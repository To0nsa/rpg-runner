import 'package:flutter_test/flutter_test.dart';

import 'package:rpg_runner/core/combat/damage.dart';
import 'package:rpg_runner/core/combat/faction.dart';
import 'package:rpg_runner/core/enemies/enemy_id.dart';
import 'package:rpg_runner/core/ecs/stores/body_store.dart';
import 'package:rpg_runner/core/ecs/stores/collider_aabb_store.dart';
import 'package:rpg_runner/core/ecs/stores/health_store.dart';
import 'package:rpg_runner/core/ecs/stores/mana_store.dart';
import 'package:rpg_runner/core/ecs/stores/stamina_store.dart';
import 'package:rpg_runner/core/ecs/spatial/broadphase_grid.dart';
import 'package:rpg_runner/core/ecs/spatial/grid_index_2d.dart';
import 'package:rpg_runner/core/ecs/systems/damage_system.dart';
import 'package:rpg_runner/core/ecs/systems/health_despawn_system.dart';
import 'package:rpg_runner/core/ecs/systems/invulnerability_system.dart';
import 'package:rpg_runner/core/ecs/systems/projectile_hit_system.dart';
import 'package:rpg_runner/core/ecs/world.dart';
import 'package:rpg_runner/core/projectiles/projectile_catalog.dart';
import 'package:rpg_runner/core/snapshots/enums.dart';
import 'package:rpg_runner/core/spells/spawn_spell_projectile.dart';
import 'package:rpg_runner/core/spells/spell_catalog.dart';
import 'package:rpg_runner/core/spells/spell_id.dart';
import 'package:rpg_runner/core/tuning/spatial_grid_tuning.dart';

import 'test_spawns.dart';
import 'package:rpg_runner/core/ecs/entity_factory.dart';

void main() {
  test('player invulnerability ignores subsequent damage in same tick', () {
    final world = EcsWorld();
    const spellCatalog = SpellCatalog();
    final lightningDamage = spellCatalog.get(SpellId.lightning).stats.damage;

    final player = EntityFactory(world).createPlayer(
      posX: 100,
      posY: 100,
      velX: 0,
      velY: 0,
      facing: Facing.right,
      grounded: true,
      body: const BodyDef(isKinematic: true, useGravity: false),
      collider: const ColliderAabbDef(halfX: 8, halfY: 8),
      health: const HealthDef(hp: 100, hpMax: 100, regenPerSecond: 0),
      mana: const ManaDef(mana: 100, manaMax: 100, regenPerSecond: 0),
      stamina: const StaminaDef(stamina: 0, staminaMax: 0, regenPerSecond: 0),
    );

    final enemy = spawnUnocoDemon(
      world,
      posX: 140,
      posY: 100,
      velX: 0,
      velY: 0,
      facing: Facing.left,
      body: const BodyDef(isKinematic: true, useGravity: false),
      collider: const ColliderAabbDef(halfX: 8, halfY: 8),
      health: const HealthDef(hp: 100, hpMax: 100, regenPerSecond: 0),
      mana: const ManaDef(mana: 0, manaMax: 0, regenPerSecond: 0),
      stamina: const StaminaDef(stamina: 0, staminaMax: 0, regenPerSecond: 0),
    );

    final projectiles = ProjectileCatalogDerived.from(
      const ProjectileCatalog(),
      tickHz: 60,
    );

    // Two enemy projectiles overlap the player in the same tick.
    spawnSpellProjectile(
      world,
      spells: spellCatalog,
      projectiles: projectiles,
      spellId: SpellId.lightning,
      faction: Faction.enemy,
      owner: enemy,
      originX: 100,
      originY: 100,
      dirX: 1,
      dirY: 0,
    );
    spawnSpellProjectile(
      world,
      spells: spellCatalog,
      projectiles: projectiles,
      spellId: SpellId.lightning,
      faction: Faction.enemy,
      owner: enemy,
      originX: 100,
      originY: 100,
      dirX: 1,
      dirY: 0,
    );

    final hit = ProjectileHitSystem();
    final damage = DamageSystem(invulnerabilityTicksOnHit: 3);

    final broadphase = BroadphaseGrid(
      index: GridIndex2D(cellSize: const SpatialGridTuning().broadphaseCellSize),
    )..rebuild(world);
    hit.step(world, damage.queue, broadphase);
    damage.step(world, currentTick: 1);

    expect(
      world.health.hp[world.health.indexOf(player)],
      closeTo(100.0 - lightningDamage, 1e-9),
    );
  });

  test('HealthDespawnSystem despawns enemies at hp=0 (player is exempt)', () {
    final world = EcsWorld();

    final player = EntityFactory(world).createPlayer(
      posX: 100,
      posY: 100,
      velX: 0,
      velY: 0,
      facing: Facing.right,
      grounded: true,
      body: const BodyDef(isKinematic: true, useGravity: false),
      collider: const ColliderAabbDef(halfX: 8, halfY: 8),
      health: const HealthDef(hp: 100, hpMax: 100, regenPerSecond: 0),
      mana: const ManaDef(mana: 0, manaMax: 0, regenPerSecond: 0),
      stamina: const StaminaDef(stamina: 0, staminaMax: 0, regenPerSecond: 0),
    );

    final enemy = spawnGroundEnemy(
      world,
      posX: 120,
      posY: 100,
      velX: 0,
      velY: 0,
      facing: Facing.left,
      body: const BodyDef(isKinematic: true, useGravity: false),
      collider: const ColliderAabbDef(halfX: 8, halfY: 8),
      health: const HealthDef(hp: 10, hpMax: 10, regenPerSecond: 0),
      mana: const ManaDef(mana: 0, manaMax: 0, regenPerSecond: 0),
      stamina: const StaminaDef(stamina: 0, staminaMax: 0, regenPerSecond: 0),
    );

    final invuln = InvulnerabilitySystem();
    final damage = DamageSystem(invulnerabilityTicksOnHit: 0);
    final death = HealthDespawnSystem();
    final killed = <EnemyId>[];

    invuln.step(world);
    damage.queue(const DamageRequest(target: 9999, amount: 999));
    damage.queue(DamageRequest(target: enemy, amount: 50));
    damage.step(world, currentTick: 1);
    death.step(world, player: player, outEnemiesKilled: killed);

    expect(world.enemy.has(enemy), isFalse);
    expect(world.health.has(enemy), isFalse);
    expect(world.health.has(player), isTrue);
    expect(killed, [EnemyId.groundEnemy]);
  });

  test('player ice bolt can kill an enemy (despawns at hp=0)', () {
    final world = EcsWorld();

    final player = EntityFactory(world).createPlayer(
      posX: 100,
      posY: 100,
      velX: 0,
      velY: 0,
      facing: Facing.right,
      grounded: true,
      body: const BodyDef(isKinematic: true, useGravity: false),
      collider: const ColliderAabbDef(halfX: 8, halfY: 8),
      health: const HealthDef(hp: 100, hpMax: 100, regenPerSecond: 0),
      mana: const ManaDef(mana: 0, manaMax: 0, regenPerSecond: 0),
      stamina: const StaminaDef(stamina: 0, staminaMax: 0, regenPerSecond: 0),
    );

    final enemy = spawnUnocoDemon(
      world,
      posX: 140,
      posY: 100,
      health: const HealthDef(hp: 10, hpMax: 10, regenPerSecond: 0),
    );

    final projectiles = ProjectileCatalogDerived.from(
      const ProjectileCatalog(),
      tickHz: 60,
    );

    // Spawn a projectile overlapping the enemy so it hits immediately.
    spawnSpellProjectile(
      world,
      spells: const SpellCatalog(),
      projectiles: projectiles,
      spellId: SpellId.iceBolt,
      faction: Faction.player,
      owner: player,
      originX: 140,
      originY: 100,
      dirX: 1,
      dirY: 0,
    );

    final hit = ProjectileHitSystem();
    final damage = DamageSystem(invulnerabilityTicksOnHit: 0);
    final despawn = HealthDespawnSystem();

    final broadphase = BroadphaseGrid(
      index: GridIndex2D(cellSize: const SpatialGridTuning().broadphaseCellSize),
    )..rebuild(world);
    hit.step(world, damage.queue, broadphase);
    damage.step(world, currentTick: 1);
    despawn.step(world, player: player);

    expect(world.enemy.has(enemy), isFalse);
    expect(world.health.has(enemy), isFalse);
  });
}
