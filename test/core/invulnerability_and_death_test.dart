import 'package:flutter_test/flutter_test.dart';

import 'package:rpg_runner/core/combat/damage.dart';
import 'package:rpg_runner/core/combat/faction.dart';
import 'package:rpg_runner/core/ecs/stores/body_store.dart';
import 'package:rpg_runner/core/ecs/stores/collider_aabb_store.dart';
import 'package:rpg_runner/core/ecs/stores/health_store.dart';
import 'package:rpg_runner/core/ecs/stores/mana_store.dart';
import 'package:rpg_runner/core/ecs/stores/stamina_store.dart';
import 'package:rpg_runner/core/ecs/spatial/broadphase_grid.dart';
import 'package:rpg_runner/core/ecs/spatial/grid_index_2d.dart';
import 'package:rpg_runner/core/ecs/systems/damage_system.dart';
import 'package:rpg_runner/core/ecs/systems/health_despawn_system.dart';
import 'package:rpg_runner/core/ecs/systems/invulnerability_system.dart';
import 'package:rpg_runner/core/ecs/systems/projectile_hit_system.dart';
import 'package:rpg_runner/core/ecs/world.dart';
import 'package:rpg_runner/core/projectiles/projectile_catalog.dart';
import 'package:rpg_runner/core/projectiles/projectile_id.dart';
import 'package:rpg_runner/core/snapshots/enums.dart';
import 'package:rpg_runner/core/abilities/ability_catalog.dart';
import 'package:rpg_runner/core/projectiles/spawn_projectile_item.dart';
import 'package:rpg_runner/core/tuning/spatial_grid_tuning.dart';

import 'test_spawns.dart';
import 'package:rpg_runner/core/ecs/entity_factory.dart';

void main() {
  test('player invulnerability ignores subsequent damage in same tick', () {
    final world = EcsWorld();
    final thunderDamage = AbilityCatalog.tryGet(
      'common.enemy_cast',
    )!.baseDamage;
    final thunderItem = const ProjectileCatalog().get(
      ProjectileId.thunderBolt,
    );

    final player = EntityFactory(world).createPlayer(
      posX: 100,
      posY: 100,
      velX: 0,
      velY: 0,
      facing: Facing.right,
      grounded: true,
      body: const BodyDef(isKinematic: true, useGravity: false),
      collider: const ColliderAabbDef(halfX: 8, halfY: 8),
      health: const HealthDef(hp: 10000, hpMax: 10000, regenPerSecond100: 0),
      mana: const ManaDef(mana: 10000, manaMax: 10000, regenPerSecond100: 0),
      stamina: const StaminaDef(
        stamina: 0,
        staminaMax: 0,
        regenPerSecond100: 0,
      ),
    );

    final enemy = spawnUnocoDemon(
      world,
      posX: 140,
      posY: 100,
      velX: 0,
      velY: 0,
      facing: Facing.left,
      body: const BodyDef(isKinematic: true, useGravity: false),
      collider: const ColliderAabbDef(halfX: 8, halfY: 8),
      health: const HealthDef(hp: 10000, hpMax: 10000, regenPerSecond100: 0),
      mana: const ManaDef(mana: 0, manaMax: 0, regenPerSecond100: 0),
      stamina: const StaminaDef(
        stamina: 0,
        staminaMax: 0,
        regenPerSecond100: 0,
      ),
    );

    // Two enemy projectiles overlap the player in the same tick.
    spawnProjectileFromCaster(
      world,
      tickHz: 60,
      projectileId: ProjectileId.thunderBolt,
      projectile: thunderItem,
      faction: Faction.enemy,
      owner: enemy,
      casterX: 100,
      casterY: 100,
      originOffset: 0,
      dirX: 1,
      dirY: 0,
      fallbackDirX: 1,
      fallbackDirY: 0,
      damage100: thunderDamage,
      critChanceBp: 0,
      damageType: thunderItem.damageType,
      procs: thunderItem.procs,
      ballistic: thunderItem.ballistic,
      gravityScale: thunderItem.gravityScale,
    );
    spawnProjectileFromCaster(
      world,
      tickHz: 60,
      projectileId: ProjectileId.thunderBolt,
      projectile: thunderItem,
      faction: Faction.enemy,
      owner: enemy,
      casterX: 100,
      casterY: 100,
      originOffset: 0,
      dirX: 1,
      dirY: 0,
      fallbackDirX: 1,
      fallbackDirY: 0,
      damage100: thunderDamage,
      critChanceBp: 0,
      damageType: thunderItem.damageType,
      procs: thunderItem.procs,
      ballistic: thunderItem.ballistic,
      gravityScale: thunderItem.gravityScale,
    );

    final hit = ProjectileHitSystem();
    final damage = DamageSystem(invulnerabilityTicksOnHit: 3, rngSeed: 1);

    final broadphase = BroadphaseGrid(
      index: GridIndex2D(
        cellSize: const SpatialGridTuning().broadphaseCellSize,
      ),
    )..rebuild(world);
    hit.step(world, broadphase, currentTick: 1);
    damage.step(world, currentTick: 1);

    expect(
      world.health.hp[world.health.indexOf(player)],
      equals(10000 - thunderDamage),
    );
  });

  test(
    'HealthDespawnSystem despawns non-enemy entities at hp=0 (player is exempt)',
    () {
      final world = EcsWorld();

      final player = EntityFactory(world).createPlayer(
        posX: 100,
        posY: 100,
        velX: 0,
        velY: 0,
        facing: Facing.right,
        grounded: true,
        body: const BodyDef(isKinematic: true, useGravity: false),
        collider: const ColliderAabbDef(halfX: 8, halfY: 8),
        health: const HealthDef(hp: 10000, hpMax: 10000, regenPerSecond100: 0),
        mana: const ManaDef(mana: 0, manaMax: 0, regenPerSecond100: 0),
        stamina: const StaminaDef(
          stamina: 0,
          staminaMax: 0,
          regenPerSecond100: 0,
        ),
      );

      final enemy = spawnGroundEnemy(
        world,
        posX: 120,
        posY: 100,
        velX: 0,
        velY: 0,
        facing: Facing.left,
        body: const BodyDef(isKinematic: true, useGravity: false),
        collider: const ColliderAabbDef(halfX: 8, halfY: 8),
        health: const HealthDef(hp: 1000, hpMax: 1000, regenPerSecond100: 0),
        mana: const ManaDef(mana: 0, manaMax: 0, regenPerSecond100: 0),
        stamina: const StaminaDef(
          stamina: 0,
          staminaMax: 0,
          regenPerSecond100: 0,
        ),
      );

      final invuln = InvulnerabilitySystem();
      final damage = DamageSystem(invulnerabilityTicksOnHit: 0, rngSeed: 1);
      final death = HealthDespawnSystem();

      invuln.step(world);
      world.damageQueue.add(
        const DamageRequest(target: 9999, amount100: 99900),
      );
      world.damageQueue.add(DamageRequest(target: enemy, amount100: 5000));
      damage.step(world, currentTick: 1);
      death.step(world, player: player);

      // Enemies with hp<=0 are handled by the enemy death state pipeline, not HealthDespawnSystem.
      // HealthDespawnSystem only despawns non-enemy entities. Enemy should still exist in enemy store.
      // The enemy death state system handles enemy removal after death animation.
      expect(world.health.has(player), isTrue);
    },
  );

  test('player heavy throw can kill an enemy (despawns at hp=0)', () {
    final world = EcsWorld();

    final player = EntityFactory(world).createPlayer(
      posX: 100,
      posY: 100,
      velX: 0,
      velY: 0,
      facing: Facing.right,
      grounded: true,
      body: const BodyDef(isKinematic: true, useGravity: false),
      collider: const ColliderAabbDef(halfX: 8, halfY: 8),
      health: const HealthDef(hp: 10000, hpMax: 10000, regenPerSecond100: 0),
      mana: const ManaDef(mana: 0, manaMax: 0, regenPerSecond100: 0),
      stamina: const StaminaDef(
        stamina: 0,
        staminaMax: 0,
        regenPerSecond100: 0,
      ),
    );

    final enemy = spawnUnocoDemon(
      world,
      posX: 140,
      posY: 100,
      health: const HealthDef(hp: 1000, hpMax: 1000, regenPerSecond100: 0),
    );

    final iceDamage = AbilityCatalog.tryGet('eloise.charged_shot')!.baseDamage;
    final iceItem = const ProjectileCatalog().get(ProjectileId.iceBolt);

    // Spawn a projectile overlapping the enemy so it hits immediately.
    spawnProjectileFromCaster(
      world,
      tickHz: 60,
      projectileId: ProjectileId.iceBolt,
      projectile: iceItem,
      faction: Faction.player,
      owner: player,
      casterX: 140,
      casterY: 100,
      originOffset: 0,
      dirX: 1,
      dirY: 0,
      fallbackDirX: 1,
      fallbackDirY: 0,
      damage100: iceDamage,
      critChanceBp: 0,
      damageType: iceItem.damageType,
      procs: iceItem.procs,
      ballistic: iceItem.ballistic,
      gravityScale: iceItem.gravityScale,
    );

    final hit = ProjectileHitSystem();
    final damage = DamageSystem(invulnerabilityTicksOnHit: 0, rngSeed: 1);
    final despawn = HealthDespawnSystem();

    final broadphase = BroadphaseGrid(
      index: GridIndex2D(
        cellSize: const SpatialGridTuning().broadphaseCellSize,
      ),
    )..rebuild(world);
    hit.step(world, broadphase, currentTick: 1);
    damage.step(world, currentTick: 1);
    despawn.step(world, player: player);

    // Enemies are handled by enemy death state pipeline, not HealthDespawnSystem.
    // After damage, enemy health should be reduced but handled by separate system.
    final hi = world.health.tryIndexOf(enemy);
    if (hi != null) {
      expect(world.health.hp[hi], lessThanOrEqualTo(0));
    }
  });
}
