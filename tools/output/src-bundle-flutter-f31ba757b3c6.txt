REPO: C:\dev\rpg_runner
COMMIT: f31ba757b3c6
DATE: 2026-02-02 12:08:02


===== FILE: lib/core/ecs/systems/projectile_system.dart =====
import 'dart:math';

import '../../players/player_tuning.dart';
import '../world.dart';

/// Moves active projectiles based on their linear velocity.
///
/// **Responsibilities**:
/// - Updates `velX` and `velY` (for use by renderers/interpolation).
/// - Explicitly integrates position: `pos += vel * dt`.
///
/// Note: Projectiles are typically simple kinematic objects that do not participate
/// in the full physics/collision resolution loop (no `Body` component), hence the
/// manual position integration here.
class ProjectileSystem {
  void step(EcsWorld world, MovementTuningDerived movement) {
    final dt = movement.dtSeconds;
    final projectiles = world.projectile;
    final transforms = world.transform;

    // Iterate efficiently over dense projectile arrays.
    final count = projectiles.denseEntities.length;
    for (var pi = 0; pi < count; pi += 1) {
      final e = projectiles.denseEntities[pi];
      
      final ti = transforms.tryIndexOf(e);
      if (ti == null) continue;

      // Physics-driven projectiles (ballistic) are moved by the main physics
      // pipeline (GravitySystem + CollisionSystem). We only keep direction
      // in sync with velocity for hitbox orientation / rendering.
      if (projectiles.usePhysics[pi]) {
        final vx = transforms.velX[ti];
        final vy = transforms.velY[ti];
        final len2 = vx * vx + vy * vy;
        if (len2 > 1e-12) {
          final invLen = 1.0 / sqrt(len2);
          projectiles.dirX[pi] = vx * invLen;
          projectiles.dirY[pi] = vy * invLen;
        }
        continue;
      }

      // Calculate velocity from direction and speed.
      final vx = projectiles.dirX[pi] * projectiles.speedUnitsPerSecond[pi];
      final vy = projectiles.dirY[pi] * projectiles.speedUnitsPerSecond[pi];

      // Update Transform velocity (useful for other systems/debug).
      transforms.velX[ti] = vx;
      transforms.velY[ti] = vy;

      // Explicit Euler integration: pos += vel * dt
      // We do this here because projectiles lack a 'Body' component for simplicity
      // and thus aren't moved by the main physics solver.
      transforms.posX[ti] += vx * dt;
      transforms.posY[ti] += vy * dt;
    }
  }
}


===== FILE: lib/core/ecs/systems/projectile_world_collision_system.dart =====
import '../entity_id.dart';
import '../world.dart';

/// Despawns physics-driven projectiles that collided with the static world.
///
/// This is intended for ballistic projectiles (arrows, thrown axes) that use
/// [BodyStore] + [CollisionSystem] for ground/wall collision. When a collision
/// occurs, the projectile is removed immediately (same tick).
class ProjectileWorldCollisionSystem {
  final List<EntityId> _toDespawn = <EntityId>[];

  void step(EcsWorld world) {
    final projectiles = world.projectile;
    if (projectiles.denseEntities.isEmpty) return;

    final collisions = world.collision;
    if (collisions.denseEntities.isEmpty) return;

    _toDespawn.clear();
    for (var pi = 0; pi < projectiles.denseEntities.length; pi += 1) {
      if (!projectiles.usePhysics[pi]) continue;

      final p = projectiles.denseEntities[pi];
      final ci = collisions.tryIndexOf(p);
      if (ci == null) continue;

      if (collisions.grounded[ci] ||
          collisions.hitCeiling[ci] ||
          collisions.hitLeft[ci] ||
          collisions.hitRight[ci]) {
        _toDespawn.add(p);
      }
    }

    for (final p in _toDespawn) {
      world.destroyEntity(p);
    }
  }
}



===== FILE: lib/core/ecs/systems/resource_regen_system.dart =====
import '../world.dart';

/// Periodically regenerates Health, Mana, and Stamina for all entities.
///
/// **Responsibilities**:
/// - Iterates over all entities with [Health], [Mana], or [Stamina].
/// - Applies regeneration rates (`regenPerSecond`) scaled by `dtSeconds`.
/// - Clamps values to `[0, Max]`.
///
/// **Performance**:
/// - Uses direct dense array iteration (Structure of Arrays) for cache efficiency.
/// - Skips full resources and zero-regen entities early.
class ResourceRegenSystem {
  ResourceRegenSystem({required int tickHz}) : _tickHz = tickHz;

  final int _tickHz;

  void step(EcsWorld world) {
    _regenHealth(world);
    _regenMana(world);
    _regenStamina(world);
  }

  void _regenHealth(EcsWorld world) {
    final store = world.health;
    final deathState = world.deathState;
    final count = store.denseEntities.length;
    // Iterate contiguous arrays directly (SoA pattern).
    for (var i = 0; i < count; i += 1) {
      if (deathState.has(store.denseEntities[i])) continue;
      final max = store.hpMax[i];
      if (max <= 0) continue;
      
      final current = store.hp[i];
      if (current >= max) continue;
      
      final regen = store.regenPerSecond100[i];
      if (regen <= 0) continue;

      final accum = store.regenAccumulator[i] + regen;
      final delta = accum ~/ _tickHz;
      if (delta > 0) {
        final next = current + delta;
        store.hp[i] = next > max ? max : next;
      }
      store.regenAccumulator[i] = accum - (delta * _tickHz);
    }
  }

  void _regenMana(EcsWorld world) {
    final store = world.mana;
    final deathState = world.deathState;
    final count = store.denseEntities.length;
    for (var i = 0; i < count; i += 1) {
      if (deathState.has(store.denseEntities[i])) continue;
      final max = store.manaMax[i];
      if (max <= 0) continue;
      
      final current = store.mana[i];
      if (current >= max) continue;
      
      final regen = store.regenPerSecond100[i];
      if (regen <= 0) continue;

      final accum = store.regenAccumulator[i] + regen;
      final delta = accum ~/ _tickHz;
      if (delta > 0) {
        final next = current + delta;
        store.mana[i] = next > max ? max : next;
      }
      store.regenAccumulator[i] = accum - (delta * _tickHz);
    }
  }

  void _regenStamina(EcsWorld world) {
    final store = world.stamina;
    final deathState = world.deathState;
    final count = store.denseEntities.length;
    for (var i = 0; i < count; i += 1) {
      if (deathState.has(store.denseEntities[i])) continue;
      final max = store.staminaMax[i];
      if (max <= 0) continue;
      
      final current = store.stamina[i];
      if (current >= max) continue;
      
      final regen = store.regenPerSecond100[i];
      if (regen <= 0) continue;

      final accum = store.regenAccumulator[i] + regen;
      final delta = accum ~/ _tickHz;
      if (delta > 0) {
        final next = current + delta;
        store.stamina[i] = next > max ? max : next;
      }
      store.regenAccumulator[i] = accum - (delta * _tickHz);
    }
  }
}


===== FILE: lib/core/ecs/systems/restoration_item_system.dart =====
import '../entity_id.dart';
import '../world.dart';
import '../stores/restoration_item_store.dart';
import '../../tuning/restoration_item_tuning.dart';
import '../../util/fixed_math.dart';

/// Handles the lifecycle and collision of restoration pickups (Health/Mana/Stamina potions).
///
/// **Responsibilities**:
/// - Despawns items that fall too far behind the camera.
/// - Checks for collision with the Player.
/// - Applies restoration effects and despawns on pickup.
class RestorationItemSystem {
  final List<EntityId> _toDespawn = <EntityId>[];

  /// Executes the system logic for a single frame.
  ///
  /// - [player]: The valid [EntityId] of the local player character.
  /// - [cameraLeft]: The X coordinate of the camera's left edge (used for culling).
  /// - [tuning]: Configuration values for pickup ranges and restore amounts.
  void step(
    EcsWorld world, {
    required EntityId player,
    required double cameraLeft,
    required RestorationItemTuning tuning,
  }) {
    final items = world.restorationItem;
    // Early exit if no items exist to process.
    if (items.denseEntities.isEmpty) return;
    
    _toDespawn.clear();
    final despawnLimit = cameraLeft - tuning.despawnBehindCameraMargin;

    // -- Resolve Player AABB (Optimization) --
    // We cache the player's world-space bounds once per frame.
    final transforms = world.transform;
    final colliders = world.colliderAabb;

    final pTi = transforms.tryIndexOf(player);
    final pCi = colliders.tryIndexOf(player);
    
    // Bounds: Min/Max X/Y
    double pMinX = 0, pMaxX = 0, pMinY = 0, pMaxY = 0;
    bool playerActive = false;

    if (pTi != null && pCi != null) {
      playerActive = true;
      final cx = transforms.posX[pTi] + colliders.offsetX[pCi];
      final cy = transforms.posY[pTi] + colliders.offsetY[pCi];
      final hx = colliders.halfX[pCi];
      final hy = colliders.halfY[pCi];
      pMinX = cx - hx;
      pMaxX = cx + hx;
      pMinY = cy - hy;
      pMaxY = cy + hy;
    }

    // -- Iterate Items --
    final count = items.denseEntities.length;
    for (var ii = 0; ii < count; ii += 1) {
      final e = items.denseEntities[ii];
      
      final ti = transforms.tryIndexOf(e);
      // Skip items that are missing spatial components (malformed entities).
      if (ti == null) continue;
      
      final ci = colliders.tryIndexOf(e);
      if (ci == null) continue;

      final cx = transforms.posX[ti] + colliders.offsetX[ci];
      
      // 1. Despawn Logic (Garbage Collection)
      if (cx < despawnLimit) {
        _toDespawn.add(e);
        continue;
      }

      // 2. Collision Check (Pickup)
      if (playerActive) {
        final cy = transforms.posY[ti] + colliders.offsetY[ci];
        final hx = colliders.halfX[ci];
        final hy = colliders.halfY[ci];

        // AABB Overlap Logic:
        final overlaps = (cx - hx) < pMaxX && 
                         (cx + hx) > pMinX && 
                         (cy - hy) < pMaxY && 
                         (cy + hy) > pMinY;

        if (overlaps) {
          _applyRestore(
            world,
            player: player,
            stat: items.stat[ii],
            percentBp: tuning.restorePercentBp,
          );
          _toDespawn.add(e);
        }
      }
    }

    // Process all despawns in batch at the end of the frame.
    for (final e in _toDespawn) {
      world.destroyEntity(e);
    }
  }

  /// RESTORES a specific stat on the target [player].
  ///
  /// - [percent]: Percentage of MAX value to restore (0.0 to 1.0).
  /// - Scales based on the player's Max HP/Mana/Stamina.
  /// - Clamps to Max value (prevents overhealing).
  void _applyRestore(
    EcsWorld world, {
    required EntityId player,
    required RestorationStat stat,
    required int percentBp,
  }) {
    // Note: We use min/max checks to ensure we don't overheal or divide by zero.
    switch (stat) {
      case RestorationStat.health:
        final index = world.health.tryIndexOf(player);
        if (index != null) {
          final max = world.health.hpMax[index];
          if (max > 0) {
            final restore = (max * percentBp) ~/ bpScale;
            final next = world.health.hp[index] + restore;
            world.health.hp[index] = next > max ? max : next;
          }
        }
      case RestorationStat.mana:
        final index = world.mana.tryIndexOf(player);
        if (index != null) {
          final max = world.mana.manaMax[index];
          if (max > 0) {
            final restore = (max * percentBp) ~/ bpScale;
            final next = world.mana.mana[index] + restore;
            world.mana.mana[index] = next > max ? max : next;
          }
        }
      case RestorationStat.stamina:
        final index = world.stamina.tryIndexOf(player);
        if (index != null) {
          final max = world.stamina.staminaMax[index];
          if (max > 0) {
            final restore = (max * percentBp) ~/ bpScale;
            final next = world.stamina.stamina[index] + restore;
            world.stamina.stamina[index] =
                next > max ? max : next;
          }
        }
    }
  }
}


===== FILE: lib/core/ecs/systems/self_ability_system.dart =====
import '../stores/self_intent_store.dart';
import '../world.dart';

/// Executes self abilities (parry, block, buffs) based on committed intents.
///
/// **Execution Only**:
/// - Reads committed intents (`tick == currentTick`).
/// - Applies effects (e.g., healing, buffs).
/// - Does **not** deduct resources or start cooldowns.
class SelfAbilitySystem {
  void step(EcsWorld world, {required int currentTick}) {
    final intents = world.selfIntent;
    if (intents.denseEntities.isEmpty) return;

    final count = intents.denseEntities.length;
    for (var ii = 0; ii < count; ii += 1) {
      final executeTick = intents.tick[ii];

      if (executeTick != currentTick) continue;

      // Invalidate now to ensure no double-execution in same tick
      _invalidateIntent(intents, ii);
    }
  }

  void _invalidateIntent(SelfIntentStore intents, int index) {
    intents.tick[index] = -1;
    intents.commitTick[index] = -1;
  }
}


===== FILE: lib/core/ecs/systems/status_system.dart =====
import '../../combat/damage.dart';
import '../../combat/damage_type.dart';
import '../../combat/status/status.dart';
import '../../events/game_event.dart';
import '../../util/tick_math.dart';
import '../../util/fixed_math.dart';
import '../entity_id.dart';
import '../stores/status/bleed_store.dart';
import '../stores/status/burn_store.dart';
import '../stores/status/slow_store.dart';
import '../../combat/control_lock.dart';
import '../world.dart';

/// Applies status effects and ticks active statuses.
class StatusSystem {
  StatusSystem({
    required int tickHz,
    StatusProfileCatalog profiles = const StatusProfileCatalog(),
  }) : _tickHz = tickHz,
       _profiles = profiles;

  final int _tickHz;
  final StatusProfileCatalog _profiles;

  final List<StatusRequest> _pending = <StatusRequest>[];
  final List<EntityId> _removeScratch = <EntityId>[];

  /// Current tick, set at the start of applyQueued.
  int _currentTick = 0;

  /// Queues a status profile to apply.
  void queue(StatusRequest request) {
    if (request.profileId == StatusProfileId.none) return;
    _pending.add(request);
  }

  /// Ticks existing statuses and queues DoT damage.
  void tickExisting(
    EcsWorld world,
  ) {
    _tickBurn(world);
    _tickBleed(world);
    _tickSlow(world);
  }

  /// Applies queued statuses and refreshes derived modifiers.
  void applyQueued(EcsWorld world, {required int currentTick}) {
    _currentTick = currentTick;
    if (_pending.isNotEmpty) {
      _applyPending(world);
      _pending.clear();
    }
    _refreshMoveSpeed(world);
  }

  void _tickBurn(
    EcsWorld world,
  ) {
    final burn = world.burn;
    if (burn.denseEntities.isEmpty) return;

    _removeScratch.clear();
    for (var i = 0; i < burn.denseEntities.length; i += 1) {
      final target = burn.denseEntities[i];
      if (world.deathState.has(target)) {
        _removeScratch.add(target);
        continue;
      }
      burn.ticksLeft[i] -= 1;
      if (burn.ticksLeft[i] <= 0) {
        _removeScratch.add(target);
        continue;
      }

      burn.periodTicksLeft[i] -= 1;
      if (burn.periodTicksLeft[i] <= 0) {
        burn.periodTicksLeft[i] = burn.periodTicks[i];
        final amount100 = (burn.dps100[i] * burn.periodTicks[i]) ~/ _tickHz;
        world.damageQueue.add(
          DamageRequest(
            target: target,
            amount100: amount100,
            damageType: DamageType.fire,
            sourceKind: DeathSourceKind.statusEffect,
          ),
        );
      }
    }
    for (final target in _removeScratch) {
      burn.removeEntity(target);
    }
  }

  void _tickBleed(
    EcsWorld world,
  ) {
    final bleed = world.bleed;
    if (bleed.denseEntities.isEmpty) return;

    _removeScratch.clear();
    for (var i = 0; i < bleed.denseEntities.length; i += 1) {
      final target = bleed.denseEntities[i];
      if (world.deathState.has(target)) {
        _removeScratch.add(target);
        continue;
      }
      bleed.ticksLeft[i] -= 1;
      if (bleed.ticksLeft[i] <= 0) {
        _removeScratch.add(target);
        continue;
      }

      bleed.periodTicksLeft[i] -= 1;
      if (bleed.periodTicksLeft[i] <= 0) {
        bleed.periodTicksLeft[i] = bleed.periodTicks[i];
        final amount100 = (bleed.dps100[i] * bleed.periodTicks[i]) ~/ _tickHz;
        world.damageQueue.add(
          DamageRequest(
            target: target,
            amount100: amount100,
            damageType: DamageType.bleed,
            sourceKind: DeathSourceKind.statusEffect,
          ),
        );
      }
    }
    for (final target in _removeScratch) {
      bleed.removeEntity(target);
    }
  }

  void _tickSlow(EcsWorld world) {
    final slow = world.slow;
    if (slow.denseEntities.isEmpty) return;

    _removeScratch.clear();
    for (var i = 0; i < slow.denseEntities.length; i += 1) {
      final target = slow.denseEntities[i];
      if (world.deathState.has(target)) {
        _removeScratch.add(target);
        continue;
      }
      slow.ticksLeft[i] -= 1;
      if (slow.ticksLeft[i] <= 0) {
        _removeScratch.add(target);
      }
    }
    for (final target in _removeScratch) {
      slow.removeEntity(target);
    }
  }

  void _applyPending(EcsWorld world) {
    final resistance = world.damageResistance;
    final immunity = world.statusImmunity;
    final invuln = world.invulnerability;

    for (final req in _pending) {
      if (world.deathState.has(req.target)) continue;
      if (!world.health.has(req.target)) continue;

      final ii = invuln.tryIndexOf(req.target);
      if (ii != null && invuln.ticksLeft[ii] > 0) continue;

      final profile = _profiles.get(req.profileId);
      if (profile.applications.isEmpty) continue;

      for (final app in profile.applications) {
        if (immunity.isImmune(req.target, app.type)) continue;

        var magnitude = app.magnitude;
        if (app.scaleByDamageType) {
          final modBp = resistance.modBpForEntity(req.target, req.damageType);
          if (modBp > 0) {
            magnitude = applyBp(magnitude, modBp);
          }
        }
        if (magnitude <= 0) continue;

        switch (app.type) {
          case StatusEffectType.slow:
            _applySlow(world, req.target, magnitude, app.durationSeconds);
          case StatusEffectType.burn:
            _applyDot(
              world,
              target: req.target,
              magnitude: magnitude,
              durationSeconds: app.durationSeconds,
              periodSeconds: app.periodSeconds,
              useBurn: true,
            );
          case StatusEffectType.bleed:
            _applyDot(
              world,
              target: req.target,
              magnitude: magnitude,
              durationSeconds: app.durationSeconds,
              periodSeconds: app.periodSeconds,
              useBurn: false,
            );
          case StatusEffectType.stun:
            _applyStun(world, req.target, magnitude, app.durationSeconds);
        }
      }
    }
  }

  void _applyStun(
    EcsWorld world,
    EntityId target,
    int magnitude,
    double durationSeconds,
  ) {
    // Stun requires statModifier for moveSpeedMul (and arguably any status effect target)
    if (!world.statModifier.has(target)) return;
    final durationTicks = ticksFromSecondsCeil(durationSeconds, _tickHz);
    if (durationTicks <= 0) return;

    // Add stun lock via ControlLockStore
    world.controlLock.addLock(target, LockFlag.stun, durationTicks, _currentTick);

    // Hard cancel active intents to prevent ghost execution
    if (world.meleeIntent.has(target)) {
      world.meleeIntent.tick[world.meleeIntent.indexOf(target)] = -1;
    }
    if (world.projectileIntent.has(target)) {
      world.projectileIntent.tick[world.projectileIntent.indexOf(target)] = -1;
    }
    if (world.selfIntent.has(target)) {
      world.selfIntent.tick[world.selfIntent.indexOf(target)] = -1;
    }
    // Cancel dash if active
    final mi = world.movement.tryIndexOf(target);
    if (mi != null && world.movement.dashTicksLeft[mi] > 0) {
      world.movement.dashTicksLeft[mi] = 0;
    }
  }

  void _applySlow(
    EcsWorld world,
    EntityId target,
    int magnitude,
    double durationSeconds,
  ) {
    if (!world.statModifier.has(target)) return;
    final ticksLeft = ticksFromSecondsCeil(durationSeconds, _tickHz);
    if (ticksLeft <= 0) return;

    final slow = world.slow;
    final clamped = clampInt(magnitude, 0, 9000);
    final index = slow.tryIndexOf(target);
    if (index == null) {
      slow.add(
        target,
        SlowDef(ticksLeft: ticksLeft, magnitude: clamped),
      );
    } else {
      final currentMagnitude = slow.magnitude[index];
      if (clamped > currentMagnitude) {
        slow.magnitude[index] = clamped;
        slow.ticksLeft[index] = ticksLeft;
      } else if (clamped == currentMagnitude) {
        if (ticksLeft > slow.ticksLeft[index]) {
          slow.ticksLeft[index] = ticksLeft;
        }
      }
    }
  }

  void _applyDot(
    EcsWorld world, {
    required EntityId target,
    required int magnitude,
    required double durationSeconds,
    required double periodSeconds,
    required bool useBurn,
  }) {
    final ticksLeft = ticksFromSecondsCeil(durationSeconds, _tickHz);
    if (ticksLeft <= 0) return;

    final periodTicks = periodSeconds <= 0.0
        ? 1
        : ticksFromSecondsCeil(periodSeconds, _tickHz);
    final dps100 = magnitude;

    if (useBurn) {
      final burn = world.burn;
      final index = burn.tryIndexOf(target);
      if (index == null) {
        burn.add(
          target,
          BurnDef(
            ticksLeft: ticksLeft,
            periodTicks: periodTicks,
            dps100: dps100,
          ),
        );
      } else {
        final currentDps = burn.dps100[index];
        if (dps100 > currentDps) {
          burn.dps100[index] = dps100;
          burn.periodTicks[index] = periodTicks;
          burn.periodTicksLeft[index] = periodTicks;
          burn.ticksLeft[index] = ticksLeft;
        } else if (dps100 == currentDps) {
          if (ticksLeft > burn.ticksLeft[index]) {
            burn.ticksLeft[index] = ticksLeft;
          }
        }
      }
      return;
    }

    final bleed = world.bleed;
    final index = bleed.tryIndexOf(target);
    if (index == null) {
      bleed.add(
        target,
        BleedDef(
          ticksLeft: ticksLeft,
          periodTicks: periodTicks,
          dps100: dps100,
        ),
      );
    } else {
      final currentDps = bleed.dps100[index];
      if (dps100 > currentDps) {
        bleed.dps100[index] = dps100;
        bleed.periodTicks[index] = periodTicks;
        bleed.periodTicksLeft[index] = periodTicks;
        bleed.ticksLeft[index] = ticksLeft;
      } else if (dps100 == currentDps) {
        if (ticksLeft > bleed.ticksLeft[index]) {
          bleed.ticksLeft[index] = ticksLeft;
        }
      }
    }
  }

  void _refreshMoveSpeed(EcsWorld world) {
    final mods = world.statModifier;
    if (mods.denseEntities.isEmpty) return;

    for (var i = 0; i < mods.denseEntities.length; i += 1) {
      mods.moveSpeedMul[i] = 1.0;
    }

    final slow = world.slow;
    if (slow.denseEntities.isEmpty) return;

    for (var i = 0; i < slow.denseEntities.length; i += 1) {
      final target = slow.denseEntities[i];
      final mi = mods.tryIndexOf(target);
      if (mi == null) continue;
      final slowBp = slow.magnitude[i];
      final multiplierBp = clampInt(bpScale - slowBp, 1000, bpScale);
      mods.moveSpeedMul[mi] = multiplierBp / bpScale;
    }
  }
}


===== FILE: lib/core/ecs/world.dart =====
import 'entity_id.dart';
import 'sparse_set.dart';
import 'stores/body_store.dart';
import 'stores/collider_aabb_store.dart';
import 'stores/collision_state_store.dart';
import 'stores/cooldown_store.dart';
import 'stores/projectile_intent_store.dart';
import 'stores/self_intent_store.dart';
import 'stores/combat/creature_tag_store.dart';
import 'stores/combat/damage_resistance_store.dart';
import 'stores/combat/equipped_loadout_store.dart';
import 'stores/combat/stat_modifier_store.dart';
import 'stores/combat/status_immunity_store.dart';
import 'stores/collectible_store.dart';
import 'stores/player/gravity_control_store.dart';
import 'stores/enemies/flying_enemy_steering_store.dart';
import 'stores/faction_store.dart';
import 'stores/anim/anim_state_store.dart';
import 'stores/active_ability_state_store.dart';
import 'stores/ability_input_buffer_store.dart';
import 'stores/enemies/enemy_store.dart';
import 'stores/enemies/ground_enemy_chase_offset_store.dart';
import 'stores/enemies/engagement_intent_store.dart';
import 'stores/enemies/melee_engagement_store.dart';
import 'stores/enemies/nav_intent_store.dart';
import 'stores/health_store.dart';
import 'stores/hit_once_store.dart';
import 'stores/hitbox_store.dart';
import 'stores/death_state_store.dart';
import 'stores/player/invulnerability_store.dart';
import 'stores/player/last_damage_store.dart';
import 'stores/lifetime_store.dart';
import 'stores/mana_store.dart';
import 'stores/melee_intent_store.dart';
import 'stores/mobility_intent_store.dart';
import 'stores/player/movement_store.dart';
import 'stores/player/player_input_store.dart';
import 'stores/projectile_store.dart';
import 'stores/restoration_item_store.dart';
import 'stores/status/bleed_store.dart';
import 'stores/status/burn_store.dart';
import 'stores/status/slow_store.dart';
import 'stores/control_lock_store.dart';
import 'stores/damage_queue_store.dart';
import 'stores/parry_consume_store.dart';
import 'stores/riposte_store.dart';
import 'stores/projectile_item_origin_store.dart';
import 'stores/stamina_store.dart';
import 'stores/enemies/surface_nav_state_store.dart';
import 'stores/transform_store.dart';

/// Minimal Entity Component System (ECS) world container.
///
/// The [EcsWorld] is the central hub of the ECS architecture. It manages the
/// creation and destruction of entities ([EntityId]) and acts as a registry
/// for all Component Stores.
///
/// Design philosophy:
/// - **Structure-of-Arrays (SoA):** Data is stored in parallel arrays within each
///   [SparseSet] component store, rather than as objects on the entity.
/// - **Composition over Inheritance:** Game objects are defined by the collection
///   of components they possess.
/// - **Pooling:** Entity IDs are recycled to keep memory usage compact and predictable.
///
/// To add functionality to the game, Systems (logic) query this World for Entities
/// with specific components and operate on them.
class EcsWorld {
  /// Creates a new ECS World with an optional [seed] for deterministic behavior.
  EcsWorld({int seed = 0}) : seed = seed;

  /// Seed used for deterministic RNG in the core, passed to components that need it.
  final int seed;

  /// Counter for generating new unique Entity IDs.
  EntityId _nextEntityId = 1;

  /// Pool of recycled Entity IDs available for reuse.
  final List<EntityId> _freeIds = <EntityId>[];

  /// Fast lookup set for recycled IDs to prevent double-freeing.
  final Set<EntityId> _freeIdsSet = <EntityId>{};

  /// Registry of all registered component stores.
  final List<SparseSet> _stores = <SparseSet>[];

  /// Helper to register a store with the world so it receives lifecycle events (like entity destruction).
  T _register<T extends SparseSet>(T store) {
    _stores.add(store);
    return store;
  }

  /// World-level damage request queue (shared across systems).
  final DamageQueueStore damageQueue = DamageQueueStore();

  /// Parry consumption tracker (per activation).
  final ParryConsumeStore parryConsume = ParryConsumeStore();

  // --- Component Stores ---
  // Each store manages a specific type of data for entities.

  /// Stores position (x, y) and velocity (vx, vy).
  late final TransformStore transform = _register(TransformStore());

  /// Helper components for handling user input events.
  late final PlayerInputStore playerInput = _register(PlayerInputStore());

  /// Buffered ability input for recovery-window handling.
  late final AbilityInputBufferStore abilityInputBuffer = _register(
    AbilityInputBufferStore(),
  );

  /// Logic and state for movement, including facing direction.
  late final MovementStore movement = _register(MovementStore());

  /// Physics properties like mass, friction, and restitution.
  late final BodyStore body = _register(BodyStore());

  /// Axis-Aligned Bounding Box (AABB) for collision detection.
  late final ColliderAabbStore colliderAabb = _register(ColliderAabbStore());

  /// Runtime state of collisions (e.g., is grounded, wall contact).
  late final CollisionStateStore collision = _register(CollisionStateStore());

  /// Generic cooldown timer for abilities or actions.
  late final CooldownStore cooldown = _register(CooldownStore());

  /// Tracks the player's intent to fire a projectile item (spell or throw).
  late final ProjectileIntentStore projectileIntent = _register(
    ProjectileIntentStore(),
  );

  /// Tracks the intent to use a self ability (parry, block, buff).
  late final SelfIntentStore selfIntent = _register(SelfIntentStore());

  /// Creature classification tags (humanoid, demon, etc.).
  late final CreatureTagStore creatureTag = _register(CreatureTagStore());

  /// Marks an entity as a collectible item (e.g., coin, power-up).
  late final CollectibleStore collectible = _register(CollectibleStore());

  /// Defines an item that restores stats (health/mana) when collected.
  late final RestorationItemStore restorationItem = _register(
    RestorationItemStore(),
  );

  /// Allows an entity to control or defy gravity.
  late final GravityControlStore gravityControl = _register(
    GravityControlStore(),
  );

  /// Defines which faction (Player, Enemy, Neutral) an entity belongs to.
  late final FactionStore faction = _register(FactionStore());

  /// Manages Health Points (HP) and max HP.
  late final HealthStore health = _register(HealthStore());

  /// Damage resistance/vulnerability modifiers.
  late final DamageResistanceStore damageResistance = _register(
    DamageResistanceStore(),
  );

  /// Grants temporary invulnerability (i-frames).
  late final InvulnerabilityStore invulnerability = _register(
    InvulnerabilityStore(),
  );

  /// Records the last entity/source that dealt damage to this entity.
  late final LastDamageStore lastDamage = _register(LastDamageStore());

  /// Tracks per-entity death lifecycle state.
  late final DeathStateStore deathState = _register(DeathStateStore());

  /// Status immunities (burn, slow, bleed).
  late final StatusImmunityStore statusImmunity = _register(
    StatusImmunityStore(),
  );

  /// Manages Mana Points (MP) and max MP.
  late final ManaStore mana = _register(ManaStore());

  /// Tracks the player's intent to perform a melee strike.
  late final MeleeIntentStore meleeIntent = _register(MeleeIntentStore());

  /// Tracks the player's intent to perform a mobility action (dash/roll).
  late final MobilityIntentStore mobilityIntent = _register(
    MobilityIntentStore(),
  );


  /// Unified loadout store (single source of truth for all equipment).
  late final EquippedLoadoutStore equippedLoadout = _register(
    EquippedLoadoutStore(),
  );

  /// Derived runtime stat modifiers (e.g., slows).
  late final StatModifierStore statModifier = _register(StatModifierStore());

  /// Manages Stamina Points (SP) and max SP.
  late final StaminaStore stamina = _register(StaminaStore());

  /// One-shot bonus granted by parry, consumed on the next landed melee hit.
  late final RiposteStore riposte = _register(RiposteStore());

  /// Marks an entity as a projectile and defines its properties.
  late final ProjectileStore projectile = _register(ProjectileStore());

  /// Defines an area that deals damage or effects on contact.
  late final HitboxStore hitbox = _register(HitboxStore());

  /// Ensures a hitbox only affects a target once per interaction.
  late final HitOnceStore hitOnce = _register(HitOnceStore());

  /// Despawns entities after a set duration.
  late final LifetimeStore lifetime = _register(LifetimeStore());

  /// Active burn DoT effects.
  late final BurnStore burn = _register(BurnStore());

  /// Active bleed DoT effects.
  late final BleedStore bleed = _register(BleedStore());

  /// Active slow effects.
  late final SlowStore slow = _register(SlowStore());

  /// Control locks for ability/action gating (stun, movement locks, etc.).
  late final ControlLockStore controlLock = _register(ControlLockStore());

  /// Links a projectile back to its originating projectile item.
  late final ProjectileItemOriginStore projectileItemOrigin = _register(
    ProjectileItemOriginStore(),
  );

  /// State for ground enemies navigating terrain (jumping gaps/walls).
  late final SurfaceNavStateStore surfaceNav = _register(
    SurfaceNavStateStore(),
  );

  /// Identifies an entity as a specific type of enemy.
  late final EnemyStore enemy = _register(EnemyStore());

  /// Per-entity animation state computed by [AnimSystem].
  late final AnimStateStore animState = _register(AnimStateStore());

  /// Tracks the currently active ability for animation purposes.
  late final ActiveAbilityStateStore activeAbility = _register(
    ActiveAbilityStateStore(),
  );

  /// Steering behaviors for flying enemies.
  late final FlyingEnemySteeringStore flyingEnemySteering = _register(
    FlyingEnemySteeringStore(),
  );

  /// AI state for ground enemies to create offset chasing behaviors.
  late final GroundEnemyChaseOffsetStore groundEnemyChaseOffset = _register(
    GroundEnemyChaseOffsetStore(),
  );

  /// Navigation intent output for ground enemies.
  late final NavIntentStore navIntent = _register(NavIntentStore());

  /// Engagement intent output for melee enemies.
  late final EngagementIntentStore engagementIntent = _register(
    EngagementIntentStore(),
  );

  /// Engagement state for melee enemies (approach/engage/strike/recover).
  late final MeleeEngagementStore meleeEngagement = _register(
    MeleeEngagementStore(),
  );

  /// Allocates a new [EntityId].
  ///
  /// Prefers reusing ID from the free pool if available; otherwise increments the counter.
  EntityId createEntity() {
    if (_freeIds.isNotEmpty) {
      final id = _freeIds.removeLast();
      _freeIdsSet.remove(id);
      return id;
    }
    final id = _nextEntityId;
    _nextEntityId += 1;
    return id;
  }

  /// Destroys [entity], removing it from all component stores.
  ///
  /// The ID is returned to the free pool for future reuse.
  /// Does nothing if the entity is already destroyed/free.
  void destroyEntity(EntityId entity) {
    if (_freeIdsSet.contains(entity)) {
      return;
    }
    for (final store in _stores) {
      store.removeEntity(entity);
    }
    parryConsume.removeEntity(entity);
    _freeIds.add(entity);
    _freeIdsSet.add(entity);
  }
}


===== FILE: lib/core/enemies/death_behavior.dart =====
/// Enemy death behavior configuration (data-driven).
library;

/// Determines how an enemy transitions from "killed" to final despawn.
enum DeathBehavior {
  /// Start the death animation immediately on kill.
  instant,

  /// If killed mid-air, fall until grounded before starting the death animation.
  groundImpactThenDeath,
}

/// Runtime death phase for enemies that are waiting to despawn.
enum DeathPhase {
  none,
  fallingUntilGround,
  deathAnim,
}



===== FILE: lib/core/enemies/enemy_catalog.dart =====
import '../ecs/stores/body_store.dart';
import '../ecs/stores/collider_aabb_store.dart';
import '../ecs/stores/combat/creature_tag_store.dart';
import '../ecs/stores/combat/damage_resistance_store.dart';
import '../ecs/stores/combat/status_immunity_store.dart';
import '../ecs/stores/health_store.dart';
import '../ecs/stores/mana_store.dart';
import '../ecs/stores/stamina_store.dart';
import '../combat/creature_tag.dart';
import '../anim/anim_resolver.dart';
import '../contracts/render_anim_set_definition.dart';
import 'death_behavior.dart';
import '../projectiles/projectile_item_id.dart';
import '../snapshots/enums.dart';
import '../util/vec2.dart';
import 'enemy_id.dart';

// -----------------------------------------------------------------------------
// Unoco Demon render animation strip definitions (authoring-time)
// -----------------------------------------------------------------------------

const int _unocoAnimFrameWidth = 81;
const int _unocoAnimFrameHeight = 71;

const int _unocoAnimIdleFrames = 4;
const double _unocoAnimIdleStepSeconds = 0.12;

const int _unocoAnimStunFrames = 4;
const double _unocoAnimStunStepSeconds = 0.12;

const int _unocoAnimMoveFrames = 4;
const double _unocoAnimMoveStepSeconds = 0.12;

const int _unocoAnimHitFrames = 4;
const double _unocoAnimHitStepSeconds = 0.10;

const int _unocoAnimDeathFrames = 7;
const double _unocoAnimDeathStepSeconds = 0.12;

const double _unocoHitAnimSeconds =
    _unocoAnimHitFrames * _unocoAnimHitStepSeconds;
const double _unocoDeathAnimSeconds =
    _unocoAnimDeathFrames * _unocoAnimDeathStepSeconds;

const Map<AnimKey, int> _unocoAnimFrameCountsByKey = <AnimKey, int>{
  AnimKey.idle: _unocoAnimIdleFrames,
  AnimKey.stun: _unocoAnimStunFrames,
  AnimKey.run: _unocoAnimMoveFrames,
  AnimKey.hit: _unocoAnimHitFrames,
  AnimKey.death: _unocoAnimDeathFrames,
};

const Map<AnimKey, double> _unocoAnimStepTimeSecondsByKey = <AnimKey, double>{
  AnimKey.idle: _unocoAnimIdleStepSeconds,
  AnimKey.stun: _unocoAnimStunStepSeconds,
  AnimKey.run: _unocoAnimMoveStepSeconds,
  AnimKey.hit: _unocoAnimHitStepSeconds,
  AnimKey.death: _unocoAnimDeathStepSeconds,
};

const Map<AnimKey, String> _unocoAnimSourcesByKey = <AnimKey, String>{
  AnimKey.idle: 'entities/enemies/unoco/flying.png',
  AnimKey.stun: 'entities/enemies/unoco/stun.png',
  AnimKey.run: 'entities/enemies/unoco/flying.png',
  AnimKey.hit: 'entities/enemies/unoco/hit.png',
  AnimKey.death: 'entities/enemies/unoco/death.png',
};

const RenderAnimSetDefinition _unocoRenderAnim = RenderAnimSetDefinition(
  frameWidth: _unocoAnimFrameWidth,
  frameHeight: _unocoAnimFrameHeight,
  sourcesByKey: _unocoAnimSourcesByKey,
  frameCountsByKey: _unocoAnimFrameCountsByKey,
  stepTimeSecondsByKey: _unocoAnimStepTimeSecondsByKey,
);

const AnimProfile _unocoAnimProfile = AnimProfile(
  minMoveSpeed: 1.0,
  runSpeedThresholdX: 0.0,
  supportsWalk: false,
  supportsJumpFall: false,
  supportsStun: true,
  strikeAnimKey: AnimKey.idle,
);

// -----------------------------------------------------------------------------
// grojib (ground enemy) render animation sheet definitions (authoring-time)
// -----------------------------------------------------------------------------

const int _grojibAnimFrameWidth = 108;
const int _grojibAnimFrameHeight = 59;

const int _grojibAnimIdleFrames = 8;
const double _grojibAnimIdleStepSeconds = 0.14;

const int _grojibAnimStunFrames = 8;
const double _grojibAnimStunStepSeconds = 0.14;

const int _grojibAnimMoveFrames = 8;
const double _grojibAnimMoveStepSeconds = 0.08;

const int _grojibAnimWalkFrames = _grojibAnimMoveFrames;
const double _grojibAnimWalkStepSeconds = _grojibAnimMoveStepSeconds;

const int _grojibAnimHitFrames = 3;
const double _grojibAnimHitStepSeconds = 0.10;

const int _grojibAnimDeathFrames = 12;
const double _grojibAnimDeathStepSeconds = 0.12;

// The authored sheet has 20 columns on the strike row:
// - frames 1..8  = Strike
// - frames 9..20 = Strike2
// Core only exposes AnimKey.strike, so we treat the full row as one animation.
const int _grojibAnimStrikeFrames = 8;
const double _grojibAnimStrikeStepSeconds = 0.06;

const int _grojibAnimJumpFrames = 3;
const double _grojibAnimJumpStepSeconds = 0.10;

const int _grojibAnimFallFrames = 3;
const double _grojibAnimFallStepSeconds = 0.10;
const double _grojibHitAnimSeconds =
    _grojibAnimHitFrames * _grojibAnimHitStepSeconds;
const double _grojibDeathAnimSeconds =
    _grojibAnimDeathFrames * _grojibAnimDeathStepSeconds;

const Map<AnimKey, int> _grojibAnimFrameCountsByKey = <AnimKey, int>{
  AnimKey.idle: _grojibAnimIdleFrames,
  AnimKey.stun: _grojibAnimStunFrames,
  AnimKey.run: _grojibAnimMoveFrames,
  AnimKey.walk: _grojibAnimWalkFrames,
  AnimKey.strike: _grojibAnimStrikeFrames,
  AnimKey.hit: _grojibAnimHitFrames,
  AnimKey.death: _grojibAnimDeathFrames,
  AnimKey.jump: _grojibAnimJumpFrames,
  AnimKey.fall: _grojibAnimFallFrames,
};

const Map<AnimKey, double> _grojibAnimStepTimeSecondsByKey = <AnimKey, double>{
  AnimKey.idle: _grojibAnimIdleStepSeconds,
  AnimKey.stun: _grojibAnimStunStepSeconds,
  AnimKey.run: _grojibAnimMoveStepSeconds,
  AnimKey.walk: _grojibAnimWalkStepSeconds,
  AnimKey.strike: _grojibAnimStrikeStepSeconds,
  AnimKey.hit: _grojibAnimHitStepSeconds,
  AnimKey.death: _grojibAnimDeathStepSeconds,
  AnimKey.jump: _grojibAnimJumpStepSeconds,
  AnimKey.fall: _grojibAnimFallStepSeconds,
};

const String _grojibAnimSpriteSheetPath = 'entities/enemies/grojib/grojib.png';

const Map<AnimKey, String> _grojibAnimSourcesByKey = <AnimKey, String>{
  AnimKey.idle: _grojibAnimSpriteSheetPath,
  AnimKey.stun: _grojibAnimSpriteSheetPath,
  AnimKey.run: _grojibAnimSpriteSheetPath,
  AnimKey.walk: _grojibAnimSpriteSheetPath,
  AnimKey.strike: _grojibAnimSpriteSheetPath,
  AnimKey.hit: _grojibAnimSpriteSheetPath,
  AnimKey.death: _grojibAnimSpriteSheetPath,
  AnimKey.jump: _grojibAnimSpriteSheetPath,
  AnimKey.fall: _grojibAnimSpriteSheetPath,
};

const Map<AnimKey, int> _grojibAnimRowByKey = <AnimKey, int>{
  AnimKey.idle: 0,
  AnimKey.stun: 0,
  AnimKey.run: 1,
  AnimKey.walk: 1,
  AnimKey.strike: 2,
  AnimKey.hit: 3,
  AnimKey.death: 4,
  AnimKey.jump: 5,
  AnimKey.fall: 7,
};

const RenderAnimSetDefinition _grojibRenderAnim = RenderAnimSetDefinition(
  frameWidth: _grojibAnimFrameWidth,
  frameHeight: _grojibAnimFrameHeight,
  sourcesByKey: _grojibAnimSourcesByKey,
  rowByKey: _grojibAnimRowByKey,
  anchorInFramePx: Vec2(77, _grojibAnimFrameHeight * 0.5),
  frameCountsByKey: _grojibAnimFrameCountsByKey,
  stepTimeSecondsByKey: _grojibAnimStepTimeSecondsByKey,
);

const AnimProfile _grojibAnimProfile = AnimProfile(
  minMoveSpeed: 1.0,
  runSpeedThresholdX: 120.0,
  supportsStun: true,
);

/// Defines the base stats and physics properties for an enemy type.
///
/// This data is "static" (read-only) configuration used to initialize
/// the ECS components effectively when an enemy spawns.
class EnemyArchetype {
  const EnemyArchetype({
    required this.body,
    required this.collider,
    required this.health,
    required this.mana,
    required this.stamina,
    required this.renderAnim,
    required this.animProfile,
    required this.hitAnimSeconds,
    required this.deathAnimSeconds,
    this.deathBehavior = DeathBehavior.instant,
    this.primaryProjectileItemId,
    this.artFacingDir = Facing.left,
    this.tags = const CreatureTagDef(),
    this.resistance = const DamageResistanceDef(),
    this.statusImmunity = const StatusImmunityDef(),
  });

  /// Physics configuration (Gravity, Constraints, Kinematics).
  final BodyDef body;

  /// Hitbox size (Collision).
  final ColliderAabbDef collider;

  /// Vitals (HP, Mana, Stamina) configuration.
  final HealthDef health;
  final ManaDef mana;
  final StaminaDef stamina;

  /// Render-only animation metadata (strip paths, frame size, timing).
  final RenderAnimSetDefinition renderAnim;

  /// Core animation profile (movement thresholds and supported keys).
  final AnimProfile animProfile;

  /// Duration the hit animation should be visible (seconds).
  final double hitAnimSeconds;

  /// Duration the death animation should be visible (seconds).
  final double deathAnimSeconds;

  /// Behavior for death transition timing (instant vs ground impact).
  final DeathBehavior deathBehavior;

  /// Optional primary projectile item for this enemy.
  ///
  /// When present, the [EnemyCastSystem] will use this to write projectile intents.
  final ProjectileItemId? primaryProjectileItemId;

  /// Direction the authored art faces when not mirrored.
  ///
  /// Most sprites face right by default, but some packs are authored facing
  /// left. The renderer uses this to mirror correctly based on logical [Facing].
  final Facing artFacingDir;

  /// Broad tags used by combat rules and content filters.
  final CreatureTagDef tags;

  /// Resistance/vulnerability modifiers by damage type.
  final DamageResistanceDef resistance;

  /// Status effect immunities for this enemy.
  final StatusImmunityDef statusImmunity;
}

/// Central registry for Enemy Definitions.
///
/// **Usage**:
/// - Accessed by `EnemySpawnSystem` (or similar) to hydration entities.
/// - Decouples "What an enemy is" from "How to spawn it".
class EnemyCatalog {
  const EnemyCatalog();

  /// Returns the static archetype definition for a given [EnemyId].
  ///
  /// Note: The returned objects are `const` and allocation-light.
  EnemyArchetype get(EnemyId id) {
    switch (id) {
      case EnemyId.unocoDemon:
        return const EnemyArchetype(
          body: BodyDef(
            isKinematic: false,
            useGravity: false,
            gravityScale: 0.0,
            sideMask: BodyDef.sideNone,
            maxVelX: 800.0,
            maxVelY: 800.0,
          ),
          collider: ColliderAabbDef(halfX: 12.0, halfY: 12.0),
          health: HealthDef(hp: 2000, hpMax: 2000, regenPerSecond100: 50),
          mana: ManaDef(mana: 8000, manaMax: 8000, regenPerSecond100: 500),
          stamina: StaminaDef(stamina: 0, staminaMax: 0, regenPerSecond100: 0),
          renderAnim: _unocoRenderAnim,
          animProfile: _unocoAnimProfile,
          hitAnimSeconds: _unocoHitAnimSeconds,
          deathAnimSeconds: _unocoDeathAnimSeconds,
          deathBehavior: DeathBehavior.instant,
          primaryProjectileItemId: ProjectileItemId.thunderBolt,
          artFacingDir: Facing.left,
          tags: CreatureTagDef(
            mask: CreatureTagMask.flying | CreatureTagMask.demon,
          ),
          resistance: DamageResistanceDef(fireBp: -5000, iceBp: 5000),
        );

      case EnemyId.grojib:
        return const EnemyArchetype(
          body: BodyDef(
            isKinematic: false,
            useGravity: true,
            ignoreCeilings: true,
            gravityScale: 1.0,
            sideMask: BodyDef.sideLeft | BodyDef.sideRight,
          ),
          collider: ColliderAabbDef(
            halfX: 25.0,
            halfY: 25.0,
            offsetX: 0.0,
            offsetY: 20.0,
          ),
          health: HealthDef(hp: 2000, hpMax: 2000, regenPerSecond100: 50),
          mana: ManaDef(mana: 0, manaMax: 0, regenPerSecond100: 0),
          stamina: StaminaDef(stamina: 0, staminaMax: 0, regenPerSecond100: 0),
          renderAnim: _grojibRenderAnim,
          animProfile: _grojibAnimProfile,
          hitAnimSeconds: _grojibHitAnimSeconds,
          deathAnimSeconds: _grojibDeathAnimSeconds,
          deathBehavior: DeathBehavior.groundImpactThenDeath,
          tags: CreatureTagDef(mask: CreatureTagMask.humanoid),
        );
    }
  }
}


===== FILE: lib/core/enemies/enemy_id.dart =====
/// Unique identifiers for enemy types.
///
/// **Usage**:
/// - Used for spawning via `SpawnSystem`.
/// - keys for `EnemyCatalog` lookup.
/// - Stable identifiers for networking/snapshots (protocol-stable).
enum EnemyId {
  /// A flying demon enemy that ignores gravity and casts spells.
  unocoDemon,

  /// A basic ground chasing enemy that is affected by gravity.
  grojib,
}



===== FILE: lib/core/enemies/enemy_killed_info.dart =====
library;

import '../snapshots/enums.dart';
import '../util/vec2.dart';
import 'enemy_id.dart';

/// Minimal data captured at the moment an enemy is killed.
///
/// Used to emit render/UI events (e.g. play a death animation) even though the
/// enemy entity is despawned immediately by Core.
class EnemyKilledInfo {
  const EnemyKilledInfo({
    required this.enemyId,
    required this.pos,
    required this.facing,
    required this.artFacingDir,
  });

  final EnemyId enemyId;
  final Vec2 pos;
  final Facing facing;
  final Facing artFacingDir;
}


===== FILE: lib/core/events/enemy_events.dart =====
part of 'game_event.dart';

/// Emitted when an enemy is killed (HP reaches 0 and the entity despawns).
///
/// This exists because Core typically despawns dead enemies immediately, so the
/// renderer would otherwise have no chance to play a death animation.
class EnemyKilledEvent extends GameEvent {
  const EnemyKilledEvent({
    required this.tick,
    required this.enemyId,
    required this.pos,
    required this.facing,
    required this.artFacingDir,
  });

  /// Simulation tick when the kill occurred.
  final int tick;

  final EnemyId enemyId;
  final Vec2 pos;
  final Facing facing;
  final Facing artFacingDir;
}


===== FILE: lib/core/events/game_event.dart =====
/// Core -> Render/UI event model.
///
/// **Architecture**:
/// - "Events" in this context are **transient side effects** emitted by the simulation.
/// - Examples: SFX triggers, Particle spawns, Run completion, Screen shake.
/// - They are distinct from "State" (Snapshots). State is continuous; Events are discrete.
///
/// **Usage**:
/// - Systems emit events into a queue.
/// - The GameController or UI layer consumes them (e.g., to play a sound or show a dialog).
/// - Events are fire-and-forget.
library;
import '../enemies/enemy_id.dart';
import '../projectiles/projectile_id.dart';
import '../snapshots/enums.dart';
import '../projectiles/projectile_item_id.dart';
import '../util/vec2.dart';

part 'run_events.dart';
part 'enemy_events.dart';
part 'projectile_events.dart';

/// Base sealed class for all simulation events.
sealed class GameEvent {
  const GameEvent();
}


===== FILE: lib/core/events/projectile_events.dart =====
part of 'game_event.dart';

/// Emitted when a projectile hits a damageable target.
///
/// Used by the renderer to spawn impact VFX even though the projectile entity
/// is despawned immediately in Core.
class ProjectileHitEvent extends GameEvent {
  const ProjectileHitEvent({
    required this.tick,
    required this.projectileId,
    required this.pos,
    required this.facing,
    required this.rotationRad,
    this.projectileItemId,
  });

  /// Simulation tick when the hit occurred.
  final int tick;

  final ProjectileId projectileId;
  final ProjectileItemId? projectileItemId;
  final Vec2 pos;
  final Facing facing;
  final double rotationRad;
}


===== FILE: lib/core/events/run_events.dart =====
part of 'game_event.dart';

/// The specific cause for a run ending.
enum RunEndReason {
  /// Player was too slow and scrolled off the screen.
  fellBehindCamera,
  
  /// Player fell into a death pit.
  fellIntoGap,
  
  /// HP reached 0 (combat death).
  playerDied,
  
  /// User manually exited the run.
  gaveUp,
}

/// Identifies the category of damage source that caused death.
enum DeathSourceKind {
  projectile,
  meleeHitbox,
  statusEffect,
  unknown,
}

/// Detailed context about what killed the player.
class DeathInfo {
  const DeathInfo({
    required this.kind,
    this.enemyId,
    this.projectileId,
    this.projectileItemId,
  });

  /// Category of the damage source.
  final DeathSourceKind kind;
  
  /// The [EnemyId] responsible (if applicable).
  final EnemyId? enemyId;
  
  /// The [ProjectileId] responsible (if applicable).
  final ProjectileId? projectileId;
  
  /// The [ProjectileItemId] responsible (if applicable).
  final ProjectileItemId? projectileItemId;
}

/// Aggregate statistics collected during a run.
class RunEndStats {
  const RunEndStats({
    required this.collectibles,
    required this.collectibleScore,
    required this.enemyKillCounts,
  });

  /// Total count of collectibles picked up.
  final int collectibles;
  
  /// Total score value of collectibles.
  final int collectibleScore;

  /// Kill counts per enemy type.
  ///
  /// **Ordering**: Indices strictly align with [EnemyId.values].
  /// `enemyKillCounts[i]` corresponds to the kills for the enemy at `EnemyId.values[i]`.
  final List<int> enemyKillCounts;
}

/// Event emitted when the game session terminates.
///
/// Contains all necessary data to display the "Game Over" screen.
class RunEndedEvent extends GameEvent {
  const RunEndedEvent({
    required this.runId,
    required this.tick,
    required this.distance,
    required this.reason,
    required this.stats,
    required this.goldEarned,
    this.deathInfo,
  });

  /// Unique identifier for this run session.
  final int runId;

  /// The tick on which the run ended.
  final int tick;
  
  /// Total distance traveled (meters/pixels).
  final double distance;
  
  /// Why the run ended (Death vs GiveUp).
  final RunEndReason reason;
  
  /// Performance stats.
  final RunEndStats stats;

  /// Gold earned for this run (derived from run stats).
  final int goldEarned;
  
  /// Details on the lethal hit (if applicable).
  final DeathInfo? deathInfo;
}


===== FILE: lib/core/game_core.dart =====
/// Authoritative, deterministic simulation layer (pure Dart).
///
/// This is the heart of the game—a pure Dart simulation that processes
/// tick-stamped commands, advances physics and AI, and produces immutable
/// snapshots for the renderer/UI. By keeping this layer Flutter/Flame-free,
/// we gain:
/// - **Testability**: Unit tests can run headless at any tick rate.
/// - **Determinism**: Same seed + commands = identical simulation.
/// - **Portability**: Core logic could run on a server for validation.
///
/// ## Architecture Overview
///
/// ```
/// Commands (from input layer)
///         ↓
///    GameCore.applyCommands()
///         ↓
///    GameCore.stepOneTick()
///         ↓
///    [Track streaming → Physics → AI → Combat → Cleanup]
///         ↓
///    GameStateSnapshot (to render layer)
/// ```
///
/// ## Module Dependencies
///
/// [GameCore] orchestrates three extracted modules:
/// - [TrackManager]: Procedural chunk generation, geometry lifecycle.
/// - [SpawnService]: Deterministic entity spawning (enemies, items).
/// - [SnapshotBuilder]: ECS → render snapshot conversion.
///
/// ## ECS System Execution Order
///
/// Systems run in a carefully ordered pipeline each tick:
/// 1. **Track streaming**: Spawn/cull chunks based on camera.
/// 2. **Cooldowns & invulnerability**: Decrement timers.
/// 3. **Enemy AI steering**: Path planning and movement intent.
/// 4. **Player input**: Resolve ability intents (including mobility).
/// 5. **Player movement**: Apply input to velocity.
/// 6. **Mobility execution**: Apply dash/roll state.
/// 7. **Gravity**: Apply gravity to non-kinematic bodies.
/// 8. **Collision**: Resolve static world collisions.
/// 9. **Pickups**: Collect items overlapping player.
/// 10. **Broadphase rebuild**: Update spatial grid for hit detection.
/// 11. **Projectile movement**: Advance existing projectiles.
/// 12. **Strike intents**: Enemies and player queue strikes.
/// 13. **Strike execution**: Spawn hitboxes/projectiles/self abilities.
/// 14. **Hitbox positioning**: Follow owner entities.
/// 15. **Hit resolution**: Detect overlaps, queue damage.
/// 16. **Status ticking**: Apply DoT ticks and queue damage.
/// 17. **Damage middleware**: Apply combat rule edits/cancellations.
/// 18. **Damage application**: Apply queued damage, set invulnerability.
/// 19. **Status application**: Apply on-hit status profiles.
/// 20. **Death handling**: Despawn dead entities, record kills.
/// 21. **Resource regen**: Regenerate mana/stamina.
/// 22. **Lifetime cleanup**: Remove expired entities.
///
/// ## Determinism Contract
///
/// Given identical inputs:
/// - Same [seed] parameter
/// - Same sequence of [Command]s with same tick stamps
/// - Same [tickHz]
///
/// The simulation will produce identical results across runs and platforms.
/// This is achieved by:
/// - Using [DeterministicRng] instead of `dart:math Random`
/// - Fixed-point-style tick math (no frame-rate-dependent dt accumulation)
/// - Deterministic iteration order (entity IDs, not hash-based)
library;

import 'dart:math';

import 'camera/autoscroll_camera.dart';
import 'abilities/ability_catalog.dart';
import 'abilities/ability_def.dart';
import 'combat/middleware/parry_middleware.dart';
import 'collision/static_world_geometry_index.dart';
import 'commands/command.dart';
import 'contracts/render_contract.dart';
import 'ecs/entity_factory.dart';
import 'ecs/entity_id.dart';
import 'ecs/spatial/broadphase_grid.dart';
import 'ecs/spatial/grid_index_2d.dart';
import 'ecs/stores/restoration_item_store.dart';
import 'ecs/systems/collectible_system.dart';
import 'ecs/systems/collision_system.dart';
import 'ecs/systems/cooldown_system.dart';
import 'ecs/systems/damage_middleware_system.dart';
import 'ecs/systems/damage_system.dart';
import 'ecs/systems/active_ability_phase_system.dart';
import 'ecs/systems/death_despawn_system.dart';
import 'ecs/systems/enemy_cast_system.dart';
import 'ecs/systems/enemy_death_state_system.dart';
import 'ecs/systems/enemy_engagement_system.dart';
import 'ecs/systems/flying_enemy_locomotion_system.dart';
import 'ecs/systems/ground_enemy_locomotion_system.dart';
import 'ecs/systems/enemy_navigation_system.dart';
import 'ecs/systems/gravity_system.dart';
import 'ecs/systems/health_despawn_system.dart';
import 'ecs/systems/hitbox_damage_system.dart';
import 'ecs/systems/hitbox_follow_owner_system.dart';
import 'ecs/systems/invulnerability_system.dart';
import 'ecs/systems/lifetime_system.dart';
import 'ecs/systems/melee_strike_system.dart';
import 'ecs/systems/ability_activation_system.dart';
import 'ecs/systems/mobility_system.dart';
import 'ecs/systems/player_movement_system.dart';
import 'ecs/systems/projectile_hit_system.dart';
import 'ecs/systems/projectile_system.dart';
import 'ecs/systems/projectile_world_collision_system.dart';
import 'ecs/systems/projectile_launch_system.dart';
import 'ecs/systems/resource_regen_system.dart';
import 'ecs/systems/restoration_item_system.dart';
import 'ecs/systems/self_ability_system.dart';
import 'ecs/systems/status_system.dart';
import 'ecs/systems/control_lock_system.dart';
import 'ecs/systems/anim/anim_system.dart';
import 'ecs/systems/enemy_cull_system.dart';
import 'ecs/systems/enemy_melee_system.dart';
import 'ecs/world.dart';
import 'enemies/enemy_catalog.dart';
import 'enemies/enemy_id.dart';
import 'events/game_event.dart';
import 'levels/level_definition.dart';
import 'levels/level_id.dart';
import 'levels/level_registry.dart';
import 'navigation/surface_graph_builder.dart';
import 'navigation/surface_navigator.dart';
import 'navigation/surface_pathfinder.dart';
import 'navigation/utils/jump_template.dart';
import 'navigation/utils/trajectory_predictor.dart';
import 'players/player_catalog.dart';
import 'players/player_character_definition.dart';
import 'players/player_character_registry.dart';
import 'projectiles/projectile_catalog.dart';
import 'snapshots/enums.dart';
import 'snapshots/game_state_snapshot.dart';
import 'snapshot_builder.dart';
import 'spawn_service.dart';
import 'projectiles/projectile_item_catalog.dart';
import 'projectiles/projectile_item_id.dart';
import 'progression/run_rewards.dart';
import 'track_manager.dart';
import 'weapons/weapon_catalog.dart';
import 'ecs/stores/combat/equipped_loadout_store.dart';
import 'tuning/camera_tuning.dart';
import 'tuning/collectible_tuning.dart';
import 'tuning/core_tuning.dart';
import 'tuning/flying_enemy_tuning.dart';
import 'tuning/ground_enemy_tuning.dart';
import 'tuning/navigation_tuning.dart';
import 'tuning/physics_tuning.dart';
import 'players/player_tuning.dart';
import 'tuning/restoration_item_tuning.dart';
import 'tuning/score_tuning.dart';
import 'tuning/spatial_grid_tuning.dart';
import 'tuning/track_tuning.dart';
import 'util/tick_math.dart';

// ─────────────────────────────────────────────────────────────────────────────
// GameCore - Main simulation coordinator
// ─────────────────────────────────────────────────────────────────────────────

/// Deterministic game simulation core.
///
/// This class is the central coordinator for the game simulation. It:
/// - Owns the [EcsWorld] and all ECS systems.
/// - Processes player [Command]s each tick.
/// - Steps physics, AI, and combat systems in order.
/// - Produces [GameStateSnapshot]s for the render layer.
/// - Emits [GameEvent]s for UI feedback (run ended, etc.).
///
/// ## Usage
///
/// ```dart
/// final core = GameCore(seed: 42);
/// core.applyCommands([JumpPressedCommand()]);
/// core.stepOneTick();
/// final snapshot = core.buildSnapshot();
/// final events = core.drainEvents();
/// ```
///
/// ## Custom Configuration
///
/// Use [CoreTuning] to customize world/level parameters:
/// ```dart
/// final core = GameCore(
///   seed: 123,
///   tuning: CoreTuning(track: TrackTuning(enabled: false)),
/// );
/// ```
///
/// Use [PlayerCharacterDefinition] to select player-specific tuning + collider:
/// ```dart
/// final core = GameCore(
///   seed: 123,
///   playerCharacter: PlayerCharacterRegistry.eloise,
/// );
/// ```
///
/// Use [LevelDefinition] to select a level configuration:
/// ```dart
/// final core = GameCore(
///   seed: 123,
///   levelDefinition: LevelRegistry.byId(LevelId.defaultLevel),
/// );
/// ```
class GameCore {
  static LevelDefinition _resolveLevelDefinition({
    required CoreTuning tuning,
    required StaticWorldGeometry staticWorldGeometry,
    LevelDefinition? levelDefinition,
  }) {
    if (levelDefinition != null) return levelDefinition;
    final base = LevelRegistry.defaultLevel;
    return LevelDefinition(
      id: base.id,
      patternPool: base.patternPool,
      earlyPatternChunks: base.earlyPatternChunks,
      noEnemyChunks: base.noEnemyChunks,
      themeId: base.themeId,
      tuning: tuning,
      staticWorldGeometry: staticWorldGeometry,
    );
  }

  /// Creates a new game simulation with the given configuration.
  ///
  /// Parameters:
  /// - [seed]: Master RNG seed for deterministic generation.
  /// - [runId]: Unique identifier for this run session (replay/ghost).
  /// - [tickHz]: Fixed tick rate (default 60). Higher = smoother but more CPU.
  /// - [tuning]: Aggregate tuning configuration (see [CoreTuning]).
  /// - Catalogs: Entity archetype definitions (spells, enemies, etc.).
  /// - [staticWorldGeometry]: Base level geometry (ground, initial platforms).
  /// - [levelDefinition]: Optional level config. When provided, its tuning,
  ///   static geometry, and pattern pools are used (and [tuning] /
  ///   [staticWorldGeometry] are ignored).
  GameCore({
    required int seed,
    int runId = 0,
    int tickHz = defaultTickHz,
    CoreTuning tuning = const CoreTuning(),
    PlayerCharacterDefinition playerCharacter =
        PlayerCharacterRegistry.defaultCharacter,
    ProjectileItemCatalog projectileItemCatalog = const ProjectileItemCatalog(),
    ProjectileCatalog projectileCatalog = const ProjectileCatalog(),
    EnemyCatalog enemyCatalog = const EnemyCatalog(),
    WeaponCatalog weaponCatalog = const WeaponCatalog(),
    StaticWorldGeometry staticWorldGeometry = const StaticWorldGeometry(
      groundPlane: StaticGroundPlane(topY: groundTopY * 1.0),
    ),
    LevelDefinition? levelDefinition,
  }) : this._fromLevel(
         seed: seed,
         runId: runId,
         tickHz: tickHz,
         levelDefinition: _resolveLevelDefinition(
           levelDefinition: levelDefinition,
           tuning: tuning,
           staticWorldGeometry: staticWorldGeometry,
         ),
         projectileItemCatalog: projectileItemCatalog,
         projectileCatalog: projectileCatalog,
         enemyCatalog: enemyCatalog,
         playerCharacter: playerCharacter,
         weaponCatalog: weaponCatalog,
       );

  GameCore._fromLevel({
    required this.seed,
    required this.runId,
    required this.tickHz,
    required LevelDefinition levelDefinition,
    required ProjectileItemCatalog projectileItemCatalog,
    required ProjectileCatalog projectileCatalog,
    required EnemyCatalog enemyCatalog,
    required PlayerCharacterDefinition playerCharacter,
    required WeaponCatalog weaponCatalog,
  }) : _levelDefinition = levelDefinition,
       _movement = MovementTuningDerived.from(
         playerCharacter.tuning.movement,
         tickHz: tickHz,
       ),
       _physicsTuning = levelDefinition.tuning.physics,
       _resourceTuning = ResourceTuningDerived.from(
         playerCharacter.tuning.resource,
       ),
       _abilities = AbilityTuningDerived.from(
         playerCharacter.tuning.ability,
         tickHz: tickHz,
       ),
       _animTuning = AnimTuningDerived.from(
         playerCharacter.tuning.anim,
         tickHz: tickHz,
       ),
       _combat = CombatTuningDerived.from(
         playerCharacter.tuning.combat,
         tickHz: tickHz,
       ),
       _unocoDemonTuning = UnocoDemonTuningDerived.from(
         levelDefinition.tuning.unocoDemon,
         tickHz: tickHz,
       ),
       _groundEnemyTuning = GroundEnemyTuningDerived.from(
         levelDefinition.tuning.groundEnemy,
         tickHz: tickHz,
       ),
       _navigationTuning = levelDefinition.tuning.navigation,
       _spatialGridTuning = levelDefinition.tuning.spatialGrid,
       _projectileItems = projectileItemCatalog,
       _projectiles = ProjectileCatalogDerived.from(
         projectileCatalog,
         tickHz: tickHz,
       ),
       _enemyCatalog = enemyCatalog,
       _playerCharacter = playerCharacter,
       _weapons = weaponCatalog,
       _scoreTuning = levelDefinition.tuning.score,
       _trackTuning = levelDefinition.tuning.track,
       _collectibleTuning = levelDefinition.tuning.collectible,
       _restorationItemTuning = levelDefinition.tuning.restorationItem {
    _initializeWorld(levelDefinition);
  }

  /// Common initialization shared by all constructors.
  void _initializeWorld(LevelDefinition levelDefinition) {
    final staticWorldGeometry = levelDefinition.staticWorldGeometry;
    final cameraTuning = levelDefinition.tuning.camera;
    // ─── Initialize ECS world and entity factory ───
    _world = EcsWorld(seed: seed);
    _entityFactory = EntityFactory(_world);

    // ─── Initialize all ECS systems ───
    _initializeSystems();

    // ─── Initialize autoscrolling camera ───
    _cameraTuning = CameraTuningDerived.from(cameraTuning, movement: _movement);
    _camera = AutoscrollCamera(
      viewWidth: virtualWidth.toDouble(),
      tuning: _cameraTuning,
      initial: CameraState(
        centerX: virtualWidth * 0.5,
        targetX: virtualWidth * 0.5,
        speedX: 0.0,
      ),
    );

    // ─── Initialize spawn service (needs ECS + catalogs) ───
    _spawnService = SpawnService(
      world: _world,
      entityFactory: _entityFactory,
      enemyCatalog: _enemyCatalog,
      unocoDemonTuning: _unocoDemonTuning,
      movement: _movement,
      collectibleTuning: _collectibleTuning,
      restorationItemTuning: _restorationItemTuning,
      trackTuning: _trackTuning,
      seed: seed,
    );

    // ─── Spawn player entity (must happen before TrackManager) ───
    final effectiveGroundTopY =
        staticWorldGeometry.groundPlane?.topY ?? groundTopY.toDouble();
    _spawnPlayer(effectiveGroundTopY);

    // ─── Initialize track manager (needs player for callbacks) ───
    _trackManager = TrackManager(
      seed: seed,
      trackTuning: _trackTuning,
      collectibleTuning: _collectibleTuning,
      restorationItemTuning: _restorationItemTuning,
      baseGeometry: staticWorldGeometry,
      surfaceGraphBuilder: _surfaceGraphBuilder,
      jumpTemplate: _groundEnemyJumpTemplate,
      enemyNavigationSystem: _enemyNavigationSystem,
      groundEnemyLocomotionSystem: _groundEnemyLocomotionSystem,
      spawnService: _spawnService,
      groundTopY: effectiveGroundTopY,
      patternPool: levelDefinition.patternPool,
      earlyPatternChunks: levelDefinition.earlyPatternChunks,
      noEnemyChunks: levelDefinition.noEnemyChunks,
    );

    // ─── Initialize snapshot builder (needs player entity ID) ───
    _snapshotBuilder = SnapshotBuilder(
      tickHz: tickHz,
      world: _world,
      player: _player,
      movement: _movement,
      abilities: _abilities,
      resources: _resourceTuning,
      projectiles: _projectiles,
      enemyCatalog: _enemyCatalog,
    );
  }

  /// Initializes all ECS systems.
  ///
  /// Systems are stateless processors that operate on component stores.
  /// They're created once at construction and reused every tick.
  void _initializeSystems() {
    // Core movement and physics.
    _movementSystem = PlayerMovementSystem();
    _mobilitySystem = MobilitySystem();
    _collisionSystem = CollisionSystem();
    _cooldownSystem = CooldownSystem();
    _gravitySystem = GravitySystem();

    // Projectile lifecycle.
    _projectileSystem = ProjectileSystem();
    _projectileHitSystem = ProjectileHitSystem();
    _projectileWorldCollisionSystem = ProjectileWorldCollisionSystem();

    // Spatial partitioning for hit detection.
    _broadphaseGrid = BroadphaseGrid(
      index: GridIndex2D(cellSize: _spatialGridTuning.broadphaseCellSize),
    );

    // Hitbox management.
    _hitboxFollowOwnerSystem = HitboxFollowOwnerSystem();
    _lifetimeSystem = LifetimeSystem();

    // Damage pipeline.
    _invulnerabilitySystem = InvulnerabilitySystem();
    _damageMiddlewareSystem = DamageMiddlewareSystem(
      middlewares: [
        ParryMiddleware(
          abilityIds: const <AbilityKey>{
            'eloise.sword_parry',
            'eloise.shield_block',
          },
        ),
      ],
    );
    _damageSystem = DamageSystem(
      invulnerabilityTicksOnHit: _combat.invulnerabilityTicks,
      rngSeed: seed,
    );
    _statusSystem = StatusSystem(tickHz: tickHz);
    _controlLockSystem = ControlLockSystem();
    _activeAbilityPhaseSystem = ActiveAbilityPhaseSystem();
    _healthDespawnSystem = HealthDespawnSystem();
    _enemyDeathStateSystem = EnemyDeathStateSystem(
      tickHz: tickHz,
      enemyCatalog: _enemyCatalog,
    );
    _deathDespawnSystem = DeathDespawnSystem();
    _enemyCullSystem = EnemyCullSystem();
    _animSystem = AnimSystem(
      tickHz: tickHz,
      enemyCatalog: _enemyCatalog,
      playerMovement: _movement,
      playerAnimTuning: _animTuning,
    );

    // Player combat (input → intents).
    _abilityActivationSystem = AbilityActivationSystem(
      tickHz: tickHz,
      inputBufferTicks: _abilities.inputBufferTicks,
      abilities: const AbilityCatalog(),
      weapons: _weapons,
      projectileItems: _projectileItems,
    );
    _hitboxDamageSystem = HitboxDamageSystem();

    // Pickup systems.
    _collectibleSystem = CollectibleSystem();
    _restorationItemSystem = RestorationItemSystem();
    _resourceRegenSystem = ResourceRegenSystem(tickHz: tickHz);

    // Projectile execution.
    _projectileLaunchSystem = ProjectileLaunchSystem(projectiles: _projectiles);
    _selfAbilitySystem = SelfAbilitySystem();
    _meleeStrikeSystem = MeleeStrikeSystem();

    // Navigation infrastructure.
    _surfaceGraphBuilder = SurfaceGraphBuilder(
      surfaceGrid: GridIndex2D(cellSize: _spatialGridTuning.broadphaseCellSize),
      takeoffSampleMaxStep: _navigationTuning.takeoffSampleMaxStep,
    );
    _groundEnemyJumpTemplate = JumpReachabilityTemplate.build(
      JumpProfile(
        jumpSpeed: _groundEnemyTuning.locomotion.jumpSpeed,
        gravityY: _physicsTuning.gravityY,
        maxAirTicks: _groundEnemyMaxAirTicks(),
        airSpeedX: _groundEnemyTuning.locomotion.speedX,
        dtSeconds: _movement.dtSeconds,
        agentHalfWidth: _enemyCatalog.get(EnemyId.grojib).collider.halfX,
      ),
    );
    _surfacePathfinder = SurfacePathfinder(
      maxExpandedNodes: _navigationTuning.maxExpandedNodes,
      runSpeedX: _groundEnemyTuning.locomotion.speedX,
      edgePenaltySeconds: _navigationTuning.edgePenaltySeconds,
    );
    _surfaceNavigator = SurfaceNavigator(
      pathfinder: _surfacePathfinder,
      repathCooldownTicks: _navigationTuning.repathCooldownTicks,
      surfaceEps: _navigationTuning.surfaceEps,
      takeoffEps: max(
        _navigationTuning.takeoffEpsMin,
        _groundEnemyTuning.locomotion.stopDistanceX,
      ),
    );

    _enemyNavigationSystem = EnemyNavigationSystem(
      surfaceNavigator: _surfaceNavigator,
      trajectoryPredictor: TrajectoryPredictor(
        gravityY: _physicsTuning.gravityY,
        dtSeconds: _movement.dtSeconds,
        maxTicks: 120,
      ),
      chaseTargetDelayTicks:
          _groundEnemyTuning.navigation.chaseTargetDelayTicks,
    );
    _enemyEngagementSystem = EnemyEngagementSystem(
      groundEnemyTuning: _groundEnemyTuning,
    );
    _groundEnemyLocomotionSystem = GroundEnemyLocomotionSystem(
      groundEnemyTuning: _groundEnemyTuning,
    );
    _flyingEnemyLocomotionSystem = FlyingEnemyLocomotionSystem(
      unocoDemonTuning: _unocoDemonTuning,
    );
    _enemyCastSystem = EnemyCastSystem(
      unocoDemonTuning: _unocoDemonTuning,
      enemyCatalog: _enemyCatalog,
      projectileItems: _projectileItems,
      projectiles: _projectiles,
    );
    _enemyMeleeSystem = EnemyMeleeSystem(groundEnemyTuning: _groundEnemyTuning);
  }

  /// Spawns the player entity at the start of a run.
  ///
  /// The player is positioned at [TrackTuning.playerStartX], standing on the
  /// ground. This must be called before [TrackManager] is created because
  /// track manager callbacks reference the player entity.
  void _spawnPlayer(double groundTopY) {
    final spawnX = _trackTuning.playerStartX;
    final playerArchetype = PlayerCatalogDerived.from(
      _playerCharacter.catalog,
      movement: _movement,
      resources: _resourceTuning,
    ).archetype;
    final playerCollider = playerArchetype.collider;

    // Position so collider bottom touches ground.
    final spawnY = groundTopY - (playerCollider.offsetY + playerCollider.halfY);
    _player = _entityFactory.createPlayer(
      posX: spawnX,
      posY: spawnY,
      velX: 0.0,
      velY: 0.0,
      facing: playerArchetype.facing,
      grounded: true,
      body: playerArchetype.body,
      collider: playerCollider,
      health: playerArchetype.health,
      mana: playerArchetype.mana,
      stamina: playerArchetype.stamina,
      tags: playerArchetype.tags,
      resistance: playerArchetype.resistance,
      statusImmunity: playerArchetype.statusImmunity,
      equippedLoadout: EquippedLoadoutDef(
        mask: playerArchetype.loadoutSlotMask,
        mainWeaponId: playerArchetype.weaponId,
        offhandWeaponId: playerArchetype.offhandWeaponId,
        projectileItemId: playerArchetype.projectileItemId,
        abilityProjectileId: _abilityIdForProjectileItem(
          playerArchetype.projectileItemId,
        ),
      ),
    );
  }

  AbilityKey _abilityIdForProjectileItem(ProjectileItemId id) {
    switch (id) {
      case ProjectileItemId.iceBolt:
        return 'eloise.ice_bolt';
      case ProjectileItemId.fireBolt:
        return 'eloise.fire_bolt';
      case ProjectileItemId.thunderBolt:
        return 'eloise.thunder_bolt';
      case ProjectileItemId.throwingKnife:
        return 'eloise.throwing_knife';
      case ProjectileItemId.throwingAxe:
        return 'eloise.throwing_knife';
    }
  }

  // ─────────────────────────────────────────────────────────────────────────
  // Fields
  // ─────────────────────────────────────────────────────────────────────────

  /// Master RNG seed for deterministic generation.
  ///
  /// The same seed produces identical track layouts, enemy spawns, and

  /// item placements across runs.
  final int seed;

  /// Unique identifier for this run session.
  final int runId;

  /// Fixed simulation tick frequency (ticks per second).
  ///
  /// Higher values = smoother physics but more CPU. Default is 60.
  final int tickHz;

  /// Core level configuration for this run.
  final LevelDefinition _levelDefinition;

  // ─── Derived Tunings ───
  // These are pre-computed from base tunings using tickHz.

  final MovementTuningDerived _movement;
  final PhysicsTuning _physicsTuning;
  final ResourceTuningDerived _resourceTuning;
  final AbilityTuningDerived _abilities;
  final AnimTuningDerived _animTuning;
  final CombatTuningDerived _combat;
  final UnocoDemonTuningDerived _unocoDemonTuning;
  final GroundEnemyTuningDerived _groundEnemyTuning;
  final NavigationTuning _navigationTuning;
  final SpatialGridTuning _spatialGridTuning;
  late final CameraTuningDerived _cameraTuning;
  final ScoreTuning _scoreTuning;
  final TrackTuning _trackTuning;
  final CollectibleTuning _collectibleTuning;
  final RestorationItemTuning _restorationItemTuning;

  // ─── Catalogs ───
  // Archetype definitions for entities.

  final ProjectileItemCatalog _projectileItems;
  final ProjectileCatalogDerived _projectiles;
  final EnemyCatalog _enemyCatalog;
  final PlayerCharacterDefinition _playerCharacter;
  final WeaponCatalog _weapons;

  // ─── ECS Core ───

  /// The ECS world containing all component stores.
  late final EcsWorld _world;

  /// Factory for creating complex entities (player, enemies).
  late final EntityFactory _entityFactory;

  /// The player entity ID.
  late EntityId _player;

  // Pending game over delay for death animation.
  int _deathAnimTicksLeft = 0;
  RunEndReason? _pendingRunEndReason;
  DeathInfo? _pendingDeathInfo;

  // ─── ECS Systems ───
  // Stateless processors that operate on component stores.

  late final PlayerMovementSystem _movementSystem;
  late final MobilitySystem _mobilitySystem;
  late final CollisionSystem _collisionSystem;
  late final CooldownSystem _cooldownSystem;
  late final GravitySystem _gravitySystem;
  late final ProjectileSystem _projectileSystem;
  late final ProjectileHitSystem _projectileHitSystem;
  late final ProjectileWorldCollisionSystem _projectileWorldCollisionSystem;
  late final BroadphaseGrid _broadphaseGrid;
  late final HitboxFollowOwnerSystem _hitboxFollowOwnerSystem;
  late final CollectibleSystem _collectibleSystem;
  late final RestorationItemSystem _restorationItemSystem;
  late final LifetimeSystem _lifetimeSystem;
  late final InvulnerabilitySystem _invulnerabilitySystem;
  late final DamageMiddlewareSystem _damageMiddlewareSystem;
  late final DamageSystem _damageSystem;
  late final StatusSystem _statusSystem;
  late final ControlLockSystem _controlLockSystem;
  late final ActiveAbilityPhaseSystem _activeAbilityPhaseSystem;
  late final HealthDespawnSystem _healthDespawnSystem;
  late final EnemyDeathStateSystem _enemyDeathStateSystem;
  late final DeathDespawnSystem _deathDespawnSystem;
  late EnemyNavigationSystem _enemyNavigationSystem;
  late EnemyEngagementSystem _enemyEngagementSystem;
  late GroundEnemyLocomotionSystem _groundEnemyLocomotionSystem;
  late FlyingEnemyLocomotionSystem _flyingEnemyLocomotionSystem;
  late EnemyCastSystem _enemyCastSystem;
  late EnemyMeleeSystem _enemyMeleeSystem;
  late final SurfaceGraphBuilder _surfaceGraphBuilder;
  late final JumpReachabilityTemplate _groundEnemyJumpTemplate;
  late final SurfacePathfinder _surfacePathfinder;
  late final SurfaceNavigator _surfaceNavigator;
  late final AbilityActivationSystem _abilityActivationSystem;
  late final SelfAbilitySystem _selfAbilitySystem;
  late final MeleeStrikeSystem _meleeStrikeSystem;
  late final ProjectileLaunchSystem _projectileLaunchSystem;
  late final HitboxDamageSystem _hitboxDamageSystem;
  late final ResourceRegenSystem _resourceRegenSystem;
  late final AnimSystem _animSystem;
  late final EnemyCullSystem _enemyCullSystem;

  // ─── Modular Services ───
  // Extracted modules for specific responsibilities.

  /// Entity spawning with deterministic placement.
  late final SpawnService _spawnService;

  /// Track streaming, geometry lifecycle, navigation updates.
  late final TrackManager _trackManager;

  /// ECS → render snapshot conversion.
  late SnapshotBuilder _snapshotBuilder;

  // ─── Camera ───

  /// Autoscrolling camera that follows and pushes the player.
  late final AutoscrollCamera _camera;

  // ─── Event Queue ───

  /// Pending events to be consumed by UI (drained each frame).
  final List<GameEvent> _events = <GameEvent>[];

  // ─── Scratch/Tracking State ───

  /// Scratch list for killed enemies (reused to avoid allocation).
  final List<EnemyId> _killedEnemiesScratch = <EnemyId>[];

  /// Kill counts per enemy type (indexed by [EnemyId.index]).
  final List<int> _enemyKillCounts = List<int>.filled(EnemyId.values.length, 0);

  // ─── Simulation State ───

  /// Current simulation tick (increments each [stepOneTick]).
  int tick = 0;

  /// Whether simulation is paused (commands still apply, time doesn't advance).
  bool paused = false;

  /// Whether the run has ended (simulation is frozen permanently).
  bool gameOver = false;

  /// Total distance traveled (world units, not meters).
  double distance = 0;

  /// Number of collectibles picked up this run.
  int collectibles = 0;

  /// Total score from collectibles.
  int collectibleScore = 0;

  // ─────────────────────────────────────────────────────────────────────────
  // Public Accessors
  // ─────────────────────────────────────────────────────────────────────────

  /// Level identifier for this run (stable across sessions).
  LevelId get levelId => _levelDefinition.id;

  /// Optional render theme identifier for this run.
  String? get themeId => _levelDefinition.themeId;

  /// Score tuning for UI display and leaderboard calculation.
  ScoreTuning get scoreTuning => _scoreTuning;

  /// Enemy catalog for render-side animation loading.
  EnemyCatalog get enemyCatalog => _enemyCatalog;

  /// Current static world geometry (base + streamed chunks).
  StaticWorldGeometry get staticWorldGeometry => _trackManager.staticGeometry;

  /// Player X position in world coordinates.
  double get playerPosX =>
      _world.transform.posX[_world.transform.indexOf(_player)];

  /// Player Y position in world coordinates.
  double get playerPosY =>
      _world.transform.posY[_world.transform.indexOf(_player)];

  /// Sets player position (for tests or teleportation).
  void setPlayerPosXY(double x, double y) =>
      _world.transform.setPosXY(_player, x, y);

  /// Player X velocity (positive = moving right).
  double get playerVelX =>
      _world.transform.velX[_world.transform.indexOf(_player)];

  /// Player Y velocity (positive = moving down).
  double get playerVelY =>
      _world.transform.velY[_world.transform.indexOf(_player)];

  /// Sets player velocity (for tests or knockback effects).
  void setPlayerVelXY(double x, double y) =>
      _world.transform.setVelXY(_player, x, y);

  /// Whether the player is currently on the ground.
  bool get playerGrounded =>
      _world.collision.grounded[_world.collision.indexOf(_player)];

  /// Player facing direction (left or right).
  Facing get playerFacing =>
      _world.movement.facing[_world.movement.indexOf(_player)];

  /// Sets player facing direction.
  set playerFacing(Facing value) {
    _world.movement.facing[_world.movement.indexOf(_player)] = value;
  }

  /// Remaining projectile cooldown ticks.
  /// Remaining projectile cooldown ticks.
  int get playerProjectileCooldownTicksLeft =>
      _world.cooldown.getTicksLeft(_player, CooldownGroup.projectile);

  /// Remaining melee strike cooldown ticks.
  int get playerMeleeCooldownTicksLeft =>
      _world.cooldown.getTicksLeft(_player, CooldownGroup.primary);

  // ─────────────────────────────────────────────────────────────────────────
  // Command Processing
  // ─────────────────────────────────────────────────────────────────────────

  /// Applies all commands scheduled for the current tick.
  ///
  /// Commands are the only way external code can influence the simulation.
  /// Each command type maps to a specific player input flag or value:
  ///
  /// - [MoveAxisCommand]: Sets horizontal movement axis (-1 to 1).
  /// - [JumpPressedCommand]: Triggers a jump attempt.
  /// - [DashPressedCommand]: Triggers a dash attempt.
  /// - [StrikePressedCommand]: Triggers an strike attempt.
  /// - [SecondaryPressedCommand]: Triggers an off-hand ability attempt.
  /// - [ProjectileAimDirCommand]: Sets projectile aim direction.
  /// - [MeleeAimDirCommand]: Sets melee strike direction.
  /// - [ProjectilePressedCommand]: Triggers the projectile slot attempt.
  /// - [BonusPressedCommand]: Triggers a bonus-slot ability attempt.
  ///
  /// Commands are processed before [stepOneTick] to ensure inputs are
  /// available when systems read them.
  void applyCommands(List<Command> commands) {
    // Reset all input flags to their default state.
    _world.playerInput.resetTickInputs(_player);
    final inputIndex = _world.playerInput.indexOf(_player);
    final movementIndex = _world.movement.indexOf(_player);

    for (final command in commands) {
      switch (command) {
        // Movement axis: -1 (left) to +1 (right).
        case MoveAxisCommand(:final axis):
          final clamped = axis.clamp(-1.0, 1.0);
          _world.playerInput.moveAxis[inputIndex] = clamped;
          // Update facing direction unless dashing (locked during dash).
          if (_world.movement.dashTicksLeft[movementIndex] == 0) {
            if (clamped < 0) {
              playerFacing = Facing.left;
            } else if (clamped > 0) {
              playerFacing = Facing.right;
            }
          }

        // Jump: Consumed by AbilityActivationSystem (mobility), executed by PlayerMovementSystem.
        case JumpPressedCommand():
          _world.playerInput.jumpPressed[inputIndex] = true;

        // Dash: Consumed by AbilityActivationSystem (mobility).
        case DashPressedCommand():
          _world.playerInput.dashPressed[inputIndex] = true;

        // Strike: Consumed by AbilityActivationSystem.
        case StrikePressedCommand():
          _world.playerInput.strikePressed[inputIndex] = true;
          _world.playerInput.hasAbilitySlotPressed[inputIndex] = true;
          _world.playerInput.lastAbilitySlotPressed[inputIndex] =
              AbilitySlot.primary;

        // Secondary: Consumed by AbilityActivationSystem.
        case SecondaryPressedCommand():
          _world.playerInput.secondaryPressed[inputIndex] = true;
          _world.playerInput.hasAbilitySlotPressed[inputIndex] = true;
          _world.playerInput.lastAbilitySlotPressed[inputIndex] =
              AbilitySlot.secondary;

        // Projectile aim: Direction vector for projectile abilities.
        case ProjectileAimDirCommand(:final x, :final y):
          _world.playerInput.projectileAimDirX[inputIndex] = x;
          _world.playerInput.projectileAimDirY[inputIndex] = y;

        // Melee aim: Direction vector for melee strikes.
        case MeleeAimDirCommand(:final x, :final y):
          _world.playerInput.meleeAimDirX[inputIndex] = x;
          _world.playerInput.meleeAimDirY[inputIndex] = y;

        // Clear projectile aim: Resets to no-aim state.
        case ClearProjectileAimDirCommand():
          _world.playerInput.projectileAimDirX[inputIndex] = 0;
          _world.playerInput.projectileAimDirY[inputIndex] = 0;

        // Clear melee aim: Resets to no-aim state.
        case ClearMeleeAimDirCommand():
          _world.playerInput.meleeAimDirX[inputIndex] = 0;
          _world.playerInput.meleeAimDirY[inputIndex] = 0;

        // Projectile slot: unified input for spells or throws.
        case ProjectilePressedCommand():
          _world.playerInput.projectilePressed[inputIndex] = true;
          _world.playerInput.hasAbilitySlotPressed[inputIndex] = true;
          _world.playerInput.lastAbilitySlotPressed[inputIndex] =
              AbilitySlot.projectile;

        // Bonus slot input.
        case BonusPressedCommand():
          _world.playerInput.bonusPressed[inputIndex] = true;
          _world.playerInput.hasAbilitySlotPressed[inputIndex] = true;
          _world.playerInput.lastAbilitySlotPressed[inputIndex] =
              AbilitySlot.bonus;
      }
    }
  }

  // ─────────────────────────────────────────────────────────────────────────
  // Simulation Tick
  // ─────────────────────────────────────────────────────────────────────────

  /// Advances the simulation by exactly one fixed tick.
  ///
  /// This is the main simulation loop. It executes all ECS systems in a
  /// carefully ordered pipeline to ensure correct behavior:
  ///
  /// 1. **Track streaming**: Generate/cull chunks, spawn enemies.
  /// 2. **Cooldowns**: Decrement ability and invulnerability timers.
  /// 3. **Enemy AI**: Compute paths and movement intentions.
  /// 4. **Player input**: Resolve ability intents (including mobility).
  /// 5. **Player movement**: Apply input to velocity.
  /// 6. **Mobility execution**: Apply dash/roll state.
  /// 7. **Gravity**: Apply gravitational acceleration.
  /// 8. **Collision**: Resolve against static world geometry.
  /// 9. **Death checks**: Detect fall-into-gap and fell-behind-camera.
  /// 10. **Camera update**: Advance autoscroll position.
  /// 11. **Pickups**: Process collectible and restoration item collection.
  /// 12. **Broadphase**: Rebuild spatial grid for hit detection.
  /// 13. **Projectiles**: Move existing projectiles.
  /// 14. **Strike intents**: Queue enemy and player strikes.
  /// 15. **Strike execution**: Spawn hitboxes/projectiles/self abilities from intents.
  /// 16. **Hitbox positioning**: Update hitbox positions from owners.
  /// 17. **Hit detection**: Check projectile and hitbox overlaps.
  /// 18. **Status ticking**: Apply DoT ticks and queue damage.
  /// 19. **Damage middleware**: Apply combat rule edits/cancellations.
  /// 20. **Damage application**: Apply queued damage events.
  /// 21. **Status application**: Apply on-hit status profiles.
  /// 22. **Death handling**: Despawn dead entities, record kills.
  /// 23. **Resource regen**: Regenerate mana and stamina.
  /// 24. **Animation**: Compute per-entity anim key + frame.
  /// 25. **Cleanup**: Remove entities past their lifetime.
  ///
  /// If the run ends during this tick (player death, fell into gap, etc.),
  /// a [RunEndedEvent] is emitted and the simulation freezes.
  void stepOneTick() {
    // Don't advance if paused or game already over.
    if (paused || gameOver) return;

    if (_deathAnimTicksLeft > 0) {
      tick += 1;
      // Update animations during death anim freeze.
      _animSystem.step(_world, player: _player, currentTick: tick);
      _deathAnimTicksLeft -= 1;
      if (_deathAnimTicksLeft <= 0) {
        _endRun(
          _pendingRunEndReason ?? RunEndReason.playerDied,
          deathInfo: _pendingDeathInfo,
        );
      }
      return;
    }

    tick += 1;

    // Cache ground Y once per tick (ground plane doesn't change mid-tick).
    final effectiveGroundTopY =
        staticWorldGeometry.groundPlane?.topY ?? groundTopY.toDouble();

    // ─── Phase 1: World generation ───
    _stepTrackManager(effectiveGroundTopY);

    // ─── Phase 2: Timer decrements ───
    _cooldownSystem.step(_world);
    _invulnerabilitySystem.step(_world);

    // ─── Phase 2.5: Control lock refresh ───
    // Must run before any gameplay systems that check locks.
    _controlLockSystem.step(_world, currentTick: tick);

    // ─── Phase 2.75: Active ability phase update ───
    _activeAbilityPhaseSystem.step(_world, currentTick: tick);

    // ─── Phase 3: AI, input, and movement ───
    _enemyNavigationSystem.step(_world, player: _player, currentTick: tick);
    _enemyEngagementSystem.step(_world, player: _player, currentTick: tick);
    _groundEnemyLocomotionSystem.step(
      _world,
      player: _player,
      dtSeconds: _movement.dtSeconds,
      currentTick: tick,
    );
    _flyingEnemyLocomotionSystem.step(
      _world,
      player: _player,
      groundTopY: effectiveGroundTopY,
      dtSeconds: _movement.dtSeconds,
      currentTick: tick,
    );

    _abilityActivationSystem.step(_world, player: _player, currentTick: tick);
    _movementSystem.step(
      _world,
      _movement,
      resources: _resourceTuning,
      currentTick: tick,
    );
    _mobilitySystem.step(_world, _movement, currentTick: tick);
    _gravitySystem.step(_world, _movement, physics: _physicsTuning);
    _collisionSystem.step(
      _world,
      _movement,
      staticWorld: _trackManager.staticIndex,
    );

    // ─── Phase 4: Distance tracking ───
    // Only count forward movement (positive X velocity).
    distance += max(0.0, playerVelX) * _movement.dtSeconds;

    // ─── Phase 5: Death condition checks ───
    if (_checkFellIntoGap(effectiveGroundTopY)) {
      _endRun(RunEndReason.fellIntoGap);
      return;
    }

    _camera.updateTick(dtSeconds: _movement.dtSeconds, playerX: playerPosX);
    if (_checkFellBehindCamera()) {
      _endRun(RunEndReason.fellBehindCamera);
      return;
    }

    // ─── Phase 6: Pickup collection ───
    _collectibleSystem.step(
      _world,
      player: _player,
      cameraLeft: _camera.left(),
      tuning: _collectibleTuning,
      onCollected: (value) {
        collectibles += 1;
        collectibleScore += value;
      },
    );
    _restorationItemSystem.step(
      _world,
      player: _player,
      cameraLeft: _camera.left(),
      tuning: _restorationItemTuning,
    );

    // ─── Phase 7: Spatial grid rebuild ───
    // Must happen before hit detection to ensure accurate overlaps.
    _broadphaseGrid.rebuild(_world);

    // ─── Phase 8: Projectile movement ───
    // Move existing projectiles before spawning new ones.
    _projectileSystem.step(_world, _movement);

    // ─── Phase 9: Strike intent writing ───
    // Enemy intent writing only.
    // Player intents are written at commit-time in Phase 3 (AbilityActivationSystem),
    // then executed later via stamped executeTick. Keep ordering explicit for tie-breaks.
    _enemyCastSystem.step(_world, player: _player, currentTick: tick);
    _enemyMeleeSystem.step(_world, player: _player, currentTick: tick);

    // ─── Phase 10: Strike execution ───
    _selfAbilitySystem.step(_world, currentTick: tick);
    // Convert intents into actual hitboxes/projectiles.
    // Self abilities first so buffs/blocks/i-frames can affect spawns & downstream combat deterministically.
    _meleeStrikeSystem.step(_world, currentTick: tick);
    _projectileLaunchSystem.step(_world, currentTick: tick);

    // ─── Phase 11: Hitbox positioning ───
    // Update hitbox transforms to follow their owner entities.
    _hitboxFollowOwnerSystem.step(_world);

    // ─── Phase 12: Hit resolution ───
    // Detect overlaps and queue damage events.
    _projectileHitSystem.step(
      _world,
      _broadphaseGrid,
      currentTick: tick,
      queueHitEvent: (event) => _events.add(event),
    );
    _hitboxDamageSystem.step(_world, _broadphaseGrid, currentTick: tick);
    _projectileWorldCollisionSystem.step(_world);
    // ─── Phase 13: Status + damage ───
    _statusSystem.tickExisting(_world);
    _damageMiddlewareSystem.step(_world, currentTick: tick);
    _damageSystem.step(
      _world,
      currentTick: tick,
      queueStatus: _statusSystem.queue,
    );
    _statusSystem.applyQueued(_world, currentTick: tick);

    // ─── Phase 14: Death handling ───
    _killedEnemiesScratch.clear();
    _enemyCullSystem.step(
      _world,
      cameraLeft: _camera.left(),
      groundTopY: effectiveGroundTopY,
      tuning: _trackTuning,
    );
    _enemyDeathStateSystem.step(
      _world,
      currentTick: tick,
      outEnemiesKilled: _killedEnemiesScratch,
    );
    _deathDespawnSystem.step(_world, currentTick: tick);
    _healthDespawnSystem.step(_world, player: _player);
    if (_killedEnemiesScratch.isNotEmpty) {
      _recordEnemyKills(_killedEnemiesScratch);
    }
    if (_isPlayerDead()) {
      if (_deathAnimTicksLeft <= 0) {
        _pendingRunEndReason = RunEndReason.playerDied;
        _pendingDeathInfo = _buildDeathInfo();
        if (_animTuning.deathAnimTicks <= 0) {
          _endRun(_pendingRunEndReason!, deathInfo: _pendingDeathInfo);
        } else {
          _deathAnimTicksLeft = _animTuning.deathAnimTicks;
        }
      }
      return;
    }

    // ─── Phase 15: Resource regeneration ───
    _resourceRegenSystem.step(_world);

    // ─── Phase 16: Animation ───
    _animSystem.step(_world, player: _player, currentTick: tick);

    // ─── Phase 17: Cleanup ───
    _lifetimeSystem.step(_world);
  }

  /// Steps the track manager and handles enemy spawning callbacks.
  ///
  /// This is extracted from [stepOneTick] to keep the main loop readable.
  void _stepTrackManager(double effectiveGroundTopY) {
    _trackManager.step(
      cameraLeft: _camera.left(),
      cameraRight: _camera.right(),
      spawnEnemy: (enemyId, x) {
        // Route spawn requests to the appropriate SpawnService method.
        switch (enemyId) {
          case EnemyId.unocoDemon:
            _spawnService.spawnUnocoDemon(
              spawnX: x,
              groundTopY: effectiveGroundTopY,
            );
          case EnemyId.grojib:
            _spawnService.spawnGroundEnemy(
              spawnX: x,
              groundTopY: effectiveGroundTopY,
            );
        }
      },
      lowestResourceStat: _lowestResourceStat,
    );
  }

  // ─────────────────────────────────────────────────────────────────────────
  // Run End Handling
  // ─────────────────────────────────────────────────────────────────────────

  /// Ends the current run and emits a [RunEndedEvent].
  ///
  /// After this call, [gameOver] is true and [stepOneTick] will no-op.
  void _endRun(RunEndReason reason, {DeathInfo? deathInfo}) {
    gameOver = true;
    paused = true;
    final goldEarned = computeGoldEarned(
      collectiblesCollected: collectibles,
    );
    _events.add(
      RunEndedEvent(
        runId: runId,
        tick: tick,
        distance: distance,
        reason: reason,
        stats: _buildRunEndStats(),
        goldEarned: goldEarned,
        deathInfo: deathInfo,
      ),
    );
  }

  /// Manually ends the run (e.g., from pause menu).
  ///
  /// Does nothing if the game is already over.
  void giveUp() {
    if (gameOver) return;
    _endRun(RunEndReason.gaveUp);
  }

  /// Records enemy kills for score calculation.
  void _recordEnemyKills(List<EnemyId> killedEnemies) {
    for (final enemyId in killedEnemies) {
      final index = enemyId.index;
      if (index >= 0 && index < _enemyKillCounts.length) {
        _enemyKillCounts[index] += 1;
      }
    }
  }

  /// Builds run statistics for the end-of-run event.
  RunEndStats _buildRunEndStats() => RunEndStats(
    collectibles: collectibles,
    collectibleScore: collectibleScore,
    enemyKillCounts: List<int>.unmodifiable(_enemyKillCounts),
  );

  /// Checks if the player's HP has reached zero.
  bool _isPlayerDead() {
    final hi = _world.health.tryIndexOf(_player);
    if (hi == null) return false;
    return _world.health.hp[hi] <= 0;
  }

  /// Builds death info for the run-ended event.
  ///
  /// This provides details about what killed the player (enemy type,
  /// projectile type, etc.) for death screen messaging.
  DeathInfo? _buildDeathInfo() {
    final li = _world.lastDamage.tryIndexOf(_player);
    if (li == null) return null;

    final kind = _world.lastDamage.kind[li];
    if (kind == DeathSourceKind.unknown) return null;

    return DeathInfo(
      kind: kind,
      enemyId: _world.lastDamage.hasEnemyId[li]
          ? _world.lastDamage.enemyId[li]
          : null,
      projectileId: _world.lastDamage.hasProjectileId[li]
          ? _world.lastDamage.projectileId[li]
          : null,
      projectileItemId: _world.lastDamage.hasProjectileItemId[li]
          ? _world.lastDamage.projectileItemId[li]
          : null,
    );
  }

  // ─────────────────────────────────────────────────────────────────────────
  // Death Condition Checks
  // ─────────────────────────────────────────────────────────────────────────

  /// Checks if the player has fallen behind the camera's left edge.
  ///
  /// This is a "soft" death—the player can still be on solid ground but
  /// has failed to keep up with the autoscrolling camera.
  bool _checkFellBehindCamera() {
    if (!(_world.transform.has(_player) && _world.colliderAabb.has(_player))) {
      return false;
    }

    final ti = _world.transform.indexOf(_player);
    final ai = _world.colliderAabb.indexOf(_player);
    final centerX = _world.transform.posX[ti] + _world.colliderAabb.offsetX[ai];
    final right = centerX + _world.colliderAabb.halfX[ai];

    // Player's right edge must stay ahead of camera's left edge.
    return right < _camera.left();
  }

  /// Checks if the player has fallen into a ground gap (pit).
  ///
  /// The kill threshold is set well below ground level to give visual
  /// feedback of falling before the death triggers. Configured via
  /// [TrackTuning.gapKillOffsetY].
  bool _checkFellIntoGap(double groundTopY) {
    if (!(_world.transform.has(_player) && _world.colliderAabb.has(_player))) {
      return false;
    }

    final ti = _world.transform.indexOf(_player);
    final ai = _world.colliderAabb.indexOf(_player);
    final bottomY =
        _world.transform.posY[ti] +
        _world.colliderAabb.offsetY[ai] +
        _world.colliderAabb.halfY[ai];

    return bottomY > groundTopY + _trackTuning.gapKillOffsetY;
  }

  // ─────────────────────────────────────────────────────────────────────────
  // Resource Helpers
  // ─────────────────────────────────────────────────────────────────────────

  /// Returns the player's most depleted resource stat.
  ///
  /// Used by restoration item spawning to bias item type toward what
  /// the player needs most. Compares ratios (current/max) to handle
  /// resources with different maximum values fairly.
  ///
  /// **Tie-breaking priority**: When ratios are equal, the first resource
  /// checked wins: health > mana > stamina. This is intentional—health
  /// is prioritized as the most critical survival resource.
  RestorationStat _lowestResourceStat() {
    final hi = _world.health.tryIndexOf(_player);
    final mi = _world.mana.tryIndexOf(_player);
    final si = _world.stamina.tryIndexOf(_player);
    if (hi == null || mi == null || si == null) {
      return RestorationStat.health;
    }

    // Start with health as baseline.
    var best = RestorationStat.health;
    var bestValue = _world.health.hp[hi];
    var bestMax = _world.health.hpMax[hi];

    // Compare mana ratio.
    final mana = _world.mana.mana[mi];
    final manaMax = _world.mana.manaMax[mi];
    if (_ratioLess(mana, manaMax, bestValue, bestMax)) {
      best = RestorationStat.mana;
      bestValue = mana;
      bestMax = manaMax;
    }

    // Compare stamina ratio.
    final stamina = _world.stamina.stamina[si];
    final staminaMax = _world.stamina.staminaMax[si];
    if (_ratioLess(stamina, staminaMax, bestValue, bestMax)) {
      best = RestorationStat.stamina;
    }

    return best;
  }

  /// Compares two ratios without division: (valueA / maxA) < (valueB / maxB).
  ///
  /// Cross-multiplies to avoid division: valueA * maxB < valueB * maxA.
  bool _ratioLess(int valueA, int maxA, int valueB, int maxB) {
    if (maxA <= 0) return false; // Invalid ratio A, can't be less.
    if (maxB <= 0) return true; // Invalid ratio B, A wins by default.
    return valueA * maxB < valueB * maxA;
  }

  /// Computes the maximum air time (in ticks) for ground enemy jumps.
  ///
  /// Based on projectile motion: time = 2 * jumpSpeed / gravity.
  /// Multiplied by 1.5 for safety margin (accounts for landing tolerance).
  int _groundEnemyMaxAirTicks() {
    final gravity = _physicsTuning.gravityY;
    if (gravity <= 0) {
      // No gravity means infinite air time; cap at 1 second.
      return ticksFromSecondsCeil(1.0, tickHz);
    }
    final jumpSpeed = _groundEnemyTuning.locomotion.jumpSpeed.abs();
    final baseAirSeconds = (2.0 * jumpSpeed) / gravity;
    return ticksFromSecondsCeil(baseAirSeconds * 1.5, tickHz);
  }

  // ─────────────────────────────────────────────────────────────────────────
  // Events & Snapshots
  // ─────────────────────────────────────────────────────────────────────────

  /// Drains and returns all pending game events.
  ///
  /// Events are produced during [stepOneTick] (e.g., [RunEndedEvent]).
  /// The UI layer should call this after each tick to process events.
  ///
  /// Returns an empty list if no events are pending (avoids allocation).
  List<GameEvent> drainEvents() {
    if (_events.isEmpty) return const <GameEvent>[];
    final drained = List<GameEvent>.unmodifiable(_events);
    _events.clear();
    return drained;
  }

  /// Builds an immutable snapshot for render/UI consumption.
  ///
  /// The snapshot contains everything needed to render a single frame:
  /// - Entity positions, velocities, and animations
  /// - Player HUD data (HP, mana, stamina, cooldowns)
  /// - Static geometry (platforms, ground gaps)
  /// - Camera position
  ///
  /// Snapshots are immutable and safe to pass to async render code.
  GameStateSnapshot buildSnapshot() {
    return _snapshotBuilder.build(
      tick: tick,
      runId: runId,
      seed: seed,
      levelId: levelId,
      themeId: themeId,
      distance: distance,
      paused: paused,
      gameOver: gameOver,
      cameraCenterX: _camera.state.centerX,
      cameraCenterY: cameraFixedY,
      collectibles: collectibles,
      collectibleScore: collectibleScore,
      staticSolids: _trackManager.staticSolidsSnapshot,
      groundGaps: _trackManager.staticGroundGapsSnapshot,
    );
  }
}


===== FILE: lib/core/levels/level_definition.dart =====
/// Data-first definition of a level configuration (Core-only).
library;

import '../collision/static_world_geometry.dart';
import '../contracts/render_contract.dart';
import '../track/chunk_pattern_pool.dart';
import '../tuning/core_tuning.dart';
import 'level_id.dart';

/// Core configuration for a single level.
///
/// This is pure data: no Flutter/Flame imports and no runtime side effects.
class LevelDefinition {
  const LevelDefinition({
    required this.id,
    required this.patternPool,
    this.tuning = const CoreTuning(),
    this.staticWorldGeometry = const StaticWorldGeometry(
      groundPlane: StaticGroundPlane(topY: groundTopY * 1.0),
    ),
    this.earlyPatternChunks = defaultEarlyPatternChunks,
    this.noEnemyChunks = defaultNoEnemyChunks,
    this.themeId,
  }) : assert(earlyPatternChunks >= 0),
       assert(noEnemyChunks >= 0);

  /// Stable identifier for this level.
  final LevelId id;

  /// Core tuning overrides for this level.
  final CoreTuning tuning;

  /// Base collision geometry for the level (ground + fixed platforms).
  final StaticWorldGeometry staticWorldGeometry;

  /// Pattern pool used for procedural chunk generation.
  final ChunkPatternPool patternPool;

  /// Number of early chunks that use [patternPool.easyPatterns].
  final int earlyPatternChunks;

  /// Number of early chunks that suppress enemy spawns.
  final int noEnemyChunks;

  /// Optional render theme identifier (e.g., lookup key for assets).
  final String? themeId;
}


===== FILE: lib/core/levels/level_id.dart =====
/// Stable identifiers for level definitions.
///
/// Avoid renaming or reordering values; treat as protocol-stable.
enum LevelId {
  /// The default runner level.
  defaultLevel,
  forest,
  field,
}


===== FILE: lib/core/levels/level_registry.dart =====
/// Registry for core level definitions.
library;

import '../track/chunk_pattern_pool.dart';
import '../track/chunk_patterns_library.dart';
import 'level_definition.dart';
import 'level_id.dart';

/// Default pattern pool (matches current behavior).
const ChunkPatternPool defaultPatternPool = ChunkPatternPool(
  easyPatterns: easyPatterns,
  allPatterns: allPatterns,
);

/// Default level definition.
const LevelDefinition defaultLevelDefinition = LevelDefinition(
  id: LevelId.defaultLevel,
  patternPool: defaultPatternPool,
  themeId: 'forest',
);

/// Resolves level definitions by stable [LevelId].
class LevelRegistry {
  const LevelRegistry._();

  /// Default level used when no level is specified.
  static const LevelDefinition defaultLevel = defaultLevelDefinition;

  /// Returns the level definition for a given [LevelId].
  static LevelDefinition byId(LevelId id) {
    switch (id) {
      case LevelId.forest:
        return LevelDefinition(
          id: LevelId.forest,
          patternPool: defaultPatternPool,
          themeId: 'forest',
        );
      case LevelId.field:
        return LevelDefinition(
          id: LevelId.field,
          patternPool: defaultPatternPool,
          themeId: 'field',
        );
      case LevelId.defaultLevel:
        return defaultLevelDefinition;
    }
  }
}


===== FILE: lib/core/loadout/loadout_issue.dart =====
import '../abilities/ability_def.dart';

/// The kind of issue found during loadout validation.
enum IssueKind {
  /// Ability is not allowed in this slot (checked against `allowedSlots`).
  slotNotAllowed,

  /// Equipped weapon definition does not match the slot's expected category.
  weaponCategoryMismatch,

  /// Equipped weapon (or effective weapon) lacks tags required by the ability.
  missingRequiredTags,

  /// Equipped weapon (or effective weapon) lacks required weapon types.
  missingRequiredWeaponTypes,

  /// Ability requires an equipped weapon, but none is present.
  requiresEquippedWeapon,

  /// Two-handed primary weapon conflicts with a separately equipped off-hand item.
  twoHandedConflict,

  /// References a definition that does not exist in the catalog.
  catalogMissing,
}

/// A single validation error or warning for a loadout.
class LoadoutIssue {
  const LoadoutIssue({
    required this.slot,
    required this.kind,
    this.abilityId,
    this.weaponId,
    this.missingTags = const {},
    this.missingWeaponTypes = const {},
    this.message = '',
  });

  /// The slot where the issue occurred.
  final AbilitySlot slot;

  /// The specific kind of validation failure.
  final IssueKind kind;

  /// The ID of the ability involved, if known.
  final String? abilityId;

  /// The ID of the weapon involved, if known.
  final String? weaponId;

  /// If [kind] is [missingRequiredTags], this set contains the missing tags.
  final Set<AbilityTag> missingTags;

  /// If [kind] is [missingRequiredWeaponTypes], this set contains the missing types.
  final Set<WeaponType> missingWeaponTypes;

  /// A human-readable message describing the issue.
  final String message;

  @override
  String toString() {
    return 'LoadoutIssue($slot, $kind, ability:$abilityId, weapon:$weaponId, missingTags:$missingTags, missingWeaponTypes:$missingWeaponTypes)';
  }
}


===== FILE: lib/core/loadout/loadout_validation_result.dart =====
import 'loadout_issue.dart';

/// Result of a full loadout validation pass.
class LoadoutValidationResult {
  const LoadoutValidationResult({
    required this.isValid,
    this.issues = const [],
  });

  /// A completely valid result with no issues.
  static const LoadoutValidationResult valid = LoadoutValidationResult(isValid: true);

  /// Creates an invalid result with a list of issues.
  factory LoadoutValidationResult.invalid(List<LoadoutIssue> issues) =>
      LoadoutValidationResult(isValid: false, issues: issues);

  /// Whether the loadout is considered valid and runnable.
  final bool isValid;

  /// List of issues found during validation.
  final List<LoadoutIssue> issues;
}


===== FILE: lib/core/loadout/loadout_validator.dart =====
import '../abilities/ability_catalog.dart';
import '../abilities/ability_def.dart';
import '../ecs/stores/combat/equipped_loadout_store.dart';
import '../projectiles/projectile_item_catalog.dart';
import '../projectiles/projectile_item_def.dart';
import '../projectiles/projectile_item_id.dart';
import '../weapons/weapon_catalog.dart';
import '../weapons/weapon_category.dart';
import '../weapons/weapon_def.dart';
import '../weapons/weapon_id.dart';
import 'loadout_issue.dart';
import 'loadout_validation_result.dart';

/// Stateless validator for checking loadout legality.
class LoadoutValidator {
  const LoadoutValidator({
    required this.abilityCatalog,
    required this.weaponCatalog,
    required this.projectileItemCatalog,
  });

  final AbilityCatalog abilityCatalog;
  final WeaponCatalog weaponCatalog;
  final ProjectileItemCatalog projectileItemCatalog;

  /// Validates an entire loadout definition.
  LoadoutValidationResult validate(EquippedLoadoutDef loadout) {
    final issues = <LoadoutIssue>[];

    // 1. Resolve Weapons
    final mainWeapon = _resolveWeapon(
      loadout.mainWeaponId,
      WeaponCategory.primary,
      AbilitySlot.primary,
      issues,
    );

    final offhandWeapon = _resolveWeapon(
      loadout.offhandWeaponId,
      WeaponCategory.offHand,
      AbilitySlot.secondary,
      issues,
    );

    final projectileItem = _resolveProjectileItem(
      loadout.projectileItemId,
      AbilitySlot.projectile,
      issues,
    );

    // 2. Derive Effective Weapons (Two-Handed Logic)
    final isTwoHanded = mainWeapon?.isTwoHanded ?? false;

    // Rule: Two-Handed weapon blocks separate secondary weapon
    if (isTwoHanded && offhandWeapon != null) {
      issues.add(LoadoutIssue(
        slot: AbilitySlot.secondary,
        kind: IssueKind.twoHandedConflict,
        weaponId: loadout.offhandWeaponId.toString(),
        message: 'Cannot equip off-hand weapon with two-handed primary.',
      ));
    }

    // Effective weapons for gating
    final effectiveSecondaryWeapon = isTwoHanded ? mainWeapon : offhandWeapon;

    // 3. Validate Slots

    // Primary
    _validateSlot(
      issues: issues,
      abilityId: loadout.abilityPrimaryId,
      slot: AbilitySlot.primary,
      mainWeapon: mainWeapon,
      effectiveSecondaryWeapon: effectiveSecondaryWeapon,
      projectileItem: projectileItem,
    );

    // Secondary
    _validateSlot(
      issues: issues,
      abilityId: loadout.abilitySecondaryId,
      slot: AbilitySlot.secondary,
      mainWeapon: mainWeapon,
      effectiveSecondaryWeapon: effectiveSecondaryWeapon,
      projectileItem: projectileItem,
    );

    // Projectile
    _validateSlot(
      issues: issues,
      abilityId: loadout.abilityProjectileId,
      slot: AbilitySlot.projectile,
      mainWeapon: mainWeapon,
      effectiveSecondaryWeapon: effectiveSecondaryWeapon,
      projectileItem: projectileItem,
    );

    // Mobility (No weapon)
    _validateSlot(
      issues: issues,
      abilityId: loadout.abilityMobilityId,
      slot: AbilitySlot.mobility,
      mainWeapon: mainWeapon,
      effectiveSecondaryWeapon: effectiveSecondaryWeapon,
      projectileItem: projectileItem,
    );

    // Bonus: payload gating is now driven by AbilityDef.payloadSource.
    _validateSlot(
      issues: issues,
      abilityId: loadout.abilityBonusId,
      slot: AbilitySlot.bonus,
      mainWeapon: mainWeapon,
      effectiveSecondaryWeapon: effectiveSecondaryWeapon,
      projectileItem: projectileItem,
    );

    // Jump (Fixed slot, no weapon)
    _validateSlot(
      issues: issues,
      abilityId: loadout.abilityJumpId,
      slot: AbilitySlot.jump,
      mainWeapon: mainWeapon,
      effectiveSecondaryWeapon: effectiveSecondaryWeapon,
      projectileItem: projectileItem,
    );

    return LoadoutValidationResult(
      isValid: issues.isEmpty,
      issues: issues,
    );
  }

  WeaponDef? _resolveWeapon(
    WeaponId id,
    WeaponCategory expectedCategory,
    AbilitySlot slot,
    List<LoadoutIssue> issues,
  ) {
    final weapon = weaponCatalog.tryGet(id);
    if (weapon == null) {
      // If we assume LoadoutStore always has valid defaults, this is a corruption/catalogMissing.
      // If we want to support "none", we'd need a specific ID for it or nullable field.
      // LoadoutDefs are non-nullable IDs.
      // So if tryGet fails, it's catalogMissing.
      issues.add(LoadoutIssue(
        slot: slot,
        kind: IssueKind.catalogMissing,
        weaponId: id.toString(),
        message: 'Weapon ID not found in catalog.',
      ));
      return null;
    }

    if (weapon.category != expectedCategory) {
      issues.add(LoadoutIssue(
        slot: slot,
        kind: IssueKind.weaponCategoryMismatch,
        weaponId: id.toString(),
        message: 'Expected $expectedCategory, found ${weapon.category}.',
      ));
      // Return null so we don't cascade category errors into type errors?
      // Or return weapon so we can still check types?
      // Returning weapon allows more checks, but might be noisy. 
      // Let's return null to fail-fast on this slot's weapon.
      return null;
    }

    return weapon;
  }

  ProjectileItemDef? _resolveProjectileItem(
    ProjectileItemId id,
    AbilitySlot slot,
    List<LoadoutIssue> issues,
  ) {
    final item = projectileItemCatalog.tryGet(id);
    if (item == null) {
      issues.add(LoadoutIssue(
        slot: slot,
        kind: IssueKind.catalogMissing,
        weaponId: id.toString(),
        message: 'Projectile item ID not found in catalog.',
      ));
      return null;
    }
    return item;
  }

  void _validateSlot({
    required List<LoadoutIssue> issues,
    required AbilityKey abilityId,
    required AbilitySlot slot,
    required WeaponDef? mainWeapon,
    required WeaponDef? effectiveSecondaryWeapon,
    required ProjectileItemDef? projectileItem,
  }) {
    final ability = abilityCatalog.resolve(abilityId);
    if (ability == null) {
      issues.add(LoadoutIssue(
        slot: slot,
        kind: IssueKind.catalogMissing,
        abilityId: abilityId,
        message: 'Ability ID not found in catalog.',
      ));
      return;
    }

    final (hasWeapon, weaponType) = _payloadContextFor(
      ability,
      mainWeapon: mainWeapon,
      effectiveSecondaryWeapon: effectiveSecondaryWeapon,
      projectileItem: projectileItem,
    );

    // 1. Slot Compatibility
    if (!ability.allowedSlots.contains(slot)) {
      issues.add(LoadoutIssue(
        slot: slot,
        kind: IssueKind.slotNotAllowed,
        abilityId: abilityId,
        message: 'Ability not allowed in $slot slot.',
      ));
    }

    // 2. Weapon Presence
    if (ability.requiresEquippedWeapon && !hasWeapon) {
      issues.add(LoadoutIssue(
        slot: slot,
        kind: IssueKind.requiresEquippedWeapon,
        abilityId: abilityId,
        message: 'Ability requires an equipped weapon.',
      ));
    }

    // 3. Weapon Type Gating
    if (ability.requiredWeaponTypes.isNotEmpty) {
      if (weaponType == null ||
          !ability.requiredWeaponTypes.contains(weaponType)) {
        issues.add(LoadoutIssue(
          slot: slot,
          kind: IssueKind.missingRequiredWeaponTypes,
          abilityId: abilityId,
          missingWeaponTypes: ability.requiredWeaponTypes,
          message: 'Missing required weapon types: ${ability.requiredWeaponTypes.join(", ")}.',
        ));
      }
    }
  }

  (bool hasWeapon, WeaponType? weaponType) _payloadContextFor(
    AbilityDef ability, {
    required WeaponDef? mainWeapon,
    required WeaponDef? effectiveSecondaryWeapon,
    required ProjectileItemDef? projectileItem,
  }) {
    switch (ability.payloadSource) {
      case AbilityPayloadSource.none:
        return (false, null);
      case AbilityPayloadSource.primaryWeapon:
        return (mainWeapon != null, mainWeapon?.weaponType);
      case AbilityPayloadSource.secondaryWeapon:
        // effectiveSecondaryWeapon already applies two-handed mapping
        return (effectiveSecondaryWeapon != null, effectiveSecondaryWeapon?.weaponType);
      case AbilityPayloadSource.projectileItem:
        return (projectileItem != null, projectileItem?.weaponType);
    }
  }
}


===== FILE: lib/core/navigation/surface_extractor.dart =====
import '../collision/static_world_geometry.dart';
import 'types/nav_tolerances.dart';
import 'types/surface_id.dart';
import 'types/walk_surface.dart';

/// Extracts [WalkSurface]s from tile-based world geometry.
///
/// **Pipeline**:
/// 1. Collect top faces of solid tiles as raw segments.
/// 2. Process ground layer (explicit segments or infinite plane).
/// 3. Subtract blockers (solids/gaps) from ground.
/// 4. Sort and merge adjacent coplanar segments.
///
/// **ID Assignment**:
/// Each surface gets a unique ID via [packSurfaceId], encoding chunk and local
/// indices. This enables stable references across graph rebuilds.
class SurfaceExtractor {
  SurfaceExtractor({
    // Use a pixel-ish tolerance by default to avoid fragmenting surfaces due to
    // tiny seams (chunk boundaries, floating error, inclusive/exclusive edges).
    this.mergeEps = navSpatialEps,
    this.groundPadding = 1024.0,
  });

  /// Tolerance for merging adjacent segments (pixels).
  final double mergeEps;

  /// Horizontal padding beyond world bounds for ground plane fallback.
  final double groundPadding;

  /// Extracts walkable surfaces from [geometry].
  ///
  /// **Returns**: Unmodifiable list of [WalkSurface]s, sorted and merged.
  List<WalkSurface> extract(StaticWorldGeometry geometry) {
    final segments = <_SurfaceSegment>[];

    // Stride for ground segment IDs to avoid collisions with tile IDs.
    const groundPieceStride = 1000;

    // -------------------------------------------------------------------------
    // Step 1: Collect solid top faces.
    // -------------------------------------------------------------------------
    var minX = double.infinity;
    var maxX = double.negativeInfinity;
    for (var i = 0; i < geometry.solids.length; i += 1) {
      final solid = geometry.solids[i];

      // Track world bounds for ground plane fallback.
      if (solid.minX < minX) minX = solid.minX;
      if (solid.maxX > maxX) maxX = solid.maxX;

      // Only include solids with a walkable top face.
      if ((solid.sides & StaticSolid.sideTop) == 0) continue;

      var localSolidIndex = solid.localSolidIndex;
      if (localSolidIndex < 0) {
        if (solid.chunkIndex != StaticSolid.noChunk) {
          throw StateError(
            'Chunk solid is missing a localSolidIndex; check track streamer.',
          );
        }
        // Non-chunk solid: use array index as fallback.
        localSolidIndex = i;
      }

      final id = packSurfaceId(
        chunkIndex: solid.chunkIndex,
        localSolidIndex: localSolidIndex,
      );
      segments.add(
        _SurfaceSegment(
          id: id,
          xMin: solid.minX,
          xMax: solid.maxX,
          yTop: solid.minY,
        ),
      );
    }

    // -------------------------------------------------------------------------
    // Step 2: Process ground layer.
    // -------------------------------------------------------------------------
    if (geometry.groundSegments.isNotEmpty) {
      // Explicit ground segments (from level data).
      for (var gi = 0; gi < geometry.groundSegments.length; gi += 1) {
        final ground = geometry.groundSegments[gi];
        var localSegmentIndex = ground.localSegmentIndex;
        if (localSegmentIndex < 0) {
          if (ground.chunkIndex != StaticSolid.noChunk) {
            throw StateError(
              'Ground segment is missing a localSegmentIndex; check track streamer.',
            );
          }
          localSegmentIndex = gi;
        }

        // Subtract solids that block the ground at this Y.
        final blockers = _collectGroundBlockers(
          geometry.solids,
          const <StaticGroundGap>[],
          ground.topY,
          mergeEps,
        );
        final groundSegments = _subtractRanges(
          ground.minX,
          ground.maxX,
          blockers,
          mergeEps,
        );

        // Create surface for each unblocked portion.
        for (var i = 0; i < groundSegments.length; i += 1) {
          final seg = groundSegments[i];
          final id = packSurfaceId(
            chunkIndex: ground.chunkIndex,
            localSolidIndex: localSegmentIndex * groundPieceStride + i,
          );
          segments.add(
            _SurfaceSegment(
              id: id,
              xMin: seg.min,
              xMax: seg.max,
              yTop: ground.topY,
            ),
          );
        }
      }
    } else {
      // Infinite ground plane fallback.
      final groundPlane = geometry.groundPlane;
      if (groundPlane != null) {
        final baseMinX = minX.isFinite ? minX : 0.0;
        final baseMaxX = maxX.isFinite ? maxX : 0.0;
        final groundMinX = baseMinX - groundPadding;
        final groundMaxX = baseMaxX + groundPadding;

        final blockers = _collectGroundBlockers(
          geometry.solids,
          geometry.groundGaps,
          groundPlane.topY,
          mergeEps,
        );
        final groundSegments = _subtractRanges(
          groundMinX,
          groundMaxX,
          blockers,
          mergeEps,
        );

        for (var i = 0; i < groundSegments.length; i += 1) {
          final seg = groundSegments[i];
          segments.add(
            _SurfaceSegment(
              id: packSurfaceId(
                chunkIndex: StaticSolid.groundChunk,
                localSolidIndex: i,
              ),
              xMin: seg.min,
              xMax: seg.max,
              yTop: groundPlane.topY,
            ),
          );
        }
      }
    }

    if (segments.isEmpty) {
      return const <WalkSurface>[];
    }

    // -------------------------------------------------------------------------
    // Step 3: Sort and merge adjacent coplanar segments.
    // -------------------------------------------------------------------------
    segments.sort(_compareSegments);

    final merged = <WalkSurface>[];
    var current = segments.first;
    for (var i = 1; i < segments.length; i += 1) {
      final next = segments[i];
      final sameY = (next.yTop - current.yTop).abs() <= mergeEps;
      final touches = next.xMin <= current.xMax + mergeEps;

      if (sameY && touches) {
        // Extend current segment to include next.
        if (next.xMax > current.xMax) {
          current = current.copyWith(xMax: next.xMax);
        }
      } else {
        // Flush current, start new segment.
        merged.add(
          WalkSurface(
            id: current.id,
            xMin: current.xMin,
            xMax: current.xMax,
            yTop: current.yTop,
          ),
        );
        current = next;
      }
    }

    // Flush final segment.
    merged.add(
      WalkSurface(
        id: current.id,
        xMin: current.xMin,
        xMax: current.xMax,
        yTop: current.yTop,
      ),
    );

    return List<WalkSurface>.unmodifiable(merged);
  }
}

// =============================================================================
// Internal types
// =============================================================================

/// Intermediate segment representation before merging.
class _SurfaceSegment {
  const _SurfaceSegment({
    required this.id,
    required this.xMin,
    required this.xMax,
    required this.yTop,
  });

  /// Packed surface ID (see [packSurfaceId]).
  final int id;

  /// Left edge X coordinate.
  final double xMin;

  /// Right edge X coordinate.
  final double xMax;

  /// Top Y coordinate (walking height).
  final double yTop;

  /// Creates a copy with modified [xMax] (used during merge).
  _SurfaceSegment copyWith({double? xMax}) {
    return _SurfaceSegment(
      id: id,
      xMin: xMin,
      xMax: xMax ?? this.xMax,
      yTop: yTop,
    );
  }
}

/// Mutable horizontal range (used for blocker collection).
class _Range {
  _Range(this.min, this.max);

  double min;
  double max;
}

// =============================================================================
// Helper functions
// =============================================================================

/// Collects horizontal ranges that block the ground at [groundTopY].
///
/// Includes:
/// - Solids with left/right walls touching ground Y.
/// - Explicit ground gaps.
///
/// Returns merged, sorted list of blocking ranges.
List<_Range> _collectGroundBlockers(
  List<StaticSolid> solids,
  List<StaticGroundGap> gaps,
  double groundTopY,
  double eps,
) {
  final blockers = <_Range>[];

  // Collect solids that intersect ground level and have vertical walls.
  for (final solid in solids) {
    final hasWalls =
        (solid.sides & (StaticSolid.sideLeft | StaticSolid.sideRight)) != 0;
    if (!hasWalls) continue;

    final touchesGround =
        solid.minY <= groundTopY + eps && solid.maxY >= groundTopY - eps;
    if (!touchesGround) continue;

    blockers.add(_Range(solid.minX, solid.maxX));
  }

  // Add explicit gaps.
  for (final gap in gaps) {
    blockers.add(_Range(gap.minX, gap.maxX));
  }

  if (blockers.isEmpty) return blockers;

  // Sort and merge overlapping blockers.
  blockers.sort((a, b) => a.min.compareTo(b.min));
  final merged = <_Range>[blockers.first];
  for (var i = 1; i < blockers.length; i += 1) {
    final current = blockers[i];
    final last = merged.last;
    if (current.min <= last.max + eps) {
      // Overlapping or adjacent—extend.
      if (current.max > last.max) {
        last.max = current.max;
      }
    } else {
      merged.add(_Range(current.min, current.max));
    }
  }

  return merged;
}

/// Subtracts [blockers] from range [min, max], returning unblocked segments.
///
/// **Algorithm**:
/// Walk left-to-right, emitting segments between blocker gaps.
List<_Range> _subtractRanges(
  double min,
  double max,
  List<_Range> blockers,
  double eps,
) {
  if (blockers.isEmpty) {
    return <_Range>[_Range(min, max)];
  }

  final segments = <_Range>[];
  var cursor = min;

  for (final blocker in blockers) {
    // Skip blockers entirely before our range.
    if (blocker.max <= min + eps) continue;
    // Stop if blocker starts after our range.
    if (blocker.min >= max - eps) break;

    // Clamp blocker to our range.
    final blockMin = blocker.min < min ? min : blocker.min;
    final blockMax = blocker.max > max ? max : blocker.max;

    // Emit segment before blocker (if any).
    if (blockMin > cursor + eps) {
      segments.add(_Range(cursor, blockMin));
    }

    // Advance cursor past blocker.
    if (blockMax > cursor) {
      cursor = blockMax;
    }
  }

  // Emit trailing segment (if any).
  if (cursor < max - eps) {
    segments.add(_Range(cursor, max));
  }

  return segments;
}

/// Comparison function for sorting segments (Y, then X, then ID).
int _compareSegments(_SurfaceSegment a, _SurfaceSegment b) {
  // Primary: Y ascending (lower platforms first in screen coords).
  if (a.yTop < b.yTop) return -1;
  if (a.yTop > b.yTop) return 1;
  // Secondary: X ascending.
  if (a.xMin < b.xMin) return -1;
  if (a.xMin > b.xMin) return 1;
  // Tertiary: Width ascending.
  if (a.xMax < b.xMax) return -1;
  if (a.xMax > b.xMax) return 1;
  // Final: ID for determinism.
  if (a.id < b.id) return -1;
  if (a.id > b.id) return 1;
  return 0;
}


===== FILE: lib/core/navigation/surface_graph_builder.dart =====
import '../collision/static_world_geometry.dart';
import '../ecs/spatial/grid_index_2d.dart';
import 'utils/jump_template.dart';
import 'types/nav_tolerances.dart';
import 'surface_extractor.dart';
import 'types/surface_graph.dart';
import 'utils/surface_spatial_index.dart';
import 'types/walk_surface.dart';

/// Result of [SurfaceGraphBuilder.build].
class SurfaceGraphBuildResult {
  const SurfaceGraphBuildResult({
    required this.graph,
    required this.spatialIndex,
  });

  /// The navigation graph (surfaces + edges in CSR format).
  final SurfaceGraph graph;

  /// Spatial index for fast surface lookups during runtime navigation.
  final SurfaceSpatialIndex spatialIndex;
}

/// Builds a [SurfaceGraph] from world geometry and jump physics.
///
/// **Pipeline**:
/// 1. Extract [WalkSurface]s from tiles via [SurfaceExtractor].
/// 2. Build spatial index for candidate queries.
/// 3. For each surface, generate edges:
///    - **Drop edges**: Walk off ledge, fall to surface below.
///    - **Jump edges**: Sample takeoff points, find reachable surfaces.
/// 4. Pack into CSR (Compressed Sparse Row) format.
///
/// **Configuration**:
/// - [standableEps]: Tolerance for standable range calculations.
/// - [dropSampleOffset]: Nudge takeoff past ledge for drop edges.
/// - [takeoffSampleMaxStep]: Maximum spacing between takeoff samples.
class SurfaceGraphBuilder {
  SurfaceGraphBuilder({
    required GridIndex2D surfaceGrid,
    SurfaceExtractor? extractor,
    this.standableEps = navGeomEps,
    this.dropSampleOffset = navSpatialEps,
    this.takeoffSampleMaxStep = 64.0,
  })  : _surfaceGrid = surfaceGrid,
        _extractor = extractor ?? SurfaceExtractor();

  /// Grid for spatial index bucket allocation.
  final GridIndex2D _surfaceGrid;

  /// Surface extractor (default: standard tile-based extraction).
  final SurfaceExtractor _extractor;

  /// Tolerance for standable range width check.
  final double standableEps;

  /// Offset past ledge for drop takeoff (ensures entity actually falls).
  final double dropSampleOffset;

  /// Maximum step between takeoff sample points.
  final double takeoffSampleMaxStep;

  /// Builds a navigation graph from world geometry.
  ///
  /// **Parameters**:
  /// - [geometry]: Static collision geometry (tile-based).
  /// - [jumpTemplate]: Precomputed jump arc for reachability queries.
  ///
  /// **Returns**: [SurfaceGraphBuildResult] with graph and spatial index.
  SurfaceGraphBuildResult build({
    required StaticWorldGeometry geometry,
    required JumpReachabilityTemplate jumpTemplate,
  }) {
    // -------------------------------------------------------------------------
    // Step 1: Extract surfaces and build spatial index.
    // -------------------------------------------------------------------------
    final surfaces = _extractor.extract(geometry);
    final spatialIndex = SurfaceSpatialIndex(index: _surfaceGrid);
    spatialIndex.rebuild(surfaces);

    // Build surface ID → index lookup.
    final indexById = <int, int>{};
    for (var i = 0; i < surfaces.length; i += 1) {
      indexById[surfaces[i].id] = i;
    }

    // -------------------------------------------------------------------------
    // Step 2: Generate edges for each surface.
    // -------------------------------------------------------------------------
    final edges = <SurfaceEdge>[];
    final edgeOffsets = List<int>.filled(surfaces.length + 1, 0);
    final tempCandidates = <int>[];

    for (var i = 0; i < surfaces.length; i += 1) {
      edgeOffsets[i] = edges.length;
      final from = surfaces[i];

      // Compute standable range (agent center positions that fit on surface).
      final standable = _standableRange(
        from,
        jumpTemplate.profile.agentHalfWidth,
        standableEps,
      );
      if (standable == null) {
        // Surface too narrow for agent.
        edgeOffsets[i + 1] = edges.length;
        continue;
      }

      // -----------------------------------------------------------------------
      // Step 2a: Generate drop edges (walk off ledge).
      // -----------------------------------------------------------------------
      final dropSamples = _dropSamples(standable.min, standable.max);
      final dropMid = (standable.min + standable.max) * 0.5;
      for (final dropX in dropSamples) {
        final landingIndex = _findFirstSurfaceBelow(
          surfaces,
          dropX,
          from.yTop,
          jumpTemplate.profile.agentHalfWidth,
        );
        if (landingIndex == null) continue;

        final landingSurface = surfaces[landingIndex];
        final dy = landingSurface.yTop - from.yTop;
        final fallTicks = estimateFallTicks(
          dy: dy,
          gravityY: jumpTemplate.profile.gravityY,
          dtSeconds: jumpTemplate.profile.dtSeconds,
          maxTicks: jumpTemplate.profile.maxAirTicks,
        );

        // Nudge takeoff past ledge so agent actually walks off.
        final commitDirX = dropX <= dropMid ? -1 : 1;
        final takeoffX = dropX + (commitDirX * dropSampleOffset);

        final edge = SurfaceEdge(
          to: landingIndex,
          kind: SurfaceEdgeKind.drop,
          takeoffX: takeoffX,
          landingX: _clamp(
            dropX,
            landingSurface.xMin + jumpTemplate.profile.agentHalfWidth,
            landingSurface.xMax - jumpTemplate.profile.agentHalfWidth,
          ),
          commitDirX: commitDirX,
          travelTicks: fallTicks,
          cost: fallTicks * jumpTemplate.profile.dtSeconds,
        );
        edges.add(edge);
      }

      // -----------------------------------------------------------------------
      // Step 2b: Generate jump edges (sample takeoff points).
      // -----------------------------------------------------------------------
      final takeoffXs = _takeoffSamples(
        standable.min,
        standable.max,
        jumpTemplate.maxDx,
        takeoffSampleMaxStep,
      );

      for (final takeoffX in takeoffXs) {
        // Query reachable surfaces within jump arc bounding box.
        final minX = takeoffX - jumpTemplate.maxDx;
        final maxX = takeoffX + jumpTemplate.maxDx;
        final minY = from.yTop + jumpTemplate.minDy;
        final maxY = from.yTop + jumpTemplate.maxDy;

        spatialIndex.queryAabb(
          minX: minX,
          minY: minY,
          maxX: maxX,
          maxY: maxY,
          outSurfaceIndices: tempCandidates,
        );

        // Sort for deterministic edge ordering.
        tempCandidates.sort(
          (a, b) => surfaces[a].id.compareTo(surfaces[b].id),
        );

        for (final targetIndex in tempCandidates) {
          if (targetIndex == i) continue; // Skip self.
          final target = surfaces[targetIndex];

          // Safety net: avoid generating "micro-hop" jump edges between surfaces
          // that are effectively coplanar and contiguous. These should have
          // been merged by the extractor; emitting a jump here can cause AI to
          // do a weird hop on top of the same obstacle.
          final dy = target.yTop - from.yTop;
          final coplanar = dy.abs() <= navSpatialEps;
          if (coplanar) {
            final touchesOrOverlaps =
                target.xMin <= from.xMax + navSpatialEps &&
                target.xMax >= from.xMin - navSpatialEps;
            if (touchesOrOverlaps) {
              continue;
            }
          }

          final landing = _standableRange(
            target,
            jumpTemplate.profile.agentHalfWidth,
            standableEps,
          );
          if (landing == null) continue; // Target too narrow.

          // Check if jump arc can reach target surface.
          final dxMin = landing.min - takeoffX;
          final dxMax = landing.max - takeoffX;
          final landingTick = jumpTemplate.findFirstLanding(
            dy: dy,
            dxMin: dxMin,
            dxMax: dxMax,
          );
          if (landingTick == null) continue; // Not reachable.

          // Compute actual landing range (intersection of reach and surface).
          final reachMin = takeoffX - landingTick.maxDx;
          final reachMax = takeoffX + landingTick.maxDx;
          final low = reachMin > landing.min ? reachMin : landing.min;
          final high = reachMax < landing.max ? reachMax : landing.max;
          if (low > high + standableEps) continue; // No overlap.

          final landingX = (low + high) * 0.5; // Center of landing range.
          final commitDirX = landingX > takeoffX + navGeomEps
              ? 1
              : (landingX < takeoffX - navGeomEps ? -1 : 0);

          final edge = SurfaceEdge(
            to: targetIndex,
            kind: SurfaceEdgeKind.jump,
            takeoffX: takeoffX,
            landingX: landingX,
            commitDirX: commitDirX,
            travelTicks: landingTick.tick,
            cost: landingTick.tick * jumpTemplate.profile.dtSeconds,
          );
          edges.add(edge);
        }
      }

      edgeOffsets[i + 1] = edges.length;
    }

    // -------------------------------------------------------------------------
    // Step 3: Pack into graph and return.
    // -------------------------------------------------------------------------
    return SurfaceGraphBuildResult(
      graph: SurfaceGraph(
        surfaces: surfaces,
        edgeOffsets: edgeOffsets,
        edges: edges,
        indexById: indexById,
      ),
      spatialIndex: spatialIndex,
    );
  }
}

// =============================================================================
// Helper types and functions
// =============================================================================

/// A horizontal range [min, max].
class _Range {
  const _Range(this.min, this.max);

  final double min;
  final double max;
}

/// Computes the standable X range for an agent on a surface.
///
/// The agent's center must be at least [halfWidth] from each edge.
/// Returns `null` if the surface is too narrow.
_Range? _standableRange(WalkSurface surface, double halfWidth, double eps) {
  final min = surface.xMin + halfWidth;
  final max = surface.xMax - halfWidth;
  if (min > max + eps) return null;
  return _Range(min, max);
}

/// Generates takeoff sample points across a standable range.
///
/// - Returns [min, mid, max] for narrow surfaces.
/// - Returns evenly-spaced samples (at most [maxStep] apart) for wide surfaces.
/// - Deduplicates samples within [navGeomEps].
List<double> _takeoffSamples(
  double min,
  double max,
  double maxDx,
  double maxStep,
) {
  if (max <= min) {
    return <double>[min];
  }

  var step = maxDx;
  if (maxStep > 0 && step > maxStep) {
    step = maxStep;
  }

  // Narrow surface: just sample endpoints and midpoint.
  if (step <= navGeomEps || (max - min) <= step) {
    final mid = (min + max) * 0.5;
    return _dedupeSamples(<double>[min, mid, max]);
  }

  // Wide surface: evenly-spaced samples.
  final samples = <double>[];
  for (var x = min; x <= max; x += step) {
    samples.add(x);
  }
  // Ensure max is included.
  if ((max - samples.last).abs() > navGeomEps) {
    samples.add(max);
  }
  return _dedupeSamples(samples);
}

/// Generates drop sample points (only at ledge endpoints).
List<double> _dropSamples(double min, double max) {
  final samples = <double>[min, max];
  return _dedupeSamples(samples);
}

/// Removes duplicate samples within [eps] tolerance.
List<double> _dedupeSamples(
  List<double> samples, {
  double eps = navGeomEps,
}) {
  samples.sort();
  final deduped = <double>[];
  for (final s in samples) {
    if (deduped.isEmpty || (s - deduped.last).abs() > eps) {
      deduped.add(s);
    }
  }
  return deduped;
}

/// Finds the first (highest) surface directly below a point.
///
/// **Parameters**:
/// - [x]: Horizontal position to check.
/// - [fromY]: Starting Y (surfaces must be below this).
/// - [halfWidth]: Agent half-width for standability check.
///
/// **Returns**: Surface index, or `null` if no surface below.
int? _findFirstSurfaceBelow(
  List<WalkSurface> surfaces,
  double x,
  double fromY,
  double halfWidth,
) {
  int? bestIndex;
  double? bestY;

  for (var i = 0; i < surfaces.length; i += 1) {
    final s = surfaces[i];
    // Must be below starting point.
    if (s.yTop <= fromY) continue;
    // Must be standable at this X.
    final minX = s.xMin + halfWidth;
    final maxX = s.xMax - halfWidth;
    if (minX > maxX) continue;
    if (x < minX || x > maxX) continue;

    // Prefer highest surface (lowest yTop).
    if (bestY == null || s.yTop < bestY) {
      bestY = s.yTop;
      bestIndex = i;
    } else if ((s.yTop - bestY).abs() < navTieEps) {
      // Tie-break by ID for determinism.
      if (s.id < surfaces[bestIndex!].id) {
        bestIndex = i;
      }
    }
  }

  return bestIndex;
}

/// Clamps [v] to the range [min, max].
double _clamp(double v, double min, double max) {
  if (v < min) return min;
  if (v > max) return max;
  return v;
}


===== FILE: lib/core/navigation/surface_navigator.dart =====
import '../ecs/stores/enemies/surface_nav_state_store.dart';
import 'types/nav_tolerances.dart';
import 'types/surface_graph.dart';
import 'types/surface_id.dart';
import 'surface_pathfinder.dart';
import 'utils/surface_spatial_index.dart';

/// Output of [SurfaceNavigator.update] indicating desired movement.
class SurfaceNavIntent {
  const SurfaceNavIntent({
    required this.desiredX,
    required this.jumpNow,
    required this.hasPlan,
    this.commitMoveDirX = 0,
  });

  /// Target X position the locomotion controller should move toward.
  final double desiredX;

  /// If `true`, the entity should jump this frame.
  final bool jumpNow;

  /// If `true`, a valid path exists (even if currently executing an edge).
  final bool hasPlan;

  /// Movement commit direction while approaching/executing an edge.
  ///
  /// When non-zero (-1 or +1), the locomotion controller should keep moving in
  /// this direction even if it would normally stop near `desiredX`, and it
  /// should not reverse direction due to tiny `desiredX` overshoots.
  ///
  /// This is primarily used to ensure drop edges actually leave the takeoff
  /// surface (walk past the ledge) instead of stopping "close enough".
  final int commitMoveDirX;
}

/// Runtime navigation controller for surface-graph-based AI movement.
///
/// **Responsibilities**:
/// 1. Track which surface the entity and target are standing on.
/// 2. Request paths via [SurfacePathfinder] when surfaces change.
/// 3. Execute path edges (walk to takeoff, jump/drop, land on destination).
/// 4. Return [SurfaceNavIntent] each tick for the locomotion controller.
///
/// **State Storage**:
/// Uses [SurfaceNavStateStore] (external SOA store) so multiple entities can
/// share a single [SurfaceNavigator] instance.
///
/// **Usage**:
/// ```dart
/// final intent = navigator.update(
///   navStore: store, navIndex: idx,
///   graph: graph, spatialIndex: index,
///   graphVersion: version,
///   entityX: e.x, entityBottomY: e.bottom, entityHalfWidth: e.hw,
///   entityGrounded: e.grounded,
///   targetX: t.x, targetBottomY: t.bottom, targetHalfWidth: t.hw,
///   targetGrounded: t.grounded,
/// );
/// // Use intent.desiredX, intent.jumpNow, intent.commitMoveDirX
/// ```
class SurfaceNavigator {
  SurfaceNavigator({
    required this.pathfinder,
    this.repathCooldownTicks = 30,
    this.surfaceEps = navSpatialEps,
    this.takeoffEps = 2.0,
  });

  /// Pathfinder used for A* queries.
  final SurfacePathfinder pathfinder;

  /// Minimum ticks between path recalculations (prevents thrashing).
  final int repathCooldownTicks;

  /// Vertical tolerance for surface detection (pixels).
  final double surfaceEps;

  /// Horizontal tolerance for reaching takeoff point (pixels).
  final double takeoffEps;

  /// Reusable buffer for spatial index queries.
  final List<int> _candidateBuffer = <int>[];

  /// Updates navigation state and returns movement intent for one entity.
  ///
  /// **Flow**:
  /// 1. Locate current and target surfaces via spatial index.
  /// 2. Invalidate path if graph version changed.
  /// 3. Repath if cooldown expired and surfaces are known.
  /// 4. If same surface, return direct movement to target.
  /// 5. Otherwise, execute next edge in path (approach → jump/drop → land).
  SurfaceNavIntent update({
    required SurfaceNavStateStore navStore,
    required int navIndex,
    required SurfaceGraph graph,
    required SurfaceSpatialIndex spatialIndex,
    required int graphVersion,
    required double entityX,
    required double entityBottomY,
    required double entityHalfWidth,
    required bool entityGrounded,
    required double targetX,
    required double targetBottomY,
    required double targetHalfWidth,
    required bool targetGrounded,
  }) {
    final prevCurrentId = navStore.currentSurfaceId[navIndex];
    final prevTargetId = navStore.targetSurfaceId[navIndex];
    final prevLastGroundId = navStore.lastGroundSurfaceId[navIndex];

    // -------------------------------------------------------------------------
    // Step 1: Locate surfaces.
    // -------------------------------------------------------------------------
    var currentSurfaceId = surfaceIdUnknown;
    if (entityGrounded) {
      final currentIndex = _locateSurfaceIndex(
        graph,
        spatialIndex,
        _candidateBuffer,
        entityX,
        entityBottomY,
        entityHalfWidth,
        surfaceEps,
      );
      currentSurfaceId = currentIndex == null
          ? surfaceIdUnknown
          : graph.surfaces[currentIndex].id;
    }

    var targetSurfaceId = prevTargetId;
    if (targetGrounded) {
      final targetIndex = _locateSurfaceIndex(
        graph,
        spatialIndex,
        _candidateBuffer,
        targetX,
        targetBottomY,
        targetHalfWidth,
        surfaceEps,
      );
      targetSurfaceId = targetIndex == null
          ? surfaceIdUnknown
          : graph.surfaces[targetIndex].id;
    }

    // -------------------------------------------------------------------------
    // Step 2: Invalidate path on graph rebuild.
    // -------------------------------------------------------------------------
    if (navStore.graphVersion[navIndex] != graphVersion) {
      navStore.graphVersion[navIndex] = graphVersion;
      navStore.pathEdges[navIndex].clear();
      navStore.pathCursor[navIndex] = 0;
      navStore.activeEdgeIndex[navIndex] = -1;
      navStore.repathTicksLeft[navIndex] = 0;
      navStore.lastGroundSurfaceId[navIndex] = surfaceIdUnknown;
    }

    navStore.currentSurfaceId[navIndex] = currentSurfaceId;
    navStore.targetSurfaceId[navIndex] = targetSurfaceId;
    if (entityGrounded && currentSurfaceId != surfaceIdUnknown) {
      navStore.lastGroundSurfaceId[navIndex] = currentSurfaceId;
    } else if (prevLastGroundId != surfaceIdUnknown) {
      navStore.lastGroundSurfaceId[navIndex] = prevLastGroundId;
    }

    // Decrement repath cooldown.
    if (navStore.repathTicksLeft[navIndex] > 0) {
      navStore.repathTicksLeft[navIndex] -= 1;
    }

    final plan = navStore.pathEdges[navIndex];
    final surfaceChanged =
        currentSurfaceId != prevCurrentId || targetSurfaceId != prevTargetId;

    // Reset cooldown if either surface changed (allows immediate repath).
    if (surfaceChanged) {
      navStore.repathTicksLeft[navIndex] = 0;
    }

    // -------------------------------------------------------------------------
    // Step 3: Repath if needed.
    // -------------------------------------------------------------------------
    if (entityGrounded &&
        navStore.repathTicksLeft[navIndex] == 0 &&
        currentSurfaceId != surfaceIdUnknown &&
        targetSurfaceId != surfaceIdUnknown) {
      final startIndex = graph.indexOfSurfaceId(currentSurfaceId);
      final goalIndex = graph.indexOfSurfaceId(targetSurfaceId);
      if (startIndex != null && goalIndex != null) {
        final found = pathfinder.findPath(
          graph,
          startIndex: startIndex,
          goalIndex: goalIndex,
          outEdges: plan,
          startX: entityX,
          goalX: targetX,
        );
        navStore.pathCursor[navIndex] = 0;
        navStore.activeEdgeIndex[navIndex] = -1;
        if (!found) {
          plan.clear();
        }
      }
      navStore.repathTicksLeft[navIndex] = repathCooldownTicks;
    }

    // -------------------------------------------------------------------------
    // Step 4: Same-surface shortcut.
    // -------------------------------------------------------------------------
    if (entityGrounded &&
      navStore.activeEdgeIndex[navIndex] < 0 &&
      currentSurfaceId != surfaceIdUnknown &&
      currentSurfaceId == targetSurfaceId) {
      plan.clear();
      navStore.pathCursor[navIndex] = 0;
      navStore.activeEdgeIndex[navIndex] = -1;
      return SurfaceNavIntent(
        desiredX: targetX,
        jumpNow: false,
        hasPlan: false,
      );
    }

    // -------------------------------------------------------------------------
    // Step 5: Execute path edges.
    // -------------------------------------------------------------------------
    final cursor = navStore.pathCursor[navIndex];
    if (plan.isEmpty || cursor >= plan.length) {
      navStore.activeEdgeIndex[navIndex] = -1;
      return SurfaceNavIntent(
        desiredX: targetX,
        jumpNow: false,
        hasPlan: false,
      );
    }

    final edgeIndex = plan[cursor];
    final edge = graph.edges[edgeIndex];

    // --- Executing an edge (mid-flight or post-takeoff) ---
    if (navStore.activeEdgeIndex[navIndex] >= 0) {
      // Check if we've landed on the destination surface.
      if (entityGrounded &&
          currentSurfaceId != surfaceIdUnknown &&
          currentSurfaceId == graph.surfaces[edge.to].id) {
        // Edge complete—advance cursor.
        navStore.activeEdgeIndex[navIndex] = -1;
        navStore.pathCursor[navIndex] = cursor + 1;
        return SurfaceNavIntent(
          desiredX: targetX,
          jumpNow: false,
          hasPlan: true,
        );
      }

      // Drop edge: keep walking toward ledge until we fall off.
      if (edge.kind == SurfaceEdgeKind.drop && entityGrounded) {
        return SurfaceNavIntent(
          desiredX: edge.takeoffX,
          jumpNow: false,
          hasPlan: true,
          commitMoveDirX: edge.commitDirX,
        );
      }

      // Drop edge in-flight: keep commit direction stable. (landingX can be
      // slightly behind the entity due to clamping, which would otherwise
      // cause a brief direction reversal.)
      if (edge.kind == SurfaceEdgeKind.drop) {
        return SurfaceNavIntent(
          desiredX: edge.landingX,
          jumpNow: false,
          hasPlan: true,
          commitMoveDirX: edge.commitDirX,
        );
      }

      // Jump edge in-flight: aim for landing point.
      return SurfaceNavIntent(
        desiredX: edge.landingX,
        jumpNow: false,
        hasPlan: true,
      );
    }

    // --- Approaching takeoff point ---
    // For jump edges with commitMoveDirX, the entity may overshoot the exact
    // takeoff point at high speeds. Check if the entity is at OR past the
    // takeoff point in the direction of travel.
    final dir = edge.commitDirX;
    final closeEnough = edge.kind == SurfaceEdgeKind.jump && dir != 0
        ? (dir > 0 ? entityX >= edge.takeoffX - takeoffEps : entityX <= edge.takeoffX + takeoffEps)
        : (entityX - edge.takeoffX).abs() <= takeoffEps;
    if (entityGrounded && closeEnough) {
      // Initiate edge execution.
      navStore.activeEdgeIndex[navIndex] = edgeIndex;

      final jumpNow = edge.kind == SurfaceEdgeKind.jump;
      return SurfaceNavIntent(
        desiredX:
            edge.kind == SurfaceEdgeKind.drop ? edge.takeoffX : edge.landingX,
        jumpNow: jumpNow,
        hasPlan: true,
        commitMoveDirX: edge.commitDirX,
      );
    }

    // Walk toward takeoff point.
    // For jump edges, commit direction keeps the entity moving at full speed
    // through the takeoff instead of decelerating as it approaches.
    return SurfaceNavIntent(
      desiredX: edge.takeoffX,
      jumpNow: false,
      hasPlan: true,
      commitMoveDirX:
          edge.kind == SurfaceEdgeKind.jump ? edge.commitDirX : 0,
    );
  }
}

/// Finds the best surface index for a given entity footprint.
///
/// **Algorithm**:
/// 1. Query spatial index for candidate surfaces in AABB.
/// 2. Filter by horizontal overlap and vertical proximity.
/// 3. Prefer lowest yTop (highest platform). Tie-break by surface ID.
///
/// **Returns**: Surface index, or `null` if not standing on any surface.
int? _locateSurfaceIndex(
  SurfaceGraph graph,
  SurfaceSpatialIndex spatialIndex,
  List<int> candidates,
  double x,
  double bottomY,
  double halfWidth,
  double eps,
) {
  final minX = x - halfWidth;
  final maxX = x + halfWidth;
  final minY = bottomY - eps;
  final maxY = bottomY + eps;

  spatialIndex.queryAabb(
    minX: minX,
    minY: minY,
    maxX: maxX,
    maxY: maxY,
    outSurfaceIndices: candidates,
  );

  int? bestIndex;
  double? bestY;
  for (final i in candidates) {
    final s = graph.surfaces[i];
    // Skip if no horizontal overlap.
    if (s.xMin > maxX || s.xMax < minX) continue;
    // Skip if too far vertically.
    if ((s.yTop - bottomY).abs() > eps) continue;

    // Prefer higher platform (lower yTop in screen coords).
    if (bestY == null || s.yTop < bestY) {
      bestY = s.yTop;
      bestIndex = i;
    } else if ((s.yTop - bestY).abs() <= eps) {
      // Tie-break by ID for determinism.
      if (s.id < graph.surfaces[bestIndex!].id) {
        bestIndex = i;
      }
    }
  }

  return bestIndex;
}


===== FILE: lib/core/navigation/surface_pathfinder.dart =====
import 'types/surface_graph.dart';
import 'types/nav_tolerances.dart';

/// A* pathfinder for surface-based navigation graphs.
///
/// **Algorithm**: Standard A* with:
/// - Admissible heuristic: straight-line horizontal distance / run speed.
/// - Edge costs: transition cost + run distance to takeoff + landing adjustment.
/// - Tie-breaking: lower g-score, then surface ID for determinism.
///
/// **Optimizations**:
/// - Generation-stamp pattern avoids clearing arrays between searches.
/// - Reusable working lists grow once, persist across queries.
/// - Linear open-list scan (adequate for small graphs; swap to binary heap
///   if graph size grows significantly).
///
/// **Usage**:
/// ```dart
/// final pathfinder = SurfacePathfinder(maxExpandedNodes: 500, runSpeedX: 200);
/// final edges = <int>[];
/// if (pathfinder.findPath(graph, startIndex: s, goalIndex: g, outEdges: edges)) {
///   // edges contains edge indices from start to goal.
/// }
/// ```
class SurfacePathfinder {
  SurfacePathfinder({
    required this.maxExpandedNodes,
    required this.runSpeedX,
    this.edgePenaltySeconds = 0.0,
  })  : assert(maxExpandedNodes > 0),
        assert(runSpeedX > 0),
        assert(edgePenaltySeconds >= 0.0);

  /// Maximum nodes to expand before giving up (prevents runaway searches).
  final int maxExpandedNodes;

  /// Horizontal run speed (pixels/second) for cost calculations.
  final double runSpeedX;

  /// Flat penalty added to every edge (discourages excessive transitions).
  final double edgePenaltySeconds;

  // ---------------------------------------------------------------------------
  // Working arrays (reused across searches via generation stamps).
  // ---------------------------------------------------------------------------

  /// Cost from start to each node (g-score).
  final List<double> _gScore = <double>[];

  /// Estimated total cost through each node (f = g + h).
  final List<double> _fScore = <double>[];

  /// Edge index used to reach each node (-1 = start or unvisited).
  final List<int> _cameFromEdge = <int>[];

  /// Predecessor node index (-1 = start or unvisited).
  final List<int> _cameFromNode = <int>[];

  /// Open set (nodes pending expansion).
  final List<int> _open = <int>[];

  /// 1 if node is in open set this search, 0 otherwise.
  final List<int> _openStamp = <int>[];

  /// Scratch space for path reconstruction.
  final List<int> _reconstruct = <int>[];

  /// Generation stamp per node (matches [_searchGeneration] if valid).
  final List<int> _nodeGenerations = <int>[];

  /// Incremented each search to invalidate stale node data.
  int _searchGeneration = 0;

  /// Finds a path from [startIndex] to [goalIndex] in [graph].
  ///
  /// **Parameters**:
  /// - [startIndex], [goalIndex]: Surface indices in [graph.surfaces].
  /// - [outEdges]: Receives ordered edge indices from start to goal.
  /// - [startX], [goalX]: Optional precise X positions for cost accuracy.
  ///
  /// **Returns**: `true` if a path was found, `false` otherwise.
  bool findPath(
    SurfaceGraph graph, {
    required int startIndex,
    required int goalIndex,
    required List<int> outEdges,
    double? startX,
    double? goalX,
  }) {
    outEdges.clear();
    if (startIndex == goalIndex) return true;

    _ensureSize(graph.surfaces.length);
    _searchGeneration += 1;

    // Initialize start node.
    _touch(startIndex);
    _open.clear();
    _open.add(startIndex);
    _openStamp[startIndex] = 1;
    _gScore[startIndex] = 0.0;
    _fScore[startIndex] = _heuristic(graph, startIndex, goalIndex);

    var expanded = 0;
    while (_open.isNotEmpty && expanded < maxExpandedNodes) {
      final current = _popBest(graph);
      if (current == goalIndex) {
        _reconstructPath(goalIndex, outEdges);
        return true;
      }

      expanded += 1;

      // Iterate outgoing edges (CSR format).
      final start = graph.edgeOffsets[current];
      final end = graph.edgeOffsets[current + 1];
      for (var ei = start; ei < end; ei += 1) {
        final edge = graph.edges[ei];
        final neighbor = edge.to;
        _touch(neighbor);

        // Total edge cost: base + run-to-takeoff + landing adjustment + penalty.
        final edgeCost = edge.cost +
            _runCost(
              graph,
              current,
              edge,
              startIndex: startIndex,
              startX: startX,
            ) +
            _goalLandingCost(
              edge,
              neighbor: neighbor,
              goalIndex: goalIndex,
              goalX: goalX,
            ) +
            edgePenaltySeconds;

        final tentative = _gScore[current] + edgeCost;
        if (tentative >= _gScore[neighbor]) continue;

        // Better path found—update neighbor.
        _cameFromEdge[neighbor] = ei;
        _cameFromNode[neighbor] = current;
        _gScore[neighbor] = tentative;
        _fScore[neighbor] = tentative + _heuristic(graph, neighbor, goalIndex);

        // Add to open set if not already present.
        if (_openStamp[neighbor] != 1) {
          _open.add(neighbor);
          _openStamp[neighbor] = 1;
        }
      }
    }

    return false; // No path found within expansion limit.
  }

  /// Admissible heuristic: horizontal distance / run speed.
  ///
  /// Ignores vertical distance (platforms can be reached by jumps/falls
  /// with minimal time penalty relative to horizontal travel).
  double _heuristic(SurfaceGraph graph, int from, int goal) {
    final dx =
        (graph.surfaces[goal].centerX - graph.surfaces[from].centerX).abs();
    return dx / runSpeedX;
  }

  /// Cost to run from current position to edge takeoff point.
  double _runCost(
    SurfaceGraph graph,
    int fromIndex,
    SurfaceEdge edge, {
    required int startIndex,
    required double? startX,
  }) {
    final fromSurface = graph.surfaces[fromIndex];
    // Use exact position for start node, otherwise surface center.
    final originX =
        (fromIndex == startIndex && startX != null) ? startX : fromSurface.centerX;
    final dx = (edge.takeoffX - originX).abs();
    return dx / runSpeedX;
  }

  /// Additional cost for landing distance to goal (only on final edge).
  double _goalLandingCost(
    SurfaceEdge edge, {
    required int neighbor,
    required int goalIndex,
    required double? goalX,
  }) {
    if (goalX == null) return 0.0;
    if (neighbor != goalIndex) return 0.0;
    final dx = (edge.landingX - goalX).abs();
    return dx / runSpeedX;
  }

  /// Extracts and removes the node with lowest f-score from [_open].
  ///
  /// Uses linear scan (O(n)) which is fine for small open sets.
  /// For larger graphs, consider a binary heap.
  int _popBest(SurfaceGraph graph) {
    var bestIndex = 0;
    var bestNode = _open[0];
    for (var i = 1; i < _open.length; i += 1) {
      final node = _open[i];
      if (_isBetter(graph, node, bestNode)) {
        bestIndex = i;
        bestNode = node;
      }
    }

    // Swap-remove: replace extracted element with last, then pop.
    final last = _open.removeLast();
    if (bestIndex < _open.length) {
      _open[bestIndex] = last;
    }
    _openStamp[bestNode] = 0;
    return bestNode;
  }

  /// Compares two nodes for priority (lower f-score wins).
  ///
  /// Tie-breaking order:
  /// 1. Lower f-score.
  /// 2. Lower g-score (prefer nodes closer to start).
  /// 3. Lower surface ID (determinism).
  bool _isBetter(SurfaceGraph graph, int a, int b) {
    final fa = _fScore[a];
    final fb = _fScore[b];
    if (fa < fb - navTieEps) return true;
    if (fa > fb + navTieEps) return false;
    final ga = _gScore[a];
    final gb = _gScore[b];
    if (ga < gb - navTieEps) return true;
    if (ga > gb + navTieEps) return false;
    return graph.surfaces[a].id < graph.surfaces[b].id;
  }

  /// Reconstructs path by walking [_cameFromEdge] back to start.
  ///
  /// Edges are collected in reverse order, then reversed into [outEdges].
  void _reconstructPath(int goalIndex, List<int> outEdges) {
    _reconstruct.clear();
    var current = goalIndex;
    while (_cameFromEdge[current] != -1) {
      _reconstruct.add(_cameFromEdge[current]);
      current = _cameFromNode[current];
    }
    // Reverse into output.
    for (var i = _reconstruct.length - 1; i >= 0; i -= 1) {
      outEdges.add(_reconstruct[i]);
    }
  }

  /// Grows working arrays to accommodate [count] nodes.
  void _ensureSize(int count) {
    while (_gScore.length < count) {
      _gScore.add(double.infinity);
      _fScore.add(double.infinity);
      _cameFromEdge.add(-1);
      _cameFromNode.add(-1);
      _openStamp.add(0);
      _nodeGenerations.add(0);
    }
  }

  /// Lazily initializes node data for the current search generation.
  ///
  /// Avoids O(n) clearing of all arrays between searches.
  void _touch(int index) {
    if (_nodeGenerations[index] != _searchGeneration) {
      _gScore[index] = double.infinity;
      _fScore[index] = double.infinity;
      _cameFromEdge[index] = -1;
      _cameFromNode[index] = -1;
      _openStamp[index] = 0;
      _nodeGenerations[index] = _searchGeneration;
    }
  }
}


===== FILE: lib/core/navigation/types/nav_tolerances.dart =====
/// Navigation-wide numeric tolerances.
///
/// **Design**:
/// - [navEps] is kept very small for geometric comparisons and deterministic
///   tie-breaking.
/// - [navSpatialEps] is intentionally larger to make runtime surface detection
///   robust against tiny simulation drift (world units are pixels).
///
/// **Warning**: Changing these values affects pathfinding determinism.
library;

/// Default epsilon for equality checks and tie-breaks (1e-6 world units).
const double navEps = 1e-6;

/// Epsilon for geometric equality checks (e.g., "are these two points the same?").
const double navGeomEps = navEps;

/// Epsilon for spatial queries (surface containment, overlap thickness).
const double navSpatialEps = 1.0;

/// Epsilon for deterministic tie-breaking in A* (f-cost and g-cost comparisons).
const double navTieEps = navEps;


===== FILE: lib/core/navigation/types/surface_graph.dart =====
import 'walk_surface.dart';

/// The type of transition between two surfaces.
enum SurfaceEdgeKind {
  /// An active jump (requires jump input).
  jump,
  
  /// A passive drop (walking off an edge).
  drop,
}

/// A directed edge in the navigation graph.
///
/// Represents a traversable connection from one [WalkSurface] to another.
class SurfaceEdge {
  const SurfaceEdge({
    required this.to,
    required this.kind,
    required this.takeoffX,
    required this.landingX,
    required this.commitDirX,
    required this.travelTicks,
    required this.cost,
  }) : assert(commitDirX >= -1 && commitDirX <= 1);

  /// Index of the destination surface in [SurfaceGraph.surfaces].
  final int to;
  
  /// Type of traversal (Jump or Drop).
  final SurfaceEdgeKind kind;
  
  /// World X coordinate where the entity leaves the source surface.
  final double takeoffX;
  
  /// World X coordinate where the entity lands on the destination surface.
  final double landingX;

  /// Movement commit direction while approaching/executing this edge.
  ///
  /// When non-zero (-1 or +1), the locomotion controller should keep moving in
  /// this direction when approaching the takeoff point and (for drops) while
  /// walking past the ledge to ensure the entity actually falls.
  ///
  /// **Design**:
  /// - For [SurfaceEdgeKind.drop], this is derived from which ledge is used.
  /// - For [SurfaceEdgeKind.jump], this is derived from `landingX - takeoffX`.
  final int commitDirX;
  
  /// Estimated travel time in simulation ticks.
  final int travelTicks;
  
  /// Pathfinding cost (typically based on time or distance).
  final double cost;
}

/// An immutable navigation graph built from [WalkSurface]s.
///
/// **Structure**:
/// - **Nodes**: [surfaces] (indexed 0..N-1).
/// - **Edges**: Stored in [edges], with [edgeOffsets] providing CSR-style indexing.
///
/// **CSR (Compressed Sparse Row) Format**:
/// - `edgeOffsets[i]` is the start index in [edges] for surface `i`.
/// - `edgeOffsets[i+1]` is the end index (exclusive).
/// - This allows O(1) lookup of outgoing edges for any surface.
class SurfaceGraph {
  SurfaceGraph({
    required List<WalkSurface> surfaces,
    required List<int> edgeOffsets,
    required List<SurfaceEdge> edges,
    required Map<int, int> indexById,
  })  : surfaces = List<WalkSurface>.unmodifiable(surfaces),
        edgeOffsets = List<int>.unmodifiable(edgeOffsets),
        edges = List<SurfaceEdge>.unmodifiable(edges),
        _indexById = Map<int, int>.unmodifiable(indexById);

  /// All walkable surfaces (graph nodes).
  final List<WalkSurface> surfaces;
  
  /// CSR row pointers into [edges]. Length = surfaces.length + 1.
  final List<int> edgeOffsets;
  
  /// All edges (graph arcs), grouped by source surface.
  final List<SurfaceEdge> edges;
  
  /// Lookup: Surface ID -> index in [surfaces].
  final Map<int, int> _indexById;

  /// Returns the index of a surface by its packed [id], or null if not found.
  int? indexOfSurfaceId(int id) => _indexById[id];

  /// Yields all outgoing edges from [surfaceIndex].
  Iterable<SurfaceEdge> edgesFor(int surfaceIndex) sync* {
    final start = edgeOffsets[surfaceIndex];
    final end = edgeOffsets[surfaceIndex + 1];
    for (var i = start; i < end; i += 1) {
      yield edges[i];
    }
  }
}


===== FILE: lib/core/navigation/types/surface_id.dart =====
/// Surface ID Packing Utilities.
///
/// Surfaces are identified by a 64-bit integer that encodes:
/// - **Chunk Index** (32 bits, high): Which level chunk the surface belongs to.
/// - **Local Solid Index** (30 bits): Index of the solid tile within the chunk.
/// - **Surface Kind** (2 bits, low): Top/Side/etc. (Currently only Top is used).
///
/// This encoding allows:
/// - Stable, deterministic IDs across save/load.
/// - Efficient Map/Set lookups.
/// - Lexicographic ordering by chunk then local index.
library;

/// The "Top" surface kind (entities stand on top of the solid).
const int surfaceKindTop = 0;

/// Sentinel value for "no surface" / invalid.
const int surfaceIdUnknown = -1;

/// Packs a surface identity into a stable, comparable 64-bit key.
///
/// **Bit Layout**:
/// ```
/// [63..32] chunkIndex (XOR'd with 0x80000000 to handle signed comparison)
/// [31..2]  localSolidIndex
/// [1..0]   surfaceKind
/// ```
int packSurfaceId({
  required int chunkIndex,
  required int localSolidIndex,
  int surfaceKind = surfaceKindTop,
}) {
  if (localSolidIndex < 0) {
    throw ArgumentError.value(
      localSolidIndex,
      'localSolidIndex',
      'must be >= 0',
    );
  }
  // XOR with sign bit to make signed chunkIndex sort correctly as unsigned.
  final chunk = (chunkIndex ^ 0x80000000) & 0xFFFFFFFF;
  // Pack localSolidIndex and surfaceKind into lower 32 bits.
  final local = ((localSolidIndex << 2) | (surfaceKind & 0x3)) & 0xFFFFFFFF;
  return (chunk << 32) | local;
}

/// Extracts the chunk index from a packed [surfaceId].
int unpackChunkIndex(int surfaceId) {
  final chunk = (surfaceId >> 32) & 0xFFFFFFFF;
  return (chunk ^ 0x80000000);
}

/// Extracts the local solid index from a packed [surfaceId].
int unpackLocalSolidIndex(int surfaceId) {
  final local = surfaceId & 0xFFFFFFFF;
  return local >> 2;
}

/// Extracts the surface kind (Top/Side) from a packed [surfaceId].
int unpackSurfaceKind(int surfaceId) {
  return surfaceId & 0x3;
}


===== FILE: lib/core/navigation/types/walk_surface.dart =====
/// Represents a horizontal walkable platform segment in world space.
///
/// **Geometry**:
/// - A 1D segment along the X-axis at a fixed Y height ([yTop]).
/// - Defined by [[xMin], [xMax]] (inclusive bounds).
///
/// **Usage**:
/// - Used by the navigation system to represent ground/platforms.
/// - Entities can stand on this surface if their X is within [xMin, xMax].
class WalkSurface {
  const WalkSurface({
    required this.id,
    required this.xMin,
    required this.xMax,
    required this.yTop,
  }) : assert(xMax >= xMin);

  /// Unique identifier (packed via [packSurfaceId]).
  final int id;

  /// Left edge of the walkable segment (inclusive).
  final double xMin;
  
  /// Right edge of the walkable segment (inclusive).
  final double xMax;

  /// World-space Y coordinate of the top surface (where entities stand).
  final double yTop;

  /// Horizontal center of the surface.
  double get centerX => (xMin + xMax) * 0.5;
  
  /// Width of the walkable segment.
  double get width => xMax - xMin;
}



===== FILE: lib/core/navigation/utils/jump_template.dart =====
import '../types/nav_tolerances.dart';

/// Physics parameters for simulating a jump arc.
///
/// Used to precompute reachability templates for AI pathfinding.
class JumpProfile {
  const JumpProfile({
    required this.jumpSpeed,
    required this.gravityY,
    required this.maxAirTicks,
    required this.airSpeedX,
    required this.dtSeconds,
    required this.agentHalfWidth,
  })  : assert(maxAirTicks > 0),
        assert(dtSeconds > 0);

  /// Instantaneous vertical speed at jump start (negative = upward).
  final double jumpSpeed;

  /// Gravity acceleration (positive = downward, e.g., 980 for ~10m/s²).
  final double gravityY;

  /// Fixed timestep in seconds (e.g., 1/60 for 60Hz).
  final double dtSeconds;

  /// Maximum ticks to simulate (limits arc length for performance).
  final int maxAirTicks;

  /// Assumed constant horizontal speed while airborne.
  final double airSpeedX;

  /// Agent's collider half-width (for landing overlap calculations).
  final double agentHalfWidth;
}

/// A single sample point along a precomputed jump arc.
class JumpSample {
  const JumpSample({
    required this.tick,
    required this.prevY,
    required this.y,
    required this.velY,
    required this.maxDx,
  });

  /// Tick number (1-based, 0 = takeoff).
  final int tick;

  /// Y position at the end of the previous tick.
  final double prevY;

  /// Y position at the end of this tick.
  final double y;

  /// Vertical velocity at the end of this tick.
  final double velY;

  /// Maximum horizontal displacement reachable by this tick.
  final double maxDx;
}

/// Result of a successful landing query.
class JumpLanding {
  const JumpLanding({required this.tick, required this.maxDx});

  /// Tick at which landing occurs.
  final int tick;

  /// Maximum horizontal reach at landing time.
  final double maxDx;
}

/// Precomputed jump arc template for reachability queries.
///
/// **Usage**:
/// - Built once from a [JumpProfile] (at startup or when physics change).
/// - Queried during graph construction to find valid jump edges.
///
/// **Physics**:
/// - Uses semi-implicit Euler integration: `vel += g*dt`, then `pos += vel*dt`.
/// - Matches the runtime physics in [GravitySystem].
class JumpReachabilityTemplate {
  JumpReachabilityTemplate._({
    required this.profile,
    required this.samples,
    required this.minDy,
    required this.maxDy,
    required this.maxDx,
  });

  /// The physics profile used to build this template.
  final JumpProfile profile;

  /// Sampled arc positions (tick 1 to maxAirTicks).
  final List<JumpSample> samples;

  /// Lowest Y offset reached (negative = above origin).
  final double minDy;

  /// Highest Y offset reached (positive = below origin, after fall).
  final double maxDy;

  /// Maximum horizontal distance reachable.
  final double maxDx;

  /// Builds a reachability template by simulating [profile.maxAirTicks] of flight.
  factory JumpReachabilityTemplate.build(JumpProfile profile) {
    final samples = <JumpSample>[];

    var y = 0.0;
    var velY = -profile.jumpSpeed; // Negative = upward
    final dt = profile.dtSeconds;
    var minDy = 0.0;
    var maxDy = 0.0;
    var maxDxOverall = 0.0;

    for (var tick = 1; tick <= profile.maxAirTicks; tick += 1) {
      final prevY = y;
      
      // Semi-implicit Euler: update velocity first, then position.
      velY += profile.gravityY * dt;
      y += velY * dt;
      
      // Horizontal reach increases linearly with time.
      final maxDx = profile.airSpeedX * dt * tick;
      
      // Track bounding box.
      if (y < minDy) minDy = y;
      if (y > maxDy) maxDy = y;
      if (maxDx > maxDxOverall) maxDxOverall = maxDx;
      
      samples.add(
        JumpSample(
          tick: tick,
          prevY: prevY,
          y: y,
          velY: velY,
          maxDx: maxDx,
        ),
      );
    }

    return JumpReachabilityTemplate._(
      profile: profile,
      samples: List<JumpSample>.unmodifiable(samples),
      minDy: minDy,
      maxDy: maxDy,
      maxDx: maxDxOverall,
    );
  }

  /// Finds the earliest tick at which a jump can land at vertical offset [dy].
  ///
  /// **Parameters**:
  /// - [dy]: Target vertical offset (positive = below takeoff, negative = above).
  /// - [dxMin], [dxMax]: Required horizontal range for a valid landing.
  ///
  /// **Returns**: [JumpLanding] if reachable, null otherwise.
  ///
  /// **Logic**:
  /// 1. Skip ascending samples (velY < 0).
  /// 2. Check if [dy] is crossed between prevY and y.
  /// 3. Check if horizontal range overlaps [dxMin, dxMax].
  JumpLanding? findFirstLanding({
    required double dy,
    required double dxMin,
    required double dxMax,
    double eps = navGeomEps,
  }) {
    if (dxMin > dxMax) return null;

    for (final sample in samples) {
      // Only consider descending phase.
      if (sample.velY < 0) continue;
      
      // Check vertical crossing: prevY <= dy <= y (with tolerance).
      final crosses = (sample.prevY <= dy + eps) && (sample.y >= dy - eps);
      if (!crosses) continue;

      // Check horizontal reachability.
      final maxDx = sample.maxDx;
      if (dxMin > maxDx + eps) continue;  // Target too far right.
      if (dxMax < -maxDx - eps) continue; // Target too far left.
      
      return JumpLanding(tick: sample.tick, maxDx: maxDx);
    }

    return null;
  }
}

/// Estimates the number of ticks to fall a given vertical distance.
///
/// Used for "drop" edges (walking off a ledge without jumping).
///
/// **Parameters**:
/// - [dy]: Distance to fall (positive = downward).
/// - [gravityY]: Gravity acceleration.
/// - [dtSeconds]: Timestep.
/// - [maxTicks]: Upper bound to prevent infinite loops.
int estimateFallTicks({
  required double dy,
  required double gravityY,
  required double dtSeconds,
  required int maxTicks,
}) {
  if (dy <= 0) return 0;
  
  var y = 0.0;
  var velY = 0.0;
  
  for (var tick = 1; tick <= maxTicks; tick += 1) {
    velY += gravityY * dtSeconds;
    y += velY * dtSeconds;
    if (y >= dy) return tick;
  }
  
  return maxTicks;
}


===== FILE: lib/core/navigation/utils/surface_spatial_index.dart =====
import '../../ecs/spatial/grid_index_2d.dart';
import '../types/nav_tolerances.dart';
import '../types/walk_surface.dart';

/// Spatial hash grid for fast AABB queries against [WalkSurface]s.
///
/// **Purpose**:
/// - Given an AABB (e.g., entity bounds), quickly find all surfaces that might overlap.
/// - Avoids O(N) linear scans over all surfaces.
///
/// **Design**:
/// - Uses a uniform grid (via [GridIndex2D]) to bucket surfaces by cell.
/// - Surfaces spanning multiple cells are inserted into each overlapping cell.
/// - A stamp-based deduplication prevents returning the same surface twice per query.
///
/// **Lifecycle**:
/// - Call [rebuild] when static geometry changes (e.g., new chunk loaded).
/// - Call [queryAabb] during gameplay (e.g., to find surfaces under an entity).
class SurfaceSpatialIndex {
  SurfaceSpatialIndex({
    required GridIndex2D index,
    this.surfaceThickness = navSpatialEps,
  }) : _index = index;

  /// The underlying grid coordinate system.
  final GridIndex2D _index;
  
  /// Vertical thickness added above/below each surface for overlap tests.
  final double surfaceThickness;

  /// Cell key -> list of surface indices in that cell.
  final Map<int, List<int>> _buckets = <int, List<int>>{};
  
  /// Keys of all currently populated buckets (for fast clearing).
  final List<int> _activeKeys = <int>[];
  
  /// Pool of reusable bucket lists (reduces GC pressure).
  final List<List<int>> _bucketPool = <List<int>>[];

  /// Stamp-based deduplication: `_seenStampBySurface[i] == _stamp` means already seen.
  final List<int> _seenStampBySurface = <int>[];
  int _stamp = 0;
  int _surfaceCount = 0;

  /// Rebuilds the spatial index from a new set of surfaces.
  ///
  /// **Performance**: O(S * C) where S = surfaces, C = avg cells per surface.
  void rebuild(List<WalkSurface> surfaces) {
    // Return all active buckets to the pool.
    for (var i = 0; i < _activeKeys.length; i += 1) {
      final key = _activeKeys[i];
      final bucket = _buckets.remove(key);
      if (bucket == null) continue;
      bucket.clear();
      _bucketPool.add(bucket);
    }
    _activeKeys.clear();

    _surfaceCount = surfaces.length;
    if (surfaces.isEmpty) return;

    // Insert each surface into all cells it overlaps.
    for (var si = 0; si < surfaces.length; si += 1) {
      final surface = surfaces[si];
      
      // Surface AABB: horizontal span + thin vertical slab.
      final minX = surface.xMin;
      final maxX = surface.xMax;
      final minY = surface.yTop - surfaceThickness;
      final maxY = surface.yTop + surfaceThickness;

      // Convert to cell coordinates.
      final minCx = _index.worldToCellX(minX);
      final maxCx = _index.worldToCellX(maxX);
      final minCy = _index.worldToCellY(minY);
      final maxCy = _index.worldToCellY(maxY);

      // Insert surface index into each overlapping cell.
      for (var cellY = minCy; cellY <= maxCy; cellY += 1) {
        for (var cellX = minCx; cellX <= maxCx; cellX += 1) {
          final key = _index.cellKey(cellX, cellY);
          var bucket = _buckets[key];
          if (bucket == null) {
            // Reuse pooled bucket or allocate new.
            bucket = _bucketPool.isNotEmpty ? _bucketPool.removeLast() : <int>[];
            _buckets[key] = bucket;
            _activeKeys.add(key);
          }
          bucket.add(si);
        }
      }
    }
  }

  /// Finds all surfaces overlapping the given AABB.
  ///
  /// Results are written to [outSurfaceIndices] (cleared first).
  /// Each surface index appears at most once (deduplicated via stamp).
  ///
  /// **Performance**: O(C * B) where C = cells in query, B = avg bucket size.
  void queryAabb({
    required double minX,
    required double minY,
    required double maxX,
    required double maxY,
    required List<int> outSurfaceIndices,
  }) {
    outSurfaceIndices.clear();
    if (_activeKeys.isEmpty) return;

    // Advance the deduplication stamp.
    _stamp += 1;
    if (_stamp == 0x7FFFFFFF) {
      // Overflow protection: reset all stamps.
      for (var i = 0; i < _seenStampBySurface.length; i += 1) {
        _seenStampBySurface[i] = 0;
      }
      _stamp = 1;
    }

    // Determine cell range for query AABB.
    final minCx = _index.worldToCellX(minX);
    final maxCx = _index.worldToCellX(maxX);
    final minCy = _index.worldToCellY(minY);
    final maxCy = _index.worldToCellY(maxY);

    // Ensure stamp array is large enough.
    if (_seenStampBySurface.length < _surfaceCount) {
      final missing = _surfaceCount - _seenStampBySurface.length;
      for (var i = 0; i < missing; i += 1) {
        _seenStampBySurface.add(0);
      }
    }

    // Iterate all cells in query range.
    for (var cellY = minCy; cellY <= maxCy; cellY += 1) {
      for (var cellX = minCx; cellX <= maxCx; cellX += 1) {
        final key = _index.cellKey(cellX, cellY);
        final bucket = _buckets[key];
        if (bucket == null || bucket.isEmpty) continue;

        // Add each unseen surface to results.
        for (var bi = 0; bi < bucket.length; bi += 1) {
          final surfaceIndex = bucket[bi];
          if (_seenStampBySurface[surfaceIndex] == _stamp) continue;
          _seenStampBySurface[surfaceIndex] = _stamp;
          outSurfaceIndices.add(surfaceIndex);
        }
      }
    }
  }
}


===== FILE: lib/core/navigation/utils/trajectory_predictor.dart =====
import '../types/surface_graph.dart';
import 'surface_spatial_index.dart';

/// Prediction result for where an airborne entity will land.
class LandingPrediction {
  const LandingPrediction({
    required this.x,
    required this.bottomY,
    required this.surfaceIndex,
    required this.ticksToLand,
  });

  /// Predicted X position at landing.
  final double x;

  /// Predicted bottom Y position at landing (on surface).
  final double bottomY;

  /// Index of the surface in [SurfaceGraph.surfaces] where landing occurs.
  final int surfaceIndex;

  /// Number of ticks until landing.
  final int ticksToLand;
}

/// Predicts where an airborne entity will land.
///
/// **Purpose**:
/// Used by ground enemy AI to anticipate where an airborne player will land,
/// enabling pathfinding toward the predicted landing spot instead of the
/// player's current (airborne) position.
///
/// **Algorithm**:
/// Simulates the entity's trajectory tick-by-tick using semi-implicit Euler
/// integration (matching [GravitySystem]), checking for surface intersections
/// at each step.
///
/// **Usage**:
/// ```dart
/// final predictor = TrajectoryPredictor(
///   gravityY: physics.gravityY,
///   dtSeconds: movement.dtSeconds,
///   maxTicks: 120,
/// );
///
/// final prediction = predictor.predictLanding(
///   startX: playerX,
///   startBottomY: playerBottomY,
///   velX: playerVelX,
///   velY: playerVelY,
///   graph: surfaceGraph,
///   spatialIndex: surfaceSpatialIndex,
///   entityHalfWidth: playerHalfX,
/// );
/// ```
class TrajectoryPredictor {
  const TrajectoryPredictor({
    required this.gravityY,
    required this.dtSeconds,
    required this.maxTicks,
  });

  /// Gravity acceleration (positive = downward).
  final double gravityY;

  /// Fixed timestep in seconds.
  final double dtSeconds;

  /// Maximum ticks to simulate before giving up.
  final int maxTicks;

  /// Predicts landing position for an airborne entity.
  ///
  /// **Parameters**:
  /// - [startX], [startBottomY]: Current position (bottom of collider).
  /// - [velX], [velY]: Current velocity.
  /// - [graph]: Surface graph for landing candidates.
  /// - [spatialIndex]: Spatial index for fast surface queries.
  /// - [entityHalfWidth]: Half-width of the entity collider.
  ///
  /// **Returns**: [LandingPrediction] if a valid landing is found, null otherwise.
  ///
  /// **Edge Cases**:
  /// - Returns null if entity is moving upward and never descends (shouldn't happen with gravity).
  /// - Returns null if no surface intersects the trajectory within [maxTicks].
  /// - Returns the FIRST valid landing (earliest tick) if multiple surfaces are crossed.
  LandingPrediction? predictLanding({
    required double startX,
    required double startBottomY,
    required double velX,
    required double velY,
    required SurfaceGraph graph,
    required SurfaceSpatialIndex spatialIndex,
    required double entityHalfWidth,
  }) {
    if (graph.surfaces.isEmpty) return null;

    var x = startX;
    var y = startBottomY;
    var vy = velY;
    final dt = dtSeconds;

    // Reusable buffer for spatial queries.
    final candidates = <int>[];

    for (var tick = 1; tick <= maxTicks; tick += 1) {
      final prevY = y;

      // Semi-implicit Euler (matches GravitySystem).
      vy += gravityY * dt;
      y += vy * dt;
      x += velX * dt;

      // Only check for landing when descending (vy > 0 means moving downward).
      if (vy <= 0) continue;

      // Check if we crossed any surface between prevY and y.
      final landing = _findLandingSurface(
        graph: graph,
        spatialIndex: spatialIndex,
        candidates: candidates,
        x: x,
        prevY: prevY,
        y: y,
        entityHalfWidth: entityHalfWidth,
        tick: tick,
      );

      if (landing != null) {
        return landing;
      }
    }

    return null;
  }

  /// Checks if the trajectory crossed a valid landing surface this tick.
  LandingPrediction? _findLandingSurface({
    required SurfaceGraph graph,
    required SurfaceSpatialIndex spatialIndex,
    required List<int> candidates,
    required double x,
    required double prevY,
    required double y,
    required double entityHalfWidth,
    required int tick,
  }) {
    // Query surfaces in the vertical band we just traversed.
    final minY = prevY < y ? prevY : y;
    final maxY = prevY > y ? prevY : y;

    spatialIndex.queryAabb(
      minX: x - entityHalfWidth,
      minY: minY,
      maxX: x + entityHalfWidth,
      maxY: maxY,
      outSurfaceIndices: candidates,
    );

    if (candidates.isEmpty) return null;

    // Find the highest surface (lowest yTop) that we crossed.
    // This handles cases where trajectory passes through multiple surfaces.
    int? bestIndex;
    double? bestYTop;

    for (final surfaceIndex in candidates) {
      final surface = graph.surfaces[surfaceIndex];

      // Check horizontal overlap: entity must fit on surface.
      final entityMinX = x - entityHalfWidth;
      final entityMaxX = x + entityHalfWidth;
      if (entityMinX > surface.xMax || entityMaxX < surface.xMin) continue;

      // Check vertical crossing: prevY was above (or at) surface, y is at or below.
      // We want surfaces where prevY <= yTop <= y (crossed from above).
      final yTop = surface.yTop;
      if (prevY > yTop) continue; // Started below surface, can't land on it.
      if (y < yTop) continue; // Ended above surface, haven't reached it yet.

      // Valid landing candidate. Prefer highest surface (lowest yTop).
      if (bestYTop == null || yTop < bestYTop) {
        bestYTop = yTop;
        bestIndex = surfaceIndex;
      }
    }

    if (bestIndex == null) return null;

    return LandingPrediction(
      x: x,
      bottomY: bestYTop!,
      surfaceIndex: bestIndex,
      ticksToLand: tick,
    );
  }
}


===== FILE: lib/core/pickups/pickup_render_catalog.dart =====
import '../contracts/render_anim_set_definition.dart';
import '../snapshots/entity_render_snapshot.dart';
import '../snapshots/enums.dart';

const int _frameW = 16;
const int _frameH = 16;
const int _frames = 12;
const double _stepSeconds = 0.08;

const Map<AnimKey, int> _frameCountsByKey = <AnimKey, int>{
  AnimKey.idle: _frames,
};

const Map<AnimKey, double> _stepTimeSecondsByKey = <AnimKey, double>{
  AnimKey.idle: _stepSeconds,
};

RenderAnimSetDefinition _rowFromSheet({
  required String assetPath,
  required int row,
}) {
  return RenderAnimSetDefinition(
    frameWidth: _frameW,
    frameHeight: _frameH,
    sourcesByKey: <AnimKey, String>{AnimKey.idle: assetPath},
    frameCountsByKey: _frameCountsByKey,
    stepTimeSecondsByKey: _stepTimeSecondsByKey,
    rowByKey: <AnimKey, int>{AnimKey.idle: row},
  );
}

class PickupRenderCatalog {
  const PickupRenderCatalog();

  RenderAnimSetDefinition get(int pickupVariant) {
    switch (pickupVariant) {
      case PickupVariant.collectible:
        return _rowFromSheet(
          assetPath: 'entities/collectibles/coins.png',
          row: 0,
        );
      case PickupVariant.restorationHealth:
        return _rowFromSheet(
          assetPath: 'entities/regenerationItems/gems.png',
          row: 0,
        );
      case PickupVariant.restorationMana:
        return _rowFromSheet(
          assetPath: 'entities/regenerationItems/gems.png',
          row: 1,
        );
      case PickupVariant.restorationStamina:
        return _rowFromSheet(
          assetPath: 'entities/regenerationItems/gems.png',
          row: 2,
        );
      default:
        throw StateError(
          'No render animation defined for pickupVariant=$pickupVariant.',
        );
    }
  }
}


===== FILE: lib/core/players/characters/eloise.dart =====
library;

import '../../ecs/stores/body_store.dart';
import '../../ecs/stores/combat/creature_tag_store.dart';
import '../../ecs/stores/combat/damage_resistance_store.dart';
import '../../ecs/stores/combat/equipped_loadout_store.dart';
import '../../ecs/stores/combat/status_immunity_store.dart';
import '../../combat/creature_tag.dart';
import '../../snapshots/enums.dart';
import '../../projectiles/projectile_item_id.dart';
import '../../weapons/weapon_id.dart';
import '../player_character_definition.dart';
import '../player_catalog.dart';
import '../player_tuning.dart';
import '../../contracts/render_anim_set_definition.dart';

/// Baseline character definition: Éloïse.
///
/// All current "default player" values in v0 are treated as belonging to Éloïse.

// -----------------------------------------------------------------------------
// Éloïse render animation strip definitions (authoring-time)
// -----------------------------------------------------------------------------

const int eloiseAnimFrameWidth = 100;
const int eloiseAnimFrameHeight = 64;

const int eloiseAnimIdleFrames = 4;
const double eloiseAnimIdleStepSeconds = 0.14;

const int eloiseAnimStunFrames = 4;
const double eloiseAnimStunStepSeconds = 0.14;

const int eloiseAnimRunFrames = 7;
const double eloiseAnimRunStepSeconds = 0.08;

const int eloiseAnimWalkFrames = 7;
const double eloiseAnimWalkStepSeconds = 0.16;

const int eloiseAnimJumpFrames = 6;
const double eloiseAnimJumpStepSeconds = 0.10;

const int eloiseAnimFallFrames = 3;
const double eloiseAnimFallStepSeconds = 0.10;

const int eloiseAnimStrikeFrames = 6;
const double eloiseAnimStrikeStepSeconds = 0.06;

const int eloiseAnimBackStrikeFrames = 5;
const double eloiseAnimBackStrikeStepSeconds = 0.08;

const int eloiseAnimParryFrames = 6;
const double eloiseAnimParryStepSeconds = 0.06;

const int eloiseAnimCastFrames = 5;
const double eloiseAnimCastStepSeconds = 0.08;

const int eloiseAnimRangedFrames = eloiseAnimCastFrames;
const double eloiseAnimRangedStepSeconds = eloiseAnimCastStepSeconds;

// Shield bash should match sword strike tempo (6 frames x 0.06s).
const int eloiseAnimShieldBashFrames = eloiseAnimStrikeFrames;
const double eloiseAnimShieldBashStepSeconds = eloiseAnimStrikeStepSeconds;

// Shield block is authored as its own strip: 7 frames x ~0.052s ~= 0.364s.
// Keep it close to parry/strike total duration (~0.36s) for consistent gameplay timing.
const int eloiseAnimShieldBlockFrames = 7;
const double eloiseAnimShieldBlockStepSeconds = 0.052;

const int eloiseAnimDashFrames = 4;
const double eloiseAnimDashStepSeconds = 0.05;

const int eloiseAnimRollFrames = 10;
const double eloiseAnimRollStepSeconds = 0.05;

const int eloiseAnimHitFrames = 4;
const double eloiseAnimHitStepSeconds = 0.10;

const int eloiseAnimDeathFrames = 6;
const double eloiseAnimDeathStepSeconds = 0.12;

// Spawn reuses idle timing/frames until a dedicated strip exists.
const int eloiseAnimSpawnFrames = eloiseAnimIdleFrames;
const double eloiseAnimSpawnStepSeconds = eloiseAnimIdleStepSeconds;

const Map<AnimKey, int> eloiseAnimFrameCountsByKey = <AnimKey, int>{
  AnimKey.idle: eloiseAnimIdleFrames,
  AnimKey.stun: eloiseAnimStunFrames,
  AnimKey.run: eloiseAnimRunFrames,
  AnimKey.jump: eloiseAnimJumpFrames,
  AnimKey.fall: eloiseAnimFallFrames,
  AnimKey.strike: eloiseAnimStrikeFrames,
  AnimKey.backStrike: eloiseAnimBackStrikeFrames,
  AnimKey.parry: eloiseAnimParryFrames,
  AnimKey.cast: eloiseAnimCastFrames,
  AnimKey.ranged: eloiseAnimRangedFrames,
  AnimKey.shieldBash: eloiseAnimShieldBashFrames,
  AnimKey.shieldBlock: eloiseAnimShieldBlockFrames,
  AnimKey.dash: eloiseAnimDashFrames,
  AnimKey.roll: eloiseAnimRollFrames,
  AnimKey.hit: eloiseAnimHitFrames,
  AnimKey.death: eloiseAnimDeathFrames,
  AnimKey.spawn: eloiseAnimSpawnFrames,
  AnimKey.walk: eloiseAnimWalkFrames,
};

const Map<AnimKey, double> eloiseAnimStepTimeSecondsByKey = <AnimKey, double>{
  AnimKey.idle: eloiseAnimIdleStepSeconds,
  AnimKey.stun: eloiseAnimStunStepSeconds,
  AnimKey.run: eloiseAnimRunStepSeconds,
  AnimKey.jump: eloiseAnimJumpStepSeconds,
  AnimKey.fall: eloiseAnimFallStepSeconds,
  AnimKey.strike: eloiseAnimStrikeStepSeconds,
  AnimKey.backStrike: eloiseAnimBackStrikeStepSeconds,
  AnimKey.parry: eloiseAnimParryStepSeconds,
  AnimKey.cast: eloiseAnimCastStepSeconds,
  AnimKey.ranged: eloiseAnimRangedStepSeconds,
  AnimKey.shieldBash: eloiseAnimShieldBashStepSeconds,
  AnimKey.shieldBlock: eloiseAnimShieldBlockStepSeconds,
  AnimKey.dash: eloiseAnimDashStepSeconds,
  AnimKey.roll: eloiseAnimRollStepSeconds,
  AnimKey.hit: eloiseAnimHitStepSeconds,
  AnimKey.death: eloiseAnimDeathStepSeconds,
  AnimKey.spawn: eloiseAnimSpawnStepSeconds,
  AnimKey.walk: eloiseAnimWalkStepSeconds,
};

const Map<AnimKey, String> eloiseAnimSourcesByKey = <AnimKey, String>{
  AnimKey.idle: 'entities/player/idle.png',
  AnimKey.stun: 'entities/player/stun.png',
  AnimKey.run: 'entities/player/move.png',
  AnimKey.jump: 'entities/player/jump.png',
  AnimKey.fall: 'entities/player/fall.png',
  AnimKey.strike: 'entities/player/strike.png',
  AnimKey.backStrike: 'entities/player/back_strike.png',
  AnimKey.parry: 'entities/player/parry.png',
  AnimKey.cast: 'entities/player/cast.png',
  AnimKey.ranged: 'entities/player/cast.png',
  AnimKey.shieldBash: 'entities/player/shield_bash.png',
  AnimKey.shieldBlock: 'entities/player/shield_block.png',
  AnimKey.dash: 'entities/player/dash.png',
  AnimKey.roll: 'entities/player/roll.png',
  AnimKey.hit: 'entities/player/hit.png',
  AnimKey.death: 'entities/player/death.png',
  AnimKey.spawn: 'entities/player/idle.png',
  AnimKey.walk: 'entities/player/walk.png',
};

const RenderAnimSetDefinition eloiseRenderAnim = RenderAnimSetDefinition(
  frameWidth: eloiseAnimFrameWidth,
  frameHeight: eloiseAnimFrameHeight,
  sourcesByKey: eloiseAnimSourcesByKey,
  frameCountsByKey: eloiseAnimFrameCountsByKey,
  stepTimeSecondsByKey: eloiseAnimStepTimeSecondsByKey,
);

// -----------------------------------------------------------------------------
// Éloïse authored Core values (single-file source of truth)
// -----------------------------------------------------------------------------

const PlayerCatalog eloiseCatalog = PlayerCatalog(
  bodyTemplate: BodyDef(
    isKinematic: false,
    useGravity: true,
    ignoreCeilings: false,
    topOnlyGround: true,
    gravityScale: 1.0,
    sideMask: BodyDef.sideLeft | BodyDef.sideRight,
  ),
  colliderWidth: 22.0,
  colliderHeight: 46.0,
  colliderOffsetX: 0.0,
  colliderOffsetY: 0.0,
  tags: CreatureTagDef(mask: CreatureTagMask.humanoid),
  resistance: DamageResistanceDef(),
  statusImmunity: StatusImmunityDef(),
  loadoutSlotMask: LoadoutSlotMask.all,
  weaponId: WeaponId.basicSword,
  offhandWeaponId: WeaponId.basicShield,
  projectileItemId: ProjectileItemId.fireBolt,
  facing: Facing.right,
);

const PlayerTuning eloiseTuning = PlayerTuning(
  movement: MovementTuning(
    maxSpeedX: 200,
    accelerationX: 600,
    decelerationX: 400,
    minMoveSpeed: 5,
    runSpeedThresholdX: 120,
    maxVelX: 1500,
    maxVelY: 1500,
    jumpSpeed: 500,
    coyoteTimeSeconds: 0.10,
    jumpBufferSeconds: 0.12,
    dashSpeedX: 550,
    dashDurationSeconds: 0.20,
    dashCooldownSeconds: 2.0,
  ),
  resource: ResourceTuning(
    playerHpMax: 100,
    playerHpRegenPerSecond: 0.5,
    playerManaMax: 100,
    playerManaRegenPerSecond: 2.0,
    playerStaminaMax: 100,
    playerStaminaRegenPerSecond: 1.0,
    jumpStaminaCost: 2,
    dashStaminaCost: 2,
  ),
  ability: AbilityTuning(
    castCooldownSeconds: 0.25,
    meleeCooldownSeconds: 0.30,
    meleeActiveSeconds: 0.10,
    meleeStaminaCost: 5.0,
    meleeDamage: 15.0,
    meleeHitboxSizeX: 32.0,
    meleeHitboxSizeY: 32.0,
  ),
  // Keep these windows in sync with Éloïse's render strips above.
  anim: AnimTuning(
    hitAnimSeconds: eloiseAnimHitFrames * eloiseAnimHitStepSeconds,
    castAnimSeconds: eloiseAnimCastFrames * eloiseAnimCastStepSeconds,
    strikeAnimSeconds: eloiseAnimStrikeFrames * eloiseAnimStrikeStepSeconds,
    backStrikeAnimSeconds:
        eloiseAnimBackStrikeFrames * eloiseAnimBackStrikeStepSeconds,
    parryAnimSeconds: eloiseAnimParryFrames * eloiseAnimParryStepSeconds,
    rangedAnimSeconds: eloiseAnimRangedFrames * eloiseAnimRangedStepSeconds,
    dashAnimSeconds: eloiseAnimDashFrames * eloiseAnimDashStepSeconds,
    rollAnimSeconds: eloiseAnimRollFrames * eloiseAnimRollStepSeconds,
    deathAnimSeconds: eloiseAnimDeathFrames * eloiseAnimDeathStepSeconds,
    spawnAnimSeconds: eloiseAnimSpawnFrames * eloiseAnimSpawnStepSeconds,
  ),
  combat: CombatTuning(invulnerabilitySeconds: 0.25),
);

const PlayerCharacterDefinition eloiseCharacter = PlayerCharacterDefinition(
  id: PlayerCharacterId.eloise,
  displayName: 'Éloïse',
  renderAnim: eloiseRenderAnim,
  catalog: eloiseCatalog,
  tuning: eloiseTuning,
);


===== FILE: lib/core/players/player_archetype.dart =====
import '../ecs/stores/body_store.dart';
import '../ecs/stores/collider_aabb_store.dart';
import '../ecs/stores/combat/creature_tag_store.dart';
import '../ecs/stores/combat/damage_resistance_store.dart';
import '../ecs/stores/combat/equipped_loadout_store.dart';
import '../ecs/stores/combat/status_immunity_store.dart';
import '../ecs/stores/health_store.dart';
import '../ecs/stores/mana_store.dart';
import '../ecs/stores/stamina_store.dart';
import '../snapshots/enums.dart';
import '../projectiles/projectile_item_id.dart';
import '../weapons/weapon_id.dart';

/// Fully-resolved player configuration used to spawn the player entity.
///
/// **Purpose**:
/// Contains all the component definitions needed to instantiate a player
/// entity in the ECS world. Unlike [PlayerCatalog], which holds authoring-time
/// templates, this class holds final, tick-rate-independent values ready for
/// entity creation.
///
/// **Lifecycle**:
/// 1. [PlayerCatalog] defines base templates (physics flags, default facing).
/// 2. [PlayerCatalogDerived.from] merges templates with tuning data to produce
///    a [PlayerArchetype].
/// 3. [EntityFactory.createPlayer] uses the archetype to add components..
class PlayerArchetype {
  const PlayerArchetype({
    required this.collider,
    required this.body,
    required this.health,
    required this.mana,
    required this.stamina,
    this.tags = const CreatureTagDef(),
    this.resistance = const DamageResistanceDef(),
    this.statusImmunity = const StatusImmunityDef(),
    this.loadoutSlotMask = LoadoutSlotMask.defaultMask,
    this.weaponId = WeaponId.basicSword,
    this.offhandWeaponId = WeaponId.basicShield,
    this.projectileItemId = ProjectileItemId.iceBolt,
    this.facing = Facing.right,
  });

  /// AABB collider definition (half-extents and offset).
  ///
  /// Determines the player's collision bounds for physics and hit detection.
  /// Typically derived from [PlayerCatalog.colliderWidth] and
  /// [PlayerCatalog.colliderHeight].
  final ColliderAabbDef collider;

  /// Physics body configuration (gravity, kinematic flags, velocity clamps).
  ///
  /// Controls how the player interacts with the physics simulation:
  /// - `useGravity`: Whether gravity affects the player.
  /// - `maxVelX/maxVelY`: Velocity clamps from movement tuning.
  /// - `sideMask`: Which collision sides are active.
  final BodyDef body;

  /// Health pool definition (current HP, max HP, regeneration rate).
  ///
  /// Values derived from [ResourceTuning.playerHpMax] and related fields.
  final HealthDef health;

  /// Mana pool definition (current mana, max mana, regeneration rate).
  ///
  /// Used for projectile abilities. Values from [ResourceTuning.playerManaMax].
  final ManaDef mana;

  /// Stamina pool definition (current stamina, max stamina, regeneration rate).
  ///
  /// Used for abilities like dash. Values from [ResourceTuning.playerStaminaMax].
  final StaminaDef stamina;

  /// Broad tags used by combat rules and content filters.
  final CreatureTagDef tags;

  /// Resistance/vulnerability modifiers by damage type.
  final DamageResistanceDef resistance;

  /// Status effect immunities for the player.
  final StatusImmunityDef statusImmunity;

  /// Bitmask of enabled loadout slots (see [LoadoutSlotMask]).
  final int loadoutSlotMask;

  /// Equipped weapon used for melee strikes.
  final WeaponId weaponId;

  /// Equipped off-hand weapon or shield.
  final WeaponId offhandWeaponId;

  /// Equipped projectile item used for thrown/ballistic projectiles.
  final ProjectileItemId projectileItemId;

  /// Initial facing direction when the player spawns.
  ///
  /// Affects sprite rendering and directional abilities.
  final Facing facing;
}


===== FILE: lib/core/players/player_catalog.dart =====
import '../combat/creature_tag.dart';
import '../ecs/stores/body_store.dart';
import '../ecs/stores/collider_aabb_store.dart';
import '../ecs/stores/combat/creature_tag_store.dart';
import '../ecs/stores/combat/damage_resistance_store.dart';
import '../ecs/stores/combat/equipped_loadout_store.dart';
import '../ecs/stores/combat/status_immunity_store.dart';
import '../ecs/stores/health_store.dart';
import '../ecs/stores/mana_store.dart';
import '../ecs/stores/stamina_store.dart';
import '../snapshots/enums.dart';
import 'player_tuning.dart';
import '../projectiles/projectile_item_id.dart';
import '../weapons/weapon_id.dart';
import 'player_archetype.dart';

/// Authoring-time configuration for the player entity.
///
/// **Purpose**:
/// Defines the base template for player physics and spawn behavior. This class
/// holds values that are independent of tick rate or specific tuning numbers,
/// focusing on structural configuration (what physics flags to use, etc.).
///
/// **Relationship to Tuning**:
/// - [PlayerCatalog]: Structural config (physics flags, collision sides).
/// - [MovementTuning]: Numeric movement values (speed, collider size, velocity clamps).
/// - [ResourceTuning]: Numeric resource values (HP, mana, stamina).
///
/// The [PlayerCatalogDerived.from] factory merges all three to produce a
/// complete [PlayerArchetype] ready for entity creation.
class PlayerCatalog {
  const PlayerCatalog({
    this.bodyTemplate = const BodyDef(
      isKinematic: false,
      useGravity: true,
      ignoreCeilings: false,
      topOnlyGround: true,
      gravityScale: 1.0,
      sideMask: BodyDef.sideLeft | BodyDef.sideRight,
    ),
    this.colliderWidth = 22.0,
    this.colliderHeight = 46.0,
    this.colliderOffsetX = 0.0,
    this.colliderOffsetY = -6.0,
    this.tags = const CreatureTagDef(mask: CreatureTagMask.humanoid),
    this.resistance = const DamageResistanceDef(),
    this.statusImmunity = const StatusImmunityDef(),
    this.loadoutSlotMask = LoadoutSlotMask.defaultMask,
    this.weaponId = WeaponId.basicSword,
    this.offhandWeaponId = WeaponId.basicShield,
    this.projectileItemId = ProjectileItemId.iceBolt,
    this.facing = Facing.right,
  });

  /// Template for how the player participates in physics.
  ///
  /// **Fields used from template**:
  /// - `isKinematic`: False for player (affected by forces).
  /// - `useGravity`: True (player falls).
  /// - `ignoreCeilings`: False (player collides with ceilings).
  /// - `topOnlyGround`: True (only collide with top of ground, not sides).
  /// - `gravityScale`: 1.0 (normal gravity).
  /// - `sideMask`: Left + Right (collide with walls on both sides).
  ///
  /// **Fields filled from [MovementTuning] during derivation**:
  /// - `maxVelX`: Horizontal velocity clamp.
  /// - `maxVelY`: Vertical velocity clamp.
  ///
  /// This split ensures movement tuning remains the single source of truth
  /// for velocity limits.
  final BodyDef bodyTemplate;

  /// Player collision AABB size (full extents) in world units.
  ///
  /// Core uses center-based AABBs, so `halfX = width * 0.5` and
  /// `halfY = height * 0.5`.
  final double colliderWidth;
  final double colliderHeight;

  /// Optional collider center offset from entity `Transform.pos`.
  final double colliderOffsetX;
  final double colliderOffsetY;

  double get colliderHalfX => colliderWidth * 0.5;
  double get colliderHalfY => colliderHeight * 0.5;
  double get colliderMaxHalfExtent =>
      colliderHalfX > colliderHalfY ? colliderHalfX : colliderHalfY;

  /// Broad tags used by combat rules and content filters.
  final CreatureTagDef tags;

  /// Resistance/vulnerability modifiers by damage type.
  final DamageResistanceDef resistance;

  /// Status effect immunities for the player.
  final StatusImmunityDef statusImmunity;

  /// Bitmask of enabled loadout slots (see [LoadoutSlotMask]).
  final int loadoutSlotMask;

  /// Default equipped weapon at spawn time.
  final WeaponId weaponId;

  /// Default equipped off-hand weapon or shield at spawn time.
  final WeaponId offhandWeaponId;

  /// Default equipped projectile item at spawn time.
  final ProjectileItemId projectileItemId;

  /// Default facing direction at spawn time.
  ///
  /// Determines initial sprite orientation and directional ability targeting.
  final Facing facing;
}

/// Derived player configuration with tick-rate-resolved values.
///
/// **Purpose**:
/// Combines [PlayerCatalog] templates with [MovementTuning] and [ResourceTuning]
/// to produce a complete [PlayerArchetype]. This is the "compiled" form of
/// player configuration, ready for entity creation.
///
/// **Why a Separate Class?**:
/// - Tuning values may be tick-rate dependent (e.g., regen per second → per tick).
/// - Collider size comes from movement tuning, not catalog.
/// - Resource pools (HP, mana, stamina) come from resource tuning.
/// - Keeping derivation explicit makes dependencies clear and testable.
///
/// **Lifecycle**:
/// Created once at game initialization, stored in [GameCore], used whenever
/// the player needs to be spawned or respawned.
class PlayerCatalogDerived {
  const PlayerCatalogDerived._({required this.archetype});

  /// Creates a derived catalog by merging base config with tuning data.
  ///
  /// **Parameters**:
  /// - [base]: The authoring-time catalog with physics flags.
  /// - [movement]: Movement tuning for collider size and velocity clamps.
  /// - [resources]: Resource tuning for HP, mana, and stamina pools.
  ///
  /// **Derivation Logic**:
  /// 1. Copy physics flags from [base.bodyTemplate].
  /// 2. Fill `maxVelX`/`maxVelY` from [movement].
  /// 3. Create AABB collider from [base].
  /// 4. Create resource pools from [resources].
  /// 5. Bundle everything into a [PlayerArchetype].
  factory PlayerCatalogDerived.from(
    PlayerCatalog base, {
    required MovementTuningDerived movement,
    required ResourceTuningDerived resources,
  }) {
    // Merge body template with velocity clamps from movement tuning.
    final body = BodyDef(
      enabled: base.bodyTemplate.enabled,
      isKinematic: base.bodyTemplate.isKinematic,
      useGravity: base.bodyTemplate.useGravity,
      ignoreCeilings: base.bodyTemplate.ignoreCeilings,
      topOnlyGround: base.bodyTemplate.topOnlyGround,
      gravityScale: base.bodyTemplate.gravityScale,
      maxVelX: movement.base.maxVelX,
      maxVelY: movement.base.maxVelY,
      sideMask: base.bodyTemplate.sideMask,
    );

    // AABB collider from catalog.
    final collider = ColliderAabbDef(
      halfX: base.colliderHalfX,
      halfY: base.colliderHalfY,
      offsetX: base.colliderOffsetX,
      offsetY: base.colliderOffsetY,
    );

    // Resource pools from resource tuning.
    final health = HealthDef(
      hp: resources.playerHpMax100,
      hpMax: resources.playerHpMax100,
      regenPerSecond100: resources.playerHpRegenPerSecond100,
    );
    final mana = ManaDef(
      mana: resources.playerManaMax100,
      manaMax: resources.playerManaMax100,
      regenPerSecond100: resources.playerManaRegenPerSecond100,
    );
    final stamina = StaminaDef(
      stamina: resources.playerStaminaMax100,
      staminaMax: resources.playerStaminaMax100,
      regenPerSecond100: resources.playerStaminaRegenPerSecond100,
    );

    return PlayerCatalogDerived._(
      archetype: PlayerArchetype(
        collider: collider,
        body: body,
        health: health,
        mana: mana,
        stamina: stamina,
        tags: base.tags,
        resistance: base.resistance,
        statusImmunity: base.statusImmunity,
        loadoutSlotMask: base.loadoutSlotMask,
        weaponId: base.weaponId,
        offhandWeaponId: base.offhandWeaponId,
        projectileItemId: base.projectileItemId,
        facing: base.facing,
      ),
    );
  }

  /// The fully-resolved player archetype ready for entity creation.
  ///
  /// Use this with [EntityFactory.createPlayer] to spawn the player entity.
  final PlayerArchetype archetype;
}


===== FILE: lib/core/players/player_character_definition.dart =====
library;

import '../contracts/render_anim_set_definition.dart';
import '../snapshots/enums.dart';
import 'player_tuning.dart';
import 'player_catalog.dart';

enum PlayerCharacterId { eloise }

class PlayerCharacterDefinition {
  const PlayerCharacterDefinition({
    required this.id,
    required this.displayName,
    required this.renderAnim,
    this.catalog = const PlayerCatalog(),
    this.tuning = const PlayerTuning(),
  });

  final PlayerCharacterId id;
  final String displayName;

  /// Render-only animation metadata (strip paths, frame size, timing).
  ///
  /// Core owns the timing numbers so render strips and deterministic animation
  /// windows can stay in sync, but the renderer remains the only layer that
  /// loads assets.
  final RenderAnimSetDefinition renderAnim;

  /// Structural player configuration (collider size/offset, physics flags, etc.).
  final PlayerCatalog catalog;

  /// Per-character numeric tuning bundle.
  final PlayerTuning tuning;

  PlayerCharacterDefinition copyWith({
    String? displayName,
    RenderAnimSetDefinition? renderAnim,
    PlayerCatalog? catalog,
    PlayerTuning? tuning,
  }) {
    return PlayerCharacterDefinition(
      id: id,
      displayName: displayName ?? this.displayName,
      renderAnim: renderAnim ?? this.renderAnim,
      catalog: catalog ?? this.catalog,
      tuning: tuning ?? this.tuning,
    );
  }

  /// Debug-only validation for authoring-time character definitions.
  ///
  /// This is intended to fail fast during development when a new character is
  /// added with incomplete render strip metadata or invalid collider sizes.
  ///
  /// In release builds, asserts are stripped and this becomes a no-op.
  void assertValid() {
    assert(() {
      if (displayName.trim().isEmpty) {
        throw StateError(
          'PlayerCharacterDefinition($id) has empty displayName',
        );
      }

      // Catalog invariants.
      if (!catalog.colliderWidth.isFinite ||
          !catalog.colliderHeight.isFinite ||
          catalog.colliderWidth <= 0 ||
          catalog.colliderHeight <= 0) {
        throw StateError(
          'PlayerCharacterDefinition($id) has invalid collider size '
          '(width=${catalog.colliderWidth}, height=${catalog.colliderHeight})',
        );
      }
      if (!catalog.colliderOffsetX.isFinite ||
          !catalog.colliderOffsetY.isFinite) {
        throw StateError(
          'PlayerCharacterDefinition($id) has non-finite collider offsets '
          '(x=${catalog.colliderOffsetX}, y=${catalog.colliderOffsetY})',
        );
      }

      // Render anim invariants.
      if (renderAnim.frameWidth <= 0 || renderAnim.frameHeight <= 0) {
        throw StateError(
          'PlayerCharacterDefinition($id) has invalid render frame size '
          '(${renderAnim.frameWidth}x${renderAnim.frameHeight})',
        );
      }
      if (!renderAnim.sourcesByKey.containsKey(AnimKey.idle)) {
        throw StateError(
          'PlayerCharacterDefinition($id) renderAnim.sourcesByKey must include AnimKey.idle',
        );
      }
      if (!renderAnim.frameCountsByKey.containsKey(AnimKey.idle)) {
        throw StateError(
          'PlayerCharacterDefinition($id) renderAnim.frameCountsByKey must include AnimKey.idle',
        );
      }
      if (!renderAnim.stepTimeSecondsByKey.containsKey(AnimKey.idle)) {
        throw StateError(
          'PlayerCharacterDefinition($id) renderAnim.stepTimeSecondsByKey must include AnimKey.idle',
        );
      }

      for (final entry in renderAnim.sourcesByKey.entries) {
        final key = entry.key;
        final path = entry.value;
        if (path.trim().isEmpty) {
          throw StateError(
            'PlayerCharacterDefinition($id) renderAnim.sourcesByKey[$key] is empty',
          );
        }

        // Frame counts / step times are allowed to be omitted per-key; render
        // falls back to the `idle` values in that case. If a value is provided
        // for the key, validate it.
        final count = renderAnim.frameCountsByKey[key];
        if (count != null && count <= 0) {
          throw StateError(
            'PlayerCharacterDefinition($id) renderAnim.frameCountsByKey[$key] must be > 0 (got $count)',
          );
        }
        final seconds = renderAnim.stepTimeSecondsByKey[key];
        if (seconds != null && (!seconds.isFinite || seconds <= 0)) {
          throw StateError(
            'PlayerCharacterDefinition($id) renderAnim.stepTimeSecondsByKey[$key] must be > 0 (got $seconds)',
          );
        }
      }

      for (final entry in renderAnim.frameCountsByKey.entries) {
        final key = entry.key;
        final count = entry.value;
        if (count <= 0) {
          throw StateError(
            'PlayerCharacterDefinition($id) renderAnim.frameCountsByKey[$key] must be > 0 (got $count)',
          );
        }
        if (key != AnimKey.idle && !renderAnim.sourcesByKey.containsKey(key)) {
          throw StateError(
            'PlayerCharacterDefinition($id) renderAnim.frameCountsByKey[$key] has no matching sourcesByKey entry',
          );
        }
      }

      for (final entry in renderAnim.stepTimeSecondsByKey.entries) {
        final key = entry.key;
        final seconds = entry.value;
        if (!seconds.isFinite || seconds <= 0) {
          throw StateError(
            'PlayerCharacterDefinition($id) renderAnim.stepTimeSecondsByKey[$key] must be > 0 (got $seconds)',
          );
        }
        if (key != AnimKey.idle && !renderAnim.sourcesByKey.containsKey(key)) {
          throw StateError(
            'PlayerCharacterDefinition($id) renderAnim.stepTimeSecondsByKey[$key] has no matching sourcesByKey entry',
          );
        }
      }

      for (final entry in renderAnim.rowByKey.entries) {
        final key = entry.key;
        final row = entry.value;
        if (row < 0) {
          throw StateError(
            'PlayerCharacterDefinition($id) renderAnim.rowByKey[$key] must be >= 0 (got $row)',
          );
        }
        if (!renderAnim.sourcesByKey.containsKey(key)) {
          throw StateError(
            'PlayerCharacterDefinition($id) renderAnim.rowByKey[$key] has no matching sourcesByKey entry',
          );
        }
        if (!renderAnim.frameCountsByKey.containsKey(key)) {
          throw StateError(
            'PlayerCharacterDefinition($id) renderAnim.rowByKey[$key] has no matching frameCountsByKey entry',
          );
        }
      }

      for (final entry in renderAnim.frameStartByKey.entries) {
        final key = entry.key;
        final start = entry.value;
        if (start < 0) {
          throw StateError(
            'PlayerCharacterDefinition($id) renderAnim.frameStartByKey[$key] must be >= 0 (got $start)',
          );
        }
        if (!renderAnim.sourcesByKey.containsKey(key)) {
          throw StateError(
            'PlayerCharacterDefinition($id) renderAnim.frameStartByKey[$key] has no matching sourcesByKey entry',
          );
        }
        if (!renderAnim.frameCountsByKey.containsKey(key)) {
          throw StateError(
            'PlayerCharacterDefinition($id) renderAnim.frameStartByKey[$key] has no matching frameCountsByKey entry',
          );
        }
      }

      final anchor = renderAnim.anchorInFramePx;
      if (anchor != null) {
        if (!anchor.x.isFinite || !anchor.y.isFinite) {
          throw StateError(
            'PlayerCharacterDefinition($id) renderAnim.anchorInFramePx must be finite (got $anchor)',
          );
        }
        if (anchor.x < 0 ||
            anchor.x > renderAnim.frameWidth ||
            anchor.y < 0 ||
            anchor.y > renderAnim.frameHeight) {
          throw StateError(
            'PlayerCharacterDefinition($id) renderAnim.anchorInFramePx must be within the frame '
            '(0..${renderAnim.frameWidth}, 0..${renderAnim.frameHeight}). Got $anchor',
          );
        }
      }

      // Tuning invariants (only basic sanity checks here).
      if (!tuning.anim.hitAnimSeconds.isFinite ||
          !tuning.anim.castAnimSeconds.isFinite ||
          !tuning.anim.strikeAnimSeconds.isFinite ||
          !tuning.anim.deathAnimSeconds.isFinite ||
          !tuning.anim.spawnAnimSeconds.isFinite ||
          !tuning.anim.rangedAnimSeconds.isFinite) {
        throw StateError(
          'PlayerCharacterDefinition($id) has non-finite AnimTuning seconds',
        );
      }

      return true;
    }());
  }
}


===== FILE: lib/core/players/player_character_registry.dart =====
library;

import 'characters/eloise.dart';
import 'player_character_definition.dart';

class PlayerCharacterRegistry {
  const PlayerCharacterRegistry._();

  static const PlayerCharacterDefinition eloise = eloiseCharacter;

  static const PlayerCharacterDefinition defaultCharacter = eloise;

  static const List<PlayerCharacterDefinition> all = [eloise];

  static final Map<PlayerCharacterId, PlayerCharacterDefinition> byId =
      _buildById(all);

  static Map<PlayerCharacterId, PlayerCharacterDefinition> _buildById(
    List<PlayerCharacterDefinition> defs,
  ) {
    assert(() {
      for (final d in defs) {
        d.assertValid();
      }
      return true;
    }());

    final map = <PlayerCharacterId, PlayerCharacterDefinition>{};
    for (final d in defs) {
      final existing = map[d.id];
      if (existing != null) {
        throw StateError('Duplicate PlayerCharacterId ${d.id} in registry');
      }
      map[d.id] = d;
    }
    return map;
  }
}


===== FILE: lib/core/players/player_tuning.dart =====
/// Player tuning (single-file source of truth).
///
/// This module intentionally centralizes all player-specific tuning:
/// movement + resources + abilities + combat + animation (and derived/cache
/// variants). This keeps per-character definitions DRY: they can reference a
/// single import and override only what differs.
library;

import '../snapshots/enums.dart';
import '../util/tick_math.dart';
import '../util/fixed_math.dart';
import '../tuning/utils/anim_tuning.dart' as anim_utils;

// ─────────────────────────────────────────────────────────────────────────────
// Player animation strip definitions (frame counts / step times) live in
// character files (e.g. `lib/core/players/characters/eloise.dart`).
// ─────────────────────────────────────────────────────────────────────────────

// Keep [AnimTuning] windows in sync with the selected character's strips.

// ─────────────────────────────────────────────────────────────────────────────
// Player movement tuning (author in seconds, applied per fixed tick)
// ─────────────────────────────────────────────────────────────────────────────

const int defaultTickHz = 60;

class MovementTuning {
  const MovementTuning({
    this.maxSpeedX = 200,
    this.accelerationX = 600,
    this.decelerationX = 400,
    this.minMoveSpeed = 5,
    this.runSpeedThresholdX = 60,
    this.maxVelX = 1500,
    this.maxVelY = 1500,
    this.jumpSpeed = 500,
    this.coyoteTimeSeconds = 0.10,
    this.jumpBufferSeconds = 0.12,
    this.dashSpeedX = 550,
    this.dashDurationSeconds = 0.20,
    this.dashCooldownSeconds = 2.0,
  });

  final double maxSpeedX;
  final double accelerationX;
  final double decelerationX;
  final double minMoveSpeed;
  final double runSpeedThresholdX;

  final double maxVelX;
  final double maxVelY;

  final double jumpSpeed;

  final double coyoteTimeSeconds;
  final double jumpBufferSeconds;

  final double dashSpeedX;
  final double dashDurationSeconds;
  final double dashCooldownSeconds;
}

class MovementTuningDerived {
  const MovementTuningDerived._({
    required this.tickHz,
    required this.dtSeconds,
    required this.base,
    required this.coyoteTicks,
    required this.jumpBufferTicks,
    required this.dashDurationTicks,
    required this.dashCooldownTicks,
  });

  factory MovementTuningDerived.from(MovementTuning base, {required int tickHz}) {
    if (tickHz <= 0) {
      throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
    }
    return MovementTuningDerived._(
      tickHz: tickHz,
      dtSeconds: 1.0 / tickHz,
      base: base,
      coyoteTicks: ticksFromSecondsCeil(base.coyoteTimeSeconds, tickHz),
      jumpBufferTicks: ticksFromSecondsCeil(base.jumpBufferSeconds, tickHz),
      dashDurationTicks: ticksFromSecondsCeil(base.dashDurationSeconds, tickHz),
      dashCooldownTicks: ticksFromSecondsCeil(base.dashCooldownSeconds, tickHz),
    );
  }

  final int tickHz;
  final double dtSeconds;
  final MovementTuning base;

  final int coyoteTicks;
  final int jumpBufferTicks;
  final int dashDurationTicks;
  final int dashCooldownTicks;
}

// ─────────────────────────────────────────────────────────────────────────────
// Player resources tuning (hp/mana/stamina + regen + costs)
// ─────────────────────────────────────────────────────────────────────────────

class ResourceTuning {
  const ResourceTuning({
    this.playerHpMax = 100,
    this.playerHpRegenPerSecond = 0.5,
    this.playerManaMax = 100,
    this.playerManaRegenPerSecond = 2.0,
    this.playerStaminaMax = 100,
    this.playerStaminaRegenPerSecond = 1.0,
    this.jumpStaminaCost = 2,
    this.dashStaminaCost = 2,
  });

  final double playerHpMax;
  final double playerHpRegenPerSecond;

  final double playerManaMax;
  final double playerManaRegenPerSecond;

  final double playerStaminaMax;
  final double playerStaminaRegenPerSecond;

  final double jumpStaminaCost;
  final double dashStaminaCost;
}

class ResourceTuningDerived {
  const ResourceTuningDerived({
    required this.playerHpMax100,
    required this.playerHpRegenPerSecond100,
    required this.playerManaMax100,
    required this.playerManaRegenPerSecond100,
    required this.playerStaminaMax100,
    required this.playerStaminaRegenPerSecond100,
    required this.jumpStaminaCost100,
    required this.dashStaminaCost100,
  });

  factory ResourceTuningDerived.from(ResourceTuning base) {
    return ResourceTuningDerived(
      playerHpMax100: toFixed100(base.playerHpMax),
      playerHpRegenPerSecond100: toFixed100(base.playerHpRegenPerSecond),
      playerManaMax100: toFixed100(base.playerManaMax),
      playerManaRegenPerSecond100: toFixed100(base.playerManaRegenPerSecond),
      playerStaminaMax100: toFixed100(base.playerStaminaMax),
      playerStaminaRegenPerSecond100: toFixed100(base.playerStaminaRegenPerSecond),
      jumpStaminaCost100: toFixed100(base.jumpStaminaCost),
      dashStaminaCost100: toFixed100(base.dashStaminaCost),
    );
  }

  /// Fixed-point: 100 = 1.0
  final int playerHpMax100;
  final int playerHpRegenPerSecond100;
  final int playerManaMax100;
  final int playerManaRegenPerSecond100;
  final int playerStaminaMax100;
  final int playerStaminaRegenPerSecond100;
  final int jumpStaminaCost100;
  final int dashStaminaCost100;
}

// ─────────────────────────────────────────────────────────────────────────────
// Player ability tuning (cast, melee)
// ─────────────────────────────────────────────────────────────────────────────

class AbilityTuning {
  const AbilityTuning({
    this.castCooldownSeconds = 0.25,
    this.meleeCooldownSeconds = 0.30,
    this.meleeActiveSeconds = 0.10,
    this.meleeStaminaCost = 5.0,
    this.meleeDamage = 15.0,
    this.meleeHitboxSizeX = 32.0,
    this.meleeHitboxSizeY = 16.0,
    this.inputBufferSeconds = 0.15,
  });

  final double castCooldownSeconds;
  final double meleeCooldownSeconds;
  final double meleeActiveSeconds;

  final double meleeStaminaCost;
  final double meleeDamage;

  final double meleeHitboxSizeX;
  final double meleeHitboxSizeY;
  final double inputBufferSeconds;
}

class AbilityTuningDerived {
  const AbilityTuningDerived._({
    required this.tickHz,
    required this.base,
    required this.castCooldownTicks,
    required this.meleeCooldownTicks,
    required this.meleeActiveTicks,
    required this.inputBufferTicks,
  });

  factory AbilityTuningDerived.from(AbilityTuning base, {required int tickHz}) {
    if (tickHz <= 0) {
      throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
    }

    return AbilityTuningDerived._(
      tickHz: tickHz,
      base: base,
      castCooldownTicks: ticksFromSecondsCeil(base.castCooldownSeconds, tickHz),
      meleeCooldownTicks: ticksFromSecondsCeil(base.meleeCooldownSeconds, tickHz),
      meleeActiveTicks: ticksFromSecondsCeil(base.meleeActiveSeconds, tickHz),
      inputBufferTicks: ticksFromSecondsCeil(base.inputBufferSeconds, tickHz),
    );
  }

  final int tickHz;
  final AbilityTuning base;

  final int castCooldownTicks;
  final int meleeCooldownTicks;
  final int meleeActiveTicks;
  final int inputBufferTicks;
}

// ─────────────────────────────────────────────────────────────────────────────
// Player combat tuning (invulnerability)
// ─────────────────────────────────────────────────────────────────────────────

class CombatTuning {
  const CombatTuning({this.invulnerabilitySeconds = 0.25});

  final double invulnerabilitySeconds;
}

class CombatTuningDerived {
  const CombatTuningDerived._({
    required this.tickHz,
    required this.base,
    required this.invulnerabilityTicks,
  });

  factory CombatTuningDerived.from(CombatTuning base, {required int tickHz}) {
    if (tickHz <= 0) {
      throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
    }

    return CombatTuningDerived._(
      tickHz: tickHz,
      base: base,
      invulnerabilityTicks: ticksFromSecondsCeil(
        base.invulnerabilitySeconds,
        tickHz,
      ),
    );
  }

  final int tickHz;
  final CombatTuning base;

  final int invulnerabilityTicks;
}

// ─────────────────────────────────────────────────────────────────────────────
// Player animation tuning (timing windows)
// ─────────────────────────────────────────────────────────────────────────────

class AnimTuning {
  const AnimTuning({
    this.hitAnimSeconds = 0.40,
    this.castAnimSeconds = 0.40,
    this.strikeAnimSeconds = 0.36,
    this.backStrikeAnimSeconds = 0.36,
    this.parryAnimSeconds = 0.36,
    this.rangedAnimSeconds = 0.40,
    this.dashAnimSeconds = 0.20,
    this.rollAnimSeconds = 0.50,
    this.deathAnimSeconds = 0.72,
    this.spawnAnimSeconds = 0.56,
  });

  static AnimTuning fromStripFrames({
    required Map<AnimKey, int> frameCounts,
    required Map<AnimKey, double> stepTimeSecondsByKey,
  }) {
    final castSeconds = anim_utils.secondsForKey(
      key: AnimKey.cast,
      frameCounts: frameCounts,
      stepTimeSecondsByKey: stepTimeSecondsByKey,
    );
    final strikeSeconds = anim_utils.secondsForKey(
      key: AnimKey.strike,
      frameCounts: frameCounts,
      stepTimeSecondsByKey: stepTimeSecondsByKey,
    );
    return AnimTuning(
      hitAnimSeconds: anim_utils.secondsForKey(
        key: AnimKey.hit,
        frameCounts: frameCounts,
        stepTimeSecondsByKey: stepTimeSecondsByKey,
      ),
      castAnimSeconds: castSeconds,
      strikeAnimSeconds: strikeSeconds,
      backStrikeAnimSeconds:
          (frameCounts.containsKey(AnimKey.backStrike) ||
                  stepTimeSecondsByKey.containsKey(AnimKey.backStrike))
              ? anim_utils.secondsForKey(
                  key: AnimKey.backStrike,
                  frameCounts: frameCounts,
                  stepTimeSecondsByKey: stepTimeSecondsByKey,
                )
              : strikeSeconds,
      parryAnimSeconds:
          (frameCounts.containsKey(AnimKey.parry) ||
                  stepTimeSecondsByKey.containsKey(AnimKey.parry))
              ? anim_utils.secondsForKey(
                  key: AnimKey.parry,
                  frameCounts: frameCounts,
                  stepTimeSecondsByKey: stepTimeSecondsByKey,
                )
              : strikeSeconds,
      rangedAnimSeconds:
          (frameCounts.containsKey(AnimKey.ranged) ||
                  stepTimeSecondsByKey.containsKey(AnimKey.ranged))
              ? anim_utils.secondsForKey(
                  key: AnimKey.ranged,
                  frameCounts: frameCounts,
                  stepTimeSecondsByKey: stepTimeSecondsByKey,
                )
              : castSeconds,
      dashAnimSeconds:
          (frameCounts.containsKey(AnimKey.dash) ||
                  stepTimeSecondsByKey.containsKey(AnimKey.dash))
              ? anim_utils.secondsForKey(
                  key: AnimKey.dash,
                  frameCounts: frameCounts,
                  stepTimeSecondsByKey: stepTimeSecondsByKey,
                )
              : 0.20,
      rollAnimSeconds:
          (frameCounts.containsKey(AnimKey.roll) ||
                  stepTimeSecondsByKey.containsKey(AnimKey.roll))
              ? anim_utils.secondsForKey(
                  key: AnimKey.roll,
                  frameCounts: frameCounts,
                  stepTimeSecondsByKey: stepTimeSecondsByKey,
                )
              : 0.50,
      deathAnimSeconds: anim_utils.secondsForKey(
        key: AnimKey.death,
        frameCounts: frameCounts,
        stepTimeSecondsByKey: stepTimeSecondsByKey,
      ),
      spawnAnimSeconds: anim_utils.secondsForKey(
        key: AnimKey.spawn,
        frameCounts: frameCounts,
        stepTimeSecondsByKey: stepTimeSecondsByKey,
      ),
    );
  }

  final double hitAnimSeconds;
  final double castAnimSeconds;
  final double strikeAnimSeconds;
  final double backStrikeAnimSeconds;
  final double parryAnimSeconds;
  final double rangedAnimSeconds;
  final double dashAnimSeconds;
  final double rollAnimSeconds;
  final double deathAnimSeconds;
  final double spawnAnimSeconds;
}

class AnimTuningDerived {
  const AnimTuningDerived._({
    required this.tickHz,
    required this.base,
    required this.hitAnimTicks,
    required this.castAnimTicks,
    required this.strikeAnimTicks,
    required this.backStrikeAnimTicks,
    required this.parryAnimTicks,
    required this.rangedAnimTicks,
    required this.dashAnimTicks,
    required this.rollAnimTicks,
    required this.deathAnimTicks,
    required this.spawnAnimTicks,
  });

  factory AnimTuningDerived.from(AnimTuning base, {required int tickHz}) {
    if (tickHz <= 0) {
      throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
    }

    return AnimTuningDerived._(
      tickHz: tickHz,
      base: base,
      hitAnimTicks: ticksFromSecondsCeil(base.hitAnimSeconds, tickHz),
      castAnimTicks: ticksFromSecondsCeil(base.castAnimSeconds, tickHz),
      strikeAnimTicks: ticksFromSecondsCeil(base.strikeAnimSeconds, tickHz),
      backStrikeAnimTicks: ticksFromSecondsCeil(base.backStrikeAnimSeconds, tickHz),
      parryAnimTicks: ticksFromSecondsCeil(base.parryAnimSeconds, tickHz),
      rangedAnimTicks: ticksFromSecondsCeil(base.rangedAnimSeconds, tickHz),
      dashAnimTicks: ticksFromSecondsCeil(base.dashAnimSeconds, tickHz),
      rollAnimTicks: ticksFromSecondsCeil(base.rollAnimSeconds, tickHz),
      deathAnimTicks: ticksFromSecondsCeil(base.deathAnimSeconds, tickHz),
      spawnAnimTicks: ticksFromSecondsCeil(base.spawnAnimSeconds, tickHz),
    );
  }

  final int tickHz;
  final AnimTuning base;

  final int hitAnimTicks;
  final int castAnimTicks;
  final int strikeAnimTicks;
  final int backStrikeAnimTicks;
  final int parryAnimTicks;
  final int rangedAnimTicks;
  final int dashAnimTicks;
  final int rollAnimTicks;
  final int deathAnimTicks;
  final int spawnAnimTicks;
}

// ─────────────────────────────────────────────────────────────────────────────
// Player tuning bundle + derived compiler (composition)
// ─────────────────────────────────────────────────────────────────────────────

class PlayerTuning {
  const PlayerTuning({
    this.movement = const MovementTuning(),
    this.resource = const ResourceTuning(),
    this.ability = const AbilityTuning(),
    this.anim = const AnimTuning(),
    this.combat = const CombatTuning(),
  });

  final MovementTuning movement;
  final ResourceTuning resource;
  final AbilityTuning ability;
  final AnimTuning anim;
  final CombatTuning combat;

  PlayerTuning copyWith({
    MovementTuning? movement,
    ResourceTuning? resource,
    AbilityTuning? ability,
    AnimTuning? anim,
    CombatTuning? combat,
  }) {
    return PlayerTuning(
      movement: movement ?? this.movement,
      resource: resource ?? this.resource,
      ability: ability ?? this.ability,
      anim: anim ?? this.anim,
      combat: combat ?? this.combat,
    );
  }
}

class PlayerTuningDerived {
  const PlayerTuningDerived({
    required this.movement,
    required this.ability,
    required this.anim,
    required this.combat,
    required this.resource,
  });

  final MovementTuningDerived movement;
  final AbilityTuningDerived ability;
  final AnimTuningDerived anim;
  final CombatTuningDerived combat;
  final ResourceTuningDerived resource;
}

class PlayerTuningCompiler {
  const PlayerTuningCompiler({required this.tickHz});

  final int tickHz;

  PlayerTuningDerived compile(PlayerTuning base) {
    return PlayerTuningDerived(
      movement: MovementTuningDerived.from(base.movement, tickHz: tickHz),
      ability: AbilityTuningDerived.from(base.ability, tickHz: tickHz),
      anim: AnimTuningDerived.from(base.anim, tickHz: tickHz),
      combat: CombatTuningDerived.from(base.combat, tickHz: tickHz),
      resource: ResourceTuningDerived.from(base.resource),
    );
  }
}


===== FILE: lib/core/progression/run_rewards.dart =====
/// Reward computation for completed runs.
///
/// Keep this module pure and deterministic so reward rules can evolve
/// without touching UI or render layers.
int computeGoldEarned({required int collectiblesCollected}) {
  return collectiblesCollected;
}


===== FILE: lib/core/projectiles/projectile_catalog.dart =====
import '../util/tick_math.dart';

import 'projectile_id.dart';

/// Static properties for a projectile type.
///
/// Defines speed, lifetime, and collision bounds. Damage is determined by
/// the spell that spawns the projectile, not the projectile itself.
class ProjectileArchetype {
  const ProjectileArchetype({
    required this.speedUnitsPerSecond,
    required this.lifetimeSeconds,
    required this.colliderSizeX,
    required this.colliderSizeY,
  });

  /// Travel speed in world units per second.
  final double speedUnitsPerSecond;

  /// How long before auto-despawn (seconds).
  final double lifetimeSeconds;

  /// Full width of the collision box (world units).
  final double colliderSizeX;

  /// Full height of the collision box (world units).
  final double colliderSizeY;
}

/// Lookup table for projectile archetypes by [ProjectileId].
///
/// All values are authoring-time constants. For tick-rate-dependent values,
/// use [ProjectileCatalogDerived].
class ProjectileCatalog {
  const ProjectileCatalog();

  /// Returns the archetype for the given projectile type.
  ProjectileArchetype get(ProjectileId id) {
    switch (id) {
      case ProjectileId.iceBolt:
        return const ProjectileArchetype(
          speedUnitsPerSecond: 1000.0,
          lifetimeSeconds: 1.0,
          colliderSizeX: 18.0,
          colliderSizeY: 8.0,
        );
      case ProjectileId.thunderBolt:
        return const ProjectileArchetype(
          speedUnitsPerSecond: 1000.0,
          lifetimeSeconds: 1.2,
          colliderSizeX: 16.0,
          colliderSizeY: 8.0,
        );
      case ProjectileId.fireBolt:
        return const ProjectileArchetype(
          speedUnitsPerSecond: 900.0,
          lifetimeSeconds: 1.3,
          colliderSizeX: 20.0,
          colliderSizeY: 10.0,
        );
      case ProjectileId.throwingAxe:
        return const ProjectileArchetype(
          speedUnitsPerSecond: 800.0,
          lifetimeSeconds: 1.6,
          colliderSizeX: 16.0,
          colliderSizeY: 10.0,
        );
      case ProjectileId.throwingKnife:
        return const ProjectileArchetype(
          speedUnitsPerSecond: 900.0,
          lifetimeSeconds: 1.2,
          colliderSizeX: 14.0,
          colliderSizeY: 6.0,
        );
    }
  }
}

/// Tick-rate-aware wrapper for [ProjectileCatalog].
///
/// Converts time-based values (seconds) to tick counts for use in systems.
class ProjectileCatalogDerived {
  const ProjectileCatalogDerived._({required this.tickHz, required this.base});

  factory ProjectileCatalogDerived.from(
    ProjectileCatalog base, {
    required int tickHz,
  }) {
    if (tickHz <= 0) {
      throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
    }
    return ProjectileCatalogDerived._(tickHz: tickHz, base: base);
  }

  final int tickHz;
  final ProjectileCatalog base;

  /// Converts [lifetimeSeconds] to ticks (rounded up).
  int lifetimeTicks(ProjectileId id) {
    return ticksFromSecondsCeil(base.get(id).lifetimeSeconds, tickHz);
  }
}


===== FILE: lib/core/projectiles/projectile_id.dart =====
/// Identifies a projectile type for catalog lookup and rendering.
///
/// Each ID maps to a [ProjectileArchetype] in [ProjectileCatalog] and
/// determines visual appearance in the renderer.
enum ProjectileId {
  /// Player's primary ranged strike. Fast, short-lived.
  iceBolt,

  /// Enemy ranged strike. Slower but longer range.
  thunderBolt,

  /// Player's fire spell projectile. Medium speed and lifetime.
  fireBolt,

  /// Physical throwing axe projectile (ballistic).
  throwingAxe,

  /// Physical throwing knife projectile (ballistic).
  throwingKnife,
}


===== FILE: lib/core/projectiles/projectile_item_catalog.dart =====
import '../abilities/ability_def.dart' show WeaponType;
import '../combat/damage_type.dart';
import '../combat/status/status.dart';
import '../projectiles/projectile_id.dart';
import '../weapons/weapon_proc.dart';
import 'projectile_item_def.dart';
import 'projectile_item_id.dart';

/// Lookup table for projectile slot items (spells + throwing weapons).
class ProjectileItemCatalog {
  const ProjectileItemCatalog();

  ProjectileItemDef get(ProjectileItemId id) {
    switch (id) {
      // Spells
      case ProjectileItemId.iceBolt:
        return const ProjectileItemDef(
          id: ProjectileItemId.iceBolt,
          weaponType: WeaponType.projectileSpell,
          projectileId: ProjectileId.iceBolt,
          ballistic: false,
          gravityScale: 1.0,
          damageType: DamageType.ice,
          procs: <WeaponProc>[
            WeaponProc(
              hook: ProcHook.onHit,
              statusProfileId: StatusProfileId.iceBolt,
              chanceBp: 10000,
            ),
          ],
        );
      case ProjectileItemId.fireBolt:
        return const ProjectileItemDef(
          id: ProjectileItemId.fireBolt,
          weaponType: WeaponType.projectileSpell,
          projectileId: ProjectileId.fireBolt,
          ballistic: false,
          gravityScale: 1.0,
          damageType: DamageType.fire,
          procs: <WeaponProc>[
            WeaponProc(
              hook: ProcHook.onHit,
              statusProfileId: StatusProfileId.fireBolt,
              chanceBp: 10000,
            ),
          ],
        );
      case ProjectileItemId.thunderBolt:
        return const ProjectileItemDef(
          id: ProjectileItemId.thunderBolt,
          weaponType: WeaponType.projectileSpell,
          projectileId: ProjectileId.thunderBolt,
          ballistic: false,
          gravityScale: 1.0,
          damageType: DamageType.thunder,
        );

      // Throwing weapons
      case ProjectileItemId.throwingKnife:
        return const ProjectileItemDef(
          id: ProjectileItemId.throwingKnife,
          weaponType: WeaponType.throwingWeapon,
          projectileId: ProjectileId.throwingKnife,
          originOffset: 6.0,
          ballistic: true,
          gravityScale: 0.9,
          damageType: DamageType.physical,
        );
      case ProjectileItemId.throwingAxe:
        return const ProjectileItemDef(
          id: ProjectileItemId.throwingAxe,
          weaponType: WeaponType.throwingWeapon,
          projectileId: ProjectileId.throwingAxe,
          originOffset: 8.0,
          ballistic: true,
          gravityScale: 1.0,
          damageType: DamageType.physical,
        );
    }
  }

  ProjectileItemDef? tryGet(ProjectileItemId id) {
    try {
      return get(id);
    } catch (_) {
      return null;
    }
  }
}


===== FILE: lib/core/projectiles/projectile_item_def.dart =====
import '../abilities/ability_def.dart' show WeaponType;
import '../combat/damage_type.dart';
import '../projectiles/projectile_id.dart';
import '../weapons/weapon_proc.dart';
import '../weapons/weapon_stats.dart';
import 'projectile_item_id.dart';

/// Unified data definition for projectile slot items (spells + throwing weapons).
class ProjectileItemDef {
  const ProjectileItemDef({
    required this.id,
    required this.weaponType,
    required this.projectileId,
    this.originOffset = 0.0,
    this.ballistic = false,
    this.gravityScale = 1.0,
    this.damageType = DamageType.physical,
    this.procs = const <WeaponProc>[],
    this.stats = const WeaponStats(),
  });

  final ProjectileItemId id;
  final WeaponType weaponType;

  final ProjectileId projectileId;
  final double originOffset;
  final bool ballistic;
  final double gravityScale;

  final DamageType damageType;
  final List<WeaponProc> procs;
  final WeaponStats stats;
}


===== FILE: lib/core/projectiles/projectile_item_id.dart =====
enum ProjectileItemId {
  iceBolt,
  fireBolt,
  thunderBolt,
  throwingKnife,
  throwingAxe,
}


===== FILE: lib/core/projectiles/projectile_render_catalog.dart =====
import '../contracts/render_anim_set_definition.dart';
import '../snapshots/enums.dart';
import 'projectile_id.dart';

// -----------------------------------------------------------------------------
// Ice Bolt render animation strip definitions (authoring-time)
// -----------------------------------------------------------------------------

const int _iceBoltFrameWidth = 48;
const int _iceBoltFrameHeight = 32;

const int _iceBoltStartFrames = 3;
const int _iceBoltRepeatFrames = 10;
const int _iceBoltHitFrames = 8;

const double _iceBoltStartStepSeconds = 0.05;
const double _iceBoltRepeatStepSeconds = 0.06;
const double _iceBoltHitStepSeconds = 0.05;

const Map<AnimKey, int> _iceBoltFrameCountsByKey = <AnimKey, int>{
  AnimKey.spawn: _iceBoltStartFrames,
  AnimKey.idle: _iceBoltRepeatFrames,
  AnimKey.hit: _iceBoltHitFrames,
};

const Map<AnimKey, double> _iceBoltStepTimeSecondsByKey = <AnimKey, double>{
  AnimKey.spawn: _iceBoltStartStepSeconds,
  AnimKey.idle: _iceBoltRepeatStepSeconds,
  AnimKey.hit: _iceBoltHitStepSeconds,
};

const Map<AnimKey, String> _iceBoltSourcesByKey = <AnimKey, String>{
  AnimKey.spawn: 'entities/spells/iceBolt/start.png',
  AnimKey.idle: 'entities/spells/iceBolt/repeatable.png',
  AnimKey.hit: 'entities/spells/iceBolt/hit.png',
};

const RenderAnimSetDefinition _iceBoltRenderAnim = RenderAnimSetDefinition(
  frameWidth: _iceBoltFrameWidth,
  frameHeight: _iceBoltFrameHeight,
  sourcesByKey: _iceBoltSourcesByKey,
  frameCountsByKey: _iceBoltFrameCountsByKey,
  stepTimeSecondsByKey: _iceBoltStepTimeSecondsByKey,
);

// -----------------------------------------------------------------------------
// Thunder Bolt render animation strip definitions (authoring-time)
// -----------------------------------------------------------------------------

const int _thunderBoltFrameWidth = 32;
const int _thunderBoltFrameHeight = 32;

const int _thunderBoltStartFrames = 5;
const int _thunderBoltRepeatFrames = 5;
const int _thunderBoltHitFrames = 6;

const double _thunderBoltStartStepSeconds = 0.05;
const double _thunderBoltRepeatStepSeconds = 0.06;
const double _thunderBoltHitStepSeconds = 0.05;

const Map<AnimKey, int> _thunderBoltFrameCountsByKey = <AnimKey, int>{
  AnimKey.spawn: _thunderBoltStartFrames,
  AnimKey.idle: _thunderBoltRepeatFrames,
  AnimKey.hit: _thunderBoltHitFrames,
};

const Map<AnimKey, double> _thunderBoltStepTimeSecondsByKey =
    <AnimKey, double>{
  AnimKey.spawn: _thunderBoltStartStepSeconds,
  AnimKey.idle: _thunderBoltRepeatStepSeconds,
  AnimKey.hit: _thunderBoltHitStepSeconds,
};

const Map<AnimKey, String> _thunderBoltSourcesByKey = <AnimKey, String>{
  AnimKey.spawn: 'entities/spells/thunderBolt/start.png',
  AnimKey.idle: 'entities/spells/thunderBolt/repeatable.png',
  AnimKey.hit: 'entities/spells/thunderBolt/hit.png',
};

const RenderAnimSetDefinition _thunderBoltRenderAnim = RenderAnimSetDefinition(
  frameWidth: _thunderBoltFrameWidth,
  frameHeight: _thunderBoltFrameHeight,
  sourcesByKey: _thunderBoltSourcesByKey,
  frameCountsByKey: _thunderBoltFrameCountsByKey,
  stepTimeSecondsByKey: _thunderBoltStepTimeSecondsByKey,
);

// -----------------------------------------------------------------------------
// Fire Bolt render animation strip definitions (authoring-time)
// -----------------------------------------------------------------------------

const int _fireBoltFrameWidth = 48;
const int _fireBoltFrameHeight = 48;

const int _fireBoltStartFrames = 4;
const int _fireBoltHitFrames = 6;

const double _fireBoltStartStepSeconds = 0.05;
const double _fireBoltIdleStepSeconds = 0.06;
const double _fireBoltHitStepSeconds = 0.05;

const Map<AnimKey, int> _fireBoltFrameCountsByKey = <AnimKey, int>{
  AnimKey.spawn: _fireBoltStartFrames,
  AnimKey.idle: _fireBoltStartFrames,
  AnimKey.hit: _fireBoltHitFrames,
};

const Map<AnimKey, int> _fireBoltFrameStartByKey = <AnimKey, int>{
  AnimKey.spawn: 0,
  AnimKey.idle: 0,
  AnimKey.hit: 5,
};

const Map<AnimKey, double> _fireBoltStepTimeSecondsByKey =
    <AnimKey, double>{
  AnimKey.spawn: _fireBoltStartStepSeconds,
  AnimKey.idle: _fireBoltIdleStepSeconds,
  AnimKey.hit: _fireBoltHitStepSeconds,
};

const Map<AnimKey, String> _fireBoltSourcesByKey = <AnimKey, String>{
  AnimKey.spawn: 'entities/spells/fireBolt/fireBolt_spriteSheet.png',
  AnimKey.idle: 'entities/spells/fireBolt/fireBolt_spriteSheet.png',
  AnimKey.hit: 'entities/spells/fireBolt/fireBolt_spriteSheet.png',
};

const RenderAnimSetDefinition _fireBoltRenderAnim = RenderAnimSetDefinition(
  frameWidth: _fireBoltFrameWidth,
  frameHeight: _fireBoltFrameHeight,
  sourcesByKey: _fireBoltSourcesByKey,
  frameStartByKey: _fireBoltFrameStartByKey,
  frameCountsByKey: _fireBoltFrameCountsByKey,
  stepTimeSecondsByKey: _fireBoltStepTimeSecondsByKey,
);

// -----------------------------------------------------------------------------
// Throwing Axe render animation strip definitions (authoring-time)
// -----------------------------------------------------------------------------

const int _throwingAxeFrameWidth = 32;
const int _throwingAxeFrameHeight = 32;

const int _throwingAxeFrames = 1;
const double _throwingAxeStepSeconds = 0.10;

const Map<AnimKey, int> _throwingAxeFrameCountsByKey = <AnimKey, int>{
  AnimKey.idle: _throwingAxeFrames,
};

const Map<AnimKey, double> _throwingAxeStepTimeSecondsByKey =
    <AnimKey, double>{
  AnimKey.idle: _throwingAxeStepSeconds,
};

const Map<AnimKey, String> _throwingAxeSourcesByKey = <AnimKey, String>{
  AnimKey.idle: 'weapons/throwingWeapons/throwingAxe.png',
};

const RenderAnimSetDefinition _throwingAxeRenderAnim = RenderAnimSetDefinition(
  frameWidth: _throwingAxeFrameWidth,
  frameHeight: _throwingAxeFrameHeight,
  sourcesByKey: _throwingAxeSourcesByKey,
  frameCountsByKey: _throwingAxeFrameCountsByKey,
  stepTimeSecondsByKey: _throwingAxeStepTimeSecondsByKey,
);

// -----------------------------------------------------------------------------
// Throwing Axe render animation strip definitions (authoring-time)
// -----------------------------------------------------------------------------

const int _throwingKnifeFrameWidth = 32;
const int _throwingKnifeFrameHeight = 32;

const int _throwingKnifeFrames = 1;
const double _throwingKnifeStepSeconds = 0.10;

const Map<AnimKey, int> _throwingKnifeFrameCountsByKey = <AnimKey, int>{
  AnimKey.idle: _throwingKnifeFrames,
};

const Map<AnimKey, double> _throwingKnifeStepTimeSecondsByKey =
    <AnimKey, double>{
  AnimKey.idle: _throwingKnifeStepSeconds,
};

const Map<AnimKey, String> _throwingKnifeSourcesByKey = <AnimKey, String>{
  AnimKey.idle: 'weapons/throwingWeapons/throwingKnife.png',
};

const RenderAnimSetDefinition _throwingKnifeRenderAnim = RenderAnimSetDefinition(
  frameWidth: _throwingKnifeFrameWidth,
  frameHeight: _throwingKnifeFrameHeight,
  sourcesByKey: _throwingKnifeSourcesByKey,
  frameCountsByKey: _throwingKnifeFrameCountsByKey,
  stepTimeSecondsByKey: _throwingKnifeStepTimeSecondsByKey,
);

/// Lookup table for projectile render animation definitions.
///
/// Core owns the animation timing and frame metadata. The renderer uses this
/// catalog to load assets and drive deterministic animation frames.
class ProjectileRenderCatalog {
  const ProjectileRenderCatalog();

  RenderAnimSetDefinition get(ProjectileId id) {
    switch (id) {
      case ProjectileId.iceBolt:
        return _iceBoltRenderAnim;
      case ProjectileId.thunderBolt:
        return _thunderBoltRenderAnim;
      case ProjectileId.fireBolt:
        return _fireBoltRenderAnim;
      case ProjectileId.throwingAxe:
        return _throwingAxeRenderAnim;
      case ProjectileId.throwingKnife:
        return _throwingKnifeRenderAnim;
    }
  }
}


===== FILE: lib/core/projectiles/spawn_projectile_item.dart =====
/// Projectile spawning utilities for projectile slot items.
library;

import 'dart:math';

import '../combat/damage_type.dart';
import '../combat/faction.dart';
import '../ecs/entity_id.dart';
import '../ecs/stores/body_store.dart';
import '../ecs/stores/collider_aabb_store.dart';
import '../ecs/stores/lifetime_store.dart';
import '../ecs/stores/projectile_item_origin_store.dart';
import '../ecs/stores/projectile_store.dart';
import '../ecs/world.dart';
import '../projectiles/projectile_catalog.dart';
import '../projectiles/projectile_id.dart';
import '../projectiles/projectile_item_id.dart';
import '../weapons/weapon_proc.dart';

const _dirEps2 = 1e-12;

({double x, double y}) _normalizeDirOrFallback(
  double x,
  double y, {
  required double fallbackX,
  required double fallbackY,
}) {
  final len2 = x * x + y * y;
  if (len2 <= _dirEps2) {
    final fbLen2 = fallbackX * fallbackX + fallbackY * fallbackY;
    if (fbLen2 <= _dirEps2) {
      return (x: 1.0, y: 0.0);
    }
    final invLen = 1.0 / sqrt(fbLen2);
    return (x: fallbackX * invLen, y: fallbackY * invLen);
  }

  final invLen = 1.0 / sqrt(len2);
  return (x: x * invLen, y: y * invLen);
}

EntityId spawnProjectileItemFromCaster(
  EcsWorld world, {
  required ProjectileCatalogDerived projectiles,
  required ProjectileItemId projectileItemId,
  required ProjectileId projectileId,
  required Faction faction,
  required EntityId owner,
  required double casterX,
  required double casterY,
  required double originOffset,
  required double dirX,
  required double dirY,
  required double fallbackDirX,
  required double fallbackDirY,
  required int damage100,
  required DamageType damageType,
  List<WeaponProc> procs = const <WeaponProc>[],
  required bool ballistic,
  required double gravityScale,
}) {
  final proj = projectiles.base.get(projectileId);
  final speedUnitsPerSecond = proj.speedUnitsPerSecond;

  final dir = _normalizeDirOrFallback(
    dirX,
    dirY,
    fallbackX: fallbackDirX,
    fallbackY: fallbackDirY,
  );

  final originX = casterX + dir.x * originOffset;
  final originY = casterY + dir.y * originOffset;

  final entity = world.createEntity();

  final initialVelX = ballistic ? dir.x * speedUnitsPerSecond : 0.0;
  final initialVelY = ballistic ? dir.y * speedUnitsPerSecond : 0.0;

  world.transform.add(
    entity,
    posX: originX,
    posY: originY,
    velX: initialVelX,
    velY: initialVelY,
  );

  world.projectile.add(
    entity,
    ProjectileDef(
      projectileId: projectileId,
      faction: faction,
      owner: owner,
      dirX: dir.x,
      dirY: dir.y,
      speedUnitsPerSecond: speedUnitsPerSecond,
      damage100: damage100,
      damageType: damageType,
      procs: procs,
      usePhysics: ballistic,
    ),
  );

  world.projectileItemOrigin.add(
    entity,
    ProjectileItemOriginDef(projectileItemId: projectileItemId),
  );

  world.lifetime.add(
    entity,
    LifetimeDef(ticksLeft: projectiles.lifetimeTicks(projectileId)),
  );

  world.colliderAabb.add(
    entity,
    ColliderAabbDef(
      halfX: proj.colliderSizeX * 0.5,
      halfY: proj.colliderSizeY * 0.5,
    ),
  );

  if (ballistic) {
    world.body.add(
      entity,
      BodyDef(
        isKinematic: false,
        useGravity: true,
        gravityScale: gravityScale,
        sideMask: BodyDef.sideLeft | BodyDef.sideRight,
      ),
    );
    world.collision.add(entity);
  }

  return entity;
}


===== FILE: lib/core/scoring/run_score_breakdown.dart =====
import '../enemies/enemy_id.dart';
import '../tuning/score_tuning.dart';

/// Categories of score contributions shown in the end-of-run breakdown.
enum RunScoreRowKind {
  /// Points earned from distance traveled.
  distance,

  /// Points earned from survival time.
  time,

  /// Points earned from collected items.
  collectibles,

  /// Points earned from killing enemies (one row per enemy type).
  enemyKill,
}

/// A single line item in the score breakdown UI.
///
/// Each row shows a category, a count (e.g., meters, seconds, kills),
/// and the points contributed by that category.
class RunScoreRow {
  const RunScoreRow({
    required this.kind,
    required this.count,
    required this.points,
    this.enemyId,
  });

  /// Row category (distance/time/collectibles/enemy kills).
  final RunScoreRowKind kind;

  /// Quantity displayed (meters, seconds, collectible count, or kill count).
  final int count;

  /// Total points contributed by this row.
  final int points;

  /// For [RunScoreRowKind.enemyKill] rows, identifies the enemy type.
  final EnemyId? enemyId;
}

/// Complete score breakdown for a finished run.
///
/// Contains itemized rows and the computed total. Used by the game-over UI
/// to display how the player earned their score.
class RunScoreBreakdown {
  const RunScoreBreakdown({required this.rows, required this.totalPoints});

  /// Itemized score contributions (distance, time, collectibles, enemy kills).
  final List<RunScoreRow> rows;

  /// Sum of all row points.
  final int totalPoints;
}

/// Computes the score breakdown for a completed run.
///
/// Converts raw game stats (ticks, distance units, kill counts) into
/// player-facing values (meters, seconds) and calculates points using
/// [ScoreTuning] multipliers.
RunScoreBreakdown buildRunScoreBreakdown({
  required int tick,
  required double distanceUnits,
  required int collectibles,
  required int collectibleScore,
  required List<int> enemyKillCounts,
  required ScoreTuning tuning,
  required int tickHz,
  int unitsPerMeter = kWorldUnitsPerMeter,
}) {
  // Convert internal units to player-facing values.
  final meters = unitsPerMeter <= 0
      ? 0
      : (distanceUnits / unitsPerMeter).floor();
  final timeSeconds = tickHz <= 0 ? 0 : tick ~/ tickHz;

  final rows = <RunScoreRow>[
    RunScoreRow(
      kind: RunScoreRowKind.distance,
      count: meters,
      points: meters * tuning.distanceScorePerMeter,
    ),
    RunScoreRow(
      kind: RunScoreRowKind.time,
      count: timeSeconds,
      points: timeSeconds * tuning.timeScorePerSecond,
    ),
    RunScoreRow(
      kind: RunScoreRowKind.collectibles,
      count: collectibles,
      points: collectibleScore,
    ),
  ];

  // Add a row for each enemy type with at least one kill.
  for (final enemyId in EnemyId.values) {
    final index = enemyId.index;
    final kills = index < enemyKillCounts.length ? enemyKillCounts[index] : 0;
    if (kills <= 0) continue;
    rows.add(
      RunScoreRow(
        kind: RunScoreRowKind.enemyKill,
        count: kills,
        points: kills * _enemyKillScore(tuning, enemyId),
        enemyId: enemyId,
      ),
    );
  }

  // Sum all rows for total.
  var totalPoints = 0;
  for (final row in rows) {
    totalPoints += row.points;
  }

  return RunScoreBreakdown(
    rows: List<RunScoreRow>.unmodifiable(rows),
    totalPoints: totalPoints,
  );
}

/// Returns the point value for killing one enemy of [enemyId] type.
int _enemyKillScore(ScoreTuning tuning, EnemyId enemyId) {
  switch (enemyId) {
    case EnemyId.grojib:
      return tuning.groundEnemyKillScore;
    case EnemyId.unocoDemon:
      return tuning.unocoDemonKillScore;
  }
}


===== FILE: lib/core/snapshot_builder.dart =====
/// Builds immutable render snapshots from ECS world state.
///
/// This module decouples snapshot construction from simulation logic,
/// providing a clean separation between the game's internal state (ECS)
/// and the data consumed by the rendering layer.
///
/// All methods are pure readers—no side effects on [EcsWorld].
///
/// ## Architecture
///
/// The render layer never reads ECS directly. Instead, [GameCore] calls
/// [SnapshotBuilder.build] once per tick to produce a [GameStateSnapshot],
/// which is an immutable, self-contained description of everything needed
/// to draw a single frame.
///
/// ## Key Types
///
/// - [SnapshotBuilder] — Stateful builder holding ECS and tuning references.
/// - [GameStateSnapshot] — Complete frame data (entities, HUD, geometry).
/// - [EntityRenderSnapshot] — Per-entity render info (position, animation, etc.).
/// - [PlayerHudSnapshot] — Player resource bars, cooldowns, affordability flags.
library;

import 'dart:math';

import 'ecs/entity_id.dart';
import 'ecs/world.dart';
import 'ecs/stores/combat/equipped_loadout_store.dart';
import 'ecs/stores/restoration_item_store.dart';
import 'levels/level_id.dart';
import 'projectiles/projectile_catalog.dart';
import 'enemies/enemy_catalog.dart';
import 'snapshots/enums.dart';
import 'snapshots/entity_render_snapshot.dart';
import 'snapshots/game_state_snapshot.dart';
import 'snapshots/player_hud_snapshot.dart';
import 'snapshots/static_ground_gap_snapshot.dart';
import 'snapshots/static_solid_snapshot.dart';
import 'players/player_tuning.dart';
import 'util/vec2.dart';
import 'abilities/ability_catalog.dart';
import 'abilities/ability_def.dart';
import 'util/fixed_math.dart';
import 'util/tick_math.dart';

// ─────────────────────────────────────────────────────────────────────────────
// SnapshotBuilder
// ─────────────────────────────────────────────────────────────────────────────

/// Constructs [GameStateSnapshot] instances from ECS world state.
///
/// Holds references to the ECS world and all tuning data needed to compute
/// derived values (e.g., cooldown progress, affordability flags).
///
/// Usage:
/// ```dart
/// final builder = SnapshotBuilder(world: ..., player: ..., ...);
/// final snapshot = builder.build(tick: 42, ...);
/// ```
class SnapshotBuilder {
  /// Creates a snapshot builder with the given dependencies.
  ///
  /// - [tickHz]: Fixed tick rate for converting seconds to ticks.
  /// - [world]: The ECS world containing all entity component data.
  /// - [player]: Entity ID of the player (used to query player-specific stores).
  /// - [movement]: Derived movement tuning (dash cooldown ticks, etc.).
  /// - [abilities]: Derived ability tuning (melee/cast cooldown ticks).
  /// - [resources]: Resource costs (jump/dash stamina, etc.).
  /// - [projectiles]: Projectile catalog for collider sizes.
  /// - [enemyCatalog]: Enemy catalog for render metadata (hit windows, art facing).
  SnapshotBuilder({
    required this.tickHz,
    required this.world,
    required this.player,
    required this.movement,
    required this.abilities,
    required this.resources,
    required this.projectiles,
    required this.enemyCatalog,
  });

  /// Tick rate (ticks per second) for converting seconds to ticks.
  final int tickHz;

  /// The ECS world containing all game entity data.
  final EcsWorld world;

  /// Entity ID of the player character.
  final EntityId player;

  /// Derived movement tuning (pre-computed tick-based values).
  final MovementTuningDerived movement;

  /// Derived ability tuning (cooldown durations in ticks).
  final AbilityTuningDerived abilities;

  /// Resource tuning (stamina/mana costs for actions).
  final ResourceTuningDerived resources;

  /// Projectile catalog for collider dimensions.
  final ProjectileCatalogDerived projectiles;

  /// Enemy catalog for render metadata (art facing direction).
  final EnemyCatalog enemyCatalog;

  // ───────────────────────────────────────────────────────────────────────────
  // Public API
  // ───────────────────────────────────────────────────────────────────────────

  /// Builds a complete [GameStateSnapshot] for the current tick.
  ///
  /// This method reads from multiple ECS component stores to assemble:
  /// - Player state (position, velocity, animation, facing direction)
  /// - HUD data (HP, mana, stamina, cooldowns, affordability)
  /// - All entity render snapshots (player, enemies, projectiles, pickups)
  /// - Static geometry (platforms, ground gaps)
  ///
  /// Parameters:
  /// - [tick]: Current simulation tick number.
  /// - [runId]: Unique identifier for this run session.
  /// - [seed]: RNG seed for this run (stored for replay/debug).
  /// - [levelId]: Level identifier for this run (stored for replay/debug).
  /// - [themeId]: Optional render theme identifier (stored for debug/UI).
  /// - [distance]: Total distance traveled (world units).
  /// - [paused]: Whether the game is currently paused.
  /// - [gameOver]: Whether the run has ended.
  /// - [cameraCenterX], [cameraCenterY]: Camera focus point (world coords).
  /// - [collectibles]: Number of collectibles picked up this run.
  /// - [collectibleScore]: Total score from collectibles.
  /// - [staticSolids]: Pre-built list of platform snapshots.
  /// - [groundGaps]: Pre-built list of ground gap snapshots.
  GameStateSnapshot build({
    required int tick,
    required int runId,
    required int seed,
    required LevelId levelId,
    required String? themeId,
    required double distance,
    required bool paused,
    required bool gameOver,
    required double cameraCenterX,
    required double cameraCenterY,
    required int collectibles,
    required int collectibleScore,
    required List<StaticSolidSnapshot> staticSolids,
    required List<StaticGroundGapSnapshot> groundGaps,
  }) {
    // ─── Query player component indices ───
    final mi = world.movement.indexOf(player);
    final onGround = world.collision.grounded[world.collision.indexOf(player)];
    final hi = world.health.indexOf(player);
    final mai = world.mana.indexOf(player);
    final si = world.stamina.indexOf(player);

    final li = world.equippedLoadout.indexOf(player);

    // ─── Read current resource values ───
    final stamina = world.stamina.stamina[si];
    final mana = world.mana.mana[mai];
    final loadout = world.equippedLoadout;
    final loadoutMask = loadout.mask[li];

    final projectileAbilityId = loadout.abilityProjectileId[li];
    final projectileAbility = AbilityCatalog.tryGet(projectileAbilityId);
    final projectileManaCost = projectileAbility?.manaCost ?? 0;
    final projectileStaminaCost = projectileAbility?.staminaCost ?? 0;
    final hasProjectileSlot = (loadoutMask & LoadoutSlotMask.projectile) != 0;

    final mobilityAbilityId = loadout.abilityMobilityId[li];
    final mobilityAbility = AbilityCatalog.tryGet(mobilityAbilityId);
    final dashStaminaCost =
        mobilityAbility?.staminaCost ?? resources.dashStaminaCost100;

    final jumpAbilityId = loadout.abilityJumpId[li];
    final jumpAbility = AbilityCatalog.tryGet(jumpAbilityId);
    final jumpStaminaCost =
        jumpAbility?.staminaCost ?? resources.jumpStaminaCost100;

    final meleeAbilityId = loadout.abilityPrimaryId[li];
    final meleeAbility = AbilityCatalog.tryGet(meleeAbilityId);
    final meleeStaminaCost =
        meleeAbility?.staminaCost ??
        toFixed100(abilities.base.meleeStaminaCost);

    final secondaryAbilityId = loadout.abilitySecondaryId[li];
    final secondaryAbility = AbilityCatalog.tryGet(secondaryAbilityId);
    final secondaryStaminaCost =
        secondaryAbility?.staminaCost ??
        toFixed100(abilities.base.meleeStaminaCost);

    final bonusAbilityId = loadout.abilityBonusId[li];
    final bonusAbility = AbilityCatalog.tryGet(bonusAbilityId);
    final bonusManaCost = bonusAbility?.manaCost ?? 0;
    final bonusStaminaCost = bonusAbility?.staminaCost ?? 0;

    final meleeInputMode = _inputModeFor(meleeAbility);
    final projectileInputMode = _inputModeFor(projectileAbility);


    final bonusInputMode = _inputModeFor(bonusAbility);
    final bonusUsesMeleeAim = bonusAbility?.hitDelivery is MeleeHitDelivery;
    // ─── Compute affordability flags ───
    // These tell the UI whether action buttons should appear enabled.
    final canAffordJump = stamina >= jumpStaminaCost;
    final canAffordDash = stamina >= dashStaminaCost;
    final canAffordMelee = stamina >= meleeStaminaCost;

    final hasSecondarySlot = (loadoutMask & LoadoutSlotMask.offHand) != 0;
    final canAffordSecondary = hasSecondarySlot && stamina >= secondaryStaminaCost;

    final canAffordProjectile =
        hasProjectileSlot &&
        stamina >= projectileStaminaCost &&
        mana >= projectileManaCost;

    final canAffordBonus =
        bonusAbility != null && stamina >= bonusStaminaCost && mana >= bonusManaCost;

    // ─── Read cooldown timers ───
    final cooldownTicksLeft = List<int>.filled(kMaxCooldownGroups, 0);
    final cooldownTicksTotal = List<int>.filled(kMaxCooldownGroups, 0);

    // Populate current ticks from store.
    for (var g = 0; g < kMaxCooldownGroups; g++) {
      cooldownTicksLeft[g] = world.cooldown.getTicksLeft(player, g);
    }

    // Populate totals for active ability slots.
    // Primary (Melee)
    cooldownTicksTotal[CooldownGroup.primary] = meleeAbility == null
        ? abilities.meleeCooldownTicks
        : _scaleAbilityTicks(meleeAbility.cooldownTicks);

    // Secondary (Off-hand)
    cooldownTicksTotal[CooldownGroup.secondary] = secondaryAbility == null
        ? abilities.meleeCooldownTicks
        : _scaleAbilityTicks(secondaryAbility.cooldownTicks);

    // Projectile
    cooldownTicksTotal[CooldownGroup.projectile] = projectileAbility == null
        ? abilities.castCooldownTicks
        : _scaleAbilityTicks(projectileAbility.cooldownTicks);

    // Mobility (Dash)
    cooldownTicksTotal[CooldownGroup.mobility] = mobilityAbility == null
        ? movement.dashCooldownTicks
        : _scaleAbilityTicks(mobilityAbility.cooldownTicks);

    // Bonus (Utility)
    cooldownTicksTotal[CooldownGroup.bonus0] =
        bonusAbility == null ? 0 : _scaleAbilityTicks(bonusAbility.cooldownTicks);

    // Jump currently has no cooldown (buffer/coyote are handled by MovementSystem).
    cooldownTicksTotal[CooldownGroup.jump] = 0;

    // ─── Read player transform ───
    final ti = world.transform.indexOf(player);
    final playerPosX = world.transform.posX[ti];
    final playerPosY = world.transform.posY[ti];
    final playerVelX = world.transform.velX[ti];
    final playerVelY = world.transform.velY[ti];
    final playerFacing = world.movement.facing[mi];
    final animState = world.animState;
    final AnimKey anim;
    final int playerAnimFrame;
    if (animState.has(player)) {
      final ai = animState.indexOf(player);
      anim = animState.anim[ai];
      playerAnimFrame = animState.animFrame[ai];
    } else {
      anim = AnimKey.idle;
      playerAnimFrame = tick;
    }

    final playerPos = Vec2(playerPosX, playerPosY);
    final playerVel = Vec2(playerVelX, playerVelY);

    Vec2? playerSize;
    if (world.colliderAabb.has(player)) {
      final aabbi = world.colliderAabb.indexOf(player);
      playerSize = Vec2(
        world.colliderAabb.halfX[aabbi] * 2,
        world.colliderAabb.halfY[aabbi] * 2,
      );
    }

    // ─── Build entity list (player first) ───
    final entities = <EntityRenderSnapshot>[
      EntityRenderSnapshot(
        id: player,
        kind: EntityKind.player,
        pos: playerPos,
        vel: playerVel,
        size: playerSize,
        facing: playerFacing,
        anim: anim,
        grounded: onGround,
        animFrame: playerAnimFrame,
      ),
    ];

    // Append all other renderable entities.
    _addProjectiles(entities, tick: tick);
    _addHitboxes(entities, tick: tick);
    _addCollectibles(entities, tick: tick);
    _addRestorationItems(entities, tick: tick);
    _addEnemies(entities, tick: tick);

    // ─── Assemble final snapshot ───
    return GameStateSnapshot(
      tick: tick,
      runId: runId,
      seed: seed,
      levelId: levelId,
      themeId: themeId,
      distance: distance,
      paused: paused,
      gameOver: gameOver,
      cameraCenterX: cameraCenterX,
      cameraCenterY: cameraCenterY,
      hud: PlayerHudSnapshot(
        hp: fromFixed100(world.health.hp[hi]),
        hpMax: fromFixed100(world.health.hpMax[hi]),
        mana: fromFixed100(mana),
        manaMax: fromFixed100(world.mana.manaMax[mai]),
        stamina: fromFixed100(stamina),
        staminaMax: fromFixed100(world.stamina.staminaMax[si]),
        canAffordJump: canAffordJump,
        canAffordDash: canAffordDash,
        canAffordMelee: canAffordMelee,
        canAffordSecondary: canAffordSecondary,
        canAffordProjectile: canAffordProjectile,
        canAffordBonus: canAffordBonus,
        cooldownTicksLeft: cooldownTicksLeft,
        cooldownTicksTotal: cooldownTicksTotal,
        meleeInputMode: meleeInputMode,
        projectileInputMode: projectileInputMode,
        bonusInputMode: bonusInputMode,
        bonusUsesMeleeAim: bonusUsesMeleeAim,
        collectibles: collectibles,
        collectibleScore: collectibleScore,
      ),
      entities: entities,
      staticSolids: staticSolids,
      groundGaps: groundGaps,
    );
  }

  int _scaleAbilityTicks(int ticks) {
    if (ticks <= 0) return 0;
    if (tickHz == _abilityTickHz) return ticks;
    final seconds = ticks / _abilityTickHz;
    return ticksFromSecondsCeil(seconds, tickHz);
  }

  AbilityInputMode _inputModeFor(AbilityDef? ability) {
    if (ability == null) return AbilityInputMode.tap;
    final targeting = ability.targetingModel;
    return targeting == TargetingModel.none
        ? AbilityInputMode.tap
        : AbilityInputMode.holdAimRelease;
  }

  static const int _abilityTickHz = 60;

  // ───────────────────────────────────────────────────────────────────────────
  // Private Entity Collectors
  // ───────────────────────────────────────────────────────────────────────────

  /// Appends projectile entity snapshots to [entities].
  ///
  /// Iterates the projectile component store and creates render snapshots
  /// with position, velocity, facing direction, and rotation angle.
  void _addProjectiles(
    List<EntityRenderSnapshot> entities, {
    required int tick,
  }) {
    final projectileStore = world.projectile;
    for (var pi = 0; pi < projectileStore.denseEntities.length; pi += 1) {
      final e = projectileStore.denseEntities[pi];
      if (!world.transform.has(e)) continue;
      final ti = world.transform.indexOf(e);

      // Look up projectile definition for collider size.
      final projectileId = projectileStore.projectileId[pi];
      final proj = projectiles.base.get(projectileId);
      final colliderSize = Vec2(proj.colliderSizeX, proj.colliderSizeY);

      // Compute facing and rotation from direction vector.
      final dirX = projectileStore.dirX[pi];
      final dirY = projectileStore.dirY[pi];
      final facing = dirX >= 0 ? Facing.right : Facing.left;
      final rotationRad = atan2(dirY, dirX);

      entities.add(
        EntityRenderSnapshot(
          id: e,
          kind: EntityKind.projectile,
          pos: Vec2(world.transform.posX[ti], world.transform.posY[ti]),
          vel: Vec2(world.transform.velX[ti], world.transform.velY[ti]),
          size: colliderSize,
          projectileId: projectileId,
          facing: facing,
          rotationRad: rotationRad,
          anim: AnimKey.idle,
          grounded: false,
          animFrame: tick,
        ),
      );
    }
  }

  /// Appends active hitbox (melee strike) snapshots to [entities].
  ///
  /// Hitboxes are short-lived trigger volumes spawned by melee strikes.
  /// They render as debug overlays or strike effects.
  void _addHitboxes(List<EntityRenderSnapshot> entities, {required int tick}) {
    final hitboxes = world.hitbox;
    for (var hi = 0; hi < hitboxes.denseEntities.length; hi += 1) {
      final e = hitboxes.denseEntities[hi];
      if (!world.transform.has(e)) continue;
      final ti = world.transform.indexOf(e);

      // Hitbox size is stored as half-extents; double for full size.
      final size = Vec2(hitboxes.halfX[hi] * 2, hitboxes.halfY[hi] * 2);
      final dirX = hitboxes.dirX[hi];
      final dirY = hitboxes.dirY[hi];
      final facing = dirX >= 0 ? Facing.right : Facing.left;
      final rotationRad = atan2(dirY, dirX);

      entities.add(
        EntityRenderSnapshot(
          id: e,
          kind: EntityKind.trigger,
          pos: Vec2(world.transform.posX[ti], world.transform.posY[ti]),
          size: size,
          facing: facing,
          rotationRad: rotationRad,
          anim: AnimKey.hit,
          grounded: false,
          animFrame: tick,
        ),
      );
    }
  }

  /// Appends collectible (score pickup) snapshots to [entities].
  ///
  /// Collectibles are small pickups that grant score when collected.
  void _addCollectibles(
    List<EntityRenderSnapshot> entities, {
    required int tick,
  }) {
    final collectiblesStore = world.collectible;
    for (var ci = 0; ci < collectiblesStore.denseEntities.length; ci += 1) {
      final e = collectiblesStore.denseEntities[ci];
      if (!world.transform.has(e)) continue;
      final ti = world.transform.indexOf(e);

      // Size comes from AABB collider if present.
      Vec2? size;
      if (world.colliderAabb.has(e)) {
        final aabbi = world.colliderAabb.indexOf(e);
        size = Vec2(
          world.colliderAabb.halfX[aabbi] * 2,
          world.colliderAabb.halfY[aabbi] * 2,
        );
      }

      entities.add(
        EntityRenderSnapshot(
          id: e,
          kind: EntityKind.pickup,
          pos: Vec2(world.transform.posX[ti], world.transform.posY[ti]),
          size: size,
          facing: Facing.right,
          pickupVariant: PickupVariant.collectible,
          rotationRad: pi * 0.25, // 45° tilt for visual interest
          anim: AnimKey.idle,
          grounded: false,
          animFrame: tick,
        ),
      );
    }
  }

  /// Appends restoration item (health/mana/stamina orb) snapshots to [entities].
  ///
  /// Restoration items restore a specific resource when picked up.
  /// The [pickupVariant] field tells the renderer which sprite to use.
  void _addRestorationItems(
    List<EntityRenderSnapshot> entities, {
    required int tick,
  }) {
    final restorationStore = world.restorationItem;
    for (var ri = 0; ri < restorationStore.denseEntities.length; ri += 1) {
      final e = restorationStore.denseEntities[ri];
      if (!world.transform.has(e)) continue;
      final ti = world.transform.indexOf(e);

      Vec2? size;
      if (world.colliderAabb.has(e)) {
        final aabbi = world.colliderAabb.indexOf(e);
        size = Vec2(
          world.colliderAabb.halfX[aabbi] * 2,
          world.colliderAabb.halfY[aabbi] * 2,
        );
      }

      // Map restoration stat enum to pickup variant for rendering.
      final stat = restorationStore.stat[ri];
      int variant;
      switch (stat) {
        case RestorationStat.health:
          variant = PickupVariant.restorationHealth;
        case RestorationStat.mana:
          variant = PickupVariant.restorationMana;
        case RestorationStat.stamina:
          variant = PickupVariant.restorationStamina;
      }

      entities.add(
        EntityRenderSnapshot(
          id: e,
          kind: EntityKind.pickup,
          pos: Vec2(world.transform.posX[ti], world.transform.posY[ti]),
          size: size,
          facing: Facing.right,
          pickupVariant: variant,
          rotationRad: pi * 0.25,
          anim: AnimKey.idle,
          grounded: false,
          animFrame: tick,
        ),
      );
    }
  }

  /// Appends enemy entity snapshots to [entities].
  ///
  /// Enemies have position, velocity, facing direction, and grounded state.
  /// Animation is read from [AnimStateStore], pre-computed by [AnimSystem].
  void _addEnemies(List<EntityRenderSnapshot> entities, {required int tick}) {
    final enemies = world.enemy;
    final animStore = world.animState;

    for (var ei = 0; ei < enemies.denseEntities.length; ei += 1) {
      final e = enemies.denseEntities[ei];
      if (!world.transform.has(e)) continue;
      final ti = world.transform.indexOf(e);
      final enemyId = enemies.enemyId[ei];
      final enemyArchetype = enemyCatalog.get(enemyId);

      Vec2? size;
      if (world.colliderAabb.has(e)) {
        final aabbi = world.colliderAabb.indexOf(e);
        size = Vec2(
          world.colliderAabb.halfX[aabbi] * 2,
          world.colliderAabb.halfY[aabbi] * 2,
        );
      }

      final grounded = world.collision.has(e)
          ? world.collision.grounded[world.collision.indexOf(e)]
          : false;

      // Read pre-computed animation from AnimStateStore.
      final AnimKey anim;
      final int animFrame;
      if (animStore.has(e)) {
        final ai = animStore.indexOf(e);
        anim = animStore.anim[ai];
        animFrame = animStore.animFrame[ai];
      } else {
        // Fallback if no anim component (shouldn't happen).
        anim = AnimKey.idle;
        animFrame = tick;
      }

      entities.add(
        EntityRenderSnapshot(
          id: e,
          kind: EntityKind.enemy,
          pos: Vec2(world.transform.posX[ti], world.transform.posY[ti]),
          vel: Vec2(world.transform.velX[ti], world.transform.velY[ti]),
          size: size,
          enemyId: enemyId,
          facing: enemies.facing[ei],
          artFacingDir: enemyArchetype.artFacingDir,
          anim: anim,
          grounded: grounded,
          animFrame: animFrame,
        ),
      );
    }
  }
}


===== FILE: lib/core/snapshots/entity_render_snapshot.dart =====
/// Renderer-facing entity data extracted from Core at the end of each tick.
///
/// This is a read-only, serializable view of entity state. It intentionally
/// hides internal ECS storage details and provides only what the renderer needs.
library;

import '../enemies/enemy_id.dart';
import '../util/vec2.dart';
import '../projectiles/projectile_id.dart';
import 'enums.dart';

/// Render-only snapshot of a single entity.
///
/// Created by [GameCore] after each simulation tick. Contains position,
/// animation state, and optional metadata for specialized rendering.
class EntityRenderSnapshot {
  const EntityRenderSnapshot({
    required this.id,
    required this.kind,
    required this.pos,
    required this.facing,
    required this.anim,
    required this.grounded,
    this.artFacingDir,
    this.vel,
    this.size,
    this.enemyId,
    this.projectileId,
    this.pickupVariant,
    this.z,
    this.rotationRad = 0.0,
    this.animFrame,
  });

  /// Stable entity identifier (protocol-stable).
  final int id;

  /// Broad entity classification for choosing visuals/behavior.
  final EntityKind kind;

  /// World position in virtual pixels.
  final Vec2 pos;

  /// Optional world velocity (useful for facing/animation).
  final Vec2? vel;

  /// Optional full extents in world units (virtual pixels).
  ///
  /// Render-only hint for placeholder shapes (e.g. projectile rectangles).
  final Vec2? size;

  /// Optional enemy archetype id (set when [kind] is [EntityKind.enemy]).
  final EnemyId? enemyId;

  /// Optional projectile archetype id (set when [kind] is [EntityKind.projectile]).
  final ProjectileId? projectileId;

  /// Optional pickup variant for render-only pickup styling.
  final int? pickupVariant;

  /// Optional sort key for render ordering.
  final double? z;

  /// Optional rotation (radians) for rendering orientation.
  final double rotationRad;

  /// Facing direction for choosing sprites/poses.
  final Facing facing;

  /// Direction the authored art faces when not mirrored.
  ///
  /// When null, render should assume `Facing.right`.
  final Facing? artFacingDir;

  /// Whether the entity is grounded at the end of the tick.
  ///
  /// This is authoritative collision state from Core (do not infer from anim).
  final bool grounded;

  /// Logical animation selection (renderer maps to assets).
  final AnimKey anim;

  /// Optional frame hint for deterministic animation in replays/networking.
  final int? animFrame;
}

/// Variant codes for pickup rendering.
///
/// Maps to visual styles (colors, icons) in the renderer.
abstract class PickupVariant {
  static const int collectible = 0;
  static const int restorationHealth = 1;
  static const int restorationMana = 2;
  static const int restorationStamina = 3;
}


===== FILE: lib/core/snapshots/enums.dart =====
/// Protocol-stable enums used by snapshots and the Core→Renderer contract.
///
/// **Stability**: These enums may become part of the network protocol for
/// replays or multiplayer. Avoid renaming or reordering values.
///
/// **Scope**: These are "logical" game concepts, not tied to specific
/// textures or asset names. The renderer maps them to visuals.
library;

/// Logical animation state for entity rendering.
///
/// The renderer maps these to sprite sheets or animation clips.
enum AnimKey {
  idle,
  stun,
  run,
  jump,
  fall,
  hit,
  cast,
  death,
  spawn,
  strike,
  dash,
  walk,
  backStrike,
  parry,
  ranged,
  roll,
  punch,
  shieldBash,
  shieldBlock,
  throwItem,
}

/// Broad entity classification for rendering and (future) networking.
///
/// Used to select visual style, collision layer, and render order.
enum EntityKind {
  player,
  enemy,
  projectile,
  obstacle,
  pickup,
  hazard,
  trigger,
}

/// Horizontal facing direction for sprites and directional abilities.
enum Facing {
  left,
  right,
}

/// Input interaction mode for an ability slot.
enum AbilityInputMode {
  /// Instant commit on press.
  tap,
  /// Hold to aim, commit on release.
  holdAimRelease,
}


===== FILE: lib/core/snapshots/game_state_snapshot.dart =====
/// Immutable snapshot of game state for rendering and UI.
///
/// Built by [GameCore] after each fixed simulation tick. This is the primary
/// contract between Core and the Flame/Flutter layer—treat as read-only.
library;

import '../levels/level_id.dart';
import 'entity_render_snapshot.dart';
import 'enums.dart';
import 'player_hud_snapshot.dart';
import 'static_ground_gap_snapshot.dart';
import 'static_solid_snapshot.dart';

/// Complete game state snapshot at a specific simulation tick.
///
/// Contains everything the renderer and UI need: camera position, HUD data,
/// entity list, and static geometry.
class GameStateSnapshot {
  const GameStateSnapshot({
    required this.tick,
    required this.runId,
    required this.seed,
    required this.levelId,
    required this.themeId,
    required this.distance,
    required this.paused,
    required this.gameOver,
    required this.cameraCenterX,
    required this.cameraCenterY,
    required this.hud,
    required this.entities,
    required this.staticSolids,
    required this.groundGaps,
  });

  /// Current simulation tick.
  final int tick;

  /// Unique identifier for this run session.
  final int runId;

  /// Seed used for deterministic generation/RNG.
  final int seed;

  /// Level identifier for this run (stable across sessions).
  final LevelId levelId;

  /// Optional render theme identifier for this run.
  ///
  /// This is Core-owned metadata (pure data) that the renderer can map to
  /// asset paths and visuals without importing any Core gameplay logic.
  final String? themeId;

  /// Distance progressed in the run.
  final double distance;

  /// Whether the simulation is currently paused.
  final bool paused;

  /// Whether the run has ended (simulation is frozen).
  final bool gameOver;

  /// Camera center used for rendering this snapshot.
  final double cameraCenterX;
  final double cameraCenterY;

  /// HUD-only player stats.
  final PlayerHudSnapshot hud;

  /// Render-only entity list for the current tick.
  final List<EntityRenderSnapshot> entities;

  /// Render-only static collision geometry (platforms/obstacles) for this run.
  final List<StaticSolidSnapshot> staticSolids;

  /// Render-only ground gaps (holes in the ground band).
  final List<StaticGroundGapSnapshot> groundGaps;

  /// Returns the player entity snapshot, or `null` if not found.
  ///
  /// Convenience getter to avoid duplicating player-lookup logic across
  /// rendering components.
  EntityRenderSnapshot? get playerEntity {
    for (final e in entities) {
      if (e.kind == EntityKind.player) return e;
    }
    return null;
  }
}


===== FILE: lib/core/snapshots/player_hud_snapshot.dart =====
/// HUD-only player data extracted from Core.
///
/// Separated from entity snapshots so the UI can render player stats
/// (HP bars, cooldowns, etc.) without scanning all entities.
import 'enums.dart';

class PlayerHudSnapshot {
  const PlayerHudSnapshot({
    required this.hp,
    required this.hpMax,
    required this.mana,
    required this.manaMax,
    required this.stamina,
    required this.staminaMax,
    required this.canAffordJump,
    required this.canAffordDash,
    required this.canAffordMelee,
    required this.canAffordSecondary,
    required this.canAffordProjectile,
    required this.canAffordBonus,
    required this.cooldownTicksLeft,
    required this.cooldownTicksTotal,
    required this.meleeInputMode,
    required this.projectileInputMode,
    required this.bonusInputMode,
    required this.bonusUsesMeleeAim,
    required this.collectibles,
    required this.collectibleScore,
  });

  /// Current health.
  final double hp;

  /// Maximum health.
  final double hpMax;

  /// Current mana (resource for spells).
  final double mana;

  /// Maximum mana.
  final double manaMax;

  /// Current stamina (resource for physical actions like jump/dash).
  final double stamina;

  /// Maximum stamina.
  final double staminaMax;

  /// Whether stamina is sufficient for jumping.
  final bool canAffordJump;

  /// Whether stamina is sufficient for dashing.
  final bool canAffordDash;

  /// Whether stamina is sufficient for melee.
  final bool canAffordMelee;

  /// Whether resources are sufficient for the equipped secondary/off-hand ability.
  final bool canAffordSecondary;

  /// Whether resources are sufficient for the equipped projectile ability.
  final bool canAffordProjectile;

  /// Whether resources are sufficient for the equipped bonus ability.
  final bool canAffordBonus;

  /// Remaining cooldown ticks for each CooldownGroup.
  final List<int> cooldownTicksLeft;

  /// Total cooldown ticks for each CooldownGroup.
  final List<int> cooldownTicksTotal;

  /// Input interaction mode for melee slot.
  final AbilityInputMode meleeInputMode;

  /// Input interaction mode for projectile slot.
  final AbilityInputMode projectileInputMode;


  /// Input interaction mode for bonus slot.
  final AbilityInputMode bonusInputMode;

  /// Which aim channel the bonus ability consumes when in hold-aim mode.
  ///
  /// - true  => uses melee aim direction
  /// - false => uses projectile aim direction
  final bool bonusUsesMeleeAim;

  /// Collected collectibles.
  final int collectibles;

  /// Score value earned from collectibles.
  final int collectibleScore;
}


===== FILE: lib/core/snapshots/static_ground_gap_snapshot.dart =====
/// Renderer-facing snapshot for a gap in the ground band.
///
/// This is a read-only view for rendering/debug overlays. Authoritative
/// collision still lives in Core using `StaticWorldGeometry`.
class StaticGroundGapSnapshot {
  const StaticGroundGapSnapshot({
    required this.minX,
    required this.maxX,
  });

  final double minX;
  final double maxX;
}


===== FILE: lib/core/snapshots/static_solid_snapshot.dart =====
/// Renderer-facing snapshot for one piece of static collision geometry.
///
/// This is a read-only view for rendering/debug overlays. Authoritative
/// collision still lives in Core using `StaticWorldGeometry`.
class StaticSolidSnapshot {
  const StaticSolidSnapshot({
    required this.minX,
    required this.minY,
    required this.maxX,
    required this.maxY,
    required this.sides,
    required this.oneWayTop,
  });

  final double minX;
  final double minY;
  final double maxX;
  final double maxY;

  /// Bitmask of enabled faces.
  final int sides;

  /// Whether the top face behaves as one-way (platform).
  final bool oneWayTop;
}



===== FILE: lib/core/spawn_service.dart =====
/// Entity spawning service for GameCore.
///
/// Centralizes all entity creation logic (enemies, collectibles, restoration
/// items) with deterministic placement algorithms. Determinism is critical
/// for replay consistency—given the same seed and chunk index, the same
/// entities spawn at the same positions.
///
/// ## Architecture
///
/// [SpawnService] is owned by [GameCore] and called during:
/// - **Enemy spawning**: When the spawn horizon advances, enemies are placed
///   at fixed X offsets ahead of the camera.
/// - **Chunk generation**: When [TrackManager] streams new chunks,
///   collectibles and restoration items are procedurally scattered.
///
/// ## Determinism Strategy
///
/// All RNG operations use [seedFrom] and [nextUint32] from the deterministic
/// RNG module. Each spawn type uses a unique salt (e.g., `0xC011EC7` for
/// collectibles) XOR'd with the chunk index to ensure:
/// - Same seed + chunk → same spawn pattern
/// - Different chunks → independent sequences
/// - Different spawn types → no correlation
///
/// ## Placement Algorithm
///
/// For collectibles and restoration items:
/// 1. Compute valid X range (chunk bounds minus edge margins).
/// 2. Generate random X, snap to grid.
/// 3. Query the [SurfaceGraph] for the highest platform at that X.
/// 4. Place item above the surface with clearance.
/// 5. Reject if overlapping solids or existing entities.
/// 6. Retry up to `maxAttempts` times.
library;

import 'abilities/ability_def.dart';
import 'ecs/entity_id.dart';
import 'ecs/entity_factory.dart';
import 'ecs/hit/aabb_hit_utils.dart';
import 'ecs/stores/body_store.dart';
import 'ecs/stores/collider_aabb_store.dart';
import 'ecs/stores/collectible_store.dart';
import 'ecs/stores/restoration_item_store.dart';
import 'ecs/world.dart';
import 'enemies/enemy_catalog.dart';
import 'enemies/enemy_id.dart';
import 'navigation/types/nav_tolerances.dart';
import 'navigation/types/surface_graph.dart';
import 'navigation/utils/surface_spatial_index.dart';
import 'snapshots/enums.dart';
import 'tuning/collectible_tuning.dart';
import 'tuning/flying_enemy_tuning.dart';
import 'players/player_tuning.dart';
import 'tuning/restoration_item_tuning.dart';
import 'tuning/track_tuning.dart';
import 'util/deterministic_rng.dart';

// ─────────────────────────────────────────────────────────────────────────────
// RNG Salt Constants
// ─────────────────────────────────────────────────────────────────────────────

/// RNG salt for collectible spawn positions ("COLLECT" in hex-speak).
const int _collectibleSalt = 0xC011EC7;

/// RNG salt for restoration item spawn phase offset ("ALTESAT" - alternate stat).
const int _restorationPhaseSalt = 0xA17E5A7;

/// RNG salt for restoration item spawn positions ("ASTALL" - a stall/restore).
const int _restorationSpawnSalt = 0xA57A11;

// ─────────────────────────────────────────────────────────────────────────────
// SpawnService
// ─────────────────────────────────────────────────────────────────────────────

/// Service for spawning game entities with deterministic, seeded placement.
///
/// Handles creation of:
/// - **Flying enemies**: Hover above ground, cast projectiles.
/// - **Ground enemies**: Walk on platforms, chase player.
/// - **Collectibles**: Score pickups scattered across chunks.
/// - **Restoration items**: Health/mana/stamina orbs on periodic chunks.
///
/// Usage:
/// ```dart
/// final spawner = SpawnService(world: ..., seed: 42, ...);
/// spawner.setSurfaceGraph(graph: navGraph, spatialIndex: index);
/// spawner.spawnUnocoDemon(spawnX: 500, groundTopY: 0);
/// spawner.spawnCollectiblesForChunk(chunkIndex: 3, ...);
/// ```
class SpawnService {
  /// Creates a spawn service with the given dependencies.
  ///
  /// - [world]: ECS world for entity creation and component access.
  /// - [entityFactory]: Factory for creating complex entities (enemies).
  /// - [enemyCatalog]: Archetype definitions for enemy types.
  /// - [unocoDemonTuning]: Flying enemy hover offset and cooldowns.
  /// - [movement]: Movement tuning for ground enemy velocity limits.
  /// - [collectibleTuning]: Spawn density, spacing, and margins.
  /// - [restorationItemTuning]: Spawn frequency and item sizing.
  /// - [trackTuning]: Chunk dimensions and grid snap settings.
  /// - [seed]: Master RNG seed for deterministic spawning.
  SpawnService({
    required EcsWorld world,
    required EntityFactory entityFactory,
    required EnemyCatalog enemyCatalog,
    required UnocoDemonTuningDerived unocoDemonTuning,
    required MovementTuningDerived movement,
    required CollectibleTuning collectibleTuning,
    required RestorationItemTuning restorationItemTuning,
    required TrackTuning trackTuning,
    required int seed,
  }) : _world = world,
       _entityFactory = entityFactory,
       _enemyCatalog = enemyCatalog,
       _unocoDemonTuning = unocoDemonTuning,
       _movement = movement,
       _collectibleTuning = collectibleTuning,
       _restorationItemTuning = restorationItemTuning,
       _trackTuning = trackTuning,
       _seed = seed;

  // ─── Dependencies ───
  final EcsWorld _world;
  final EntityFactory _entityFactory;
  final EnemyCatalog _enemyCatalog;
  final UnocoDemonTuningDerived _unocoDemonTuning;
  final MovementTuningDerived _movement;
  final CollectibleTuning _collectibleTuning;
  final RestorationItemTuning _restorationItemTuning;
  final TrackTuning _trackTuning;
  final int _seed;

  // ─── Scratch buffers (reused to avoid allocation) ───

  /// X positions of collectibles spawned in the current chunk (for spacing).
  final List<double> _collectibleSpawnXs = <double>[];

  /// Surface indices returned by spatial queries.
  final List<int> _surfaceQueryCandidates = <int>[];

  // ─── Surface graph state (updated by TrackManager) ───
  SurfaceGraph? _surfaceGraph;
  SurfaceSpatialIndex? _surfaceSpatialIndex;
  double _surfaceMinY = 0.0;
  double _surfaceMaxY = 0.0;

  // ───────────────────────────────────────────────────────────────────────────
  // Surface Graph Management
  // ───────────────────────────────────────────────────────────────────────────

  /// Updates the navigation surface graph for item placement queries.
  ///
  /// Called by [TrackManager] whenever the track geometry changes.
  /// The surface graph provides platform positions for placing items
  /// "on top of" surfaces rather than floating in mid-air.
  ///
  /// Also caches the Y-axis bounds for efficient spatial queries.
  void setSurfaceGraph({
    required SurfaceGraph? graph,
    required SurfaceSpatialIndex? spatialIndex,
  }) {
    _surfaceGraph = graph;
    _surfaceSpatialIndex = spatialIndex;
    _surfaceMinY = 0.0;
    _surfaceMaxY = 0.0;

    // Pre-compute Y bounds to avoid repeated iteration during queries.
    if (graph != null && graph.surfaces.isNotEmpty) {
      var minY = graph.surfaces.first.yTop;
      var maxY = minY;
      for (var i = 1; i < graph.surfaces.length; i += 1) {
        final y = graph.surfaces[i].yTop;
        if (y < minY) minY = y;
        if (y > maxY) maxY = y;
      }
      _surfaceMinY = minY;
      _surfaceMaxY = maxY;
    }
  }

  // ───────────────────────────────────────────────────────────────────────────
  // Enemy Spawning
  // ───────────────────────────────────────────────────────────────────────────

  /// Spawns the Unoco Demon at [spawnX], hovering above [groundTopY].
  ///
  /// Flying enemies are placed at a fixed vertical offset above the ground
  /// (defined by [UnocoDemonTuning.unocoDemonHoverOffsetY]). They don't
  /// use gravity and will begin AI behavior on the next tick.
  ///
  /// The enemy's cast cooldown is pre-set to avoid immediate projectile
  /// spam on the spawn tick—this keeps early-game pacing predictable.
  ///
  /// Returns the [EntityId] of the newly created enemy.
  EntityId spawnUnocoDemon({
    required double spawnX,
    required double groundTopY,
  }) {
    final archetype = _enemyCatalog.get(EnemyId.unocoDemon);
    final unocoDemon = _entityFactory.createEnemy(
      enemyId: EnemyId.unocoDemon,
      posX: spawnX,
      posY: groundTopY - _unocoDemonTuning.base.unocoDemonHoverOffsetY,
      velX: 0.0,
      velY: 0.0,
      facing: Facing.left,
      body: archetype.body,
      collider: archetype.collider,
      health: archetype.health,
      mana: archetype.mana,
      stamina: archetype.stamina,
      tags: archetype.tags,
      resistance: archetype.resistance,
      statusImmunity: archetype.statusImmunity,
    );

    // Pre-set cooldown to prevent immediate casting on spawn tick.
    // This ensures consistent early-game difficulty across runs.
    _world.cooldown.setTicksLeft(
      unocoDemon,
      CooldownGroup.projectile,
      _unocoDemonTuning.unocoDemonCastCooldownTicks,
    );

    return unocoDemon;
  }

  /// Spawns a ground enemy at [spawnX], standing on [groundTopY].
  ///
  /// Ground enemies use gravity and collision. Their Y position is
  /// computed so their collider's bottom edge rests on the ground surface.
  ///
  /// The enemy inherits movement velocity limits from [MovementTuning]
  /// to ensure consistent chase behavior relative to player speed.
  ///
  /// Returns the [EntityId] of the newly created enemy.
  EntityId spawnGroundEnemy({
    required double spawnX,
    required double groundTopY,
  }) {
    final archetype = _enemyCatalog.get(EnemyId.grojib);

    // Position so collider bottom touches ground.
    return _entityFactory.createEnemy(
      enemyId: EnemyId.grojib,
      posX: spawnX,
      posY:
          groundTopY - (archetype.collider.offsetY + archetype.collider.halfY),
      velX: 0.0,
      velY: 0.0,
      facing: Facing.left,
      body: BodyDef(
        enabled: archetype.body.enabled,
        isKinematic: archetype.body.isKinematic,
        useGravity: archetype.body.useGravity,
        ignoreCeilings: archetype.body.ignoreCeilings,
        topOnlyGround: archetype.body.topOnlyGround,
        gravityScale: archetype.body.gravityScale,
        maxVelX: _movement.base.maxVelX,
        maxVelY: _movement.base.maxVelY,
        sideMask: archetype.body.sideMask,
      ),
      collider: archetype.collider,
      health: archetype.health,
      mana: archetype.mana,
      stamina: archetype.stamina,
      tags: archetype.tags,
      resistance: archetype.resistance,
      statusImmunity: archetype.statusImmunity,
    );
  }

  // ───────────────────────────────────────────────────────────────────────────
  // Collectible & Restoration Item Spawning
  // ───────────────────────────────────────────────────────────────────────────

  /// Spawns a single collectible at the given world position.
  ///
  /// Collectibles are stationary pickups that grant score when touched.
  /// They have an AABB collider for overlap detection but no physics body.
  ///
  /// Prefer [spawnCollectiblesForChunk] for procedural placement.
  EntityId spawnCollectibleAt(double x, double y) {
    final half = _collectibleTuning.collectibleSize * 0.5;
    final entity = _world.createEntity();
    _world.transform.add(entity, posX: x, posY: y, velX: 0.0, velY: 0.0);
    _world.colliderAabb.add(entity, ColliderAabbDef(halfX: half, halfY: half));
    _world.collectible.add(
      entity,
      CollectibleDef(value: _collectibleTuning.valuePerCollectible),
    );
    return entity;
  }

  /// Spawns a restoration item at the given world position.
  ///
  /// Restoration items restore the specified [stat] (health, mana, or
  /// stamina) when collected. Like collectibles, they're stationary with
  /// an AABB collider.
  ///
  /// Prefer [spawnRestorationItemForChunk] for procedural placement.
  EntityId spawnRestorationItemAt(double x, double y, RestorationStat stat) {
    final half = _restorationItemTuning.itemSize * 0.5;
    final entity = _world.createEntity();
    _world.transform.add(entity, posX: x, posY: y, velX: 0.0, velY: 0.0);
    _world.colliderAabb.add(entity, ColliderAabbDef(halfX: half, halfY: half));
    _world.restorationItem.add(entity, RestorationItemDef(stat: stat));
    return entity;
  }

  /// Spawns collectibles for a track chunk using deterministic placement.
  ///
  /// This method:
  /// 1. Skips if collectibles are disabled or chunk is too early.
  /// 2. Determines spawn count from RNG (between min and max per chunk).
  /// 3. For each collectible, picks a random X within chunk bounds.
  /// 4. Snaps X to grid and enforces minimum spacing between items.
  /// 5. Queries the highest surface at that X for vertical placement.
  /// 6. Rejects positions overlapping platforms or existing items.
  ///
  /// The RNG is seeded with `seed XOR chunkIndex XOR 0xC011EC7` to ensure
  /// deterministic but unique sequences per chunk.
  void spawnCollectiblesForChunk({
    required int chunkIndex,
    required double chunkStartX,
    required List<StaticSolid> solids,
  }) {
    final tuning = _collectibleTuning;

    // ─── Early-out checks ───
    if (!tuning.enabled) return;
    if (chunkIndex < tuning.spawnStartChunkIndex) return;
    if (tuning.maxPerChunk <= 0) return;

    final graph = _surfaceGraph;
    final spatialIndex = _surfaceSpatialIndex;
    if (graph == null || spatialIndex == null || graph.surfaces.isEmpty) {
      return;
    }

    // ─── Compute valid X range ───
    final minX = chunkStartX + tuning.chunkEdgeMarginX;
    final maxX =
        chunkStartX + _trackTuning.chunkWidth - tuning.chunkEdgeMarginX;
    if (maxX <= minX) return;

    // ─── Initialize RNG and determine target count ───
    var rngState = seedFrom(_seed, chunkIndex ^ _collectibleSalt);
    rngState = nextUint32(rngState);
    final countRange = tuning.maxPerChunk - tuning.minPerChunk + 1;
    final targetCount = tuning.minPerChunk + (rngState % countRange);
    if (targetCount <= 0) return;

    // ─── Spawn loop with rejection sampling ───
    _collectibleSpawnXs.clear();
    final halfSize = tuning.collectibleSize * 0.5;
    final maxAttempts = tuning.maxAttemptsPerChunk;

    for (
      var attempt = 0;
      attempt < maxAttempts && _collectibleSpawnXs.length < targetCount;
      attempt += 1
    ) {
      // Generate candidate X position.
      rngState = nextUint32(rngState);
      var x = rangeDouble(rngState, minX, maxX);
      x = _snapToGrid(x, _trackTuning.gridSnap);
      if (x < minX || x > maxX) continue;

      // Enforce minimum spacing from already-spawned collectibles.
      if (tuning.minSpacingX > 0.0) {
        var spaced = true;
        for (final prevX in _collectibleSpawnXs) {
          if ((prevX - x).abs() < tuning.minSpacingX) {
            spaced = false;
            break;
          }
        }
        if (!spaced) continue;
      }

      // Find surface Y and compute item center position.
      final surfaceY = _highestSurfaceYAtX(x);
      if (surfaceY == null) continue;
      final centerY = surfaceY - tuning.surfaceClearanceY - halfSize;

      // Reject if overlapping static geometry.
      if (_overlapsAnySolid(
        centerX: x,
        centerY: centerY,
        halfSize: halfSize,
        margin: tuning.noSpawnMargin,
        solids: solids,
      )) {
        continue;
      }

      // Success—spawn and record position.
      spawnCollectibleAt(x, centerY);
      _collectibleSpawnXs.add(x);
    }
  }

  /// Spawns a restoration item for a chunk if eligible.
  ///
  /// Restoration items spawn on a periodic schedule (e.g., every N chunks)
  /// with a phase offset derived from the seed to avoid predictable timing.
  ///
  /// The item type is determined by [lowestResourceStat], which should
  /// return the player's most depleted resource (health, mana, or stamina).
  ///
  /// Placement follows the same rejection-sampling algorithm as collectibles,
  /// with an additional check to avoid overlapping existing collectibles.
  void spawnRestorationItemForChunk({
    required int chunkIndex,
    required double chunkStartX,
    required List<StaticSolid> solids,
    required RestorationStat Function() lowestResourceStat,
  }) {
    final tuning = _restorationItemTuning;

    // ─── Early-out checks ───
    if (!tuning.enabled) return;
    if (chunkIndex < tuning.spawnStartChunkIndex) return;
    if (tuning.spawnEveryChunks <= 0) return;

    // ─── Periodic spawn check (with seeded phase offset) ───
    final phase =
        seedFrom(_seed, _restorationPhaseSalt) % tuning.spawnEveryChunks;
    if ((chunkIndex - phase) % tuning.spawnEveryChunks != 0) return;

    final graph = _surfaceGraph;
    final spatialIndex = _surfaceSpatialIndex;
    if (graph == null || spatialIndex == null || graph.surfaces.isEmpty) {
      return;
    }

    // ─── Compute valid X range ───
    final minX = chunkStartX + tuning.chunkEdgeMarginX;
    final maxX =
        chunkStartX + _trackTuning.chunkWidth - tuning.chunkEdgeMarginX;
    if (maxX <= minX) return;

    // ─── Determine which stat to restore ───
    final stat = lowestResourceStat();

    // ─── Spawn with rejection sampling ───
    var rngState = seedFrom(_seed, chunkIndex ^ _restorationSpawnSalt);
    final halfSize = tuning.itemSize * 0.5;

    for (var attempt = 0; attempt < tuning.maxAttemptsPerSpawn; attempt += 1) {
      rngState = nextUint32(rngState);
      var x = rangeDouble(rngState, minX, maxX);
      x = _snapToGrid(x, _trackTuning.gridSnap);
      if (x < minX || x > maxX) continue;

      final surfaceY = _highestSurfaceYAtX(x);
      if (surfaceY == null) continue;
      final centerY = surfaceY - tuning.surfaceClearanceY - halfSize;

      // Reject if overlapping static geometry.
      if (_overlapsAnySolid(
        centerX: x,
        centerY: centerY,
        halfSize: halfSize,
        margin: tuning.noSpawnMargin,
        solids: solids,
      )) {
        continue;
      }

      // Reject if overlapping existing collectibles.
      if (_overlapsAnyCollectible(
        centerX: x,
        centerY: centerY,
        halfSize: halfSize,
        margin: tuning.noSpawnMargin,
      )) {
        continue;
      }

      // Success—spawn and exit.
      spawnRestorationItemAt(x, centerY, stat);
      return;
    }
  }

  // ───────────────────────────────────────────────────────────────────────────
  // Private Helpers
  // ───────────────────────────────────────────────────────────────────────────

  /// Snaps [x] to the nearest multiple of [grid].
  ///
  /// Grid snapping ensures items align visually with the track's tile grid,
  /// avoiding sub-pixel positioning artifacts.
  double _snapToGrid(double x, double grid) {
    if (grid <= 0) return x;
    return (x / grid).roundToDouble() * grid;
  }

  /// Returns the Y coordinate of the highest surface at [x], or null if none.
  ///
  /// Uses the [SurfaceSpatialIndex] for efficient lookup, then filters
  /// candidates to find the topmost platform. Ties are broken by surface ID
  /// for determinism.
  double? _highestSurfaceYAtX(double x) {
    final graph = _surfaceGraph;
    final spatialIndex = _surfaceSpatialIndex;
    if (graph == null || spatialIndex == null || graph.surfaces.isEmpty) {
      return null;
    }

    // Query all surfaces that might contain X.
    final minY = _surfaceMinY - navSpatialEps;
    final maxY = _surfaceMaxY + navSpatialEps;
    _surfaceQueryCandidates.clear();
    spatialIndex.queryAabb(
      minX: x - navSpatialEps,
      minY: minY,
      maxX: x + navSpatialEps,
      maxY: maxY,
      outSurfaceIndices: _surfaceQueryCandidates,
    );

    // Find highest (smallest Y in screen coords) surface containing X.
    double? bestY;
    int? bestId;
    for (final i in _surfaceQueryCandidates) {
      final s = graph.surfaces[i];
      if (x < s.xMin - navGeomEps || x > s.xMax + navGeomEps) continue;

      // Prefer lower Y (higher on screen). Break ties by ID for determinism.
      if (bestY == null || s.yTop < bestY - navTieEps) {
        bestY = s.yTop;
        bestId = s.id;
      } else if ((s.yTop - bestY).abs() <= navTieEps && s.id < bestId!) {
        bestY = s.yTop;
        bestId = s.id;
      }
    }

    return bestY;
  }

  /// Checks if an AABB centered at ([centerX], [centerY]) overlaps any solid.
  ///
  /// The AABB is expanded by [margin] to prevent items from spawning too
  /// close to platform edges.
  bool _overlapsAnySolid({
    required double centerX,
    required double centerY,
    required double halfSize,
    required double margin,
    required List<StaticSolid> solids,
  }) {
    if (solids.isEmpty) return false;

    // Expand bounds by half-size and margin.
    final minX = centerX - halfSize - margin;
    final maxX = centerX + halfSize + margin;
    final minY = centerY - halfSize - margin;
    final maxY = centerY + halfSize + margin;

    for (final solid in solids) {
      final overlaps = aabbOverlapsMinMax(
        aMinX: minX,
        aMaxX: maxX,
        aMinY: minY,
        aMaxY: maxY,
        bMinX: solid.minX,
        bMaxX: solid.maxX,
        bMinY: solid.minY,
        bMaxY: solid.maxY,
      );
      if (overlaps) return true;
    }
    return false;
  }

  /// Checks if an AABB overlaps any existing collectible entity.
  ///
  /// Used by restoration item spawning to avoid stacking pickups.
  bool _overlapsAnyCollectible({
    required double centerX,
    required double centerY,
    required double halfSize,
    required double margin,
  }) {
    final collectibles = _world.collectible;
    if (collectibles.denseEntities.isEmpty) return false;

    final minX = centerX - halfSize - margin;
    final maxX = centerX + halfSize + margin;
    final minY = centerY - halfSize - margin;
    final maxY = centerY + halfSize + margin;

    for (var ci = 0; ci < collectibles.denseEntities.length; ci += 1) {
      final e = collectibles.denseEntities[ci];
      if (!(_world.transform.has(e) && _world.colliderAabb.has(e))) continue;

      // Read collectible's world-space AABB.
      final ti = _world.transform.indexOf(e);
      final ai = _world.colliderAabb.indexOf(e);
      final cx = _world.transform.posX[ti] + _world.colliderAabb.offsetX[ai];
      final cy = _world.transform.posY[ti] + _world.colliderAabb.offsetY[ai];

      final overlaps = aabbOverlapsMinMax(
        aMinX: minX,
        aMaxX: maxX,
        aMinY: minY,
        aMaxY: maxY,
        bMinX: cx - _world.colliderAabb.halfX[ai],
        bMaxX: cx + _world.colliderAabb.halfX[ai],
        bMinY: cy - _world.colliderAabb.halfY[ai],
        bMaxY: cy + _world.colliderAabb.halfY[ai],
      );
      if (overlaps) return true;
    }

    return false;
  }
}

// ─────────────────────────────────────────────────────────────────────────────
// Supporting Types
// ─────────────────────────────────────────────────────────────────────────────

/// Axis-aligned bounding box for static world geometry.
///
/// Used by [SpawnService] for overlap rejection during item placement.
/// Re-exported here to avoid circular imports with collision module.
typedef StaticSolid = ({double minX, double maxX, double minY, double maxY});


===== FILE: lib/core/track/chunk_builder.dart =====
/// Chunk geometry builder functions for track streaming.
///
/// Converts chunk-relative pattern definitions into world-space collision
/// geometry ([StaticSolid], [StaticGroundSegment], [StaticGroundGap]).
library;

import '../collision/static_world_geometry.dart';
import 'chunk_pattern.dart';

/// Result of building ground geometry from a chunk pattern.
class GroundBuildResult {
  const GroundBuildResult({
    required this.segments,
    required this.gaps,
  });

  /// Walkable ground spans (between gaps).
  final List<StaticGroundSegment> segments;

  /// Pit/gap spans.
  final List<StaticGroundGap> gaps;
}

/// Converts pattern platforms/obstacles into world-space [StaticSolid]s.
///
/// [pattern] - The chunk pattern containing platforms and obstacles.
/// [chunkStartX] - World X where this chunk begins.
/// [chunkIndex] - Sequential chunk number for tagging solids.
/// [groundTopY] - World Y of the ground surface.
/// [chunkWidth] - Width of a chunk (for bounds checking).
/// [gridSnap] - Grid snap value (for alignment checking).
List<StaticSolid> buildSolids(
  ChunkPattern pattern, {
  required double chunkStartX,
  required int chunkIndex,
  required double groundTopY,
  required double chunkWidth,
  required double gridSnap,
}) {
  // Preserve author ordering for determinism.
  final solids = <StaticSolid>[];
  var localSolidIndex = 0;

  // ── Platforms (one-way top) ──
  for (final p in pattern.platforms) {
    assert(
      _withinChunk(p.x, p.width, chunkWidth),
      'Platform out of chunk bounds: ${pattern.name}',
    );
    assert(
      _snapped(p.x, gridSnap) &&
          _snapped(p.width, gridSnap) &&
          _snapped(p.aboveGroundTop, gridSnap),
      'Platform not snapped to grid: ${pattern.name}',
    );
    final topY = groundTopY - p.aboveGroundTop;
    solids.add(
      StaticSolid(
        minX: chunkStartX + p.x,
        minY: topY,
        maxX: chunkStartX + p.x + p.width,
        maxY: topY + p.thickness,
        sides: StaticSolid.sideTop,
        oneWayTop: true,
        chunkIndex: chunkIndex,
        localSolidIndex: localSolidIndex,
      ),
    );
    localSolidIndex += 1;
  }

  // ── Obstacles (solid on all sides) ──
  for (final o in pattern.obstacles) {
    assert(
      _withinChunk(o.x, o.width, chunkWidth),
      'Obstacle out of chunk bounds: ${pattern.name}',
    );
    assert(
      _snapped(o.x, gridSnap) &&
          _snapped(o.width, gridSnap) &&
          _snapped(o.height, gridSnap),
      'Obstacle not snapped to grid: ${pattern.name}',
    );
    solids.add(
      StaticSolid(
        minX: chunkStartX + o.x,
        minY: groundTopY - o.height,
        maxX: chunkStartX + o.x + o.width,
        maxY: groundTopY,
        sides: StaticSolid.sideAll,
        oneWayTop: false,
        chunkIndex: chunkIndex,
        localSolidIndex: localSolidIndex,
      ),
    );
    localSolidIndex += 1;
  }

  return solids;
}

/// Builds ground segments by splitting at gap positions.
///
/// Gaps are sorted by X, then segments fill the remaining spans.
///
/// [pattern] - The chunk pattern containing ground gaps.
/// [chunkStartX] - World X where this chunk begins.
/// [chunkIndex] - Sequential chunk number for tagging segments.
/// [groundTopY] - World Y of the ground surface.
/// [chunkWidth] - Width of a chunk.
/// [gridSnap] - Grid snap value (for alignment checking).
GroundBuildResult buildGroundSegments(
  ChunkPattern pattern, {
  required double chunkStartX,
  required int chunkIndex,
  required double groundTopY,
  required double chunkWidth,
  required double gridSnap,
}) {
  // Sort gaps left-to-right for sequential processing.
  final orderedGaps = List<GapRel>.from(pattern.groundGaps);
  if (orderedGaps.isNotEmpty) {
    orderedGaps.sort((a, b) => a.x.compareTo(b.x));
  }

  final segments = <StaticGroundSegment>[];
  final gaps = <StaticGroundGap>[];
  var cursor = 0.0; // Tracks end of last segment/gap.
  var localSegmentIndex = 0;
  var lastGapEnd = -1.0; // For overlap assertion.

  for (final gap in orderedGaps) {
    assert(
      _withinChunk(gap.x, gap.width, chunkWidth),
      'Ground gap out of chunk bounds: ${pattern.name}',
    );
    assert(
      _snapped(gap.x, gridSnap) && _snapped(gap.width, gridSnap),
      'Ground gap not snapped to grid: ${pattern.name}',
    );
    assert(
      gap.x >= lastGapEnd - 1e-6,
      'Ground gap overlaps previous: ${pattern.name}',
    );

    final gapStart = gap.x;
    final gapEnd = gap.x + gap.width;

    // Emit segment from cursor to gap start (if non-empty).
    if (gapStart > cursor + 1e-6) {
      segments.add(
        StaticGroundSegment(
          minX: chunkStartX + cursor,
          maxX: chunkStartX + gapStart,
          topY: groundTopY,
          chunkIndex: chunkIndex,
          localSegmentIndex: localSegmentIndex,
        ),
      );
      localSegmentIndex += 1;
    }

    // Record gap for collision/rendering.
    gaps.add(
      StaticGroundGap(
        minX: chunkStartX + gapStart,
        maxX: chunkStartX + gapEnd,
      ),
    );

    // Advance cursor past gap.
    cursor = gapEnd > cursor ? gapEnd : cursor;
    lastGapEnd = gapEnd;
  }

  // Emit trailing segment from last gap to chunk end.
  if (cursor < chunkWidth - 1e-6) {
    segments.add(
      StaticGroundSegment(
        minX: chunkStartX + cursor,
        maxX: chunkStartX + chunkWidth,
        topY: groundTopY,
        chunkIndex: chunkIndex,
        localSegmentIndex: localSegmentIndex,
      ),
    );
  }

  return GroundBuildResult(segments: segments, gaps: gaps);
}

/// Checks if a span [x, x+width] fits within [0, chunkWidth].
bool _withinChunk(double x, double width, double chunkWidth) {
  return x >= 0.0 && (x + width) <= chunkWidth;
}

/// Checks if a value is snapped to the grid.
bool _snapped(double v, double gridSnap) {
  final snapped = (v / gridSnap).roundToDouble() * gridSnap;
  return (v - snapped).abs() < 1e-9;
}


===== FILE: lib/core/track/chunk_pattern.dart =====
/// Chunk pattern data structures for track streaming.
///
/// Defines the authored building blocks (platforms, obstacles, gaps, spawns)
/// used to compose procedural track chunks.
library;

import '../enemies/enemy_id.dart';

/// Authored chunk template defining platforms, obstacles, gaps, and spawns.
///
/// All coordinates are chunk-relative (x in `[0, chunkWidth)`).
/// Heights are expressed as "above ground top" so patterns are ground-agnostic.
class ChunkPattern {
  const ChunkPattern({
    required this.name,
    this.platforms = const <PlatformRel>[],
    this.obstacles = const <ObstacleRel>[],
    this.groundGaps = const <GapRel>[],
    this.spawnMarkers = const <SpawnMarker>[],
  });

  /// Human-readable identifier for debugging/logging.
  final String name;

  /// One-way platforms the player can jump through.
  final List<PlatformRel> platforms;

  /// Solid obstacles the player must jump over.
  final List<ObstacleRel> obstacles;

  /// Holes in the ground (pit hazards or visual breaks).
  final List<GapRel> groundGaps;

  /// Probabilistic enemy spawn points.
  final List<SpawnMarker> spawnMarkers;
}

/// Chunk-relative platform definition (one-way top surface).
class PlatformRel {
  const PlatformRel({
    required this.x,
    required this.width,
    required this.aboveGroundTop,
    required this.thickness,
  }) : assert(width > 0),
       assert(thickness > 0),
       assert(aboveGroundTop > 0);

  /// Left edge offset from chunk start.
  final double x;

  /// Horizontal extent.
  final double width;

  /// Vertical offset above ground (positive = higher).
  final double aboveGroundTop;

  /// Platform thickness (visual/collision depth).
  final double thickness;
}

/// Chunk-relative obstacle definition (solid on all sides).
class ObstacleRel {
  const ObstacleRel({
    required this.x,
    required this.width,
    required this.height,
  }) : assert(width > 0),
       assert(height > 0);

  /// Left edge offset from chunk start.
  final double x;

  /// Horizontal extent.
  final double width;

  /// Vertical extent (sits on ground, extends upward).
  final double height;
}

/// Chunk-relative ground gap (pit hazard).
class GapRel {
  const GapRel({
    required this.x,
    required this.width,
  }) : assert(width > 0);

  /// Left edge offset from chunk start.
  final double x;

  /// Horizontal extent of the gap.
  final double width;
}

/// Chunk-relative enemy spawn marker with probabilistic activation.
class SpawnMarker {
  const SpawnMarker({
    required this.enemyId,
    required this.x,
    required this.chancePercent,
    required this.salt,
  }) : assert(chancePercent >= 0),
       assert(chancePercent <= 100);

  /// Enemy type to spawn.
  final EnemyId enemyId;

  /// Spawn X offset from chunk start.
  final double x;

  /// Probability [0–100] that this marker activates.
  final int chancePercent;

  /// Extra entropy to differentiate markers with same position.
  final int salt;
}


===== FILE: lib/core/track/chunk_pattern_pool.dart =====
/// Groups pattern pools used for procedural track generation.
library;

import 'chunk_pattern.dart';

/// Default count of early chunks that draw from the "easy" pool.
const int defaultEarlyPatternChunks = 3;

/// Default count of early chunks that suppress enemy spawns.
const int defaultNoEnemyChunks = 3;

/// Pattern pools for early vs full difficulty.
class ChunkPatternPool {
  const ChunkPatternPool({
    required this.easyPatterns,
    required this.allPatterns,
  });

  /// Simpler patterns for early chunks.
  final List<ChunkPattern> easyPatterns;

  /// Full pattern pool used after early chunks.
  final List<ChunkPattern> allPatterns;
}


===== FILE: lib/core/track/chunk_patterns_library.dart =====
/// Pre-authored chunk pattern library for track streaming.
///
/// Notes:
/// - All coordinates are relative to the chunk start (x in [0, chunkWidth)).
/// - Y is expressed as "above ground top" (so 48 means 48 units above ground).
/// - Values are authored on a 16-unit grid for stability.
library;

import '../enemies/enemy_id.dart';
import 'chunk_pattern.dart';

/// Standard platform thickness (visual/collision depth).
const double kPlatformThickness = 16.0;

/// Shorthand for [kPlatformThickness] in pattern definitions.
const double _t = kPlatformThickness;

/// Simpler patterns for early-game chunks (default early window).
///
/// These give the player breathing room before harder patterns appear.
const List<ChunkPattern> easyPatterns = <ChunkPattern>[
  ChunkPattern(
    name: 'recovery-flat',
    platforms: <PlatformRel>[],
    obstacles: <ObstacleRel>[],
    groundGaps: <GapRel>[],
    spawnMarkers: <SpawnMarker>[],
  ),
  ChunkPattern(
    name: 'single-low-platform',
    platforms: <PlatformRel>[
      PlatformRel(x: 160, width: 160, aboveGroundTop: 48, thickness: _t),
    ],
    obstacles: <ObstacleRel>[],
    groundGaps: <GapRel>[GapRel(x: 64, width: 96)],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
        enemyId: EnemyId.unocoDemon,
        x: 240,
        chancePercent: 10,
        salt: 0x11,
      ),
    ],
  ),
  ChunkPattern(
    name: 'two-low-platforms',
    platforms: <PlatformRel>[
      PlatformRel(x: 64, width: 144, aboveGroundTop: 48, thickness: _t),
      PlatformRel(x: 272, width: 144, aboveGroundTop: 64, thickness: _t),
    ],
    obstacles: <ObstacleRel>[],
    groundGaps: <GapRel>[],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
        enemyId: EnemyId.grojib,
        x: 448,
        chancePercent: 10,
        salt: 0x12,
      ),
    ],
  ),
];

/// Full pattern pool for later chunks (index >= 3).
///
/// Includes [easyPatterns] plus more challenging layouts.
const List<ChunkPattern> allPatterns = <ChunkPattern>[
  // ── Recovery / breathers ──
  ...easyPatterns,

  // ── Platforming ──
  ChunkPattern(
    name: 'staggered-mid-platforms',
    platforms: <PlatformRel>[
      PlatformRel(x: 48, width: 160, aboveGroundTop: 64, thickness: _t),
      PlatformRel(x: 256, width: 160, aboveGroundTop: 96, thickness: _t),
    ],
    groundGaps: <GapRel>[GapRel(x: 240, width: 128)],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
        enemyId: EnemyId.unocoDemon,
        x: 352,
        chancePercent: 17,
        salt: 0x01,
      ),
    ],
  ),
  ChunkPattern(
    name: 'triple-runner-platforms',
    platforms: <PlatformRel>[
      PlatformRel(x: 32, width: 128, aboveGroundTop: 48, thickness: _t),
      PlatformRel(x: 192, width: 128, aboveGroundTop: 80, thickness: _t),
      PlatformRel(x: 352, width: 96, aboveGroundTop: 64, thickness: _t),
    ],
    groundGaps: <GapRel>[],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
        enemyId: EnemyId.unocoDemon,
        x: 288,
        chancePercent: 15,
        salt: 0x02,
      ),
    ],
  ),
  ChunkPattern(
    name: 'high-platform-over-obstacle',
    platforms: <PlatformRel>[
      PlatformRel(x: 224, width: 192, aboveGroundTop: 112, thickness: _t),
    ],
    obstacles: <ObstacleRel>[ObstacleRel(x: 128, width: 48, height: 64)],
    groundGaps: <GapRel>[GapRel(x: 176, width: 96)],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
        enemyId: EnemyId.grojib,
        x: 320,
        chancePercent: 22,
        salt: 0x03,
      ),
    ],
  ),

  // ── Obstacles (ground blocks that force a jump/dash) ──
  ChunkPattern(
    name: 'single-block',
    obstacles: <ObstacleRel>[ObstacleRel(x: 224, width: 48, height: 64)],
    groundGaps: <GapRel>[GapRel(x: 128, width: 96)],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
        enemyId: EnemyId.grojib,
        x: 320,
        chancePercent: 17,
        salt: 0x04,
      ),
    ],
  ),
  ChunkPattern(
    name: 'double-blocks',
    obstacles: <ObstacleRel>[
      ObstacleRel(x: 160, width: 32, height: 48),
      ObstacleRel(x: 288, width: 48, height: 64),
    ],
    groundGaps: <GapRel>[],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
        enemyId: EnemyId.unocoDemon,
        x: 96,
        chancePercent: 12,
        salt: 0x05,
      ),
      SpawnMarker(
        enemyId: EnemyId.grojib,
        x: 352,
        chancePercent: 15,
        salt: 0x06,
      ),
    ],
  ),
  ChunkPattern(
    name: 'low-staircase-platforms',
    platforms: <PlatformRel>[
      PlatformRel(x: 48, width: 128, aboveGroundTop: 48, thickness: _t),
      PlatformRel(x: 208, width: 128, aboveGroundTop: 64, thickness: _t),
      PlatformRel(x: 368, width: 128, aboveGroundTop: 80, thickness: _t),
    ],
    groundGaps: <GapRel>[GapRel(x: 304, width: 96)],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
        enemyId: EnemyId.grojib,
        x: 112,
        chancePercent: 15,
        salt: 0x07,
      ),
      SpawnMarker(
        enemyId: EnemyId.unocoDemon,
        x: 320,
        chancePercent: 15,
        salt: 0x08,
      ),
    ],
  ),
  ChunkPattern(
    name: 'wide-platform-gap',
    platforms: <PlatformRel>[
      PlatformRel(x: 32, width: 192, aboveGroundTop: 64, thickness: _t),
      PlatformRel(x: 288, width: 192, aboveGroundTop: 64, thickness: _t),
    ],
    groundGaps: <GapRel>[],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
        enemyId: EnemyId.unocoDemon,
        x: 192,
        chancePercent: 17,
        salt: 0x09,
      ),
      SpawnMarker(
        enemyId: EnemyId.grojib,
        x: 448,
        chancePercent: 15,
        salt: 0x0A,
      ),
    ],
  ),
  ChunkPattern(
    name: 'double-obstacle-lane',
    obstacles: <ObstacleRel>[
      ObstacleRel(x: 144, width: 48, height: 64),
      ObstacleRel(x: 336, width: 48, height: 64),
    ],
    groundGaps: <GapRel>[],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
        enemyId: EnemyId.grojib,
        x: 256,
        chancePercent: 17,
        salt: 0x0B,
      ),
      SpawnMarker(
        enemyId: EnemyId.unocoDemon,
        x: 80,
        chancePercent: 12,
        salt: 0x0C,
      ),
    ],
  ),
  ChunkPattern(
    name: 'mid-platform-overhang',
    platforms: <PlatformRel>[
      PlatformRel(x: 96, width: 160, aboveGroundTop: 96, thickness: _t),
      PlatformRel(x: 384, width: 128, aboveGroundTop: 64, thickness: _t),
    ],
    obstacles: <ObstacleRel>[ObstacleRel(x: 320, width: 64, height: 80)],
    groundGaps: <GapRel>[],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
        enemyId: EnemyId.unocoDemon,
        x: 176,
        chancePercent: 15,
        salt: 0x0D,
      ),
      SpawnMarker(
        enemyId: EnemyId.grojib,
        x: 448,
        chancePercent: 15,
        salt: 0x0E,
      ),
    ],
  ),
  ChunkPattern(
    name: 'tight-platforms',
    platforms: <PlatformRel>[
      PlatformRel(x: 32, width: 96, aboveGroundTop: 80, thickness: _t),
      PlatformRel(x: 160, width: 96, aboveGroundTop: 96, thickness: _t),
      PlatformRel(x: 288, width: 96, aboveGroundTop: 80, thickness: _t),
    ],
    obstacles: <ObstacleRel>[ObstacleRel(x: 448, width: 48, height: 64)],
    groundGaps: <GapRel>[GapRel(x: 112, width: 128)],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
        enemyId: EnemyId.unocoDemon,
        x: 240,
        chancePercent: 15,
        salt: 0x0F,
      ),
      SpawnMarker(
        enemyId: EnemyId.grojib,
        x: 480,
        chancePercent: 12,
        salt: 0x10,
      ),
    ],
  ),

  // ── Ground gaps ──
  ChunkPattern(
    name: 'ground-gap-small',
    groundGaps: <GapRel>[GapRel(x: 256, width: 64)],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
        enemyId: EnemyId.grojib,
        x: 160,
        chancePercent: 12,
        salt: 0x21,
      ),
      SpawnMarker(
        enemyId: EnemyId.unocoDemon,
        x: 416,
        chancePercent: 12,
        salt: 0x22,
      ),
    ],
  ),
  ChunkPattern(
    name: 'ground-gap-wide',
    groundGaps: <GapRel>[GapRel(x: 224, width: 128)],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
        enemyId: EnemyId.unocoDemon,
        x: 96,
        chancePercent: 12,
        salt: 0x23,
      ),
      SpawnMarker(
        enemyId: EnemyId.grojib,
        x: 480,
        chancePercent: 12,
        salt: 0x24,
      ),
    ],
  ),
];


===== FILE: lib/core/track/track_streamer.dart =====
/// Infinite-runner track streaming system.
///
/// Procedurally generates level geometry (platforms, obstacles, ground gaps)
/// and enemy spawn points by selecting from a pool of pre-authored chunk
/// patterns. Uses deterministic RNG so runs are reproducible given the same
/// seed.
library;

import '../collision/static_world_geometry.dart';
import '../enemies/enemy_id.dart';
import '../tuning/track_tuning.dart';
import '../util/deterministic_rng.dart' show mix32;
import 'chunk_builder.dart';
import 'chunk_pattern.dart';
import 'chunk_pattern_pool.dart';

/// Callback to spawn an enemy at a world X position.
typedef SpawnEnemy = void Function(EnemyId enemyId, double x);

/// Metadata for a newly spawned chunk, returned by [TrackStreamer.step].
class TrackSpawnedChunk {
  const TrackSpawnedChunk({
    required this.index,
    required this.startX,
  });

  /// Sequential chunk number (0 = first chunk).
  final int index;

  /// World X coordinate where this chunk begins.
  final double startX;
}

/// Result of a single [TrackStreamer.step] call.
class TrackStreamStepResult {
  const TrackStreamStepResult({
    required this.changed,
    required this.spawnedChunks,
  });

  /// True if geometry lists were rebuilt (chunk spawned or culled).
  final bool changed;

  /// Chunks created this step (empty on steady-state frames).
  final List<TrackSpawnedChunk> spawnedChunks;
}

/// Streams procedural track chunks based on camera position.
///
/// Call [step] each frame with the current camera bounds. The streamer:
/// 1. Spawns new chunks ahead of the camera (within [TrackTuning.spawnAheadMargin]).
/// 2. Culls old chunks behind the camera (beyond [TrackTuning.cullBehindMargin]).
/// 3. Rebuilds [dynamicSolids], [dynamicGroundSegments], [dynamicGroundGaps].
///
/// Pattern selection is deterministic given [seed] and chunk index.
class TrackStreamer {
  /// Creates a streamer seeded for deterministic generation.
  TrackStreamer({
    required this.seed,
    required this.tuning,
    required this.groundTopY,
    required this.patterns,
    required this.earlyPatternChunks,
    required this.noEnemyChunks,
  }) : _nextChunkIndex = 0,
       _nextChunkStartX = 0.0;

  /// RNG seed for pattern selection and spawn rolls.
  final int seed;

  /// Tuning parameters (chunk width, margins, grid snap).
  final TrackTuning tuning;

  /// World Y of the ground surface (platforms offset from this).
  final double groundTopY;

  /// Pattern pools for early vs full difficulty.
  final ChunkPatternPool patterns;

  /// Number of early chunks that use [patterns.easyPatterns].
  final int earlyPatternChunks;

  /// Number of early chunks that suppress enemy spawns.
  final int noEnemyChunks;

  int _nextChunkIndex;
  double _nextChunkStartX;

  final List<_ActiveChunk> _active = <_ActiveChunk>[];
  List<StaticSolid> _dynamicSolids = const <StaticSolid>[];
  List<StaticGroundSegment> _dynamicGroundSegments =
      const <StaticGroundSegment>[];
  List<StaticGroundGap> _dynamicGroundGaps = const <StaticGroundGap>[];

  /// Current streamed solids (excluding any caller-provided base solids).
  List<StaticSolid> get dynamicSolids => _dynamicSolids;

  /// Current streamed ground segments (excluding any base segments).
  List<StaticGroundSegment> get dynamicGroundSegments => _dynamicGroundSegments;

  /// Current streamed ground gaps (excluding any base gaps).
  List<StaticGroundGap> get dynamicGroundGaps => _dynamicGroundGaps;

  /// Advances chunk streaming based on the current camera bounds.
  ///
  /// Returns a step result (spawned chunks + whether geometry changed).
  TrackStreamStepResult step({
    required double cameraLeft,
    required double cameraRight,
    required SpawnEnemy spawnEnemy,
  }) {
    // Streaming disabled – return no-op.
    if (!tuning.enabled) {
      return const TrackStreamStepResult(
        changed: false,
        spawnedChunks: <TrackSpawnedChunk>[],
      );
    }

    var changed = false;
    final spawnedChunks = <TrackSpawnedChunk>[];

    // ── Spawn new chunks ahead of the camera ──
    final spawnLimitX = cameraRight + tuning.spawnAheadMargin;
    while (_nextChunkStartX <= spawnLimitX) {
      final chunkIndex = _nextChunkIndex;
      final startX = _nextChunkStartX;
      final endX = startX + tuning.chunkWidth;

      // Select pattern deterministically from seed + index.
      final pattern = _patternFor(seed, chunkIndex);

      // Build geometry from pattern.
      final solids = buildSolids(
        pattern,
        chunkStartX: startX,
        chunkIndex: chunkIndex,
        groundTopY: groundTopY,
        chunkWidth: tuning.chunkWidth,
        gridSnap: tuning.gridSnap,
      );
      final ground = buildGroundSegments(
        pattern,
        chunkStartX: startX,
        chunkIndex: chunkIndex,
        groundTopY: groundTopY,
        chunkWidth: tuning.chunkWidth,
        gridSnap: tuning.gridSnap,
      );

      // Track active chunk.
      _active.add(
        _ActiveChunk(
          index: chunkIndex,
          startX: startX,
          endX: endX,
          solids: solids,
          groundSegments: ground.segments,
          groundGaps: ground.gaps,
        ),
      );
      spawnedChunks.add(
        TrackSpawnedChunk(index: chunkIndex, startX: startX),
      );

      // Roll for enemy spawns.
      _spawnEnemiesForChunk(
        pattern,
        chunkIndex,
        chunkStartX: startX,
        spawnEnemy: spawnEnemy,
      );

      _nextChunkIndex += 1;
      _nextChunkStartX += tuning.chunkWidth;
      changed = true;
    }

    // ── Cull old chunks behind the camera ──
    final cullLimitX = cameraLeft - tuning.cullBehindMargin;
    while (_active.isNotEmpty && _active.first.endX < cullLimitX) {
      _active.removeAt(0); // O(n) but chunk count is small (~3-5).
      changed = true;
    }

    // ── Rebuild flattened geometry lists if anything changed ──
    if (changed) {
      final rebuilt = <StaticSolid>[];
      final rebuiltGroundSegments = <StaticGroundSegment>[];
      final rebuiltGroundGaps = <StaticGroundGap>[];
      for (final c in _active) {
        rebuilt.addAll(c.solids);
        rebuiltGroundSegments.addAll(c.groundSegments);
        rebuiltGroundGaps.addAll(c.groundGaps);
      }
      _dynamicSolids = List<StaticSolid>.unmodifiable(rebuilt);
      _dynamicGroundSegments =
          List<StaticGroundSegment>.unmodifiable(rebuiltGroundSegments);
      _dynamicGroundGaps =
          List<StaticGroundGap>.unmodifiable(rebuiltGroundGaps);
    }

    return TrackStreamStepResult(
      changed: changed,
      spawnedChunks: List<TrackSpawnedChunk>.unmodifiable(spawnedChunks),
    );
  }

  /// Rolls for enemy spawns defined in [pattern].
  ///
  /// Uses deterministic RNG keyed by seed, chunk index, and marker salt.
  void _spawnEnemiesForChunk(
    ChunkPattern pattern,
    int chunkIndex, {
    required double chunkStartX,
    required SpawnEnemy spawnEnemy,
  }) {
    // Early-game safety: keep first few chunks enemy-free.
    if (chunkIndex < noEnemyChunks) return;

    for (var i = 0; i < pattern.spawnMarkers.length; i += 1) {
      final m = pattern.spawnMarkers[i];

      // Deterministic roll: hash(seed, chunkIndex, markerIndex, salt).
      final roll = mix32(
        seed ^ (chunkIndex * 0x9e3779b9) ^ (i * 0x85ebca6b) ^ m.salt,
      );
      if ((roll % 100) >= m.chancePercent) continue;

      final x = chunkStartX + m.x;
      spawnEnemy(m.enemyId, x);
    }
  }

  /// Selects a chunk pattern deterministically from [seed] and [chunkIndex].
  ///
  /// Early chunks draw from [patterns.easyPatterns]; later chunks use full pool.
  ChunkPattern _patternFor(int seed, int chunkIndex) {
    final isEarly = chunkIndex < earlyPatternChunks;
    final pool = isEarly ? patterns.easyPatterns : patterns.allPatterns;
    // MurmurHash-style mix for uniform distribution.
    final h = mix32(seed ^ (chunkIndex * 0x9e3779b9) ^ 0x27d4eb2d);
    final idx = h % pool.length;
    return pool[idx];
  }
}

/// Tracks a spawned chunk's geometry while it's within camera culling bounds.
class _ActiveChunk {
  const _ActiveChunk({
    required this.index,
    required this.startX,
    required this.endX,
    required this.solids,
    required this.groundSegments,
    required this.groundGaps,
  });

  /// Sequential chunk number.
  final int index;

  /// World X where chunk begins.
  final double startX;

  /// World X where chunk ends (startX + chunkWidth).
  final double endX;

  /// Platforms and obstacles in this chunk.
  final List<StaticSolid> solids;

  /// Walkable ground spans.
  final List<StaticGroundSegment> groundSegments;

  /// Holes in the ground.
  final List<StaticGroundGap> groundGaps;
}


===== FILE: lib/core/track_manager.dart =====
/// Track streaming and geometry lifecycle management.
///
/// This module handles the procedural generation of track chunks as the
/// player progresses, maintaining both collision geometry and navigation
/// data for enemy AI.
///
/// ## Architecture
///
/// [TrackManager] is owned by [GameCore] and orchestrates:
/// - **Track streaming**: [TrackStreamer] spawns/culls chunks based on camera.
/// - **Collision geometry**: Merges base geometry with streamed chunks.
/// - **Surface graph**: Rebuilds navigation data when geometry changes.
/// - **Item spawning**: Delegates to [SpawnService] for new chunks.
///
/// ## Geometry Lifecycle
///
/// ```
/// Camera moves right
///        ↓
/// TrackStreamer.step() detects chunk spawn/cull needed
///        ↓
/// TrackManager merges base + dynamic geometry
///        ↓
/// StaticWorldGeometryIndex rebuilt (collision)
///        ↓
/// SurfaceGraphBuilder.build() (navigation)
///        ↓
/// SpawnService + enemy navigation systems receive new graphs
/// ```
///
/// ## Chunk Spawning Flow
///
/// When a new chunk enters the horizon:
/// 1. [TrackStreamer] generates platforms and enemy spawn points.
/// 2. [TrackManager] merges the new solids into collision geometry.
/// 3. Collectibles and restoration items are placed via [SpawnService].
/// 4. Surface graph is rebuilt so enemies can navigate new platforms.
library;

import 'collision/static_world_geometry_index.dart';
import 'ecs/stores/restoration_item_store.dart' show RestorationStat;
import 'ecs/systems/ground_enemy_locomotion_system.dart';
import 'ecs/systems/enemy_navigation_system.dart';
import 'enemies/enemy_id.dart';
import 'navigation/surface_graph_builder.dart';
import 'navigation/utils/jump_template.dart';
import 'snapshots/static_ground_gap_snapshot.dart';
import 'snapshots/static_solid_snapshot.dart';
import 'spawn_service.dart' hide StaticSolid;
import 'track/chunk_pattern_pool.dart';
import 'track/track_streamer.dart';
import 'tuning/collectible_tuning.dart';
import 'tuning/restoration_item_tuning.dart';
import 'tuning/track_tuning.dart';

// ─────────────────────────────────────────────────────────────────────────────
// Types
// ─────────────────────────────────────────────────────────────────────────────

/// Callback invoked when a chunk's enemy spawn point enters the horizon.
///
/// - [enemyId]: The type of enemy to spawn (ground or flying).
/// - [x]: The world X coordinate for the spawn.
typedef SpawnEnemyCallback = void Function(EnemyId enemyId, double x);

/// Result of a single [TrackManager.step] call.
///
/// Used by [GameCore] to decide whether to update render snapshots.
class TrackStepResult {
  const TrackStepResult({required this.geometryChanged});

  /// Whether static geometry was updated this step.
  ///
  /// When true, collision indices, surface graphs, and render snapshots
  /// have all been regenerated.
  final bool geometryChanged;
}

// ─────────────────────────────────────────────────────────────────────────────
// TrackManager
// ─────────────────────────────────────────────────────────────────────────────

/// Manages track streaming, collision geometry, and navigation graph updates.
///
/// Responsibilities:
/// - Steps [TrackStreamer] each tick to spawn/cull chunks.
/// - Merges base level geometry with dynamically streamed platforms.
/// - Rebuilds [StaticWorldGeometryIndex] for collision detection.
/// - Rebuilds [SurfaceGraph] for enemy pathfinding.
/// - Triggers collectible/item spawning for new chunks.
///
/// Usage:
/// ```dart
/// final manager = TrackManager(seed: 42, ...);
/// final result = manager.step(
///   cameraLeft: cam.left,
///   cameraRight: cam.right,
///   spawnEnemy: (id, x) => spawner.spawn(id, x),
///   lowestResourceStat: () => player.lowestStat,
/// );
/// if (result.geometryChanged) {
///   // Update render snapshots
/// }
/// ```
class TrackManager {
  /// Creates a track manager with the given dependencies.
  ///
  /// - [seed]: Master RNG seed for deterministic chunk generation.
  /// - [trackTuning]: Chunk dimensions, spawn horizons, platform density.
  /// - [collectibleTuning]: Collectible spawn parameters.
  /// - [restorationItemTuning]: Restoration item spawn parameters.
  /// - [baseGeometry]: Static level geometry (ground plane, initial platforms).
  /// - [surfaceGraphBuilder]: Builder for navigation surface graphs.
  /// - [jumpTemplate]: Precomputed jump reachability for pathfinding.
  /// - [enemyNavigationSystem]: Ground enemy navigation (receives graph updates).
  /// - [groundEnemyLocomotionSystem]: Ground locomotion (receives graph updates).
  /// - [spawnService]: Entity spawner (receives surface graph updates).
  /// - [groundTopY]: Y coordinate of the ground surface (for spawning).
  /// - [patternPool]: Chunk pattern pools for procedural generation.
  /// - [earlyPatternChunks]: Number of early chunks using easy patterns.
  /// - [noEnemyChunks]: Number of early chunks that suppress enemy spawns.
  TrackManager({
    required int seed,
    required TrackTuning trackTuning,
    required CollectibleTuning collectibleTuning,
    required RestorationItemTuning restorationItemTuning,
    required StaticWorldGeometry baseGeometry,
    required SurfaceGraphBuilder surfaceGraphBuilder,
    required JumpReachabilityTemplate jumpTemplate,
    required EnemyNavigationSystem enemyNavigationSystem,
    required GroundEnemyLocomotionSystem groundEnemyLocomotionSystem,
    required SpawnService spawnService,
    required double groundTopY,
    required ChunkPatternPool patternPool,
    int earlyPatternChunks = defaultEarlyPatternChunks,
    int noEnemyChunks = defaultNoEnemyChunks,
  }) : _trackTuning = trackTuning,
        _collectibleTuning = collectibleTuning,
        _restorationItemTuning = restorationItemTuning,
        _baseGeometry = baseGeometry,
        _surfaceGraphBuilder = surfaceGraphBuilder,
        _jumpTemplate = jumpTemplate,
        _enemyNavigationSystem = enemyNavigationSystem,
        _groundEnemyLocomotionSystem = groundEnemyLocomotionSystem,
        _spawnService = spawnService,
        _patternPool = patternPool,
        _earlyPatternChunks = earlyPatternChunks,
        _noEnemyChunks = noEnemyChunks {
    // Initialize geometry state from base level.
    _staticGeometry = baseGeometry;
    _staticIndex = StaticWorldGeometryIndex.from(baseGeometry);
    _staticSolidsSnapshot = _buildStaticSolidsSnapshot(baseGeometry);
    _staticGroundGapsSnapshot = _buildGroundGapsSnapshot(baseGeometry);

    // Create track streamer if procedural generation is enabled.
    if (_trackTuning.enabled) {
      _trackStreamer = TrackStreamer(
        seed: seed,
        tuning: _trackTuning,
        groundTopY: groundTopY,
        patterns: _patternPool,
        earlyPatternChunks: _earlyPatternChunks,
        noEnemyChunks: _noEnemyChunks,
      );
    }

    // Build initial surface graph for enemy navigation.
    _rebuildSurfaceGraph();
  }

  // ─── Dependencies ───
  final TrackTuning _trackTuning;
  final CollectibleTuning _collectibleTuning;
  final RestorationItemTuning _restorationItemTuning;
  final StaticWorldGeometry _baseGeometry;
  final SurfaceGraphBuilder _surfaceGraphBuilder;
  final JumpReachabilityTemplate _jumpTemplate;
  final EnemyNavigationSystem _enemyNavigationSystem;
  final GroundEnemyLocomotionSystem _groundEnemyLocomotionSystem;
  final SpawnService _spawnService;
  final ChunkPatternPool _patternPool;
  final int _earlyPatternChunks;
  final int _noEnemyChunks;

  // ─── Runtime State ───

  /// The track streamer (null if procedural generation is disabled).
  TrackStreamer? _trackStreamer;

  /// Version counter for surface graph rebuilds (for cache invalidation).
  int _surfaceGraphVersion = 0;

  /// Current merged geometry (base + streamed chunks).
  late StaticWorldGeometry _staticGeometry;

  /// Spatial index for broadphase collision queries.
  late StaticWorldGeometryIndex _staticIndex;

  /// Immutable snapshot of solids for the render layer.
  late List<StaticSolidSnapshot> _staticSolidsSnapshot;

  /// Immutable snapshot of ground gaps for the render layer.
  late List<StaticGroundGapSnapshot> _staticGroundGapsSnapshot;

  // ───────────────────────────────────────────────────────────────────────────
  // Public API
  // ───────────────────────────────────────────────────────────────────────────

  /// Current static world geometry (base + streamed chunks).
  ///
  /// Used by physics systems for collision resolution.
  StaticWorldGeometry get staticGeometry => _staticGeometry;

  /// Spatial index for efficient collision queries.
  ///
  /// Rebuilt whenever geometry changes.
  StaticWorldGeometryIndex get staticIndex => _staticIndex;

  /// Immutable snapshot of static solids for rendering.
  ///
  /// Contains platform AABBs, side masks, and one-way flags.
  List<StaticSolidSnapshot> get staticSolidsSnapshot => _staticSolidsSnapshot;

  /// Immutable snapshot of ground gaps for rendering.
  ///
  /// Used to draw pit hazard indicators.
  List<StaticGroundGapSnapshot> get staticGroundGapsSnapshot =>
      _staticGroundGapsSnapshot;

  /// Advances the track streamer and updates geometry if needed.
  ///
  /// This method should be called once per tick with the current camera
  /// bounds. It handles:
  /// 1. Chunk spawning/culling based on camera position.
  /// 2. Geometry merging and index rebuilding.
  /// 3. Surface graph updates for enemy AI.
  /// 4. Collectible and restoration item spawning.
  ///
  /// Parameters:
  /// - [cameraLeft], [cameraRight]: Camera X bounds for horizon calculation.
  /// - [spawnEnemy]: Callback invoked for each enemy spawn point in new chunks.
  /// - [lowestResourceStat]: Returns player's lowest resource for item type selection.
  ///
  /// Returns a [TrackStepResult] indicating whether geometry changed.
  TrackStepResult step({
    required double cameraLeft,
    required double cameraRight,
    required SpawnEnemyCallback spawnEnemy,
    required RestorationStat Function() lowestResourceStat,
  }) {
    final streamer = _trackStreamer;
    if (streamer == null) {
      // Procedural generation disabled—geometry never changes.
      return const TrackStepResult(geometryChanged: false);
    }

    // Step the streamer to spawn/cull chunks based on camera position.
    final result = streamer.step(
      cameraLeft: cameraLeft,
      cameraRight: cameraRight,
      spawnEnemy: spawnEnemy,
    );

    if (!result.changed) {
      // No chunks spawned or culled—nothing to update.
      return const TrackStepResult(geometryChanged: false);
    }

    // ─── Merge base geometry with streamed chunks ───
    final combinedSolids = <StaticSolid>[
      ..._baseGeometry.solids,
      ...streamer.dynamicSolids,
    ];
    final combinedSegments = <StaticGroundSegment>[
      ..._baseGeometry.groundSegments,
      ...streamer.dynamicGroundSegments,
    ];
    final combinedGaps = <StaticGroundGap>[
      ..._baseGeometry.groundGaps,
      ...streamer.dynamicGroundGaps,
    ];

    // Apply the new combined geometry (rebuilds index, snapshots, nav graph).
    _setStaticGeometry(
      StaticWorldGeometry(
        groundPlane: _baseGeometry.groundPlane,
        groundSegments: List<StaticGroundSegment>.unmodifiable(
          combinedSegments,
        ),
        solids: List<StaticSolid>.unmodifiable(combinedSolids),
        groundGaps: List<StaticGroundGap>.unmodifiable(combinedGaps),
      ),
    );

    // ─── Spawn items for newly created chunks ───
    if (result.spawnedChunks.isNotEmpty) {
      // Convert geometry to spawn-friendly format (avoids import cycles).
      final solidsForSpawn = _staticGeometry.solids
          .map((s) => (minX: s.minX, maxX: s.maxX, minY: s.minY, maxY: s.maxY))
          .toList();

      for (final chunk in result.spawnedChunks) {
        // Spawn collectibles if enabled.
        if (_collectibleTuning.enabled) {
          _spawnService.spawnCollectiblesForChunk(
            chunkIndex: chunk.index,
            chunkStartX: chunk.startX,
            solids: solidsForSpawn,
          );
        }

        // Spawn restoration items if enabled.
        if (_restorationItemTuning.enabled) {
          _spawnService.spawnRestorationItemForChunk(
            chunkIndex: chunk.index,
            chunkStartX: chunk.startX,
            solids: solidsForSpawn,
            lowestResourceStat: lowestResourceStat,
          );
        }
      }
    }

    return const TrackStepResult(geometryChanged: true);
  }

  // ───────────────────────────────────────────────────────────────────────────
  // Private Helpers
  // ───────────────────────────────────────────────────────────────────────────

  /// Applies new static geometry, rebuilding all derived data structures.
  ///
  /// This is the single point of geometry mutation. It ensures that the
  /// collision index, render snapshots, and navigation graph stay in sync.
  void _setStaticGeometry(StaticWorldGeometry geometry) {
    _staticGeometry = geometry;
    _staticIndex = StaticWorldGeometryIndex.from(geometry);
    _staticSolidsSnapshot = _buildStaticSolidsSnapshot(geometry);
    _staticGroundGapsSnapshot = _buildGroundGapsSnapshot(geometry);
    _rebuildSurfaceGraph();
  }

  /// Rebuilds the navigation surface graph and distributes it to consumers.
  ///
  /// The surface graph is used by:
  /// - [SpawnService]: To place items "on top of" platforms.
  /// - [EnemyNavigationSystem]: To compute jump/walk paths to the player.
  /// - [GroundEnemyLocomotionSystem]: To snap jump velocity on active edges.
  ///
  /// A version counter is incremented each rebuild so consumers can
  /// invalidate cached paths.
  void _rebuildSurfaceGraph() {
    _surfaceGraphVersion += 1;
    final result = _surfaceGraphBuilder.build(
      geometry: _staticGeometry,
      jumpTemplate: _jumpTemplate,
    );

    // Distribute new graph to spawn service.
    _spawnService.setSurfaceGraph(
      graph: result.graph,
      spatialIndex: result.spatialIndex,
    );

    // Distribute new graph to enemy AI system.
    _enemyNavigationSystem.setSurfaceGraph(
      graph: result.graph,
      spatialIndex: result.spatialIndex,
      graphVersion: _surfaceGraphVersion,
    );
    _groundEnemyLocomotionSystem.setSurfaceGraph(graph: result.graph);
  }

  /// Builds an immutable list of [StaticSolidSnapshot] from geometry.
  ///
  /// Converts internal collision representation to render-friendly format.
  static List<StaticSolidSnapshot> _buildStaticSolidsSnapshot(
    StaticWorldGeometry geometry,
  ) {
    return List<StaticSolidSnapshot>.unmodifiable(
      geometry.solids.map(
        (s) => StaticSolidSnapshot(
          minX: s.minX,
          minY: s.minY,
          maxX: s.maxX,
          maxY: s.maxY,
          sides: s.sides,
          oneWayTop: s.oneWayTop,
        ),
      ),
    );
  }

  /// Builds an immutable list of [StaticGroundGapSnapshot] from geometry.
  ///
  /// Returns an empty const list if no gaps exist (avoids allocation).
  static List<StaticGroundGapSnapshot> _buildGroundGapsSnapshot(
    StaticWorldGeometry geometry,
  ) {
    if (geometry.groundGaps.isEmpty) {
      return const <StaticGroundGapSnapshot>[];
    }
    return List<StaticGroundGapSnapshot>.unmodifiable(
      geometry.groundGaps.map(
        (g) => StaticGroundGapSnapshot(minX: g.minX, maxX: g.maxX),
      ),
    );
  }
}


===== FILE: lib/core/tuning/camera_tuning.dart =====
/// Camera auto-scroll and follow tuning.
library;

import 'dart:math';

import '../players/player_tuning.dart';

class CameraTuning {
  const CameraTuning({
    this.speedLagMulX = 0.0,
    this.accelX = 1200.0,
    this.followThresholdRatio = 0.5,
    this.catchupLerp = 8.0,
    this.targetCatchupLerp = 2.5,
  });

  /// Baseline auto-scroll lags behind `MovementTuning.maxSpeedX` by this multiplier.
  final double speedLagMulX;

  /// Acceleration used to ease camera speed toward its target speed.
  final double accelX;

  /// Threshold ratio (from left edge) after which the player can pull the camera forward.
  final double followThresholdRatio;

  /// Smoothing for camera center toward its target (per-second).
  final double catchupLerp;

  /// Smoothing for camera target toward player (per-second).
  final double targetCatchupLerp;
}

class CameraTuningDerived {
  const CameraTuningDerived({
    required this.targetSpeedX,
    required this.accelX,
    required this.followThresholdRatio,
    required this.catchupLerp,
    required this.targetCatchupLerp,
  });

  factory CameraTuningDerived.from(
    CameraTuning tuning, {
    required MovementTuningDerived movement,
  }) {
    final targetSpeedX = max(0.0, movement.base.maxSpeedX * tuning.speedLagMulX);
    return CameraTuningDerived(
      targetSpeedX: targetSpeedX,
      accelX: tuning.accelX,
      followThresholdRatio: tuning.followThresholdRatio,
      catchupLerp: tuning.catchupLerp,
      targetCatchupLerp: tuning.targetCatchupLerp,
    );
  }

  final double targetSpeedX;
  final double accelX;
  final double followThresholdRatio;
  final double catchupLerp;
  final double targetCatchupLerp;
}


===== FILE: lib/core/tuning/collectible_tuning.dart =====
/// Collectible spawning and value configuration.
class CollectibleTuning {
  const CollectibleTuning({
    this.enabled = true,
    this.minPerChunk = 1,
    this.maxPerChunk = 2,
    this.spawnStartChunkIndex = 2,
    this.collectibleSize = 16.0,
    this.surfaceClearanceY = 10.0,
    this.noSpawnMargin = 2.0,
    this.minSpacingX = 80.0,
    this.chunkEdgeMarginX = 32.0,
    this.maxAttemptsPerChunk = 40,
    this.despawnBehindCameraMargin = 900.0,
    this.valuePerCollectible = 50,
  }) : assert(maxPerChunk >= minPerChunk);

  /// Master toggle for collectible spawning.
  final bool enabled;

  /// Min collectibles spawned per chunk.
  final int minPerChunk;

  /// Max collectibles spawned per chunk.
  final int maxPerChunk;

  /// First chunk index where collectibles can spawn.
  final int spawnStartChunkIndex;

  /// Collision/render size (world units).
  final double collectibleSize;

  /// Vertical clearance above surface (world units).
  final double surfaceClearanceY;

  /// Margin from surface edges to avoid clipping (world units).
  final double noSpawnMargin;

  /// Minimum horizontal spacing between collectibles (world units).
  final double minSpacingX;

  /// Margin from chunk edges (world units).
  final double chunkEdgeMarginX;

  /// Max placement attempts before giving up.
  final int maxAttemptsPerChunk;

  /// Distance behind camera before despawn (world units).
  final double despawnBehindCameraMargin;

  /// Score value per collectible.
  final int valuePerCollectible;
}


===== FILE: lib/core/tuning/core_tuning.dart =====
/// Aggregate tuning configuration for the game simulation core.
///
/// This class bundles all tuning parameters into a single object, simplifying
/// the [GameCore] constructor API. All fields have sensible defaults, so you
/// only need to override what you want to customize.
///
/// ## Usage
///
/// ```dart
/// // Default configuration:
/// final core = GameCore(seed: 42);
///
/// // Custom configuration:
/// final core = GameCore(
///   seed: 42,
///   tuning: CoreTuning(
///     track: TrackTuning(enabled: false),
///   ),
/// );
/// ```
///
/// ## Testing
///
/// For unit tests, create a custom [CoreTuning] with specific overrides:
/// ```dart
/// final testTuning = CoreTuning(
///   track: TrackTuning(enabled: false),  // Disable procedural gen
///   physics: PhysicsTuning(gravityY: 0), // Zero gravity
/// );
/// final core = GameCore(seed: 123, tuning: testTuning);
/// ```
library;

import 'camera_tuning.dart';
import 'collectible_tuning.dart';
import 'flying_enemy_tuning.dart';
import 'ground_enemy_tuning.dart';
import 'navigation_tuning.dart';
import 'physics_tuning.dart';
import 'restoration_item_tuning.dart';
import 'score_tuning.dart';
import 'spatial_grid_tuning.dart';
import 'track_tuning.dart';

/// Aggregate container for all game simulation tuning parameters.
///
/// Provides a cleaner API than passing 15+ individual tuning objects to
/// [GameCore]. All fields default to their respective tuning class defaults.
class CoreTuning {
  /// Creates a core tuning configuration with optional overrides.
  ///
  /// Any parameter not specified uses its default value.
  const CoreTuning({
    this.physics = const PhysicsTuning(),
    this.unocoDemon = const UnocoDemonTuning(),
    this.groundEnemy = const GroundEnemyTuning(),
    this.navigation = const NavigationTuning(),
    this.spatialGrid = const SpatialGridTuning(),
    this.camera = const CameraTuning(),
    this.track = const TrackTuning(),
    this.collectible = const CollectibleTuning(),
    this.restorationItem = const RestorationItemTuning(),
    this.score = const ScoreTuning(),
  });

  /// Physics constants (gravity, etc.).
  final PhysicsTuning physics;

  /// Flying enemy AI and spawn parameters.
  final UnocoDemonTuning unocoDemon;

  /// Ground enemy AI and movement parameters.
  final GroundEnemyTuning groundEnemy;

  /// Pathfinding and navigation parameters.
  final NavigationTuning navigation;

  /// Spatial partitioning grid settings.
  final SpatialGridTuning spatialGrid;

  /// Camera behavior (autoscroll, smoothing).
  final CameraTuning camera;

  /// Track streaming and chunk generation.
  final TrackTuning track;

  /// Collectible spawn density and placement.
  final CollectibleTuning collectible;

  /// Restoration item spawn frequency and sizing.
  final RestorationItemTuning restorationItem;

  /// Score calculation parameters.
  final ScoreTuning score;
}


===== FILE: lib/core/tuning/flying_enemy_tuning.dart =====
/// Flying enemy AI tuning (steering, strikes).
library;

import '../util/tick_math.dart';

class UnocoDemonTuning {
  const UnocoDemonTuning({
    this.unocoDemonHoverOffsetY = 150.0,
    this.unocoDemonDesiredRangeMin = 50.0,
    this.unocoDemonDesiredRangeMax = 90.0,
    this.unocoDemonDesiredRangeHoldMinSeconds = 0.60,
    this.unocoDemonDesiredRangeHoldMaxSeconds = 1.40,
    this.unocoDemonHoldSlack = 20.0,
    this.unocoDemonMaxSpeedX = 300.0,
    this.unocoDemonSlowRadiusX = 80.0,
    this.unocoDemonAccelX = 600.0,
    this.unocoDemonDecelX = 400.0,
    this.unocoDemonMinHeightAboveGround = 100.0,
    this.unocoDemonMaxHeightAboveGround = 240.0,
    this.unocoDemonFlightTargetHoldMinSeconds = 1.5,
    this.unocoDemonFlightTargetHoldMaxSeconds = 3.0,
    this.unocoDemonMaxSpeedY = 300.0,
    this.unocoDemonVerticalKp = 4.0,
    this.unocoDemonVerticalDeadzone = 20.0,
    this.unocoDemonAimLeadMinSeconds = 0.08,
    this.unocoDemonAimLeadMaxSeconds = 0.40,
    this.unocoDemonCastCooldownSeconds = 2.0,
    this.unocoDemonCastOriginOffset = 20.0,
  });

  // ── Steering ──

  /// Vertical offset above player when hovering (world units).
  final double unocoDemonHoverOffsetY;

  /// Min horizontal range to maintain from player (world units).
  final double unocoDemonDesiredRangeMin;

  /// Max horizontal range to maintain from player (world units).
  final double unocoDemonDesiredRangeMax;

  /// Min time to hold a desired range before picking new (seconds).
  final double unocoDemonDesiredRangeHoldMinSeconds;

  /// Max time to hold a desired range (seconds).
  final double unocoDemonDesiredRangeHoldMaxSeconds;

  /// Slack distance before recalculating position (world units).
  final double unocoDemonHoldSlack;

  /// Max horizontal speed (world units/sec).
  final double unocoDemonMaxSpeedX;

  /// Distance from target where decel starts (world units).
  final double unocoDemonSlowRadiusX;

  /// Horizontal acceleration (world units/sec²).
  final double unocoDemonAccelX;

  /// Horizontal deceleration (world units/sec²).
  final double unocoDemonDecelX;

  /// Min height above ground (world units).
  final double unocoDemonMinHeightAboveGround;

  /// Max height above ground (world units).
  final double unocoDemonMaxHeightAboveGround;

  /// Min time to hold a flight target (seconds).
  final double unocoDemonFlightTargetHoldMinSeconds;

  /// Max time to hold a flight target (seconds).
  final double unocoDemonFlightTargetHoldMaxSeconds;

  /// Max vertical speed (world units/sec).
  final double unocoDemonMaxSpeedY;

  /// Proportional gain for vertical steering.
  final double unocoDemonVerticalKp;

  /// Deadzone for vertical error (world units).
  final double unocoDemonVerticalDeadzone;

  // ── Strikes ──

  /// Min lead time when aiming at player (seconds).
  final double unocoDemonAimLeadMinSeconds;

  /// Max lead time when aiming at player (seconds).
  final double unocoDemonAimLeadMaxSeconds;

  /// Cooldown between casts (seconds).
  final double unocoDemonCastCooldownSeconds;

  /// Projectile spawn offset from center (world units).
  final double unocoDemonCastOriginOffset;
}

class UnocoDemonTuningDerived {
  const UnocoDemonTuningDerived._({
    required this.tickHz,
    required this.base,
    required this.unocoDemonCastCooldownTicks,
  });

  factory UnocoDemonTuningDerived.from(
    UnocoDemonTuning base, {
    required int tickHz,
  }) {
    if (tickHz <= 0) {
      throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
    }

    return UnocoDemonTuningDerived._(
      tickHz: tickHz,
      base: base,
      unocoDemonCastCooldownTicks: ticksFromSecondsCeil(
        base.unocoDemonCastCooldownSeconds,
        tickHz,
      ),
    );
  }

  final int tickHz;
  final UnocoDemonTuning base;

  final int unocoDemonCastCooldownTicks;
}


===== FILE: lib/core/tuning/ground_enemy_tuning.dart =====
/// Ground enemy AI tuning grouped by navigation/engagement/locomotion/combat.
library;

import '../util/tick_math.dart';

class GroundEnemyTuning {
  const GroundEnemyTuning({
    this.navigation = const GroundEnemyNavigationTuning(),
    this.engagement = const GroundEnemyEngagementTuning(),
    this.locomotion = const GroundEnemyLocomotionTuning(),
    this.combat = const GroundEnemyCombatTuning(),
  });

  final GroundEnemyNavigationTuning navigation;
  final GroundEnemyEngagementTuning engagement;
  final GroundEnemyLocomotionTuning locomotion;
  final GroundEnemyCombatTuning combat;
}

/// Navigation tuning (chase offset + speed variance).
class GroundEnemyNavigationTuning {
  const GroundEnemyNavigationTuning({
    this.chaseOffsetMaxX = 18.0,
    this.chaseOffsetMinAbsX = 6.0,
    this.chaseOffsetMeleeX = 3.0,
    this.chaseSpeedScaleMin = 0.92,
    this.chaseSpeedScaleMax = 1.08,
    this.chaseTargetDelayTicks = 6,
  });

  /// Max random chase offset from player (world units).
  final double chaseOffsetMaxX;

  /// Min absolute chase offset (prevents clumping).
  final double chaseOffsetMinAbsX;

  /// Chase offset when in melee range (world units).
  final double chaseOffsetMeleeX;

  /// Min speed scale for chase variance.
  final double chaseSpeedScaleMin;

  /// Max speed scale for chase variance.
  final double chaseSpeedScaleMax;

  /// Fixed reaction delay (in simulation ticks) applied to chase targeting.
  ///
  /// The navigation system will chase the player's (or predicted) target X from
  /// `delayTicks` ago, producing a deterministic "reaction time" feel.
  ///
  /// Example: At 60 Hz, `6` ticks ≈ 100ms.
  final int chaseTargetDelayTicks;
}

/// Engagement tuning (slot selection + melee state movement).
class GroundEnemyEngagementTuning {
  const GroundEnemyEngagementTuning({
    this.meleeEngageBufferX = 4.0,
    this.meleeEngageHysteresisX = 2.0,
    this.meleeArriveSlowRadiusX = 12.0,
    this.meleeStrikeSpeedMul = 0.25,
    this.meleeRecoverSpeedMul = 0.5,
  });

  /// Extra buffer beyond melee range to enter engage state.
  final double meleeEngageBufferX;

  /// Hysteresis added to engage buffer for disengage threshold.
  final double meleeEngageHysteresisX;

  /// Radius within which arrival steering slows to zero.
  final double meleeArriveSlowRadiusX;

  /// Speed multiplier during strike state.
  final double meleeStrikeSpeedMul;

  /// Speed multiplier during recover state.
  final double meleeRecoverSpeedMul;
}

/// Locomotion tuning (movement + jump).
class GroundEnemyLocomotionTuning {
  const GroundEnemyLocomotionTuning({
    this.speedX = 300.0,
    this.stopDistanceX = 6.0,
    this.accelX = 600.0,
    this.decelX = 400.0,
    this.jumpSpeed = 500.0,
  });

  /// Target horizontal speed (world units/sec).
  final double speedX;

  /// Distance at which enemy stops chasing (world units).
  final double stopDistanceX;

  /// Horizontal acceleration (world units/sec^2).
  final double accelX;

  /// Horizontal deceleration (world units/sec^2).
  final double decelX;

  /// Jump velocity (world units/sec, positive = upward).
  final double jumpSpeed;
}

/// Combat tuning (melee timing + damage).
class GroundEnemyCombatTuning {
  const GroundEnemyCombatTuning({
    this.meleeRangeX = 52.0,
    this.meleeCooldownSeconds = 1.0,
    this.meleeActiveSeconds = 0.10,
    this.meleeAnimSeconds = 0.60,
    this.meleeWindupSeconds = 0.18,
    this.meleeDamage = 5.0,
    this.meleeHitboxSizeX = 56.0,
    this.meleeHitboxSizeY = 32.0,
  });

  /// Horizontal range to trigger melee strike (world units).
  final double meleeRangeX;

  /// Cooldown between melee strikes (seconds).
  final double meleeCooldownSeconds;

  /// Duration melee hitbox is active (seconds).
  final double meleeActiveSeconds;

  /// Duration the melee strike animation should be visible (seconds).
  ///
  /// This can be longer than [meleeActiveSeconds] since the hitbox
  /// window is often only a subset of the full animation.
  final double meleeAnimSeconds;

  /// Telegraph window before the melee hitbox becomes active (seconds).
  ///
  /// This delays hitbox spawn relative to the start of the strike animation.
  final double meleeWindupSeconds;

  /// Damage dealt by melee strike.
  final double meleeDamage;

  /// Melee hitbox width (world units).
  final double meleeHitboxSizeX;

  /// Melee hitbox height (world units).
  final double meleeHitboxSizeY;
}

class GroundEnemyTuningDerived {
  const GroundEnemyTuningDerived._({
    required this.tickHz,
    required this.base,
    required this.navigation,
    required this.engagement,
    required this.locomotion,
    required this.combat,
  });

  factory GroundEnemyTuningDerived.from(
    GroundEnemyTuning base, {
    required int tickHz,
  }) {
    if (tickHz <= 0) {
      throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
    }

    final combat = base.combat;
    final engagement = base.engagement;

    final meleeStandOffX = () {
      final desired = combat.meleeHitboxSizeX * (2.0 / 3.0);
      if (desired.isNaN || desired.isInfinite) return 0.0;
      final clampedToRange = desired > combat.meleeRangeX
          ? combat.meleeRangeX
          : desired;
      return clampedToRange < 0.0 ? 0.0 : clampedToRange;
    }();

    return GroundEnemyTuningDerived._(
      tickHz: tickHz,
      base: base,
      navigation: base.navigation,
      engagement: GroundEnemyEngagementTuningDerived(
        meleeEngageBufferX: engagement.meleeEngageBufferX,
        meleeEngageHysteresisX: engagement.meleeEngageHysteresisX,
        meleeArriveSlowRadiusX: engagement.meleeArriveSlowRadiusX,
        meleeStrikeSpeedMul: engagement.meleeStrikeSpeedMul,
        meleeRecoverSpeedMul: engagement.meleeRecoverSpeedMul,
        meleeStandOffX: meleeStandOffX,
      ),
      locomotion: base.locomotion,
      combat: () {
        final meleeCooldownTicks = ticksFromSecondsCeil(
          combat.meleeCooldownSeconds,
          tickHz,
        );
        final meleeActiveTicks = ticksFromSecondsCeil(
          combat.meleeActiveSeconds,
          tickHz,
        );
        final meleeAnimTicks = ticksFromSecondsCeil(
          combat.meleeAnimSeconds,
          tickHz,
        );
        final rawWindupTicks = ticksFromSecondsCeil(
          combat.meleeWindupSeconds,
          tickHz,
        );
        // Ensure the hit tick occurs while the strike animation is still visible.
        final maxWindupTicks = meleeAnimTicks > 0 ? meleeAnimTicks - 1 : 0;
        final meleeWindupTicks =
            rawWindupTicks > maxWindupTicks ? maxWindupTicks : rawWindupTicks;
        return GroundEnemyCombatTuningDerived(
        meleeRangeX: combat.meleeRangeX,
        meleeCooldownSeconds: combat.meleeCooldownSeconds,
        meleeActiveSeconds: combat.meleeActiveSeconds,
        meleeAnimSeconds: combat.meleeAnimSeconds,
        meleeWindupSeconds: combat.meleeWindupSeconds,
        meleeDamage: combat.meleeDamage,
        meleeHitboxSizeX: combat.meleeHitboxSizeX,
        meleeHitboxSizeY: combat.meleeHitboxSizeY,
        meleeCooldownTicks: meleeCooldownTicks,
        meleeActiveTicks: meleeActiveTicks,
        meleeAnimTicks: meleeAnimTicks,
        meleeWindupTicks: meleeWindupTicks,
      );
      }(),
    );
  }

  final int tickHz;
  final GroundEnemyTuning base;
  final GroundEnemyNavigationTuning navigation;
  final GroundEnemyEngagementTuningDerived engagement;
  final GroundEnemyLocomotionTuning locomotion;
  final GroundEnemyCombatTuningDerived combat;
}

class GroundEnemyEngagementTuningDerived extends GroundEnemyEngagementTuning {
  const GroundEnemyEngagementTuningDerived({
    required super.meleeEngageBufferX,
    required super.meleeEngageHysteresisX,
    required super.meleeArriveSlowRadiusX,
    required super.meleeStrikeSpeedMul,
    required super.meleeRecoverSpeedMul,
    required this.meleeStandOffX,
  });

  /// Stand-off target used in engage/strike/recover phases.
  ///
  /// Derived from [GroundEnemyCombatTuning.meleeHitboxSizeX] so the player
  /// sits well within the hitbox when the enemy is at its preferred slot.
  final double meleeStandOffX;
}

class GroundEnemyCombatTuningDerived extends GroundEnemyCombatTuning {
  const GroundEnemyCombatTuningDerived({
    required super.meleeRangeX,
    required super.meleeCooldownSeconds,
    required super.meleeActiveSeconds,
    required super.meleeAnimSeconds,
    required super.meleeWindupSeconds,
    required super.meleeDamage,
    required super.meleeHitboxSizeX,
    required super.meleeHitboxSizeY,
    required this.meleeCooldownTicks,
    required this.meleeActiveTicks,
    required this.meleeAnimTicks,
    required this.meleeWindupTicks,
  });

  final int meleeCooldownTicks;
  final int meleeActiveTicks;
  final int meleeAnimTicks;
  final int meleeWindupTicks;
}


===== FILE: lib/core/tuning/navigation_tuning.dart =====
/// Navigation tuning for surface-graph based AI.
///
/// This is intentionally separate from movement/combat tunings:
/// - movement tuning controls the player's physical feel
/// - enemy tuning controls per-enemy locomotion abilities
/// - navigation tuning controls pathfinding + graph build tradeoffs
library;
import '../navigation/types/nav_tolerances.dart';

class NavigationTuning {
  const NavigationTuning({
    this.repathCooldownTicks = 30,
    this.maxExpandedNodes = 128,
    this.edgePenaltySeconds = 0.05,
    this.surfaceEps = navSpatialEps,
    this.takeoffEpsMin = 2.0,
    this.takeoffSampleMaxStep = 64.0,
  }) : assert(repathCooldownTicks >= 0),
       assert(maxExpandedNodes > 0),
       assert(edgePenaltySeconds >= 0.0),
       assert(surfaceEps > 0.0),
       assert(takeoffEpsMin >= 0.0),
       assert(takeoffSampleMaxStep > 0.0);

  /// Throttle replans per entity to avoid per-tick A* on mobile.
  final int repathCooldownTicks;

  /// Hard cap on A* node expansions (fail fast deterministically).
  final int maxExpandedNodes;

  /// Small per-edge penalty that biases toward fewer hops when costs tie.
  final double edgePenaltySeconds;

  /// Vertical tolerance when locating the current/target surface (world units).
  final double surfaceEps;

  /// Minimum horizontal tolerance for "close enough to takeoff" (world units).
  ///
  /// The actual takeoff epsilon can be increased by the locomotion controller
  /// (e.g. tied to an enemy's stop distance) to avoid "stops too early to jump".
  final double takeoffEpsMin;

  /// Maximum step between takeoff samples on long surfaces (world units).
  final double takeoffSampleMaxStep;
}


===== FILE: lib/core/tuning/physics_tuning.dart =====
/// Global physics tuning for the Core simulation.
///
/// This is intentionally separate from movement/ability/combat tunings so it can
/// evolve into per-level/biome physics profiles later (e.g. low-gravity zones).
class PhysicsTuning {
  const PhysicsTuning({
    this.gravityY = 1200,
  });

  /// Gravity acceleration (positive is downward), in world units / second^2.
  final double gravityY;
}



===== FILE: lib/core/tuning/restoration_item_tuning.dart =====
/// Restoration item spawning and restore configuration.
class RestorationItemTuning {
  const RestorationItemTuning({
    this.enabled = true,
    this.spawnEveryChunks = 16,
    this.spawnStartChunkIndex = 2,
    this.restorePercentBp = 3000,
    this.itemSize = 16.0,
    this.surfaceClearanceY = 10.0,
    this.noSpawnMargin = 2.0,
    this.chunkEdgeMarginX = 32.0,
    this.maxAttemptsPerSpawn = 40,
    this.despawnBehindCameraMargin = 900.0,
  });

  /// Master toggle for restoration item spawning.
  final bool enabled;

  /// Spawn one item every N chunks.
  final int spawnEveryChunks;

  /// First chunk index where items can spawn.
  final int spawnStartChunkIndex;

  /// Fraction of max HP/mana/stamina restored in basis points (100 = 1%).
  final int restorePercentBp;

  /// Collision/render size (world units).
  final double itemSize;

  /// Vertical clearance above surface (world units).
  final double surfaceClearanceY;

  /// Margin from surface edges (world units).
  final double noSpawnMargin;

  /// Margin from chunk edges (world units).
  final double chunkEdgeMarginX;

  /// Max placement attempts before giving up.
  final int maxAttemptsPerSpawn;

  /// Distance behind camera before despawn (world units).
  final double despawnBehindCameraMargin;
}


===== FILE: lib/core/tuning/score_tuning.dart =====
/// Scoring tuning (points per time, distance, kills).
library;

/// World units per meter (used for distance→score conversion).
const int kWorldUnitsPerMeter = 50;

class ScoreTuning {
  const ScoreTuning({
    this.timeScorePerSecond = 5,
    this.distanceScorePerMeter = 5,
    this.groundEnemyKillScore = 100,
    this.unocoDemonKillScore = 150,
  }) : assert(timeScorePerSecond >= 0),
       assert(distanceScorePerMeter >= 0),
       assert(groundEnemyKillScore >= 0),
       assert(unocoDemonKillScore >= 0);

  /// Points per real-time second survived (implemented deterministically via tickHz).
  final int timeScorePerSecond;

  /// Points per whole meter traveled (50 world units = 1 meter).
  final int distanceScorePerMeter;

  /// Points for killing an enemy (by type).
  final int groundEnemyKillScore;
  final int unocoDemonKillScore;
}


===== FILE: lib/core/tuning/spatial_grid_tuning.dart =====
/// Simulation tuning/config for grid-based spatial indexing (broadphase now,
/// navigation later).
///
/// Keep this separate from combat tuning: broadphase is a physics/simulation
/// concern, not a combat rule.
class SpatialGridTuning {
  const SpatialGridTuning({
    this.broadphaseCellSize = 32.0,
  });

  /// Default broadphase cell size for dynamic AABB queries.
  ///
  /// With current collider sizes (player ~16x16, enemies ~24x24), `32.0`
  /// keeps candidate sets small while keeping grid math cheap.
  final double broadphaseCellSize;
}



===== FILE: lib/core/tuning/track_tuning.dart =====
/// Track streaming / deterministic chunk spawning configuration.
///
/// This is simulation config (Core), not combat/ability tuning.
class TrackTuning {
  const TrackTuning({
    this.enabled = true,
    this.chunkWidth = 600.0,
    this.spawnAheadMargin = 600.0,
    this.cullBehindMargin = 600.0,
    this.enemyCullBelowGroundOffsetY = 300.0,
    this.gridSnap = 16.0,
    this.playerStartX = 300.0,
    this.gapKillOffsetY = 400.0,
  }) : assert(chunkWidth > 0),
       assert(spawnAheadMargin >= 0),
       assert(cullBehindMargin >= 0),
       assert(enemyCullBelowGroundOffsetY >= 0),
       assert(gridSnap > 0),
       assert(playerStartX >= 0),
       assert(gapKillOffsetY >= 0);

  /// If false, no chunk streaming is performed (static world only).
  final bool enabled;

  /// Width of a chunk in world units.
  final double chunkWidth;

  /// Spawn chunks while `cameraRight + spawnAheadMargin >= nextChunkStartX`.
  final double spawnAheadMargin;

  /// Cull chunks while `chunkEndX < cameraLeft - cullBehindMargin`.
  final double cullBehindMargin;

  /// Enemies are despawned if their bottom falls this far below groundTopY.
  final double enemyCullBelowGroundOffsetY;

  /// Authoring grid snap for chunk patterns (world units).
  final double gridSnap;

  /// Player spawn X position at run start (world units).
  final double playerStartX;

  /// How far below ground the player must fall before death triggers.
  ///
  /// Set high enough to give visual feedback of falling into the gap
  /// before the death screen appears.
  final double gapKillOffsetY;
}


===== FILE: lib/core/tuning/utils/anim_tuning.dart =====
/// Animation tuning helper utilities (Core-owned, deterministic).
///
/// This module is intentionally generic so it can be reused by player/enemy
/// tuning without taking a dependency on any specific character system.
library;

/// Computes a recommended duration for a strip based on frame count and step time.
double secondsForStrip({
  required int frameCount,
  required double stepTimeSeconds,
}) {
  if (frameCount <= 0 || stepTimeSeconds <= 0) return 0.0;
  return frameCount * stepTimeSeconds;
}

/// Computes strip duration for a specific [key] from tuning maps.
///
/// Works with any key type (enums, ints, strings) to keep it reusable.
double secondsForKey<K>({
  required K key,
  required Map<K, int> frameCounts,
  required Map<K, double> stepTimeSecondsByKey,
  int defaultFrameCount = 1,
  double defaultStepTimeSeconds = 0.10,
}) {
  final frames = frameCounts[key] ?? defaultFrameCount;
  final step = stepTimeSecondsByKey[key] ?? defaultStepTimeSeconds;
  return secondsForStrip(frameCount: frames, stepTimeSeconds: step);
}



===== FILE: lib/core/util/deterministic_rng.dart =====
/// Deterministic random number generation utilities.
///
/// Provides seedable, reproducible pseudo-random numbers for procedural
/// generation. Uses Xorshift32 (fast, small state) with MurmurHash3 mixing
/// for seed avalanche. All functions are pure and tick-deterministic.
library;

/// Bitmask for 32-bit unsigned integer operations.
const int _mask32 = 0xffffffff;

/// Fallback seed when mixing produces zero (Xorshift32 degenerates on zero).
const int _nonZeroSeed = 0x6d2b79f5;

/// MurmurHash3 finalizer-style bit mixer.
///
/// Produces a well-distributed 32-bit hash from any integer input.
/// Used to "avalanche" seed bits before RNG initialization.
int mix32(int x) {
  var v = x & _mask32;
  v ^= (v >> 16);
  v = (v * 0x7feb352d) & _mask32;
  v ^= (v >> 15);
  v = (v * 0x846ca68b) & _mask32;
  v ^= (v >> 16);
  return v & _mask32;
}

/// Derives a non-zero 32-bit RNG state from [seed] and [salt].
///
/// XORs seed with salt, then mixes. Guarantees non-zero output to
/// prevent Xorshift32 from degenerating into a constant sequence.
int seedFrom(int seed, int salt) {
  final mixed = mix32(seed ^ salt);
  return mixed == 0 ? _nonZeroSeed : mixed;
}

/// Advances [state] by one Xorshift32 step, returning the new state.
///
/// The returned value serves as both the next state and the random output.
/// Period: 2³²−1. Passes most statistical tests for game use.
int nextUint32(int state) {
  var x = state & _mask32;
  if (x == 0) x = _nonZeroSeed; // Guard against degenerate zero state.
  x ^= (x << 13) & _mask32;
  x ^= (x >> 17);
  x ^= (x << 5) & _mask32;
  return x & _mask32;
}

/// Converts a 32-bit unsigned [value] to a double in \[0, 1\].
///
/// Uses simple division for uniform distribution. Inclusive on both ends.
double uint32ToUnitDouble(int value) {
  return (value & _mask32) / _mask32;
}

/// Maps a 32-bit unsigned [value] to a double in \[[min], [max]\].
///
/// Automatically swaps [min]/[max] if inverted. Distribution is uniform.
double rangeDouble(int value, double min, double max) {
  final lo = min <= max ? min : max;
  final hi = min <= max ? max : min;
  return lo + (hi - lo) * uint32ToUnitDouble(value);
}


===== FILE: lib/core/util/double_math.dart =====
/// Floating-point math helpers.
///
/// Supplements `dart:math` with common operations not in the standard library.
library;

import 'dart:math';

/// Clamps [v] to the range \[[lo], [hi]\].
///
/// Returns [lo] if `v < lo`, [hi] if `v > hi`, otherwise [v].
double clampDouble(double v, double lo, double hi) => max(lo, min(hi, v));



===== FILE: lib/core/util/fixed_math.dart =====
/// Fixed-point math helpers for deterministic simulation.
///
/// Units:
/// - Fixed100: 100 = 1.00
/// - Basis Points (bp): 100 = 1%, 10000 = 100%
library;

import 'dart:math';

const int fixedScale = 100;
const int bpScale = 10000;

/// Converts a double to fixed-point (100 = 1.0).
int toFixed100(double value) => (value * fixedScale).round();

/// Converts a double to basis points (100 = 1%).
int toBp(double value) => (value * bpScale).round();

/// Converts fixed-point (100 = 1.0) to double.
double fromFixed100(int value) => value / fixedScale;

/// Clamps [v] to the range [lo, hi].
int clampInt(int v, int lo, int hi) => max(lo, min(hi, v));

/// Scales [value] by a basis-point modifier.
///
/// Example: value=1000, bonusBp=2000 (+20%) -> 1200.
int applyBp(int value, int bonusBp) =>
    (value * (bpScale + bonusBp)) ~/ bpScale;



===== FILE: lib/core/util/smoothing.dart =====
/// Smoothing utilities for frame-rate-independent interpolation.
///
/// Provides exponential smoothing factors that behave consistently
/// regardless of tick rate, useful for camera follow, UI animations, etc.
library;

import 'dart:math';

/// Returns an exponential smoothing factor α in \[0, 1\].
///
/// Given responsiveness [k] (1/seconds) and tick duration [dtSeconds],
/// computes `α = 1 − e^(−k·dt)`. Use as: `value += α * (target − value)`.
///
/// Matches the common pattern: `alpha = 1 - exp(-k * dt)`.
double expSmoothingFactor(double k, double dtSeconds) {
  if (k <= 0) return 0.0;
  if (dtSeconds <= 0) return 0.0;
  return 1.0 - exp(-k * dtSeconds);
}



===== FILE: lib/core/util/tick_math.dart =====
/// Tick/time conversion utilities.
///
/// Bridges between author-friendly seconds and simulation tick counts.
library;

import 'dart:math';

/// Converts [seconds] to tick count at [tickHz], rounding up.
///
/// Rules:
/// - `seconds <= 0` => `0` ticks
/// - otherwise `max(1, ceil(seconds * tickHz))`
int ticksFromSecondsCeil(double seconds, int tickHz) {
  if (tickHz <= 0) {
    throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
  }
  if (seconds <= 0) return 0;
  return max(1, (seconds * tickHz).ceil());
}



===== FILE: lib/core/util/vec2.dart =====
/// Minimal 2D vector type for Core ↔ UI data transfer.
///
/// Immutable, allocation-light, pure Dart. Used in snapshots and events.
/// Internal systems prefer raw `double` fields for hot loops.
library;

/// Immutable 2D vector with [x] and [y] coordinates.
class Vec2 {
  /// Creates a new immutable vector at ([x], [y]).
  const Vec2(this.x, this.y);

  /// Zero vector (0, 0).
  static const Vec2 zero = Vec2(0, 0);

  /// X coordinate (Horizontal), usually in world units/pixels.
  final double x;

  /// Y coordinate (Vertical), usually in world units/pixels.
  final double y;

  /// Returns a new [Vec2] with [x] replaced by [value].
  Vec2 withX(double value) => Vec2(value, y);

  /// Returns a new [Vec2] with [y] replaced by [value].
  Vec2 withY(double value) => Vec2(x, value);

  /// Component-wise Addition.
  Vec2 operator +(Vec2 other) => Vec2(x + other.x, y + other.y);

  /// Component-wise Subtraction.
  Vec2 operator -(Vec2 other) => Vec2(x - other.x, y - other.y);

  /// Scalar Multiplication.
  Vec2 scale(double factor) => Vec2(x * factor, y * factor);

  @override
  String toString() => 'Vec2(${x.toStringAsFixed(2)}, ${y.toStringAsFixed(2)})';
  
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Vec2 &&
          runtimeType == other.runtimeType &&
          x == other.x &&
          y == other.y;

  @override
  int get hashCode => x.hashCode ^ y.hashCode;
}


===== FILE: lib/core/util/velocity_math.dart =====
/// Velocity ramping utilities.
///
/// Helpers for smoothly accelerating/decelerating toward a target speed,
/// used by player and enemy movement systems.
library;

/// Ramps [current] velocity toward [desired] using asymmetric accel/decel.
///
/// - Accelerates at [accelPerSecond] when moving toward non-zero [desired].
/// - Decelerates at [decelPerSecond] when [desired] is zero.
/// - Snaps to zero if `|current| <= minStopSpeed` and `desired == 0`.
///
/// Returns the updated velocity after [dtSeconds].
double applyAccelDecel({
  required double current,
  required double desired,
  required double dtSeconds,
  required double accelPerSecond,
  required double decelPerSecond,
  double minStopSpeed = 0.0,
}) {
  if (dtSeconds <= 0.0) return current;
  if (desired == 0.0 && current.abs() <= minStopSpeed) return 0.0;

  final accel = desired == 0.0 ? decelPerSecond : accelPerSecond;
  final maxDelta = accel * dtSeconds;
  final delta = desired - current;
  if (delta.abs() > maxDelta) {
    return current + (delta > 0.0 ? maxDelta : -maxDelta);
  }
  return desired;
}


===== FILE: lib/core/weapons/weapon_catalog.dart =====
import '../abilities/ability_def.dart' show AbilityTag, WeaponType;
import 'weapon_category.dart';
import 'weapon_def.dart';
import 'weapon_id.dart';
import 'weapon_stats.dart';

/// Lookup table for weapon definitions.
///
/// Similar to [ProjectileItemCatalog], but for melee weapons.
class WeaponCatalog {
  const WeaponCatalog();

  WeaponDef get(WeaponId id) {
    switch (id) {
      case WeaponId.basicSword:
        return const WeaponDef(
          id: WeaponId.basicSword,
          category: WeaponCategory.primary,
          weaponType: WeaponType.oneHandedSword,
          grantedAbilityTags: {AbilityTag.melee, AbilityTag.physical},
        );
      case WeaponId.goldenSword:
        return const WeaponDef(
          id: WeaponId.goldenSword,
          category: WeaponCategory.primary,
          weaponType: WeaponType.oneHandedSword,
          grantedAbilityTags: {AbilityTag.melee, AbilityTag.physical},
          stats: WeaponStats(powerBonusBp: 2000), // +20% Damage
        );
      case WeaponId.basicShield:
        return const WeaponDef(
          id: WeaponId.basicShield,
          category: WeaponCategory.offHand,
          weaponType: WeaponType.shield,
          grantedAbilityTags: {AbilityTag.buff, AbilityTag.physical},
          stats: WeaponStats(powerBonusBp: 500),
        );
      case WeaponId.goldenShield:
        return const WeaponDef(
          id: WeaponId.goldenShield,
          category: WeaponCategory.offHand,
          weaponType: WeaponType.shield,
          grantedAbilityTags: {AbilityTag.buff, AbilityTag.physical},
          stats: WeaponStats(powerBonusBp: 1000),
        );
    }
  }

  WeaponDef? tryGet(WeaponId id) {
    try {
      return get(id);
    } catch (_) {
      return null;
    }
  }
}


===== FILE: lib/core/weapons/weapon_category.dart =====
/// Equipment slot category for weapons.
///
/// This determines which equipment slot(s) a weapon occupies,
/// not which ability slots it can power.
enum WeaponCategory {
  /// Main hand weapons (swords, axes, spears).
  primary,

  /// Off-hand equipment (shields, daggers, torches).
  offHand,

  /// Throwing weapons (knives, axes).
  projectile,
}


===== FILE: lib/core/weapons/weapon_def.dart =====
import '../abilities/ability_def.dart' show AbilityTag, WeaponType;
import '../combat/damage_type.dart';
import 'weapon_category.dart';
import 'weapon_id.dart';
import 'weapon_proc.dart';
import 'weapon_stats.dart';

/// Static, data-first definition for a melee weapon.
///
/// Weapon definitions are queried by [WeaponId] and used by intent writers
/// (e.g. [AbilityActivationSystem]) to fill combat metadata like damage type and
/// on-hit status profiles.
class WeaponDef {
  const WeaponDef({
    required this.id,
    required this.category,
    required this.weaponType,
    this.grantedAbilityTags = const {},
    this.damageType = DamageType.physical,
    this.procs = const [],
    this.stats = const WeaponStats(),
    this.isTwoHanded = false,
  });

  final WeaponId id;

  /// Equipment slot category (primary/offHand/projectile).
  final WeaponCategory category;

  /// Visual/functional family (used for ability gating).
  final WeaponType weaponType;

  /// Capabilities provided by this weapon.
  /// Abilities check: requiredTags ⊆ grantedAbilityTags.
  /// Safe default: empty grants nothing.
  final Set<AbilityTag> grantedAbilityTags;

  /// Default damage type applied to hits.
  final DamageType damageType;

  /// New, extensible proc list (Phase 2+).
  final List<WeaponProc> procs;

  /// Passive stats provided by this weapon (future use).
  final WeaponStats stats;

  /// If true, occupies both Primary + Secondary equipment slots.
  /// Enforcement is equip-time validation (Phase 3/4).
  final bool isTwoHanded;
}


===== FILE: lib/core/weapons/weapon_id.dart =====
/// Stable identifiers for melee weapons.
///
/// These IDs are intended to be deterministic and allocation-light, similar to
/// projectile item IDs used for the projectile slot.
enum WeaponId {
  /// Default starter weapon.
  basicSword,
  basicShield,
  goldenSword,
  goldenShield,
}


===== FILE: lib/core/weapons/weapon_proc.dart =====
import '../combat/status/status.dart';

/// Hook points where weapon procs can trigger.
enum ProcHook {
  onHit,
  onBlock,
  onKill,
  onCrit,
}

/// A single proc effect that can be attached to a weapon.
///
/// When the specified [hook] triggers, there's a [chance] to apply
/// the status effect defined by [statusProfileId].
class WeaponProc {
  const WeaponProc({
    required this.hook,
    required this.statusProfileId,
    this.chanceBp = 10000,
  }) : assert(chanceBp >= 0 && chanceBp <= 10000, 'chanceBp must be in [0..10000]');

  /// When this proc can trigger.
  final ProcHook hook;

  /// The status effect profile to apply.
  final StatusProfileId statusProfileId;

  /// Probability of triggering in Basis Points (100 = 1%, 10000 = 100%).
  final int chanceBp;
}



===== FILE: lib/core/weapons/weapon_stats.dart =====
/// Passive stat modifiers provided by a weapon.
///
/// These are not consumed by runtime systems in Phase 2 but provide
/// the data foundation for future damage/crit scaling.
class WeaponStats {
  const WeaponStats({
    this.powerBonusBp = 0,
    this.critChanceBonusBp = 0,
    this.critDamageBonusBp = 0,
    this.rangeScalarPercent = 100,
  }) : assert(rangeScalarPercent > 0, 'rangeScalarPercent must be > 0');

  /// Additive power bonus in Basis Points (100 = 1%).
  final int powerBonusBp;

  /// Additive crit chance bonus in Basis Points (100 = 1%).
  final int critChanceBonusBp;

  /// Additive crit damage bonus in Basis Points (100 = 1%).
  final int critDamageBonusBp;

  /// Multiplicative range modifier relative to 100 (100 = unchanged).
  final int rangeScalarPercent;
}


===== FILE: lib/firebase_options.dart =====
// File generated by FlutterFire CLI.
// ignore_for_file: type=lint
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'firebase_options.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        return ios;
      case TargetPlatform.macOS:
        return macos;
      case TargetPlatform.windows:
        return windows;
      case TargetPlatform.linux:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static const FirebaseOptions web = FirebaseOptions(
    apiKey: 'AIzaSyBVf_cQ5Xj15s_ZngbkeDXAokYCSCR8P7Y',
    appId: '1:964001571974:web:97acd9d8974e215dd81d07',
    messagingSenderId: '964001571974',
    projectId: 'rpg-runner-d7add',
    authDomain: 'rpg-runner-d7add.firebaseapp.com',
    storageBucket: 'rpg-runner-d7add.firebasestorage.app',
    measurementId: 'G-86SWFBNW26',
  );

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyB_RE8QyjyVnoBQ-H59DCIbGbc39faaixA',
    appId: '1:964001571974:android:d48582bc9cde8cf2d81d07',
    messagingSenderId: '964001571974',
    projectId: 'rpg-runner-d7add',
    storageBucket: 'rpg-runner-d7add.firebasestorage.app',
  );

  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: 'AIzaSyCFNb8YfiG8TULypJb6t5c_obcSKxOTpk4',
    appId: '1:964001571974:ios:84c6faf57baaa0f4d81d07',
    messagingSenderId: '964001571974',
    projectId: 'rpg-runner-d7add',
    storageBucket: 'rpg-runner-d7add.firebasestorage.app',
    iosBundleId: 'com.example.rpgRunner',
  );

  static const FirebaseOptions macos = FirebaseOptions(
    apiKey: 'AIzaSyCFNb8YfiG8TULypJb6t5c_obcSKxOTpk4',
    appId: '1:964001571974:ios:84c6faf57baaa0f4d81d07',
    messagingSenderId: '964001571974',
    projectId: 'rpg-runner-d7add',
    storageBucket: 'rpg-runner-d7add.firebasestorage.app',
    iosBundleId: 'com.example.rpgRunner',
  );

  static const FirebaseOptions windows = FirebaseOptions(
    apiKey: 'AIzaSyBVf_cQ5Xj15s_ZngbkeDXAokYCSCR8P7Y',
    appId: '1:964001571974:web:2f0915a1e04e6c16d81d07',
    messagingSenderId: '964001571974',
    projectId: 'rpg-runner-d7add',
    authDomain: 'rpg-runner-d7add.firebaseapp.com',
    storageBucket: 'rpg-runner-d7add.firebasestorage.app',
    measurementId: 'G-XPENVW9P9L',
  );

}

===== FILE: lib/game/AGENTS.md =====
# AGENTS.md - Game Layer

Instructions for AI coding agents working in the **Game** rendering layer (`lib/game/`).

## Game Layer Responsibility

The Game layer is responsible for **visuals only**. It uses the Flame game engine to render the game state produced by Core.

**Critical rule:** Game layer is **never authoritative** for gameplay logic, collision, or state management. All gameplay truth lives in Core.

## Core Snapshot Consumption

### Read-Only Contract

- The Game layer receives `GameStateSnapshot` objects from Core
- **Treat snapshots as read-only** - never mutate snapshot data
- Never simulate or extrapolate gameplay logic in the Game layer

### Interpolation Pattern

For smooth visuals, interpolate between snapshots:

```dart
void render(GameStateSnapshot prevSnapshot, 
            GameStateSnapshot currSnapshot, 
            double alpha) {
  // alpha ranges from 0.0 (prevSnapshot) to 1.0 (currSnapshot)
  
  final prevPos = prevSnapshot.entities[id].position;
  final currPos = currSnapshot.entities[id].position;
  
  final renderPos = prevPos.lerp(currPos, alpha);
  
  // Update sprite position
  sprite.position = renderPos;
}
```

**Rules:**
- Use `prevSnapshot` and `currSnapshot` for interpolation
- `alpha` is the interpolation factor (0.0 to 1.0)
- **Never simulate** - only interpolate between known states
- Never predict future positions or run physics in Game layer

## Flame Component Patterns

### Entity View Components

Entity view components are Flame components that visualize Core entities:

```dart
class PlayerView extends PositionComponent {
  final int entityId;
  
  void update(GameStateSnapshot snapshot, double alpha) {
    // Read entity data from snapshot
    final entity = snapshot.entities[entityId];
    
    // Update visual representation
    position = entity.position;
    animationState = entity.animationState;
  }
}
```

### Component Organization

- **Entity views** (`lib/game/components/`) - Visual representations of Core entities
- **Camera management** - Viewport, camera follow, shake effects
- **Parallax backgrounds** - Multi-layer scrolling backgrounds
- **VFX** - Visual effects (particles, explosions, trails)
- **Debug visualization** (`lib/game/debug/`) - Collision boxes, debug overlays

## World & Camera Rules

### Virtual Resolution

- Pick one **virtual resolution** (world units == virtual pixels)
- Example: 320×180, 640×360, or 1920×1080 depending on art style
- All Core coordinates use this virtual resolution

### Integer Scaling + Letterboxing

- Use **integer scaling** to avoid fractional pixels (prevents shimmering)
- Add **letterboxing** (black bars) when aspect ratio doesn't match
- No fractional scaling - sprite pixels must be crisp

### Pixel Snapping

- Snap camera position to integer pixels inside the scaled viewport
- Snap entity render positions to integer pixels
- This prevents sub-pixel jitter in pixel-art games

```dart
// Example pixel snapping
final snappedX = (position.x).floor().toDouble();
final snappedY = (position.y).floor().toDouble();
sprite.position = Vector2(snappedX, snappedY);
```

## Asset Management

### Per-Scene Loading

- Assets are loaded **per scene**, not at boot
- Load assets when entering a game route/level
- Unload assets when leaving the route/level

**Example:**
```dart
class LevelScene {
  Future<void> load() async {
    await images.load('level1/background.png');
    await images.load('level1/tileset.png');
    // ... load level-specific assets
  }
  
  void unload() {
    images.clear();
  }
}
```

### No Loading During Gameplay

- **Never load assets during active gameplay**
- Load all required assets during a loading screen
- Preload critical assets before gameplay starts
- Use asset pools for frequently spawned entities

## Input Handling

### Convert Input to Commands

The Game layer can receive input (e.g., from Flame's input system), but it must **convert input to Commands** and send them to the controller.

```dart
@override
void onTapDown(TapDownEvent event) {
  // Convert Flame input to Core command
  final command = JumpCommand(
    tickNumber: controller.currentTick,
    playerId: 0,
  );
  
  // Send to controller
  controller.enqueueCommand(command);
}
```

**Rules:**
- Never modify Core state directly from input handlers
- Always use the Command pattern
- Let Core process commands during its tick execution

## Game Events

Game layer consumes `GameEvent` objects from Core to trigger visual/audio effects:

```dart
void handleEvents(List<GameEvent> events) {
  for (final event in events) {
    switch (event) {
      case HitEvent(:final position, :final damage):
        spawnHitVFX(position, damage);
        playSFX('hit.wav');
        break;
        
      case ScreenShakeEvent(:final intensity, :final duration):
        cameraShake(intensity, duration);
        break;
        
      // ... handle other event types
    }
  }
}
```

**Event types:**
- Spawn/despawn events → Create/remove entity views
- Hit/damage events → Spawn VFX, play sounds
- Screen shake events → Apply camera effects
- Reward events → Display score popups, notifications

## Flame API Preferences

### Use Flame for Render Concerns

Flame provides excellent tools for rendering. Use them:

- **Camera components** - `CameraComponent`, `Viewport`, camera follow
- **Parallax rendering** - `ParallaxComponent` for scrolling backgrounds
- **Effects** - `MoveEffect`, `ScaleEffect`, `OpacityEffect`, etc.
- **Sprite animations** - `SpriteAnimationComponent`
- **Particles** - `ParticleSystemComponent` for VFX

### Don't Use Flame for Gameplay

Flame also provides gameplay-adjacent features that we **do not use**:

- ❌ **Flame collision system** - Core handles all collision authoritatively
- ❌ **Flame physics** - Core handles all physics
- ❌ **Flame game loop timing** - Core uses fixed ticks, not Flame's variable dt

## Common Game Subsystems

- **GameController** (`lib/game/game_controller.dart`) - Bridges UI, Game, and Core
- **RunnerFlameGame** (`lib/game/runner_flame_game.dart`) - Main Flame game instance
- **Components** (`lib/game/components/`) - Entity views and visual components
- **Input** (`lib/game/input/`) - Input handling and command conversion
- **Themes** (`lib/game/themes/`) - Visual themes and color schemes
- **Debug** (`lib/game/debug/`) - Debug visualization and tools

## What NOT to Do in Game Layer

- ❌ **Do not simulate gameplay** - that's Core's job
- ❌ **Do not use Flame collision as gameplay truth** - Core is authoritative
- ❌ **Do not mutate Core state** - send Commands instead
- ❌ **Do not mutate snapshots** - they are read-only
- ❌ **Do not load assets during gameplay** - preload everything
- ❌ **Do not use variable dt for gameplay** - Core uses fixed ticks

## Best Practices

✅ **Interpolate for smooth visuals** using prev/curr snapshots
✅ **Use Flame components** for camera, parallax, effects
✅ **Convert input to Commands** before sending to Core
✅ **Consume events** to trigger VFX and SFX
✅ **Load assets per-scene** and unload when done
✅ **Snap positions** for pixel-perfect rendering

---

**For cross-layer architecture and general rules**, see [lib/AGENTS.md](file:///c:/dev/rpg_runner/lib/AGENTS.md).


===== FILE: lib/game/components/aim_ray_component.dart =====
import 'package:flame/components.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/widgets.dart';

import '../../core/snapshots/entity_render_snapshot.dart';
import '../../core/snapshots/enums.dart';
import '../game_controller.dart';
import '../input/aim_preview.dart';

/// Renders a visual "aim ray" or laser sight extending from the player.
///
/// Reacts to [AimPreviewState] to show the player where their projectile
/// or ability will land.
class AimRayComponent extends Component {
  AimRayComponent({
    required this.controller,
    required this.preview,
    required this.length,
    this.playerRenderPos,
    Paint? paint,
    this.drawWhenNoAim = true,
  }) : _paint =
           paint ??
           (Paint()
             ..color = const Color.fromARGB(255, 120, 165, 236)
             ..strokeWidth = 2
             ..strokeCap = StrokeCap.round);

  /// Provides access to the game state (player position).
  final GameController controller;

  /// Reactive state for the current aim direction/status.
  final ValueListenable<AimPreviewState> preview;

  /// Length of the ray in world units (pixels).
  final double length;

  /// Optional rendered player position (already snapped for pixel-perfect render).
  ///
  /// When provided, the ray origin uses this position instead of the raw
  /// snapshot value to avoid 1px drift when render interpolation/snapping is
  /// enabled.
  final ValueGetter<Vector2>? playerRenderPos;

  /// Whether to draw a "straight ahead" ray even when the player hasn't
  /// explicitly dragged to aim (fallback to player facing).
  final bool drawWhenNoAim;

  final Paint _paint;

  @override
  void render(Canvas canvas) {
    final state = preview.value;
    if (!state.active) return;
    if (!state.hasAim && !drawWhenNoAim) return;

    final player = controller.snapshot.playerEntity;
    if (player == null) return;

    final (dirX, dirY) = _resolveDir(state, player);
    final rendered = playerRenderPos?.call();
    final startX = rendered?.x ?? player.pos.x;
    final startY = rendered?.y ?? player.pos.y;
    final endX = startX + dirX * length;
    final endY = startY + dirY * length;

    canvas.drawLine(Offset(startX, startY), Offset(endX, endY), _paint);
  }

  /// Determines the ray direction.
  ///
  /// Uses the explicit aim if available; otherwise falls back to the player's
  /// current facing direction.
  (double, double) _resolveDir(
    AimPreviewState state,
    EntityRenderSnapshot player,
  ) {
    if (state.hasAim) {
      return (state.dirX, state.dirY);
    }
    final facing = player.facing;
    return (facing == Facing.right ? 1.0 : -1.0, 0.0);
  }
}


===== FILE: lib/game/components/enemies/enemy_render_registry.dart =====
/// Enemy render registry and loaders (render layer only).
library;

import 'package:flame/cache.dart';
import 'package:flame/components.dart';

import '../../../core/contracts/render_anim_set_definition.dart';
import '../../../core/enemies/enemy_catalog.dart';
import '../../../core/enemies/enemy_id.dart';
import '../../../core/snapshots/enums.dart';
import '../sprite_anim/deterministic_anim_view_component.dart';
import '../sprite_anim/sprite_anim_set.dart';
import '../sprite_anim/strip_animation_loader.dart';

typedef EnemyAnimLoader =
    Future<SpriteAnimSet> Function(
      Images images, {
      required RenderAnimSetDefinition renderAnim,
      required Set<AnimKey> oneShotKeys,
    });

typedef EnemyViewFactory =
    DeterministicAnimViewComponent Function(
      SpriteAnimSet animSet,
      Vector2 renderScale,
    );

enum EnemyDeathAnimPolicy { spawn, none }

const Set<AnimKey> _defaultEnemyOneShotKeys = <AnimKey>{
  AnimKey.strike,
  AnimKey.hit,
  AnimKey.death,
};

DeterministicAnimViewComponent _defaultEnemyViewFactory(
  SpriteAnimSet animSet,
  Vector2 renderScale,
) {
  return DeterministicAnimViewComponent(
    animSet: animSet,
    renderSize: Vector2(animSet.frameSize.x, animSet.frameSize.y),
    renderScale: renderScale,
  );
}

class EnemyRenderEntry {
  EnemyRenderEntry({
    required this.id,
    required this.renderScale,
    this.deathAnimPolicy = EnemyDeathAnimPolicy.spawn,
    this.oneShotKeys = _defaultEnemyOneShotKeys,
    this.loader = loadAnimSetFromDefinition,
    this.viewFactory = _defaultEnemyViewFactory,
  });

  final EnemyId id;
  final Vector2 renderScale;
  final EnemyDeathAnimPolicy deathAnimPolicy;
  final Set<AnimKey> oneShotKeys;
  final EnemyAnimLoader loader;
  final EnemyViewFactory viewFactory;

  SpriteAnimSet? _animSet;
  bool _hasAssets = true;

  bool get hasAssets => _hasAssets;

  bool get isLoaded => _animSet != null;

  bool get isRenderable => _hasAssets && _animSet != null;

  SpriteAnimSet get animSet {
    final value = _animSet;
    if (value == null) {
      throw StateError('EnemyRenderEntry($id) has not been loaded yet.');
    }
    return value;
  }

  Future<void> load(
    Images images, {
    required RenderAnimSetDefinition renderAnim,
  }) async {
    final idlePath = renderAnim.sourcesByKey[AnimKey.idle];
    if (idlePath == null || idlePath.trim().isEmpty) {
      _hasAssets = false;
      _animSet = null;
      return;
    }
    _animSet = await loader(
      images,
      renderAnim: renderAnim,
      oneShotKeys: oneShotKeys,
    );
  }
}

/// Render registry for enemies (EnemyId -> render wiring).
class EnemyRenderRegistry {
  EnemyRenderRegistry({EnemyCatalog enemyCatalog = const EnemyCatalog()})
    : _enemyCatalog = enemyCatalog;

  final EnemyCatalog _enemyCatalog;

  final Map<EnemyId, EnemyRenderEntry> _entries = <EnemyId, EnemyRenderEntry>{
    EnemyId.unocoDemon: EnemyRenderEntry(
      id: EnemyId.unocoDemon,
      renderScale: Vector2.all(0.5),
    ),
    EnemyId.grojib: EnemyRenderEntry(
      id: EnemyId.grojib,
      renderScale: Vector2.all(1.5),
    ),
  };

  EnemyRenderEntry? entryFor(EnemyId id) {
    final entry = _entries[id];
    if (entry == null || !entry.isRenderable) return null;
    return entry;
  }

  Future<void> load(Images images) async {
    for (final entry in _entries.values) {
      final renderAnim = _enemyCatalog.get(entry.id).renderAnim;
      await entry.load(images, renderAnim: renderAnim);
    }
  }
}


===== FILE: lib/game/components/pickups/pickup_render_registry.dart =====
/// Pickup render registry and loaders (render layer only).
library;

import 'package:flame/cache.dart';
import 'package:flame/components.dart';

import '../../../core/contracts/render_anim_set_definition.dart';
import '../../../core/pickups/pickup_render_catalog.dart';
import '../../../core/snapshots/entity_render_snapshot.dart';
import '../../../core/snapshots/enums.dart';
import '../sprite_anim/deterministic_anim_view_component.dart';
import '../sprite_anim/sprite_anim_set.dart';
import '../sprite_anim/strip_animation_loader.dart';

typedef PickupAnimLoader =
    Future<SpriteAnimSet> Function(
      Images images, {
      required RenderAnimSetDefinition renderAnim,
      required Set<AnimKey> oneShotKeys,
    });

typedef PickupViewFactory =
    DeterministicAnimViewComponent Function(
      SpriteAnimSet animSet,
      Vector2 renderScale,
    );

DeterministicAnimViewComponent _defaultPickupViewFactory(
  SpriteAnimSet animSet,
  Vector2 renderScale,
) {
  return DeterministicAnimViewComponent(
    animSet: animSet,
    renderSize: Vector2(animSet.frameSize.x, animSet.frameSize.y),
    renderScale: renderScale,
    respectFacing: false,
  );
}

class PickupRenderEntry {
  PickupRenderEntry({
    required this.variant,
    required this.renderScale,
    this.oneShotKeys = const <AnimKey>{},
    this.loader = loadAnimSetFromDefinition,
    this.viewFactory = _defaultPickupViewFactory,
  });

  final int variant;
  final Vector2 renderScale;
  final Set<AnimKey> oneShotKeys;
  final PickupAnimLoader loader;
  final PickupViewFactory viewFactory;

  SpriteAnimSet? _animSet;

  bool get isLoaded => _animSet != null;

  SpriteAnimSet get animSet {
    final value = _animSet;
    if (value == null) {
      throw StateError('PickupRenderEntry($variant) has not been loaded yet.');
    }
    return value;
  }

  Future<void> load(
    Images images, {
    required RenderAnimSetDefinition renderAnim,
  }) async {
    _animSet = await loader(
      images,
      renderAnim: renderAnim,
      oneShotKeys: oneShotKeys,
    );
  }
}

/// Render registry for pickups (PickupVariant -> render wiring).
class PickupRenderRegistry {
  PickupRenderRegistry({
    PickupRenderCatalog catalog = const PickupRenderCatalog(),
  }) : _catalog = catalog;

  final PickupRenderCatalog _catalog;

  // 16px art scaled to match Core collider sizes.
  static final Vector2 _collectibleScale = Vector2.all(1.0);
  static final Vector2 _restorationScale = Vector2.all(1.0);

  final Map<int, PickupRenderEntry> _entries = <int, PickupRenderEntry>{
    // Collectible coin.
    PickupVariant.collectible: PickupRenderEntry(
      variant: PickupVariant.collectible,
      renderScale: _collectibleScale,
    ),
    // Restoration gems.
    PickupVariant.restorationHealth: PickupRenderEntry(
      variant: PickupVariant.restorationHealth,
      renderScale: _restorationScale,
    ),
    PickupVariant.restorationMana: PickupRenderEntry(
      variant: PickupVariant.restorationMana,
      renderScale: _restorationScale,
    ),
    PickupVariant.restorationStamina: PickupRenderEntry(
      variant: PickupVariant.restorationStamina,
      renderScale: _restorationScale,
    ),
  };

  PickupRenderEntry entryForVariant(int variant) {
    final entry = _entries[variant];
    if (entry == null) {
      throw StateError(
        'No pickup render entry registered for variant=$variant.',
      );
    }
    return entry;
  }

  Future<void> load(Images images) async {
    for (final entry in _entries.values) {
      final renderAnim = _catalog.get(entry.variant);
      await entry.load(images, renderAnim: renderAnim);
    }
  }
}


===== FILE: lib/game/components/pixel_parallax_backdrop_component.dart =====
// Renders a multi-layer parallax background for pixel-art games.
//
// Each layer scrolls at a fraction of the camera movement (controlled by
// `parallaxFactor`), creating depth. Layers are rendered in order, so
// earlier layers appear behind later ones.
//
// The component uses a fixed "virtual" viewport size to maintain pixel-perfect
// rendering regardless of actual screen resolution. Images are tiled horizontally
// and bottom-aligned within the viewport.
import 'dart:ui' as ui;
import 'package:flame/components.dart';
import 'package:flame/game.dart';
import 'package:flutter/painting.dart';
import '../util/math_util.dart';

/// Renders a pixel-perfect, multi-layer parallax background.
///
/// Layers are defined via [PixelParallaxLayerSpec] and rendered back-to-front.
/// Each layer's scroll position is determined by its [PixelParallaxLayerSpec.parallaxFactor]:
/// - `0.0` = static (doesn't move with camera)
/// - `1.0` = moves 1:1 with camera (no parallax effect)
/// - Values between create the classic parallax depth illusion
class PixelParallaxBackdropComponent extends Component
    with HasGameReference<FlameGame> {
  PixelParallaxBackdropComponent({
    required this.virtualWidth,
    required this.virtualHeight,
    required this.layers,
    this.snapScrollToPixels = true,
  });

  /// Width of the virtual viewport in pixels.
  final int virtualWidth;

  /// Height of the virtual viewport in pixels.
  final int virtualHeight;

  /// Layer specifications, rendered in order (index 0 = backmost).
  final List<PixelParallaxLayerSpec> layers;

  /// If true, scroll offsets are rounded to whole pixels for crisp rendering.
  final bool snapScrollToPixels;

  /// Loaded images for each layer (parallel to [layers]).
  late final List<ui.Image> _images;

  /// Previous frame's camera X position (for delta calculation).
  double? _prevCameraLeftX;

  /// Accumulated scroll offset for each layer (in pixels).
  late final List<double> _scroll;

  /// Paint configured for nearest-neighbor (pixel-perfect) filtering.
  final Paint _paint = Paint()..filterQuality = FilterQuality.none;

  @override
  Future<void> onLoad() async {
    await super.onLoad();
    _images = await Future.wait(
      layers.map((layer) => game.images.load(layer.assetPath)),
    );
    _scroll = List<double>.filled(layers.length, 0);
  }

  /// Updates scroll offsets based on camera movement.
  ///
  /// Each layer's scroll is incremented by `cameraDelta * parallaxFactor`,
  /// then wrapped to avoid floating-point overflow on long play sessions.
  @override
  void update(double dt) {
    super.update(dt);

    final viewWidth = virtualWidth.toDouble();
    final camX = -game.camera.viewfinder.transform.offset.x;
    final cameraLeftX = camX - viewWidth * 0.5;

    final prev = _prevCameraLeftX;
    _prevCameraLeftX = cameraLeftX;
    if (prev == null) return; // First frame: just record position, skip scroll.

    final delta = cameraLeftX - prev;
    if (delta == 0) return; // No camera movement, nothing to update.

    for (var i = 0; i < layers.length; i++) {
      _scroll[i] += delta * layers[i].parallaxFactor;
      // Wrap scroll to [0, imageWidth) to prevent overflow.
      _scroll[i] = positiveModDouble(_scroll[i], _images[i].width.toDouble());
    }
  }

  /// Renders all parallax layers, back-to-front.
  ///
  /// Each layer is horizontally tiled and bottom-aligned within the virtual
  /// viewport. The viewport is clipped to prevent overdraw outside bounds.
  @override
  void render(ui.Canvas canvas) {
    super.render(canvas);

    final viewWidth = virtualWidth;
    final viewHeight = virtualHeight;

    canvas.save();
    canvas.clipRect(
      ui.Rect.fromLTWH(0, 0, viewWidth.toDouble(), viewHeight.toDouble()),
    );

    for (var i = 0; i < layers.length; i++) {
      final image = _images[i];

      final imageW = image.width;
      final imageH = image.height;
      final y = (viewHeight - imageH).toDouble(); // Bottom-aligned.

      // Optionally snap to whole pixels for crisp pixel-art rendering.
      final scroll = snapScrollToPixels
          ? roundToPixels(_scroll[i])
          : _scroll[i];
      final offsetPx = -scroll;
      final startX = positiveModDouble(offsetPx, imageW.toDouble());

      // Tile the image across the viewport width.
      for (var x = startX - imageW; x < viewWidth; x += imageW) {
        canvas.drawImage(image, ui.Offset(x, y), _paint);
      }
    }

    canvas.restore();
  }
}

/// Configuration for a single parallax layer.
class PixelParallaxLayerSpec {
  const PixelParallaxLayerSpec({
    required this.assetPath,
    required this.parallaxFactor,
  });

  /// Path to the layer image (relative to assets/images/).
  final String assetPath;

  /// How much this layer scrolls relative to camera movement.
  ///
  /// - `0.0`: Layer is static (sky, distant mountains).
  /// - `0.5`: Layer moves at half camera speed (mid-ground).
  /// - `1.0`: Layer moves 1:1 with camera (no parallax, foreground).
  final double parallaxFactor;
}


===== FILE: lib/game/components/player/player_animations.dart =====
/// Player animation loading utilities (render layer only).
///
/// Loads horizontal sprite-strip animations from `assets/images/entities/player/`.
library;

import 'package:flame/cache.dart';

import '../../../core/contracts/render_anim_set_definition.dart';
import '../../../core/snapshots/enums.dart';
import '../sprite_anim/sprite_anim_set.dart';
import '../sprite_anim/strip_animation_loader.dart';

Future<SpriteAnimSet> loadPlayerAnimations(
  Images images, {
  required RenderAnimSetDefinition renderAnim,
}) async {
  final oneShotKeys = <AnimKey>{
    AnimKey.strike,
    AnimKey.backStrike,
    AnimKey.cast,
    AnimKey.ranged,
    AnimKey.dash,
    AnimKey.hit,
    AnimKey.death,
  };
  return loadAnimSetFromDefinition(
    images,
    renderAnim: renderAnim,
    oneShotKeys: oneShotKeys,
  );
}


===== FILE: lib/game/components/player/player_view_component.dart =====
/// Player render component driven purely by Core snapshots.
library;

import 'package:flame/components.dart';

import '../../../core/snapshots/enums.dart';
import '../sprite_anim/deterministic_anim_view_component.dart';
import '../sprite_anim/sprite_anim_set.dart';

class PlayerViewComponent extends DeterministicAnimViewComponent {
  PlayerViewComponent({
    required SpriteAnimSet animationSet,
    Vector2? renderSize,
    Vector2? renderScale,
  }) : super(
         animSet: animationSet,
         initial: AnimKey.idle,
         renderSize: renderSize ??
             Vector2(animationSet.frameSize.x, animationSet.frameSize.y),
         renderScale: renderScale,
         fallbackResolver: (desired) {
           // Allow directional variants to fall back to their base animation key.
           if (desired == AnimKey.backStrike &&
               !animationSet.animations.containsKey(AnimKey.backStrike) &&
               animationSet.animations.containsKey(AnimKey.strike)) {
             return AnimKey.strike;
           }
           if (desired == AnimKey.ranged &&
               !animationSet.animations.containsKey(AnimKey.ranged) &&
               animationSet.animations.containsKey(AnimKey.cast)) {
             return AnimKey.cast;
           }
           return desired;
         },
       );
}


===== FILE: lib/game/components/projectiles/projectile_render_registry.dart =====
/// Projectile render registry and loaders (render layer only).
library;

import 'dart:math';

import 'package:flame/cache.dart';
import 'package:flame/components.dart';

import '../../../core/contracts/render_anim_set_definition.dart';
import '../../../core/projectiles/projectile_id.dart';
import '../../../core/projectiles/projectile_render_catalog.dart';
import '../../../core/snapshots/enums.dart';
import '../sprite_anim/deterministic_anim_view_component.dart';
import '../sprite_anim/sprite_anim_set.dart';
import '../sprite_anim/strip_animation_loader.dart';

typedef ProjectileAnimLoader =
    Future<SpriteAnimSet> Function(
      Images images, {
      required RenderAnimSetDefinition renderAnim,
      required Set<AnimKey> oneShotKeys,
    });

typedef ProjectileViewFactory =
    DeterministicAnimViewComponent Function(
      SpriteAnimSet animSet,
      Vector2 renderScale,
    );

const Set<AnimKey> _defaultProjectileOneShotKeys = <AnimKey>{
  AnimKey.spawn,
  AnimKey.hit,
};

DeterministicAnimViewComponent _defaultProjectileViewFactory(
  SpriteAnimSet animSet,
  Vector2 renderScale,
) {
  return DeterministicAnimViewComponent(
    animSet: animSet,
    renderSize: Vector2(animSet.frameSize.x, animSet.frameSize.y),
    renderScale: renderScale,
    respectFacing: false,
  );
}

class ProjectileRenderEntry {
  ProjectileRenderEntry({
    required this.id,
    required this.renderScale,
    this.oneShotKeys = _defaultProjectileOneShotKeys,
    this.loader = loadAnimSetFromDefinition,
    this.viewFactory = _defaultProjectileViewFactory,
    this.spinSpeedRadPerSecond = 0.0,
  });

  final ProjectileId id;
  final Vector2 renderScale;
  final Set<AnimKey> oneShotKeys;
  final ProjectileAnimLoader loader;
  final ProjectileViewFactory viewFactory;
  final double spinSpeedRadPerSecond;

  SpriteAnimSet? _animSet;
  bool _hasAssets = true;
  final Map<int, int> _spawnAnimTicksCache = <int, int>{};

  bool get hasAssets => _hasAssets;

  bool get isLoaded => _animSet != null;

  bool get isRenderable => _hasAssets && _animSet != null;

  SpriteAnimSet get animSet {
    final value = _animSet;
    if (value == null) {
      throw StateError('ProjectileRenderEntry($id) has not been loaded yet.');
    }
    return value;
  }

  int spawnAnimTicks(int tickHz) {
    final cached = _spawnAnimTicksCache[tickHz];
    if (cached != null) return cached;

    final set = _animSet;
    if (set == null) return 0;
    final anim = set.animations[AnimKey.spawn];
    if (anim == null) return 0;
    final frameCount = anim.frames.length;
    if (frameCount <= 1) return 0;

    final ticksPerFrame = set.ticksPerFrameFor(AnimKey.spawn, tickHz);
    final totalTicks = ticksPerFrame * frameCount;
    _spawnAnimTicksCache[tickHz] = totalTicks;
    return totalTicks;
  }

  Future<void> load(
    Images images, {
    required RenderAnimSetDefinition renderAnim,
  }) async {
    final idlePath = renderAnim.sourcesByKey[AnimKey.idle];
    if (idlePath == null || idlePath.trim().isEmpty) {
      _hasAssets = false;
      _animSet = null;
      return;
    }
    _animSet = await loader(
      images,
      renderAnim: renderAnim,
      oneShotKeys: oneShotKeys,
    );
  }
}

/// Render registry for projectiles (ProjectileId -> render wiring).
class ProjectileRenderRegistry {
  ProjectileRenderRegistry({
    ProjectileRenderCatalog projectileCatalog = const ProjectileRenderCatalog(),
  }) : _projectileCatalog = projectileCatalog;

  final ProjectileRenderCatalog _projectileCatalog;

  static const double _throwingAxeSpinRps = 6.0;
  static const double _throwingKnifeSpinRps = 7.0;

  final Map<ProjectileId, ProjectileRenderEntry> _entries =
      <ProjectileId, ProjectileRenderEntry>{
        ProjectileId.iceBolt: ProjectileRenderEntry(
          id: ProjectileId.iceBolt,
          renderScale: Vector2.all(1.0),
        ),
        ProjectileId.thunderBolt: ProjectileRenderEntry(
          id: ProjectileId.thunderBolt,
          renderScale: Vector2.all(1.0),
        ),
        ProjectileId.fireBolt: ProjectileRenderEntry(
          id: ProjectileId.fireBolt,
          renderScale: Vector2.all(1.0),
        ),
        ProjectileId.throwingAxe: ProjectileRenderEntry(
          id: ProjectileId.throwingAxe,
          renderScale: Vector2.all(1.0),
          spinSpeedRadPerSecond: _throwingAxeSpinRps * 2.0 * pi,
        ),
        ProjectileId.throwingKnife: ProjectileRenderEntry(
          id: ProjectileId.throwingKnife,
          renderScale: Vector2.all(1.0),
          spinSpeedRadPerSecond: _throwingKnifeSpinRps * 2.0 * pi,
        ),
      };

  ProjectileRenderEntry? entryFor(ProjectileId id) {
    final entry = _entries[id];
    if (entry == null || !entry.isRenderable) return null;
    return entry;
  }

  Future<void> load(Images images) async {
    for (final entry in _entries.values) {
      final renderAnim = _projectileCatalog.get(entry.id);
      await entry.load(images, renderAnim: renderAnim);
    }
  }
}


===== FILE: lib/game/components/sprite_anim/deterministic_anim_view_component.dart =====
/// Generic deterministic sprite animation component driven by Core snapshots.
library;

import 'package:flame/components.dart';
import 'package:flutter/widgets.dart';

import '../../../core/snapshots/entity_render_snapshot.dart';
import '../../../core/snapshots/enums.dart';
import 'sprite_anim_set.dart';
import '../../util/math_util.dart' as math;

typedef AnimKeyFallbackResolver = AnimKey Function(AnimKey desired);

class DeterministicAnimViewComponent
    extends SpriteAnimationGroupComponent<AnimKey> {
  DeterministicAnimViewComponent({
    required SpriteAnimSet animSet,
    AnimKey initial = AnimKey.idle,
    AnimKeyFallbackResolver? fallbackResolver,
    Vector2? renderSize,
    Vector2? renderScale,
    bool respectFacing = true,
  }) : _animSet = animSet,
       _availableAnimations = animSet.animations,
       _oneShotKeys = animSet.oneShotKeys,
       _fallbackResolver = fallbackResolver,
       _baseScale = renderScale?.clone() ?? Vector2.all(1.0),
       _respectFacing = respectFacing,
       super(
         animations: animSet.animations,
         current: initial,
         size: renderSize ?? Vector2(animSet.frameSize.x, animSet.frameSize.y),
         scale: renderScale?.clone() ?? Vector2.all(1.0),
         anchor: animSet.anchor,
         paint: Paint()..filterQuality = FilterQuality.none,
       ) {
    // We drive animation frames deterministically from `EntityRenderSnapshot.animFrame`.
    playing = false;
  }

  final SpriteAnimSet _animSet;
  final Map<AnimKey, SpriteAnimation> _availableAnimations;
  final Set<AnimKey> _oneShotKeys;
  final AnimKeyFallbackResolver? _fallbackResolver;
  final Vector2 _baseScale;
  final bool _respectFacing;

  void applySnapshot(
    EntityRenderSnapshot e, {
    required int tickHz,
    Vector2? pos,
    AnimKey? overrideAnim,
    int? overrideAnimFrame,
  }) {
    if (pos != null) {
      position.setFrom(pos);
    } else {
      position.setValues(
        math.roundToPixels(e.pos.x),
        math.roundToPixels(e.pos.y),
      );
    }

    var next = overrideAnim ?? e.anim;
    if (_fallbackResolver != null) {
      next = _fallbackResolver(next);
    }
    if (!_availableAnimations.containsKey(next)) {
      next = AnimKey.idle;
    }
    if (current != next) {
      current = next;
    }

    if (_respectFacing) {
      final artFacing = e.artFacingDir ?? Facing.right;
      final sign = e.facing == artFacing ? 1.0 : -1.0;
      final desiredScaleX = _baseScale.x * sign;
      if (scale.x != desiredScaleX || scale.y != _baseScale.y) {
        scale.setValues(desiredScaleX, _baseScale.y);
      }
    } else if (scale.x != _baseScale.x || scale.y != _baseScale.y) {
      scale.setValues(_baseScale.x, _baseScale.y);
    }

    final frameHint = overrideAnimFrame ?? e.animFrame;
    if (frameHint == null) return;

    final ticker = animationTicker;
    final anim = animation;
    if (ticker == null || anim == null) return;

    final framesLen = anim.frames.length;
    if (framesLen <= 1) return;

    final currentKey = current ?? AnimKey.idle;
    final ticksPerFrame = _animSet.ticksPerFrameFor(currentKey, tickHz);
    final rawIndex = frameHint ~/ ticksPerFrame;
    final index = _oneShotKeys.contains(currentKey)
        ? rawIndex.clamp(0, framesLen - 1).toInt()
        : rawIndex % framesLen;
    ticker.currentIndex = index;
  }
}


===== FILE: lib/game/components/sprite_anim/sprite_anim_set.dart =====
/// Shared render-side sprite animation bundle.
library;

import 'dart:math';

import 'package:flame/components.dart';

import '../../../core/snapshots/enums.dart';

class SpriteAnimSet {
  SpriteAnimSet({
    required this.animations,
    required this.stepTimeSecondsByKey,
    required this.oneShotKeys,
    required this.frameSize,
    this.anchor = Anchor.center,
  });

  final Map<AnimKey, SpriteAnimation> animations;
  final Map<AnimKey, double> stepTimeSecondsByKey;
  final Set<AnimKey> oneShotKeys;

  /// Source frame size inside each horizontal strip image.
  final Vector2 frameSize;

  /// Anchor used by view components when rendering this animation set.
  ///
  /// Defaults to `Anchor.center`.
  final Anchor anchor;

  final Map<int, Map<AnimKey, int>> _ticksPerFrameCache =
      <int, Map<AnimKey, int>>{};

  int ticksPerFrameFor(AnimKey key, int tickHz) {
    final cache = _ticksPerFrameCache.putIfAbsent(
      tickHz,
      () => <AnimKey, int>{},
    );
    final existing = cache[key];
    if (existing != null) return existing;

    final stepSeconds =
        stepTimeSecondsByKey[key] ?? stepTimeSecondsByKey[AnimKey.idle] ?? 0.10;
    final ticks = max(1, (stepSeconds * tickHz).round());
    cache[key] = ticks;
    return ticks;
  }
}


===== FILE: lib/game/components/sprite_anim/strip_animation_loader.dart =====
/// Shared sprite-strip animation loader utilities (render layer only).
library;

import 'dart:ui';

import 'package:flame/cache.dart';
import 'package:flame/components.dart';

import '../../../core/contracts/render_anim_set_definition.dart';
import '../../../core/snapshots/enums.dart';
import '../../../core/util/vec2.dart';
import 'sprite_anim_set.dart';

Future<SpriteAnimSet> loadStripAnimations(
  Images images, {
  required int frameWidth,
  required int frameHeight,
  required Map<AnimKey, String> sourcesByKey,
  Map<AnimKey, int> rowByKey = const <AnimKey, int>{},
  Vec2? anchorInFramePx,
  Map<AnimKey, int> frameStartByKey = const <AnimKey, int>{},
  required Map<AnimKey, int> frameCountsByKey,
  required Map<AnimKey, double> stepTimeSecondsByKey,
  required Set<AnimKey> oneShotKeys,
}) async {
  final frameSize = Vector2(frameWidth.toDouble(), frameHeight.toDouble());

  final anchor = switch (anchorInFramePx) {
    null => Anchor.center,
    final a => () {
      assert(
        a.x >= 0 && a.x <= frameWidth,
        'anchorInFramePx.x must be in [0, $frameWidth] (got ${a.x}).',
      );
      assert(
        a.y >= 0 && a.y <= frameHeight,
        'anchorInFramePx.y must be in [0, $frameHeight] (got ${a.y}).',
      );
      return Anchor(a.x / frameWidth, a.y / frameHeight);
    }(),
  };

  final keysByPath = <String, List<AnimKey>>{};
  for (final entry in sourcesByKey.entries) {
    keysByPath.putIfAbsent(entry.value, () => <AnimKey>[]).add(entry.key);
  }

  // Load each unique path once (Images also caches globally, but this keeps the
  // loader itself allocation-light and predictable).
  final imagesByPath = <String, Image>{};
  for (final path in keysByPath.keys) {
    imagesByPath[path] = await images.load(path);
  }

  final animations = <AnimKey, SpriteAnimation>{};
  for (final entry in sourcesByKey.entries) {
    final key = entry.key;
    final path = entry.value;
    final img = imagesByPath[path]!;

    final stepTime =
        stepTimeSecondsByKey[key] ?? stepTimeSecondsByKey[AnimKey.idle] ?? 0.1;
    final frameCount =
        frameCountsByKey[key] ?? frameCountsByKey[AnimKey.idle] ?? 1;
    final row = rowByKey[key] ?? 0;
    final startFrame = frameStartByKey[key] ?? 0;

    assert(
      startFrame >= 0,
      'frameStartByKey[$key] must be >= 0 (got $startFrame).',
    );

    final sprites = List<Sprite>.generate(frameCount, (i) {
      return Sprite(
        img,
        srcPosition: Vector2(
          frameWidth.toDouble() * (startFrame + i),
          frameHeight.toDouble() * row,
        ),
        srcSize: frameSize,
      );
    });

    animations[key] = SpriteAnimation.spriteList(
      sprites,
      stepTime: stepTime,
      loop: !oneShotKeys.contains(key),
    );
  }

  return SpriteAnimSet(
    animations: animations,
    stepTimeSecondsByKey: stepTimeSecondsByKey,
    oneShotKeys: oneShotKeys,
    frameSize: frameSize,
    anchor: anchor,
  );
}

Future<SpriteAnimSet> loadAnimSetFromDefinition(
  Images images, {
  required RenderAnimSetDefinition renderAnim,
  required Set<AnimKey> oneShotKeys,
}) async {
  final animSet = await loadStripAnimations(
    images,
    frameWidth: renderAnim.frameWidth,
    frameHeight: renderAnim.frameHeight,
    sourcesByKey: renderAnim.sourcesByKey,
    rowByKey: renderAnim.rowByKey,
    anchorInFramePx: renderAnim.anchorInFramePx,
    frameStartByKey: renderAnim.frameStartByKey,
    frameCountsByKey: renderAnim.frameCountsByKey,
    stepTimeSecondsByKey: renderAnim.stepTimeSecondsByKey,
    oneShotKeys: oneShotKeys,
  );

  // Default spawn to idle when no dedicated strip exists.
  animSet.animations[AnimKey.spawn] ??= animSet.animations[AnimKey.idle]!;

  return animSet;
}


===== FILE: lib/game/components/tiled_ground_band_component.dart =====
// Renders a horizontally-tiled ground band (e.g., grass, dirt, platforms).
//
// Supports two rendering modes:
// - **Backdrop mode** (`renderInBackdrop = true`): Renders in screen-space with
//   a fixed virtual viewport. Used for decorative ground in the parallax stack.
// - **World-space mode** (`renderInBackdrop = false`): Renders tiles in world
//   coordinates, following the camera. Used for gameplay-relevant ground.
//
// **Ground Gaps**: Both modes support "gaps" (holes in the ground) by using
// `BlendMode.clear` to punch transparent regions into the tile strip.
//
// **Performance Note**: When gaps are present, `canvas.saveLayer` is used to
// enable the clear blend mode. This incurs GPU overhead due to offscreen
// rasterization. Scenes with many gaps may see performance impact.
import 'dart:ui' as ui;

import 'package:flame/components.dart';
import 'package:flame/game.dart';
import 'package:flutter/painting.dart';

import '../../core/snapshots/static_ground_gap_snapshot.dart';
import '../game_controller.dart';
import '../util/math_util.dart';

/// Renders a horizontally-tiled ground band with optional gap support.
///
/// See file header for rendering mode details and performance considerations.
class TiledGroundBandComponent extends Component
    with HasGameReference<FlameGame> {
  TiledGroundBandComponent({
    required this.assetPath,
    required this.controller,
    this.virtualWidth,
    required this.virtualHeight,
    this.renderInBackdrop = false,
  }) {
    if (renderInBackdrop && virtualWidth == null) {
      throw ArgumentError(
        'virtualWidth is required when renderInBackdrop is true',
      );
    }
  }

  /// Path to the tile image asset (loaded via Flame's image cache).
  final String assetPath;

  /// Game controller providing snapshot data (including ground gaps).
  final GameController controller;

  /// Fixed viewport width for backdrop mode. Required when [renderInBackdrop] is true.
  final int? virtualWidth;

  /// Virtual viewport height; tiles are bottom-aligned to this value.
  final int virtualHeight;

  /// If true, render in screen-space (backdrop); otherwise, render in world-space.
  final bool renderInBackdrop;

  late final ui.Image _image;

  /// Paint with nearest-neighbor filtering for pixel-perfect rendering.
  final Paint _paint = Paint()..filterQuality = FilterQuality.none;

  /// Paint used to "punch holes" for ground gaps.
  final Paint _clearPaint = Paint()..blendMode = ui.BlendMode.clear;

  @override
  Future<void> onLoad() async {
    await super.onLoad();
    _image = await game.images.load(assetPath);
  }

  @override
  void render(ui.Canvas canvas) {
    super.render(canvas);

    final gaps = controller.snapshot.groundGaps;
    final tileW = _image.width;
    final tileH = _image.height;
    final y = (virtualHeight - tileH).toDouble(); // bottom-aligned

    if (renderInBackdrop) {
      _renderBackdropMode(canvas, gaps, tileW, tileH, y);
    } else {
      _renderWorldMode(canvas, gaps, tileW, tileH, y);
    }
  }

  /// Renders tiles in screen-space (fixed virtual viewport).
  void _renderBackdropMode(
    ui.Canvas canvas,
    List<StaticGroundGapSnapshot> gaps,
    int tileW,
    int tileH,
    double y,
  ) {
    final viewWidth = virtualWidth!;
    final halfWidth = viewWidth * 0.5;
    final camX = -game.camera.viewfinder.transform.offset.x;
    final leftWorld = camX - halfWidth;
    final rightWorld = camX + halfWidth;

    double worldToScreenX(double worldX) =>
        roundToPixels(worldX - camX) + halfWidth;

    final startTile = floorDivInt(leftWorld.floor(), tileW) - 1;
    final endTile = floorDivInt(rightWorld.ceil(), tileW) + 1;
    final clipRect = ui.Rect.fromLTWH(
      0,
      0,
      viewWidth.toDouble(),
      virtualHeight.toDouble(),
    );

    _withGapSupport(canvas, clipRect, gaps.isNotEmpty, () {
      for (var tile = startTile; tile <= endTile; tile++) {
        final worldX = (tile * tileW).toDouble();
        final x = worldToScreenX(worldX);
        canvas.drawImage(_image, ui.Offset(x, y), _paint);
      }

      if (gaps.isNotEmpty) {
        final maxX = viewWidth.toDouble();
        for (final gap in gaps) {
          final x0 = worldToScreenX(gap.minX);
          final x1 = worldToScreenX(gap.maxX);
          if (x1 < 0.0 || x0 > maxX) continue;
          if (x1 <= x0) continue;
          canvas.drawRect(ui.Rect.fromLTRB(x0, y, x1, y + tileH), _clearPaint);
        }
      }
    });
  }

  /// Renders tiles in world-space (following camera).
  void _renderWorldMode(
    ui.Canvas canvas,
    List<StaticGroundGapSnapshot> gaps,
    int tileW,
    int tileH,
    double y,
  ) {
    final visible = game.camera.visibleWorldRect;
    final camX = -game.camera.viewfinder.transform.offset.x;
    final left = visible.left.floor();
    final right = visible.right.ceil();

    final startTile = floorDivInt(left, tileW) - 1;
    final endTile = floorDivInt(right, tileW) + 1;

    final clipRect = ui.Rect.fromLTRB(
      visible.left,
      0,
      visible.right,
      virtualHeight.toDouble(),
    );

    _withGapSupport(canvas, clipRect, gaps.isNotEmpty, () {
      for (var tile = startTile; tile <= endTile; tile++) {
        final x = (tile * tileW).toDouble();
        final snappedX = snapWorldToPixelsInCameraSpace1d(x, camX);
        canvas.drawImage(_image, ui.Offset(snappedX, y), _paint);
      }

      if (gaps.isNotEmpty) {
        _clearGapRects(
          canvas,
          gaps: gaps,
          offsetX: 0.0,
          visibleMinX: visible.left,
          visibleMaxX: visible.right,
          y: y,
          height: tileH.toDouble(),
          snapRelativeToCameraX: camX,
        );
      }
    });
  }

  /// Wraps rendering in saveLayer (if gaps exist) or save, then restores.
  ///
  /// When [hasGaps] is true, uses `saveLayer` to enable `BlendMode.clear`.
  /// This has GPU overhead but is necessary for punching transparent holes.
  void _withGapSupport(
    ui.Canvas canvas,
    ui.Rect clipRect,
    bool hasGaps,
    void Function() drawCallback,
  ) {
    if (hasGaps) {
      canvas.saveLayer(clipRect, Paint());
    } else {
      canvas.save();
    }
    canvas.clipRect(clipRect);

    drawCallback();

    canvas.restore();
  }

  /// Punches transparent holes in the tile strip for each gap.
  ///
  /// Uses [_clearPaint] with `BlendMode.clear` to erase pixels. Only draws
  /// gaps that intersect the visible range `[visibleMinX, visibleMaxX]`.
  void _clearGapRects(
    ui.Canvas canvas, {
    required List<StaticGroundGapSnapshot> gaps,
    required double offsetX,
    required double visibleMinX,
    required double visibleMaxX,
    required double y,
    required double height,
    double? snapRelativeToCameraX,
  }) {
    for (final gap in gaps) {
      var x0 = gap.minX + offsetX;
      var x1 = gap.maxX + offsetX;
      if (snapRelativeToCameraX != null) {
        x0 = snapWorldToPixelsInCameraSpace1d(x0, snapRelativeToCameraX);
        x1 = snapWorldToPixelsInCameraSpace1d(x1, snapRelativeToCameraX);
      }
      if (x1 < visibleMinX || x0 > visibleMaxX) continue;
      canvas.drawRect(ui.Rect.fromLTRB(x0, y, x1, y + height), _clearPaint);
    }
  }
}


===== FILE: lib/game/debug/debug_aabb_overlay.dart =====
/// Reusable helper for syncing AABB debug overlays from Core snapshots.
library;

import 'package:flame/components.dart';
import 'package:flutter/widgets.dart';

import '../../core/snapshots/entity_render_snapshot.dart';
import '../util/math_util.dart' as math;

void syncDebugAabbOverlays({
  required Iterable<EntityRenderSnapshot> entities,
  required bool enabled,
  required Component parent,
  required Map<int, RectangleComponent> pool,
  required int priority,
  required Paint paint,
  bool Function(EntityRenderSnapshot e)? include,
  Map<int, EntityRenderSnapshot>? prevById,
  double Function(EntityRenderSnapshot e)? offsetXFor,
  double Function(EntityRenderSnapshot e)? offsetYFor,
  double alpha = 1.0,
  Vector2? cameraCenter,
}) {
  if (!enabled) {
    if (pool.isEmpty) return;
    for (final view in pool.values) {
      view.removeFromParent();
    }
    pool.clear();
    return;
  }

  final seen = <int>{};

  for (final e in entities) {
    if (include != null && !include(e)) continue;
    final size = e.size;
    if (size == null) continue;

    seen.add(e.id);

    var view = pool[e.id];
    if (view == null) {
      view = RectangleComponent(
        size: Vector2(size.x, size.y),
        anchor: Anchor.center,
        paint: paint,
      )..priority = priority;
      pool[e.id] = view;
      parent.add(view);
    } else {
      view.size.setValues(size.x, size.y);
    }

    final prev = prevById == null ? null : prevById[e.id];
    final prevPos = prev?.pos ?? e.pos;
    final prevOffsetX = offsetXFor?.call(prev ?? e) ?? 0.0;
    final prevOffsetY = offsetYFor?.call(prev ?? e) ?? 0.0;
    final offsetX = offsetXFor?.call(e) ?? 0.0;
    final offsetY = offsetYFor?.call(e) ?? 0.0;
    final worldX = math.lerpDouble(
      prevPos.x + prevOffsetX,
      e.pos.x + offsetX,
      alpha,
    );
    final worldY = math.lerpDouble(
      prevPos.y + prevOffsetY,
      e.pos.y + offsetY,
      alpha,
    );
    if (cameraCenter == null) {
      view.position.setValues(
        math.roundToPixels(worldX),
        math.roundToPixels(worldY),
      );
    } else {
      view.position.setValues(
        math.snapWorldToPixelsInCameraSpace1d(worldX, cameraCenter.x),
        math.snapWorldToPixelsInCameraSpace1d(worldY, cameraCenter.y),
      );
    }
  }

  if (pool.isEmpty) return;
  final toRemove = <int>[];
  for (final id in pool.keys) {
    if (!seen.contains(id)) toRemove.add(id);
  }
  for (final id in toRemove) {
    pool.remove(id)?.removeFromParent();
  }
}


===== FILE: lib/game/debug/render_debug_flags.dart =====
/// Render-layer debug flags.
///
/// Kept in `lib/game/**` so Core remains pure/deterministic and unaware of
/// any debug drawing concerns.
library;

import 'package:flutter/foundation.dart';

abstract class RenderDebugFlags {
  /// Draws collision AABB overlays for "actor" entities (player + enemies).
  ///
  /// Default is `false` even in debug builds; toggle locally when needed.
  static bool drawActorHitboxes = false;

  /// Convenience for enabling all render debug overlays in debug/profile
  /// builds while keeping release builds clean.
  static bool get canUseRenderDebug => !kReleaseMode;
}



===== FILE: lib/game/game_controller.dart =====
// Bridge between Core simulation and the Flutter/Flame runtime.
//
// Responsibilities:
// - Owns the `GameCore` instance
// - Queues tick-stamped input commands
// - Runs a fixed-tick simulation loop using an accumulator
// - Exposes (`prevSnapshot`, `snapshot`, `alpha`) for render interpolation
// - Buffers transient `GameEvent`s for Render/UI to consume
import 'dart:math';

import 'package:flutter/foundation.dart';

import '../core/commands/command.dart';
import '../core/enemies/enemy_catalog.dart';
import '../core/events/game_event.dart';
import '../core/game_core.dart';
import '../core/snapshots/game_state_snapshot.dart';
import '../core/tuning/score_tuning.dart';
import 'tick_input_frame.dart';

typedef GameEventListener = void Function(GameEvent event);

/// Owns the simulation clock and provides a stable interface to UI/renderer.
class GameController extends ChangeNotifier {
  GameController({required GameCore core, this.tickHz = 60, this.inputLead = 1})
    : _core = core {
    if (tickHz <= 0) {
      throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
    }
    if (inputLead < 1) {
      throw ArgumentError.value(inputLead, 'inputLead', 'must be >= 1');
    }
    if (tickHz != _core.tickHz) {
      throw ArgumentError(
        'GameController.tickHz ($tickHz) must match GameCore.tickHz (${_core.tickHz}).',
      );
    }
    _curr = _core.buildSnapshot();
    _prev = _curr;
  }

  final GameCore _core;

  /// Fixed simulation tick frequency.
  final int tickHz;

  /// How many ticks ahead local input is scheduled by default.
  ///
  /// `1` means "next tick".
  final int inputLead;

  /// Buffered commands keyed by their target tick.
  final Map<int, TickInputFrame> _inputsByTick = <int, TickInputFrame>{};

  /// Scratch buffer for building command lists without allocation.
  final List<Command> _commandScratch = <Command>[];

  /// Fallback input frame for ticks with no buffered commands.
  final TickInputFrame _frameScratch = TickInputFrame();

  /// Buffered transient events produced by the core.
  final List<GameEvent> _events = <GameEvent>[];

  /// Optional event listeners (render/UI side-effects).
  ///
  /// Listeners are invoked for every event emitted by Core, before events are
  /// buffered into [_events].
  final List<GameEventListener> _eventListeners = <GameEventListener>[];

  /// The most recent [RunEndedEvent], if any.
  ///
  /// Stored separately so UI can access it after events are drained.
  RunEndedEvent? lastRunEndedEvent;

  late GameStateSnapshot _prev;
  late GameStateSnapshot _curr;

  /// Accumulated time for fixed-tick simulation.
  double _accumulatorSeconds = 0;

  /// Current simulation tick (authoritative).
  int get tick => _core.tick;

  ScoreTuning get scoreTuning => _core.scoreTuning;

  EnemyCatalog get enemyCatalog => _core.enemyCatalog;

  /// Latest snapshot produced by the core.
  GameStateSnapshot get snapshot => _curr;

  /// Previous snapshot (used for render interpolation).
  GameStateSnapshot get prevSnapshot => _prev;

  /// Interpolation factor between `prevSnapshot` and `snapshot` for rendering.
  double get alpha {
    final dtTick = 1.0 / tickHz;
    return (_accumulatorSeconds / dtTick).clamp(0, 1);
  }

  /// Enqueues a command to be applied at its declared tick.
  void enqueue(Command command) {
    final frame = _inputsByTick.putIfAbsent(
      command.tick,
      () => TickInputFrame(),
    );
    frame.apply(command);
  }

  /// Helper to schedule a command for the next tick (plus `inputLead`).
  void enqueueForNextTick(Command Function(int tick) factory) {
    enqueue(factory(tick + inputLead));
  }

  /// Drains and clears all buffered transient events.
  List<GameEvent> drainEvents() {
    if (_events.isEmpty) return const <GameEvent>[];
    final drained = List<GameEvent>.unmodifiable(_events);
    _events.clear();
    return drained;
  }

  /// Registers a callback to observe transient [GameEvent]s.
  ///
  /// This is useful for render-only effects (e.g. death animations) that should
  /// not require draining the shared event buffer.
  void addEventListener(GameEventListener listener) {
    if (_eventListeners.contains(listener)) return;
    _eventListeners.add(listener);
  }

  void removeEventListener(GameEventListener listener) {
    _eventListeners.remove(listener);
  }

  /// Pauses/unpauses the simulation.
  void setPaused(bool value) {
    if (_core.paused == value) return;
    _core.paused = value;
    _accumulatorSeconds = 0;
    _prev = _core.buildSnapshot();
    _curr = _prev;
    notifyListeners();
  }

  /// Permanently stops this controller for the current session.
  ///
  /// Use this when leaving the mini-game route (dispose), NOT for backgrounding
  /// (that's what [setPaused] is for).
  ///
  /// What it does:
  /// - pauses the core
  /// - clears queued commands (prevents "stuck input" on next mount)
  /// - clears buffered transient events
  /// - resets interpolation state (accumulator + snapshots)
  void shutdown() {
    // Pause regardless of current state (do NOT early-return like setPaused()).
    _core.paused = true;

    // Drop any in-flight fixed-tick accumulation.
    _accumulatorSeconds = 0;

    // Kill transient buffers so nothing leaks across sessions.
    _inputsByTick.clear();
    _events.clear();

    // Make snapshots consistent with the paused state.
    _curr = _core.buildSnapshot();
    _prev = _curr;
    lastRunEndedEvent = null;
    notifyListeners();
  }

  /// Ends the current run early (player quit).
  ///
  /// Triggers a [RunEndedEvent] with the current score and resets interpolation.
  void giveUp() {
    if (_core.gameOver) return;
    _core.giveUp();
    _accumulatorSeconds = 0;

    _collectCoreEvents();

    _prev = _core.buildSnapshot();
    _curr = _prev;
    notifyListeners();
  }

  /// Advances the simulation clock based on a variable frame delta.
  ///
  /// This uses an accumulator to execute a fixed number of simulation ticks.
  /// [dtSeconds] is clamped to [dtFrameMaxSeconds] (default 100ms) to avoid
  /// "spiral of death" when the app resumes from background or after a lag spike.
  void advanceFrame(double dtSeconds, {double dtFrameMaxSeconds = 0.1}) {
    if (dtSeconds.isNaN || dtSeconds.isInfinite) return;
    if (_core.paused) {
      _accumulatorSeconds = 0;
      return;
    }

    final clamped = max(0.0, min(dtSeconds, dtFrameMaxSeconds));
    _accumulatorSeconds += clamped;

    final dtTick = 1.0 / tickHz;
    var didStep = false;

    while (_accumulatorSeconds >= dtTick) {
      if (_core.paused) {
        _accumulatorSeconds = 0;
        break;
      }
      final nextTick = _core.tick + 1;
      final input = _inputsByTick.remove(nextTick) ?? _frameScratch;
      _applyTickInput(nextTick, input);
      _core.stepOneTick();

      _collectCoreEvents();

      _prev = _curr;
      _curr = _core.buildSnapshot();
      _accumulatorSeconds -= dtTick;
      didStep = true;

      // If the core became paused during the tick (e.g. game over), stop consuming
      // accumulator to avoid an infinite loop.
      if (_core.paused) {
        _accumulatorSeconds = 0;
        break;
      }
    }
    if (didStep) {
      notifyListeners();
    }
  }

  /// Drains events from the core and buffers them for UI consumption.
  ///
  /// Also captures [RunEndedEvent] into [lastRunEndedEvent] for easy access.
  void _collectCoreEvents() {
    final newEvents = _core.drainEvents();
    for (final event in newEvents) {
      if (event is RunEndedEvent) {
        lastRunEndedEvent = event;
      }
      if (_eventListeners.isNotEmpty) {
        for (final listener in _eventListeners) {
          listener(event);
        }
      }
    }
    if (newEvents.isNotEmpty) {
      _events.addAll(newEvents);
    }
  }

  /// Converts a [TickInputFrame] into [Command]s and applies them to the core.
  ///
  /// Uses [_commandScratch] to avoid allocating a new list each tick.
  /// Only non-default values are sent (e.g., zero axis is skipped since the
  /// core treats absence of input as no movement).
  void _applyTickInput(int tick, TickInputFrame input) {
    _commandScratch.clear();

    final axis = input.moveAxis;
    if (axis != 0) {
      _commandScratch.add(MoveAxisCommand(tick: tick, axis: axis));
    }

    if (input.projectileAimDirSet) {
      _commandScratch.add(
        ProjectileAimDirCommand(
          tick: tick,
          x: input.projectileAimDirX,
          y: input.projectileAimDirY,
        ),
      );
    }
    if (input.meleeAimDirSet) {
      _commandScratch.add(
        MeleeAimDirCommand(
          tick: tick,
          x: input.meleeAimDirX,
          y: input.meleeAimDirY,
        ),
      );
    }
    if (input.jumpPressed) {
      _commandScratch.add(JumpPressedCommand(tick: tick));
    }
    if (input.dashPressed) {
      _commandScratch.add(DashPressedCommand(tick: tick));
    }
    if (input.strikePressed) {
      _commandScratch.add(StrikePressedCommand(tick: tick));
    }
    if (input.projectilePressed) {
      _commandScratch.add(ProjectilePressedCommand(tick: tick));
    }
    if (input.secondaryPressed) {
      _commandScratch.add(SecondaryPressedCommand(tick: tick));
    }
    if (input.bonusPressed) {
      _commandScratch.add(BonusPressedCommand(tick: tick));
    }

    _core.applyCommands(_commandScratch);

    // If this is a scratch fallback, it will be reset by the next use anyway.
    // For frames stored in the map we drop the instance after remove().
    input.reset();
  }
}


===== FILE: lib/game/input/aim_preview.dart =====
// Observable aim preview state for the UI layer.
//
// Provides reactive state so that UI widgets (e.g., aim indicators, arrows)
// can listen and update when the player begins aiming, moves the aim direction,
// or releases aim input. This decouples the input router from the rendering layer.
import 'package:flutter/foundation.dart';

/// Immutable snapshot of the current aim preview state.
///
/// - [active]: Whether the player is currently in aiming mode (e.g., touch held).
/// - [hasAim]: Whether a valid aim direction has been determined.
/// - [dirX], [dirY]: The normalized aim direction vector (only meaningful when [hasAim] is true).
class AimPreviewState {
  const AimPreviewState({
    required this.active,
    required this.hasAim,
    required this.dirX,
    required this.dirY,
  });

  /// True when the player is actively aiming (e.g., dragging on the cast button).
  final bool active;

  /// True when a valid direction has been established (drag exceeds dead zone).
  final bool hasAim;

  /// Horizontal component of the normalized aim direction.
  final double dirX;

  /// Vertical component of the normalized aim direction.
  final double dirY;

  /// Default state when the player is not aiming.
  static const AimPreviewState inactive = AimPreviewState(
    active: false,
    hasAim: false,
    dirX: 0,
    dirY: 0,
  );
}

/// Reactive model for aim preview state.
///
/// Extends [ValueNotifier] so UI widgets can listen for changes via
/// [ValueListenableBuilder] or similar patterns. The input layer updates this
/// model as the player interacts with aim controls, and the UI layer consumes
/// it to render visual feedback (e.g., directional arrow, aim reticle).
class AimPreviewModel extends ValueNotifier<AimPreviewState> {
  /// Creates an [AimPreviewModel] initialized to the inactive state.
  AimPreviewModel() : super(AimPreviewState.inactive);

  /// Called when the player starts an aiming gesture (e.g., touch down on cast button).
  ///
  /// Sets [active] to true but [hasAim] remains false until a direction is established.
  void begin() {
    value = const AimPreviewState(
      active: true,
      hasAim: false,
      dirX: 0,
      dirY: 0,
    );
  }

  /// Updates the aim direction during an active aiming gesture.
  ///
  /// [x] and [y] should be the normalized direction vector.
  /// Sets both [active] and [hasAim] to true.
  void updateAim(double x, double y) {
    value = AimPreviewState(active: true, hasAim: true, dirX: x, dirY: y);
  }

  /// Clears the aim direction while keeping the aiming gesture active.
  ///
  /// Used when the drag returns inside the dead zone—player is still touching
  /// but hasn't committed to a direction yet.
  void clearAim() {
    value = const AimPreviewState(
      active: true,
      hasAim: false,
      dirX: 0,
      dirY: 0,
    );
  }

  /// Called when the player ends the aiming gesture (e.g., touch up).
  ///
  /// Resets the model to the fully inactive state.
  void end() {
    value = AimPreviewState.inactive;
  }
}


===== FILE: lib/game/input/aim_quantizer.dart =====
// Utility for quantizing aim direction values.
//
// Quantization reduces floating-point precision to avoid scheduling redundant
// aim commands when the direction changes by negligible amounts. This improves
// determinism and reduces command spam in the input queue.

/// Quantizes aim direction components to a fixed precision.
///
/// By rounding to 1/256 increments, tiny floating-point variations (e.g., from
/// touch jitter) are collapsed into stable values. This ensures:
/// - Fewer redundant [ProjectileAimDirCommand] / [MeleeAimDirCommand] commands.
/// - Consistent behavior across frames when the aim direction is nearly unchanged.
class AimQuantizer {
  /// Private constructor to prevent instantiation; all methods are static.
  const AimQuantizer._();

  /// Quantization scale factor (256 levels per unit).
  ///
  /// Chosen to provide ~0.4% precision, which is imperceptible to players
  /// but sufficient to filter out floating-point noise.
  static const double _aimQuantizeScale = 256.0;

  /// Returns [value] rounded to the nearest 1/256 increment.
  ///
  /// Returns 0 unchanged to preserve exact zero (no aim bias).
  static double quantize(double value) {
    if (value == 0) return 0;
    return (value * _aimQuantizeScale).roundToDouble() / _aimQuantizeScale;
  }
}


===== FILE: lib/game/input/runner_input_router.dart =====
import 'dart:math';

import '../../core/commands/command.dart';
import '../game_controller.dart';
import 'aim_quantizer.dart';

/// Shared input scheduler for multiple input sources (touch + keyboard + mouse).
///
/// - Holds the current continuous inputs (move axis, projectile aim direction).
/// - Schedules them into the GameController for upcoming ticks so Core receives
///   tick-stamped Commands.
/// - Schedules edge-triggered presses (jump/dash/strike/projectile) for the next tick.
///
/// The router distinguishes between:
/// - **Continuous inputs** (movement axis, aim directions): held state is pumped
///   each frame via [pumpHeldInputs], scheduling commands for upcoming ticks.
/// - **Edge-triggered inputs** (jump, dash, strike, projectile): one-shot events
///   scheduled immediately for the next tick via [pressJump], [pressDash], etc.
class RunnerInputRouter {
  /// Creates a router bound to the given [controller].
  RunnerInputRouter({required this.controller});

  /// The game controller that receives scheduled commands.
  final GameController controller;

  /// Input buffering window in seconds.
  ///
  /// This determines how far ahead continuous inputs (move, aim) are scheduled
  /// to smooth over frame rate hitches.
  static const double _inputBufferSeconds = 0.1;

  // ─────────────────────────────────────────────────────────────────────────
  // Movement axis state
  // ─────────────────────────────────────────────────────────────────────────

  /// Current horizontal movement axis in [-1, 1]. Set by touch/keyboard input.
  double _moveAxis = 0;

  /// Last axis value that was scheduled, used to detect changes.
  double _lastScheduledAxis = 0;

  /// Highest tick for which axis commands have been enqueued.
  int _axisScheduledThroughTick = 0;

  // ─────────────────────────────────────────────────────────────────────────
  // Aim state channels
  // ─────────────────────────────────────────────────────────────────────────

  final _AimInputChannel _projectileAim = _AimInputChannel();

  final _AimInputChannel _meleeAim = _AimInputChannel();

  // ─────────────────────────────────────────────────────────────────────────
  // Public setters for continuous inputs
  // ─────────────────────────────────────────────────────────────────────────

  /// Sets the horizontal movement axis (clamped to [-1, 1]).
  ///
  /// Called by joystick or keyboard handlers. The value is held until changed
  /// and pumped to the controller each frame via [pumpHeldInputs].
  void setMoveAxis(double axis) {
    _moveAxis = axis.clamp(-1.0, 1.0);
  }

  /// Sets the projectile aim direction (should be normalized or near-normalized).
  ///
  /// The direction is quantized to reduce floating-point noise. If the quantized
  /// value matches the current aim, the call is a no-op to avoid redundant updates.
  void setProjectileAimDir(double x, double y) => _projectileAim.set(x, y);

  /// Clears the projectile aim direction.
  ///
  /// Called when the player releases the aim input. Subsequent [pumpHeldInputs]
  /// calls will schedule [ClearProjectileAimDirCommand] for upcoming ticks.
  void clearProjectileAimDir() => _projectileAim.clear();

  /// Sets the melee aim direction (should be normalized or near-normalized).
  ///
  /// Quantized similarly to [setProjectileAimDir] to reduce jitter.
  void setMeleeAimDir(double x, double y) => _meleeAim.set(x, y);

  /// Clears the melee aim direction.
  ///
  /// Called when the player releases the melee aim input.
  void clearMeleeAimDir() => _meleeAim.clear();

  // ─────────────────────────────────────────────────────────────────────────
  // Edge-triggered (one-shot) input methods
  // ─────────────────────────────────────────────────────────────────────────

  /// Schedules a jump press for the next tick.
  void pressJump() =>
      controller.enqueueForNextTick((tick) => JumpPressedCommand(tick: tick));

  /// Schedules a dash press for the next tick.
  void pressDash() =>
      controller.enqueueForNextTick((tick) => DashPressedCommand(tick: tick));

  /// Schedules a melee strike press for the next tick.
  void pressStrike() =>
      controller.enqueueForNextTick((tick) => StrikePressedCommand(tick: tick));

  /// Schedules a projectile slot press for the next tick.
  void pressProjectile() => controller.enqueueForNextTick(
        (tick) => ProjectilePressedCommand(tick: tick),
      );

  /// Schedules a secondary-slot press for the next tick.
  void pressSecondary() =>
      controller.enqueueForNextTick((tick) => SecondaryPressedCommand(tick: tick));

  /// Schedules a bonus-slot press for the next tick.
  void pressBonus() =>
      controller.enqueueForNextTick((tick) => BonusPressedCommand(tick: tick));

  // ─────────────────────────────────────────────────────────────────────────
  // Combined action methods (aim + action in a single tick)
  // ─────────────────────────────────────────────────────────────────────────

  /// Presses projectile on the next tick and ensures the projectile aim direction
  /// is set for the same tick.
  void pressProjectileWithAim() {
    commitProjectileWithAim(clearAim: false);
  }

  /// Commits projectile on the next tick using the current projectile aim dir (if set).
  ///
  /// When [clearAim] is true, clear commands are delayed until after the commit
  /// tick to avoid overwriting the aimed shot.
  void commitProjectileWithAim({required bool clearAim}) {
    final tick = controller.tick + controller.inputLead;
    final hadAim = _projectileAim.isSet;
    if (hadAim) {
      controller.enqueue(
        ProjectileAimDirCommand(
          tick: tick,
          x: _projectileAim.x,
          y: _projectileAim.y,
        ),
      );
    }

    controller.enqueue(ProjectilePressedCommand(tick: tick));

    if (clearAim) {
      _projectileAim.clear();
      if (hadAim) {
        // Prevent immediate clear command from overwriting the aim we just committed
        _projectileAim.blockClearThrough(tick);
      }
    }
  }

  /// Commits the bonus ability while preserving the current aim direction.
  ///
  /// Bonus can host projectile or melee abilities; [usesMeleeAim] selects which
  /// aim channel is consumed by the equipped bonus ability.
  void commitBonusWithAim({
    required bool clearAim,
    required bool usesMeleeAim,
  }) {
    final tick = controller.tick + controller.inputLead;
    final channel = usesMeleeAim ? _meleeAim : _projectileAim;
    final hadAim = channel.isSet;

    if (hadAim) {
      controller.enqueue(
        usesMeleeAim
            ? MeleeAimDirCommand(tick: tick, x: channel.x, y: channel.y)
            : ProjectileAimDirCommand(tick: tick, x: channel.x, y: channel.y),
      );
    }

    controller.enqueue(BonusPressedCommand(tick: tick));

    if (clearAim) {
      channel.clear();
      if (hadAim) {
        // Prevent immediate clear command from overwriting the aim we just committed.
        channel.blockClearThrough(tick);
      }
    }
  }


  /// Commits a melee strike on the next tick using the current melee aim dir.
  void commitMeleeStrike() {
    final tick = controller.tick + controller.inputLead;
    final hadAim = _meleeAim.isSet;
    if (hadAim) {
      controller.enqueue(
        MeleeAimDirCommand(tick: tick, x: _meleeAim.x, y: _meleeAim.y),
      );
    } else {
      controller.enqueue(ClearMeleeAimDirCommand(tick: tick));
    }
    controller.enqueue(StrikePressedCommand(tick: tick));

    // Clear aim after commit (release behavior).
    _meleeAim.clear();
    if (hadAim) {
      _meleeAim.blockClearThrough(tick);
    }
  }

  // ─────────────────────────────────────────────────────────────────────────
  // Frame pump: schedule continuous inputs for upcoming ticks
  // ─────────────────────────────────────────────────────────────────────────

  /// Schedules the current held inputs across upcoming ticks.
  ///
  /// This method should be called once per frame, before `controller.advanceFrame(dt)`,
  /// to ensure that continuous inputs (movement, aim) are scheduled far enough
  /// ahead that the simulation always has input data available.
  ///
  /// The scheduling window extends `inputLead + maxTicksPerFrame` ticks into the
  /// future to handle variable frame rates without input starvation.
  void pumpHeldInputs() {
    // 1. Movement: enqueue MoveAxisCommand for upcoming ticks (or overwrite if axis changed).
    _scheduleHeldMoveAxis();

    // 2. Projectile aim: enqueue aim direction or clear commands for upcoming ticks.
    _projectileAim.schedule(
      controller,
      _inputBufferSeconds,
      (t, x, y) => ProjectileAimDirCommand(tick: t, x: x, y: y),
      (t) => ClearProjectileAimDirCommand(tick: t),
    );

    // 3. Melee aim: same pattern as projectile, but for melee strike direction.
    _meleeAim.schedule(
      controller,
      _inputBufferSeconds,
      (t, x, y) => MeleeAimDirCommand(tick: t, x: x, y: y),
      (t) => ClearMeleeAimDirCommand(tick: t),
    );

  }

  /// Schedules [MoveAxisCommand]s for upcoming ticks based on the current axis value.
  ///
  /// Detects axis changes and re-schedules to overwrite any already-buffered ticks.
  void _scheduleHeldMoveAxis() {
    final axis = _moveAxis;

    if (axis == 0 && _lastScheduledAxis == 0) {
      // No held axis and nothing to override.
      _axisScheduledThroughTick = controller.tick;
      return;
    }

    if (axis != _lastScheduledAxis) {
      // Axis changed (including to 0); reschedule to overwrite any already
      // buffered ticks.
      _axisScheduledThroughTick = controller.tick;
      _lastScheduledAxis = axis;
    }

    final maxTicksPerFrame = (controller.tickHz * _inputBufferSeconds).ceil();
    final targetMaxTick =
        controller.tick + controller.inputLead + maxTicksPerFrame;

    final startTick = max(controller.tick + 1, _axisScheduledThroughTick + 1);
    for (var t = startTick; t <= targetMaxTick; t += 1) {
      controller.enqueue(MoveAxisCommand(tick: t, axis: axis));
    }
    _axisScheduledThroughTick = targetMaxTick;
  }
}

/// Helper class to encapsulate the state and scheduling logic for a single aim input (e.g., Projectile or Melee).
class _AimInputChannel {
  /// Whether an aim direction is currently set.
  bool isSet = false;

  /// The X component of the current aim direction (quantized).
  double x = 0;

  /// The Y component of the current aim direction (quantized).
  double y = 0;

  // -- Scheduling State --

  /// Whether the aim was set during the last schedule pass.
  bool _lastScheduledSet = false;

  /// The X component scheduled during the last pass.
  double _lastScheduledX = 0;

  /// The Y component scheduled during the last pass.
  double _lastScheduledY = 0;

  /// The highest tick for which we have already scheduled aim commands.
  int _scheduledThroughTick = 0;

  /// Tick through which clear commands are blocked.
  ///
  /// This is used when a "commit" action (like firing a projectile) uses the aim, and we want
  /// to ensure the subsequent clear command doesn't overwrite it in the same tick.
  int _clearBlockedThroughTick = 0;

  /// Updates the aim direction.
  void set(double rawX, double rawY) {
    final qx = AimQuantizer.quantize(rawX);
    final qy = AimQuantizer.quantize(rawY);

    if (isSet && qx == x && qy == y) {
      return;
    }

    isSet = true;
    x = qx;
    y = qy;
  }

  /// Clears the aim direction.
  void clear() {
    isSet = false;
    x = 0;
    y = 0;
  }

  /// Prevents `Clear...Command` from being scheduled up to and including [tick].
  void blockClearThrough(int tick) {
    _clearBlockedThroughTick = max(_clearBlockedThroughTick, tick);
  }

  /// Schedules aim or clear commands for upcoming ticks.
  ///
  /// [bufferSeconds] determines how far ahead to schedule.
  /// [createAimCmd] factory for the specific aim command (Projectile vs Melee).
  /// [createClearCmd] factory for the specific clear command.
  void schedule(
    GameController controller,
    double bufferSeconds,
    Command Function(int tick, double x, double y) createAimCmd,
    Command Function(int tick) createClearCmd,
  ) {
    if (!isSet && !_lastScheduledSet) {
      // No held aim and nothing to override.
      _scheduledThroughTick = controller.tick;
      return;
    }

    if (isSet != _lastScheduledSet) {
      // Aim active state changed; force reschedule from current tick to overwrite buffers.
      _scheduledThroughTick = controller.tick;
      _lastScheduledSet = isSet;
      _lastScheduledX = x;
      _lastScheduledY = y;
    }

    if (isSet && (x != _lastScheduledX || y != _lastScheduledY)) {
      // Vector changed; force reschedule from current tick.
      _scheduledThroughTick = controller.tick;
      _lastScheduledX = x;
      _lastScheduledY = y;
    }

    final maxTicksPerFrame = (controller.tickHz * bufferSeconds).ceil();
    final targetMaxTick =
        controller.tick + controller.inputLead + maxTicksPerFrame;

    var startTick = max(controller.tick + 1, _scheduledThroughTick + 1);

    // If we are clearing aim, ensure we don't overwrite a committed action tick.
    if (!isSet) {
      startTick = max(startTick, _clearBlockedThroughTick + 1);
    }

    for (var t = startTick; t <= targetMaxTick; t += 1) {
      if (isSet) {
        controller.enqueue(createAimCmd(t, x, y));
      } else {
        controller.enqueue(createClearCmd(t));
      }
    }
    _scheduledThroughTick = targetMaxTick;
  }
}


===== FILE: lib/game/runner_flame_game.dart =====
// Flame rendering layer for the runner (Milestone 0 placeholder).
//
// Reads the latest `GameStateSnapshot` from `GameController` each frame and
// renders a minimal representation (a player dot + debug text). This file is
// intentionally tiny and non-authoritative: gameplay truth lives in Core.
import 'package:flame/components.dart';
import 'package:flame/game.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/widgets.dart';

import '../core/contracts/render_contract.dart';
import '../core/events/game_event.dart';
import '../core/players/player_character_definition.dart';
import '../core/snapshots/entity_render_snapshot.dart';
import '../core/snapshots/enums.dart';
import '../core/snapshots/static_solid_snapshot.dart';
import 'debug/debug_aabb_overlay.dart';
import 'debug/render_debug_flags.dart';
import 'components/player/player_animations.dart';
import 'components/player/player_view_component.dart';
import 'components/enemies/enemy_render_registry.dart';
import 'components/pickups/pickup_render_registry.dart';
import 'components/projectiles/projectile_render_registry.dart';
import 'components/sprite_anim/deterministic_anim_view_component.dart';
import 'tuning/player_render_tuning.dart';
import 'input/runner_input_router.dart';
import 'input/aim_preview.dart';
import 'components/pixel_parallax_backdrop_component.dart';
import 'components/tiled_ground_band_component.dart';
import 'components/aim_ray_component.dart';
import 'game_controller.dart';
import 'themes/parallax_theme_registry.dart';
import 'util/math_util.dart' as math;

// ─────────────────────────────────────────────────────────────────────────────
// Render priorities
// ─────────────────────────────────────────────────────────────────────────────

const _priorityBackgroundParallax = -30;
const _priorityGroundTiles = -20;
const _priorityForegroundParallax = -10;
const _priorityStaticSolids = -5;
const _priorityPlayer = -3;
const _priorityEnemies = -2;
const _priorityProjectiles = -1;
const _priorityCollectibles = -1;
const _priorityHitboxes = 1;
const _priorityActorHitboxes = 2;
const _priorityProjectileAimRay = 5;
const _priorityMeleeAimRay = 6;
const PlayerRenderTuning _playerRenderTuning = PlayerRenderTuning();

enum RunLoadPhase {
  start,
  themeResolved,
  parallaxMounted,
  playerAnimationsLoaded,
  registriesLoaded,
  worldReady,
}

@immutable
class RunLoadState {
  const RunLoadState({required this.phase, required this.progress});

  final RunLoadPhase phase;
  final double progress;

  static const RunLoadState initial = RunLoadState(
    phase: RunLoadPhase.start,
    progress: 0.0,
  );
}

/// Minimal Flame `Game` that renders from snapshots.
class RunnerFlameGame extends FlameGame {
  RunnerFlameGame({
    required this.controller,
    required this.input,
    required this.projectileAimPreview,
    required this.meleeAimPreview,
    required this.playerCharacter,
  }) : _enemyRenderRegistry = EnemyRenderRegistry(
         enemyCatalog: controller.enemyCatalog,
       ),
       _projectileRenderRegistry = ProjectileRenderRegistry(),
       _pickupRenderRegistry = PickupRenderRegistry(),
       super(
         camera: CameraComponent.withFixedResolution(
           width: virtualWidth.toDouble(),
           height: virtualHeight.toDouble(),
         ),
       );

  /// Bridge/controller that owns the simulation and produces snapshots.
  final GameController controller;

  /// Input scheduler/aggregator (touch + keyboard + mouse).
  final RunnerInputRouter input;

  /// UI-driven aim preview (render-only).
  final ValueListenable<AimPreviewState> projectileAimPreview;
  final ValueListenable<AimPreviewState> meleeAimPreview;

  /// The selected player character definition for this run (render-only usage).
  final PlayerCharacterDefinition playerCharacter;

  /// UI-facing load progress for the run route.
  final ValueNotifier<RunLoadState> loadState = ValueNotifier<RunLoadState>(
    RunLoadState.initial,
  );

  late final PlayerViewComponent _player;
  final EnemyRenderRegistry _enemyRenderRegistry;
  final ProjectileRenderRegistry _projectileRenderRegistry;
  final PickupRenderRegistry _pickupRenderRegistry;
  final List<RectangleComponent> _staticSolids = <RectangleComponent>[];
  List<StaticSolidSnapshot>? _lastStaticSolidsSnapshot;

  /// Entity view pools, keyed by entity ID.
  final Map<int, DeterministicAnimViewComponent> _projectileAnimViews =
      <int, DeterministicAnimViewComponent>{};
  final Map<int, DeterministicAnimViewComponent> _pickupAnimViews =
      <int, DeterministicAnimViewComponent>{};
  final Map<int, DeterministicAnimViewComponent> _enemies =
      <int, DeterministicAnimViewComponent>{};
  final Map<int, RectangleComponent> _hitboxes = <int, RectangleComponent>{};
  final Map<int, RectangleComponent> _actorHitboxes =
      <int, RectangleComponent>{};

  final Paint _hitboxPaint = Paint()..color = const Color(0x66EF4444);
  final Paint _actorHitboxPaint = Paint()
    ..color = const Color(0xFF22C55E)
    ..style = PaintingStyle.stroke
    ..strokeWidth = 1.0;

  final Map<int, EntityRenderSnapshot> _prevEntitiesById =
      <int, EntityRenderSnapshot>{};
  final Map<int, int> _projectileSpawnTicks = <int, int>{};
  final Set<int> _seenIdsScratch = <int>{};
  final List<int> _toRemoveScratch = <int>[];
  final Vector2 _cameraCenterScratch = Vector2.zero();
  final Vector2 _snapScratch = Vector2.zero();
  final List<ProjectileHitEvent> _pendingProjectileHitEvents =
      <ProjectileHitEvent>[];

  @override
  Future<void> onLoad() async {
    await super.onLoad();
    assert(() {
      playerCharacter.assertValid();
      return true;
    }());
    controller.addEventListener(_handleGameEvent);
    final theme = ParallaxThemeRegistry.forThemeId(controller.snapshot.themeId);
    _setLoadState(RunLoadPhase.themeResolved, 0.15);

    // Background parallax layers (sky, distant mountains, etc.)
    camera.backdrop.add(
      PixelParallaxBackdropComponent(
        virtualWidth: virtualWidth,
        virtualHeight: virtualHeight,
        snapScrollToPixels: false,
        layers: theme.backgroundLayers,
      )..priority = _priorityBackgroundParallax,
    );

    // Ground tiles (with gap support)
    camera.backdrop.add(
      TiledGroundBandComponent(
        assetPath: theme.groundLayerAsset,
        controller: controller,
        virtualWidth: virtualWidth,
        virtualHeight: virtualHeight,
        renderInBackdrop: true,
      )..priority = _priorityGroundTiles,
    );

    // Foreground parallax layers (grass, bushes, etc.)
    camera.backdrop.add(
      PixelParallaxBackdropComponent(
        virtualWidth: virtualWidth,
        virtualHeight: virtualHeight,
        snapScrollToPixels: false,
        layers: theme.foregroundLayers,
      )..priority = _priorityForegroundParallax,
    );
    _setLoadState(RunLoadPhase.parallaxMounted, 0.35);

    final playerAnimations = await loadPlayerAnimations(
      images,
      renderAnim: playerCharacter.renderAnim,
    );
    _setLoadState(RunLoadPhase.playerAnimationsLoaded, 0.55);
    await _enemyRenderRegistry.load(images);
    await _projectileRenderRegistry.load(images);
    await _pickupRenderRegistry.load(images);
    _setLoadState(RunLoadPhase.registriesLoaded, 0.8);
    _player = PlayerViewComponent(
      animationSet: playerAnimations,
      renderScale: Vector2.all(_playerRenderTuning.scale),
    )..priority = _priorityPlayer;
    world.add(_player);

    world.add(
      AimRayComponent(
        controller: controller,
        preview: projectileAimPreview,
        length: projectileAimRayLength,
        playerRenderPos: () => _player.position,
        drawWhenNoAim: false,
      )..priority = _priorityProjectileAimRay,
    );

    world.add(
      AimRayComponent(
        controller: controller,
        preview: meleeAimPreview,
        length: meleeAimRayLength,
        playerRenderPos: () => _player.position,
        drawWhenNoAim: false,
        paint: Paint()
          ..color = const Color(0xFFDC4440)
          ..strokeWidth = 2
          ..strokeCap = StrokeCap.round,
      )..priority = _priorityMeleeAimRay,
    );

    _mountStaticSolids(controller.snapshot.staticSolids);
    _lastStaticSolidsSnapshot = controller.snapshot.staticSolids;
    _setLoadState(RunLoadPhase.worldReady, 1.0);
  }

  @override
  void update(double dt) {
    final snapshot = controller.snapshot;
    if (!snapshot.paused && !snapshot.gameOver) {
      input.pumpHeldInputs();
    }

    // Step the deterministic core using the frame delta, then render the newest
    // snapshot. This order is critical: Flame components (parallax, etc.) read
    // the camera during their own update(), so Core + camera + view sync must
    // run BEFORE super.update(dt).
    controller.advanceFrame(dt);

    final prevSnapshot = controller.prevSnapshot;
    final currSnapshot = controller.snapshot;
    final alpha = controller.alpha;

    _prevEntitiesById.clear();
    for (final e in prevSnapshot.entities) {
      _prevEntitiesById[e.id] = e;
    }

    final camX = math.lerpDouble(
      prevSnapshot.cameraCenterX,
      currSnapshot.cameraCenterX,
      alpha,
    );
    final camY = math.lerpDouble(
      prevSnapshot.cameraCenterY,
      currSnapshot.cameraCenterY,
      alpha,
    );
    _cameraCenterScratch.setValues(camX, camY);
    camera.viewfinder.position = _cameraCenterScratch;

    _syncStaticSolids(currSnapshot.staticSolids);
    _snapStaticSolids(
      currSnapshot.staticSolids,
      cameraCenter: _cameraCenterScratch,
    );

    final player = currSnapshot.playerEntity;
    if (player != null) {
      final prev = _prevEntitiesById[player.id] ?? player;
      final worldX = math.lerpDouble(prev.pos.x, player.pos.x, alpha);
      final worldY = math.lerpDouble(prev.pos.y, player.pos.y, alpha);
      _snapScratch.setValues(
        math.snapWorldToPixelsInCameraSpace1d(worldX, _cameraCenterScratch.x),
        math.snapWorldToPixelsInCameraSpace1d(worldY, _cameraCenterScratch.y),
      );
      _player.applySnapshot(
        player,
        tickHz: controller.tickHz,
        pos: _snapScratch,
      );
    }

    _syncEnemies(
      currSnapshot.entities,
      prevById: _prevEntitiesById,
      alpha: alpha,
      cameraCenter: _cameraCenterScratch,
    );
    _syncProjectiles(
      currSnapshot.entities,
      prevById: _prevEntitiesById,
      alpha: alpha,
      cameraCenter: _cameraCenterScratch,
      tick: currSnapshot.tick,
    );
    _syncCollectibles(
      currSnapshot.entities,
      prevById: _prevEntitiesById,
      alpha: alpha,
      cameraCenter: _cameraCenterScratch,
    );
    final drawHitboxes =
        RenderDebugFlags.canUseRenderDebug &&
        RenderDebugFlags.drawActorHitboxes;
    if (drawHitboxes) {
      _syncHitboxes(
        currSnapshot.entities,
        prevById: _prevEntitiesById,
        alpha: alpha,
        cameraCenter: _cameraCenterScratch,
      );
    } else if (_hitboxes.isNotEmpty) {
      for (final view in _hitboxes.values) {
        view.removeFromParent();
      }
      _hitboxes.clear();
    }
    syncDebugAabbOverlays(
      entities: currSnapshot.entities,
      enabled:
          RenderDebugFlags.canUseRenderDebug &&
          RenderDebugFlags.drawActorHitboxes,
      parent: world,
      pool: _actorHitboxes,
      priority: _priorityActorHitboxes,
      paint: _actorHitboxPaint,
      include: (e) => e.kind == EntityKind.player || e.kind == EntityKind.enemy,
      prevById: _prevEntitiesById,
      offsetXFor: (e) {
        switch (e.kind) {
          case EntityKind.player:
            return playerCharacter.catalog.colliderOffsetX;
          case EntityKind.enemy:
            final enemyId = e.enemyId;
            if (enemyId == null) return 0.0;
            return controller.enemyCatalog.get(enemyId).collider.offsetX;
          default:
            return 0.0;
        }
      },
      offsetYFor: (e) {
        switch (e.kind) {
          case EntityKind.player:
            return playerCharacter.catalog.colliderOffsetY;
          case EntityKind.enemy:
            final enemyId = e.enemyId;
            if (enemyId == null) return 0.0;
            return controller.enemyCatalog.get(enemyId).collider.offsetY;
          default:
            return 0.0;
        }
      },
      alpha: alpha,
      cameraCenter: _cameraCenterScratch,
    );

    _flushPendingProjectileHitEvents(cameraCenter: _cameraCenterScratch);

    super.update(dt);
  }

  /// Mounts static solid rectangles into the world.
  ///
  /// Called once on load and whenever the static solids list changes.
  /// One-way platforms are rendered with a green tint, solid platforms with
  /// purple.
  void _mountStaticSolids(List<StaticSolidSnapshot> solids) {
    if (solids.isEmpty) return;

    for (final solid in solids) {
      final color = solid.oneWayTop
          ? const Color(0x6648BB78) // green-ish translucent
          : const Color(0x668B5CF6); // purple translucent

      final rect = RectangleComponent(
        position: Vector2(solid.minX, solid.minY),
        size: Vector2(solid.maxX - solid.minX, solid.maxY - solid.minY),
        paint: Paint()..color = color,
      );
      rect.priority = _priorityStaticSolids;
      _staticSolids.add(rect);
      world.add(rect);
    }
  }

  /// Synchronizes enemy view components with the snapshot.
  ///
  /// Creates view components for new enemies, updates existing ones, and
  /// removes components for despawned enemies.
  void _syncEnemies(
    List<EntityRenderSnapshot> entities, {
    required Map<int, EntityRenderSnapshot> prevById,
    required double alpha,
    required Vector2 cameraCenter,
  }) {
    final seen = _seenIdsScratch..clear();

    for (final e in entities) {
      if (e.kind != EntityKind.enemy) continue;

      final entry = e.enemyId == null
          ? null
          : _enemyRenderRegistry.entryFor(e.enemyId!);
      if (entry == null) {
        _enemies.remove(e.id)?.removeFromParent();
        continue;
      }

      seen.add(e.id);

      var view = _enemies[e.id];
      if (view == null) {
        view = entry.viewFactory(entry.animSet, entry.renderScale)
          ..priority = _priorityEnemies;
        _enemies[e.id] = view;
        world.add(view);
      }

      final prev = prevById[e.id] ?? e;
      final worldX = math.lerpDouble(prev.pos.x, e.pos.x, alpha);
      final worldY = math.lerpDouble(prev.pos.y, e.pos.y, alpha);
      final snappedX = math.snapWorldToPixelsInCameraSpace1d(
        worldX,
        cameraCenter.x,
      );
      final snappedY = math.snapWorldToPixelsInCameraSpace1d(
        worldY,
        cameraCenter.y,
      );

      _snapScratch.setValues(snappedX, snappedY);
      view.applySnapshot(e, tickHz: controller.tickHz, pos: _snapScratch);
    }

    if (_enemies.isEmpty) return;
    final toRemove = _toRemoveScratch..clear();
    for (final id in _enemies.keys) {
      if (!seen.contains(id)) toRemove.add(id);
    }
    for (final id in toRemove) {
      _enemies.remove(id)?.removeFromParent();
    }
  }

  void _handleGameEvent(GameEvent event) {
    if (event is ProjectileHitEvent) {
      _pendingProjectileHitEvents.add(event);
    }
  }

  void _flushPendingProjectileHitEvents({required Vector2 cameraCenter}) {
    if (_pendingProjectileHitEvents.isEmpty) return;

    for (final event in _pendingProjectileHitEvents) {
      final entry = _projectileRenderRegistry.entryFor(event.projectileId);
      if (entry == null) continue;

      final hitAnim = entry.animSet.animations[AnimKey.hit];
      if (hitAnim == null) continue;

      final component = _CameraSpaceSnappedSpriteAnimationComponent(
        animation: hitAnim,
        size: entry.animSet.frameSize.clone(),
        worldPosX: event.pos.x,
        worldPosY: event.pos.y,
        anchor: entry.animSet.anchor,
        paint: Paint()..filterQuality = FilterQuality.none,
        removeOnFinish: true,
      )..priority = _priorityProjectiles;

      component.scale.setValues(entry.renderScale.x, entry.renderScale.y);
      component.angle = event.rotationRad;
      component.snapToCamera(cameraCenter);
      world.add(component);
    }

    _pendingProjectileHitEvents.clear();
  }

  /// Synchronizes projectile view components with the snapshot.
  ///
  /// Creates rectangle components for new projectiles, updates position/size
  /// for existing ones, and removes components for despawned projectiles.
  void _syncProjectiles(
    List<EntityRenderSnapshot> entities, {
    required Map<int, EntityRenderSnapshot> prevById,
    required double alpha,
    required Vector2 cameraCenter,
    required int tick,
  }) {
    final seen = _seenIdsScratch..clear();

    for (final e in entities) {
      if (e.kind != EntityKind.projectile) continue;
      seen.add(e.id);

      final projectileId = e.projectileId;
      final entry = projectileId == null
          ? null
          : _projectileRenderRegistry.entryFor(projectileId);

      if (entry != null) {
        var view = _projectileAnimViews[e.id];
        if (view == null) {
          view = entry.viewFactory(entry.animSet, entry.renderScale);
          view.priority = _priorityProjectiles;
          _projectileAnimViews[e.id] = view;
          _projectileSpawnTicks[e.id] = tick;
          world.add(view);
        }

        final prev = prevById[e.id] ?? e;
        final worldX = math.lerpDouble(prev.pos.x, e.pos.x, alpha);
        final worldY = math.lerpDouble(prev.pos.y, e.pos.y, alpha);
        _snapScratch.setValues(
          math.snapWorldToPixelsInCameraSpace1d(worldX, cameraCenter.x),
          math.snapWorldToPixelsInCameraSpace1d(worldY, cameraCenter.y),
        );

        final spawnTick = _projectileSpawnTicks[e.id] ?? tick;
        final startTicks = entry.spawnAnimTicks(controller.tickHz);
        final ageTicks = tick - spawnTick;
        final animOverride =
            startTicks > 0 && ageTicks >= 0 && ageTicks < startTicks
            ? AnimKey.spawn
            : AnimKey.idle;
        final overrideAnimFrame = animOverride == AnimKey.spawn
            ? ageTicks
            : null;

        view.applySnapshot(
          e,
          tickHz: controller.tickHz,
          pos: _snapScratch,
          overrideAnim: animOverride,
          overrideAnimFrame: overrideAnimFrame,
        );
        final spinSpeed = entry.spinSpeedRadPerSecond;
        if (spinSpeed == 0.0) {
          view.angle = e.rotationRad;
        } else {
          final spinSeconds = (ageTicks.toDouble() + alpha) / controller.tickHz;
          view.angle = e.rotationRad + spinSpeed * spinSeconds;
        }
      } else {
        // No fallback rendering for unknown/unregistered projectiles.
        //
        // If the projectile exists in Core but has no render wiring (or assets),
        // we simply avoid rendering it rather than using placeholder rectangles.
        _projectileAnimViews.remove(e.id)?.removeFromParent();
        _projectileSpawnTicks.remove(e.id);
      }
    }

    if (_projectileAnimViews.isNotEmpty) {
      final toRemove = _toRemoveScratch..clear();
      for (final id in _projectileAnimViews.keys) {
        if (!seen.contains(id)) toRemove.add(id);
      }
      for (final id in toRemove) {
        _projectileAnimViews.remove(id)?.removeFromParent();
        _projectileSpawnTicks.remove(id);
      }
    }
  }

  /// Synchronizes collectible/pickup view components with the snapshot.
  ///
  /// Creates deterministic animation components for pickups and removes
  /// components for collected pickups.
  void _syncCollectibles(
    List<EntityRenderSnapshot> entities, {
    required Map<int, EntityRenderSnapshot> prevById,
    required double alpha,
    required Vector2 cameraCenter,
  }) {
    final seen = _seenIdsScratch..clear();

    for (final e in entities) {
      if (e.kind != EntityKind.pickup) continue;
      seen.add(e.id);

      final variant = e.pickupVariant ?? PickupVariant.collectible;
      final entry = _pickupRenderRegistry.entryForVariant(variant);

      var view = _pickupAnimViews[e.id];
      if (view == null) {
        view = entry.viewFactory(entry.animSet, entry.renderScale);
        view.priority = _priorityCollectibles;
        _pickupAnimViews[e.id] = view;
        world.add(view);
      }

      final prev = prevById[e.id] ?? e;
      final worldX = math.lerpDouble(prev.pos.x, e.pos.x, alpha);
      final worldY = math.lerpDouble(prev.pos.y, e.pos.y, alpha);
      _snapScratch.setValues(
        math.snapWorldToPixelsInCameraSpace1d(worldX, cameraCenter.x),
        math.snapWorldToPixelsInCameraSpace1d(worldY, cameraCenter.y),
      );
      view.applySnapshot(e, tickHz: controller.tickHz, pos: _snapScratch);
      view.angle = e.rotationRad;
    }

    if (_pickupAnimViews.isEmpty) return;
    final toRemove = _toRemoveScratch..clear();
    for (final id in _pickupAnimViews.keys) {
      if (!seen.contains(id)) toRemove.add(id);
    }
    for (final id in toRemove) {
      _pickupAnimViews.remove(id)?.removeFromParent();
    }
  }

  /// Synchronizes trigger/hitbox view components with the snapshot.
  ///
  /// Creates translucent red rectangle components for new triggers, updates
  /// position/size for existing ones, and removes components for despawned
  /// triggers.
  void _syncHitboxes(
    List<EntityRenderSnapshot> entities, {
    required Map<int, EntityRenderSnapshot> prevById,
    required double alpha,
    required Vector2 cameraCenter,
  }) {
    final seen = _seenIdsScratch..clear();

    for (final e in entities) {
      if (e.kind != EntityKind.trigger) continue;
      seen.add(e.id);

      var view = _hitboxes[e.id];
      if (view == null) {
        final size = e.size;
        view = RectangleComponent(
          size: Vector2(size?.x ?? 8.0, size?.y ?? 8.0),
          anchor: Anchor.center,
          paint: _hitboxPaint,
        );
        view.priority = _priorityHitboxes;
        _hitboxes[e.id] = view;
        world.add(view);
      } else {
        final size = e.size;
        if (size != null) {
          view.size.setValues(size.x, size.y);
        }
      }

      final prev = prevById[e.id] ?? e;
      final worldX = math.lerpDouble(prev.pos.x, e.pos.x, alpha);
      final worldY = math.lerpDouble(prev.pos.y, e.pos.y, alpha);
      view.position.setValues(
        math.snapWorldToPixelsInCameraSpace1d(worldX, cameraCenter.x),
        math.snapWorldToPixelsInCameraSpace1d(worldY, cameraCenter.y),
      );
    }

    if (_hitboxes.isEmpty) return;
    final toRemove = _toRemoveScratch..clear();
    for (final id in _hitboxes.keys) {
      if (!seen.contains(id)) toRemove.add(id);
    }
    for (final id in toRemove) {
      _hitboxes.remove(id)?.removeFromParent();
    }
  }

  /// Synchronizes static solid views with the snapshot.
  ///
  /// Uses identity comparison as a cheap version check since Core rebuilds
  /// the list only when geometry actually changes (spawn/cull).
  void _syncStaticSolids(List<StaticSolidSnapshot> solids) {
    // Core rebuilds the list only when geometry changes (spawn/cull),
    // so identity check is a cheap "version" check.
    if (identical(solids, _lastStaticSolidsSnapshot)) return;
    _lastStaticSolidsSnapshot = solids;

    for (final c in _staticSolids) {
      c.removeFromParent();
    }
    _staticSolids.clear();

    _mountStaticSolids(solids);
  }

  void _snapStaticSolids(
    List<StaticSolidSnapshot> solids, {
    required Vector2 cameraCenter,
  }) {
    if (solids.isEmpty) return;
    if (_staticSolids.length != solids.length) return;

    for (var i = 0; i < solids.length; i++) {
      final solid = solids[i];
      final view = _staticSolids[i];
      view.position.setValues(
        math.snapWorldToPixelsInCameraSpace1d(solid.minX, cameraCenter.x),
        math.snapWorldToPixelsInCameraSpace1d(solid.minY, cameraCenter.y),
      );
    }
  }

  @override
  void onRemove() {
    controller.removeEventListener(_handleGameEvent);
    images.clearCache();
    super.onRemove();
  }

  @override
  void onDispose() {
    loadState.dispose();
    super.onDispose();
  }

  void _setLoadState(RunLoadPhase phase, double progress) {
    final clamped = progress.clamp(0.0, 1.0);
    loadState.value = RunLoadState(phase: phase, progress: clamped);
  }
}

class _CameraSpaceSnappedSpriteAnimationComponent
    extends SpriteAnimationComponent
    with HasGameReference<FlameGame> {
  _CameraSpaceSnappedSpriteAnimationComponent({
    required SpriteAnimation super.animation,
    required Vector2 super.size,
    required this.worldPosX,
    required this.worldPosY,
    this.anchor = Anchor.center,
    super.paint,
    super.removeOnFinish,
  }) : super(anchor: anchor);

  final double worldPosX;
  final double worldPosY;
  final Anchor anchor;

  void snapToCamera(Vector2 cameraCenter) {
    position.setValues(
      math.snapWorldToPixelsInCameraSpace1d(worldPosX, cameraCenter.x),
      math.snapWorldToPixelsInCameraSpace1d(worldPosY, cameraCenter.y),
    );
  }

  @override
  void update(double dt) {
    snapToCamera(game.camera.viewfinder.position);
    super.update(dt);
  }
}


===== FILE: lib/game/themes/parallax_theme.dart =====
/// Render-layer parallax theme configuration.
library;

import '../components/pixel_parallax_backdrop_component.dart';

class ParallaxTheme {
  const ParallaxTheme({
    required this.backgroundLayers,
    required this.groundLayerAsset,
    required this.foregroundLayers,
  });

  final List<PixelParallaxLayerSpec> backgroundLayers;
  final String groundLayerAsset;
  final List<PixelParallaxLayerSpec> foregroundLayers;
}



===== FILE: lib/game/themes/parallax_theme_registry.dart =====
/// Render-layer mapping of Core theme IDs to concrete parallax assets.
library;

import 'parallax_theme.dart';
import '../components/pixel_parallax_backdrop_component.dart';

/// Returns the [ParallaxTheme] for a given Core `themeId`.
///
/// Unknown or null theme IDs fall back to the default theme.
class ParallaxThemeRegistry {
  const ParallaxThemeRegistry._();

  static ParallaxTheme forThemeId(String? themeId) {
    switch (themeId) {
      case 'field':
        return _field;
      case 'forest':
        return _forest;
      default:
        return _field;
    }
  }
}

const ParallaxTheme _field = ParallaxTheme(
  backgroundLayers: <PixelParallaxLayerSpec>[
    PixelParallaxLayerSpec(
      assetPath: 'parallax/field/Field Layer 01.png',
      parallaxFactor: 0.10,
    ),
    PixelParallaxLayerSpec(
      assetPath: 'parallax/field/Field Layer 02.png',
      parallaxFactor: 0.15,
    ),
    PixelParallaxLayerSpec(
      assetPath: 'parallax/field/Field Layer 03.png',
      parallaxFactor: 0.20,
    ),
    PixelParallaxLayerSpec(
      assetPath: 'parallax/field/Field Layer 04.png',
      parallaxFactor: 0.30,
    ),
    PixelParallaxLayerSpec(
      assetPath: 'parallax/field/Field Layer 05.png',
      parallaxFactor: 0.40,
    ),
    PixelParallaxLayerSpec(
      assetPath: 'parallax/field/Field Layer 06.png',
      parallaxFactor: 0.50,
    ),
    PixelParallaxLayerSpec(
      assetPath: 'parallax/field/Field Layer 07.png',
      parallaxFactor: 0.60,
    ),
    PixelParallaxLayerSpec(
      assetPath: 'parallax/field/Field Layer 08.png',
      parallaxFactor: 0.70,
    ),
  ],
  groundLayerAsset: 'parallax/field/Field Layer 09.png',
  foregroundLayers: <PixelParallaxLayerSpec>[
    PixelParallaxLayerSpec(
      assetPath: 'parallax/field/Field Layer 10.png',
      parallaxFactor: 1.0,
    ),
  ],
);

const ParallaxTheme _forest = ParallaxTheme(
  backgroundLayers: <PixelParallaxLayerSpec>[
    PixelParallaxLayerSpec(
      assetPath: 'parallax/forest/Forest Layer 01.png',
      parallaxFactor: 0.10,
    ),
    PixelParallaxLayerSpec(
      assetPath: 'parallax/forest/Forest Layer 02.png',
      parallaxFactor: 0.20,
    ),
    PixelParallaxLayerSpec(
      assetPath: 'parallax/forest/Forest Layer 03.png',
      parallaxFactor: 0.30,
    ),
  ],
  groundLayerAsset: 'parallax/forest/Forest Layer 04.png',
  foregroundLayers: <PixelParallaxLayerSpec>[
    PixelParallaxLayerSpec(
      assetPath: 'parallax/forest/Forest Layer 05.png',
      parallaxFactor: 1.0,
    ),
  ],
);

===== FILE: lib/game/tick_input_frame.dart =====
// Aggregated input state for a single simulation tick.
//
// The game schedules input commands ahead of time (via RunnerInputRouter).
// Multiple commands may target the same tick, so this class merges them into
// a single coherent state that the simulation consumes.
import '../core/commands/command.dart';

/// Aggregated per-tick input for the simulation.
///
/// This replaces `List<Command>` buffering for a given tick to avoid duplicate
/// commands (e.g., multiple [MoveAxisCommand]s for the same tick). Instead of
/// storing a list, we collapse commands into their final values.
///
/// **Usage pattern:**
/// 1. [GameController] creates one [TickInputFrame] per buffered tick.
/// 2. As commands arrive, [apply] merges them into the frame.
/// 3. When the tick executes, the simulation reads the aggregated state.
/// 4. After use, [reset] clears the frame for potential reuse.
class TickInputFrame {
  // ─────────────────────────────────────────────────────────────────────────
  // Movement
  // ─────────────────────────────────────────────────────────────────────────

  /// Horizontal movement axis in [-1, 1]. Last [MoveAxisCommand] wins.
  double moveAxis = 0;

  // ─────────────────────────────────────────────────────────────────────────
  // Edge-triggered actions (one-shot per tick)
  // ─────────────────────────────────────────────────────────────────────────

  /// True if jump was pressed this tick.
  bool jumpPressed = false;

  /// True if dash was pressed this tick.
  bool dashPressed = false;

  /// True if melee strike was pressed this tick.
  bool strikePressed = false;

  /// True if projectile slot was pressed this tick.
  bool projectilePressed = false;

  /// True if secondary slot was pressed this tick.
  bool secondaryPressed = false;

  /// True if bonus slot was pressed this tick.
  bool bonusPressed = false;

  // ─────────────────────────────────────────────────────────────────────────
  // Projectile aim direction
  // ─────────────────────────────────────────────────────────────────────────

  /// Whether a projectile aim direction is set for this tick.
  bool projectileAimDirSet = false;

  /// Projectile aim X component (only valid if [projectileAimDirSet] is true).
  double projectileAimDirX = 0;

  /// Projectile aim Y component (only valid if [projectileAimDirSet] is true).
  double projectileAimDirY = 0;

  // ─────────────────────────────────────────────────────────────────────────
  // Melee aim direction
  // ─────────────────────────────────────────────────────────────────────────

  /// Whether a melee aim direction is set for this tick.
  bool meleeAimDirSet = false;

  /// Melee aim X component (only valid if [meleeAimDirSet] is true).
  double meleeAimDirX = 0;

  /// Melee aim Y component (only valid if [meleeAimDirSet] is true).
  double meleeAimDirY = 0;

  // ─────────────────────────────────────────────────────────────────────────
  /// Applies a [Command] to this frame, merging it with existing state.
  ///
  /// For continuous inputs (move axis, aim), later commands overwrite earlier ones.
  /// For edge-triggered inputs (jump, dash, strike, projectile), any press sets the flag.
  void apply(Command command) {
    switch (command) {
      case MoveAxisCommand(:final axis):
        moveAxis = axis.clamp(-1.0, 1.0);
      case JumpPressedCommand():
        jumpPressed = true;
      case DashPressedCommand():
        dashPressed = true;
      case StrikePressedCommand():
        strikePressed = true;
      case ProjectileAimDirCommand(:final x, :final y):
        projectileAimDirSet = true;
        projectileAimDirX = x;
        projectileAimDirY = y;
      case MeleeAimDirCommand(:final x, :final y):
        meleeAimDirSet = true;
        meleeAimDirX = x;
        meleeAimDirY = y;
      case ClearProjectileAimDirCommand():
        projectileAimDirSet = false;
        projectileAimDirX = 0;
        projectileAimDirY = 0;
      case ClearMeleeAimDirCommand():
        meleeAimDirSet = false;
        meleeAimDirX = 0;
        meleeAimDirY = 0;
      case ProjectilePressedCommand():
        projectilePressed = true;
      case SecondaryPressedCommand():
        secondaryPressed = true;
      case BonusPressedCommand():
        bonusPressed = true;
    }
  }

  /// Resets all fields to their default (idle) state.
  ///
  /// Call this to reuse the frame for a new tick without allocating a new object.
  void reset() {
    moveAxis = 0;
    jumpPressed = false;
    dashPressed = false;
    strikePressed = false;
    projectileAimDirSet = false;
    projectileAimDirX = 0;
    projectileAimDirY = 0;
    meleeAimDirSet = false;
    meleeAimDirX = 0;
    meleeAimDirY = 0;
    projectilePressed = false;
    secondaryPressed = false;
    bonusPressed = false;
  }
}


===== FILE: lib/game/tuning/player_render_tuning.dart =====
/// Render-layer tuning for player sprite presentation.
library;

import 'package:flutter/foundation.dart';

@immutable
class PlayerRenderTuning {
  const PlayerRenderTuning({
    this.scale = 0.75,
  });

  /// Uniform scale applied to the 100x64 sprite frames.
  final double scale;
}


===== FILE: lib/game/util/math_util.dart =====
// Math utilities for the game layer.
//
// Provides helper functions for common math operations that Dart's standard
// library doesn't handle correctly for game use cases (e.g., negative modulo,
// floor division with negative numbers).

import 'package:flame/components.dart';

import '../../core/util/vec2.dart';

/// Returns `value % mod`, always in the range `[0, mod)`.
///
/// Dart's `%` operator can return negative results for negative [value];
/// this function corrects that.
double positiveModDouble(double value, double mod) {
  if (mod <= 0) throw ArgumentError.value(mod, 'mod', 'must be > 0');
  final r = value % mod;
  return r < 0 ? r + mod : r;
}

/// Integer floor division that correctly handles negative dividends.
///
/// Dart's `~/` operator truncates toward zero, which gives incorrect results
/// for negative numbers when you want true floor division (toward -∞).
///
/// Example: `-1 ~/ 16` returns `0`, but `floorDivInt(-1, 16)` returns `-1`.
int floorDivInt(int a, int b) {
  if (b <= 0) throw ArgumentError.value(b, 'b', 'must be > 0');
  if (a >= 0) return a ~/ b;
  return -(((-a) + b - 1) ~/ b);
}

double lerpDouble(double a, double b, double t) => a + (b - a) * t;

Vec2 lerpVec2(Vec2 a, Vec2 b, double t) =>
    Vec2(lerpDouble(a.x, b.x, t), lerpDouble(a.y, b.y, t));

double roundToPixels(double value) => value.roundToDouble();

/// Snaps a world coordinate to integer pixels in camera space.
///
/// Keeps [camera] fractional and rounds only the screen-space delta
/// (`world - camera`) to the nearest pixel.
double snapWorldToPixelsInCameraSpace1d(double world, double camera) =>
    camera + roundToPixels(world - camera);

/// Convenience 2D version of [snapWorldToPixelsInCameraSpace1d].
Vector2 snapWorldToPixelsInCameraSpace(Vec2 world, Vector2 camera) => Vector2(
  snapWorldToPixelsInCameraSpace1d(world.x, camera.x),
  snapWorldToPixelsInCameraSpace1d(world.y, camera.y),
);


===== FILE: lib/main.dart =====
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:firebase_core/firebase_core.dart';

import 'firebase_options.dart';
import 'ui/app/ui_app.dart';

/// Production app entry point for the rpg-runner game.
///
/// The runner can also be embedded in other Flutter apps via
/// `RunnerGameWidget` / `createRunnerGameRoute` (see `lib/runner.dart`).
/// Embedding apps should initialize Firebase (and any other services) themselves.
Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // Lock to landscape orientation
  await SystemChrome.setPreferredOrientations([
    DeviceOrientation.landscapeLeft,
    DeviceOrientation.landscapeRight,
  ]);

  // Hide status bar and navigation bar (immersive fullscreen)
  // Note: Also re-applied in MenuScaffold to handle navigation edge cases
  await SystemChrome.setEnabledSystemUIMode(SystemUiMode.immersiveSticky);

  await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);
  runApp(const UiApp());
}


===== FILE: lib/runner.dart =====
// Public entrypoint ("barrel file") for embedding the runner in a host app.
//
// Host apps should import only this file:
// `import 'package:rpg_runner/runner.dart';`
//
// This keeps the public API stable while allowing internal folders/files to
// evolve without breaking downstream imports.
export 'core/levels/level_id.dart';
export 'core/players/player_character_definition.dart';
export 'core/players/player_character_registry.dart';
export 'ui/runner_game_route.dart';
export 'ui/runner_game_widget.dart';


===== FILE: lib/ui/AGENTS.md =====
# AGENTS.md - UI Layer

Instructions for AI coding agents working in the **UI** layer (`lib/ui/`).

## UI Layer Responsibility

The UI layer is responsible for **Flutter widgets**: menus, overlays, navigation, settings, and HUD elements.

**Critical rule:** UI **never modifies gameplay state directly**. It sends **Commands** to the game controller.

## Command Pattern

### Sending Commands to Core

UI interacts with Core gameplay through the Command pattern:

```dart
class PauseButton extends StatelessWidget {
  final GameController controller;
  
  @override
  Widget build(BuildContext context) {
    return IconButton(
      icon: Icon(Icons.pause),
      onPressed: () {
        // Send command to Core
        controller.enqueueCommand(
          PauseCommand(tickNumber: controller.currentTick)
        );
      },
    );
  }
}
```

**Rules:**
- Never access Core state directly
- Never mutate gameplay state from UI code
- Always use Commands for gameplay interactions
- Examples: pause, resume, level selection, ability activation

### Command Examples

Common UI → Core command patterns:

- **Level selection** → `LoadLevelCommand(levelId: 'level_2')`
- **Pause/Resume** → `PauseCommand()` / `ResumeCommand()`
- **Settings changes** → `UpdateSettingsCommand(volume: 0.8)`
- **Player actions** → Typically from Game input, but UI can also send them (e.g., virtual buttons)

## Widget Organization

### HUD Components

HUD (Heads-Up Display) elements are overlays that show game state:

- **Health bars** (`lib/ui/hud/`) - Display player health from snapshots
- **Score display** - Show current score, combo, multiplier
- **Progress indicators** - Level progress, distance traveled
- **Ability cooldowns** - Visual timers for abilities
- **Mini-map** (if applicable) - Simplified world view

**Pattern:**
```dart
class HealthBar extends StatelessWidget {
  final GameStateSnapshot snapshot;
  
  @override
  Widget build(BuildContext context) {
    final health = snapshot.player.health;
    final maxHealth = snapshot.player.maxHealth;
    
    return LinearProgressIndicator(
      value: health / maxHealth,
      backgroundColor: Colors.red[900],
      valueColor: AlwaysStoppedAnimation(Colors.red),
    );
  }
}
```

### Menu Screens

Menu screens for navigation and settings:

- **Play hub + setup** (`lib/ui/pages/`) - Start run, setup, meta routes
- **Pause menu** - Resume, restart, quit to menu
- **Game over screen** - Score, retry, quit
- **Level selection** - Choose which level to play
- **Settings** - Audio, graphics, controls

### Controls

Input widgets that send commands:

- **Virtual joystick** (`lib/ui/controls/`) - Directional input
- **Action buttons** - Jump, strike, ability buttons
- **Touch zones** - Swipe gestures, tap-to-jump areas

## State Management

### UI State vs Gameplay State

**Separation of concerns:**

- **Gameplay state** - Lives in Core, authoritative, deterministic
- **UI state** - Lives in UI layer, ephemeral, non-deterministic
  - Examples: menu visibility, animation states, selected options

### RunnerGameUIState

UI-specific state management:

```dart
class RunnerGameUIState {
  bool isPaused = false;
  bool isMenuOpen = false;
  String? selectedLevel;
  
  // UI state only - not part of Core
}
```

**Rules:**
- Keep UI state separate from gameplay state
- UI state can be mutable and non-deterministic
- Gameplay state must go through Core and Commands

### Scoped State

Use scoped state management (`lib/ui/scoped/`) for widgets that need shared UI state without affecting Core:

- Provider/InheritedWidget patterns for UI state
- Never use for gameplay state
- Keep scope narrow (menu-level, screen-level)

## Embedding Contract

### Public API

The game is embeddable via a stable public API:

- **`lib/runner.dart`** - Public entry point, exports main widgets/routes
- **`RunnerGameWidget`** - Main game widget component
- **`RunnerGameRoute`** - Flutter route for navigation

**Usage:**
```dart
// In another app
import 'package:rpg_runner/runner.dart';

Navigator.push(
  context,
  MaterialPageRoute(builder: (context) => RunnerGameWidget()),
);
```

### Dev Host

- **`lib/main.dart`** - Development host/demo app only
- Treat as a development harness, not part of the public API
- Safe to modify for development/testing without affecting embedding

## Viewport Integration

### Letterboxing & Safe Areas

UI overlays must respect the game viewport:

```dart
class GameOverlay extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return SafeArea(
      child: Stack(
        children: [
          // Game viewport (rendered by Flame)
          GameWidget(),
          
          // UI overlay (respects safe areas)
          Positioned(
            top: 16,
            left: 16,
            child: HealthBar(),
          ),
        ],
      ),
    );
  }
}
```

**Rules:**
- Use `SafeArea` to avoid notches/system UI
- Position HUD elements outside the game viewport if needed
- Respect letterboxing (black bars) in layout
- Don't cover critical gameplay areas with UI

## Snapshot Consumption

UI can read snapshots for display purposes:

```dart
class ScoreDisplay extends StatelessWidget {
  final GameStateSnapshot snapshot;
  
  @override
  Widget build(BuildContext context) {
    return Text(
      'Score: ${snapshot.score}',
      style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
    );
  }
}
```

**Rules:**
- Read snapshot data for display only
- Never mutate snapshots
- Never simulate or extrapolate gameplay from snapshots in UI

## Level Selection

Level selection is a UI concern that sends commands to Core:

```dart
class LevelSelectScreen extends StatelessWidget {
  final GameController controller;
  
  @override
  Widget build(BuildContext context) {
    return ListView(
      children: [
        LevelButton(
          levelId: 'level_1',
          onTap: () {
            controller.enqueueCommand(
              LoadLevelCommand(levelId: 'level_1')
            );
            Navigator.push(context, GameRoute());
          },
        ),
        // ... more levels
      ],
    );
  }
}
```

**Pattern:**
- Display level metadata (name, preview, locked state)
- Send `LoadLevelCommand` when level is selected
- Navigate to game route after command is sent
- Core handles actual level loading deterministically

## Common UI Subsystems

- **Controls** (`lib/ui/controls/`) - Input widgets (joystick, buttons)
- **HUD** (`lib/ui/hud/`) - In-game overlays (health, score, progress)
- **Assets** (`lib/ui/assets/`) - UI preview asset lifecycle (hub/run cache + warmup)
- **App** (`lib/ui/app/`) - App shell, routes, navigation
- **Bootstrap** (`lib/ui/bootstrap/`) - Loader + startup tasks
- **State** (`lib/ui/state/`) - Menu selection state + persistence
- **Pages** (`lib/ui/pages/`) - Menu/meta screens (hub, setup, meta, lab)
- **Levels** (`lib/ui/levels/`) - Level selection UI
- **Leaderboard** (`lib/ui/leaderboard/`) - Score display and rankings
- **Scoped** (`lib/ui/scoped/`) - Scoped state management
- **Viewport** (`lib/ui/viewport/`) - Viewport and safe area management

## What NOT to Do in UI Layer

- ❌ **Do not modify gameplay state directly** - use Commands
- ❌ **Do not simulate gameplay** - that's Core's job
- ❌ **Do not access Core internals** - use snapshots and commands
- ❌ **Do not mix UI state with gameplay state** - keep them separate
- ❌ **Do not mutate snapshots** - they are read-only

## Best Practices

✅ **Send Commands** for all gameplay interactions
✅ **Read snapshots** for display purposes only
✅ **Separate concerns** - UI state vs gameplay state
✅ **Respect viewport** - use SafeArea and letterboxing
✅ **Keep embedding API stable** - `lib/runner.dart` is public
✅ **Use Flutter best practices** - StatelessWidget, composition, etc.

---

**For cross-layer architecture and general rules**, see [lib/AGENTS.md](file:///c:/dev/rpg_runner/lib/AGENTS.md).


===== FILE: lib/ui/app/ui_app.dart =====
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

import '../assets/ui_asset_lifecycle.dart';
import '../levels/level_id_ui.dart';
import '../state/app_state.dart';
import 'ui_router.dart';
import 'ui_routes.dart';

class UiApp extends StatefulWidget {
  const UiApp({super.key});

  @override
  State<UiApp> createState() => _UiAppState();
}

class _UiAppState extends State<UiApp> with WidgetsBindingObserver {
  final GlobalKey<NavigatorState> _navigatorKey = GlobalKey<NavigatorState>();
  late final _UiRouteObserver _routeObserver = _UiRouteObserver(
    onRouteChanged: _handleRouteChanged,
  );

  String? _currentRouteName;
  bool _hasSeenRoute = false;
  bool _resumeInFlight = false;

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    super.dispose();
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    super.didChangeAppLifecycleState(state);
    if (state == AppLifecycleState.resumed) {
      _showResumeLoader();
    }
  }

  void _handleRouteChanged(
    _UiRouteChange change,
    Route<dynamic>? route,
    Route<dynamic>? previousRoute,
  ) {
    _hasSeenRoute = true;
    if (change == _UiRouteChange.pop || change == _UiRouteChange.remove) {
      _currentRouteName = previousRoute?.settings.name;
    } else {
      _currentRouteName = route?.settings.name;
    }

    if (change == _UiRouteChange.pop && route?.settings.name == UiRoutes.run) {
      _purgeRunCaches();
    }

    if (_currentRouteName == UiRoutes.hub) {
      unawaited(_warmHubSelection());
    }
  }

  Future<void> _warmHubSelection() async {
    final ctx = _navigatorKey.currentContext;
    if (ctx == null) return;
    final appState = Provider.of<AppState>(ctx, listen: false);
    final lifecycle = Provider.of<UiAssetLifecycle>(ctx, listen: false);
    final selection = appState.selection;
    await lifecycle.warmHubSelection(
      themeId: selection.selectedLevelId.themeId,
      characterId: selection.selectedCharacterId,
      context: ctx,
    );
  }

  void _purgeRunCaches() {
    final ctx = _navigatorKey.currentContext;
    if (ctx == null) return;
    final lifecycle = Provider.of<UiAssetLifecycle>(ctx, listen: false);
    lifecycle.purgeRunCaches();
  }

  void _showResumeLoader() {
    if (_resumeInFlight) return;
    if (!_hasSeenRoute || _currentRouteName == UiRoutes.loader) {
      return;
    }
    final navigator = _navigatorKey.currentState;
    if (navigator == null) return;

    _resumeInFlight = true;
    navigator
        .pushNamed(UiRoutes.loader, arguments: const LoaderArgs(isResume: true))
        .whenComplete(() {
          _resumeInFlight = false;
        });
  }

  @override
  Widget build(BuildContext context) {
    return MultiProvider(
      providers: [
        ChangeNotifierProvider(create: (_) => AppState()),
        Provider<UiAssetLifecycle>(
          create: (_) => UiAssetLifecycle(),
          dispose: (_, lifecycle) => lifecycle.dispose(),
        ),
      ],
      child: MaterialApp(
        title: 'rpg-runner',
        debugShowCheckedModeBanner: false,
        theme: ThemeData(
          colorScheme: ColorScheme.fromSeed(
            seedColor: Colors.white,
            brightness: Brightness.dark,
          ),
          useMaterial3: true,
        ),
        navigatorKey: _navigatorKey,
        initialRoute: UiRoutes.brandSplash,
        onGenerateRoute: UiRouter.onGenerateRoute,
        navigatorObservers: [_routeObserver],
      ),
    );
  }
}

class _UiRouteObserver extends NavigatorObserver {
  _UiRouteObserver({required this.onRouteChanged});

  final void Function(
    _UiRouteChange change,
    Route<dynamic>? route,
    Route<dynamic>? previousRoute,
  )
  onRouteChanged;

  void _update(
    _UiRouteChange change,
    Route<dynamic>? route,
    Route<dynamic>? previousRoute,
  ) {
    onRouteChanged(change, route, previousRoute);
  }

  @override
  void didPush(Route<dynamic> route, Route<dynamic>? previousRoute) {
    super.didPush(route, previousRoute);
    _update(_UiRouteChange.push, route, previousRoute);
  }

  @override
  void didPop(Route<dynamic> route, Route<dynamic>? previousRoute) {
    super.didPop(route, previousRoute);
    _update(_UiRouteChange.pop, route, previousRoute);
  }

  @override
  void didReplace({Route<dynamic>? newRoute, Route<dynamic>? oldRoute}) {
    super.didReplace(newRoute: newRoute, oldRoute: oldRoute);
    _update(_UiRouteChange.replace, newRoute, oldRoute);
  }

  @override
  void didRemove(Route<dynamic> route, Route<dynamic>? previousRoute) {
    super.didRemove(route, previousRoute);
    _update(_UiRouteChange.remove, route, previousRoute);
  }
}

enum _UiRouteChange { push, pop, replace, remove }


===== FILE: lib/ui/app/ui_router.dart =====
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import '../bootstrap/loader_page.dart';
import '../bootstrap/brand_splash_screen.dart';
import '../pages/hub/play_hub_page.dart';
import '../pages/leaderboards/leaderboards_page.dart';
import '../pages/lab/loadout_lab_page.dart';
import '../pages/meta/credits_page.dart';
import '../pages/meta/town_page.dart';
import '../pages/meta/support_page.dart';
import '../pages/meta/library_page.dart';
import '../pages/meta/options_page.dart';
import '../pages/profile/profile_page.dart';
import '../pages/setup/level_setup_page.dart';
import '../pages/setup/loadout_setup_page.dart';
import '../pages/setup/profile_name_setup_page.dart';
import '../runner_game_route.dart';
import 'ui_routes.dart';

class UiRouter {
  const UiRouter._();

  static Route<dynamic> onGenerateRoute(RouteSettings settings) {
    switch (settings.name) {
      case UiRoutes.brandSplash:
        return MaterialPageRoute<void>(
          settings: settings,
          builder: (_) => const BrandSplashScreen(),
        );
      case UiRoutes.loader:
        final args = settings.arguments is LoaderArgs
            ? settings.arguments as LoaderArgs
            : const LoaderArgs();
        return MaterialPageRoute<void>(
          settings: settings,
          builder: (_) => LoaderPage(args: args),
        );
      case UiRoutes.hub:
        return MaterialPageRoute<void>(
          settings: settings,
          builder: (_) => const PlayHubPage(),
        );
      case UiRoutes.setupLevel:
        return MaterialPageRoute<void>(
          settings: settings,
          builder: (_) => const LevelSetupPage(),
        );
      case UiRoutes.setupLoadout:
        return MaterialPageRoute<void>(
          settings: settings,
          builder: (_) => const LoadoutSetupPage(),
        );
      case UiRoutes.setupProfileName:
        return MaterialPageRoute<void>(
          settings: settings,
          builder: (_) => const ProfileNameSetupPage(),
        );
      case UiRoutes.profile:
        return MaterialPageRoute<void>(
          settings: settings,
          builder: (_) => const ProfilePage(),
        );
      case UiRoutes.loadoutLab:
        return MaterialPageRoute<void>(
          settings: settings,
          builder: (_) => const LoadoutLabPage(),
        );
      case UiRoutes.leaderboards:
        return MaterialPageRoute<void>(
          settings: settings,
          builder: (_) => const LeaderboardsPage(),
        );
      case UiRoutes.options:
        return MaterialPageRoute<void>(
          settings: settings,
          builder: (_) => const OptionsPage(),
        );
      case UiRoutes.library:
        return MaterialPageRoute<void>(
          settings: settings,
          builder: (_) => const LibraryPage(),
        );
      case UiRoutes.town:
        return MaterialPageRoute<void>(
          settings: settings,
          builder: (_) => const TownPage(),
        );
      case UiRoutes.support:
        return MaterialPageRoute<void>(
          settings: settings,
          builder: (_) => const SupportPage(),
        );
      case UiRoutes.credits:
        return MaterialPageRoute<void>(
          settings: settings,
          builder: (_) => const CreditsPage(),
        );
      case UiRoutes.run:
        final args = settings.arguments;
        if (args is RunStartArgs) {
          return createRunnerGameRoute(
            runId: args.runId,
            seed: args.seed,
            levelId: args.levelId,
            playerCharacterId: args.playerCharacterId,
            settings: settings,
            restoreOrientations: const [
              DeviceOrientation.landscapeLeft,
              DeviceOrientation.landscapeRight,
            ],
          );
        }
        return MaterialPageRoute<void>(
          settings: settings,
          builder: (_) => const PlayHubPage(),
        );
      default:
        return MaterialPageRoute<void>(
          settings: settings,
          builder: (_) => const PlayHubPage(),
        );
    }
  }
}


===== FILE: lib/ui/app/ui_routes.dart =====
import '../../core/levels/level_id.dart';
import '../../core/players/player_character_definition.dart';
import '../state/selection_state.dart';

class UiRoutes {
  const UiRoutes._();

  static const String brandSplash = '/brand_splash';
  static const String loader = '/loader';
  static const String hub = '/hub';
  static const String setupProfileName = '/setup/profile-name';
  static const String setupLevel = '/setup/level';
  static const String setupLoadout = '/setup/loadout';
  static const String profile = '/profile';
  static const String loadoutLab = '/lab';
  static const String leaderboards = '/leaderboards';
  static const String options = '/meta/options';
  static const String library = '/meta/library';
  static const String town = '/meta/town';
  static const String support = '/meta/support';
  static const String credits = '/credits';
  static const String run = '/run';
}

class LoaderArgs {
  const LoaderArgs({this.isResume = false});

  final bool isResume;
}

class RunStartArgs {
  const RunStartArgs({
    required this.runId,
    required this.seed,
    required this.levelId,
    required this.playerCharacterId,
    required this.runType,
  });

  final int runId;
  final int seed;
  final LevelId levelId;
  final PlayerCharacterId playerCharacterId;
  final RunType runType;
}


===== FILE: lib/ui/assets/asset_scopes.dart =====
/// Asset lifetimes scoped to UI usage.
enum AssetScope {
  /// Menu/hub previews that can persist between routes.
  hub,

  /// Run-specific assets that should be purged on exit.
  run,
}


===== FILE: lib/ui/assets/lru_cache.dart =====
import 'dart:collection';

typedef EvictCallback<V> = void Function(V value);

/// Small, allocation-light LRU cache with optional eviction callback.
class LruCache<K, V> {
  LruCache({required int maxEntries, this.onEvict})
      : _maxEntries = maxEntries < 0 ? 0 : maxEntries;

  final int _maxEntries;
  final EvictCallback<V>? onEvict;
  final LinkedHashMap<K, V> _map = LinkedHashMap<K, V>();

  int get length => _map.length;

  Iterable<V> get values => _map.values;

  V? get(K key) {
    final value = _map.remove(key);
    if (value == null) return null;
    _map[key] = value;
    return value;
  }

  void put(K key, V value) {
    final existing = _map.remove(key);
    if (existing != null && !identical(existing, value)) {
      onEvict?.call(existing);
    }
    _map[key] = value;
    trim();
  }

  bool containsKey(K key) => _map.containsKey(key);

  void remove(K key) {
    final value = _map.remove(key);
    if (value != null) {
      onEvict?.call(value);
    }
  }

  void clear() {
    if (onEvict != null) {
      for (final value in _map.values) {
        onEvict!(value);
      }
    }
    _map.clear();
  }

  void trim() {
    if (_maxEntries <= 0) {
      clear();
      return;
    }
    while (_map.length > _maxEntries) {
      final entry = _map.entries.first;
      _map.remove(entry.key);
      onEvict?.call(entry.value);
    }
  }
}


===== FILE: lib/ui/assets/ui_asset_lifecycle.dart =====
import 'package:flame/cache.dart';
import 'package:flame/components.dart';
import 'package:flutter/widgets.dart';

import '../../core/players/player_character_definition.dart';
import '../../core/players/player_character_registry.dart';
import '../../core/snapshots/enums.dart';
import '../../game/components/player/player_animations.dart';
import '../../game/themes/parallax_theme_registry.dart';
import 'asset_scopes.dart';
import 'lru_cache.dart';

class IdleAnimBundle {
  const IdleAnimBundle({
    required this.animation,
    required this.anchor,
  });

  final SpriteAnimation animation;
  final Anchor anchor;
}

class UiAssetLifecycle {
  UiAssetLifecycle({
    int maxHubThemes = 8,
    int maxHubCharacters = 4,
    int maxRunThemes = 0,
    int maxRunCharacters = 0,
  }) : _hubParallaxCache = LruCache<String, List<AssetImage>>(
         maxEntries: maxHubThemes,
         onEvict: _evictParallaxLayers,
       ),
       _runParallaxCache = LruCache<String, List<AssetImage>>(
         maxEntries: maxRunThemes,
         onEvict: _evictParallaxLayers,
       ),
       _hubIdleCache = LruCache<PlayerCharacterId, IdleAnimBundle>(
         maxEntries: maxHubCharacters,
       ),
       _runIdleCache = LruCache<PlayerCharacterId, IdleAnimBundle>(
         maxEntries: maxRunCharacters,
       );

  final Images _idleImages = Images();

  final LruCache<String, List<AssetImage>> _hubParallaxCache;
  final LruCache<String, List<AssetImage>> _runParallaxCache;
  final LruCache<PlayerCharacterId, IdleAnimBundle> _hubIdleCache;
  final LruCache<PlayerCharacterId, IdleAnimBundle> _runIdleCache;

  final Map<PlayerCharacterId, Future<IdleAnimBundle>> _hubIdleInFlight =
      <PlayerCharacterId, Future<IdleAnimBundle>>{};
  final Map<PlayerCharacterId, Future<IdleAnimBundle>> _runIdleInFlight =
      <PlayerCharacterId, Future<IdleAnimBundle>>{};

  final Map<AssetImage, Future<void>> _parallaxPrecacheInFlight =
      <AssetImage, Future<void>>{};

  Future<IdleAnimBundle> getIdle(
    PlayerCharacterId id, {
    AssetScope scope = AssetScope.hub,
  }) {
    final cache = _idleCacheFor(scope);
    final cached = cache.get(id);
    if (cached != null) return Future.value(cached);

    final inFlight = _idleInFlightFor(scope);
    final existing = inFlight[id];
    if (existing != null) return existing;

    final future = _loadIdleBundle(id).then((bundle) {
      cache.put(id, bundle);
      inFlight.remove(id);
      return bundle;
    }).catchError((error, stackTrace) {
      inFlight.remove(id);
      return Future<IdleAnimBundle>.error(error, stackTrace);
    });

    inFlight[id] = future;
    return future;
  }

  Future<List<AssetImage>> getParallaxLayers(
    String? themeId, {
    AssetScope scope = AssetScope.hub,
  }) async {
    final cache = _parallaxCacheFor(scope);
    final key = _cacheKeyForTheme(themeId);
    final cached = cache.get(key);
    if (cached != null) return cached;

    final built = _buildParallaxLayers(themeId);
    cache.put(key, built);
    return built;
  }

  Future<void> precacheParallaxLayers(
    List<AssetImage> layers,
    BuildContext context,
  ) async {
    if (layers.isEmpty) return;
    final futures = <Future<void>>[];
    for (final provider in layers) {
      futures.add(_precacheImageOnce(provider, context));
    }
    await Future.wait(futures);
  }

  Future<void> warmHubSelection({
    required String? themeId,
    required PlayerCharacterId characterId,
    required BuildContext context,
  }) async {
    try {
      final layers = await getParallaxLayers(
        themeId,
        scope: AssetScope.hub,
      );
      await Future.wait([
        getIdle(characterId, scope: AssetScope.hub),
        precacheParallaxLayers(layers, context),
      ]);
      trimHubCaches();
    } catch (_) {
      // Best-effort warmup.
    }
  }

  void trimHubCaches() {
    _hubParallaxCache.trim();
    _hubIdleCache.trim();
  }

  void purgeRunCaches() {
    _runParallaxCache.clear();
    _runIdleCache.clear();
    _runIdleInFlight.clear();
  }

  void purgeAll() {
    _hubParallaxCache.clear();
    _runParallaxCache.clear();
    _hubIdleCache.clear();
    _runIdleCache.clear();
    _hubIdleInFlight.clear();
    _runIdleInFlight.clear();
    _parallaxPrecacheInFlight.clear();
    _idleImages.clearCache();
  }

  void dispose() => purgeAll();

  LruCache<String, List<AssetImage>> _parallaxCacheFor(AssetScope scope) {
    return scope == AssetScope.run ? _runParallaxCache : _hubParallaxCache;
  }

  LruCache<PlayerCharacterId, IdleAnimBundle> _idleCacheFor(AssetScope scope) {
    return scope == AssetScope.run ? _runIdleCache : _hubIdleCache;
  }

  Map<PlayerCharacterId, Future<IdleAnimBundle>> _idleInFlightFor(
    AssetScope scope,
  ) {
    return scope == AssetScope.run ? _runIdleInFlight : _hubIdleInFlight;
  }

  Future<IdleAnimBundle> _loadIdleBundle(PlayerCharacterId characterId) async {
    final def =
        PlayerCharacterRegistry.byId[characterId] ??
        PlayerCharacterRegistry.defaultCharacter;
    final animSet = await loadPlayerAnimations(
      _idleImages,
      renderAnim: def.renderAnim,
    );
    final idle = animSet.animations[AnimKey.idle];
    if (idle == null) {
      throw StateError('Missing idle animation for $characterId');
    }
    return IdleAnimBundle(animation: idle, anchor: animSet.anchor);
  }

  static String _cacheKeyForTheme(String? themeId) {
    return themeId ?? '__null__';
  }

  static List<AssetImage> _buildParallaxLayers(String? themeId) {
    final theme = ParallaxThemeRegistry.forThemeId(themeId);

    AssetImage img(String relToImagesFolder) =>
        AssetImage('assets/images/$relToImagesFolder');

    return <AssetImage>[
      for (final layer in theme.backgroundLayers) img(layer.assetPath),
      img(theme.groundLayerAsset),
      for (final layer in theme.foregroundLayers) img(layer.assetPath),
    ];
  }

  Future<void> _precacheImageOnce(
    AssetImage provider,
    BuildContext context,
  ) {
    final existing = _parallaxPrecacheInFlight[provider];
    if (existing != null) return existing;

    final future = precacheImage(provider, context)
        .catchError((_) {})
        .whenComplete(() {
      _parallaxPrecacheInFlight.remove(provider);
    });

    _parallaxPrecacheInFlight[provider] = future;
    return future;
  }

  static void _evictParallaxLayers(List<AssetImage> layers) {
    final cache = PaintingBinding.instance.imageCache;
    for (final provider in layers) {
      cache.evict(provider);
    }
  }
}


===== FILE: lib/ui/bootstrap/app_bootstrapper.dart =====
import '../state/app_state.dart';

class BootstrapResult {
  const BootstrapResult._({required this.ok, this.error, this.stackTrace});

  final bool ok;
  final Object? error;
  final StackTrace? stackTrace;

  static const BootstrapResult success = BootstrapResult._(ok: true);

  factory BootstrapResult.failure(Object error, StackTrace stackTrace) {
    return BootstrapResult._(ok: false, error: error, stackTrace: stackTrace);
  }
}

class AppBootstrapper {
  const AppBootstrapper();

  Future<BootstrapResult> run(AppState appState, {required bool force}) async {
    try {
      await appState.bootstrap(force: force);
      return BootstrapResult.success;
    } catch (error, stackTrace) {
      return BootstrapResult.failure(error, stackTrace);
    }
  }
}


===== FILE: lib/ui/bootstrap/brand_splash_screen.dart =====
import 'dart:async';

import 'package:flutter/material.dart';

import '../app/ui_routes.dart';

class BrandSplashScreen extends StatefulWidget {
  const BrandSplashScreen({super.key});

  @override
  State<BrandSplashScreen> createState() => _BrandSplashScreenState();
}

class _BrandSplashScreenState extends State<BrandSplashScreen> {
  @override
  void initState() {
    super.initState();
    // Wait for 1.5 seconds, then navigate to the loader.
    Timer(const Duration(milliseconds: 1500), () {
      if (mounted) {
        Navigator.pushReplacementNamed(context, UiRoutes.loader);
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.black,
      body: Center(
        child: Text(
          'ToonsaCorp',
          style: Theme.of(context).textTheme.headlineLarge?.copyWith(
            color: Colors.white,
            fontWeight: FontWeight.bold,
          ),
        ),
      ),
    );
  }
}


===== FILE: lib/ui/bootstrap/loader_content.dart =====
import 'package:flutter/material.dart';

/// Shared loading visual used by bootstrap + run loading.
class LoaderContent extends StatelessWidget {
  const LoaderContent({
    super.key,
    this.title = 'rpg-runner',
    this.subtitle = 'Loading...',
    this.errorMessage,
    this.onContinue,
  });

  final String title;
  final String subtitle;
  final String? errorMessage;
  final VoidCallback? onContinue;

  bool get _hasError => errorMessage != null;

  @override
  Widget build(BuildContext context) {
    return Column(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        Text(
          title,
          style: const TextStyle(
            fontSize: 36,
            fontWeight: FontWeight.bold,
            color: Colors.white,
            letterSpacing: 2,
          ),
        ),
        const SizedBox(height: 24),
        if (!_hasError) ...[
          const CircularProgressIndicator(color: Colors.white),
          const SizedBox(height: 16),
          Text(subtitle, style: const TextStyle(color: Colors.white70)),
        ],
        if (_hasError) ...[
          const Text(
            'Bootstrap failed',
            style: TextStyle(color: Colors.redAccent, fontSize: 16),
          ),
          const SizedBox(height: 8),
          Text(
            errorMessage!,
            textAlign: TextAlign.center,
            style: const TextStyle(color: Colors.white70),
          ),
          if (onContinue != null) ...[
            const SizedBox(height: 16),
            FilledButton(
              onPressed: onContinue,
              child: const Text('Continue with defaults'),
            ),
          ],
        ],
      ],
    );
  }
}


===== FILE: lib/ui/bootstrap/loader_page.dart =====
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

import '../app/ui_routes.dart';
import '../components/menu_layout.dart';
import '../components/menu_scaffold.dart';
import '../state/app_state.dart';
import '../state/profile_flag_keys.dart';
import 'app_bootstrapper.dart';
import 'loader_content.dart';

class LoaderPage extends StatefulWidget {
  const LoaderPage({
    super.key,
    required this.args,
    this.bootstrapper = const AppBootstrapper(),
  });

  final LoaderArgs args;
  final AppBootstrapper bootstrapper;

  @override
  State<LoaderPage> createState() => _LoaderPageState();
}

class _LoaderPageState extends State<LoaderPage> {
  BootstrapResult? _result;
  bool _starting = false;

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _startBootstrap();
    });
  }

  Future<void> _startBootstrap() async {
    if (_starting) return;
    _starting = true;
    final appState = context.read<AppState>();
    // Ensure the loading screen is visible for at least 2 seconds.
    final minWait = Future<void>.delayed(const Duration(seconds: 2));
    final bootstrap = widget.bootstrapper.run(
      appState,
      force: widget.args.isResume,
    );

    final result = await bootstrap;
    await minWait;
    if (!mounted) return;
    setState(() {
      _result = result;
    });
    if (result.ok) {
      _complete();
    }
  }

  void _complete() {
    final navigator = Navigator.of(context);
    if (widget.args.isResume && navigator.canPop()) {
      navigator.pop();
      return;
    }

    final appState = context.read<AppState>();
    final completed =
        appState.profile.flags[ProfileFlagKeys.namePromptCompleted] == true;

    if (!widget.args.isResume && !completed) {
      navigator.pushReplacementNamed(UiRoutes.setupProfileName);
      return;
    }

    navigator.pushReplacementNamed(UiRoutes.hub);
  }

  void _continueWithDefaults() {
    final appState = context.read<AppState>();
    appState.applyDefaults();
    _complete();
  }

  @override
  Widget build(BuildContext context) {
    final hasError = _result != null && !_result!.ok;

    return MenuScaffold(
      showAppBar: false,
      child: MenuLayout(
        alignment: Alignment.center,
        scrollable: false,
        child: hasError
            ? LoaderContent(
                errorMessage: '${_result!.error}',
                onContinue: _continueWithDefaults,
              )
            : const LoaderContent(),
      ),
    );
  }
}


===== FILE: lib/ui/components/level_card.dart =====
import 'package:flutter/material.dart';

import '../../core/levels/level_id.dart';
import '../levels/level_id_ui.dart';
import 'level_parallax_preview.dart';

/// A card widget displaying a level with its full parallax background.
///
/// Shows all parallax layers composited as background with the title centered.
/// Use in a row for level selection screens.
class LevelCard extends StatelessWidget {
  const LevelCard({
    super.key,
    required this.levelId,
    required this.onTap,
    this.selected = false,
    this.width,
    this.height = 120,
    this.borderRadius = 12,
  });

  /// The level this card represents.
  final LevelId levelId;

  /// Callback when the card is tapped.
  final VoidCallback onTap;

  /// Whether this card is currently selected.
  final bool selected;

  /// Card width. If null, uses available space (e.g., in Expanded).
  final double? width;

  /// Card height. Defaults to 120.
  final double height;

  /// Corner radius. Defaults to 12.
  final double borderRadius;

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: onTap,
      child: Container(
        width: width,
        height: height,
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(borderRadius),
          border: Border.all(
            color: selected ? Colors.amberAccent : Colors.white,
            width: 2,
          ),
          boxShadow: const [
            BoxShadow(
              color: Colors.black54,
              blurRadius: 8,
              offset: Offset(0, 4),
            ),
          ],
        ),
        child: ClipRRect(
          borderRadius: BorderRadius.circular(borderRadius - 2),
          child: Stack(
            fit: StackFit.expand,
            children: [
              // Full theme preview (no gradient overlay).
              LevelParallaxPreview(themeId: levelId.themeId),

              // Title: readable via shadow, not via a dark scrim.
              Center(
                child: Text(
                  levelId.displayName.toUpperCase(),
                  style: const TextStyle(
                    fontSize: 20,
                    fontWeight: FontWeight.bold,
                    color: Colors.white,
                    letterSpacing: 2,
                    shadows: [
                      Shadow(
                        color: Colors.black,
                        blurRadius: 4,
                        offset: Offset(1, 1),
                      ),
                    ],
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}


===== FILE: lib/ui/components/level_parallax_preview.dart =====
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

import '../assets/ui_asset_lifecycle.dart';

/// Static (non-scrolling) parallax preview for menu cards.
///
/// - Uses UiAssetLifecycle for theme → layers caching.
/// - Precaches per widget lifetime to avoid first-frame hitch.
/// - Never crashes the UI if a layer asset is missing.
class LevelParallaxPreview extends StatefulWidget {
  const LevelParallaxPreview({
    super.key,
    required this.themeId,
    this.baseColor = const Color(0xFF0B1020),
    this.alignment = Alignment.bottomCenter,
    this.filterQuality = FilterQuality.none,
  });

  final String? themeId;

  /// Fill behind transparent pixels in layers.
  /// Important because MenuScaffold background is black.
  final Color baseColor;

  final AlignmentGeometry alignment;
  final FilterQuality filterQuality;

  @override
  State<LevelParallaxPreview> createState() => _LevelParallaxPreviewState();
}

class _LevelParallaxPreviewState extends State<LevelParallaxPreview> {
  String? _cacheKey;
  List<AssetImage> _layers = const <AssetImage>[];
  bool _precached = false;

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    _refreshLayers();
  }

  @override
  void didUpdateWidget(LevelParallaxPreview oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.themeId != widget.themeId) {
      _refreshLayers();
    }
  }

  void _refreshLayers() {
    final key = widget.themeId ?? '__null__';
    if (_cacheKey == key && _layers.isNotEmpty) return;

    _cacheKey = key;
    _precached = false;

    final lifecycle = context.read<UiAssetLifecycle>();
    lifecycle.getParallaxLayers(widget.themeId).then((layers) {
      if (!mounted || _cacheKey != key) return;
      setState(() => _layers = layers);
      _schedulePrecache(layers);
    }).catchError((_) {
      // Best-effort preview; ignore missing assets.
    });
  }

  void _schedulePrecache(List<AssetImage> layers) {
    if (_precached) return;
    _precached = true;
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (!mounted) return;
      unawaited(
        context.read<UiAssetLifecycle>().precacheParallaxLayers(
          layers,
          context,
        ),
      );
    });
  }

  @override
  Widget build(BuildContext context) {
    return RepaintBoundary(
      child: Stack(
        fit: StackFit.expand,
        children: [
          ColoredBox(color: widget.baseColor),

          for (final provider in _layers)
            Positioned.fill(
              child: Align(
                alignment: widget.alignment,
                child: Image(
                  image: provider,
                  fit: BoxFit.cover,
                  alignment: widget.alignment,
                  filterQuality: widget.filterQuality,
                  errorBuilder: (context, error, stackTrace) {
                    // If one layer is missing, just skip it visually.
                    return const SizedBox.shrink();
                  },
                ),
              ),
            ),
        ],
      ),
    );
  }
}


===== FILE: lib/ui/components/menu_button.dart =====
import 'package:flutter/material.dart';

/// A simple, reusable button for menu screens.
///
/// Styled for a minimal black/white aesthetic. Use this for main menu,
/// pause menu, and other navigation screens.
class MenuButton extends StatelessWidget {
  const MenuButton({
    super.key,
    required this.label,
    required this.onPressed,
    this.width = 160,
    this.height = 48,
    this.backgroundColor = Colors.white,
    this.foregroundColor = Colors.black,
    this.borderColor,
    this.borderWidth = 2,
    this.fontSize = 16,
  });

  /// The text label displayed on the button.
  final String label;

  /// Callback when the button is pressed. Null disables the button.
  final VoidCallback? onPressed;

  /// Button width. Defaults to 160.
  final double width;

  /// Button height. Defaults to 56.
  final double height;

  /// Background color. Defaults to white.
  final Color backgroundColor;

  /// Text color. Defaults to black.
  final Color foregroundColor;

  /// Border color. Defaults to foregroundColor if not specified.
  final Color? borderColor;

  /// Border width. Defaults to 2.
  final double borderWidth;

  /// Font size. Defaults to 18.
  final double fontSize;

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      width: width,
      height: height,
      child: OutlinedButton(
        onPressed: onPressed,
        style: OutlinedButton.styleFrom(
          backgroundColor: backgroundColor,
          foregroundColor: foregroundColor,
          side: BorderSide(
            color: borderColor ?? foregroundColor,
            width: borderWidth,
          ),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(8),
          ),
        ),
        child: Text(
          label,
          style: TextStyle(
            fontSize: fontSize,
            fontWeight: FontWeight.bold,
          ),
        ),
      ),
    );
  }
}


===== FILE: lib/ui/components/menu_layout.dart =====
import 'dart:math' as math;

import 'package:flutter/material.dart';

class MenuLayout extends StatelessWidget {
  const MenuLayout({
    super.key,
    required this.child,
    this.maxWidth = 1100,
    this.horizontalPadding = 24,
    this.verticalPadding = 24,
    this.scrollable = true,
    this.alignment = Alignment.topCenter,
  });

  final Widget child;
  final double maxWidth;
  final double horizontalPadding;
  final double verticalPadding;
  final bool scrollable;
  final Alignment alignment;

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        final padding = EdgeInsets.symmetric(
          horizontal: horizontalPadding,
          vertical: verticalPadding,
        );
        final availableWidth = math.max(
          0.0,
          constraints.maxWidth - padding.horizontal,
        );
        final width = math.min(availableWidth, maxWidth);

        final aligned = Align(
          alignment: alignment,
          child: Padding(
            padding: padding,
            child: ConstrainedBox(
              constraints: BoxConstraints(maxWidth: width),
              child: child,
            ),
          ),
        );

        if (!scrollable) {
          return aligned;
        }

        final minHeight = math.max(
          0.0,
          constraints.maxHeight - padding.vertical,
        );

        return SingleChildScrollView(
          child: ConstrainedBox(
            constraints: BoxConstraints(minHeight: minHeight),
            child: aligned,
          ),
        );
      },
    );
  }
}


===== FILE: lib/ui/components/menu_scaffold.dart =====
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

/// A scaffold wrapper for menu pages with consistent black/white styling.
///
/// Handles:
/// - Black background
/// - Optional AppBar with back button
/// - Immersive mode re-application on build
/// - SafeArea for content
///
/// Use this for all menu pages to maintain consistency and DRY principles.
class MenuScaffold extends StatelessWidget {
  const MenuScaffold({
    super.key,
    required this.child,
    this.title,
    this.showAppBar = true,
  });

  /// The main content of the page.
  final Widget child;

  /// Optional title for the AppBar. If null, no title is shown.
  final String? title;

  /// Whether to show the AppBar with back button. Defaults to true.
  final bool showAppBar;

  @override
  Widget build(BuildContext context) {
    // Re-apply immersive mode to prevent system UI from reappearing
    SystemChrome.setEnabledSystemUIMode(SystemUiMode.immersiveSticky);

    return Scaffold(
      backgroundColor: Colors.black,
      appBar: showAppBar
          ? AppBar(
              title: title != null
                  ? Text(title!, style: const TextStyle(color: Colors.white))
                  : null,
              backgroundColor: Colors.black,
              iconTheme: const IconThemeData(color: Colors.white),
            )
          : null,
      body: SafeArea(child: child),
    );
  }
}


===== FILE: lib/ui/components/overlay_button.dart =====
import 'package:flutter/material.dart';

class OverlayButton extends StatelessWidget {
  const OverlayButton({
    super.key,
    required this.label,
    required this.onPressed,
  });

  final String label;
  final VoidCallback? onPressed;

  @override
  Widget build(BuildContext context) {
    return TextButton(
      onPressed: onPressed,
      style: TextButton.styleFrom(
        foregroundColor: const Color(0xFFFFFFFF),
        backgroundColor: const Color(0xAA000000),
        padding: const EdgeInsets.symmetric(horizontal: 18, vertical: 10),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(10),
          side: const BorderSide(color: Color(0xFFFFFFFF)),
        ),
      ),
      child: Text(
        label,
        style: const TextStyle(fontSize: 14, fontWeight: FontWeight.w600),
      ),
    );
  }
}


===== FILE: lib/ui/components/placeholder_page.dart =====
import 'package:flutter/material.dart';

import 'menu_layout.dart';
import 'menu_scaffold.dart';

/// A reusable placeholder page for features not yet implemented.
///
/// Displays the page title and "Coming Soon" text with consistent styling.
/// Use this for any menu pages that are placeholders for future features.
class PlaceholderPage extends StatelessWidget {
  const PlaceholderPage({
    super.key,
    required this.title,
    this.message = 'Coming Soon',
  });

  /// The title shown in the AppBar.
  final String title;

  /// The placeholder message shown in the center. Defaults to "Coming Soon".
  final String message;

  @override
  Widget build(BuildContext context) {
    return MenuScaffold(
      title: title,
      child: MenuLayout(
        alignment: Alignment.center,
        scrollable: false,
        child: Text(
          message,
          style: const TextStyle(
            fontSize: 24,
            color: Colors.white54,
          ),
        ),
      ),
    );
  }
}


===== FILE: lib/ui/components/player_idle_preview.dart =====
import 'package:flame/widgets.dart';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

import '../../core/players/player_character_definition.dart';
import '../assets/ui_asset_lifecycle.dart';

/// Lightweight UI preview for a character's idle animation.
///
/// Caches animation loads per character to avoid asset churn in menus.
class PlayerIdlePreview extends StatelessWidget {
  const PlayerIdlePreview({
    super.key,
    required this.characterId,
    this.size = 88,
  });

  final PlayerCharacterId characterId;
  final double size;

  static final Paint _paint = Paint()..filterQuality = FilterQuality.none;

  @override
  Widget build(BuildContext context) {
    final lifecycle = context.read<UiAssetLifecycle>();
    final future = lifecycle.getIdle(characterId);

    return SizedBox(
      width: size,
      height: size,
      child: FutureBuilder<IdleAnimBundle>(
        future: future,
        builder: (context, snapshot) {
          if (snapshot.connectionState != ConnectionState.done) {
            return _buildPlaceholder();
          }
          final data = snapshot.data;
          if (data == null || snapshot.hasError) {
            return _buildPlaceholder();
          }

          return RepaintBoundary(
            child: Transform.scale(
              scaleX: -1,
              alignment: Alignment.center,
              child: SpriteAnimationWidget(
                animation: data.animation,
                animationTicker: data.animation.createTicker(),
                anchor: data.anchor,
                paint: _paint,
              ),
            ),
          );
        },
      ),
    );
  }

  Widget _buildPlaceholder() {
    return Container(
      alignment: Alignment.center,
      decoration: BoxDecoration(
        color: const Color(0x22000000),
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: Colors.white24),
      ),
      child: const Icon(Icons.person, color: Colors.white24, size: 20),
    );
  }
}


===== FILE: lib/ui/controls/action_button.dart =====
import 'package:flutter/material.dart';

import 'cooldown_ring.dart';

// lib/ui/controls/action_button.dart

class ActionButton extends StatelessWidget {
  const ActionButton({
    super.key,
    required this.label,
    required this.icon,
    required this.onPressed,
    this.affordable = true,
    this.cooldownTicksLeft = 0,
    this.cooldownTicksTotal = 0,
    this.size = 72,
    this.backgroundColor = const Color(0x33000000),
    this.foregroundColor = Colors.white,
    this.labelFontSize = 12,
    this.labelGap = 2,
  });

  final String label;
  final IconData icon;
  final VoidCallback onPressed;
  final bool affordable;
  final int cooldownTicksLeft;
  final int cooldownTicksTotal;
  final double size;
  final Color backgroundColor;
  final Color foregroundColor;
  final double labelFontSize;
  final double labelGap;

  @override
  Widget build(BuildContext context) {
    final interactable = affordable && cooldownTicksLeft <= 0;
    final effectiveForeground =
        affordable ? foregroundColor : _disabledForeground(foregroundColor);
    final effectiveBackground =
        affordable ? backgroundColor : _disabledBackground(backgroundColor);

    return SizedBox(
      width: size,
      height: size,
      child: Stack(
        fit: StackFit.expand,
        children: [
          Material(
            color: effectiveBackground,
            shape: const CircleBorder(),
            child: InkWell(
              customBorder: const CircleBorder(),
              onTapDown: interactable ? (_) => onPressed() : null,
              onTap: null,
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(icon, color: effectiveForeground),
                  SizedBox(height: labelGap),
                  Text(
                    label,
                    style: TextStyle(
                      fontSize: labelFontSize,
                      color: effectiveForeground,
                    ),
                  ),
                ],
              ),
            ),
          ),
          IgnorePointer(
            child: CooldownRing(
              cooldownTicksLeft: cooldownTicksLeft,
              cooldownTicksTotal: cooldownTicksTotal,
            ),
          ),
        ],
      ),
    );
  }

  Color _disabledForeground(Color color) => color.withValues(alpha: 0.35);
  Color _disabledBackground(Color color) =>
      color.withValues(alpha: color.a * 0.6);
}



===== FILE: lib/ui/controls/controls_tuning.dart =====
import 'dart:ui';

import 'package:flutter/foundation.dart';

enum ControlsJoystickKind { fixed, floating }

@immutable
class ControlsTuning {
  const ControlsTuning({
    this.edgePadding = 16,
    this.bottomEdgePadding = 16,
    this.buttonGap = 12,
    this.rowGap = 12,
    this.joystickKind = ControlsJoystickKind.floating,
    this.fixedJoystick = const FixedJoystickTuning(),
    this.floatingJoystick = const FloatingJoystickTuning(),
    this.actionButton = const ActionButtonTuning(),
    this.directionalActionButton = const DirectionalActionButtonTuning(),
  });

  final double edgePadding;
  final double bottomEdgePadding;
  final double buttonGap;
  final double rowGap;

  final ControlsJoystickKind joystickKind;
  final FixedJoystickTuning fixedJoystick;
  final FloatingJoystickTuning floatingJoystick;

  final ActionButtonTuning actionButton;
  final DirectionalActionButtonTuning directionalActionButton;

  static const floating = ControlsTuning();
  static const fixed = ControlsTuning(
    joystickKind: ControlsJoystickKind.fixed,
  );
}

@immutable
class ActionButtonTuning {
  const ActionButtonTuning({
    this.size = 52,
    this.backgroundColor = const Color(0x33000000),
    this.foregroundColor = const Color(0xFFFFFFFF),
    this.labelFontSize = 8,
    this.labelGap = 2,
  });

  final double size;
  final Color backgroundColor;
  final Color foregroundColor;
  final double labelFontSize;
  final double labelGap;
}

@immutable
class DirectionalActionButtonTuning {
  const DirectionalActionButtonTuning({
    this.size = 52,
    this.deadzoneRadius = 12,
    this.backgroundColor = const Color(0x33000000),
    this.foregroundColor = const Color(0xFFFFFFFF),
    this.labelFontSize = 8,
    this.labelGap = 2,
  });

  final double size;
  final double deadzoneRadius;
  final Color backgroundColor;
  final Color foregroundColor;
  final double labelFontSize;
  final double labelGap;
}

@immutable
class FixedJoystickTuning {
  const FixedJoystickTuning({
    this.size = 120,
    this.knobSize = 56,
    this.baseColor = const Color(0x33000000),
    this.baseBorderColor = const Color(0x55FFFFFF),
    this.baseBorderWidth = 1,
    this.knobColor = const Color(0x66FFFFFF),
    this.knobBorderColor = const Color(0x88FFFFFF),
    this.knobBorderWidth = 1,
  });

  final double size;
  final double knobSize;
  final Color baseColor;
  final Color baseBorderColor;
  final double baseBorderWidth;
  final Color knobColor;
  final Color knobBorderColor;
  final double knobBorderWidth;
}

@immutable
class FloatingJoystickTuning {
  const FloatingJoystickTuning({
    this.areaSize = 220,
    this.baseSize = 120,
    this.knobSize = 56,
    this.followSmoothing = 0.25,
    this.baseColor = const Color(0x33000000),
    this.baseBorderColor = const Color(0x55FFFFFF),
    this.baseBorderWidth = 1,
    this.knobColor = const Color(0x66FFFFFF),
    this.knobBorderColor = const Color(0x88FFFFFF),
    this.knobBorderWidth = 1,
  });

  final double areaSize;
  final double baseSize;
  final double knobSize;
  final double followSmoothing;
  final Color baseColor;
  final Color baseBorderColor;
  final double baseBorderWidth;
  final Color knobColor;
  final Color knobBorderColor;
  final double knobBorderWidth;
}


===== FILE: lib/ui/controls/cooldown_ring.dart =====
import 'dart:math' as math;

import 'package:flutter/widgets.dart';

class CooldownRing extends StatelessWidget {
  const CooldownRing({
    super.key,
    required this.cooldownTicksLeft,
    required this.cooldownTicksTotal,
    this.thickness = 3,
    this.trackColor = const Color(0x66FFFFFF),
    this.progressColor = const Color(0xFFFFFFFF),
  });

  final int cooldownTicksLeft;
  final int cooldownTicksTotal;
  final double thickness;
  final Color trackColor;
  final Color progressColor;

  @override
  Widget build(BuildContext context) {
    if (cooldownTicksLeft <= 0 || cooldownTicksTotal <= 0) {
      return const SizedBox.shrink();
    }

    final clampedLeft = cooldownTicksLeft.clamp(0, cooldownTicksTotal);
    final elapsed = 1.0 - (clampedLeft / cooldownTicksTotal);

    return CustomPaint(
      painter: _CooldownRingPainter(
        elapsedFraction: elapsed.clamp(0.0, 1.0),
        thickness: thickness,
        trackColor: trackColor,
        progressColor: progressColor,
      ),
    );
  }
}

class _CooldownRingPainter extends CustomPainter {
  _CooldownRingPainter({
    required this.elapsedFraction,
    required this.thickness,
    required this.trackColor,
    required this.progressColor,
  });

  final double elapsedFraction;
  final double thickness;
  final Color trackColor;
  final Color progressColor;

  @override
  void paint(Canvas canvas, Size size) {
    final inset = thickness / 2;
    final rect = Rect.fromLTWH(
      inset,
      inset,
      size.width - thickness,
      size.height - thickness,
    );

    final trackPaint = Paint()
      ..color = trackColor
      ..style = PaintingStyle.stroke
      ..strokeWidth = thickness;

    final progressPaint = Paint()
      ..color = progressColor
      ..style = PaintingStyle.stroke
      ..strokeWidth = thickness
      ..strokeCap = StrokeCap.round;

    const startAngle = -math.pi / 2;
    canvas.drawArc(rect, startAngle, math.pi * 2, false, trackPaint);
    if (elapsedFraction > 0) {
      canvas.drawArc(
        rect,
        startAngle,
        math.pi * 2 * elapsedFraction,
        false,
        progressPaint,
      );
    }
  }

  @override
  bool shouldRepaint(covariant _CooldownRingPainter oldDelegate) {
    return oldDelegate.elapsedFraction != elapsedFraction ||
        oldDelegate.thickness != thickness ||
        oldDelegate.trackColor != trackColor ||
        oldDelegate.progressColor != progressColor;
  }
}


===== FILE: lib/ui/controls/directional_action_button.dart =====
import 'dart:math' as math;

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

import '../../game/input/aim_preview.dart';
import '../../game/input/aim_quantizer.dart';
import 'cooldown_ring.dart';

class DirectionalActionButton extends StatefulWidget {
  const DirectionalActionButton({
    super.key,
    required this.label,
    required this.icon,
    required this.onAimDir,
    required this.onAimClear,
    required this.onCommit,
    required this.projectileAimPreview,
    this.cancelHitboxRect,
    this.affordable = true,
    this.cooldownTicksLeft = 0,
    this.cooldownTicksTotal = 0,
    this.size = 72,
    this.deadzoneRadius = 12,
    this.backgroundColor = const Color(0x33000000),
    this.foregroundColor = Colors.white,
    this.labelFontSize = 12,
    this.labelGap = 2,
  });

  final String label;
  final IconData icon;
  final void Function(double x, double y) onAimDir;
  final VoidCallback onAimClear;
  final VoidCallback onCommit;
  final AimPreviewModel projectileAimPreview;
  final ValueListenable<Rect?>? cancelHitboxRect;
  final bool affordable;
  final int cooldownTicksLeft;
  final int cooldownTicksTotal;
  final double size;
  final double deadzoneRadius;
  final Color backgroundColor;
  final Color foregroundColor;
  final double labelFontSize;
  final double labelGap;

  @override
  State<DirectionalActionButton> createState() =>
      _DirectionalActionButtonState();
}

class _DirectionalActionButtonState extends State<DirectionalActionButton> {
  int? _pointer;
  bool _canceled = false;

  @override
  Widget build(BuildContext context) {
    final interactable = widget.affordable && widget.cooldownTicksLeft <= 0;
    final effectiveForeground = widget.affordable
        ? widget.foregroundColor
        : _disabledForeground(widget.foregroundColor);
    final effectiveBackground = widget.affordable
        ? widget.backgroundColor
        : _disabledBackground(widget.backgroundColor);

    return SizedBox(
      width: widget.size,
      height: widget.size,
      child: Stack(
        fit: StackFit.expand,
        children: [
          IgnorePointer(
            ignoring: !interactable,
            child: Listener(
              onPointerDown: _handlePointerDown,
              onPointerMove: _handlePointerMove,
              onPointerUp: _handlePointerUp,
              onPointerCancel: _handlePointerCancel,
              child: Material(
                color: effectiveBackground,
                shape: const CircleBorder(),
                child: Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Icon(widget.icon, color: effectiveForeground),
                      SizedBox(height: widget.labelGap),
                      Text(
                        widget.label,
                        style: TextStyle(
                          fontSize: widget.labelFontSize,
                          color: effectiveForeground,
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            ),
          ),
          IgnorePointer(
            child: CooldownRing(
              cooldownTicksLeft: widget.cooldownTicksLeft,
              cooldownTicksTotal: widget.cooldownTicksTotal,
            ),
          ),
        ],
      ),
    );
  }

  void _handlePointerDown(PointerDownEvent event) {
    if (_pointer != null) return;
    _pointer = event.pointer;
    _canceled = false;
    widget.projectileAimPreview.begin();
    widget.onAimClear();
    _updateAim(event.localPosition);
  }

  void _handlePointerMove(PointerMoveEvent event) {
    if (event.pointer != _pointer) return;
    _updateAim(event.localPosition);
  }

  void _handlePointerUp(PointerUpEvent event) {
    if (event.pointer != _pointer) return;

    // Cancel is decided by where the pointer is released in *screen space*.
    // (The cancel hitbox cannot receive pointer events because the pointer
    // started on this button, so we must hit-test using the global position.)
    final cancelRect = widget.cancelHitboxRect?.value;
    if (cancelRect != null && cancelRect.contains(event.position)) {
      _cancelAim();
    }

    if (!_canceled) {
      widget.onCommit();
    }
    _resetAim();
  }

  void _handlePointerCancel(PointerCancelEvent event) {
    if (event.pointer != _pointer) return;
    // System canceled the pointer stream -> treat as Cancel (never commit).
    _cancelAim();
    _resetAim();
  }

  void _updateAim(Offset localPosition) {
    if (_canceled) return;
    final center = Offset(widget.size / 2, widget.size / 2);
    final dx = localPosition.dx - center.dx;
    final dy = localPosition.dy - center.dy;
    final len = math.sqrt(dx * dx + dy * dy);
    if (len <= widget.deadzoneRadius) {
      widget.onAimClear();
      widget.projectileAimPreview.clearAim();
      return;
    }
    final nx = dx / len;
    final ny = dy / len;
    final qx = AimQuantizer.quantize(nx);
    final qy = AimQuantizer.quantize(ny);
    widget.onAimDir(qx, qy);
    widget.projectileAimPreview.updateAim(qx, qy);
  }

  void _cancelAim() {
    if (_canceled) return;
    _canceled = true;
    widget.onAimClear();
    widget.projectileAimPreview.end();
  }

  void _resetAim() {
    _pointer = null;
    _canceled = false;
    widget.onAimClear();
    widget.projectileAimPreview.end();
  }

  Color _disabledForeground(Color color) => color.withValues(alpha: 0.35);

  Color _disabledBackground(Color color) =>
      color.withValues(alpha: color.a * 0.6);
}


===== FILE: lib/ui/controls/fixed_joystick.dart =====
import 'package:flutter/widgets.dart';

/// Fixed-position horizontal joystick.
///
/// - Only outputs an X axis in `[-1, 1]`.
/// - Centered at the widget's bounds; drag left/right to set axis.
class FixedJoystick extends StatefulWidget {
  const FixedJoystick({
    super.key,
    required this.onAxisChanged,
    this.size = 120,
    this.knobSize = 56,
    this.baseColor = const Color(0x33000000),
    this.baseBorderColor = const Color(0x55FFFFFF),
    this.baseBorderWidth = 1,
    this.knobColor = const Color(0x66FFFFFF),
    this.knobBorderColor = const Color(0x88FFFFFF),
    this.knobBorderWidth = 1,
  });

  final ValueChanged<double> onAxisChanged;
  final double size;
  final double knobSize;
  final Color baseColor;
  final Color baseBorderColor;
  final double baseBorderWidth;
  final Color knobColor;
  final Color knobBorderColor;
  final double knobBorderWidth;

  @override
  State<FixedJoystick> createState() => _FixedJoystickState();
}

class _FixedJoystickState extends State<FixedJoystick> {
  double _axis = 0;

  @override
  Widget build(BuildContext context) {
    final baseSize = widget.size;
    final knobSize = widget.knobSize;
    final radius = (baseSize - knobSize) / 2;

    return SizedBox(
      width: baseSize,
      height: baseSize,
      child: GestureDetector(
        onPanStart: (d) => _update(d.localPosition, radius),
        onPanUpdate: (d) => _update(d.localPosition, radius),
        onPanEnd: (_) => _setAxis(0),
        onPanCancel: () => _setAxis(0),
        child: Stack(
          children: [
            Positioned.fill(
              child: Center(
                child: Container(
                  width: baseSize,
                  height: baseSize,
                  decoration: BoxDecoration(
                    color: widget.baseColor,
                    shape: BoxShape.circle,
                    border: Border.all(
                      color: widget.baseBorderColor,
                      width: widget.baseBorderWidth,
                    ),
                  ),
                ),
              ),
            ),
            Positioned.fill(
              child: Center(
                child: Transform.translate(
                  offset: Offset(_axis * radius, 0),
                  child: Container(
                    width: knobSize,
                    height: knobSize,
                    decoration: BoxDecoration(
                      color: widget.knobColor,
                      shape: BoxShape.circle,
                      border: Border.all(
                        color: widget.knobBorderColor,
                        width: widget.knobBorderWidth,
                      ),
                    ),
                  ),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  void _update(Offset local, double radius) {
    final center = Offset(widget.size / 2, widget.size / 2);
    final dx = local.dx - center.dx;
    final clamped = dx.clamp(-radius, radius);
    final axis = radius <= 0 ? 0.0 : clamped / radius;
    _setAxis(axis);
  }

  void _setAxis(double axis) {
    final a = axis.clamp(-1.0, 1.0);
    if (a == _axis) return;
    setState(() => _axis = a);
    widget.onAxisChanged(a);
  }
}


===== FILE: lib/ui/controls/floating_joystick.dart =====
import 'package:flutter/widgets.dart';

/// Floating horizontal joystick.
///
/// - Touch anywhere inside the widget bounds to place the base.
/// - Drag left/right to set axis in `[-1, 1]`.
/// - Soft-follow: when dragged past the knob radius, the base eases toward the
///   pointer so the gesture stays comfortable.
/// - Release to snap back to center and hide.
class FloatingJoystick extends StatefulWidget {
  const FloatingJoystick({
    super.key,
    required this.onAxisChanged,
    this.areaSize = 220,
    this.baseSize = 120,
    this.knobSize = 56,
    this.followSmoothing = 0.25,
    this.baseColor = const Color(0x33000000),
    this.baseBorderColor = const Color(0x55FFFFFF),
    this.baseBorderWidth = 1,
    this.knobColor = const Color(0x66FFFFFF),
    this.knobBorderColor = const Color(0x88FFFFFF),
    this.knobBorderWidth = 1,
  });

  final ValueChanged<double> onAxisChanged;

  /// Size of the touch area (square).
  final double areaSize;

  /// Visual size of the joystick base circle.
  final double baseSize;

  /// Visual size of the joystick knob circle.
  final double knobSize;

  /// How strongly the base follows the pointer when stretched past the knob
  /// radius.
  ///
  /// - `0`: no follow (base stays where pressed).
  /// - `1`: hard follow (base snaps to keep the pointer on the edge).
  final double followSmoothing;
  final Color baseColor;
  final Color baseBorderColor;
  final double baseBorderWidth;
  final Color knobColor;
  final Color knobBorderColor;
  final double knobBorderWidth;

  @override
  State<FloatingJoystick> createState() => _FloatingJoystickState();
}

class _FloatingJoystickState extends State<FloatingJoystick> {
  int? _activePointer;
  Offset? _baseCenter;
  double _axis = 0;

  @override
  Widget build(BuildContext context) {
    final areaSize = widget.areaSize;
    final baseSize = widget.baseSize;
    final knobSize = widget.knobSize;
    final radius = (baseSize - knobSize) / 2;

    return SizedBox(
      width: areaSize,
      height: areaSize,
      child: Listener(
        behavior: HitTestBehavior.opaque,
        onPointerDown: (e) => _onPointerDown(e, radius),
        onPointerMove: (e) => _onPointerMove(e, radius),
        onPointerUp: _onPointerUp,
        onPointerCancel: _onPointerCancel,
        child: Stack(
          children: [
            if (_baseCenter case final baseCenter?) ...[
              _JoystickBase(
                center: baseCenter,
                size: baseSize,
                color: widget.baseColor,
                borderColor: widget.baseBorderColor,
                borderWidth: widget.baseBorderWidth,
              ),
              _JoystickKnob(
                center: baseCenter.translate(_axis * radius, 0),
                size: knobSize,
                color: widget.knobColor,
                borderColor: widget.knobBorderColor,
                borderWidth: widget.knobBorderWidth,
              ),
            ],
          ],
        ),
      ),
    );
  }

  void _onPointerDown(PointerDownEvent event, double radius) {
    if (_activePointer != null) return;
    final center = _clampBaseCenter(event.localPosition);
    setState(() {
      _activePointer = event.pointer;
      _baseCenter = center;
      _axis = 0;
    });
    widget.onAxisChanged(0);
  }

  void _onPointerMove(PointerMoveEvent event, double radius) {
    if (event.pointer != _activePointer) return;
    final baseCenter = _baseCenter;
    if (baseCenter == null) return;

    final pointer = event.localPosition;

    var nextBaseCenter = baseCenter;
    if (radius > 0) {
      final delta = pointer - baseCenter;
      final dist = delta.distance;
      if (dist > radius && dist > 0) {
        final targetBaseCenter = pointer - (delta / dist) * radius;
        final t = widget.followSmoothing.clamp(0.0, 1.0).toDouble();
        nextBaseCenter =
            Offset.lerp(baseCenter, targetBaseCenter, t) ?? baseCenter;
        nextBaseCenter = _clampBaseCenter(nextBaseCenter);
      }
    }

    final dx = pointer.dx - nextBaseCenter.dx;
    final clamped = dx.clamp(-radius, radius);
    final axis = radius <= 0 ? 0.0 : clamped / radius;
    _setBaseAndAxis(baseCenter: nextBaseCenter, axis: axis);
  }

  void _onPointerUp(PointerUpEvent event) {
    if (event.pointer != _activePointer) return;
    _reset();
  }

  void _onPointerCancel(PointerCancelEvent event) {
    if (event.pointer != _activePointer) return;
    _reset();
  }

  Offset _clampBaseCenter(Offset local) {
    final areaSize = widget.areaSize;
    final baseSize = widget.baseSize;
    final halfBase = baseSize / 2;

    if (areaSize <= baseSize) {
      return Offset(areaSize / 2, areaSize / 2);
    }

    final clampedX = local.dx.clamp(halfBase, areaSize - halfBase).toDouble();
    final clampedY = local.dy.clamp(halfBase, areaSize - halfBase).toDouble();
    return Offset(clampedX, clampedY);
  }

  void _reset() {
    final shouldNotify = _axis != 0;
    setState(() {
      _activePointer = null;
      _baseCenter = null;
      _axis = 0;
    });
    if (shouldNotify) widget.onAxisChanged(0);
  }

  void _setBaseAndAxis({required Offset baseCenter, required double axis}) {
    final nextAxis = axis.clamp(-1.0, 1.0);
    final axisChanged = nextAxis != _axis;
    final baseChanged = baseCenter != _baseCenter;
    if (!axisChanged && !baseChanged) return;

    setState(() {
      _baseCenter = baseCenter;
      _axis = nextAxis;
    });
    if (axisChanged) widget.onAxisChanged(nextAxis);
  }
}

class _JoystickBase extends StatelessWidget {
  const _JoystickBase({
    required this.center,
    required this.size,
    required this.color,
    required this.borderColor,
    required this.borderWidth,
  });

  final Offset center;
  final double size;
  final Color color;
  final Color borderColor;
  final double borderWidth;

  @override
  Widget build(BuildContext context) {
    return Positioned(
      left: center.dx - size / 2,
      top: center.dy - size / 2,
      width: size,
      height: size,
      child: Container(
        decoration: BoxDecoration(
          color: color,
          shape: BoxShape.circle,
          border: Border.all(color: borderColor, width: borderWidth),
        ),
      ),
    );
  }
}

class _JoystickKnob extends StatelessWidget {
  const _JoystickKnob({
    required this.center,
    required this.size,
    required this.color,
    required this.borderColor,
    required this.borderWidth,
  });

  final Offset center;
  final double size;
  final Color color;
  final Color borderColor;
  final double borderWidth;

  @override
  Widget build(BuildContext context) {
    return Positioned(
      left: center.dx - size / 2,
      top: center.dy - size / 2,
      width: size,
      height: size,
      child: Container(
        decoration: BoxDecoration(
          color: color,
          shape: BoxShape.circle,
          border: Border.all(color: borderColor, width: borderWidth),
        ),
      ),
    );
  }
}


===== FILE: lib/ui/controls/runner_controls_overlay(radial).dart =====
import 'dart:math' as math;

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

import '../../game/input/aim_preview.dart';
import 'package:rpg_runner/core/snapshots/enums.dart';
import 'action_button.dart';
import 'controls_tuning.dart';
import 'directional_action_button.dart';
import 'fixed_joystick.dart';
import 'floating_joystick.dart';

class RunnerControlsOverlay extends StatelessWidget {
  const RunnerControlsOverlay({
    super.key,
    required this.onMoveAxis,
    required this.onJumpPressed,
    required this.onDashPressed,
    required this.onSecondaryPressed,
    required this.onBonusPressed,
    required this.onBonusCommitted,
    required this.onProjectileCommitted,
    required this.onProjectilePressed,
    required this.onProjectileAimDir,
    required this.onProjectileAimClear,
    required this.projectileAimPreview,
    required this.projectileAffordable,
    required this.projectileCooldownTicksLeft,
    required this.projectileCooldownTicksTotal,
    required this.onMeleeAimDir,
    required this.onMeleeAimClear,
    required this.onMeleeCommitted,
    required this.onMeleePressed,
    required this.meleeAimPreview,
    required this.aimCancelHitboxRect,
    required this.meleeAffordable,
    required this.meleeCooldownTicksLeft,
    required this.meleeCooldownTicksTotal,
    required this.meleeInputMode,
    required this.projectileInputMode,
    required this.bonusInputMode,
    required this.bonusUsesMeleeAim,
    required this.jumpAffordable,
    required this.dashAffordable,
    required this.dashCooldownTicksLeft,
    required this.dashCooldownTicksTotal,
    required this.secondaryAffordable,
    required this.secondaryCooldownTicksLeft,
    required this.secondaryCooldownTicksTotal,
    required this.bonusAffordable,
    required this.bonusCooldownTicksLeft,
    required this.bonusCooldownTicksTotal,
    this.tuning = ControlsTuning.fixed,
  });

  final ValueChanged<double> onMoveAxis;
  final VoidCallback onJumpPressed;
  final VoidCallback onDashPressed;
  final VoidCallback onSecondaryPressed;
  final VoidCallback onBonusPressed;
  final VoidCallback onBonusCommitted;
  final VoidCallback onProjectileCommitted;
  final VoidCallback onProjectilePressed;
  final void Function(double x, double y) onProjectileAimDir;
  final VoidCallback onProjectileAimClear;
  final AimPreviewModel projectileAimPreview;
  final bool projectileAffordable;
  final int projectileCooldownTicksLeft;
  final int projectileCooldownTicksTotal;
  final void Function(double x, double y) onMeleeAimDir;
  final VoidCallback onMeleeAimClear;
  final VoidCallback onMeleeCommitted;
  final VoidCallback onMeleePressed;
  final AimPreviewModel meleeAimPreview;
  final ValueListenable<Rect?> aimCancelHitboxRect;
  final bool meleeAffordable;
  final int meleeCooldownTicksLeft;
  final int meleeCooldownTicksTotal;
  final AbilityInputMode meleeInputMode;
  final AbilityInputMode projectileInputMode;

  final AbilityInputMode bonusInputMode;
  final bool bonusUsesMeleeAim;
  final bool jumpAffordable;
  final bool dashAffordable;
  final int dashCooldownTicksLeft;
  final int dashCooldownTicksTotal;
  final bool secondaryAffordable;
  final int secondaryCooldownTicksLeft;
  final int secondaryCooldownTicksTotal;
  final bool bonusAffordable;
  final int bonusCooldownTicksLeft;
  final int bonusCooldownTicksTotal;
  final ControlsTuning tuning;

  @override
  Widget build(BuildContext context) {
    final t = tuning;
    final action = t.actionButton;
    final directional = t.directionalActionButton;
    final jumpSize = action.size * 1.4;
    final smallActionSize = action.size * 0.9;
    final smallDirectionalSize = directional.size * 0.9;
    final smallDeadzoneRadius = directional.deadzoneRadius * 0.9;

    // Arrange the 5 action slots (Mobility, Secondary, Primary, Projectile, Bonus)
    // in a clean radial arc around the Jump button.

    Offset polar(double radius, double degrees) {
      final radians = degrees * math.pi / 180.0;
      return Offset(math.cos(radians) * radius, math.sin(radians) * radius);
    }

    double rightFor(Offset centerOffset, double targetSize) {
      return t.edgePadding + jumpSize * 0.5 - centerOffset.dx - targetSize * 0.5;
    }

    double bottomFor(Offset centerOffset, double targetSize) {
      return t.edgePadding + jumpSize * 0.5 - centerOffset.dy - targetSize * 0.5;
    }

    final jumpRadius = jumpSize * 0.5;
    final ringGap = t.buttonGap * 0.9;
    final ringRadius =
        jumpRadius + math.max(smallDirectionalSize, smallActionSize) * 0.5 + ringGap;

    // Evenly spread the 5 action buttons over an arc above/left of the jump.
    // Degrees follow the standard unit circle, but note Flutter's Y axis points down.
    const startDeg = 160.0;
    const stepDeg = 35.0;

    final dashOffset = polar(ringRadius, startDeg + stepDeg * 0);
    final meleeOffset = polar(ringRadius, startDeg + stepDeg * 0.2);
    final secondaryOffset = polar(ringRadius, startDeg + stepDeg * 1.6);
    final projectileOffset = polar(ringRadius, startDeg + stepDeg * 3);
    final bonusOffset = polar(ringRadius, startDeg + stepDeg * 4);

    return Stack(
      children: [
        Positioned(
          left: t.edgePadding,
          bottom: t.bottomEdgePadding,
          child: t.joystickKind == ControlsJoystickKind.floating
              ? FloatingJoystick(
                  onAxisChanged: onMoveAxis,
                  areaSize: t.floatingJoystick.areaSize,
                  baseSize: t.floatingJoystick.baseSize,
                  knobSize: t.floatingJoystick.knobSize,
                  followSmoothing: t.floatingJoystick.followSmoothing,
                  baseColor: t.floatingJoystick.baseColor,
                  baseBorderColor: t.floatingJoystick.baseBorderColor,
                  baseBorderWidth: t.floatingJoystick.baseBorderWidth,
                  knobColor: t.floatingJoystick.knobColor,
                  knobBorderColor: t.floatingJoystick.knobBorderColor,
                  knobBorderWidth: t.floatingJoystick.knobBorderWidth,
                )
              : FixedJoystick(
                  onAxisChanged: onMoveAxis,
                  size: t.fixedJoystick.size,
                  knobSize: t.fixedJoystick.knobSize,
                  baseColor: t.fixedJoystick.baseColor,
                  baseBorderColor: t.fixedJoystick.baseBorderColor,
                  baseBorderWidth: t.fixedJoystick.baseBorderWidth,
                  knobColor: t.fixedJoystick.knobColor,
                  knobBorderColor: t.fixedJoystick.knobBorderColor,
                  knobBorderWidth: t.fixedJoystick.knobBorderWidth,
                ),
        ),
        Positioned(
          right: rightFor(projectileOffset, smallDirectionalSize),
          bottom: bottomFor(projectileOffset, smallDirectionalSize),
          child: projectileInputMode == AbilityInputMode.tap
              ? ActionButton(
                  label: 'Projectile',
                  icon: Icons.auto_awesome,
                  onPressed: onProjectilePressed,
                  affordable: projectileAffordable,
                  cooldownTicksLeft: projectileCooldownTicksLeft,
                  cooldownTicksTotal: projectileCooldownTicksTotal,
                  size: smallDirectionalSize,
                  backgroundColor: action.backgroundColor,
                  foregroundColor: action.foregroundColor,
                  labelFontSize: action.labelFontSize,
                  labelGap: action.labelGap,
                )
              : DirectionalActionButton(
                  label: 'Projectile',
                  icon: Icons.auto_awesome,
                  onAimDir: onProjectileAimDir,
                  onAimClear: onProjectileAimClear,
                  onCommit: onProjectileCommitted,
                  projectileAimPreview: projectileAimPreview,
                  cancelHitboxRect: aimCancelHitboxRect,
                  affordable: projectileAffordable,
                  cooldownTicksLeft: projectileCooldownTicksLeft,
                  cooldownTicksTotal: projectileCooldownTicksTotal,
                  size: smallDirectionalSize,
                  deadzoneRadius: smallDeadzoneRadius,
                  backgroundColor: directional.backgroundColor,
                  foregroundColor: directional.foregroundColor,
                  labelFontSize: directional.labelFontSize,
                  labelGap: directional.labelGap,
                ),
        ),
        Positioned(
          right: rightFor(bonusOffset, smallActionSize),
          bottom: bottomFor(bonusOffset, smallActionSize),
          child: bonusInputMode == AbilityInputMode.tap
              ? ActionButton(
                  label: 'Bonus',
                  icon: Icons.star,
                  onPressed: onBonusPressed,
                  affordable: bonusAffordable,
                  cooldownTicksLeft: bonusCooldownTicksLeft,
                  cooldownTicksTotal: bonusCooldownTicksTotal,
                  size: smallActionSize,
                  backgroundColor: action.backgroundColor,
                  foregroundColor: action.foregroundColor,
                  labelFontSize: action.labelFontSize,
                  labelGap: action.labelGap,
                )
              : DirectionalActionButton(
                  label: 'Bonus',
                  icon: Icons.star,
                  onAimDir: bonusUsesMeleeAim ? onMeleeAimDir : onProjectileAimDir,
                  onAimClear: bonusUsesMeleeAim ? onMeleeAimClear : onProjectileAimClear,
                  onCommit: onBonusCommitted,
                  projectileAimPreview:
                      bonusUsesMeleeAim ? meleeAimPreview : projectileAimPreview,
                  cancelHitboxRect: aimCancelHitboxRect,
                  affordable: bonusAffordable,
                  cooldownTicksLeft: bonusCooldownTicksLeft,
                  cooldownTicksTotal: bonusCooldownTicksTotal,
                  size: smallDirectionalSize,
                  deadzoneRadius: smallDeadzoneRadius,
                  backgroundColor: directional.backgroundColor,
                  foregroundColor: directional.foregroundColor,
                  labelFontSize: directional.labelFontSize,
                  labelGap: directional.labelGap,
                ),
        ),
        Positioned(
          right: rightFor(secondaryOffset, smallActionSize),
          bottom: bottomFor(secondaryOffset, smallActionSize),
          child: ActionButton(
            label: 'Sec',
            icon: Icons.shield,
            onPressed: onSecondaryPressed,
            affordable: secondaryAffordable,
            cooldownTicksLeft: secondaryCooldownTicksLeft,
            cooldownTicksTotal: secondaryCooldownTicksTotal,
            size: smallActionSize,
            backgroundColor: action.backgroundColor,
            foregroundColor: action.foregroundColor,
            labelFontSize: action.labelFontSize,
            labelGap: action.labelGap,
          ),
        ),
        Positioned(
          right: rightFor(meleeOffset, smallDirectionalSize),
          bottom: bottomFor(meleeOffset, smallDirectionalSize),
          child: meleeInputMode == AbilityInputMode.tap
              ? ActionButton(
                  label: 'Atk',
                  icon: Icons.close,
                  onPressed: onMeleePressed,
                  affordable: meleeAffordable,
                  cooldownTicksLeft: meleeCooldownTicksLeft,
                  cooldownTicksTotal: meleeCooldownTicksTotal,
                  size: smallDirectionalSize,
                  backgroundColor: action.backgroundColor,
                  foregroundColor: action.foregroundColor,
                  labelFontSize: action.labelFontSize,
                  labelGap: action.labelGap,
                )
              : DirectionalActionButton(
                  label: 'Atk',
                  icon: Icons.close,
                  onAimDir: onMeleeAimDir,
                  onAimClear: onMeleeAimClear,
                  onCommit: onMeleeCommitted,
                  projectileAimPreview: meleeAimPreview,
                  cancelHitboxRect: aimCancelHitboxRect,
                  affordable: meleeAffordable,
                  cooldownTicksLeft: meleeCooldownTicksLeft,
                  cooldownTicksTotal: meleeCooldownTicksTotal,
                  size: smallDirectionalSize,
                  deadzoneRadius: smallDeadzoneRadius,
                  backgroundColor: directional.backgroundColor,
                  foregroundColor: directional.foregroundColor,
                  labelFontSize: directional.labelFontSize,
                  labelGap: directional.labelGap,
                ),
        ),
        Positioned(
          right: rightFor(dashOffset, smallActionSize),
          bottom: bottomFor(dashOffset, smallActionSize),
          child: ActionButton(
            label: 'Dash',
            icon: Icons.flash_on,
            onPressed: onDashPressed,
            affordable: dashAffordable,
            cooldownTicksLeft: dashCooldownTicksLeft,
            cooldownTicksTotal: dashCooldownTicksTotal,
            size: smallActionSize,
            backgroundColor: action.backgroundColor,
            foregroundColor: action.foregroundColor,
            labelFontSize: action.labelFontSize,
            labelGap: action.labelGap,
          ),
        ),
        Positioned(
          right: t.edgePadding,
          bottom: t.edgePadding,
          child: ActionButton(
            label: 'Jump',
            icon: Icons.arrow_upward,
            onPressed: onJumpPressed,
            affordable: jumpAffordable,
            size: jumpSize,
            backgroundColor: action.backgroundColor,
            foregroundColor: action.foregroundColor,
            labelFontSize: action.labelFontSize,
            labelGap: action.labelGap,
          ),
        ),
      ],
    );
  }
}


===== FILE: lib/ui/controls/runner_controls_overlay.dart =====
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

import '../../game/input/aim_preview.dart';
import 'package:rpg_runner/core/snapshots/enums.dart';
import 'action_button.dart';
import 'controls_tuning.dart';
import 'directional_action_button.dart';
import 'fixed_joystick.dart';
import 'floating_joystick.dart';

class RunnerControlsOverlay extends StatelessWidget {
  const RunnerControlsOverlay({
    super.key,
    required this.onMoveAxis,
    required this.onJumpPressed,
    required this.onDashPressed,
    required this.onSecondaryPressed,
    required this.onBonusPressed,
    required this.onBonusCommitted,
    required this.onProjectileCommitted,
    required this.onProjectilePressed,
    required this.onProjectileAimDir,
    required this.onProjectileAimClear,
    required this.projectileAimPreview,
    required this.projectileAffordable,
    required this.projectileCooldownTicksLeft,
    required this.projectileCooldownTicksTotal,
    required this.onMeleeAimDir,
    required this.onMeleeAimClear,
    required this.onMeleeCommitted,
    required this.onMeleePressed,
    required this.meleeAimPreview,
    required this.aimCancelHitboxRect,
    required this.meleeAffordable,
    required this.meleeCooldownTicksLeft,
    required this.meleeCooldownTicksTotal,
    required this.meleeInputMode,
    required this.projectileInputMode,
    required this.bonusInputMode,
    required this.bonusUsesMeleeAim,
    required this.jumpAffordable,
    required this.dashAffordable,
    required this.dashCooldownTicksLeft,
    required this.dashCooldownTicksTotal,
    required this.secondaryAffordable,
    required this.secondaryCooldownTicksLeft,
    required this.secondaryCooldownTicksTotal,
    required this.bonusAffordable,
    required this.bonusCooldownTicksLeft,
    required this.bonusCooldownTicksTotal,
    this.tuning = ControlsTuning.fixed,
  });

  final ValueChanged<double> onMoveAxis;
  final VoidCallback onJumpPressed;
  final VoidCallback onDashPressed;
  final VoidCallback onSecondaryPressed;
  final VoidCallback onBonusPressed;
  final VoidCallback onBonusCommitted;
  final VoidCallback onProjectileCommitted;
  final VoidCallback onProjectilePressed;
  final void Function(double x, double y) onProjectileAimDir;
  final VoidCallback onProjectileAimClear;
  final AimPreviewModel projectileAimPreview;
  final bool projectileAffordable;
  final int projectileCooldownTicksLeft;
  final int projectileCooldownTicksTotal;
  final void Function(double x, double y) onMeleeAimDir;
  final VoidCallback onMeleeAimClear;
  final VoidCallback onMeleeCommitted;
  final VoidCallback onMeleePressed;
  final AimPreviewModel meleeAimPreview;
  final ValueListenable<Rect?> aimCancelHitboxRect;
  final bool meleeAffordable;
  final int meleeCooldownTicksLeft;
  final int meleeCooldownTicksTotal;
  final AbilityInputMode meleeInputMode;
  final AbilityInputMode projectileInputMode;

  final AbilityInputMode bonusInputMode;
  final bool bonusUsesMeleeAim;
  final bool jumpAffordable;
  final bool dashAffordable;
  final int dashCooldownTicksLeft;
  final int dashCooldownTicksTotal;
  final bool secondaryAffordable;
  final int secondaryCooldownTicksLeft;
  final int secondaryCooldownTicksTotal;
  final bool bonusAffordable;
  final int bonusCooldownTicksLeft;
  final int bonusCooldownTicksTotal;
  final ControlsTuning tuning;

  @override
  Widget build(BuildContext context) {
    final t = tuning;
    final action = t.actionButton;
    final directional = t.directionalActionButton;

    // Uniform size for all buttons in the grid
    final btnSize = action.size;

    // Grid configuration
    final gap = t.buttonGap;

    // 2x3 Grid definition (col, row) -> 0-indexed
    // col 0 is rightmost, row 0 is bottom
    //
    // [Secondary (0,1)] [Projectile (1,1)] [Bonus (2,1)]
    // [Jump (0,0)]      [Melee (1,0)]      [Dash (2,0)]

    double rightForCol(int col) {
      return t.edgePadding + col * (btnSize + gap);
    }

    double bottomForRow(int row) {
      return t.edgePadding + row * (btnSize + gap);
    }

    return Stack(
      children: [
        Positioned(
          left: t.edgePadding,
          bottom: t.bottomEdgePadding,
          child: t.joystickKind == ControlsJoystickKind.floating
              ? FloatingJoystick(
                  onAxisChanged: onMoveAxis,
                  areaSize: t.floatingJoystick.areaSize,
                  baseSize: t.floatingJoystick.baseSize,
                  knobSize: t.floatingJoystick.knobSize,
                  followSmoothing: t.floatingJoystick.followSmoothing,
                  baseColor: t.floatingJoystick.baseColor,
                  baseBorderColor: t.floatingJoystick.baseBorderColor,
                  baseBorderWidth: t.floatingJoystick.baseBorderWidth,
                  knobColor: t.floatingJoystick.knobColor,
                  knobBorderColor: t.floatingJoystick.knobBorderColor,
                  knobBorderWidth: t.floatingJoystick.knobBorderWidth,
                )
              : FixedJoystick(
                  onAxisChanged: onMoveAxis,
                  size: t.fixedJoystick.size,
                  knobSize: t.fixedJoystick.knobSize,
                  baseColor: t.fixedJoystick.baseColor,
                  baseBorderColor: t.fixedJoystick.baseBorderColor,
                  baseBorderWidth: t.fixedJoystick.baseBorderWidth,
                  knobColor: t.fixedJoystick.knobColor,
                  knobBorderColor: t.fixedJoystick.knobBorderColor,
                  knobBorderWidth: t.fixedJoystick.knobBorderWidth,
                ),
        ),

        // --- Row 1 (Top) ---

        // Mob (Dash): Col 0, Row 1 (Top Right)
        Positioned(
          right: rightForCol(0),
          bottom: bottomForRow(1),
          child: ActionButton(
            label: 'Mob',
            icon: Icons.flash_on,
            onPressed: onDashPressed,
            affordable: dashAffordable,
            cooldownTicksLeft: dashCooldownTicksLeft,
            cooldownTicksTotal: dashCooldownTicksTotal,
            size: btnSize,
            backgroundColor: action.backgroundColor,
            foregroundColor: action.foregroundColor,
            labelFontSize: action.labelFontSize,
            labelGap: action.labelGap,
          ),
        ),

        // Prim (Melee): Col 1, Row 1 (Top Middle)
        Positioned(
          right: rightForCol(1),
          bottom: bottomForRow(1),
          child: meleeInputMode == AbilityInputMode.tap
              ? ActionButton(
                  label: 'Prim',
                  icon: Icons.close,
                  onPressed: onMeleePressed,
                  affordable: meleeAffordable,
                  cooldownTicksLeft: meleeCooldownTicksLeft,
                  cooldownTicksTotal: meleeCooldownTicksTotal,
                  size: btnSize,
                  backgroundColor: action.backgroundColor,
                  foregroundColor: action.foregroundColor,
                  labelFontSize: action.labelFontSize,
                  labelGap: action.labelGap,
                )
              : DirectionalActionButton(
                  label: 'Prim',
                  icon: Icons.close,
                  onAimDir: onMeleeAimDir,
                  onAimClear: onMeleeAimClear,
                  onCommit: onMeleeCommitted,
                  projectileAimPreview: meleeAimPreview,
                  cancelHitboxRect: aimCancelHitboxRect,
                  affordable: meleeAffordable,
                  cooldownTicksLeft: meleeCooldownTicksLeft,
                  cooldownTicksTotal: meleeCooldownTicksTotal,
                  size: btnSize,
                  deadzoneRadius: directional.deadzoneRadius,
                  backgroundColor: directional.backgroundColor,
                  foregroundColor: directional.foregroundColor,
                  labelFontSize: directional.labelFontSize,
                  labelGap: directional.labelGap,
                ),
        ),

        // Proj (Projectile): Col 2, Row 1 (Top Left)
        Positioned(
          right: rightForCol(2),
          bottom: bottomForRow(1),
          child: projectileInputMode == AbilityInputMode.tap
              ? ActionButton(
                  label: 'Proj',
                  icon: Icons.auto_awesome,
                  onPressed: onProjectilePressed,
                  affordable: projectileAffordable,
                  cooldownTicksLeft: projectileCooldownTicksLeft,
                  cooldownTicksTotal: projectileCooldownTicksTotal,
                  size: btnSize,
                  backgroundColor: action.backgroundColor,
                  foregroundColor: action.foregroundColor,
                  labelFontSize: action.labelFontSize,
                  labelGap: action.labelGap,
                )
              : DirectionalActionButton(
                  label: 'Proj',
                  icon: Icons.auto_awesome,
                  onAimDir: onProjectileAimDir,
                  onAimClear: onProjectileAimClear,
                  onCommit: onProjectileCommitted,
                  projectileAimPreview: projectileAimPreview,
                  cancelHitboxRect: aimCancelHitboxRect,
                  affordable: projectileAffordable,
                  cooldownTicksLeft: projectileCooldownTicksLeft,
                  cooldownTicksTotal: projectileCooldownTicksTotal,
                  size: btnSize,
                  deadzoneRadius:
                      directional.deadzoneRadius, // Use standard deadzone
                  backgroundColor: directional.backgroundColor,
                  foregroundColor: directional.foregroundColor,
                  labelFontSize: directional.labelFontSize,
                  labelGap: directional.labelGap,
                ),
        ),

        // --- Row 0 (Bottom) ---

        // Jump: Col 0, Row 0 (Bottom Right)
        Positioned(
          right: rightForCol(0),
          bottom: bottomForRow(0),
          child: ActionButton(
            label: 'Jump',
            icon: Icons.arrow_upward,
            onPressed: onJumpPressed,
            affordable: jumpAffordable,
            size: btnSize,
            backgroundColor: action.backgroundColor,
            foregroundColor: action.foregroundColor,
            labelFontSize: action.labelFontSize,
            labelGap: action.labelGap,
          ),
        ),

        // Sec (Secondary): Col 1, Row 0 (Bottom Middle)
        Positioned(
          right: rightForCol(1),
          bottom: bottomForRow(0),
          child: ActionButton(
            label: 'Sec',
            icon: Icons.shield,
            onPressed: onSecondaryPressed,
            affordable: secondaryAffordable,
            cooldownTicksLeft: secondaryCooldownTicksLeft,
            cooldownTicksTotal: secondaryCooldownTicksTotal,
            size: btnSize,
            backgroundColor: action.backgroundColor,
            foregroundColor: action.foregroundColor,
            labelFontSize: action.labelFontSize,
            labelGap: action.labelGap,
          ),
        ),

        // Bonus: Col 2, Row 0 (Bottom Left)
        Positioned(
          right: rightForCol(2),
          bottom: bottomForRow(0),
          child: bonusInputMode == AbilityInputMode.tap
              ? ActionButton(
                  label: 'Bonus',
                  icon: Icons.star,
                  onPressed: onBonusPressed,
                  affordable: bonusAffordable,
                  cooldownTicksLeft: bonusCooldownTicksLeft,
                  cooldownTicksTotal: bonusCooldownTicksTotal,
                  size: btnSize,
                  backgroundColor: action.backgroundColor,
                  foregroundColor: action.foregroundColor,
                  labelFontSize: action.labelFontSize,
                  labelGap: action.labelGap,
                )
              : DirectionalActionButton(
                  label: 'Bonus',
                  icon: Icons.star,
                  onAimDir: bonusUsesMeleeAim
                      ? onMeleeAimDir
                      : onProjectileAimDir,
                  onAimClear: bonusUsesMeleeAim
                      ? onMeleeAimClear
                      : onProjectileAimClear,
                  onCommit: onBonusCommitted,
                  projectileAimPreview: bonusUsesMeleeAim
                      ? meleeAimPreview
                      : projectileAimPreview,
                  cancelHitboxRect: aimCancelHitboxRect,
                  affordable: bonusAffordable,
                  cooldownTicksLeft: bonusCooldownTicksLeft,
                  cooldownTicksTotal: bonusCooldownTicksTotal,
                  size: btnSize,
                  deadzoneRadius: directional.deadzoneRadius,
                  backgroundColor: directional.backgroundColor,
                  foregroundColor: directional.foregroundColor,
                  labelFontSize: directional.labelFontSize,
                  labelGap: directional.labelGap,
                ),
        ),
      ],
    );
  }
}


===== FILE: lib/ui/dev_menu_page.dart =====
import 'package:flutter/material.dart';

import 'app/ui_routes.dart';

/// Development-only menu used by the standalone host app (`lib/main.dart`).
///
/// Not part of the embeddable runner API. Host apps should integrate the game
/// via `RunnerGameWidget` / `createRunnerGameRoute` (see `lib/runner.dart`).
class DevMenuPage extends StatelessWidget {
  const DevMenuPage({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text(
          'rpg Runner (Dev)',
          style: TextStyle(color: Colors.white),
        ),
        backgroundColor: Color.fromARGB(255, 6, 21, 48),
      ),
      body: Center(
        child: FilledButton(
          onPressed: () {
            Navigator.of(context).pushNamed(UiRoutes.hub);
          },
          child: const Text('Menu'),
        ),
      ),
    );
  }
}


===== FILE: lib/ui/hud/game/aim_cancel_button_overlay.dart =====
import 'package:flutter/material.dart';

import '../../../game/input/aim_preview.dart';

/// Visual-only cancel affordance for aimed actions.
///
/// Important: this widget does *not* receive pointer events when the player
/// started the gesture on an action button (hit testing is frozen on pointer
/// down). The action buttons must hit-test this widget's global rect on release.
class AimCancelButtonOverlay extends StatefulWidget {
  const AimCancelButtonOverlay({
    super.key,
    required this.projectileAimPreview,
    required this.meleeAimPreview,
    required this.hitboxRect,
  });

  final AimPreviewModel projectileAimPreview;
  final AimPreviewModel meleeAimPreview;

  /// Global rect (screen space) of the cancel hitbox.
  ///
  /// Directional buttons read this on pointer-up to decide whether to cancel.
  final ValueNotifier<Rect?> hitboxRect;

  @override
  State<AimCancelButtonOverlay> createState() => _AimCancelButtonOverlayState();
}

class _AimCancelButtonOverlayState extends State<AimCancelButtonOverlay> {
  final GlobalKey _hitboxKey = GlobalKey();

  @override
  void initState() {
    super.initState();
    widget.projectileAimPreview.addListener(_onAimChanged);
    widget.meleeAimPreview.addListener(_onAimChanged);
    _onAimChanged();
  }

  @override
  void didUpdateWidget(covariant AimCancelButtonOverlay oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.projectileAimPreview != widget.projectileAimPreview) {
      oldWidget.projectileAimPreview.removeListener(_onAimChanged);
      widget.projectileAimPreview.addListener(_onAimChanged);
    }
    if (oldWidget.meleeAimPreview != widget.meleeAimPreview) {
      oldWidget.meleeAimPreview.removeListener(_onAimChanged);
      widget.meleeAimPreview.addListener(_onAimChanged);
    }
    if (oldWidget.hitboxRect != widget.hitboxRect) {
      // Force recompute if the target notifier changed.
      WidgetsBinding.instance.addPostFrameCallback((_) => _syncHitboxRect());
    }
    _onAimChanged();
  }

  @override
  void dispose() {
    widget.projectileAimPreview.removeListener(_onAimChanged);
    widget.meleeAimPreview.removeListener(_onAimChanged);
    widget.hitboxRect.value = null;
    super.dispose();
  }

  bool get _active =>
      widget.projectileAimPreview.value.active || widget.meleeAimPreview.value.active;

  void _onAimChanged() {
    if (!mounted) return;
    setState(() {});
    WidgetsBinding.instance.addPostFrameCallback((_) => _syncHitboxRect());
  }

  void _syncHitboxRect() {
    if (!mounted) return;

    if (!_active) {
      if (widget.hitboxRect.value != null) {
        widget.hitboxRect.value = null;
      }
      return;
    }

    final ctx = _hitboxKey.currentContext;
    if (ctx == null) return;
    final ro = ctx.findRenderObject();
    if (ro is! RenderBox || !ro.hasSize) return;

    final topLeft = ro.localToGlobal(Offset.zero);
    final rect = topLeft & ro.size;

    if (widget.hitboxRect.value != rect) {
      widget.hitboxRect.value = rect;
    }
  }

  @override
  Widget build(BuildContext context) {
    if (!_active) return const SizedBox.shrink();

    // Fixed screen-space location between clock (top-center) and distance (top-right).
    // The hitbox is intentionally larger than the icon for mobile ergonomics.
    return Positioned(
      top: 56,
      right: 180,
      child: IgnorePointer(
        // Visual only; directional buttons do the hit-test in screen space.
        ignoring: true,
        child: SizedBox(
          key: _hitboxKey,
          width: 56,
          height: 56,
          child: DecoratedBox(
            decoration: BoxDecoration(
              color: const Color.fromARGB(26, 255, 0, 0),
              borderRadius: BorderRadius.circular(28),
            ),
            child: const Center(
              child: Icon(
                Icons.close,
                size: 22,
                color: Colors.white,
              ),
            ),
          ),
        ),
      ),
    );
  }
}


===== FILE: lib/ui/hud/game/exit_button_overlay.dart =====
import 'package:flutter/material.dart';

class ExitButtonOverlay extends StatelessWidget {
  const ExitButtonOverlay({
    super.key,
    required this.onPressed,
    required this.highlight,
  });

  final VoidCallback? onPressed;
  final bool highlight;

  @override
  Widget build(BuildContext context) {
    return Align(
      alignment: Alignment.topRight,
      child: Padding(
        padding: const EdgeInsets.all(8),
        child: IconButton(
          onPressed: onPressed,
          icon: const Icon(Icons.close),
          color: highlight ? Colors.white : null,
        ),
      ),
    );
  }
}


===== FILE: lib/ui/hud/game/game_overlay.dart =====
import 'package:flutter/widgets.dart';

import '../../../game/game_controller.dart';
import '../../../game/input/aim_preview.dart';
import '../../../game/input/runner_input_router.dart';
import '../../controls/runner_controls_overlay.dart';
import 'package:rpg_runner/core/abilities/ability_def.dart';
import '../../runner_game_ui_state.dart';
import 'pause_overlay.dart';
import 'ready_overlay.dart';
import 'top_center_hud_overlay.dart';
import 'top_left_hud_overlay.dart';
import 'top_right_hud_overlay.dart';
import 'aim_cancel_button_overlay.dart';

class GameOverlay extends StatelessWidget {
  const GameOverlay({
    super.key,
    required this.controller,
    required this.input,
    required this.projectileAimPreview,
    required this.meleeAimPreview,
    required this.aimCancelHitboxRect,
    required this.uiState,
    required this.onStart,
    required this.onTogglePause,
    required this.showExitButton,
    required this.onExit,
    required this.exitConfirmOpen,
    required this.onExitConfirmResume,
    required this.onExitConfirmExit,
  });

  final GameController controller;
  final RunnerInputRouter input;
  final AimPreviewModel projectileAimPreview;
  final AimPreviewModel meleeAimPreview;
  final ValueNotifier<Rect?> aimCancelHitboxRect;
  final RunnerGameUiState uiState;
  final VoidCallback onStart;
  final VoidCallback onTogglePause;
  final bool showExitButton;
  final VoidCallback? onExit;
  final bool exitConfirmOpen;
  final VoidCallback onExitConfirmResume;
  final VoidCallback onExitConfirmExit;

  @override
  Widget build(BuildContext context) {
    final hud = controller.snapshot.hud;

    return Stack(
      fit: StackFit.expand,
      children: [
        IgnorePointer(
          ignoring: !uiState.isRunning,
          child: RunnerControlsOverlay(
            onMoveAxis: input.setMoveAxis,
            onJumpPressed: input.pressJump,
            onDashPressed: input.pressDash,
            onSecondaryPressed: input.pressSecondary,
            onBonusPressed: input.pressBonus,
            onBonusCommitted: () => input.commitBonusWithAim(
              clearAim: true,
              usesMeleeAim: hud.bonusUsesMeleeAim,
            ),
            onProjectileCommitted: () =>
                input.commitProjectileWithAim(clearAim: true),
            onProjectilePressed: input.pressProjectile,
            onProjectileAimDir: input.setProjectileAimDir,
            onProjectileAimClear: input.clearProjectileAimDir,
            projectileAimPreview: projectileAimPreview,
            projectileAffordable: hud.canAffordProjectile,
            projectileCooldownTicksLeft:
                hud.cooldownTicksLeft[CooldownGroup.projectile],
            projectileCooldownTicksTotal:
                hud.cooldownTicksTotal[CooldownGroup.projectile],
            onMeleeAimDir: input.setMeleeAimDir,
            onMeleeAimClear: input.clearMeleeAimDir,
            onMeleeCommitted: input.commitMeleeStrike,
            onMeleePressed: input.pressStrike,
            meleeAimPreview: meleeAimPreview,
            aimCancelHitboxRect: aimCancelHitboxRect,
            meleeAffordable: hud.canAffordMelee,
            meleeCooldownTicksLeft:
                hud.cooldownTicksLeft[CooldownGroup.primary],
            meleeCooldownTicksTotal:
                hud.cooldownTicksTotal[CooldownGroup.primary],
            meleeInputMode: hud.meleeInputMode,
            projectileInputMode: hud.projectileInputMode,
            bonusInputMode: hud.bonusInputMode,
            bonusUsesMeleeAim: hud.bonusUsesMeleeAim,
            jumpAffordable: hud.canAffordJump,
            dashAffordable: hud.canAffordDash,
            dashCooldownTicksLeft:
                hud.cooldownTicksLeft[CooldownGroup.mobility],
            dashCooldownTicksTotal:
                hud.cooldownTicksTotal[CooldownGroup.mobility],
            secondaryAffordable: hud.canAffordSecondary,
            secondaryCooldownTicksLeft:
                hud.cooldownTicksLeft[CooldownGroup.secondary],
            secondaryCooldownTicksTotal:
                hud.cooldownTicksTotal[CooldownGroup.secondary],
            bonusAffordable: hud.canAffordBonus,
            bonusCooldownTicksLeft:
                hud.cooldownTicksLeft[CooldownGroup.bonus0],
            bonusCooldownTicksTotal:
                hud.cooldownTicksTotal[CooldownGroup.bonus0],
          ),
        ),
        PauseOverlay(
          visible: uiState.showPauseOverlay,
          exitConfirmOpen: exitConfirmOpen,
          onResume: onExitConfirmResume,
          onExit: onExitConfirmExit,
        ),
        ReadyOverlay(visible: uiState.showReadyOverlay, onTap: onStart),
        Align(
          alignment: Alignment.topLeft,
          child: Padding(
            padding: const EdgeInsets.all(12),
            child: TopLeftHudOverlay(controller: controller),
          ),
        ),
        TopCenterHudOverlay(
          controller: controller,
          uiState: uiState,
          onStart: onStart,
          onTogglePause: onTogglePause,
        ),
        AimCancelButtonOverlay(
          projectileAimPreview: projectileAimPreview,
          meleeAimPreview: meleeAimPreview,
          hitboxRect: aimCancelHitboxRect,
        ),
        TopRightHudOverlay(
          controller: controller,
          showExitButton: showExitButton,
          onExit: onExit,
        ),
      ],
    );
  }
}


===== FILE: lib/ui/hud/game/pause_overlay.dart =====
import 'package:flutter/material.dart';

import '../../components/overlay_button.dart';

class PauseOverlay extends StatelessWidget {
  const PauseOverlay({
    super.key,
    required this.visible,
    required this.exitConfirmOpen,
    required this.onResume,
    required this.onExit,
  });

  final bool visible;
  final bool exitConfirmOpen;
  final VoidCallback onResume;
  final VoidCallback onExit;

  @override
  Widget build(BuildContext context) {
    if (!visible) return const SizedBox.shrink();

    return SizedBox.expand(
      child: ColoredBox(
        color: const Color(0x66000000),
        child: SafeArea(
          minimum: const EdgeInsets.all(18),
          child: Center(
            child: exitConfirmOpen
                ? Column(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      const Text(
                        'Want to exit?',
                        style: TextStyle(
                          color: Color(0xFFFFFFFF),
                          fontSize: 22,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                      const SizedBox(height: 14),
                      Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          OverlayButton(label: 'Resume', onPressed: onResume),
                          const SizedBox(width: 12),
                          OverlayButton(label: 'Exit', onPressed: onExit),
                        ],
                      ),
                    ],
                  )
                : const SizedBox.shrink(),
          ),
        ),
      ),
    );
  }
}


===== FILE: lib/ui/hud/game/ready_overlay.dart =====
import 'package:flutter/widgets.dart';

class ReadyOverlay extends StatelessWidget {
  const ReadyOverlay({super.key, required this.visible, required this.onTap});

  final bool visible;
  final VoidCallback onTap;

  @override
  Widget build(BuildContext context) {
    if (!visible) return const SizedBox.shrink();

    return GestureDetector(
      behavior: HitTestBehavior.opaque,
      onTap: onTap,
      child: const ColoredBox(
        color: Color(0x88000000),
        child: Center(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Text(
                'Tap to start',
                style: TextStyle(
                  color: Color(0xFFFFFFFF),
                  fontSize: 28,
                  fontWeight: FontWeight.w600,
                ),
              ),
              SizedBox(height: 8),
              Text(
                'Survive as long as possible',
                style: TextStyle(color: Color(0xB3FFFFFF), fontSize: 14),
              ),
            ],
          ),
        ),
      ),
    );
  }
}


===== FILE: lib/ui/hud/game/score_overlay.dart =====
import 'dart:ui' show Color, FontFeature;

import 'package:flutter/widgets.dart';

import '../../../game/game_controller.dart';

class ScoreOverlay extends StatelessWidget {
  const ScoreOverlay({
    super.key,
    required this.controller,
    this.padding = const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
  });

  final GameController controller;
  final EdgeInsets padding;

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: controller,
      builder: (context, _) {
        final distanceMeters =
            (controller.snapshot.distance / 100.0).floor();
        final collectibles = controller.snapshot.hud.collectibles;
        return IgnorePointer(
          child: RepaintBoundary(
            child: Container(
              padding: padding,
              decoration: BoxDecoration(
                color: const Color(0x66000000),
                borderRadius: BorderRadius.circular(10),
              ),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Text(
                    'Distance ${distanceMeters}m',
                    textAlign: TextAlign.center,
                    style: const TextStyle(
                      fontSize: 14,
                      color: Color(0xFFFFFFFF),
                      fontFeatures: [FontFeature.tabularFigures()],
                    ),
                  ),
                  const SizedBox(height: 2),
                  Text(
                    'Collectibles $collectibles',
                    textAlign: TextAlign.center,
                    style: const TextStyle(
                      fontSize: 14,
                      color: Color(0xFFFFFFFF),
                      fontFeatures: [FontFeature.tabularFigures()],
                    ),
                  ),
                ],
              ),
            ),
          ),
        );
      },
    );
  }
}


===== FILE: lib/ui/hud/game/start_pause_button_overlay.dart =====
import 'package:flutter/material.dart';

import '../../runner_game_ui_state.dart';

class StartPauseButtonOverlay extends StatelessWidget {
  const StartPauseButtonOverlay({
    super.key,
    required this.uiState,
    required this.onStart,
    required this.onTogglePause,
  });

  final RunnerGameUiState uiState;
  final VoidCallback onStart;
  final VoidCallback onTogglePause;

  @override
  Widget build(BuildContext context) {
    return IconButton(
      onPressed: uiState.gameOver
          ? null
          : () {
              if (!uiState.started) {
                onStart();
                return;
              }
              onTogglePause();
            },
      icon: Icon(uiState.paused ? Icons.play_arrow : Icons.pause),
      color: Colors.white,
      tooltip: uiState.paused ? 'Play' : 'Pause',
    );
  }
}


===== FILE: lib/ui/hud/game/survival_timer_overlay.dart =====
import 'package:flutter/widgets.dart';

import '../../../game/game_controller.dart';

class SurvivalTimerOverlay extends StatelessWidget {
  const SurvivalTimerOverlay({
    super.key,
    required this.controller,
    this.padding = const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
  });

  final GameController controller;
  final EdgeInsets padding;

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: controller,
      builder: (context, _) {
        final ticks = controller.snapshot.tick;
        final hz = controller.tickHz;

        final totalSeconds = ticks ~/ hz;
        final minutes = totalSeconds ~/ 60;
        final seconds = totalSeconds % 60;

        final text =
            '${minutes.toString().padLeft(2, '0')}:${seconds.toString().padLeft(2, '0')}';

        return IgnorePointer(
          child: RepaintBoundary(
            child: Container(
              padding: padding,
              decoration: BoxDecoration(
                color: const Color(0x66000000),
                borderRadius: BorderRadius.circular(10),
              ),
              child: Text(
                text,
                textAlign: TextAlign.center,
                style: const TextStyle(
                  fontSize: 18,
                  color: Color(0xFFFFFFFF),
                  fontFeatures: [FontFeature.tabularFigures()],
                ),
              ),
            ),
          ),
        );
      },
    );
  }
}


===== FILE: lib/ui/hud/game/top_center_hud_overlay.dart =====
import 'package:flutter/material.dart';

import '../../../game/game_controller.dart';
import 'survival_timer_overlay.dart';
import '../../runner_game_ui_state.dart';
import 'start_pause_button_overlay.dart';

class TopCenterHudOverlay extends StatelessWidget {
  const TopCenterHudOverlay({
    super.key,
    required this.controller,
    required this.uiState,
    required this.onStart,
    required this.onTogglePause,
  });

  final GameController controller;
  final RunnerGameUiState uiState;
  final VoidCallback onStart;
  final VoidCallback onTogglePause;

  @override
  Widget build(BuildContext context) {
    return Align(
      alignment: Alignment.topCenter,
      child: Padding(
        padding: const EdgeInsets.only(top: 8),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            SurvivalTimerOverlay(controller: controller),
            const SizedBox(width: 8),
            StartPauseButtonOverlay(
              uiState: uiState,
              onStart: onStart,
              onTogglePause: onTogglePause,
            ),
          ],
        ),
      ),
    );
  }
}


===== FILE: lib/ui/hud/game/top_left_hud_overlay.dart =====
import 'package:flutter/widgets.dart';

import '../../../game/game_controller.dart';

class TopLeftHudOverlay extends StatelessWidget {
  const TopLeftHudOverlay({required this.controller, super.key});

  final GameController controller;

  static const double _barWidth = 140;
  static const double _barHeight = 6;
  static const double _barGap = 4;

  @override
  Widget build(BuildContext context) {
    final totalHeight = _barHeight * 3 + _barGap * 2;

    return AnimatedBuilder(
      animation: controller,
      builder: (context, _) {
        final hud = controller.snapshot.hud;
        return IgnorePointer(
          child: RepaintBoundary(
            child: SizedBox(
              width: _barWidth,
              height: totalHeight,

              child: CustomPaint(
                painter: _HudBarsPainter(
                  hp: hud.hp,
                  hpMax: hud.hpMax,
                  mana: hud.mana,
                  manaMax: hud.manaMax,
                  stamina: hud.stamina,
                  staminaMax: hud.staminaMax,
                  barWidth: _barWidth,
                  barHeight: _barHeight,
                  barGap: _barGap,
                ),
              ),
            ),
          ),
        );
      },
    );
  }
}

class _HudBarsPainter extends CustomPainter {
  _HudBarsPainter({
    required this.hp,
    required this.hpMax,
    required this.mana,
    required this.manaMax,
    required this.stamina,
    required this.staminaMax,
    required this.barWidth,
    required this.barHeight,
    required this.barGap,
  });

  final double hp;
  final double hpMax;
  final double mana;
  final double manaMax;
  final double stamina;
  final double staminaMax;
  final double barWidth;
  final double barHeight;
  final double barGap;

  static final Paint _back = Paint()..color = const Color(0xAA000000);
  static final Paint _outline = Paint()
    ..color = const Color(0xFFFFFFFF)
    ..style = PaintingStyle.stroke
    ..strokeWidth = 1;
  static final Paint _hp = Paint()..color = const Color(0xFFDC4440);
  static final Paint _mana = Paint()..color = const Color(0xFF2D98DA);
  static final Paint _stamina = Paint()..color = const Color(0xFF4CD137);

  @override
  void paint(Canvas canvas, Size size) {
    _drawBar(
      canvas,
      y: 0,
      value: hp,
      max: hpMax,
      fill: _hp,
    );
    _drawBar(
      canvas,
      y: barHeight + barGap,
      value: mana,
      max: manaMax,
      fill: _mana,
    );
    _drawBar(
      canvas,
      y: (barHeight + barGap) * 2,
      value: stamina,
      max: staminaMax,
      fill: _stamina,
    );
  }

  void _drawBar(
    Canvas canvas, {
    required double y,
    required double value,
    required double max,
    required Paint fill,
  }) {
    final backRect = Rect.fromLTWH(0, y, barWidth, barHeight);
    canvas.drawRect(backRect, _back);
    canvas.drawRect(backRect, _outline);

    if (max <= 0) return;
    final t = (value / max).clamp(0.0, 1.0);
    if (t <= 0) return;
    canvas.drawRect(Rect.fromLTWH(0, y, barWidth * t, barHeight), fill);
  }

  @override
  bool shouldRepaint(covariant _HudBarsPainter oldDelegate) {
    return hp != oldDelegate.hp ||
        hpMax != oldDelegate.hpMax ||
        mana != oldDelegate.mana ||
        manaMax != oldDelegate.manaMax ||
        stamina != oldDelegate.stamina ||
        staminaMax != oldDelegate.staminaMax ||
        barWidth != oldDelegate.barWidth ||
        barHeight != oldDelegate.barHeight ||
        barGap != oldDelegate.barGap;
  }
}


===== FILE: lib/ui/hud/game/top_right_hud_overlay.dart =====
import 'package:flutter/material.dart';

import '../../../game/game_controller.dart';
import 'score_overlay.dart';

class TopRightHudOverlay extends StatelessWidget {
  const TopRightHudOverlay({
    super.key,
    required this.controller,
    required this.showExitButton,
    required this.onExit,
  });

  final GameController controller;
  final bool showExitButton;
  final VoidCallback? onExit;

  @override
  Widget build(BuildContext context) {
    return Align(
      alignment: Alignment.topRight,
      child: Padding(
        padding: const EdgeInsets.all(8),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            ScoreOverlay(controller: controller),
            if (showExitButton) ...[
              const SizedBox(width: 8),
              IconButton(
                onPressed: onExit,
                icon: const Icon(Icons.close),
                color: Colors.white,
                disabledColor: Colors.white,
              ),
            ],
          ],
        ),
      ),
    );
  }
}


===== FILE: lib/ui/hud/gameover/game_over_header.dart =====
import 'package:flutter/material.dart';

class GameOverHeader extends StatelessWidget {
  const GameOverHeader({
    super.key,
    required this.subtitleDeathReason,
    required this.displayScore,
  });

  final String? subtitleDeathReason;
  final int? displayScore;

  @override
  Widget build(BuildContext context) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        const Text(
          'Game Over',
          style: TextStyle(
            color: Color(0xFFFFFFFF),
            fontSize: 28,
            fontWeight: FontWeight.w600,
          ),
        ),
        if (subtitleDeathReason != null) ...[
          const SizedBox(height: 8),
          Text(
            subtitleDeathReason!,
            style: const TextStyle(
              color: Color(0xFFFFFFFF),
              fontSize: 14,
              fontWeight: FontWeight.w500,
            ),
            textAlign: TextAlign.center,
          ),
        ],
        if (displayScore != null) ...[
          const SizedBox(height: 14),
          Text(
            'Score: $displayScore',
            style: const TextStyle(
              color: Color(0xFFFFFFFF),
              fontSize: 16,
              fontWeight: FontWeight.w600,
            ),
            textAlign: TextAlign.center,
          ),
        ],
      ],
    );
  }
}


===== FILE: lib/ui/hud/gameover/game_over_overlay.dart =====
import 'package:flutter/material.dart';
import 'package:flutter/scheduler.dart';

import '../../../core/enemies/enemy_id.dart';
import '../../../core/events/game_event.dart';
import '../../../core/levels/level_id.dart';
import '../../../core/projectiles/projectile_id.dart';
import '../../../core/scoring/run_score_breakdown.dart';
import '../../../core/tuning/score_tuning.dart';
import '../../leaderboard/leaderboard_store.dart';
import 'game_over_header.dart';
import 'leaderboard_panel.dart';
import 'restart_exit_buttons.dart';
import 'score_breakdown_formatter.dart';
import 'score_distribution.dart';
import 'score_feed_controller.dart';
import '../../components/overlay_button.dart';
// import '../../../core/spells/spell_id.dart';

class GameOverOverlay extends StatefulWidget {
  const GameOverOverlay({
    super.key,
    required this.visible,
    required this.onRestart,
    required this.onExit,
    required this.showExitButton,
    required this.levelId,
    required this.runEndedEvent,
    required this.scoreTuning,
    required this.tickHz,
    this.goldEarned,
    this.totalGold,
    this.leaderboardStore,
  });

  final bool visible;
  final VoidCallback onRestart;
  final VoidCallback? onExit;
  final bool showExitButton;
  final LevelId levelId;
  final RunEndedEvent? runEndedEvent;
  final ScoreTuning scoreTuning;
  final int tickHz;
  final int? goldEarned;
  final int? totalGold;
  final LeaderboardStore? leaderboardStore;

  @override
  State<GameOverOverlay> createState() => _GameOverOverlayState();
}

class _GameOverOverlayState extends State<GameOverOverlay>
    with SingleTickerProviderStateMixin {
  late final RunScoreBreakdown _breakdown;
  late final ScoreFeedController _feedController;

  Ticker? _ticker;
  Duration _lastElapsed = Duration.zero;

  @override
  void initState() {
    super.initState();
    _breakdown = _buildBreakdown();
    _feedController = ScoreFeedController(
      rows: _breakdown.rows,
      totalPoints: _breakdown.totalPoints,
    );
  }

  RunScoreBreakdown _buildBreakdown() {
    final event = widget.runEndedEvent;
    if (event == null) {
      return const RunScoreBreakdown(rows: <RunScoreRow>[], totalPoints: 0);
    }

    return buildRunScoreBreakdown(
      tick: event.tick,
      distanceUnits: event.distance,
      collectibles: event.stats.collectibles,
      collectibleScore: event.stats.collectibleScore,
      enemyKillCounts: event.stats.enemyKillCounts,
      tuning: widget.scoreTuning,
      tickHz: widget.tickHz,
    );
  }

  Widget? _buildGoldPanel() {
    final goldEarned = widget.goldEarned;
    if (goldEarned == null) return null;
    final totalGold = widget.totalGold;

    const labelStyle = TextStyle(
      color: Color(0xFFFFFFFF),
      fontSize: 14,
      fontWeight: FontWeight.w600,
    );
    const valueStyle = TextStyle(
      color: Color(0xFFFFD54F),
      fontSize: 14,
      fontWeight: FontWeight.w700,
    );

    Widget buildRow(String label, String value) {
      return Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Text('$label: ', style: labelStyle),
          Text(value, style: valueStyle),
        ],
      );
    }

    return DecoratedBox(
      decoration: BoxDecoration(
        color: const Color(0x33000000),
        borderRadius: BorderRadius.circular(8),
      ),
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            buildRow('Gold earned', '+$goldEarned'),
            if (totalGold != null) ...[
              const SizedBox(height: 4),
              buildRow('Total gold', '$totalGold'),
            ],
          ],
        ),
      ),
    );
  }

  void _startFeed() {
    if (_feedController.startFeed()) {
      _startTicker();
      setState(() {});
    }
  }

  void _startTicker() {
    _ticker?.dispose();
    _lastElapsed = Duration.zero;
    _ticker = createTicker(_onTick)..start();
  }

  void _stopTicker() {
    final ticker = _ticker;
    if (ticker == null) return;
    ticker.stop();
    ticker.dispose();
    _ticker = null;
  }

  void _onTick(Duration elapsed) {
    if (_feedController.feedState != ScoreFeedState.feeding) return;

    final dt = (elapsed - _lastElapsed).inMicroseconds.toDouble() / 1000000.0;
    _lastElapsed = elapsed;
    if (dt <= 0) return;

    final changed = _feedController.tick(dt);
    if (_feedController.feedState == ScoreFeedState.complete) {
      _stopTicker();
    }
    if (changed && mounted) setState(() {});
  }

  void _completeFeed() {
    _feedController.completeFeed();
    _stopTicker();
  }

  void _onCollectPressed() {
    if (_feedController.feedState == ScoreFeedState.idle) {
      _startFeed();
      return;
    }
    if (_feedController.feedState == ScoreFeedState.feeding) {
      _completeFeed();
      setState(() {});
    }
  }

  void _completeThen(VoidCallback? action) {
    if (_feedController.feedState != ScoreFeedState.complete) {
      _completeFeed();
      setState(() {});
    }
    if (action == null) return;
    WidgetsBinding.instance.addPostFrameCallback((_) => action());
  }

  @override
  void dispose() {
    _stopTicker();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    if (!widget.visible) return const SizedBox.shrink();

    final subtitleDeathReason = _buildSubtitleDeathReason(widget.runEndedEvent);
    final showCollectButton =
        _feedController.totalPoints > 0 &&
        _feedController.feedState != ScoreFeedState.complete;
    final showScoreInHeader =
        _feedController.feedState == ScoreFeedState.complete;
    final collectLabel = _feedController.feedState == ScoreFeedState.idle
        ? 'Collect score'
        : 'Skip';
    final goldPanel = _buildGoldPanel();
    final rowLabels = [
      for (var i = 0; i < _feedController.rows.length; i += 1)
        formatScoreRow(
          _feedController.rows[i].row,
          _feedController.rows[i].remainingPoints,
          enemyName: _enemyName,
        ),
    ];

    return SizedBox.expand(
      child: ColoredBox(
        color: const Color(0x88000000),
        child: SafeArea(
          minimum: const EdgeInsets.all(18),
          child: Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Expanded(
                flex: 2,
                child: Align(
                  alignment: Alignment.topCenter,
                  child: Column(
                    mainAxisSize: MainAxisSize.max,
                    children: [
                      GameOverHeader(
                        subtitleDeathReason: subtitleDeathReason,
                        displayScore: showScoreInHeader
                            ? _feedController.displayScore
                            : null,
                      ),
                      if (goldPanel != null) ...[
                        const SizedBox(height: 10),
                        goldPanel,
                      ],
                      const SizedBox(height: 14),
                      if (showCollectButton)
                        OverlayButton(
                          label: collectLabel,
                          onPressed: _onCollectPressed,
                        )
                      else
                        RestartExitButtons(
                          restartButton: OverlayButton(
                            label: 'Restart',
                            onPressed: () => _completeThen(widget.onRestart),
                          ),
                          exitButton: widget.showExitButton
                              ? OverlayButton(
                                  label: 'Exit',
                                  onPressed: () => _completeThen(widget.onExit),
                                )
                              : null,
                        ),
                      const SizedBox(height: 16),
                      Flexible(child: ScoreDistribution(rowLabels: rowLabels)),
                    ],
                  ),
                ),
              ),
              Expanded(
                flex: 1,
                child: Align(
                  alignment: Alignment.topCenter,
                  child: LeaderboardPanel(
                    levelId: widget.levelId,
                    runEndedEvent: widget.runEndedEvent,
                    scoreTuning: widget.scoreTuning,
                    tickHz: widget.tickHz,
                    revealCurrentRunScore:
                        _feedController.feedState == ScoreFeedState.complete,
                    leaderboardStore: widget.leaderboardStore,
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

String? _buildSubtitleDeathReason(RunEndedEvent? event) {
  if (event == null) return null;
  switch (event.reason) {
    case RunEndReason.gaveUp:
      return 'You gave up the run.';
    case RunEndReason.fellBehindCamera:
      return 'You fell behind.';
    case RunEndReason.fellIntoGap:
      return 'You fell into a gap.';
    case RunEndReason.playerDied:
      return _buildDeathSubtitle(event.deathInfo);
  }
}

String _buildDeathSubtitle(DeathInfo? info) {
  if (info == null) return 'You died.';
  switch (info.kind) {
    case DeathSourceKind.projectile:
      return _buildProjectileDeath(info);
    case DeathSourceKind.meleeHitbox:
      return _buildMeleeDeath(info);
    case DeathSourceKind.statusEffect:
      return 'You succumbed to a status effect.';
    case DeathSourceKind.unknown:
      return 'You died.';
  }
}

String _buildProjectileDeath(DeathInfo info) {
  final projectileId = info.projectileId;
  if (projectileId == null) return 'You died.';
  final projectileName = _projectileName(projectileId);
  /* final spellName =
      info.spellId == null ? null : _spellName(info.spellId!); */
  final enemyName = info.enemyId == null ? null : _enemyName(info.enemyId!);

  final buffer = StringBuffer('Killed by $projectileName');
  /*   if (spellName != null) {
    buffer.write(' ($spellName)');
  } */
  if (enemyName != null) {
    buffer.write(' from $enemyName.');
  } else {
    buffer.write('.');
  }
  return buffer.toString();
}

String _buildMeleeDeath(DeathInfo info) {
  if (info.enemyId == null) return 'You died.';
  return 'Killed by a melee strike from a ${_enemyName(info.enemyId!)}.';
}

String _enemyName(EnemyId id) {
  switch (id) {
    case EnemyId.unocoDemon:
      return 'Unoco Demon';
    case EnemyId.grojib:
      return 'Ground enemy';
  }
}

String _projectileName(ProjectileId id) {
  switch (id) {
    case ProjectileId.iceBolt:
      return 'Ice Bolt';
    case ProjectileId.thunderBolt:
      return 'thunder Bolt';
    case ProjectileId.fireBolt:
      return 'Fire Bolt';
    case ProjectileId.throwingAxe:
      return 'Throwing Axe';
    case ProjectileId.throwingKnife:
      return 'Throwing Knife';
  }
}

/* String _spellName(SpellId id) {
  switch (id) {
    case SpellId.iceBolt:
      return 'Ice Bolt';
    case SpellId.thunderBolt:
      return 'thunder';
  }
} */


===== FILE: lib/ui/hud/gameover/leaderboard_panel.dart =====
import 'package:flutter/material.dart';

import '../../../core/events/game_event.dart';
import '../../../core/levels/level_id.dart';
import '../../../core/tuning/score_tuning.dart';
import '../../leaderboard/leaderboard_store.dart';
import '../../leaderboard/run_result.dart';
import '../../leaderboard/shared_prefs_leaderboard_store.dart';
import '../../levels/level_id_ui.dart';

class LeaderboardPanel extends StatefulWidget {
  const LeaderboardPanel({
    super.key,
    required this.levelId,
    required this.runEndedEvent,
    required this.scoreTuning,
    required this.tickHz,
    this.revealCurrentRunScore = true,
    this.leaderboardStore,
  });

  final LevelId levelId;
  final RunEndedEvent? runEndedEvent;
  final ScoreTuning scoreTuning;
  final int tickHz;
  final bool revealCurrentRunScore;
  final LeaderboardStore? leaderboardStore;

  @override
  State<LeaderboardPanel> createState() => _LeaderboardPanelState();
}

class _LeaderboardPanelState extends State<LeaderboardPanel> {
  late final LeaderboardStore _store;
  List<RunResult> _entries = const <RunResult>[];
  int? _currentRunId;
  bool _loaded = false;

  static const double _rankColWidth = 28;
  static const double _scoreColWidth = 64;
  static const double _distanceColWidth = 56;
  static const double _timeColWidth = 54;

  @override
  void initState() {
    super.initState();
    _store = widget.leaderboardStore ?? SharedPrefsLeaderboardStore();
    _loadLeaderboard();
  }

  Future<void> _loadLeaderboard() async {
    final event = widget.runEndedEvent;
    if (event == null) {
      final entries = await _store.loadTop10(levelId: widget.levelId);
      if (!mounted) return;
      setState(() {
        _entries = entries;
        _loaded = true;
      });
      return;
    }

    final draft = buildRunResult(
      event: event,
      scoreTuning: widget.scoreTuning,
      tickHz: widget.tickHz,
      endedAtMs: DateTime.now().millisecondsSinceEpoch,
    );
    final snapshot = await _store.addResult(
      levelId: widget.levelId,
      result: draft,
    );
    if (!mounted) return;
    setState(() {
      _entries = snapshot.entries;
      _currentRunId = snapshot.current.runId;
      _loaded = true;
    });
  }

  Widget _buildRow(int rank, RunResult entry) {
    final isCurrent = _currentRunId != null && entry.runId == _currentRunId;
    final color = isCurrent ? const Color(0xFFFFF59D) : const Color(0xFFFFFFFF);
    final scoreText =
        isCurrent && !widget.revealCurrentRunScore ? '—' : entry.score.toString();

    return DecoratedBox(
      decoration: isCurrent
          ? BoxDecoration(
              color: const Color(0x33FFFFFF),
              borderRadius: BorderRadius.circular(6),
            )
          : const BoxDecoration(),
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 3),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            SizedBox(
              width: _rankColWidth,
              child: Text(
                '#$rank',
                style: TextStyle(color: color),
              ),
            ),
            SizedBox(
              width: _scoreColWidth,
              child: Text(
                scoreText,
                textAlign: TextAlign.right,
                style: TextStyle(color: color),
              ),
            ),
            SizedBox(
              width: _distanceColWidth,
              child: Text(
                '${entry.distanceMeters}m',
                textAlign: TextAlign.right,
                style: TextStyle(color: color),
              ),
            ),
            SizedBox(
              width: _timeColWidth,
              child: Text(
                _formatTime(entry.durationSeconds),
                textAlign: TextAlign.right,
                style: TextStyle(color: color),
              ),
            ),
          ],
        ),
      ),
    );
  }

  String _formatTime(int totalSeconds) {
    final minutes = totalSeconds ~/ 60;
    final seconds = totalSeconds % 60;
    return '${minutes.toString().padLeft(2, '0')}:${seconds.toString().padLeft(2, '0')}';
  }

  @override
  Widget build(BuildContext context) {
    final titleStyle = const TextStyle(
      color: Color(0xFFFFFFFF),
      fontSize: 14,
      fontWeight: FontWeight.w600,
    );
    final textStyle = const TextStyle(
      color: Color(0xFFFFFFFF),
      fontSize: 12,
      fontWeight: FontWeight.w500,
    );

    Widget content;
    if (!_loaded) {
      content = Text('Loading leaderboard...', style: textStyle);
    } else if (_entries.isEmpty) {
      content = Text('No runs yet.', style: textStyle);
    } else {
      content = Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          for (var i = 0; i < _entries.length; i += 1) ...[
            _buildRow(i + 1, _entries[i]),
            if (i < _entries.length - 1) const SizedBox(height: 4),
          ],
        ],
      );
    }

    return ConstrainedBox(
      constraints: const BoxConstraints(maxWidth: 240),
      child: DecoratedBox(
        decoration: BoxDecoration(
          color: const Color(0x66000000),
          borderRadius: BorderRadius.circular(10),
        ),
        child: Padding(
          padding: const EdgeInsets.all(12),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text('${widget.levelId.displayName} Scoreboard', style: titleStyle),
              const SizedBox(height: 8),
              DefaultTextStyle(style: textStyle, child: content),
            ],
          ),
        ),
      ),
    );
  }
}


===== FILE: lib/ui/hud/gameover/restart_exit_buttons.dart =====
import 'package:flutter/material.dart';

class RestartExitButtons extends StatelessWidget {
  const RestartExitButtons({
    super.key,
    required this.restartButton,
    this.exitButton,
    this.trailingButton,
  });

  final Widget restartButton;
  final Widget? exitButton;
  final Widget? trailingButton;

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      width: double.infinity,
      child: Stack(
        alignment: Alignment.center,
        children: [
          Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              restartButton,
              if (exitButton != null) ...[
                const SizedBox(width: 12),
                exitButton!,
              ],
            ],
          ),
          if (trailingButton != null)
            Align(alignment: Alignment.centerRight, child: trailingButton),
        ],
      ),
    );
  }
}


===== FILE: lib/ui/hud/gameover/score_breakdown_formatter.dart =====
import '../../../core/enemies/enemy_id.dart';
import '../../../core/scoring/run_score_breakdown.dart';

String formatScoreRow(
  RunScoreRow row,
  int remainingPoints, {
  required String Function(EnemyId id) enemyName,
}) {
  switch (row.kind) {
    case RunScoreRowKind.distance:
      return 'Distance: ${row.count}m -> $remainingPoints';
    case RunScoreRowKind.time:
      return 'Time: ${_formatTime(row.count)} -> $remainingPoints';
    case RunScoreRowKind.collectibles:
      return 'Collectibles: ${row.count} -> $remainingPoints';
    case RunScoreRowKind.enemyKill:
      final name = row.enemyId == null ? 'Enemy' : enemyName(row.enemyId!);
      return '$name x${row.count} -> $remainingPoints';
  }
}

String _formatTime(int totalSeconds) {
  final minutes = totalSeconds ~/ 60;
  final seconds = totalSeconds % 60;
  return '${minutes.toString().padLeft(2, '0')}:${seconds.toString().padLeft(2, '0')}';
}


===== FILE: lib/ui/hud/gameover/score_distribution.dart =====
import 'package:flutter/material.dart';

class ScoreDistribution extends StatelessWidget {
  const ScoreDistribution({
    super.key,
    required this.rowLabels,
  });

  final List<String> rowLabels;

  @override
  Widget build(BuildContext context) {
    return Scrollbar(
      child: SingleChildScrollView(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            for (var i = 0; i < rowLabels.length; i += 1) ...[
              Text(
                rowLabels[i],
                style: const TextStyle(
                  color: Color(0xFFFFFFFF),
                  fontSize: 14,
                  fontWeight: FontWeight.w500,
                ),
                textAlign: TextAlign.center,
              ),
              if (i < rowLabels.length - 1) const SizedBox(height: 4),
            ],
          ],
        ),
      ),
    );
  }
}


===== FILE: lib/ui/hud/gameover/score_feed_controller.dart =====
import '../../../core/scoring/run_score_breakdown.dart';

enum ScoreFeedState { idle, feeding, complete }

class ScoreFeedRowState {
  ScoreFeedRowState({
    required this.row,
    required this.pointsPerSecond,
  }) : remainingPoints = row.points;

  final RunScoreRow row;
  final double pointsPerSecond;
  int remainingPoints;
  double carry = 0.0;
}

class ScoreFeedController {
  ScoreFeedController({
    required List<RunScoreRow> rows,
    required this.totalPoints,
    double feedDurationSeconds = 0.8,
  }) : _rows = [
          for (final row in rows)
            ScoreFeedRowState(
              row: row,
              pointsPerSecond:
                  row.points <= 0 ? 0.0 : row.points / feedDurationSeconds,
            ),
        ],
        displayScore = 0,
        feedState =
            totalPoints > 0 ? ScoreFeedState.idle : ScoreFeedState.complete;

  final int totalPoints;
  final List<ScoreFeedRowState> _rows;

  int displayScore;
  ScoreFeedState feedState;

  List<ScoreFeedRowState> get rows => _rows;

  bool startFeed() {
    if (feedState != ScoreFeedState.idle || totalPoints <= 0) return false;
    feedState = ScoreFeedState.feeding;
    return true;
  }

  bool tick(double dtSeconds) {
    if (feedState != ScoreFeedState.feeding || dtSeconds <= 0) {
      return false;
    }

    var gained = 0;
    var anyRemaining = false;

    for (final row in _rows) {
      if (row.remainingPoints <= 0 || row.pointsPerSecond <= 0) continue;
      row.carry += dtSeconds * row.pointsPerSecond;
      final raw = row.carry.floor();
      if (raw <= 0) {
        anyRemaining = true;
        continue;
      }
      row.carry -= raw;
      final consume =
          raw > row.remainingPoints ? row.remainingPoints : raw;
      row.remainingPoints -= consume;
      gained += consume;
      if (row.remainingPoints > 0) anyRemaining = true;
    }

    if (gained > 0) {
      displayScore += gained;
      if (displayScore > totalPoints) displayScore = totalPoints;
    }

    if (!anyRemaining) {
      completeFeed();
      return true;
    }

    return gained > 0;
  }

  void completeFeed() {
    displayScore = totalPoints;
    for (final row in _rows) {
      row.remainingPoints = 0;
      row.carry = 0.0;
    }
    feedState = ScoreFeedState.complete;
  }
}


===== FILE: lib/ui/leaderboard/leaderboard_store.dart =====
import '../../core/levels/level_id.dart';

import 'run_result.dart';

class LeaderboardSnapshot {
  const LeaderboardSnapshot({
    required this.entries,
    required this.current,
  });

  final List<RunResult> entries;
  final RunResult current;
}

abstract class LeaderboardStore {
  Future<LeaderboardSnapshot> addResult({
    required LevelId levelId,
    required RunResult result,
  });

  Future<List<RunResult>> loadTop10({required LevelId levelId});
}


===== FILE: lib/ui/leaderboard/run_result.dart =====
import '../../core/events/game_event.dart';
import '../../core/scoring/run_score_breakdown.dart';
import '../../core/tuning/score_tuning.dart';

class RunResult {
  const RunResult({
    required this.runId,
    required this.endedAtMs,
    required this.endedReason,
    required this.score,
    required this.distanceMeters,
    required this.durationSeconds,
    required this.tick,
  });

  final int runId;
  final int endedAtMs;
  final RunEndReason endedReason;
  final int score;
  final int distanceMeters;
  final int durationSeconds;
  final int tick;

  RunResult copyWith({
    int? runId,
    int? endedAtMs,
  }) {
    return RunResult(
      runId: runId ?? this.runId,
      endedAtMs: endedAtMs ?? this.endedAtMs,
      endedReason: endedReason,
      score: score,
      distanceMeters: distanceMeters,
      durationSeconds: durationSeconds,
      tick: tick,
    );
  }

  Map<String, dynamic> toJson() => <String, dynamic>{
        'runId': runId,
        'endedAtMs': endedAtMs,
        'endedReason': endedReason.name,
        'score': score,
        'distanceMeters': distanceMeters,
        'durationSeconds': durationSeconds,
        'tick': tick,
      };

  static RunResult fromJson(Map<String, dynamic> json) {
    final reasonName = json['endedReason'] as String?;
    final reason = _reasonFromName(reasonName);
    return RunResult(
      runId: json['runId'] as int? ?? 0,
      endedAtMs: json['endedAtMs'] as int? ?? 0,
      endedReason: reason,
      score: json['score'] as int? ?? 0,
      distanceMeters: json['distanceMeters'] as int? ?? 0,
      durationSeconds: json['durationSeconds'] as int? ?? 0,
      tick: json['tick'] as int? ?? 0,
    );
  }

  static RunEndReason _reasonFromName(String? name) {
    if (name == null) return RunEndReason.playerDied;
    for (final value in RunEndReason.values) {
      if (value.name == name) return value;
    }
    return RunEndReason.playerDied;
  }
}

RunResult buildRunResult({
  required RunEndedEvent event,
  required ScoreTuning scoreTuning,
  required int tickHz,
  required int endedAtMs,
}) {
  final breakdown = buildRunScoreBreakdown(
    tick: event.tick,
    distanceUnits: event.distance,
    collectibles: event.stats.collectibles,
    collectibleScore: event.stats.collectibleScore,
    enemyKillCounts: event.stats.enemyKillCounts,
    tuning: scoreTuning,
    tickHz: tickHz,
  );

  final distanceMeters = (event.distance / kWorldUnitsPerMeter).floor();
  final durationSeconds = tickHz <= 0 ? 0 : event.tick ~/ tickHz;

  return RunResult(
    runId: 0,
    endedAtMs: endedAtMs,
    endedReason: event.reason,
    score: breakdown.totalPoints,
    distanceMeters: distanceMeters,
    durationSeconds: durationSeconds,
    tick: event.tick,
  );
}


===== FILE: lib/ui/leaderboard/shared_prefs_leaderboard_store.dart =====
import 'dart:convert';

import 'package:shared_preferences/shared_preferences.dart';

import '../../core/levels/level_id.dart';
import 'leaderboard_store.dart';
import 'run_result.dart';

class SharedPrefsLeaderboardStore implements LeaderboardStore {
  static const String _entriesKeyPrefix = 'leaderboard_v2_entries_';
  static const String _nextIdKeyPrefix = 'leaderboard_v2_next_id_';

  String _entriesKey(LevelId levelId) => '$_entriesKeyPrefix${levelId.name}';
  String _nextIdKey(LevelId levelId) => '$_nextIdKeyPrefix${levelId.name}';

  @override
  Future<LeaderboardSnapshot> addResult({
    required LevelId levelId,
    required RunResult result,
  }) async {
    final prefs = await SharedPreferences.getInstance();

    final nextId = (prefs.getInt(_nextIdKey(levelId)) ?? 1);
    final stored = result.copyWith(runId: nextId);
    final entries = _loadEntries(prefs, levelId);
    entries.add(stored);
    entries.sort(_compare);

    final top = entries.length > 10 ? entries.sublist(0, 10) : entries;
    await prefs.setString(_entriesKey(levelId), _encode(top));
    await prefs.setInt(_nextIdKey(levelId), nextId + 1);

    return LeaderboardSnapshot(
      entries: List<RunResult>.unmodifiable(top),
      current: stored,
    );
  }

  @override
  Future<List<RunResult>> loadTop10({required LevelId levelId}) async {
    final prefs = await SharedPreferences.getInstance();
    final entries = _loadEntries(prefs, levelId);
    entries.sort(_compare);
    if (entries.length > 10) return entries.sublist(0, 10);
    return List<RunResult>.unmodifiable(entries);
  }

  List<RunResult> _loadEntries(SharedPreferences prefs, LevelId levelId) {
    final raw = prefs.getString(_entriesKey(levelId));
    if (raw == null || raw.isEmpty) return <RunResult>[];

    final decoded = jsonDecode(raw);
    if (decoded is! List) return <RunResult>[];

    final entries = <RunResult>[];
    for (final entry in decoded) {
      if (entry is Map<String, dynamic>) {
        entries.add(RunResult.fromJson(entry));
      } else if (entry is Map) {
        entries.add(RunResult.fromJson(Map<String, dynamic>.from(entry)));
      }
    }
    return entries;
  }

  String _encode(List<RunResult> entries) {
    return jsonEncode(entries.map((entry) => entry.toJson()).toList());
  }

  int _compare(RunResult a, RunResult b) {
    if (a.score != b.score) return b.score.compareTo(a.score);
    if (a.endedAtMs != b.endedAtMs) {
      return b.endedAtMs.compareTo(a.endedAtMs);
    }
    return b.runId.compareTo(a.runId);
  }
}


===== FILE: lib/ui/levels/level_id_ui.dart =====
import '../../core/levels/level_id.dart';
import '../../core/levels/level_registry.dart';

/// UI-layer extensions for [LevelId].
extension LevelIdUi on LevelId {
  /// Human-readable display name for the level.
  String get displayName {
    switch (this) {
      case LevelId.defaultLevel:
        return 'Default';
      case LevelId.forest:
        return 'Forest';
      case LevelId.field:
        return 'Field';
    }
  }

  /// Theme identifier used for asset lookup.
  ///
  /// Resolves through [LevelRegistry] to get the authoritative themeId.
  /// Returns 'field' as fallback if the level has no theme set.
  String get themeId => LevelRegistry.byId(this).themeId ?? 'field';
}


===== FILE: lib/ui/pages/hub/components/hub_selection_card_body.dart =====
import 'package:flutter/material.dart';

/// Shared inner content for hub selection cards (level/character/etc.).
///
/// Owns typography + spacing contract so individual cards only provide data
/// (header/title/subtitle) and optional visuals (e.g. character preview).
class HubSelectionCardBody extends StatelessWidget {
  const HubSelectionCardBody({
    super.key,
    required this.headerText,
    required this.title,
    required this.subtitle,
    this.trailing,
    this.titleMaxLines = 1,
    this.subtitleMaxLines = 1,
  });

  final String headerText;
  final String title;
  final String subtitle;
  final Widget? trailing;
  final int titleMaxLines;
  final int subtitleMaxLines;

  static const TextStyle _headerStyle = TextStyle(
    color: Colors.white,
    fontSize: 14,
    letterSpacing: 1.5,
    fontWeight: FontWeight.bold,
    shadows: [
      Shadow(
        color: Colors.black,
        blurRadius: 2,
        offset: Offset(0, 2),
      ),
    ],
  );

  static const TextStyle _titleStyle = TextStyle(
    color: Colors.white,
    fontSize: 18,
    fontWeight: FontWeight.bold,
    shadows: [
      Shadow(
        color: Colors.black,
        blurRadius: 2,
        offset: Offset(0, 2),
      ),
    ],
  );

  static const TextStyle _subtitleStyle = TextStyle(
    color: Colors.white,
    fontSize: 13,
    fontWeight: FontWeight.bold,
    shadows: [
      Shadow(
        color: Colors.black,
        blurRadius: 2,
        offset: Offset(0, 2),
      ),
    ],
  );

  @override
  Widget build(BuildContext context) {
    final base = Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(headerText, style: _headerStyle),
        const SizedBox(height: 8),
        Text(
          title,
          style: _titleStyle,
          maxLines: titleMaxLines,
          overflow: TextOverflow.ellipsis,
        ),
        const SizedBox(height: 4),
        Text(
          subtitle,
          style: _subtitleStyle,
          maxLines: subtitleMaxLines,
          overflow: TextOverflow.ellipsis,
        ),
      ],
    );

    final t = trailing;
    if (t == null) return base;

    return Stack(
      children: [
        base,
        Positioned(
          right: 0,
          bottom: 0,
          child: t,
        ),
      ],
    );
  }
}


===== FILE: lib/ui/pages/hub/components/hub_selection_card_frame.dart =====
import 'dart:math' as math;

import 'package:flutter/material.dart';

/// Shared frame for hub selection cards (level/character).
///
/// Owns layout contract: size, border, shadow, padding, clipping, and overlay.
class HubSelectionCardFrame extends StatelessWidget {
  const HubSelectionCardFrame({
    super.key,
    required this.width,
    required this.height,
    required this.background,
    required this.child,
    this.onTap,
    this.padding = defaultPadding,
    this.borderRadius = 12,
    this.borderColor = Colors.white54,
    this.borderWidth = 2,
    this.boxShadow = const [
      BoxShadow(
        color: Colors.black54,
        blurRadius: 8,
        offset: Offset(0, 4),
      ),
    ],
    this.overlayGradient = const LinearGradient(
      begin: Alignment.topCenter,
      end: Alignment.bottomCenter,
      colors: [
        Color(0x00000000),
        Color(0xAA000000),
      ],
    ),
    this.backgroundColor = Colors.black,
  });

  static const double defaultWidth = 240;
  static const double defaultHeight = 128;
  static const EdgeInsets defaultPadding = EdgeInsets.all(16);

  final double width;
  final double height;
  final Widget background;
  final Widget child;
  final VoidCallback? onTap;
  final EdgeInsets padding;
  final double borderRadius;
  final Color borderColor;
  final double borderWidth;
  final List<BoxShadow> boxShadow;
  final Gradient? overlayGradient;
  final Color backgroundColor;

  @override
  Widget build(BuildContext context) {
    final innerRadius = math.max(0.0, borderRadius - borderWidth);

    final content = Container(
      width: width,
      height: height,
      decoration: BoxDecoration(
        color: backgroundColor,
        borderRadius: BorderRadius.circular(borderRadius),
        border: Border.all(color: borderColor, width: borderWidth),
        boxShadow: boxShadow,
      ),
      child: ClipRRect(
        borderRadius: BorderRadius.circular(innerRadius),
        child: Stack(
          fit: StackFit.expand,
          children: [
            background,
            if (overlayGradient != null)
              DecoratedBox(
                decoration: BoxDecoration(gradient: overlayGradient),
              ),
            Padding(padding: padding, child: child),
          ],
        ),
      ),
    );

    if (onTap == null) return content;

    return GestureDetector(
      onTap: onTap,
      child: content,
    );
  }
}


===== FILE: lib/ui/pages/hub/components/selected_character_card.dart =====
import 'package:flutter/material.dart';

import '../../../../core/players/player_character_definition.dart';
import '../../../../core/players/player_character_registry.dart';
import 'hub_selection_card_body.dart';
import 'hub_selection_card_frame.dart';
import '../../../components/player_idle_preview.dart';

/// Hub card showing the currently selected character and build name.
class SelectedCharacterCard extends StatelessWidget {
  const SelectedCharacterCard({
    super.key,
    required this.characterId,
    required this.buildName,
    required this.onChange,
    this.width = HubSelectionCardFrame.defaultWidth,
    this.height = HubSelectionCardFrame.defaultHeight,
  });

  final PlayerCharacterId characterId;
  final String buildName;
  final VoidCallback onChange;
  final double width;
  final double height;

  @override
  Widget build(BuildContext context) {
    final def =
        PlayerCharacterRegistry.byId[characterId] ??
        PlayerCharacterRegistry.defaultCharacter;

    return HubSelectionCardFrame(
      width: width,
      height: height,
      padding: const EdgeInsets.fromLTRB(16, 8, 16, 16),
      onTap: onChange,
      background: const DecoratedBox(
        decoration: BoxDecoration(
          gradient: LinearGradient(
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
            colors: [Color(0xFF0C111B), Color(0xFF1A2333)],
          ),
        ),
      ),
      child: HubSelectionCardBody(
        headerText: 'CHARACTER SELECTION',
        title: def.displayName,
        subtitle: buildName,
        trailing: PlayerIdlePreview(characterId: characterId, size: 88),
      ),
    );
  }
}


===== FILE: lib/ui/pages/hub/components/selected_level_card.dart =====
import 'package:flutter/material.dart';

import '../../../../core/levels/level_id.dart';
import '../../../levels/level_id_ui.dart';
import 'hub_selection_card_body.dart';
import 'hub_selection_card_frame.dart';
import '../../../components/level_parallax_preview.dart';

/// Hub card showing the currently selected level.
class SelectedLevelCard extends StatelessWidget {
  const SelectedLevelCard({
    super.key,
    required this.levelId,
    required this.runTypeLabel,
    required this.onChange,
    this.width = HubSelectionCardFrame.defaultWidth,
    this.height = HubSelectionCardFrame.defaultHeight,
  });

  final LevelId levelId;
  final String runTypeLabel;
  final VoidCallback onChange;
  final double width;
  final double height;

  @override
  Widget build(BuildContext context) {
    return HubSelectionCardFrame(
      width: width,
      height: height,
      padding: const EdgeInsets.fromLTRB(16, 8, 16, 16),
      onTap: onChange,
      background: LevelParallaxPreview(
        themeId: levelId.themeId,
        alignment: Alignment.center,
      ),
      child: HubSelectionCardBody(
        headerText: 'LEVEL SELECTION',
        title: levelId.displayName.toUpperCase(),
        subtitle: runTypeLabel,
      ),
    );
  }
}


===== FILE: lib/ui/pages/hub/play_hub_page.dart =====
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

import '../../app/ui_routes.dart';
import '../../components/menu_button.dart';
import '../../components/menu_layout.dart';
import '../../components/menu_scaffold.dart';
import 'components/selected_character_card.dart';
import 'components/selected_level_card.dart';
import '../../state/app_state.dart';
import '../../state/profile_counter_keys.dart';
import '../../state/selection_state.dart';

class PlayHubPage extends StatefulWidget {
  const PlayHubPage({super.key});

  @override
  State<PlayHubPage> createState() => _PlayHubPageState();
}

class _PlayHubPageState extends State<PlayHubPage> {
  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (!mounted) return;
      context.read<AppState>().startWarmup();
    });
  }

  @override
  Widget build(BuildContext context) {
    final appState = context.watch<AppState>();
    final selection = appState.selection;
    final profile = appState.profile;
    final gold = profile.counters[ProfileCounterKeys.gold] ?? 0;

    return MenuScaffold(
      showAppBar: false,
      child: MenuLayout(
        child: Row(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                _HubIconButton(
                  icon: Icons.person,
                  label: 'Profile',
                  onPressed: () =>
                      Navigator.of(context).pushNamed(UiRoutes.profile),
                ),
                _HubIconButton(
                  icon: Icons.leaderboard,
                  label: 'Leaderboards',
                  onPressed: () =>
                      Navigator.of(context).pushNamed(UiRoutes.leaderboards),
                ),
                _HubIconButton(
                  icon: Icons.library_books,
                  label: 'Codex',
                  onPressed: () =>
                      Navigator.of(context).pushNamed(UiRoutes.library),
                ),
                _HubIconButton(
                  icon: Icons.storefront,
                  label: 'Town',
                  onPressed: () =>
                      Navigator.of(context).pushNamed(UiRoutes.town),
                ),
                _HubIconButton(
                  icon: Icons.monetization_on,
                  label: 'Support',
                  onPressed: () =>
                      Navigator.of(context).pushNamed(UiRoutes.support),
                ),
                _HubIconButton(
                  icon: Icons.settings,
                  label: 'Options',
                  onPressed: () =>
                      Navigator.of(context).pushNamed(UiRoutes.options),
                ),
              ],
            ),
            const SizedBox(width: 48),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  _ProfileGoldRow(
                    displayName:
                        profile.displayName.isEmpty ? 'Guest' : profile.displayName,
                    profileId: profile.profileId,
                    gold: gold,
                  ),
                  const SizedBox(height: 12),
                  _WeeklyBadgeRow(
                    onWeeklyPressed: null,
                    onWeeklyLeaderboardPressed: () =>
                        Navigator.of(context).pushNamed(UiRoutes.leaderboards),
                  ),
                  const SizedBox(height: 20),
                  Center(
                    child: Wrap(
                      alignment: WrapAlignment.center,
                      spacing: 16,
                      runSpacing: 16,
                      children: [
                        SelectedLevelCard(
                          levelId: selection.selectedLevelId,
                          runTypeLabel: _runTypeLabel(
                            selection.selectedRunType,
                          ),
                          onChange: () => Navigator.of(
                            context,
                          ).pushNamed(UiRoutes.setupLevel),
                        ),
                        SelectedCharacterCard(
                          characterId: selection.selectedCharacterId,
                          buildName: selection.buildName,
                          onChange: () => Navigator.of(
                            context,
                          ).pushNamed(UiRoutes.setupLoadout),
                        ),
                      ],
                    ),
                  ),
                  const SizedBox(height: 24),
                  Center(
                    child: MenuButton(
                      label: 'PLAY',
                      width: 220,
                      height: 56,
                      fontSize: 18,
                      onPressed: () {
                        final args = appState.buildRunStartArgs();
                        Navigator.of(
                          context,
                        ).pushNamed(UiRoutes.run, arguments: args);
                      },
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}

String _runTypeLabel(RunType runType) {
  switch (runType) {
    case RunType.practice:
      return 'Practice (Random)';
    case RunType.competitive:
      return 'Competitive (Season)';
  }
}

class _WeeklyBadgeRow extends StatelessWidget {
  const _WeeklyBadgeRow({
    required this.onWeeklyPressed,
    required this.onWeeklyLeaderboardPressed,
  });

  final VoidCallback? onWeeklyPressed;
  final VoidCallback onWeeklyLeaderboardPressed;

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
      decoration: BoxDecoration(
        border: Border.all(color: Colors.white24),
        borderRadius: BorderRadius.circular(10),
      ),
      child: Row(
        children: [
          const Expanded(
            child: Text(
              'Weekly Challenge · Coming Soon',
              style: TextStyle(color: Colors.white70),
            ),
          ),
          MenuButton(
            label: 'Weekly',
            width: 100,
            height: 36,
            fontSize: 12,
            onPressed: onWeeklyPressed,
          ),
          const SizedBox(width: 8),
          MenuButton(
            label: 'Weekly LB',
            width: 120,
            height: 36,
            fontSize: 12,
            onPressed: onWeeklyLeaderboardPressed,
          ),
        ],
      ),
    );
  }
}

class _ProfileGoldRow extends StatelessWidget {
  const _ProfileGoldRow({
    required this.displayName,
    required this.profileId,
    required this.gold,
  });

  final String displayName;
  final String profileId;
  final int gold;

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
      decoration: BoxDecoration(
        border: Border.all(color: Colors.white24),
        borderRadius: BorderRadius.circular(10),
      ),
      child: Row(
        children: [
          Expanded(
            child: Text(
              displayName,
              style: const TextStyle(color: Colors.white70),
              overflow: TextOverflow.ellipsis,
            ),
          ),
          const Icon(Icons.monetization_on, color: Color(0xFFFFD54F), size: 18),
          const SizedBox(width: 6),
          Text(
            gold.toString(),
            style: const TextStyle(
              color: Color(0xFFFFF59D),
              fontWeight: FontWeight.w600,
            ),
          ),
        ],
      ),
    );
  }
}

class _HubIconButton extends StatelessWidget {
  const _HubIconButton({
    required this.icon,
    required this.label,
    required this.onPressed,
  });

  final IconData icon;
  final String label;
  final VoidCallback onPressed;

  @override
  Widget build(BuildContext context) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        IconButton(
          onPressed: onPressed,
          icon: Icon(icon, color: Colors.white),
          iconSize: 32,
          padding: EdgeInsets.zero,
          constraints: const BoxConstraints(),
        ),
        Text(
          label,
          style: const TextStyle(color: Colors.white70, fontSize: 10),
          textAlign: TextAlign.center,
        ),
      ],
    );
  }
}


===== FILE: lib/ui/pages/lab/loadout_lab_page.dart =====
import 'package:flutter/material.dart';

import '../../components/placeholder_page.dart';

class LoadoutLabPage extends StatelessWidget {
  const LoadoutLabPage({super.key});

  @override
  Widget build(BuildContext context) {
    return const PlaceholderPage(title: 'Loadout Lab');
  }
}


===== FILE: lib/ui/pages/leaderboards/leaderboards_page.dart =====
import 'package:flutter/material.dart';

import '../../components/placeholder_page.dart';

class LeaderboardsPage extends StatelessWidget {
  const LeaderboardsPage({super.key});

  @override
  Widget build(BuildContext context) {
    return const PlaceholderPage(title: 'Leaderboards');
  }
}


===== FILE: lib/ui/pages/meta/credits_page.dart =====
import 'package:flutter/material.dart';

import '../../components/placeholder_page.dart';

class CreditsPage extends StatelessWidget {
  const CreditsPage({super.key});

  @override
  Widget build(BuildContext context) {
    return const PlaceholderPage(title: 'Credits');
  }
}


===== FILE: lib/ui/pages/meta/library_page.dart =====
import 'package:flutter/material.dart';

import '../../components/placeholder_page.dart';

class LibraryPage extends StatelessWidget {
  const LibraryPage({super.key});

  @override
  Widget build(BuildContext context) {
    return const PlaceholderPage(title: 'Library');
  }
}


===== FILE: lib/ui/pages/meta/options_page.dart =====
import 'package:flutter/material.dart';

import '../../components/placeholder_page.dart';

class OptionsPage extends StatelessWidget {
  const OptionsPage({super.key});

  @override
  Widget build(BuildContext context) {
    return const PlaceholderPage(title: 'Options');
  }
}


===== FILE: lib/ui/pages/meta/support_page.dart =====
import 'package:flutter/material.dart';

import '../../components/placeholder_page.dart';

class SupportPage extends StatelessWidget {
  const SupportPage({super.key});

  @override
  Widget build(BuildContext context) {
    return const PlaceholderPage(title: 'Support');
  }
}


===== FILE: lib/ui/pages/meta/town_page.dart =====
import 'package:flutter/material.dart';

import '../../components/placeholder_page.dart';

class TownPage extends StatelessWidget {
  const TownPage({super.key});

  @override
  Widget build(BuildContext context) {
    return const PlaceholderPage(title: 'Town');
  }
}


===== FILE: lib/ui/pages/profile/profile_page.dart =====
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

import '../../components/menu_button.dart';
import '../../components/menu_layout.dart';
import '../../components/menu_scaffold.dart';
import '../../profile/display_name_policy.dart';
import '../../state/app_state.dart';
import '../../state/profile_counter_keys.dart';

class ProfilePage extends StatefulWidget {
  const ProfilePage({super.key});

  @override
  State<ProfilePage> createState() => _ProfilePageState();
}

class _ProfilePageState extends State<ProfilePage> {
  final _controller = TextEditingController();
  final _policy = const DisplayNamePolicy();
  String? _error;
  bool _saving = false;

  static const Duration _cooldown = Duration(hours: 24);

  @override
  void initState() {
    super.initState();
    final profile = context.read<AppState>().profile;
    _controller.text = profile.displayName;
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  String _fallbackName(String displayName) =>
      displayName.isEmpty ? 'Guest' : displayName;

  bool _cooldownActive(int lastChangedAtMs, int nowMs) {
    if (lastChangedAtMs <= 0) return false;
    return nowMs - lastChangedAtMs < _cooldown.inMilliseconds;
  }

  Duration _cooldownRemaining(int lastChangedAtMs, int nowMs) {
    final elapsed = nowMs - lastChangedAtMs;
    final remainingMs = _cooldown.inMilliseconds - elapsed;
    final clampedMs = remainingMs.clamp(0, _cooldown.inMilliseconds).toInt();
    return Duration(milliseconds: clampedMs);
  }

  Future<void> _save() async {
    if (_saving) return;
    final appState = context.read<AppState>();
    final profile = appState.profile;

    final raw = _controller.text.trim();
    if (raw == profile.displayName) {
      setState(() => _error = 'Name is unchanged.');
      return;
    }

    final nowMs = DateTime.now().millisecondsSinceEpoch;
    final active = _cooldownActive(profile.displayNameLastChangedAtMs, nowMs);
    if (active) {
      final rem = _cooldownRemaining(profile.displayNameLastChangedAtMs, nowMs);
      setState(() {
        _error =
            'You can change your name again in ${rem.inHours}h ${rem.inMinutes.remainder(60)}m.';
      });
      return;
    }

    final err = _policy.validate(raw);
    if (err != null) {
      setState(() => _error = err);
      return;
    }

    setState(() {
      _saving = true;
      _error = null;
    });

    final shouldSetCooldown = profile.displayName.isNotEmpty;

    await appState.updateProfile((p) {
      return p.copyWith(
        displayName: raw,
        displayNameLastChangedAtMs: shouldSetCooldown
            ? nowMs
            : p.displayNameLastChangedAtMs,
      );
    });

    if (!mounted) return;
    setState(() => _saving = false);
    ScaffoldMessenger.of(
      context,
    ).showSnackBar(const SnackBar(content: Text('Name updated')));
  }

  @override
  Widget build(BuildContext context) {
    final appState = context.watch<AppState>();
    final profile = appState.profile;
    final gold = profile.counters[ProfileCounterKeys.gold] ?? 0;
    final nowMs = DateTime.now().millisecondsSinceEpoch;

    final cdActive = _cooldownActive(profile.displayNameLastChangedAtMs, nowMs);
    final cdText = cdActive
        ? _cooldownRemaining(profile.displayNameLastChangedAtMs, nowMs)
        : null;

    return MenuScaffold(
      showAppBar: false,
      child: MenuLayout(
        child: Center(
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 560),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                const Text(
                  'Profile',
                  style: TextStyle(
                    fontSize: 28,
                    fontWeight: FontWeight.w700,
                    color: Colors.white,
                  ),
                ),
                const SizedBox(height: 16),
                Container(
                  padding: const EdgeInsets.all(16),
                  decoration: BoxDecoration(
                    border: Border.all(color: Colors.white24),
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: Column(
                    children: [
                      _row('Display name', _fallbackName(profile.displayName)),
                      _row('Profile id', profile.profileId),
                      _row('Gold', gold.toString()),
                      if (cdText != null)
                        Padding(
                          padding: const EdgeInsets.only(top: 8),
                          child: Text(
                            'Name change cooldown: ${cdText.inHours}h ${cdText.inMinutes.remainder(60)}m remaining',
                            style: const TextStyle(color: Colors.white70),
                          ),
                        ),
                    ],
                  ),
                ),
                const SizedBox(height: 20),
                TextField(
                  controller: _controller,
                  style: const TextStyle(color: Colors.white),
                  decoration: InputDecoration(
                    labelText: 'Change display name',
                    labelStyle: const TextStyle(color: Colors.white70),
                    errorText: _error,
                    filled: true,
                    fillColor: Colors.white10,
                    border: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(12),
                    ),
                  ),
                  onChanged: (_) => setState(() => _error = null),
                ),
                const SizedBox(height: 12),
                MenuButton(
                  label: 'Save',
                  width: 160,
                  height: 44,
                  fontSize: 14,
                  onPressed: _saving ? null : _save,
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _row(String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 6),
      child: Row(
        children: [
          Expanded(
            flex: 2,
            child: Text(label, style: const TextStyle(color: Colors.white70)),
          ),
          Expanded(
            flex: 3,
            child: Text(
              value,
              style: const TextStyle(color: Colors.white),
              overflow: TextOverflow.ellipsis,
            ),
          ),
        ],
      ),
    );
  }
}


===== FILE: lib/ui/pages/setup/level_select_section.dart =====
import 'package:flutter/material.dart';

import '../../../core/levels/level_id.dart';
import '../../components/level_card.dart';

class LevelSelectSection extends StatelessWidget {
  const LevelSelectSection({
    super.key,
    required this.selectedLevelId,
    required this.onSelectLevel,
  });

  final LevelId selectedLevelId;
  final ValueChanged<LevelId> onSelectLevel;

  @override
  Widget build(BuildContext context) {
    return Wrap(
      spacing: 16,
      runSpacing: 16,
      alignment: WrapAlignment.center,
      children: [
        for (final levelId in LevelId.values)
          LevelCard(
            levelId: levelId,
            selected: levelId == selectedLevelId,
            width: 200,
            onTap: () => onSelectLevel(levelId),
          ),
      ],
    );
  }
}


===== FILE: lib/ui/pages/setup/level_setup_page.dart =====
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

import '../../app/ui_routes.dart';
import '../../components/menu_button.dart';
import '../../components/menu_layout.dart';
import '../../components/menu_scaffold.dart';
import '../../state/app_state.dart';
import '../../state/selection_state.dart';
import 'level_select_section.dart';

class LevelSetupPage extends StatelessWidget {
  const LevelSetupPage({super.key});

  @override
  Widget build(BuildContext context) {
    final appState = context.watch<AppState>();
    final selection = appState.selection;

    return MenuScaffold(
      title: 'Select Level',
      child: MenuLayout(
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Run Type',
              style: TextStyle(color: Colors.white70, letterSpacing: 1.2),
            ),
            const SizedBox(height: 8),
            SegmentedButton<RunType>(
              segments: const [
                ButtonSegment<RunType>(
                  value: RunType.practice,
                  label: Text('Practice (Random)'),
                ),
                ButtonSegment<RunType>(
                  value: RunType.competitive,
                  label: Text('Competitive (Season)'),
                ),
              ],
              selected: {selection.selectedRunType},
              onSelectionChanged: (value) {
                if (value.isEmpty) return;
                appState.setRunType(value.first);
              },
            ),
            const SizedBox(height: 24),
            _WeeklyChallengeCard(
              onPlayWeekly: null,
              onLeaderboard: () =>
                  Navigator.of(context).pushNamed(UiRoutes.leaderboards),
            ),
            const SizedBox(height: 24),
            Center(
              child: LevelSelectSection(
                selectedLevelId: selection.selectedLevelId,
                onSelectLevel: appState.setLevel,
              ),
            ),
            const SizedBox(height: 16),
            Row(
              children: [
                MenuButton(
                  label: 'Back',
                  onPressed: () => Navigator.of(context).maybePop(),
                ),
                const SizedBox(width: 12),
                MenuButton(
                  label: 'Loadout',
                  onPressed: () =>
                      Navigator.of(context).pushNamed(UiRoutes.setupLoadout),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}

class _WeeklyChallengeCard extends StatelessWidget {
  const _WeeklyChallengeCard({
    required this.onPlayWeekly,
    required this.onLeaderboard,
  });

  final VoidCallback? onPlayWeekly;
  final VoidCallback onLeaderboard;

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: Colors.white30),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            'Weekly Challenge',
            style: TextStyle(
              color: Colors.white,
              fontSize: 16,
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 6),
          const Text(
            'Week 01 · ends in 2d 14h',
            style: TextStyle(color: Colors.white70),
          ),
          const SizedBox(height: 12),
          Row(
            children: [
              MenuButton(
                label: 'Play Weekly',
                width: 140,
                height: 40,
                fontSize: 12,
                onPressed: onPlayWeekly,
              ),
              const SizedBox(width: 8),
              MenuButton(
                label: 'Leaderboard',
                width: 140,
                height: 40,
                fontSize: 12,
                onPressed: onLeaderboard,
              ),
            ],
          ),
        ],
      ),
    );
  }
}


===== FILE: lib/ui/pages/setup/loadout_setup_page.dart =====
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:provider/provider.dart';

import '../../../core/ecs/stores/combat/equipped_loadout_store.dart';
import '../../../core/projectiles/projectile_item_id.dart';
import '../../app/ui_routes.dart';
import '../../components/menu_button.dart';
import '../../components/menu_layout.dart';
import '../../components/menu_scaffold.dart';
import '../../state/app_state.dart';
import '../../state/selection_state.dart';

class LoadoutSetupPage extends StatelessWidget {
  const LoadoutSetupPage({super.key});

  @override
  Widget build(BuildContext context) {
    final appState = context.watch<AppState>();
    final selection = appState.selection;
    final loadout = selection.equippedLoadout;

    return MenuScaffold(
      title: 'Setup Loadout',
      child: MenuLayout(
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Build Name',
              style: TextStyle(color: Colors.white70, letterSpacing: 1.2),
            ),
            const SizedBox(height: 8),
            _BuildNameField(
              buildName: selection.buildName,
              onCommit: appState.setBuildName,
            ),
            const SizedBox(height: 20),
            Text(
              'Current Loadout',
              style: Theme.of(context)
                  .textTheme
                  .titleMedium
                  ?.copyWith(color: Colors.white),
            ),
            const SizedBox(height: 12),
            _LoadoutSummary(loadout: loadout),
            const SizedBox(height: 24),
            const Text(
              'Quick Presets',
              style: TextStyle(color: Colors.white70, letterSpacing: 1.2),
            ),
            const SizedBox(height: 8),
            Wrap(
              spacing: 12,
              children: [
                MenuButton(
                  label: 'Default',
                  onPressed: () => appState.setLoadout(const EquippedLoadoutDef()),
                ),
                MenuButton(
                  label: 'Fire Bolt',
                  onPressed: () => appState.setLoadout(
                    _withProjectile(loadout, ProjectileItemId.fireBolt, 'eloise.fire_bolt'),
                  ),
                ),
                MenuButton(
                  label: 'Thunder Bolt',
                  onPressed: () => appState.setLoadout(
                    _withProjectile(
                      loadout,
                      ProjectileItemId.thunderBolt,
                      'eloise.thunder_bolt',
                    ),
                  ),
                ),
              ],
            ),
            const SizedBox(height: 24),
            Row(
              children: [
                MenuButton(
                  label: 'Back',
                  onPressed: () => Navigator.of(context).maybePop(),
                ),
                const SizedBox(width: 12),
                MenuButton(
                  label: 'Level',
                  onPressed: () =>
                      Navigator.of(context).pushNamed(UiRoutes.setupLevel),
                ),
                const SizedBox(width: 12),
                MenuButton(
                  label: 'Try Lab',
                  onPressed: () =>
                      Navigator.of(context).pushNamed(UiRoutes.loadoutLab),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}

EquippedLoadoutDef _withProjectile(
  EquippedLoadoutDef base,
  ProjectileItemId projectileItemId,
  String abilityProjectileId,
) {
  return EquippedLoadoutDef(
    mask: base.mask,
    mainWeaponId: base.mainWeaponId,
    offhandWeaponId: base.offhandWeaponId,
    projectileItemId: projectileItemId,
    abilityPrimaryId: base.abilityPrimaryId,
    abilitySecondaryId: base.abilitySecondaryId,
    abilityProjectileId: abilityProjectileId,
    abilityBonusId: base.abilityBonusId,
    abilityMobilityId: base.abilityMobilityId,
    abilityJumpId: base.abilityJumpId,
  );
}

class _BuildNameField extends StatefulWidget {
  const _BuildNameField({
    required this.buildName,
    required this.onCommit,
  });

  final String buildName;
  final ValueChanged<String> onCommit;

  @override
  State<_BuildNameField> createState() => _BuildNameFieldState();
}

class _BuildNameFieldState extends State<_BuildNameField> {
  late final TextEditingController _controller;
  late final FocusNode _focusNode;

  @override
  void initState() {
    super.initState();
    _controller = TextEditingController(text: widget.buildName);
    _focusNode = FocusNode()..addListener(_handleFocusChange);
  }

  @override
  void didUpdateWidget(covariant _BuildNameField oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (!_focusNode.hasFocus &&
        oldWidget.buildName != widget.buildName &&
        _controller.text != widget.buildName) {
      _controller.text = widget.buildName;
    }
  }

  void _handleFocusChange() {
    if (!_focusNode.hasFocus) {
      _commit();
    }
  }

  void _commit() {
    widget.onCommit(_controller.text);
    FocusScope.of(context).unfocus();
  }

  @override
  void dispose() {
    _focusNode
      ..removeListener(_handleFocusChange)
      ..dispose();
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final borderRadius = BorderRadius.circular(8);
    return TextField(
      controller: _controller,
      focusNode: _focusNode,
      maxLength: SelectionState.buildNameMaxLength,
      maxLengthEnforcement: MaxLengthEnforcement.enforced,
      textInputAction: TextInputAction.done,
      onSubmitted: (_) => _commit(),
      style: const TextStyle(color: Colors.white),
      cursorColor: Colors.white,
      decoration: InputDecoration(
        hintText: SelectionState.defaultBuildName,
        hintStyle: const TextStyle(color: Colors.white38),
        filled: true,
        fillColor: const Color(0xFF0E131D),
        border: OutlineInputBorder(
          borderRadius: borderRadius,
          borderSide: const BorderSide(color: Colors.white24),
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: borderRadius,
          borderSide: const BorderSide(color: Colors.white24),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: borderRadius,
          borderSide: const BorderSide(color: Colors.white70),
        ),
        counterStyle: const TextStyle(color: Colors.white38, fontSize: 11),
        contentPadding: const EdgeInsets.symmetric(
          horizontal: 12,
          vertical: 10,
        ),
      ),
    );
  }
}

class _LoadoutSummary extends StatelessWidget {
  const _LoadoutSummary({required this.loadout});

  final EquippedLoadoutDef loadout;

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: Colors.white24),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text('Primary: ${loadout.abilityPrimaryId}',
              style: const TextStyle(color: Colors.white70)),
          Text('Secondary: ${loadout.abilitySecondaryId}',
              style: const TextStyle(color: Colors.white70)),
          Text('Projectile: ${loadout.abilityProjectileId}',
              style: const TextStyle(color: Colors.white70)),
          Text('Mobility: ${loadout.abilityMobilityId}',
              style: const TextStyle(color: Colors.white70)),
          Text('Bonus: ${loadout.abilityBonusId}',
              style: const TextStyle(color: Colors.white70)),
        ],
      ),
    );
  }
}


===== FILE: lib/ui/pages/setup/profile_name_setup_page.dart =====
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

import '../../app/ui_routes.dart';
import '../../components/menu_button.dart';
import '../../components/menu_layout.dart';
import '../../components/menu_scaffold.dart';
import '../../profile/display_name_policy.dart';
import '../../state/app_state.dart';
import '../../state/profile_flag_keys.dart';

class ProfileNameSetupPage extends StatefulWidget {
  const ProfileNameSetupPage({super.key});

  @override
  State<ProfileNameSetupPage> createState() => _ProfileNameSetupPageState();
}

class _ProfileNameSetupPageState extends State<ProfileNameSetupPage> {
  final _controller = TextEditingController();
  final _policy = const DisplayNamePolicy();

  String? _error;
  bool _saving = false;

  @override
  void initState() {
    super.initState();
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  Future<void> _complete({required bool skipped}) async {
    if (_saving) return;
    setState(() => _saving = true);

    final appState = context.read<AppState>();
    final nowMs = DateTime.now().millisecondsSinceEpoch;

    await appState.updateProfile((p) {
      final flags = Map<String, bool>.from(p.flags);
      flags[ProfileFlagKeys.namePromptCompleted] = true;

      if (skipped) {
        return p.copyWith(flags: flags);
      }

      final raw = _controller.text;
      final shouldSetCooldown = p.displayName.isNotEmpty;
      return p.copyWith(
        displayName: raw.trim(),
        displayNameLastChangedAtMs: shouldSetCooldown
            ? nowMs
            : p.displayNameLastChangedAtMs,
        flags: flags,
      );
    });

    if (!mounted) return;
    Navigator.of(context).pushReplacementNamed(UiRoutes.hub);
  }

  Future<void> _confirm() async {
    final err = _policy.validate(_controller.text);
    if (err != null) {
      setState(() => _error = err);
      return;
    }
    await _complete(skipped: false);
  }

  @override
  Widget build(BuildContext context) {
    return MenuScaffold(
      showAppBar: false,
      child: MenuLayout(
        child: Center(
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 520),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                const Text(
                  'Choose your name',
                  style: TextStyle(
                    fontSize: 28,
                    fontWeight: FontWeight.w700,
                    color: Colors.white,
                  ),
                ),
                const SizedBox(height: 8),
                const Text(
                  'This is optional. You can change it later in Profile.',
                  style: TextStyle(color: Colors.white70),
                  textAlign: TextAlign.center,
                ),
                const SizedBox(height: 24),
                TextField(
                  controller: _controller,
                  style: const TextStyle(color: Colors.white),
                  decoration: InputDecoration(
                    labelText: 'Display name',
                    labelStyle: const TextStyle(color: Colors.white70),
                    errorText: _error,
                    filled: true,
                    fillColor: Colors.white10,
                    border: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(12),
                    ),
                  ),
                  onChanged: (_) => setState(() => _error = null),
                ),
                const SizedBox(height: 20),
                Row(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    MenuButton(
                      label: 'Skip',
                      width: 120,
                      height: 44,
                      fontSize: 14,
                      onPressed: _saving
                          ? null
                          : () => _complete(skipped: true),
                    ),
                    const SizedBox(width: 12),
                    MenuButton(
                      label: 'Continue',
                      width: 160,
                      height: 44,
                      fontSize: 14,
                      onPressed: _saving ? null : _confirm,
                    ),
                  ],
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}


===== FILE: lib/ui/profile/display_name_policy.dart =====
class DisplayNamePolicy {
  const DisplayNamePolicy();

  static const int minLen = 3;
  static const int maxLen = 16;

  static final RegExp allowed = RegExp(r'^[a-zA-Z0-9 _-]+$');

  static const Set<String> reservedNormalized = <String>{
    'admin',
    'moderator',
    'mod',
    'support',
    'staff',
    'developer',
    'dev',
    'system',
  };

  static const List<String> bannedSubstringsNormalized = <String>[
    'fuck',
    'shit',
    'bitch',
    'asshole',
    'cunt',
    'nazi',
  ];

  String normalize(String input) {
    final trimmed = input.trim();
    final collapsed = trimmed.replaceAll(RegExp(r'\s+'), ' ');
    return collapsed.toLowerCase();
  }

  String? validate(String raw) {
    final name = raw.trim();
    if (name.isEmpty) return 'Name is required.';
    if (name.length < minLen) return 'Name must be at least $minLen characters.';
    if (name.length > maxLen) return 'Name must be at most $maxLen characters.';
    if (!allowed.hasMatch(name)) {
      return 'Only letters, numbers, spaces, "_" and "-" are allowed.';
    }

    final n = normalize(name);
    if (reservedNormalized.contains(n)) {
      return 'That name is reserved.';
    }
    for (final bad in bannedSubstringsNormalized) {
      if (n.contains(bad)) return 'That name is not allowed.';
    }
    return null;
  }
}


===== FILE: lib/ui/runner_game_route.dart =====
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import '../core/levels/level_id.dart';
import '../core/players/player_character_definition.dart';
import 'runner_game_widget.dart';
import 'scoped/scoped_preferred_orientations.dart';
import 'scoped/scoped_system_ui_mode.dart';

/// Embed-friendly route factory for hosting the mini-game in any Flutter app.
///
/// Host apps can `Navigator.push(createRunnerGameRoute(...))` without depending
/// on this package's development host app (`lib/main.dart`).
///
/// Use [runId] to tag the run for replay/ghost metadata.
Route<void> createRunnerGameRoute({
  int runId = 0,
  int seed = 1,
  LevelId levelId = LevelId.defaultLevel,
  PlayerCharacterId playerCharacterId = PlayerCharacterId.eloise,
  bool lockLandscape = true,
  List<DeviceOrientation>? restoreOrientations,
  RouteSettings? settings,
}) {
  return MaterialPageRoute<void>(
    settings: settings,
    builder: (context) {
      Widget child = RunnerGameWidget(
        runId: runId,
        seed: seed,
        levelId: levelId,
        playerCharacterId: playerCharacterId,
        onExit: () => Navigator.of(context).maybePop(),
      );

      if (lockLandscape) {
        child = ScopedPreferredOrientations(
          preferredOrientations: const [
            DeviceOrientation.landscapeLeft,
            DeviceOrientation.landscapeRight,
          ],
          restoreOrientations: restoreOrientations,
          child: child,
        );
      }

      // Hide status + nav bars only for this route.
      child = ScopedSystemUiMode(
        mode: SystemUiMode.immersiveSticky,
        restoreMode: SystemUiMode.edgeToEdge,
        child: child,
      );

      return Scaffold(body: child);
    },
  );
}


===== FILE: lib/ui/runner_game_ui_state.dart =====
class RunnerGameUiState {
  const RunnerGameUiState({
    required this.started,
    required this.paused,
    required this.gameOver,
  });

  final bool started;
  final bool paused;
  final bool gameOver;

  bool get canRun => started && !gameOver;

  bool get isRunning => canRun && !paused;

  bool get showReadyOverlay => !started;

  bool get showPauseOverlay => started && paused && !gameOver;
}


===== FILE: lib/ui/runner_game_widget.dart =====
import 'dart:math';

import 'package:flame/game.dart';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

import '../core/contracts/render_contract.dart';
import '../core/events/game_event.dart';
import '../core/game_core.dart';
import '../core/levels/level_id.dart';
import '../core/levels/level_registry.dart';
import '../core/players/player_character_definition.dart';
import '../core/players/player_character_registry.dart';
import '../game/game_controller.dart';
import '../game/input/aim_preview.dart';
import '../game/input/runner_input_router.dart';
import '../game/runner_flame_game.dart';
import 'hud/game/game_overlay.dart';
import 'hud/gameover/game_over_overlay.dart';
import 'bootstrap/loader_content.dart';
import 'components/menu_layout.dart';
import 'runner_game_ui_state.dart';
import 'state/app_state.dart';
import 'state/profile_counter_keys.dart';
import 'viewport/game_viewport.dart';
import 'viewport/viewport_metrics.dart';

/// Embed-friendly widget that hosts the mini-game.
///
/// Intended to be mounted by a host app. It owns its [GameController] and
/// cleans it up on dispose.
///
/// Viewport scaling is applied by [GameViewport] to keep the fixed virtual
/// resolution fitted to the available screen.
class RunnerGameWidget extends StatefulWidget {
  const RunnerGameWidget({
    super.key,
    this.runId = 0,
    this.seed = 1,
    this.levelId = LevelId.defaultLevel,
    this.playerCharacterId = PlayerCharacterId.eloise,
    this.onExit,
    this.showExitButton = true,
    this.viewportMode = ViewportScaleMode.pixelPerfectContain,
    this.viewportAlignment = Alignment.center,
  });

  /// Master RNG seed for deterministic generation.
  final int seed;

  /// Unique identifier for this run session (replay/ghost).
  final int runId;

  /// Which core level definition to run.
  final LevelId levelId;

  /// Which player character to use for this run.
  final PlayerCharacterId playerCharacterId;

  final VoidCallback? onExit;
  final bool showExitButton;

  /// How the game view is scaled to the available screen.
  final ViewportScaleMode viewportMode;

  /// Where the scaled view is placed within the available screen.
  final Alignment viewportAlignment;

  @override
  State<RunnerGameWidget> createState() => _RunnerGameWidgetState();
}

class _RunnerGameWidgetState extends State<RunnerGameWidget>
    with WidgetsBindingObserver {
  final Random _runIdRandom = Random();

  bool _pausedByLifecycle = false;
  bool _started = false;
  bool _exitConfirmOpen = false;
  bool _pausedBeforeExitConfirm = false;

  late int _runId;
  int? _lastRewardedRunId;
  int? _lastGoldEarned;
  int? _lastGoldTotal;

  late GameController _controller;
  late RunnerInputRouter _input;
  late AimPreviewModel _projectileAimPreview;
  late AimPreviewModel _meleeAimPreview;
  late ValueNotifier<Rect?> _aimCancelHitboxRect;
  late RunnerFlameGame _game;

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);

    _runId = widget.runId != 0 ? widget.runId : _createFallbackRunId();
    _initGame();

    // Start in "ready" (paused) until the user taps to begin.
    _controller.setPaused(true);
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) =>
      _onLifecycle(state);

  void _onLifecycle(AppLifecycleState state) {
    final uiState = _buildUiState();
    if (state == AppLifecycleState.resumed) {
      if (_pausedByLifecycle && uiState.started && !uiState.gameOver) {
        _pausedByLifecycle = false;
        _controller.setPaused(false);
      }
      return;
    }

    // Only mark lifecycle-paused if we were actually running.
    _pausedByLifecycle = uiState.isRunning;
    _controller.setPaused(true);
    _clearInputs();
  }

  void _clearInputs() {
    _input.setMoveAxis(0);
    _input.clearProjectileAimDir();
    _input.clearMeleeAimDir();
    _projectileAimPreview.end();
    _meleeAimPreview.end();
    _input.pumpHeldInputs();
  }

  AppState? _maybeAppState() {
    try {
      return Provider.of<AppState>(context, listen: false);
    } on ProviderNotFoundException {
      return null;
    }
  }

  int _createFallbackRunId() {
    final nowMs = DateTime.now().millisecondsSinceEpoch;
    final salt = _runIdRandom.nextInt(1 << 20);
    return (nowMs << 20) | salt;
  }

  int _nextRunId() {
    final appState = _maybeAppState();
    if (appState != null) return appState.createRunId();
    return _createFallbackRunId();
  }

  void _handleGameEvent(GameEvent event) {
    if (event is! RunEndedEvent) return;
    _grantGold(event);
  }

  void _grantGold(RunEndedEvent event) {
    final runId = event.runId;
    if (_lastRewardedRunId == runId) return;

    _lastRewardedRunId = runId;
    _lastGoldEarned = event.goldEarned;

    final appState = _maybeAppState();
    if (appState == null) {
      _lastGoldTotal = null;
      return;
    }

    final currentGold =
        appState.profile.counters[ProfileCounterKeys.gold] ?? 0;
    final nextGold = currentGold + event.goldEarned;
    _lastGoldTotal = nextGold;

    appState.updateProfile((current) {
      final counters = Map<String, int>.from(current.counters);
      counters[ProfileCounterKeys.gold] = nextGold;
      return current.copyWith(counters: counters);
    });
  }

  RunnerGameUiState _buildUiState() {
    final snapshot = _controller.snapshot;
    return RunnerGameUiState(
      started: _started,
      paused: snapshot.paused,
      gameOver: snapshot.gameOver,
    );
  }

  void _startGame() {
    setState(() => _started = true);
    _clearInputs();
    _controller.setPaused(false);
  }

  void _restartGame() {
    final oldController = _controller;
    final oldProjectilePreview = _projectileAimPreview;
    final oldMeleePreview = _meleeAimPreview;
    final oldAimCancelHitboxRect = _aimCancelHitboxRect;
    oldController.removeEventListener(_handleGameEvent);

    setState(() {
      _pausedByLifecycle = false;
      _started = false;
      _exitConfirmOpen = false;
      _runId = _nextRunId();
      _lastGoldEarned = null;
      _lastGoldTotal = null;
      _initGame();
    });
    _controller.setPaused(true);
    _clearInputs();

    WidgetsBinding.instance.addPostFrameCallback((_) {
      oldController.shutdown();
      oldController.dispose();
      oldProjectilePreview.dispose();
      oldMeleePreview.dispose();
      oldAimCancelHitboxRect.dispose();
    });
  }

  void _openExitConfirm() {
    final wasPaused = _controller.snapshot.paused;
    if (!wasPaused) _clearInputs();
    _controller.setPaused(true);

    setState(() {
      _pausedBeforeExitConfirm = wasPaused;
      _exitConfirmOpen = true;
    });
  }

  void _closeExitConfirm({required bool resume}) {
    setState(() => _exitConfirmOpen = false);
    if (resume) {
      _controller.setPaused(_pausedBeforeExitConfirm);
    }
  }

  void _confirmExitGiveUp() {
    setState(() => _exitConfirmOpen = false);
    _controller.giveUp();
  }

  void _togglePause() {
    final paused = _controller.snapshot.paused;
    if (!paused) _clearInputs();
    _controller.setPaused(!paused);
  }

  void _initGame() {
    final playerCharacter =
        PlayerCharacterRegistry.byId[widget.playerCharacterId] ??
        PlayerCharacterRegistry.defaultCharacter;
    _controller = GameController(
      core: GameCore(
        seed: widget.seed,
        runId: _runId,
        levelDefinition: LevelRegistry.byId(widget.levelId),
        playerCharacter: playerCharacter,
      ),
    );
    _controller.addEventListener(_handleGameEvent);
    _input = RunnerInputRouter(controller: _controller);
    _projectileAimPreview = AimPreviewModel();
    _meleeAimPreview = AimPreviewModel();
    _aimCancelHitboxRect = ValueNotifier<Rect?>(null);
    _game = RunnerFlameGame(
      controller: _controller,
      input: _input,
      projectileAimPreview: _projectileAimPreview,
      meleeAimPreview: _meleeAimPreview,
      playerCharacter: playerCharacter,
    );
  }

  void _disposeGame() {
    _controller.removeEventListener(_handleGameEvent);
    _controller.shutdown();
    _controller.dispose();
    _projectileAimPreview.dispose();
    _meleeAimPreview.dispose();
    _aimCancelHitboxRect.dispose();
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    _disposeGame();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Stack(
      fit: StackFit.expand,
      children: [
        LayoutBuilder(
          builder: (context, constraints) {
            final devicePixelRatio = MediaQuery.devicePixelRatioOf(context);
            final metrics = computeViewportMetrics(
              constraints,
              devicePixelRatio,
              virtualWidth,
              virtualHeight,
              widget.viewportMode,
              alignment: widget.viewportAlignment,
            );
            Widget gameView = GameViewport(
              metrics: metrics,
              child: GameWidget(
                key: ValueKey(_game),
                game: _game,
                autofocus: false,
                loadingBuilder: (_) => const _RunLoadingView(),
              ),
            );

            return gameView;
          },
        ),
        AnimatedBuilder(
          animation: _controller,
          builder: (context, _) {
            final uiState = _buildUiState();
            if (uiState.gameOver) {
              final runEndedEvent = _controller.lastRunEndedEvent;
              final runEndKey =
                  runEndedEvent?.tick ?? _controller.snapshot.tick;
              return GameOverOverlay(
                key: ValueKey('gameOver-$runEndKey-${runEndedEvent?.reason}'),
                visible: true,
                onRestart: _restartGame,
                onExit: widget.onExit,
                showExitButton: widget.showExitButton,
                levelId: _controller.snapshot.levelId,
                runEndedEvent: runEndedEvent,
                scoreTuning: _controller.scoreTuning,
                tickHz: _controller.tickHz,
                goldEarned: _lastGoldEarned,
                totalGold: _lastGoldTotal,
              );
            }
            return GameOverlay(
              controller: _controller,
              input: _input,
              projectileAimPreview: _projectileAimPreview,
              meleeAimPreview: _meleeAimPreview,
              aimCancelHitboxRect: _aimCancelHitboxRect,
              uiState: uiState,
              onStart: _startGame,
              onTogglePause: _togglePause,
              showExitButton: widget.showExitButton,
              onExit: uiState.started && !uiState.gameOver
                  ? _openExitConfirm
                  : widget.onExit,
              exitConfirmOpen: _exitConfirmOpen,
              onExitConfirmResume: () => _closeExitConfirm(resume: true),
              onExitConfirmExit: _confirmExitGiveUp,
            );
          },
        ),
      ],
    );
  }
}

class _RunLoadingView extends StatelessWidget {
  const _RunLoadingView();

  @override
  Widget build(BuildContext context) {
    return ColoredBox(
      color: Colors.black,
      child: MenuLayout(
        alignment: Alignment.center,
        scrollable: false,
        child: const LoaderContent(),
      ),
    );
  }
}


===== FILE: lib/ui/scoped/scoped_preferred_orientations.dart =====
import 'package:flutter/foundation.dart';
import 'package:flutter/services.dart';
import 'package:flutter/widgets.dart';

/// Applies `SystemChrome.setPreferredOrientations` while this widget is mounted.
///
/// This is intentionally scoped to a subtree (typically a route) so the runner
/// can be embedded in a host app without enforcing a global orientation policy.
///
/// Notes:
/// - Flutter does not expose the *previous* preferred orientations, so the
///   caller must decide what to restore on dispose.
/// - Platform-level orientation support (Android manifest / iOS Info.plist)
///   still needs to include the requested orientations.
class ScopedPreferredOrientations extends StatefulWidget {
  const ScopedPreferredOrientations({
    super.key,
    required this.preferredOrientations,
    required this.child,
    this.restoreOrientations,
  });

  final List<DeviceOrientation> preferredOrientations;
  final List<DeviceOrientation>? restoreOrientations;
  final Widget child;

  @override
  State<ScopedPreferredOrientations> createState() =>
      _ScopedPreferredOrientationsState();
}

class _ScopedPreferredOrientationsState
    extends State<ScopedPreferredOrientations> {
  @override
  void initState() {
    super.initState();
    SystemChrome.setPreferredOrientations(widget.preferredOrientations);
  }

  @override
  void didUpdateWidget(covariant ScopedPreferredOrientations oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (!listEquals(
      oldWidget.preferredOrientations,
      widget.preferredOrientations,
    )) {
      SystemChrome.setPreferredOrientations(widget.preferredOrientations);
    }
  }

  @override
  void dispose() {
    final restore = widget.restoreOrientations;
    if (restore != null) {
      SystemChrome.setPreferredOrientations(restore);
    }
    super.dispose();
  }

  @override
  Widget build(BuildContext context) => widget.child;
}


===== FILE: lib/ui/scoped/scoped_system_ui_mode.dart =====
import 'package:flutter/services.dart';
import 'package:flutter/widgets.dart';

/// Applies `SystemChrome.setEnabledSystemUIMode` while this widget is mounted.
///
/// Scoped to a subtree (typically a route) so embedding stays clean.
class ScopedSystemUiMode extends StatefulWidget {
  const ScopedSystemUiMode({
    super.key,
    required this.mode,
    required this.child,
    this.overlays,
    this.restoreMode = SystemUiMode.edgeToEdge,
    this.restoreOverlays,
  });

  final SystemUiMode mode;
  final List<SystemUiOverlay>? overlays;

  final SystemUiMode restoreMode;
  final List<SystemUiOverlay>? restoreOverlays;

  final Widget child;

  @override
  State<ScopedSystemUiMode> createState() => _ScopedSystemUiModeState();
}

class _ScopedSystemUiModeState extends State<ScopedSystemUiMode> {
  @override
  void initState() {
    super.initState();
    _apply();
  }

  @override
  void didUpdateWidget(covariant ScopedSystemUiMode oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.mode != widget.mode ||
        oldWidget.overlays != widget.overlays) {
      _apply();
    }
  }

  void _apply() {
    SystemChrome.setEnabledSystemUIMode(widget.mode, overlays: widget.overlays);
  }

  @override
  void dispose() {
    SystemChrome.setEnabledSystemUIMode(
      widget.restoreMode,
      overlays: widget.restoreOverlays,
    );
    super.dispose();
  }

  @override
  Widget build(BuildContext context) => widget.child;
}


===== FILE: lib/ui/state/app_state.dart =====
import 'dart:math';

import 'package:flutter/foundation.dart';

import '../../core/ecs/stores/combat/equipped_loadout_store.dart';
import '../../core/levels/level_id.dart';
import '../../core/players/player_character_definition.dart';
import '../app/ui_routes.dart';
import 'selection_state.dart';
import 'selection_store.dart';
import 'user_profile.dart';
import 'user_profile_store.dart';

class AppState extends ChangeNotifier {
  AppState({SelectionStore? selectionStore, UserProfileStore? userProfileStore})
      : _selectionStore = selectionStore ?? SelectionStore(),
        _profileStore = userProfileStore ?? UserProfileStore();

  final Random _random = Random();
  final SelectionStore _selectionStore;
  final UserProfileStore _profileStore;

  SelectionState _selection = SelectionState.defaults;
  UserProfile _profile = UserProfile.empty();
  bool _bootstrapped = false;
  bool _warmupStarted = false;

  SelectionState get selection => _selection;
  UserProfile get profile => _profile;
  bool get isBootstrapped => _bootstrapped;

  Future<void> bootstrap({bool force = false}) async {
    if (_bootstrapped && !force) return;
    final loadedSelection = await _selectionStore.load();
    final loadedProfile = await _profileStore.load();
    _selection = loadedSelection;
    _profile = loadedProfile;
    _bootstrapped = true;
    notifyListeners();
  }

  void applyDefaults() {
    _selection = SelectionState.defaults;
    _profile = _profileStore.createFresh();
    _persistSelection();
    _persistProfile();
    notifyListeners();
  }

  Future<void> setLevel(LevelId levelId) async {
    _selection = _selection.copyWith(selectedLevelId: levelId);
    _persistSelection();
    notifyListeners();
  }

  Future<void> setRunType(RunType runType) async {
    _selection = _selection.copyWith(selectedRunType: runType);
    _persistSelection();
    notifyListeners();
  }

  Future<void> setCharacter(PlayerCharacterId id) async {
    _selection = _selection.copyWith(selectedCharacterId: id);
    _persistSelection();
    notifyListeners();
  }

  Future<void> setLoadout(EquippedLoadoutDef loadout) async {
    _selection = _selection.copyWith(equippedLoadout: loadout);
    _persistSelection();
    notifyListeners();
  }

  Future<void> setBuildName(String buildName) async {
    final normalized = SelectionState.normalizeBuildName(buildName);
    if (normalized == _selection.buildName) return;
    _selection = _selection.copyWith(buildName: normalized);
    _persistSelection();
    notifyListeners();
  }

  Future<void> updateProfile(
    UserProfile Function(UserProfile current) fn,
  ) async {
    final current = _profile;
    final updated = fn(current);
    final nowMs = DateTime.now().millisecondsSinceEpoch;
    final next = updated.copyWith(
      schemaVersion: UserProfile.latestSchemaVersion,
      profileId:
          updated.profileId.isEmpty ? current.profileId : updated.profileId,
      createdAtMs:
          updated.createdAtMs == 0 ? current.createdAtMs : updated.createdAtMs,
      updatedAtMs: nowMs,
      revision: current.revision + 1,
    );
    _profile = next;
    await _profileStore.save(next);
    notifyListeners();
  }

  void startWarmup() {
    if (_warmupStarted) return;
    _warmupStarted = true;
    // TODO: kick off non-critical asset caching and lightweight services.
  }

  RunStartArgs buildRunStartArgs({int? seed}) {
    return RunStartArgs(
      runId: createRunId(),
      seed: seed ?? _random.nextInt(1 << 31),
      levelId: _selection.selectedLevelId,
      playerCharacterId: _selection.selectedCharacterId,
      runType: _selection.selectedRunType,
    );
  }

  int createRunId() => _createRunId();

  int _createRunId() {
    final nowMs = DateTime.now().millisecondsSinceEpoch;
    final salt = _random.nextInt(1 << 20);
    return (nowMs << 20) | salt;
  }

  void _persistSelection() {
    _selectionStore.save(_selection);
  }

  void _persistProfile() {
    _profileStore.save(_profile);
  }
}


===== FILE: lib/ui/state/profile_counter_keys.dart =====
class ProfileCounterKeys {
  const ProfileCounterKeys._();

  static const String gold = 'gold';
}


===== FILE: lib/ui/state/profile_flag_keys.dart =====
class ProfileFlagKeys {
  const ProfileFlagKeys._();

  static const String namePromptCompleted = 'namePromptCompleted';
}


===== FILE: lib/ui/state/selection_state.dart =====
import '../../core/ecs/stores/combat/equipped_loadout_store.dart';
import '../../core/levels/level_id.dart';
import '../../core/players/player_character_definition.dart';
import '../../core/projectiles/projectile_item_id.dart';
import '../../core/weapons/weapon_id.dart';

/// Menu-facing run type for the selected level.
enum RunType { practice, competitive }

/// Persistent menu selection state.
class SelectionState {
  const SelectionState({
    required this.selectedLevelId,
    required this.selectedRunType,
    required this.selectedCharacterId,
    required this.equippedLoadout,
    required this.buildName,
  });

  static const String defaultBuildName = 'Build 1';
  static const int buildNameMaxLength = 24;

  static const SelectionState defaults = SelectionState(
    selectedLevelId: LevelId.field,
    selectedRunType: RunType.practice,
    selectedCharacterId: PlayerCharacterId.eloise,
    equippedLoadout: EquippedLoadoutDef(),
    buildName: defaultBuildName,
  );

  final LevelId selectedLevelId;
  final RunType selectedRunType;
  final PlayerCharacterId selectedCharacterId;
  final EquippedLoadoutDef equippedLoadout;
  final String buildName;

  bool get isCompetitive => selectedRunType == RunType.competitive;

  SelectionState copyWith({
    LevelId? selectedLevelId,
    RunType? selectedRunType,
    PlayerCharacterId? selectedCharacterId,
    EquippedLoadoutDef? equippedLoadout,
    String? buildName,
  }) {
    return SelectionState(
      selectedLevelId: selectedLevelId ?? this.selectedLevelId,
      selectedRunType: selectedRunType ?? this.selectedRunType,
      selectedCharacterId: selectedCharacterId ?? this.selectedCharacterId,
      equippedLoadout: equippedLoadout ?? this.equippedLoadout,
      buildName:
          buildName == null ? this.buildName : normalizeBuildName(buildName),
    );
  }

  Map<String, Object?> toJson() {
    return <String, Object?>{
      'levelId': selectedLevelId.name,
      'runType': selectedRunType.name,
      'characterId': selectedCharacterId.name,
      'loadout': _loadoutToJson(equippedLoadout),
      'buildName': buildName,
    };
  }

  static SelectionState fromJson(Map<String, dynamic> json) {
    final levelId = _enumFromName(
      LevelId.values,
      json['levelId'] as String?,
      LevelId.field,
    );
    final runType = _enumFromName(
      RunType.values,
      json['runType'] as String?,
      RunType.practice,
    );
    final characterId = _enumFromName(
      PlayerCharacterId.values,
      json['characterId'] as String?,
      PlayerCharacterId.eloise,
    );
    final loadout = _loadoutFromJson(json['loadout']);
    final buildName = normalizeBuildName(
      json['buildName'] is String ? json['buildName'] as String : null,
    );

    return SelectionState(
      selectedLevelId: levelId,
      selectedRunType: runType,
      selectedCharacterId: characterId,
      equippedLoadout: loadout,
      buildName: buildName,
    );
  }

  static String normalizeBuildName(String? raw) {
    final trimmed = (raw ?? '').trim();
    if (trimmed.isEmpty) return defaultBuildName;
    if (trimmed.length <= buildNameMaxLength) return trimmed;
    return trimmed.substring(0, buildNameMaxLength);
  }
}

T _enumFromName<T extends Enum>(List<T> values, String? name, T fallback) {
  if (name == null) return fallback;
  for (final value in values) {
    if (value.name == name) return value;
  }
  return fallback;
}

Map<String, Object?> _loadoutToJson(EquippedLoadoutDef loadout) {
  return <String, Object?>{
    'mask': loadout.mask,
    'mainWeaponId': loadout.mainWeaponId.name,
    'offhandWeaponId': loadout.offhandWeaponId.name,
    'projectileItemId': loadout.projectileItemId.name,
    'abilityPrimaryId': loadout.abilityPrimaryId,
    'abilitySecondaryId': loadout.abilitySecondaryId,
    'abilityProjectileId': loadout.abilityProjectileId,
    'abilityBonusId': loadout.abilityBonusId,
    'abilityMobilityId': loadout.abilityMobilityId,
    'abilityJumpId': loadout.abilityJumpId,
  };
}

EquippedLoadoutDef _loadoutFromJson(Object? raw) {
  if (raw is! Map) {
    return const EquippedLoadoutDef();
  }
  final map = Map<String, dynamic>.from(raw);
  return EquippedLoadoutDef(
    mask: map['mask'] is int ? map['mask'] as int : LoadoutSlotMask.defaultMask,
    mainWeaponId: _enumFromName(
      WeaponId.values,
      map['mainWeaponId'] as String?,
      WeaponId.basicSword,
    ),
    offhandWeaponId: _enumFromName(
      WeaponId.values,
      map['offhandWeaponId'] as String?,
      WeaponId.basicShield,
    ),
    projectileItemId: _enumFromName(
      ProjectileItemId.values,
      map['projectileItemId'] as String?,
      ProjectileItemId.iceBolt,
    ),
    abilityPrimaryId: (map['abilityPrimaryId'] as String?) ??
        const EquippedLoadoutDef().abilityPrimaryId,
    abilitySecondaryId: (map['abilitySecondaryId'] as String?) ??
        const EquippedLoadoutDef().abilitySecondaryId,
    abilityProjectileId: (map['abilityProjectileId'] as String?) ??
        const EquippedLoadoutDef().abilityProjectileId,
    abilityBonusId: (map['abilityBonusId'] as String?) ??
        const EquippedLoadoutDef().abilityBonusId,
    abilityMobilityId: (map['abilityMobilityId'] as String?) ??
        const EquippedLoadoutDef().abilityMobilityId,
    abilityJumpId: (map['abilityJumpId'] as String?) ??
        const EquippedLoadoutDef().abilityJumpId,
  );
}


===== FILE: lib/ui/state/selection_store.dart =====
import 'dart:convert';

import 'package:shared_preferences/shared_preferences.dart';

import 'selection_state.dart';

class SelectionStore {
  static const String _prefsKey = 'ui.selection_state.v1';

  Future<SelectionState> load() async {
    final prefs = await SharedPreferences.getInstance();
    final raw = prefs.getString(_prefsKey);
    if (raw == null || raw.isEmpty) {
      return SelectionState.defaults;
    }

    try {
      final decoded = jsonDecode(raw);
      if (decoded is Map<String, dynamic>) {
        return SelectionState.fromJson(decoded);
      }
      if (decoded is Map) {
        return SelectionState.fromJson(Map<String, dynamic>.from(decoded));
      }
    } catch (_) {
      // Fall through to defaults.
    }

    return SelectionState.defaults;
  }

  Future<void> save(SelectionState state) async {
    final prefs = await SharedPreferences.getInstance();
    final payload = jsonEncode(state.toJson());
    await prefs.setString(_prefsKey, payload);
  }

  Future<void> clear() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.remove(_prefsKey);
  }
}


===== FILE: lib/ui/state/user_profile.dart =====
import 'profile_counter_keys.dart';

class UserProfile {
  UserProfile({
    required this.schemaVersion,
    required this.profileId,
    required this.createdAtMs,
    required this.updatedAtMs,
    required this.revision,
    required this.displayName,
    required this.displayNameLastChangedAtMs,
    required Map<String, bool> flags,
    required Map<String, int> counters,
  }) : flags = Map<String, bool>.unmodifiable(flags),
       counters = Map<String, int>.unmodifiable(counters);

  static const int latestSchemaVersion = 2;

  final int schemaVersion;
  final String profileId;
  final int createdAtMs;
  final int updatedAtMs;
  final int revision;
  final String displayName;
  final int displayNameLastChangedAtMs;
  final Map<String, bool> flags;
  final Map<String, int> counters;

  static UserProfile empty() {
    return UserProfile(
      schemaVersion: latestSchemaVersion,
      profileId: 'guest',
      createdAtMs: 0,
      updatedAtMs: 0,
      revision: 0,
      displayName: '',
      displayNameLastChangedAtMs: 0,
      flags: const <String, bool>{},
      counters: const <String, int>{ProfileCounterKeys.gold: 0},
    );
  }

  static UserProfile createNew({
    required String profileId,
    required int nowMs,
  }) {
    return UserProfile(
      schemaVersion: latestSchemaVersion,
      profileId: profileId,
      createdAtMs: nowMs,
      updatedAtMs: nowMs,
      revision: 0,
      displayName: '',
      displayNameLastChangedAtMs: 0,
      flags: const <String, bool>{},
      counters: const <String, int>{ProfileCounterKeys.gold: 0},
    );
  }

  UserProfile copyWith({
    int? schemaVersion,
    String? profileId,
    int? createdAtMs,
    int? updatedAtMs,
    int? revision,
    String? displayName,
    int? displayNameLastChangedAtMs,
    Map<String, bool>? flags,
    Map<String, int>? counters,
  }) {
    return UserProfile(
      schemaVersion: schemaVersion ?? this.schemaVersion,
      profileId: profileId ?? this.profileId,
      createdAtMs: createdAtMs ?? this.createdAtMs,
      updatedAtMs: updatedAtMs ?? this.updatedAtMs,
      revision: revision ?? this.revision,
      displayName: displayName ?? this.displayName,
      displayNameLastChangedAtMs:
          displayNameLastChangedAtMs ?? this.displayNameLastChangedAtMs,
      flags: flags ?? this.flags,
      counters: counters ?? this.counters,
    );
  }

  Map<String, Object?> toJson() {
    return <String, Object?>{
      'schemaVersion': schemaVersion,
      'profileId': profileId,
      'createdAtMs': createdAtMs,
      'updatedAtMs': updatedAtMs,
      'revision': revision,
      'displayName': displayName,
      'displayNameLastChangedAtMs': displayNameLastChangedAtMs,
      'flags': flags,
      'counters': counters,
    };
  }

  factory UserProfile.fromJson(
    Map<String, dynamic> json, {
    required String fallbackProfileId,
    required int nowMs,
  }) {
    final schemaVersion =
        _readInt(json['schemaVersion']) ?? latestSchemaVersion;
    final profileId = _readString(json['profileId']) ?? fallbackProfileId;
    final createdAtMs = _readInt(json['createdAtMs']) ?? nowMs;
    final updatedAtMs = _readInt(json['updatedAtMs']) ?? createdAtMs;
    final revision = _readInt(json['revision']) ?? 0;
    final displayName = _readStringAllowEmpty(json['displayName']) ?? '';
    final displayNameLastChangedAtMs =
        _readInt(json['displayNameLastChangedAtMs']) ?? 0;
    final flags = _readBoolMap(json['flags']);
    final counters = _readIntMap(json['counters']);
    counters.putIfAbsent(ProfileCounterKeys.gold, () => 0);

    return UserProfile(
      schemaVersion: schemaVersion,
      profileId: profileId,
      createdAtMs: createdAtMs,
      updatedAtMs: updatedAtMs,
      revision: revision,
      displayName: displayName,
      displayNameLastChangedAtMs: displayNameLastChangedAtMs,
      flags: flags,
      counters: counters,
    );
  }
}

int? _readInt(Object? raw) {
  if (raw is int) return raw;
  if (raw is num) return raw.toInt();
  return null;
}

String? _readString(Object? raw) {
  if (raw is String && raw.isNotEmpty) return raw;
  return null;
}

String? _readStringAllowEmpty(Object? raw) {
  if (raw is String) return raw;
  return null;
}

Map<String, bool> _readBoolMap(Object? raw) {
  if (raw is! Map) return <String, bool>{};
  final map = <String, bool>{};
  raw.forEach((key, value) {
    if (key is String && value is bool) {
      map[key] = value;
    }
  });
  return map;
}

Map<String, int> _readIntMap(Object? raw) {
  if (raw is! Map) return <String, int>{};
  final map = <String, int>{};
  raw.forEach((key, value) {
    if (key is! String) return;
    if (value is int) {
      map[key] = value;
      return;
    }
    if (value is num) {
      map[key] = value.toInt();
    }
  });
  return map;
}


===== FILE: lib/ui/state/user_profile_store.dart =====
import 'dart:convert';
import 'dart:developer' as developer;
import 'dart:math';

import 'package:shared_preferences/shared_preferences.dart';

import 'user_profile.dart';
import 'profile_counter_keys.dart';

class UserProfileStore {
  UserProfileStore({Random? random, DateTime Function()? now})
    : _random = random ?? Random(),
      _now = now ?? DateTime.now;

  static const String _prefsKey = 'ui.user_profile';

  final Random _random;
  final DateTime Function() _now;

  Future<UserProfile> load() async {
    final prefs = await SharedPreferences.getInstance();
    final raw = prefs.getString(_prefsKey);
    final nowMs = _now().millisecondsSinceEpoch;
    final fallbackProfileId = _generateProfileId(nowMs);

    if (raw == null || raw.isEmpty) {
      final created = UserProfile.createNew(
        profileId: fallbackProfileId,
        nowMs: nowMs,
      );
      await save(created);
      return created;
    }

    try {
      final decoded = jsonDecode(raw);
      Map<String, dynamic>? map;
      if (decoded is Map<String, dynamic>) {
        map = decoded;
      } else if (decoded is Map) {
        map = Map<String, dynamic>.from(decoded);
      }

      if (map == null) {
        _logWarning(
          'Expected map payload for user profile but found '
          '${decoded.runtimeType}.',
        );
      } else {
        final migration = _migrateToLatest(
          map,
          nowMs: nowMs,
          fallbackProfileId: fallbackProfileId,
        );
        final profile = UserProfile.fromJson(
          migration.data,
          fallbackProfileId: fallbackProfileId,
          nowMs: nowMs,
        );
        if (migration.didChange) {
          await save(profile);
        }
        return profile;
      }
    } catch (error, stackTrace) {
      _logWarning(
        'Failed to decode stored user profile.',
        error: error,
        stackTrace: stackTrace,
      );
    }

    final created = UserProfile.createNew(
      profileId: fallbackProfileId,
      nowMs: nowMs,
    );
    await save(created);
    return created;
  }

  Future<void> save(UserProfile profile) async {
    final prefs = await SharedPreferences.getInstance();
    final payload = jsonEncode(profile.toJson());
    await prefs.setString(_prefsKey, payload);
  }

  Future<void> clear() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.remove(_prefsKey);
  }

  UserProfile createFresh() {
    final nowMs = _now().millisecondsSinceEpoch;
    return UserProfile.createNew(
      profileId: _generateProfileId(nowMs),
      nowMs: nowMs,
    );
  }

  _MigrationResult _migrateToLatest(
    Map<String, dynamic> raw, {
    required int nowMs,
    required String fallbackProfileId,
  }) {
    var didChange = false;
    final data = Map<String, dynamic>.from(raw);

    final schemaVersion = _readInt(data['schemaVersion']);
    if (schemaVersion == null) {
      data['schemaVersion'] = UserProfile.latestSchemaVersion;
      didChange = true;
    } else if (schemaVersion < UserProfile.latestSchemaVersion) {
      data['schemaVersion'] = UserProfile.latestSchemaVersion;
      didChange = true;
    }

    final profileId = data['profileId'];
    if (profileId is! String || profileId.isEmpty) {
      data['profileId'] = fallbackProfileId;
      didChange = true;
    }

    final createdAtMs = _readInt(data['createdAtMs']);
    if (createdAtMs == null) {
      data['createdAtMs'] = nowMs;
      didChange = true;
    }

    final updatedAtMs = _readInt(data['updatedAtMs']);
    if (updatedAtMs == null) {
      data['updatedAtMs'] = createdAtMs ?? nowMs;
      didChange = true;
    }

    final revision = _readInt(data['revision']);
    if (revision == null) {
      data['revision'] = 0;
      didChange = true;
    }

    final displayName = data['displayName'];
    if (displayName is! String) {
      data['displayName'] = '';
      didChange = true;
    }

    // displayNameNormalized removal (schema v2)
    if (data.containsKey('displayNameNormalized')) {
      data.remove('displayNameNormalized');
      didChange = true;
    }

    final displayNameLastChangedAtMs = _readInt(
      data['displayNameLastChangedAtMs'],
    );
    if (displayNameLastChangedAtMs == null) {
      data['displayNameLastChangedAtMs'] = 0;
      didChange = true;
    }

    if (data['flags'] is! Map) {
      data['flags'] = <String, bool>{};
      didChange = true;
    }

    if (data['counters'] is! Map) {
      data['counters'] = <String, int>{};
      didChange = true;
    } else {
      final counters = data['counters'];
      if (counters is Map && !counters.containsKey(ProfileCounterKeys.gold)) {
        counters[ProfileCounterKeys.gold] = 0;
        didChange = true;
      }
    }

    return _MigrationResult(data, didChange);
  }

  String _generateProfileId(int nowMs) {
    final stamp = nowMs.toRadixString(36);
    final suffix = _random.nextInt(1 << 31).toRadixString(36);
    return 'guest_${stamp}_$suffix';
  }

  void _logWarning(String message, {Object? error, StackTrace? stackTrace}) {
    developer.log(
      message,
      name: 'UserProfileStore',
      error: error,
      stackTrace: stackTrace,
    );
  }

  int? _readInt(Object? raw) {
    if (raw is int) return raw;
    if (raw is num) return raw.toInt();
    return null;
  }
}

class _MigrationResult {
  const _MigrationResult(this.data, this.didChange);

  final Map<String, dynamic> data;
  final bool didChange;
}


===== FILE: lib/ui/viewport/game_viewport.dart =====
import 'package:flutter/widgets.dart';

import 'viewport_metrics.dart';

/// Scales a fixed virtual canvas into the available space.
///
/// Use [computeViewportMetrics] so rendering and input mapping share the same
/// view size + offset.
class GameViewport extends StatelessWidget {
  const GameViewport({
    super.key,
    required this.metrics,
    required this.child,
    this.letterboxColor = const Color(0xFF000000),
  });

  final ViewportMetrics metrics;
  final Widget child;
  final Color letterboxColor;

  @override
  Widget build(BuildContext context) {
    return ColoredBox(
      color: letterboxColor,
      child: ClipRect(
        child: SizedBox.expand(
          child: Stack(
            fit: StackFit.expand,
            children: [
              Positioned(
                left: metrics.offsetX,
                top: metrics.offsetY,
                width: metrics.viewW,
                height: metrics.viewH,
                child: child,
              ),
            ],
          ),
        ),
      ),
    );
  }
}


===== FILE: lib/ui/viewport/viewport_metrics.dart =====
import 'dart:math' as math;

import 'package:flutter/widgets.dart';
/// Viewport scaling modes for fitting a fixed virtual canvas to the screen.
enum ViewportScaleMode {
  /// Integer physical-pixel scale (pixel-perfect, no cropping).
  ///
  /// Fits the entire virtual canvas on-screen, letterboxing the remaining area.
  pixelPerfectContain,

  /// Integer physical-pixel scale (pixel-perfect, with cropping).
  ///
  /// Fully covers the screen by scaling up until both dimensions fit. Any
  /// overflow is cropped by the outer [ClipRect].
  pixelPerfectCover,
}

/// Shared viewport sizing results for rendering and input mapping.
@immutable
class ViewportMetrics {
  const ViewportMetrics({
    required this.viewW,
    required this.viewH,
    required this.offsetX,
    required this.offsetY,
  });

  /// Scaled viewport width in logical pixels.
  final double viewW;

  /// Scaled viewport height in logical pixels.
  final double viewH;

  /// Viewport top-left offset in logical pixels.
  final double offsetX;

  /// Viewport top-left offset in logical pixels.
  final double offsetY;
}

/// Computes shared viewport metrics from the current layout constraints.
ViewportMetrics computeViewportMetrics(
  BoxConstraints constraints,
  double devicePixelRatio,
  int virtualW,
  int virtualH,
  ViewportScaleMode mode, {
  Alignment alignment = Alignment.center,
}) {
  assert(devicePixelRatio > 0);
  assert(virtualW > 0);
  assert(virtualH > 0);

  final screenW = constraints.hasBoundedWidth ? constraints.maxWidth : 0.0;
  final screenH = constraints.hasBoundedHeight ? constraints.maxHeight : 0.0;
  final screenPxW = screenW * devicePixelRatio;
  final screenPxH = screenH * devicePixelRatio;

  final scaleW = screenPxW / virtualW;
  final scaleH = screenPxH / virtualH;

  final scalePx = switch (mode) {
    ViewportScaleMode.pixelPerfectContain =>
      math.max(1.0, math.min(scaleW, scaleH).floorToDouble()),
    ViewportScaleMode.pixelPerfectCover =>
      math.max(1.0, math.max(scaleW, scaleH).ceilToDouble()),
  };

  final viewPxW = virtualW * scalePx;
  final viewPxH = virtualH * scalePx;
  final viewW = viewPxW / devicePixelRatio;
  final viewH = viewPxH / devicePixelRatio;

  final alignX = (alignment.x + 1.0) * 0.5;
  final alignY = (alignment.y + 1.0) * 0.5;
  final offsetX = (screenW - viewW) * alignX;
  final offsetY = (screenH - viewH) * alignY;

  return ViewportMetrics(
    viewW: viewW,
    viewH: viewH,
    offsetX: offsetX,
    offsetY: offsetY,
  );
}

