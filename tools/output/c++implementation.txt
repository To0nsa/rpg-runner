===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/animation/Animation.cpp =====
#include "animation/Animation.h"

#include <algorithm>
#include <utility>

// SpriteAnimator implementation
SpriteAnimator::SpriteAnimator(sf::Sprite& sprite) : m_sprite(sprite) {}

SpriteAnimator::ClipId SpriteAnimator::addClip(AnimationClip clip) {
    const ClipId id = m_clips.size();
    m_clips.push_back(std::move(clip));
    return id;
}

void SpriteAnimator::playClip(ClipId clipId, std::function<void()> onCompleteOnce) {
    if (clipId == kInvalidClip || clipId >= m_clips.size())
        return;

    const bool sameClip = (clipId == m_activeClipId);

    if (sameClip && !m_restartRequested) {
        if (onCompleteOnce) {
            m_onCompleteOnce = std::move(onCompleteOnce);
        }
        return;
    }

    // When restarting the same clip without providing a new callback, preserve the existing one.
    std::function<void()> cb = std::move(onCompleteOnce);
    if (!cb && sameClip)
        cb = m_onCompleteOnce;

    m_activeClipId     = clipId;
    m_onCompleteOnce   = std::move(cb);
    m_timeAccumulator  = 0.f;
    m_frameIndex       = 0;
    m_restartRequested = false;

    if (const auto& clip = m_clips[m_activeClipId]; clip.texture)
        m_sprite.setTexture(*clip.texture);
    applyFrameRect();
}

void SpriteAnimator::requestRestart() { m_restartRequested = true; }

void SpriteAnimator::update(float dt) {
    if (m_activeClipId == kInvalidClip || m_activeClipId >= m_clips.size())
        return;

    AnimationClip& clip = m_clips[m_activeClipId];

    if (clip.frames.empty() || clip.fps <= 0.f)
        return;

    m_timeAccumulator += dt;
    const float frameDuration = 1.f / clip.fps;

    while (m_timeAccumulator >= frameDuration) {
        m_timeAccumulator -= frameDuration;
        advanceFrame(clip);
    }
}

void SpriteAnimator::advanceFrame(const AnimationClip& clip) {
    if (m_frameIndex + 1 < clip.frames.size()) {
        ++m_frameIndex;
        applyFrameRect();
        return;
    }

    if (clip.looping) {
        m_frameIndex = 0;
        applyFrameRect();
    } else {
        // Hold on the last frame and fire completion once.
        if (m_onCompleteOnce) {
            auto cb          = std::move(m_onCompleteOnce);
            m_onCompleteOnce = nullptr;
            cb();
        }
    }
}

void SpriteAnimator::applyFrameRect() {
    if (m_activeClipId == kInvalidClip || m_activeClipId >= m_clips.size())
        return;
    const AnimationClip& clip = m_clips[m_activeClipId];
    if (clip.frames.empty())
        return;
    m_sprite.setTextureRect(clip.frames[m_frameIndex].rect);
}

// Animation namespace implementation
namespace Animation {

    AnimationClip makeClipFromRow(const std::string& name, const sf::Texture& texture,
                                  sf::Vector2i frameSize, int frameCount, float fps, bool looping) {
        AnimationClip clip;
        clip.name    = name;
        clip.texture = &texture;
        clip.fps     = fps;
        clip.looping = looping;

        clip.frames.reserve(frameCount);
        for (int i = 0; i < frameCount; ++i) {
            clip.frames.push_back(AnimationClip::Frame{
                sf::IntRect{{i * frameSize.x, 0}, {frameSize.x, frameSize.y}}});
        }
        return clip;
    }

    AnimationClip makeClipFromSheet(const std::string& name, const sf::Texture& texture,
                                    sf::Vector2i frameSize, sf::Vector2i firstCell,
                                    sf::Vector2i lastCell, float fps, bool looping) {
        AnimationClip clip;
        clip.name    = name;
        clip.texture = &texture;
        clip.fps     = fps;
        clip.looping = looping;

        // Grid metrics
        const sf::Vector2u texSz = texture.getSize();
        const int          cols  = (frameSize.x > 0) ? static_cast<int>(texSz.x) / frameSize.x : 0;
        const int          rows  = (frameSize.y > 0) ? static_cast<int>(texSz.y) / frameSize.y : 0;
        if (cols <= 0 || rows <= 0)
            return clip;

        auto toIndex = [cols](sf::Vector2i cell) { return cell.y * cols + cell.x; };

        // Clamp to grid and ensure start <= end
        firstCell.x = std::clamp(firstCell.x, 0, cols - 1);
        firstCell.y = std::clamp(firstCell.y, 0, rows - 1);
        lastCell.x  = std::clamp(lastCell.x, 0, cols - 1);
        lastCell.y  = std::clamp(lastCell.y, 0, rows - 1);

        int start = toIndex(firstCell);
        int end   = toIndex(lastCell);
        if (start > end)
            std::swap(start, end);

        clip.frames.reserve(static_cast<std::size_t>(end - start + 1));
        for (int i = start; i <= end; ++i) {
            const int c = i % cols;
            const int r = i / cols;
            clip.frames.push_back(AnimationClip::Frame{
                sf::IntRect{{c * frameSize.x, r * frameSize.y}, {frameSize.x, frameSize.y}}});
        }
        return clip;
    }

} // namespace Animation

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/animation/Animation.cpp =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/animation/Animation.h =====
#pragma once

#include <SFML/Graphics/Rect.hpp>
#include <SFML/Graphics/Sprite.hpp>
#include <SFML/Graphics/Texture.hpp>
#include <SFML/System/Vector2.hpp>
#include <cstdint>
#include <functional>
#include <limits>
#include <string>
#include <vector>

struct AnimationClip {
    struct Frame {
        sf::IntRect rect{};
    };

    std::string        name;
    const sf::Texture* texture = nullptr;
    std::vector<Frame> frames;
    float              fps     = 8.f;
    bool               looping = true;
};

class SpriteAnimator {
  public:
    using ClipId                         = std::size_t;
    static constexpr ClipId kInvalidClip = std::numeric_limits<ClipId>::max();

    explicit SpriteAnimator(sf::Sprite& sprite);

    ClipId addClip(AnimationClip clip);

    // Start or switch to a clip. If non-looping, onCompleteOnce fires when the
    // clip finishes.
    void playClip(ClipId clipId, std::function<void()> onCompleteOnce = {});

    // Request a restart of the current clip at the next update
    void requestRestart();

    void update(float dt);

  private:
    sf::Sprite&                m_sprite;
    std::vector<AnimationClip> m_clips;

    ClipId                m_activeClipId = kInvalidClip;
    std::function<void()> m_onCompleteOnce;

    float       m_timeAccumulator  = 0.f;
    std::size_t m_frameIndex       = 0;
    bool        m_restartRequested = false;

    void advanceFrame(const AnimationClip& clip);
    void applyFrameRect();
};

namespace Animation {

    AnimationClip makeClipFromRow(const std::string& name, const sf::Texture& texture,
                                  sf::Vector2i frameSize, int frameCount, float fps, bool looping);

    AnimationClip makeClipFromSheet(const std::string& name, const sf::Texture& texture,
                                    sf::Vector2i frameSize, sf::Vector2i firstCell,
                                    sf::Vector2i lastCell, float fps, bool looping);

} // namespace Animation

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/animation/Animation.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/collision/Collider.h =====
// Collider.h
#pragma once
#include <SFML/Graphics.hpp>

class Collider {
  public:
    virtual ~Collider() = default;

    virtual sf::FloatRect worldAabb() const = 0;

    bool intersects(const Collider& other) const {
        return worldAabb().findIntersection(other.worldAabb()).has_value();
    }
};

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/collision/Collider.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/collision/CollisionLayers.h =====
#pragma once

#include <cstdint>
#include <initializer_list>

// Basic collision layer + mask helpers. Layers are mutually exclusive per entity;
// masks express which layers this entity is willing to interact with.
enum class CollisionLayer : std::uint8_t {
    None = 0,
    Player,
    Enemy,
    PlayerProjectile,
    EnemyProjectile,
    Obstacle,
    Platform,
    Collectible,
    Count
};

using CollisionMask = std::uint32_t;

constexpr CollisionMask maskNone() { return 0u; }
constexpr CollisionMask maskAll() { return 0xFFFFFFFFu; }

constexpr CollisionMask maskFor(CollisionLayer layer) {
    return static_cast<CollisionMask>(1u) << static_cast<std::uint8_t>(layer);
}

constexpr CollisionMask maskFrom(std::initializer_list<CollisionLayer> layers) {
    CollisionMask mask = maskNone();
    for (auto layer : layers)
        mask |= maskFor(layer);
    return mask;
}

constexpr bool maskContains(CollisionMask mask, CollisionLayer layer) {
    return (mask & maskFor(layer)) != 0;
}

// Two entities "can collide" only if both masks agree on each other's layer.
constexpr bool layersCanCollide(CollisionLayer aLayer, CollisionMask aMask, CollisionLayer bLayer,
                                CollisionMask bMask) {
    return maskContains(aMask, bLayer) && maskContains(bMask, aLayer);
}

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/collision/CollisionLayers.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/collision/CollisionSystem.cpp =====
#include "collision/CollisionSystem.h"

#include "collision/CollisionLayers.h"
#include "core/World.h"
#include "entities/actor/enemy/Enemy.h"
#include "entities/actor/player/Player.h"
#include "entities/collectible/RedSquare.h"
#include "entities/obstacle/Obstacle.h"
#include "entities/platform/Platform.h"
#include "environment/Environment.h"
#include "gameplay/Damage.h"
#include "gameplay/GameSession.h"
#include "spell/projectile/Projectile.h"
#include "utils/Geom.h"
#include "utils/Math.h"

namespace {
    void resolvePlayerObstacleContactDps(const CollisionContext& ctx) {
        Player* player = ctx.player;
        if (!player || !player->isAlive())
            return;

        const sf::FloatRect playerBounds = player->getCollider().worldAabb();
        for (auto* obstacle : ctx.obstacles) {
            if (!obstacle || !obstacle->isAlive())
                continue;

            const sf::FloatRect obstacleBounds = obstacle->getCollider().worldAabb();
            if (!geom::aabbIntersects(playerBounds, obstacleBounds))
                continue;

            // Contact damage when intersecting obstacle sides; separation is handled in physics.
            DamageInfo info = buildDamageInfo(obstacle->getDps() * ctx.dt, obstacle, playerBounds,
                                              &obstacleBounds);
            player->applyDamage(info);
        }
    }

    void resolveObstacleTopDps(const CollisionContext& ctx) {
        Player* player = ctx.player;
        if (!player || !player->isAlive())
            return;

        const sf::FloatRect playerBounds = player->getCollider().worldAabb();
        for (auto* obstacle : ctx.obstacles) {
            if (!obstacle || !obstacle->isAlive())
                continue;
            const sf::FloatRect obstacleBounds = obstacle->getCollider().worldAabb();
            if (geom::touchTop(playerBounds, obstacleBounds, 0.75f)) {
                DamageInfo info = buildDamageInfo(obstacle->getDps() * ctx.dt, obstacle,
                                                  playerBounds, &obstacleBounds);
                player->applyDamage(info);
            }
        }
    }

    void resolveProjectileHits(const CollisionContext& ctx) {
        for (auto* proj : ctx.projectiles) {
            if (!proj || !proj->isAlive() || !proj->isDamageActive())
                continue;

            const sf::FloatRect  projectileBounds = proj->getCollider().worldAabb();
            const CollisionLayer projLayer        = proj->getCollisionLayer();
            const CollisionMask  projMask         = proj->getCollisionMask();

            if (projLayer == CollisionLayer::EnemyProjectile) {
                Player* player = ctx.player;
                if (!player || !player->isAlive())
                    continue;
                if (!layersCanCollide(projLayer, projMask, player->getCollisionLayer(),
                                      player->getCollisionMask()))
                    continue;
                const sf::FloatRect playerBounds = player->getCollider().worldAabb();
                if (geom::aabbIntersects(projectileBounds, playerBounds)) {
                    DamageInfo info = buildDamageInfo(proj->getStats().damage, proj, playerBounds,
                                                      &projectileBounds);
                    player->applyDamage(info);
                    proj->requestImpact();
                }
            } else if (projLayer == CollisionLayer::PlayerProjectile) {
                bool hitEnemy = false;

                // Enemies
                for (auto* enemy : ctx.enemies) {
                    if (!enemy || !enemy->isAlive())
                        continue;
                    if (!layersCanCollide(projLayer, projMask, enemy->getCollisionLayer(),
                                          enemy->getCollisionMask()))
                        continue;
                    const sf::FloatRect enemyBounds = enemy->getCollider().worldAabb();
                    if (geom::aabbIntersects(projectileBounds, enemyBounds)) {
                        const float hpBefore = enemy->getHp();
                        DamageInfo  info     = buildDamageInfo(proj->getStats().damage, proj,
                                                               enemyBounds, &projectileBounds);
                        enemy->applyDamage(info);
                        if (hpBefore > 0.f && enemy->getHp() <= 0.f && ctx.session)
                            ctx.session->addScore(100);
                        proj->requestImpact();
                        hitEnemy = true;
                        break;
                    }
                }
                if (hitEnemy)
                    continue;

                // Collectibles
                for (auto* collectible : ctx.collectibles) {
                    if (!collectible || !collectible->isAlive())
                        continue;
                    if (!layersCanCollide(projLayer, projMask, collectible->getCollisionLayer(),
                                          collectible->getCollisionMask()))
                        continue;
                    const sf::FloatRect collectibleBounds = collectible->getCollider().worldAabb();
                    if (geom::aabbIntersects(projectileBounds, collectibleBounds)) {
                        if (ctx.session)
                            ctx.session->addScore(100);
                        collectible->setAlive(false);
                        proj->requestImpact();
                        break;
                    }
                }
            }
        }
    }

    void resolvePlayerCollectibles(const CollisionContext& ctx) {
        Player* player = ctx.player;
        if (!player || !player->isAlive())
            return;

        const sf::FloatRect playerBounds = player->getCollider().worldAabb();
        for (auto* collectible : ctx.collectibles) {
            if (!collectible || !collectible->isAlive())
                continue;
            if (!layersCanCollide(player->getCollisionLayer(), player->getCollisionMask(),
                                  collectible->getCollisionLayer(),
                                  collectible->getCollisionMask()))
                continue;
            const sf::FloatRect collectibleBounds = collectible->getCollider().worldAabb();
            if (geom::aabbIntersects(playerBounds, collectibleBounds)) {
                if (ctx.session)
                    ctx.session->addScore(100);
                collectible->setAlive(false);
            }
        }
    }

    void resolveHazards(const CollisionContext& ctx) {
        Player* player = ctx.player;
        if (!player || !player->isAlive())
            return;

        const sf::FloatRect playerBounds = player->getCollider().worldAabb();
        if (ctx.environment && ctx.cameraView) {
            if (ctx.environment->intersectsHazard(playerBounds, *ctx.cameraView)) {
                // Treat environment hazard as an instant-kill hit without a concrete source entity.
                DamageInfo info = buildDamageInfo(10000.f, nullptr, playerBounds, nullptr);
                player->applyDamage(info);
            }
        }

        if (geom::right(playerBounds) < ctx.cameraLeft) {
            DamageInfo info = buildDamageInfo(10000.f, nullptr, playerBounds, nullptr);
            player->applyDamage(info);
        }
    }

} // namespace

void collision::resolve(const CollisionContext& ctx) {
    resolvePlayerObstacleContactDps(ctx);
    resolveProjectileHits(ctx);
    resolveObstacleTopDps(ctx);
    resolvePlayerCollectibles(ctx);
    resolveHazards(ctx);
}

CollisionContext collision::buildCollisionContext(const World& world, float dt,
                                                  const MultiRectCollider* groundCollider) {
    CollisionContext ctx;
    ctx.dt          = dt;
    ctx.player      = world.m_pPlayer;
    ctx.ground      = groundCollider;
    ctx.cameraView  = &world.m_camera.getView();
    ctx.cameraLeft  = world.getCameraLeft();
    ctx.session     = &world.m_session;
    ctx.environment = &world.m_environment;

    ctx.actors.reserve(world.m_entities.size());
    ctx.enemies.reserve(world.m_entities.size());
    ctx.projectiles.reserve(world.m_entities.size());
    ctx.obstacles.reserve(world.m_entities.size());
    ctx.platforms.reserve(world.m_entities.size());
    ctx.collectibles.reserve(world.m_entities.size());

    for (auto& entity : world.m_entities) {
        if (!entity->isAlive())
            continue;

        switch (entity->getCollisionLayer()) {
        case CollisionLayer::Player:
            ctx.actors.push_back(static_cast<Actor*>(entity.get()));
            break;
        case CollisionLayer::Enemy:
            ctx.actors.push_back(static_cast<Actor*>(entity.get()));
            ctx.enemies.push_back(static_cast<Enemy*>(entity.get()));
            break;
        case CollisionLayer::PlayerProjectile:
        case CollisionLayer::EnemyProjectile:
            ctx.projectiles.push_back(static_cast<Projectile*>(entity.get()));
            break;
        case CollisionLayer::Obstacle:
            ctx.obstacles.push_back(static_cast<Obstacle*>(entity.get()));
            break;
        case CollisionLayer::Platform:
            ctx.platforms.push_back(static_cast<Platform*>(entity.get()));
            break;
        case CollisionLayer::Collectible:
            ctx.collectibles.push_back(static_cast<RedSquare*>(entity.get()));
            break;
        default:
            break;
        }
    }

    return ctx;
}

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/collision/CollisionSystem.cpp =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/collision/CollisionSystem.h =====
#pragma once

#include "collision/MultiRectCollider.h"

#include <SFML/Graphics/View.hpp>
#include <vector>

class Actor;
class Enemy;
class Environment;
class GameSession;
class Obstacle;
class Platform;
class Player;
class Projectile;
class RedSquare;
class World;

struct CollisionContext {
    float dt = 0.f;

    Player* player = nullptr;

    std::vector<Actor*>      actors;
    std::vector<Enemy*>      enemies;
    std::vector<Projectile*> projectiles;
    std::vector<Obstacle*>   obstacles;
    std::vector<Platform*>   platforms;
    std::vector<RedSquare*>  collectibles;

    const MultiRectCollider* ground     = nullptr;
    const sf::View*          cameraView = nullptr;
    float                    cameraLeft = 0.f;

    GameSession*       session     = nullptr;
    const Environment* environment = nullptr;
};

namespace collision {

    // Resolves all gameplay collisions in a frame using the provided context.
    void resolve(const CollisionContext& ctx);

    // Builds a CollisionContext for the given world snapshot.
    CollisionContext buildCollisionContext(const World& world, float dt,
                                           const MultiRectCollider* groundCollider);

} // namespace collision

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/collision/CollisionSystem.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/collision/MultiRectCollider.h =====
#pragma once

#include "collision/Collider.h"

#include <SFML/Graphics/Rect.hpp>
#include <algorithm>
#include <limits>
#include <vector>

// A collider composed of multiple axis-aligned rectangles.
// Used for ground with gaps where a single AABB isn't sufficient.
class MultiRectCollider final : public Collider {
  public:
    MultiRectCollider() = default;

    void setRectColliders(std::vector<sf::FloatRect> rects) { m_rects = std::move(rects); }
    const std::vector<sf::FloatRect>& getRectColliders() const { return m_rects; }

    sf::FloatRect worldAabb() const override {
        if (m_rects.empty())
            return sf::FloatRect{{0.f, 0.f}, {0.f, 0.f}};

        float minX = std::numeric_limits<float>::infinity();
        float minY = std::numeric_limits<float>::infinity();
        float maxX = -std::numeric_limits<float>::infinity();
        float maxY = -std::numeric_limits<float>::infinity();

        for (const auto& r : m_rects) {
            const float l   = r.position.x;
            const float t   = r.position.y;
            const float rgt = r.position.x + r.size.x;
            const float bot = r.position.y + r.size.y;

            minX = std::min(minX, l);
            minY = std::min(minY, t);
            maxX = std::max(maxX, rgt);
            maxY = std::max(maxY, bot);
        }

        const float w = std::max(0.f, maxX - minX);
        const float h = std::max(0.f, maxY - minY);
        return sf::FloatRect{{minX, minY}, {w, h}};
    }

  private:
    std::vector<sf::FloatRect> m_rects;
};

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/collision/MultiRectCollider.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/collision/RectCollider.cpp =====
#include "collision/RectCollider.h"

#include "entities/Entity.h"

#include <SFML/Graphics/Transformable.hpp>
#include <cmath>

sf::FloatRect RectCollider::worldAabb() const {
    const sf::Transformable& sprite = m_entity->getColliderTransformable();
    const sf::Vector2f&      size   = m_entity->getColliderSize();
    const sf::Vector2f&      offset = m_entity->getColliderOffset();

    const sf::Vector2f center = sprite.getTransform().transformPoint(sprite.getOrigin() + offset);

    const sf::Vector2f s = sprite.getScale();
    const sf::Vector2f half{std::abs(s.x) * (size.x * 0.5f), std::abs(s.y) * (size.y * 0.5f)};

    const sf::Vector2f pos  = {center.x - half.x, center.y - half.y};
    const sf::Vector2f dims = {half.x * 2.f, half.y * 2.f};

    return sf::FloatRect(pos, dims);
}

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/collision/RectCollider.cpp =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/collision/RectCollider.h =====
#pragma once

#include "collision/Collider.h"

class Entity;

class RectCollider final : public Collider {
  public:
    explicit RectCollider(const Entity& entity) : m_entity(&entity) {}

    sf::FloatRect worldAabb() const override;

  private:
    const Entity* m_entity = nullptr;
};
===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/collision/RectCollider.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/core/Application.cpp =====
#include "core/Application.h"

#include "states/IState.h"
#include "states/StateMenu.h"

#include <SFML/System/Clock.hpp>
#include <optional>

Application::Application()
    : m_window(sf::VideoMode({Config::windowWidth, Config::windowHeight}), Config::windowTitle),
      m_states() {
    m_window.setKeyRepeatEnabled(false);
    m_window.setVerticalSyncEnabled(true);

    m_states.push<StateMenu>(m_window);
}

int Application::run() {
    sf::Clock clock;

    while (m_window.isOpen()) {
        const float dt = clock.restart().asSeconds();
        processEvents();
        update(dt);
        render();
        m_states.performPendingPops();
    }
    return 0;
}

void Application::processEvents() {
    IState* state = m_states.getCurrentState();
    while (const std::optional<sf::Event> event = m_window.pollEvent()) {
        if (event->is<sf::Event::Closed>()) {
            m_window.close();
        }
        if (state) {
            state->handleEvent(*event);
        }
    }
}

void Application::update(float dt) {
    if (IState* state = m_states.getCurrentState()) {
        state->update(dt);
    } else {
        m_window.close();
    }
}

void Application::render() {
    m_window.clear();
    if (IState* state = m_states.getCurrentState()) {
        state->render(m_window);
    }
    m_window.display();
}

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/core/Application.cpp =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/core/Application.h =====
#pragma once

#include "core/Config.h"
#include "states/StateStack.h"

#include <SFML/Graphics/RenderWindow.hpp>

class Application {
  public:
    Application();
    int run();

  private:
    void processEvents();
    void update(float dt);
    void render();

    sf::RenderWindow m_window;
    StateStack       m_states;
};

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/core/Application.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/core/Assets.h =====
#pragma once

#include <string_view>

namespace Assets {

    namespace Font {
        inline constexpr std::string_view Lavigne = "font/Lavigne.ttf";
    } // namespace Font

    namespace Tex {

        namespace Player {
            inline constexpr std::string_view Idle  = "image/player/idle.png";
            inline constexpr std::string_view Move  = "image/player/move.png";
            inline constexpr std::string_view Jump  = "image/player/jump.png";
            inline constexpr std::string_view Fall  = "image/player/fall.png";
            inline constexpr std::string_view Dash  = "image/player/dash.png";
            inline constexpr std::string_view Hit   = "image/player/hit.png";
            inline constexpr std::string_view Cast  = "image/player/cast.png";
            inline constexpr std::string_view Death = "image/player/death.png";
        } // namespace Player

        namespace Enemy {
            namespace Demon {
                inline constexpr std::string_view Fly   = "image/enemies/demon/fly.png";
                inline constexpr std::string_view Hit   = "image/enemies/demon/hit.png";
                inline constexpr std::string_view Death = "image/enemies/demon/death.png";
            } // namespace Demon

            namespace FireWorm {
                inline constexpr std::string_view Move   = "image/enemies/fireWorm/move.png";
                inline constexpr std::string_view Idle   = "image/enemies/fireWorm/idle.png";
                inline constexpr std::string_view Attack = "image/enemies/fireWorm/attack.png";
                inline constexpr std::string_view Hit    = "image/enemies/fireWorm/hit.png";
                inline constexpr std::string_view Death  = "image/enemies/fireWorm/death.png";
            } // namespace FireWorm
        } // namespace Enemy

        namespace Environment {
            namespace Ground {
                inline constexpr std::string_view Lava = "image/environment/ground/lava.png";
            } // namespace Ground

            namespace Parallax {
                namespace VolcanoDay {
                    inline constexpr std::string_view Layer01 =
                        "image/environment/parallax/volcano-day/layer_01.png";
                    inline constexpr std::string_view Layer02 =
                        "image/environment/parallax/volcano-day/layer_02.png";
                    inline constexpr std::string_view Layer03 =
                        "image/environment/parallax/volcano-day/layer_03.png";
                    inline constexpr std::string_view Layer04 =
                        "image/environment/parallax/volcano-day/layer_04.png";
                    inline constexpr std::string_view Layer05 =
                        "image/environment/parallax/volcano-day/layer_05.png";
                    inline constexpr std::string_view Layer06 =
                        "image/environment/parallax/volcano-day/layer_06.png";
                    inline constexpr std::string_view Layer07 =
                        "image/environment/parallax/volcano-day/layer_07.png";
                    inline constexpr std::string_view Layer08 =
                        "image/environment/parallax/volcano-day/layer_08.png";
                    inline constexpr std::string_view Bg01 =
                        "image/environment/parallax/volcano-day/bg_01.png";
                    inline constexpr std::string_view Bg02 =
                        "image/environment/parallax/volcano-day/bg_02.png";
                    inline constexpr std::string_view Bg03 =
                        "image/environment/parallax/volcano-day/bg_03.png";
                } // namespace VolcanoDay
            } // namespace Parallax
        } // namespace Environment

        namespace Obstacle {
            inline constexpr std::string_view Altar1    = "image/obstacles/altar1.png";
            inline constexpr std::string_view Altar2    = "image/obstacles/altar2.png";
            inline constexpr std::string_view Tree      = "image/obstacles/tree.png";
            inline constexpr std::string_view Lich      = "image/obstacles/lich.png";
            inline constexpr std::string_view SkullPile = "image/obstacles/skull_pile.png";
        } // namespace Obstacle

        namespace Platform {
            inline constexpr std::string_view Rock1 = "image/platform/rock_01.png";
            inline constexpr std::string_view Rock2 = "image/platform/rock_02.png";
        } // namespace Platform

        namespace Spell {
            namespace Icebolt {
                inline constexpr std::string_view Start = "image/spells/icebolt/start.png";
                inline constexpr std::string_view Loop  = "image/spells/icebolt/loop.png";
                inline constexpr std::string_view Hit   = "image/spells/icebolt/hit.png";
            } // namespace Icebolt
            namespace Lightning {
                inline constexpr std::string_view Start = "image/spells/lightning/start.png";
                inline constexpr std::string_view Loop  = "image/spells/lightning/loop.png";
                inline constexpr std::string_view Hit   = "image/spells/lightning/hit.png";
            } // namespace Lightning
        } // namespace Spell

        namespace Shader {
            inline constexpr std::string_view Flash = "shader/flash.frag";
        } // namespace Shader

    } // namespace Tex

} // namespace Assets

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/core/Assets.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/core/Camera.cpp =====
#include "core/Camera.h"

#include "entities/actor/player/Player.h"
#include "utils/Math.h"

#include <algorithm>

Camera::Camera(const sf::Vector2f& viewSize) {
    m_view.setSize(viewSize);
    m_view.setCenter({viewSize.x * 0.5f, viewSize.y * 0.5f});

    m_cameraX       = m_view.getCenter().x;
    m_cameraTargetX = m_cameraX;
    m_cameraSpeed   = 0.f; // ease-in
}

void Camera::update(float dt, const Player* player) {
    // Auto-scroll baseline (advance target; center eases toward it)
    if (m_cameraSpeed < m_cameraTargetSpeed) {
        m_cameraSpeed = std::min(m_cameraTargetSpeed, m_cameraSpeed + kCameraAccel * dt);
    } else if (m_cameraSpeed > m_cameraTargetSpeed) {
        m_cameraSpeed = std::max(m_cameraTargetSpeed, m_cameraSpeed - kCameraAccel * dt);
    }
    m_cameraTargetX += m_cameraSpeed * dt;

    // If player passes the follow threshold, let the target drift toward player smoothly.
    if (player && player->isAlive()) {
        const float playerX         = player->getPosition().x;
        const float followThreshold = followThresholdX();
        if (playerX > followThreshold) {
            const float alphaT    = math::expSmoothingFactor(kTargetCatchupLerp, dt);
            const float desired   = playerX; // player centered
            const float newTarget = m_cameraTargetX + (desired - m_cameraTargetX) * alphaT;
            m_cameraTargetX       = std::max(m_cameraTargetX, newTarget);
        }
    }

    // Ease camera center toward target
    const float alpha = math::expSmoothingFactor(kCatchupLerp, dt);
    m_cameraX += (m_cameraTargetX - m_cameraX) * alpha;
    m_view.setCenter({m_cameraX, m_view.getSize().y * 0.5f});
}

void Camera::apply(sf::RenderTarget& target) const { target.setView(m_view); }

float Camera::left() const { return m_view.getCenter().x - 0.5f * m_view.getSize().x; }

float Camera::right(float widthMultiplier) const {
    return left() + m_view.getSize().x * widthMultiplier;
}

float Camera::bottom() const { return m_view.getCenter().y + 0.5f * m_view.getSize().y; }

float Camera::catchupX() const { return left() + kCatchupMarginLeft; }

float Camera::followThresholdX() const {
    return left() + kFollowThresholdRatio * m_view.getSize().x;
}

sf::Vector2f Camera::mapPixelToWorld(const sf::RenderWindow& window,
                                     const sf::Vector2i&     pixel) const {
    return window.mapPixelToCoords(pixel, m_view);
}

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/core/Camera.cpp =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/core/Camera.h =====
#pragma once

#include <SFML/Graphics/RenderTarget.hpp>
#include <SFML/Graphics/RenderWindow.hpp>
#include <SFML/Graphics/View.hpp>
#include <SFML/System/Vector2.hpp>

class Player;

// Camera owns the sf::View and encapsulates scrolling / follow logic.
class Camera {
  public:
    explicit Camera(const sf::Vector2f& viewSize);
    Camera() = default;

    void update(float dt, const Player* player);

    void            apply(sf::RenderTarget& target) const;
    const sf::View& getView() const { return m_view; }

    float left() const;
    float bottom() const;
    float catchupX() const;
    float followThresholdX() const;
    float right(float widthMultiplier = 2.f) const;

    sf::Vector2f mapPixelToWorld(const sf::RenderWindow& window, const sf::Vector2i& pixel) const;

  private:
    sf::View m_view;

    float m_cameraX           = 0.f;
    float m_cameraTargetX     = 0.f; // smoothed target center X
    float m_cameraSpeed       = 0.f;
    float m_cameraTargetSpeed = 490.f; // playerMaxSpeed = 500.f

    static constexpr float kCameraAccel          = 1200.f;
    static constexpr float kCatchupMarginLeft    = 60.f;
    static constexpr float kFollowThresholdRatio = 0.80f; // 80% from left
    static constexpr float kCatchupLerp          = 8.f;   // view center smoothing
    static constexpr float kTargetCatchupLerp    = 2.5f;  // target center smoothing
};

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/core/Camera.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/core/Config.h =====
#pragma once

namespace sf {
    class RenderWindow;
}

namespace Config {
    inline constexpr int  windowWidth   = 1500;
    inline constexpr int  windowHeight  = 900;
    inline constexpr char windowTitle[] = "SFML Game";
    inline constexpr bool kDebugDraw    = true;
} // namespace Config

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/core/Config.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/core/Debug.h =====
#pragma once

#include "collision/Collider.h"
#include "physics/StaticWorldGeometry.h"
#include "utils/Palette.h"

#include <SFML/Graphics/Color.hpp>
#include <SFML/Graphics/RectangleShape.hpp>
#include <SFML/Graphics/RenderTarget.hpp>
#include <SFML/Graphics/Sprite.hpp>

namespace Debug {
    inline void drawRectOutline(sf::RenderTarget& target, const sf::FloatRect& rect,
                                const sf::Color& color, float thickness = 1.f) {
        sf::RectangleShape outline;
        outline.setPosition(rect.position);
        outline.setSize(rect.size);
        outline.setFillColor(sf::Color(0, 0, 0, 0));
        outline.setOutlineColor(color);
        outline.setOutlineThickness(thickness);
        target.draw(outline);
    }

    inline void drawSpriteBounds(sf::RenderTarget& target, const sf::Sprite& sprite,
                                 const sf::Color& color, float thickness = 1.f) {
        const sf::FloatRect bounds = sprite.getGlobalBounds();

        drawRectOutline(target, bounds, color, thickness);
    }

    inline void drawSpriteOrigin(sf::RenderTarget& target, const sf::Sprite& sprite,
                                 const sf::Color& color, float size = 10.f, float thickness = 2.f) {
        const sf::Vector2f originPos = sprite.getTransform().transformPoint(sprite.getOrigin());

        sf::RectangleShape crosshairH;
        crosshairH.setPosition({originPos.x - size * 0.5f, originPos.y - thickness * 0.5f});
        crosshairH.setSize({size, thickness});
        crosshairH.setFillColor(color);
        target.draw(crosshairH);

        sf::RectangleShape crosshairV;
        crosshairV.setPosition({originPos.x - thickness * 0.5f, originPos.y - size * 0.5f});
        crosshairV.setSize({thickness, size});
        crosshairV.setFillColor(color);
        target.draw(crosshairV);
    }

    inline void drawColliderBounds(sf::RenderTarget& target, const Collider& collider,
                                   const sf::Color& color, float thickness = 1.f) {
        const sf::FloatRect bounds = collider.worldAabb();

        drawRectOutline(target, bounds, color, thickness);
    }

    inline void drawVerticalGuide(sf::RenderTarget& target, const sf::View& view, float x,
                                  const sf::Color& color, float thickness = 3.f) {
        const float        bottomY = 0.f;
        const float        height  = view.getSize().y;
        sf::RectangleShape line({thickness, height});
        line.setPosition({x - thickness * 0.5f, bottomY});
        line.setFillColor(color);
        target.draw(line);
    }

    inline void drawCameraGuides(sf::RenderTarget& target, const sf::View& view, float catchupX,
                                 float followX) {
        drawVerticalGuide(target, view, catchupX, sf::Color::Cyan);
        drawVerticalGuide(target, view, followX, sf::Color::Yellow);
    }

    // Draws vertical bands across the camera view using a caller-provided sampler.
    // The sampler must be invocable as sampler(xCenter, width) and return an object
    // with bool hasSolid and bool hasHazard fields (e.g. GroundSample from WorldGroundSample.h).
    template <typename Sampler>
    inline void drawGroundSampleBands(sf::RenderTarget& target, const sf::View& view,
                                      Sampler&& sampler, float step = 96.f) {
        const sf::Vector2f viewSize   = view.getSize();
        const sf::Vector2f viewCenter = view.getCenter();
        const float        viewLeft   = viewCenter.x - 0.5f * viewSize.x;
        const float        viewTop    = viewCenter.y - 0.5f * viewSize.y;
        const float        viewRight  = viewLeft + viewSize.x;

        for (float x = viewLeft; x < viewRight; x += step) {
            const auto sample = sampler(x, step);

            sf::FloatRect band{{x - step * 0.5f, viewTop}, {step, viewSize.y}};

            sf::Color color;
            if (!sample.hasSolid)
                color = sf::Color::Red; // red: no solid
            else if (sample.hasHazard)
                color = sf::Color::Yellow; // yellow: hazard
            else
                color = sf::Color::Green; // green: safe

            drawRectOutline(target, band, color, 1.f);
        }
    }

    inline void drawStaticWorldGeometry(sf::RenderTarget&          target,
                                        const StaticWorldGeometry& geometry) {
        for (const StaticSolid& solid : geometry.solids) {
            sf::Color color;

            if (hasSide(solid.sides, StaticSolidSide::SolidSide_Top)) {
                // Top surfaces: distinguish by kind.
                switch (solid.kind) {
                case StaticSolidKind::GroundBand:
                    color = Palette::kDebugStaticGroundTop;
                    break;
                case StaticSolidKind::Platform:
                    color = Palette::kDebugStaticPlatformTop;
                    break;
                case StaticSolidKind::Obstacle:
                    color = Palette::kDebugStaticObstacleTop;
                    break;
                }
            } else if (hasSide(solid.sides, StaticSolidSide::SolidSide_Left) ||
                       hasSide(solid.sides, StaticSolidSide::SolidSide_Right)) {
                // Walls: use a distinct color to highlight vertical blockers.
                switch (solid.kind) {
                case StaticSolidKind::GroundBand:
                    color = Palette::kDebugStaticGroundWall;
                    break;
                case StaticSolidKind::Platform:
                    color = Palette::kDebugStaticPlatformWall;
                    break;
                case StaticSolidKind::Obstacle:
                    color = Palette::kDebugStaticObstacleWall;
                    break;
                }
            } else {
                continue;
            }

            drawRectOutline(target, solid.rect, color, 1.f);
        }
    }
} // namespace Debug

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/core/Debug.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/core/ResourceManager.cpp =====
#include "core/ResourceManager.h"

#include <algorithm>
#include <iostream>
#include <stdexcept>

void ResourceManager::init(std::string executablePath) {
    std::replace(executablePath.begin(), executablePath.end(), '\\', '/');
    size_t lastSlashIndex = executablePath.find_last_of('/');
    if (lastSlashIndex != std::string::npos)
        m_assetPath = executablePath.substr(0, lastSlashIndex + 1);
    m_assetPath += "assets/";
}

const sf::Font& ResourceManager::getFont(std::string_view filename) {
    const std::string key(filename);

    if (auto it = m_loadedFonts.find(key); it != m_loadedFonts.end())
        return it->second;

    auto [it, inserted] = m_loadedFonts.emplace(key, sf::Font{});
    if (!inserted) {
        throw std::runtime_error("ResourceManager::getFont: failed to emplace font entry for '" +
                                 key + "'");
    }

    sf::Font&  font     = it->second;
    const auto fullPath = getAssetPath(key);
    if (!font.openFromFile(fullPath)) {
        throw std::runtime_error("ResourceManager::getFont: could not load font from '" + key +
                                 "' at '" + fullPath.string() + "'");
    }

    return font;
}

sf::Texture& ResourceManager::getTexture(std::string_view filename) {
    const std::string key(filename);

    if (auto it = m_loadedTextures.find(key); it != m_loadedTextures.end())
        return it->second;

    auto [it, inserted] = m_loadedTextures.emplace(key, sf::Texture{});
    if (!inserted) {
        throw std::runtime_error(
            "ResourceManager::getTexture: failed to emplace texture entry for '" + key + "'");
    }

    sf::Texture& texture  = it->second;
    const auto   fullPath = getAssetPath(key);
    if (!texture.loadFromFile(fullPath)) {
        throw std::runtime_error("ResourceManager::getTexture: could not load texture from '" +
                                 key + "' at '" + fullPath.string() + "'");
    }

    return texture;
}

sf::Texture& ResourceManager::getRepeatedTexture(std::string_view filename) {
    sf::Texture& texture = getTexture(filename);

    if (texture.isRepeated())
        return texture;

    texture.setRepeated(true);
    return texture;
}

const sf::SoundBuffer& ResourceManager::getSoundBuffer(std::string_view filename) {
    const std::string key(filename);

    if (auto it = m_loadedSoundBuffers.find(key); it != m_loadedSoundBuffers.end())
        return it->second;

    auto [it, inserted] = m_loadedSoundBuffers.emplace(key, sf::SoundBuffer{});
    if (!inserted) {
        throw std::runtime_error(
            "ResourceManager::getSoundBuffer: failed to emplace sound buffer entry for '" + key +
            "'");
    }

    sf::SoundBuffer& buffer   = it->second;
    const auto       fullPath = getAssetPath(key);
    if (!buffer.loadFromFile(fullPath)) {
        throw std::runtime_error(
            "ResourceManager::getSoundBuffer: could not load sound buffer from '" + key + "' at '" +
            fullPath.string() + "'");
    }

    return buffer;
}

std::filesystem::path ResourceManager::getAssetPath(std::string_view filename) {
    return std::filesystem::path(m_assetPath) / std::string(filename);
}

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/core/ResourceManager.cpp =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/core/ResourceManager.h =====
#pragma once

#include <SFML/Audio/SoundBuffer.hpp>
#include <SFML/Graphics/Font.hpp>
#include <SFML/Graphics/Shader.hpp>
#include <SFML/Graphics/Texture.hpp>
#include <filesystem>
#include <string>
#include <string_view>
#include <unordered_map>

class ResourceManager {
  public:
    static void                   init(std::string executablePath);
    static const sf::Font&        getFont(std::string_view filename);
    static sf::Texture&           getTexture(std::string_view filename);
    static sf::Texture&           getRepeatedTexture(std::string_view filename);
    static const sf::SoundBuffer& getSoundBuffer(std::string_view filename);

  private:
    static inline std::string                                      m_assetPath;
    static inline std::unordered_map<std::string, sf::Font>        m_loadedFonts;
    static inline std::unordered_map<std::string, sf::Texture>     m_loadedTextures;
    static inline std::unordered_map<std::string, sf::SoundBuffer> m_loadedSoundBuffers;

    static std::filesystem::path getAssetPath(std::string_view filename);
};

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/core/ResourceManager.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/core/World.cpp =====
#include "core/World.h"

#include "collision/CollisionLayers.h"
#include "collision/CollisionSystem.h"
#include "collision/MultiRectCollider.h"
#include "core/Config.h"
#include "core/Debug.h"
#include "entities/actor/Actor.h"
#include "entities/actor/enemy/Demon.h"
#include "entities/actor/enemy/Enemy.h"
#include "entities/actor/enemy/FireWorm.h"
#include "entities/actor/player/Player.h"
#include "entities/collectible/RedSquare.h"
#include "entities/obstacle/Obstacle.h"
#include "entities/obstacle/ObstacleFactory.h"
#include "entities/obstacle/ObstacleTypes.h"
#include "entities/platform/Platform.h"
#include "entities/platform/PlatformFactory.h"
#include "physics/StaticWorldGeometryBuilder.h"
#include "spell/projectile/Projectile.h"
#include "states/StatePlaying.h"
#include "utils/Geom.h"
#include "utils/Random.h"

#include <SFML/Graphics/RenderTarget.hpp>
#include <SFML/Graphics/RenderWindow.hpp>
#include <SFML/Window/Mouse.hpp>
#include <algorithm>
#include <memory>
#include <vector>

World::World(StatePlaying& owner, GameSession& session, sf::RenderWindow& window)
    : m_owner(owner), m_session(session), m_window(window) {}

World::~World() = default;

bool World::init() {
    // Initialize camera with window size
    const sf::Vector2f viewSize{static_cast<float>(Config::windowWidth),
                                static_cast<float>(Config::windowHeight)};
    m_camera = Camera(viewSize);

    // Initialize environment
    if (!m_environment.initVolcanoDay())
        return false;
    m_environment.update(0.f, m_camera.getView());

    // Create player entity
    m_pPlayer = createEntity<Player>();
    if (!m_pPlayer || !m_pPlayer->init())
        return false;
    m_pPlayer->setPosition(sf::Vector2f(Config::windowWidth * 0.5f, Config::windowHeight * 0.5f));

    // Seed RNG and schedule first obstacle spawn a bit ahead of view
    // Random::seed(Random::timeSeed()); // uncomment for non-deterministic runs

    // Schedule first obstacle and platform
    const float viewRight = getCameraRight();
    m_nextObstacleX       = viewRight + Random::rangef(880.f, 1680.f);
    m_nextPlatformX       = viewRight + Random::rangef(680.f, 980.f);

    return true;
}

void World::update(float dt) {
    // Update all entities
    for (std::size_t i = 0; i < m_entities.size(); ++i) {
        Entity* e = m_entities[i].get();
        if (e && e->isAlive())
            e->update(dt);
    }

    // Update camera
    m_camera.update(dt, (m_pPlayer && m_pPlayer->isAlive()) ? m_pPlayer : nullptr);

    // Update environment and build ground collider
    m_environment.update(dt, m_camera.getView());
    const MultiRectCollider* groundCollider = m_environment.getGroundCollider();

    // Build combined static geometry for physics (ground + obstacles + platforms).
    updateStaticWorldGeometry(groundCollider);

    // Step physics. At this stage, bodies may or may not be registered yet;
    // wiring happens in the actors that opt into physics.
    m_physics.step(dt, &m_staticWorld);

    // Resolve collisions
    auto collisionCtx = collision::buildCollisionContext(*this, dt, groundCollider);
    collision::resolve(collisionCtx);

    {
        // TO-DO build enemy spawn system
        // Timed Demon spawns: every 10 seconds at y=400, just off the right edge of the view
        m_demonSpawnTimer -= dt;
        if (m_demonSpawnTimer <= 0.f) {
            m_demonSpawnTimer += 10.f;
            const float leftX  = getCameraLeft() - 60.f;
            const float demonY = 400.f;

            if (auto* demon = createEntity<Demon>()) {
                if (demon->init()) {
                    demon->setPosition({leftX, demonY});
                    demon->update(0.f);
                }
            }

            // Spawn FireWorm aligned to safe ground if available at this X;
            const float  rightX     = getCameraRight() + 60.f;
            GroundSample wormSample = sampleGround(rightX, 64.f);
            if (wormSample.isSafe()) {
                if (auto* worm = createEntity<FireWorm>()) {
                    if (worm->init()) {

                        worm->setPosition({rightX, wormSample.topY});
                        const sf::FloatRect aabb   = worm->getCollider().worldAabb();
                        const float         bottom = aabb.position.y + aabb.size.y;
                        auto                pos    = worm->getPosition();
                        pos.y += wormSample.topY - bottom;
                        worm->setPosition(pos);

                        worm->update(0.f);
                    }
                }
            }
        }
    }

    // TO-DO build level generation system
    // Stream simple random obstacles ahead of camera
    {
        const float viewRight = m_camera.right();
        if (groundCollider) {
            while (viewRight + 50.f >= m_nextObstacleX) {
                const int   kindIdx = Random::rangei(0, static_cast<int>(ObstacleKind::Count) - 1);
                const auto  kind    = static_cast<ObstacleKind>(kindIdx);
                const auto& desc    = getObstacleDesc(kind);
                const float x       = m_nextObstacleX;

                GroundSample sample = sampleGround(x, desc.colliderSize.x);
                if (sample.isSafe()) {
                    const float y = sample.topY - desc.colliderSize.y;
                    spawnObstacle(*this, kind, {x, y});
                }

                m_nextObstacleX += Random::rangef(680.f, 1280.f);
            }
        }
    }
    // Stream simple random platforms ahead of camera
    {
        const float viewRight = m_camera.right();
        if (groundCollider) {
            const float groundTop = m_environment.getGroundTopY(m_camera.getView());
            while (viewRight + 50.f >= m_nextPlatformX) {
                const int   kindIdx = Random::rangei(0, static_cast<int>(PlatformKind::Count) - 1);
                const auto  kind    = static_cast<PlatformKind>(kindIdx);
                const auto& desc    = getPlatformDesc(kind);
                const float y = groundTop - desc.colliderSize.y - Random::rangef(100.f, 300.f);
                const float x = m_nextPlatformX;
                if (auto* p = spawnPlatform(*this, kind, {x, y})) {
                    // Spawn a red square 10px above the platform top, centered horizontally
                    const sf::FloatRect pb  = p->getCollider().worldAabb();
                    const float         top = pb.position.y;
                    const float         cx  = pb.position.x + pb.size.x * 0.5f;
                    const float         cy  = top - 10.f - (RedSquare::kSize * 0.5f);
                    if (auto* sq = createEntity<RedSquare>(sf::Vector2f{cx, cy}))
                        (void)sq->init();
                }
                m_nextPlatformX += Random::rangef(480.f, 880.f);
            }
        }
    }

    // Lifetime culling, mark obstacles, platforms, collectibles dead if offscreen
    cullOffscreen();

    // Remove dead entities and unregister any physics bodies they owned.
    m_entities.erase(std::remove_if(m_entities.begin(), m_entities.end(),
                                    [this](const auto& e) {
                                        if (!e->isAlive()) {
                                            m_physics.unregisterBody(*e);
                                            return true;
                                        }
                                        return false;
                                    }),
                     m_entities.end());
}

void World::render(sf::RenderTarget& target) const {
    const sf::View oldView = target.getView();
    m_camera.apply(target);

    m_environment.renderBackground(target, m_camera.getView());

    for (const std::unique_ptr<Entity>& pEntity : m_entities) {
        if (dynamic_cast<Actor*>(pEntity.get()))
            pEntity->render(target);
    }

    m_environment.renderForeground(target, m_camera.getView());

    for (const std::unique_ptr<Entity>& pEntity : m_entities) {
        if (!dynamic_cast<Actor*>(pEntity.get()))
            pEntity->render(target);
    }

    // Debug helpers
    if constexpr (Config::kDebugDraw) {
        Debug::drawCameraGuides(target, m_camera.getView(), getCameraCatchupX(),
                                getFollowThresholdX());

        if (const MultiRectCollider* ground = m_environment.getGroundCollider()) {
            const auto& rects = ground->getRectColliders();
            for (const auto& rect : rects) {
                Debug::drawRectOutline(target, rect, Palette::kDebugStaticGroundTop, 1.f);
            }
        }

        Debug::drawStaticWorldGeometry(target, m_staticWorld);

        Debug::drawGroundSampleBands(
            target, m_camera.getView(),
            [&env = m_environment, view = m_camera.getView()](float x, float w) {
                return sampleGroundFromEnvironment(env, view, x, w);
            });
    }

    target.setView(oldView);
}

float World::getCameraLeft() const { return m_camera.left(); }

float World::getCameraRight() const { return m_camera.right(); }

float World::getCameraCatchupX() const { return m_camera.catchupX(); }

float World::getFollowThresholdX() const { return m_camera.followThresholdX(); }

sf::Vector2f World::getMouseWorld() const {
    const sf::Vector2i pixel = sf::Mouse::getPosition(m_window);
    return m_camera.mapPixelToWorld(m_window, pixel);
}

GroundSample World::sampleGround(float x, float width) const {
    return sampleGroundFromEnvironment(m_environment, m_camera.getView(), x, width);
}

float World::getGroundTopYAt(float x) const {
    sf::View probeView = m_camera.getView();
    probeView.setCenter({x, probeView.getCenter().y});
    return m_environment.getGroundTopY(probeView);
}

bool World::canSpawnOnGroundAt(float x, float width) const {
    const GroundSample sample = sampleGround(x, width);
    return sample.isSafe();
}

void World::addScore(int points) { m_session.addScore(points); }

void World::requestExitToMenu() { m_owner.requestExitToMenu(); }

void World::cullOffscreen() {
    const float viewLeft   = getCameraLeft();
    const float cullBefore = viewLeft - m_camera.getView().getSize().x;

    for (auto& entity : m_entities) {
        if (!entity->isAlive())
            continue;

        const CollisionLayer layer = entity->getCollisionLayer();
        if (layer != CollisionLayer::Obstacle && layer != CollisionLayer::Platform &&
            layer != CollisionLayer::Collectible)
            continue;

        const sf::FloatRect aabb  = entity->getCollider().worldAabb();
        const float         right = aabb.position.x + aabb.size.x;
        if (right < cullBefore)
            entity->setAlive(false);
    }
}

void World::updateStaticWorldGeometry(const MultiRectCollider* groundCollider) {
    m_staticWorld = physics::buildStaticWorldGeometry(groundCollider, m_entities);
}

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/core/World.cpp =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/core/World.h =====
#pragma once

#include "collision/CollisionSystem.h"
#include "core/Camera.h"
#include "core/WorldGroundSample.h"
#include "environment/Environment.h"
#include "gameplay/GameSession.h"
#include "physics/PhysicsSystem.h"
#include "physics/StaticWorldGeometry.h"

#include <SFML/Graphics/Rect.hpp>
#include <SFML/System/Vector2.hpp>
#include <memory>
#include <vector>

class Entity;
class GameSession;
class Player;
class StatePlaying;

namespace sf {
    class RenderTarget;
    class RenderWindow;
} // namespace sf

class World {
  public:
    World(StatePlaying& owner, GameSession& session, sf::RenderWindow& window);
    ~World();

    bool init();
    void update(float dt);
    void render(sf::RenderTarget& target) const;

    Player* getPlayer() const { return m_pPlayer; }

    float getCameraLeft() const;
    float getCameraRight() const;
    float getCameraCatchupX() const;
    float getFollowThresholdX() const;
    float getViewBottomY() const { return m_camera.bottom(); }

    sf::Vector2f getMouseWorld() const;

    void addScore(int points);
    void requestExitToMenu();

    // Samples ground and hazard state under a horizontal band centered at x.
    // width == 0 => a small default width is used.
    GroundSample sampleGround(float x, float width) const;

    // Top Y of the environment ground band at a given X, ignoring hazards/gaps.
    float getGroundTopYAt(float x) const;

    // Convenience helper for spawn logic that only cares about "can I safely stand here?"
    bool canSpawnOnGroundAt(float x, float width = 0.f) const;

    PhysicsSystem&       getPhysics() { return m_physics; }
    const PhysicsSystem& getPhysics() const { return m_physics; }

    template <typename T, typename... Args> T* createEntity(Args&&... args) {
        auto entity    = std::make_unique<T>(std::forward<Args>(args)...);
        T*   entityPtr = entity.get();
        entityPtr->setWorld(this);
        m_entities.push_back(std::move(entity));
        return entityPtr;
    }

  private:
    StatePlaying&     m_owner;
    GameSession&      m_session;
    sf::RenderWindow& m_window;

    Player* m_pPlayer = nullptr;

    std::vector<std::unique_ptr<Entity>> m_entities;

    Environment m_environment;

    float m_nextObstacleX = 0.f;
    float m_nextPlatformX = 0.f;

    Camera m_camera;

    // Combined static geometry used by the physics system (ground + obstacles + platforms).
    StaticWorldGeometry m_staticWorld;

    PhysicsSystem m_physics;

    float m_demonSpawnTimer = 10.f; // spawn a demon every 10 seconds

    friend CollisionContext
    collision::buildCollisionContext(const World& world, float dt,
                                     const MultiRectCollider* groundCollider);

    void cullOffscreen();

    void updateStaticWorldGeometry(const MultiRectCollider* groundCollider);
};

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/core/World.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/core/WorldGroundSample.h =====
#pragma once

#include "environment/Environment.h"

#include <SFML/Graphics/Rect.hpp>
#include <SFML/Graphics/View.hpp>

// Query result when sampling ground / hazards under a horizontal band.
struct GroundSample {
    // True when there is any supporting solid (e.g., ground band) under the sampled band.
    bool hasSolid = false;

    // True when the environment hazard (lava / gap) intersects the sampled band.
    bool hasHazard = false;

    // Top Y of the main ground we want to stand on when hasSolid == true.
    float topY = 0.f;

    bool isSafe() const { return hasSolid && !hasHazard; }
};

// Stateless helper that samples ground + hazards for a given environment/view.
inline GroundSample sampleGroundFromEnvironment(const Environment& environment,
                                                const sf::View& referenceView, float xCenter,
                                                float bandWidth) {
    GroundSample sample{};

    sf::View probeView = referenceView;
    probeView.setCenter({xCenter, referenceView.getCenter().y});

    const sf::Vector2f viewSize   = probeView.getSize();
    const sf::Vector2f viewCenter = probeView.getCenter();
    const float        top        = viewCenter.y - 0.5f * viewSize.y;
    const float        bottom     = viewCenter.y + 0.5f * viewSize.y;

    if (bandWidth <= 0.f)
        bandWidth = 32.f;
    const float halfW = bandWidth * 0.5f;

    const sf::FloatRect column{{xCenter - halfW, top}, {bandWidth, bottom - top}};

    sample.hasHazard = environment.intersectsHazard(column, probeView);
    if (sample.hasHazard)
        return sample;

    const float groundTop = environment.getGroundTopY(probeView);
    sample.hasSolid       = true;
    sample.topY           = groundTop;

    return sample;
}

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/core/WorldGroundSample.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/core/main.cpp =====
#include "core/Application.h"
#include "core/ResourceManager.h"

#include <iostream>

int main(int argc, char* argv[]) try {
    (void)argc;

    // ResourceManager must be instantiated here -- DO NOT CHANGE
    ResourceManager::init(argv[0]);

    Application app;
    return app.run();

} catch (const std::exception& e) {
    std::cerr << "Fatal error: " << e.what() << std::endl;
    return EXIT_FAILURE;
} catch (...) {
    std::cerr << "Fatal error: unknown exception occurred" << std::endl;
    return EXIT_FAILURE;
}

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/core/main.cpp =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/entities/Entity.h =====
#pragma once

#include "animation/Animation.h"
#include "collision/CollisionLayers.h"
#include "collision/RectCollider.h"

#include <SFML/Graphics/Sprite.hpp>
#include <SFML/System/Vector2.hpp>
#include <cmath>
#include <memory>

class World;

namespace sf {
    class RenderTarget;
};

class Entity {
  public:
    Entity() : m_collider(*this) {}
    virtual ~Entity() = default;

    virtual bool init()                                 = 0;
    virtual void update(float dt)                       = 0;
    virtual void render(sf::RenderTarget& target) const = 0;

    bool isAlive() const { return m_alive; }
    void setAlive(bool alive) { m_alive = alive; }

    const sf::Vector2f& getPosition() const { return m_position; }
    void                setPosition(const sf::Vector2f& position) {
        m_position = position;
        if (m_pSprite)
            m_pSprite->setPosition(m_position);
    }

    // back-reference to owning world
    void   setWorld(World* world) { m_world = world; }
    World* getWorld() const { return m_world; }

    // Collision helper
    const sf::Transformable& getColliderTransformable() const { return *m_pSprite; }
    const sf::Vector2f&      getColliderSize() const { return m_colliderSize; }
    const sf::Vector2f&      getColliderOffset() const { return m_colliderOffset; }
    void                     setColliderSize(const sf::Vector2f& size) { m_colliderSize = size; }
    void setColliderOffset(const sf::Vector2f& offset) { m_colliderOffset = offset; }

    CollisionLayer getCollisionLayer() const { return m_collisionLayer; }
    void           setCollisionLayer(CollisionLayer layer) { m_collisionLayer = layer; }
    CollisionMask  getCollisionMask() const { return m_collisionMask; }
    void           setCollisionMask(CollisionMask mask) { m_collisionMask = mask; }

    const RectCollider& getCollider() const { return m_collider; }

    // Physics
    const sf::Vector2f& getVelocity() const { return m_velocity; }
    void                setVelocity(const sf::Vector2f& v) { m_velocity = v; }

  protected:
    // State
    bool m_alive = true;

    // Render
    std::unique_ptr<sf::Sprite> m_pSprite;
    sf::Vector2f                m_spriteScale{1.f, 1.f};
    // Rendering transform
    sf::Vector2f m_position;

    // Animation
    std::unique_ptr<SpriteAnimator> m_pAnimator;

    // Facing
    enum class Facing { Left, Right };
    Facing m_facing        = Facing::Right;
    float  m_artFacingDirX = +1.f; // +1 = art facing right, -1 = art facing left

    void setFacing(Facing facing) {
        m_facing = facing;
        applyFacingScale();
    }
    void setArtFacingDirX(float directionX) {
        m_artFacingDirX = (directionX >= 0.f) ? +1.f : -1.f;
        applyFacingScale();
    }
    void applyFacingScale() {
        if (!m_pSprite)
            return;
        const float dir = (m_facing == Facing::Right) ? +1.f : -1.f;
        m_pSprite->setScale({dir * std::abs(m_spriteScale.x) * m_artFacingDirX, m_spriteScale.y});
    }

    // Physics and movement
    sf::Vector2f m_velocity;

    // Collision
    RectCollider   m_collider;
    sf::Vector2f   m_colliderSize;
    sf::Vector2f   m_colliderOffset;
    CollisionLayer m_collisionLayer = CollisionLayer::None;
    CollisionMask  m_collisionMask  = maskNone();

  public:
    // World reference
    World* m_world = nullptr;
};

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/entities/Entity.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/entities/actor/Actor.cpp =====
// src/game/Actor.cpp
#include "entities/actor/Actor.h"

#include "core/Config.h"
#include "core/Debug.h"
#include "core/ResourceManager.h"

#include <SFML/Graphics/RenderTarget.hpp>
#include <algorithm>
#include <cmath>

void Actor::render(sf::RenderTarget& target) const {
    if (m_pSprite)
        target.draw(*m_pSprite);
    if (m_pSprite && Config::kDebugDraw) {
        Debug::drawSpriteBounds(target, *m_pSprite, sf::Color::Red, 1.f);
        Debug::drawSpriteOrigin(target, *m_pSprite, sf::Color::Yellow, 10.f, 2.f);
        Debug::drawColliderBounds(target, getCollider(), sf::Color::Green, 1.f);
    }
}

void Actor::setInitialStats(float hpMax, float manaMax, float manaRegenRate, float hpRegenRate,
                            float staminaMax, float staminaRegenRate) {
    m_hpMax            = std::max(0.f, hpMax);
    m_hp               = m_hpMax;
    m_hpRegenRate      = std::max(0.f, hpRegenRate);
    m_manaMax          = std::max(0.f, manaMax);
    m_mana             = m_manaMax;
    m_manaRegenRate    = std::max(0.f, manaRegenRate);
    m_staminaMax       = std::max(0.f, staminaMax);
    m_stamina          = m_staminaMax;
    m_staminaRegenRate = std::max(0.f, staminaRegenRate);
}

void Actor::regenerateMana(float dt) {
    if (m_mana < m_manaMax) {
        m_mana += m_manaRegenRate * dt;
        if (m_mana > m_manaMax)
            m_mana = m_manaMax;
    }
}

void Actor::regenerateHp(float dt) {
    if (m_hp < m_hpMax) {
        m_hp += m_hpRegenRate * dt;
        if (m_hp > m_hpMax)
            m_hp = m_hpMax;
    }
}

void Actor::regenerateStamina(float dt) {
    if (m_stamina < m_staminaMax) {
        m_stamina += m_staminaRegenRate * dt;
        if (m_stamina > m_staminaMax)
            m_stamina = m_staminaMax;
    }
}

float Actor::getHp() const { return m_hp; }
float Actor::getHpMax() const { return m_hpMax; }
float Actor::getMana() const { return m_mana; }
float Actor::getManaMax() const { return m_manaMax; }
float Actor::getStamina() const { return m_stamina; }
float Actor::getStaminaMax() const { return m_staminaMax; }

void Actor::applyDamage(const DamageInfo& info) {
    if (!isAlive())
        return;

    // Core HP handling is centralized here so derived classes only deal with reactions.
    m_hp -= info.amount;
    if (m_hp < 0.f)
        m_hp = 0.f;

    onDamaged(info);
}

void Actor::onDamaged(const DamageInfo& /*info*/) {} // called by applyDamage, noop by default

void Actor::updateActorBase(float dt) {
    regenerateHp(dt);
    regenerateMana(dt);
    regenerateStamina(dt);
}

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/entities/actor/Actor.cpp =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/entities/actor/Actor.h =====
#pragma once

#include "entities/Entity.h"
#include "gameplay/Damage.h"

#include <SFML/System/Vector2.hpp>

class Collider;

class Actor : public Entity {
  public:
    Actor()          = default;
    virtual ~Actor() = default;

    // Stats
    void setInitialStats(float hpMax, float manaMax, float manaRegenRate, float hpRegenRate,
                         float staminaMax, float staminaRegenRate);

    void regenerateMana(float dt);
    void regenerateHp(float dt);
    void regenerateStamina(float dt);

    // Getters
    float getHp() const;
    float getHpMax() const;
    float getMana() const;
    float getManaMax() const;
    float getStamina() const;
    float getStaminaMax() const;

    // Main damage entry point using hit data.
    void applyDamage(const DamageInfo& info);

  protected:
    virtual void updateActorBase(float dt);

    // Hook for derived classes to react to damage (animations, knockback, etc.).
    virtual void onDamaged(const DamageInfo& info);

    // Stats
    // Health
    float m_hp          = 1.f;
    float m_hpMax       = 1.f;
    float m_hpRegenRate = 0.f;
    // Mana
    float m_mana          = 0.f;
    float m_manaMax       = 0.f;
    float m_manaRegenRate = 0.f;
    // Stamina
    float m_stamina          = 0.f;
    float m_staminaMax       = 0.f;
    float m_staminaRegenRate = 0.f;

    // Rendering
    void render(sf::RenderTarget& target) const override;
};

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/entities/actor/Actor.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/entities/actor/enemy/Demon.cpp =====
#include "entities/actor/enemy/Demon.h"

#include "animation/Animation.h"
#include "core/Assets.h"
#include "core/ResourceManager.h"
#include "core/World.h"
#include "entities/actor/player/Player.h"
#include "gameplay/Faction.h"
#include "physics/PhysicsSystem.h"
#include "spell/SpellCatalog.h"
#include "spell/projectile/Projectile.h"
#include "utils/Math.h"
#include "utils/Random.h"

bool Demon::init() {
    // Load textures
    sf::Texture& flyTex   = ResourceManager::getTexture(Assets::Tex::Enemy::Demon::Fly);
    sf::Texture& deathTex = ResourceManager::getTexture(Assets::Tex::Enemy::Demon::Death);
    sf::Texture& hitTex   = ResourceManager::getTexture(Assets::Tex::Enemy::Demon::Hit);

    // Sprite
    m_pSprite = std::make_unique<sf::Sprite>(flyTex);
    m_pSprite->setOrigin({kFrameSize.x * 0.5f, kFrameSize.y * 0.5f});
    m_spriteScale = {kSpriteScale.x, kSpriteScale.y};
    applyFacingScale();
    m_pSprite->setPosition(m_position);

    // Stats
    setInitialStats(kDemonHpMax, kDemonManaMax, kDemonManaRegenRate, kDemonHpRegenRate, 0.f, 0.f);

    // Animator
    m_pAnimator = std::make_unique<SpriteAnimator>(*m_pSprite);

    // Clips
    m_flyClip =
        m_pAnimator->addClip(Animation::makeClipFromRow("fly", flyTex, kFrameSize, 4, 10.f, true));
    m_deathClip = m_pAnimator->addClip(
        Animation::makeClipFromRow("death", deathTex, kFrameSize, 7, 10.f, false));
    m_hitClip =
        m_pAnimator->addClip(Animation::makeClipFromRow("hit", hitTex, kFrameSize, 4, 10.f, false));

    // Collider
    setColliderSize({kFrameSize.x * kColliderSizeMult.x, kFrameSize.y * kColliderSizeMult.y});
    setArtFacingDirX(-1.f);

    // Register with physics system
    PhysicsBodyConfig physCfg;
    physCfg.enabled       = true;
    physCfg.isKinematic   = false; // dynamic body => PhysicsSystem moves it
    physCfg.useGravity    = false; // demon flies, no gravity pull
    physCfg.topOnlyGround = true;  // clamp to top of ground/platform/obstacles
    physCfg.gravityScale  = 0.f;
    physCfg.maxVelX       = kMoveSpeed;
    physCfg.maxVelY       = kMoveSpeed;
    m_world->getPhysics().registerBody(*this, physCfg);

    enterFly();
    return true;
}

void Demon::onDamaged(const DamageInfo& /*info*/) {
    // Skip reactions once death has started so we don't interrupt the death animation.
    if (m_state == State::Death)
        return;

    // For now, any damaging hit just plays the hit animation; later we can add knockback, etc.
    if (m_state != State::Hit)
        enterHit();
}

void Demon::enterFly() {
    m_state = State::Fly;
    m_pAnimator->playClip(m_flyClip);

    m_flightTargetHoldLeftS   = 0.f;
    m_flightTargetAboveGround = Random::rangef(kMinHeightAboveGround, kMaxHeightAboveGround);

    m_desiredRangeHoldLeftS = Random::rangef(kDesiredRangeMinHoldS, kDesiredRangeMaxHoldS);
    m_desiredRange          = Random::rangef(kMinDesiredRange, kMaxDesiredRange);
}

void Demon::enterHit() {
    m_state = State::Hit;
    m_pAnimator->playClip(m_hitClip, [this]() { enterFly(); });
}

void Demon::enterDeath() {
    m_state = State::Death;
    m_pAnimator->playClip(m_deathClip, [this]() { setAlive(false); });
}

void Demon::updateFly(float dt) {
    Player* player = m_world->getPlayer();
    if (!player || dt <= 0.f)
        return;

    // Hold desired range target
    if (m_desiredRangeHoldLeftS > 0.f) {
        m_desiredRangeHoldLeftS -= dt;
    } else {
        m_desiredRangeHoldLeftS = Random::rangef(kDesiredRangeMinHoldS, kDesiredRangeMaxHoldS);
        m_desiredRange          = Random::rangef(kMinDesiredRange, kMaxDesiredRange);
    }

    const float toPlayerX = player->getPosition().x - m_position.x;
    const float distX     = std::abs(toPlayerX);

    // Face toward player
    if (distX > 0.001f)
        setFacing((toPlayerX >= 0.f) ? Entity::Facing::Right : Entity::Facing::Left);

    // X controller: arrive toward target distance + accel limiting
    float desiredVelX = 0.f;

    if (distX > 0.001f) {
        const float dirToPlayerX = (toPlayerX >= 0.f) ? 1.f : -1.f;
        const float error        = distX - m_desiredRange; // >0 too far, <0 too close

        if (std::abs(error) > kHoldSlack) {
            const float t     = math::saturate((std::abs(error) - kHoldSlack) / kSlowRadiusX);
            const float speed = t * kMoveSpeed;

            // too far => move toward player, too close => move away
            desiredVelX = (error > 0.f ? +dirToPlayerX : -dirToPlayerX) * speed;
        }
    }

    // Y target
    if (m_flightTargetHoldLeftS > 0.f) {
        m_flightTargetHoldLeftS -= dt;
    } else {
        m_flightTargetHoldLeftS   = Random::rangef(kFlightTargetMinHoldS, kFlightTargetMaxHoldS);
        m_flightTargetAboveGround = Random::rangef(kMinHeightAboveGround, kMaxHeightAboveGround);
    }

    const float groundTopY = m_world->getGroundTopYAt(m_position.x);
    const float desiredY   = groundTopY - m_flightTargetAboveGround;

    const float deltaY      = desiredY - m_position.y;
    float       desiredVelY = math::clampToMagnitude(deltaY * kVerticalKp, kVerticalMaxSpeed);
    if (std::abs(deltaY) <= kVerticalDeadzonePx)
        desiredVelY = 0.f;

    // Accel limit X
    sf::Vector2f v = getVelocity();

    const float maxDelta = ((desiredVelX == 0.f) ? kDecelX : kAccelX) * dt;
    const float dxv      = desiredVelX - v.x;

    if (std::abs(dxv) > maxDelta)
        v.x += (dxv > 0.f ? +maxDelta : -maxDelta);
    else
        v.x = desiredVelX;

    // Y can stay "direct set" we have deadzone + clamp
    v.y = desiredVelY;

    setVelocity(v);
}

void Demon::update(float dt) {
    // Death gate
    if (m_hp <= 0.f && m_state != State::Death)
        enterDeath();
    if (m_state == State::Death) {
        m_pAnimator->update(dt);
        m_pSprite->setPosition(m_position);
        return;
    }

    updateActorBase(dt);
    updateFly(dt);

    // Casting: aim at player and fire when in range and cooldown elapsed
    if (m_castCooldownLeft > 0.f)
        m_castCooldownLeft -= dt;
    else if (m_castCooldownLeft <= 0.f) {
        auto*        player = m_world->getPlayer();
        sf::Vector2f dir    = math::normalizeVec(player->getPosition() - m_position);

        // Spawn lightning bolt
        const sf::Vector2f origin = m_position + dir * 20.f;
        if (auto* proj =
                m_world->createEntity<Projectile>(SpellId::Lightning, Faction::Enemy, origin, dir))
            (void)proj->init();
        m_castCooldownLeft = kCastCooldown;
    }
    // Animation tick
    m_pAnimator->update(dt);
}

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/entities/actor/enemy/Demon.cpp =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/entities/actor/enemy/Demon.h =====
#pragma once

#include "animation/Animation.h"
#include "entities/actor/enemy/Enemy.h"

#include <SFML/System/Vector2.hpp>

class Demon final : public Enemy {
  public:
    Demon()           = default;
    ~Demon() override = default;

    bool init() override;
    void update(float dt) override;

  private:
    enum class State { Fly, Death, Hit };
    State m_state = State::Fly;

    void enterFly();
    void enterDeath();
    void enterHit();

    void updateFly(float dt);

    // React to damage by briefly entering the hit animation state.
    void onDamaged(const DamageInfo& info) override;

    // Casting
    static constexpr float kCastCooldown      = 2.0f;
    float                  m_castCooldownLeft = 0.f;

    // Movement goal: hover around desired range from player
    static constexpr float kMinDesiredRange      = 100.f;
    static constexpr float kMaxDesiredRange      = 250.f;
    static constexpr float kDesiredRangeMinHoldS = 0.60f;
    static constexpr float kDesiredRangeMaxHoldS = 1.40f;

    // deadband around target distance
    static constexpr float kHoldSlack = 30.f;

    // movement limits
    static constexpr float kMoveSpeed = 800.f; // px/s

    // "arrive" tuning: start slowing down when close to the target range
    static constexpr float kSlowRadiusX = 220.f;

    // acceleration limiting (prevents flip-flop jitter)
    static constexpr float kAccelX = 5200.f; // px/s^2
    static constexpr float kDecelX = 7200.f; // px/s^2

    // height
    static constexpr float kMinHeightAboveGround = 350.f;
    static constexpr float kMaxHeightAboveGround = 600.f;
    static constexpr float kFlightTargetMinHoldS = 0.65f;
    static constexpr float kFlightTargetMaxHoldS = 1.45f;
    static constexpr float kVerticalMaxSpeed     = 300.f;
    static constexpr float kVerticalKp           = 4.0f; // proportional gain
    static constexpr float kVerticalDeadzonePx   = 20.f;

    // state
    float m_flightTargetAboveGround = 275.f;
    float m_flightTargetHoldLeftS   = 0.f;

    // held desired range target (for X)
    float m_desiredRange          = 200.f;
    float m_desiredRangeHoldLeftS = 0.f;

    // Stats
    static constexpr float kDemonHpMax         = 50.f;
    static constexpr float kDemonManaMax       = 80.f;
    static constexpr float kDemonHpRegenRate   = 0.f;
    static constexpr float kDemonManaRegenRate = 5.f;

    static inline const sf::Vector2i kFrameSize{81, 71};
    static inline const sf::Vector2f kSpriteScale{1.2f, 1.2f};
    static inline const sf::Vector2f kColliderSizeMult{0.30f, 0.60f};
    SpriteAnimator::ClipId           m_flyClip   = SpriteAnimator::kInvalidClip;
    SpriteAnimator::ClipId           m_deathClip = SpriteAnimator::kInvalidClip;
    SpriteAnimator::ClipId           m_hitClip   = SpriteAnimator::kInvalidClip;
};

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/entities/actor/enemy/Demon.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/entities/actor/enemy/Enemy.h =====
#pragma once

#include "collision/CollisionLayers.h"
#include "entities/actor/Actor.h"

class Enemy : public Actor {
  public:
    Enemy() {
        setCollisionLayer(CollisionLayer::Enemy);
        setCollisionMask(maskFrom({CollisionLayer::PlayerProjectile}));
    }
    ~Enemy() override = default;
};

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/entities/actor/enemy/Enemy.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/entities/actor/enemy/FireWorm.cpp =====
#include "entities/actor/enemy/FireWorm.h"

#include "animation/Animation.h"
#include "core/Assets.h"
#include "core/ResourceManager.h"
#include "core/World.h"
#include "entities/actor/player/Player.h"
#include "gameplay/Faction.h"
#include "spell/SpellCatalog.h"
#include "spell/projectile/Projectile.h"

bool FireWorm::init() {
    // Load textures
    sf::Texture& moveTex   = ResourceManager::getTexture(Assets::Tex::Enemy::FireWorm::Move);
    sf::Texture& idleTex   = ResourceManager::getTexture(Assets::Tex::Enemy::FireWorm::Idle);
    sf::Texture& attackTex = ResourceManager::getTexture(Assets::Tex::Enemy::FireWorm::Attack);
    sf::Texture& deathTex  = ResourceManager::getTexture(Assets::Tex::Enemy::FireWorm::Death);
    sf::Texture& hitTex    = ResourceManager::getTexture(Assets::Tex::Enemy::FireWorm::Hit);

    // Sprite
    m_pSprite = std::make_unique<sf::Sprite>(moveTex);
    m_pSprite->setOrigin({kFrameSize.x * 0.5f, kFrameSize.y * 0.5f});
    m_spriteScale = {kSpriteScale.x, kSpriteScale.y};
    applyFacingScale();
    m_pSprite->setPosition(m_position);

    // Stats
    setInitialStats(kFireWormHpMax, kFireWormManaMax, kFireWormManaRegenRate, kFireWormHpRegenRate,
                    0.f, 0.f);

    // Animator
    m_pAnimator = std::make_unique<SpriteAnimator>(*m_pSprite);

    // Clips
    m_moveClip = m_pAnimator->addClip(
        Animation::makeClipFromRow("move", moveTex, kFrameSize, 9, 10.f, true));
    m_idleClip = m_pAnimator->addClip(
        Animation::makeClipFromRow("idle", idleTex, kFrameSize, 9, 10.f, true));
    m_attackClip = m_pAnimator->addClip(
        Animation::makeClipFromRow("attack", attackTex, kFrameSize, 16, 10.f, false));
    m_deathClip = m_pAnimator->addClip(
        Animation::makeClipFromRow("death", deathTex, kFrameSize, 8, 10.f, false));
    m_hitClip =
        m_pAnimator->addClip(Animation::makeClipFromRow("hit", hitTex, kFrameSize, 3, 10.f, false));
    // Collider
    setColliderSize({kFrameSize.x * kColliderSizeMult.x, kFrameSize.y * kColliderSizeMult.y});
    setArtFacingDirX(+1.f);
    enterMove();
    return true;
}

void FireWorm::onDamaged(const DamageInfo& /*info*/) {
    // Skip reactions once death has started so we don't interrupt the death animation.
    if (m_state == State::Death)
        return;

    // For now, any damaging hit just plays the hit animation; later we can add knockback, etc.
    if (m_state != State::Hit)
        enterHit();
}

void FireWorm::enterMove() {
    m_state = State::Move;
    m_pAnimator->playClip(m_moveClip);
}

void FireWorm::enterIdle() {
    m_state = State::Idle;
    m_pAnimator->playClip(m_idleClip);
}

void FireWorm::enterAttack() {
    m_state = State::Attack;
    m_pAnimator->playClip(m_attackClip, [this]() { enterMove(); });
}

void FireWorm::enterHit() {
    m_state = State::Hit;
    m_pAnimator->playClip(m_hitClip, [this]() { enterMove(); });
}

void FireWorm::enterDeath() {
    m_state = State::Death;
    m_pAnimator->playClip(m_deathClip, [this]() { setAlive(false); });
}

void FireWorm::updateMove(float /* dt */) {}

void FireWorm::update(float dt) {
    // Death gate
    if (m_hp <= 0.f && m_state != State::Death)
        enterDeath();
    if (m_state == State::Death) {
        m_pAnimator->update(dt);
        m_pSprite->setPosition(m_position);
        return;
    }

    updateActorBase(dt);
    updateMove(dt);

    // Animation tick
    m_pAnimator->update(dt);
    m_pSprite->setPosition(m_position);
}

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/entities/actor/enemy/FireWorm.cpp =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/entities/actor/enemy/FireWorm.h =====
#pragma once

#include "animation/Animation.h"
#include "entities/actor/enemy/Enemy.h"

#include <SFML/System/Vector2.hpp>

class FireWorm final : public Enemy {
  public:
    FireWorm()           = default;
    ~FireWorm() override = default;

    bool init() override;
    void update(float dt) override;

  private:
    enum class State { Move, Idle, Attack, Death, Hit };
    State m_state = State::Idle;

    void enterMove();
    void enterIdle();
    void enterAttack();
    void enterHit();
    void enterDeath();

    void updateMove(float dt);

    // React to damage by briefly entering the hit animation state.
    void onDamaged(const DamageInfo& info) override;

    // Casting
    static constexpr float kCastCooldown      = 2.0f;
    float                  m_castCooldownLeft = 0.f;

    // Movement goal: hover around desired range from player
    static constexpr float kDesiredRange = 300.f;
    static constexpr float kHoldSlack    = 30.f;  // acceptable band around desired
    static constexpr float kMoveSpeed    = 800.f; // px/s

    // Stats
    static constexpr float kFireWormHpMax         = 50.f;
    static constexpr float kFireWormManaMax       = 80.f;
    static constexpr float kFireWormHpRegenRate   = 0.f;
    static constexpr float kFireWormManaRegenRate = 5.f;

    static inline const sf::Vector2i kFrameSize{90, 90};
    static inline const sf::Vector2f kSpriteScale{2.5f, 2.5f};
    static inline const sf::Vector2f kColliderSizeMult{0.30f, 0.30f};
    SpriteAnimator::ClipId           m_moveClip   = SpriteAnimator::kInvalidClip;
    SpriteAnimator::ClipId           m_idleClip   = SpriteAnimator::kInvalidClip;
    SpriteAnimator::ClipId           m_attackClip = SpriteAnimator::kInvalidClip;
    SpriteAnimator::ClipId           m_deathClip  = SpriteAnimator::kInvalidClip;
    SpriteAnimator::ClipId           m_hitClip    = SpriteAnimator::kInvalidClip;
};

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/entities/actor/enemy/FireWorm.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/entities/actor/player/Player.cpp =====
#include "entities/actor/player/Player.h"

#include "animation/Animation.h"
#include "collision/CollisionLayers.h"
#include "collision/RectCollider.h"
#include "core/Assets.h"
#include "core/ResourceManager.h"
#include "core/World.h"
#include "gameplay/Faction.h"
#include "physics/PhysicsBody.h"
#include "physics/StaticWorldGeometry.h"
#include "spell/CastRequest.h"
#include "spell/SpellCatalog.h"
#include "spell/projectile/Projectile.h"
#include "utils/Geom.h"

#include <SFML/Graphics/Sprite.hpp>
#include <cmath>

bool Player::init() {
    // Setup collision layer and mask
    setCollisionLayer(CollisionLayer::Player);
    setCollisionMask(maskFrom({CollisionLayer::Obstacle, CollisionLayer::Platform,
                               CollisionLayer::Collectible, CollisionLayer::EnemyProjectile}));

    // Load animation textures if present
    const sf::Texture& idleTex  = ResourceManager::getTexture(Assets::Tex::Player::Idle);
    const sf::Texture& runTex   = ResourceManager::getTexture(Assets::Tex::Player::Move);
    const sf::Texture& jumpTex  = ResourceManager::getTexture(Assets::Tex::Player::Jump);
    const sf::Texture& fallTex  = ResourceManager::getTexture(Assets::Tex::Player::Fall);
    const sf::Texture& dashTex  = ResourceManager::getTexture(Assets::Tex::Player::Dash);
    const sf::Texture& deathTex = ResourceManager::getTexture(Assets::Tex::Player::Death);
    const sf::Texture& castTex  = ResourceManager::getTexture(Assets::Tex::Player::Cast);
    const sf::Texture& hitTex   = ResourceManager::getTexture(Assets::Tex::Player::Hit);

    // Setup sprite
    m_pSprite = std::make_unique<sf::Sprite>(idleTex);
    m_pSprite->setOrigin({kFrameSize.x * 0.5f, kFrameSize.y * 0.5f});
    m_spriteScale = kPlayerScale;
    applyFacingScale();
    m_pSprite->setPosition(m_position);

    // Setup animator
    m_pAnimator = std::make_unique<SpriteAnimator>(*m_pSprite);

    // Build animation clips
    m_idleClip =
        m_pAnimator->addClip(Animation::makeClipFromRow("idle", idleTex, kFrameSize, 4, 6.f, true));
    m_runClip =
        m_pAnimator->addClip(Animation::makeClipFromRow("run", runTex, kFrameSize, 7, 12.f, true));
    m_jumpClip = m_pAnimator->addClip(
        Animation::makeClipFromRow("jump", jumpTex, kFrameSize, 6, 12.f, false));
    m_fallClip = m_pAnimator->addClip(
        Animation::makeClipFromRow("fall", fallTex, kFrameSize, 3, 12.f, true));
    m_dashClip = m_pAnimator->addClip(
        Animation::makeClipFromRow("dash", dashTex, kFrameSize, 4, 20.f, false));
    m_deathClip = m_pAnimator->addClip(
        Animation::makeClipFromRow("death", deathTex, kFrameSize, 6, 8.f, false));
    m_castClip = m_pAnimator->addClip(
        Animation::makeClipFromRow("cast", castTex, kFrameSize, 5, 20.f, false));
    m_hitClip =
        m_pAnimator->addClip(Animation::makeClipFromRow("hit", hitTex, kFrameSize, 4, 10.f, false));

    // Setup collider
    setColliderSize(
        {static_cast<float>(kFrameSize.x) * 0.2f, static_cast<float>(kFrameSize.y) * 0.88f});

    // Register with physics system so movement and gravity are applied centrally.
    PhysicsBodyConfig physCfg;
    physCfg.enabled       = true;
    physCfg.isKinematic   = false;
    physCfg.useGravity    = true;
    physCfg.topOnlyGround = true;
    physCfg.gravityScale  = 1.f;
    physCfg.maxVelX       = kMaxVelX;
    physCfg.maxVelY       = kMaxVelY;
    physCfg.sideMask      = static_cast<std::uint8_t>(StaticSolidSide::SolidSide_Left) |
                       static_cast<std::uint8_t>(StaticSolidSide::SolidSide_Right);
    m_world->getPhysics().registerBody(*this, physCfg);

    // Setup stats
    setInitialStats(kPlayerHpMax, kPlayerManaMax, kPlayerManaRegenRate, kPlayerHpRegenRate,
                    kPlayerStaminaMax, kPlayerStaminaRegenRate);

    // Enter initial state
    enterMove();
    return true;
}

void Player::applyHorizontalMovement(const sf::Vector2f& direction, float dt) {
    // Horizontal move
    if (direction.x != 0.f) {
        // Accelerate toward desired X
        const float desiredX = direction.x * kMaxSpeed;
        const float deltaX   = desiredX - m_velocity.x;
        const float maxDelta = kAcceleration * dt;
        if (std::abs(deltaX) > maxDelta) {
            m_velocity.x += (deltaX > 0.f ? +maxDelta : -maxDelta);
        } else {
            m_velocity.x = desiredX;
        }
    } else {
        // Decelerate X toward 0
        const float speedX = std::abs(m_velocity.x);
        if (speedX > 0.f) {
            const float drop = kDeceleration * dt;
            if (speedX <= drop || speedX <= kMinSpeed) {
                m_velocity.x = 0.f;
            } else {
                m_velocity.x += (m_velocity.x > 0.f ? -drop : +drop);
            }
        }
    }
}

void Player::update(float dt) {
    // Death state: if HP or Stamina is zero or below, enter death and only update animation.
    if ((m_hp <= 0.f || m_stamina <= 0.f) && m_state != State::Death) {
        enterDeath();
    }

    // Death state: only update death animation.
    if (m_state == State::Death) {
        m_pAnimator->playClip(m_deathClip);
        m_pAnimator->update(dt);
        m_pSprite->setPosition(m_position);
        return;
    }

    // Base actor update (regeneration, etc)
    updateActorBase(dt);

    // Consume input supplied by the state
    if (m_input.jumpPressed) {
        // Start / refresh jump buffer window on edge-triggered press
        m_jumpBufferLeft = kJumpBufferTime;
    }
    if (m_input.dashPressed) {
        m_dashRequested = true;
    }

    // Timers: coyote time and jump buffer
    if (isGrounded()) {
        m_coyoteTimer = kCoyoteTime;
    } else {
        m_coyoteTimer -= dt;
    }

    // Jump buffer timer
    if (m_jumpBufferLeft > 0.f) {
        m_jumpBufferLeft -= dt;
        if (m_jumpBufferLeft < 0.f)
            m_jumpBufferLeft = 0.f;
    }

    // Dash timers and transitions
    if (m_dashCooldownLeft > 0.f)
        m_dashCooldownLeft -= dt;
    if (m_dashCooldownLeft < 0.f)
        m_dashCooldownLeft = 0.f;
    if (m_state == State::Dash) {
        m_dashTimer -= dt;
        if (m_dashTimer <= 0.f)
            enterMove();
    }

    // Horizontal direction
    sf::Vector2f dir{0.f, 0.f};
    if (m_input.moveLeft)
        dir.x -= 1.f;
    if (m_input.moveRight)
        dir.x += 1.f;
    if (dir.x != 0.f)
        dir.x = (dir.x > 0.f) ? 1.f : -1.f;

    // Facing updates only during normal movement
    if (m_state == State::Move) {
        if (m_input.moveLeft)
            setFacing(Entity::Facing::Left);
        else if (m_input.moveRight)
            setFacing(Entity::Facing::Right);
    }

    // Try dash when not already dashing
    if (m_state != State::Dash && m_state != State::Cast)
        tryApplyDash();

    // Try cast
    if (m_input.castPressed && m_state != State::Dash && m_state != State::Death)
        enterCast();

    // Apply horizontal movement
    if (m_state == State::Move) {
        applyHorizontalMovement(dir, dt);
    } else if (m_state == State::Dash) {
        m_velocity.x = m_dashDirX * kDashSpeed;
    } else if (m_state == State::Cast) {
        // Allow light movement during cast
        applyHorizontalMovement(dir, dt);
    }

    // Jumping (disabled while dashing)
    if (m_state != State::Dash)
        tryApplyJump();

    // Animation selection
    if (m_state == State::Dash) {
        m_pAnimator->playClip(m_dashClip);
    } else if (m_state == State::Cast) {
        m_pAnimator->playClip(m_castClip);
    } else if (m_state == State::Hit) {
        m_pAnimator->playClip(m_hitClip);
    } else if (!isGrounded()) {
        updateJumpAnimation();
    } else {
        updateMoveAnimation();
    }
    m_pAnimator->update(dt);

    // Sprite position follows entity transform (via Entity::setPosition / PhysicsSystem).
}

void Player::tryApplyJump() {
    // Already grounded => nothing to do
    if (!(isGrounded() || m_coyoteTimer > 0.f))
        return;

    // No buffered jump request => nothing to do
    if (m_jumpBufferLeft <= 0.f)
        return;

    if (m_stamina < kJumpStaminaCost)
        return;

    // Perform the jump
    m_velocity.y = -kJumpForce;
    m_stamina -= kJumpStaminaCost;

    // Consume the buffer so we don't chain extra jumps
    m_jumpBufferLeft = 0.f;

    m_pAnimator->requestRestart();
}

void Player::tryApplyDash() {
    if (!m_dashRequested)
        return;
    m_dashRequested = false;
    if (m_dashCooldownLeft > 0.f)
        return;
    if (m_stamina < kDashStaminaCost)
        return;

    float dirX = 0.f;
    if (m_input.moveLeft)
        dirX = -1.f;
    else if (m_input.moveRight)
        dirX = +1.f;
    else
        dirX = (m_facing == Facing::Right) ? +1.f : -1.f;
    enterDash(dirX);
}

void Player::updateJumpAnimation() {
    if (m_velocity.y < 0.f) {
        m_pAnimator->playClip(m_jumpClip);
    } else {
        m_pAnimator->playClip(m_fallClip);
    }
}

void Player::updateMoveAnimation() {
    const float speed = std::abs(m_velocity.x);
    if (speed > kMinSpeed)
        m_pAnimator->playClip(m_runClip);
    else
        m_pAnimator->playClip(m_idleClip);
}

void Player::enterMove() {
    m_state = State::Move;
    m_pAnimator->playClip(m_idleClip);

    // Restore normal gravity after dash or other special states.
    if (auto* body = m_world->getPhysics().findBody(*this)) {
        body->config.useGravity = true;
    }
}

void Player::enterDash(float dirX) {
    m_state            = State::Dash;
    m_dashTimer        = kDashDuration;
    m_dashCooldownLeft = kDashCooldown;
    m_dashDirX         = (dirX >= 0.f) ? +1.f : -1.f;
    // Reset vertical velocity so dash does not inherit any upward or downward motion,
    // and temporarily disable gravity while dashing.
    m_velocity.y = 0.f;
    if (auto* body = m_world->getPhysics().findBody(*this)) {
        body->config.useGravity = false;
    }
    if (m_stamina >= kDashStaminaCost)
        m_stamina -= kDashStaminaCost;
    setFacing(m_dashDirX > 0 ? Facing::Right : Facing::Left);
    m_pAnimator->playClip(m_dashClip);
}

void Player::enterDeath() {
    m_state = State::Death;

    m_pAnimator->playClip(m_deathClip, [world = m_world]() { world->requestExitToMenu(); });
}

void Player::enterCast() {
    // Spend mana and spawn a projectile if possible
    const SpellDef& def = getSpellDef(SpellId::IceBolt);
    if (m_mana < def.stats.manaCost)
        return;
    m_mana -= def.stats.manaCost;

    // Aim: from player position to mouse world position
    sf::Vector2f       aimDir{(m_facing == Facing::Right) ? +1.f : -1.f, 0.f};
    const sf::Vector2f mouseWorld = m_world->getMouseWorld();
    sf::Vector2f       v          = mouseWorld - m_position;
    sf::Vector2f       n          = math::normalizeVec(v);
    if (n.x != 0.f || n.y != 0.f)
        aimDir = n;

    // Origin slightly in front along aim
    sf::Vector2f orig = m_position + aimDir * (kFrameSize.x * 0.4f);

    auto* proj = m_world->createEntity<Projectile>(SpellId::IceBolt, Faction::Player, orig, aimDir);

    (void)proj->init();

    // Play cast animation and return to move on completion
    m_state = State::Cast;
    m_pAnimator->playClip(m_castClip, [this]() {
        if (m_state == State::Cast)
            enterMove();
    });
}

void Player::enterHit() {
    m_state = State::Hit;

    m_pAnimator->playClip(m_hitClip, [this]() {
        if (m_state == State::Hit)
            enterMove();
    });
}

bool Player::isGrounded() const {
    const PhysicsBody* body = m_world->getPhysics().findBody(*this);
    return body->grounded;
}

void Player::onDamaged(const DamageInfo& damage) {
    if (m_state == State::Death)
        return;

    if (m_state == State::Hit)
        return;

    if (damage.collideWith == CollisionLayer::EnemyProjectile)
        enterHit();
}

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/entities/actor/player/Player.cpp =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/entities/actor/player/Player.h =====
#pragma once

#include "animation/Animation.h"
#include "entities/actor/Actor.h"

struct PlayerInput {
    bool moveLeft    = false;
    bool moveRight   = false;
    bool jumpPressed = false; // edge-triggered
    bool dashPressed = false; // edge-triggered
    bool castPressed = false; // edge-triggered
};

class Player final : public Actor {
  public:
    Player()           = default;
    ~Player() override = default;

    bool init() override;
    void update(float dt) override;
    void setInput(const PlayerInput& input) { m_input = input; }

  private:
    // State machine
    enum class State { Move, Dash, Death, Cast, Hit };
    State m_state = State::Move;

    bool isGrounded() const;

    void enterMove();
    void enterDash(float dirX);
    void enterDeath();
    void enterCast();
    void enterHit();

    void applyHorizontalMovement(const sf::Vector2f& direction, float dt);
    void tryApplyJump();
    void tryApplyDash();

    void updateJumpAnimation();
    void updateMoveAnimation();

    // Called when the player takes damage;
    void onDamaged(const DamageInfo& info) override;

    // Input state
    PlayerInput m_input;

    // Rendering
    static inline const sf::Vector2i kFrameSize{100, 64};
    static inline const sf::Vector2f kPlayerScale{1.5f, 1.5f};
    SpriteAnimator::ClipId           m_idleClip  = SpriteAnimator::kInvalidClip;
    SpriteAnimator::ClipId           m_runClip   = SpriteAnimator::kInvalidClip;
    SpriteAnimator::ClipId           m_jumpClip  = SpriteAnimator::kInvalidClip;
    SpriteAnimator::ClipId           m_fallClip  = SpriteAnimator::kInvalidClip;
    SpriteAnimator::ClipId           m_dashClip  = SpriteAnimator::kInvalidClip;
    SpriteAnimator::ClipId           m_deathClip = SpriteAnimator::kInvalidClip;
    SpriteAnimator::ClipId           m_castClip  = SpriteAnimator::kInvalidClip;
    SpriteAnimator::ClipId           m_hitClip   = SpriteAnimator::kInvalidClip;

    // Configuration
    static constexpr float kMaxSpeed     = 500.f;
    static constexpr float kAcceleration = 1200.f;
    static constexpr float kDeceleration = 800.f;
    static constexpr float kMinSpeed     = 5.f;
    static constexpr float kMaxVelY      = 3000.f;
    static constexpr float kMaxVelX      = 3000.f;

    // Stats
    static constexpr float kPlayerHpMax            = 100.f;
    static constexpr float kPlayerHpRegenRate      = 1.f;
    static constexpr float kPlayerManaMax          = 100.f;
    static constexpr float kPlayerManaRegenRate    = 3.f;
    static constexpr float kPlayerStaminaMax       = 100.f;
    static constexpr float kPlayerStaminaRegenRate = 1.f;
    static constexpr float kJumpStaminaCost        = 2.f;
    static constexpr float kDashStaminaCost        = 2.f;

    // Jumping
    static constexpr float kJumpForce       = 1200.f;
    static constexpr float kCoyoteTime      = 0.10f;
    static constexpr float kJumpBufferTime  = 0.12f;
    float                  m_coyoteTimer    = 0.f;
    float                  m_jumpBufferLeft = 0.f;

    // Dash
    static constexpr float kDashSpeed         = 1100.f;
    static constexpr float kDashDuration      = 0.20f;
    static constexpr float kDashCooldown      = 3.f;
    bool                   m_dashRequested    = false;
    float                  m_dashTimer        = 0.f;
    float                  m_dashCooldownLeft = 0.f;
    float                  m_dashDirX         = 0.f; // -1 left, +1 right
};

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/entities/actor/player/Player.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/entities/collectible/RedSquare.cpp =====
#include "entities/collectible/RedSquare.h"

#include "core/Assets.h"
#include "core/Config.h"
#include "core/Debug.h"
#include "core/ResourceManager.h"
#include "core/World.h"
#include "entities/actor/player/Player.h"
#include "utils/Geom.h"

bool RedSquare::init() {
    // Hidden sprite used only for collider transform (not rendered)
    const sf::Texture& tex = ResourceManager::getTexture(Assets::Tex::Spell::Icebolt::Start);
    m_pSprite              = std::make_unique<sf::Sprite>(tex);
    m_pSprite->setOrigin({kSize * 0.5f, kSize * 0.5f});
    m_pSprite->setPosition(m_startCenter);

    // Collider matches square size
    setColliderSize({kSize, kSize});

    // Visual rectangle
    m_shape.setSize({kSize, kSize});
    m_shape.setOrigin({kSize * 0.5f, kSize * 0.5f});
    m_shape.setFillColor(sf::Color(220, 68, 64)); // Red-ish
    m_shape.setOutlineColor(sf::Color::White);
    m_shape.setOutlineThickness(1.f);
    m_shape.setPosition(m_startCenter);
    return true;
}

void RedSquare::update(float dt) {
    // Rotate in place
    const float ang = m_shape.getRotation().asDegrees() + kRotateDps * dt;
    m_shape.setRotation(sf::degrees(ang));
    if (m_pSprite)
        m_pSprite->setPosition(m_shape.getPosition());
}

void RedSquare::render(sf::RenderTarget& target) const {
    target.draw(m_shape);
    if constexpr (Config::kDebugDraw) {
        Debug::drawColliderBounds(target, getCollider(), sf::Color::Green, 1.f);
    }
}

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/entities/collectible/RedSquare.cpp =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/entities/collectible/RedSquare.h =====
#pragma once

#include "collision/CollisionLayers.h"
#include "entities/Entity.h"

#include <SFML/Graphics/RectangleShape.hpp>

// Minimal rotating collectible square.
class RedSquare final : public Entity {
  public:
    explicit RedSquare(const sf::Vector2f& center) : m_startCenter(center) {
        setCollisionLayer(CollisionLayer::Collectible);
        setCollisionMask(maskFrom({CollisionLayer::Player, CollisionLayer::PlayerProjectile}));
    }
    ~RedSquare() override = default;

    bool init() override;
    void update(float dt) override;

    // Size used for collider and visuals (square).
    static constexpr float kSize = 24.f;

  private:
    void render(sf::RenderTarget& target) const override;

    // Visual
    sf::RectangleShape m_shape;
    sf::Vector2f       m_startCenter{0.f, 0.f};

    // Rotation
    static constexpr float kRotateDps = 90.f; // degrees per second
};

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/entities/collectible/RedSquare.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/entities/obstacle/Obstacle.h =====
#pragma once

#include "animation/Animation.h"
#include "collision/CollisionLayers.h"
#include "core/Config.h"
#include "core/Debug.h"
#include "core/ResourceManager.h"
#include "entities/Entity.h"
#include "entities/obstacle/ObstacleTypes.h"

#include <SFML/Graphics/Sprite.hpp>

// Minimal obstacle entity: static sprite with optional sheet-based animation.
class Obstacle final : public Entity {
  public:
    explicit Obstacle(const ObstacleDesc& desc) : m_desc(desc) {
        setCollisionLayer(CollisionLayer::Obstacle);
        setCollisionMask(maskFrom({CollisionLayer::Player}));
    }

    bool init() override {
        // Load texture
        const sf::Texture& tex = ResourceManager::getTexture(m_desc.textureKey);

        // Sprite setup
        m_pSprite     = std::make_unique<sf::Sprite>(tex);
        m_spriteScale = m_desc.scale;
        applyFacingScale();
        m_pSprite->setOrigin({m_desc.frameSize.x * 0.5f, m_desc.frameSize.y * 0.5f});

        // Animation setup
        if (m_desc.animated) {
            m_pAnimator = std::make_unique<SpriteAnimator>(*m_pSprite);
            auto clip =
                Animation::makeClipFromSheet("main", tex, m_desc.frameSize, m_desc.startCell,
                                             m_desc.endCell, m_desc.fps, m_desc.loop);
            m_mainClip = m_pAnimator->addClip(std::move(clip));
            m_pAnimator->playClip(m_mainClip);
        }

        // Collider setup
        sf::Vector2f spritePos = m_pSprite->getPosition();
        setColliderSize(m_desc.colliderSize);
        setColliderOffset(spritePos);

        return true;
    }

    void update(float dt) override {
        if (m_pAnimator)
            m_pAnimator->update(dt);
        if (m_pSprite)
            m_pSprite->setPosition(m_position);
    }

    void render(sf::RenderTarget& target) const override {
        if (m_pSprite)
            target.draw(*m_pSprite);
        if constexpr (Config::kDebugDraw) {
            Debug::drawColliderBounds(target, getCollider(), sf::Color::Green, 1.f);
            Debug::drawSpriteOrigin(target, *m_pSprite, sf::Color::Yellow, 10.f, 2.f);
            Debug::drawSpriteBounds(target, *m_pSprite, sf::Color::Red, 1.f);
        }
    }

    float               getDps() const { return m_desc.dps; }
    const ObstacleDesc& getDesc() const { return m_desc; }

  private:
    ObstacleDesc           m_desc;
    SpriteAnimator::ClipId m_mainClip = SpriteAnimator::kInvalidClip;
};

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/entities/obstacle/Obstacle.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/entities/obstacle/ObstacleFactory.h =====
#pragma once

#include "entities/obstacle/Obstacle.h"
#include "entities/obstacle/ObstacleTypes.h"

class World;

// Tiny, inline spawn helper that hides the registry lookup
inline Obstacle* spawnObstacle(World& world, ObstacleKind kind, const sf::Vector2f& pos) {
    const ObstacleDesc& desc = getObstacleDesc(kind);
    auto*               obs  = world.createEntity<Obstacle>(desc);
    if (!obs || !obs->init())
        return nullptr;
    // Position sprite so its visual top-left aligns at pos + visualOffset
    obs->setPosition({pos + desc.visualOffset});
    obs->update(0.f);
    return obs;
}

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/entities/obstacle/ObstacleFactory.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/entities/obstacle/ObstacleTypes.h =====

#pragma once

#include "core/Assets.h"

#include <SFML/Graphics.hpp>
#include <array>
#include <cstdint>
#include <string>
#include <string_view>
#include <vector>

enum class ObstacleKind : uint8_t { Altar1, Altar2, Tree, Lich, SkullPile, Count };

struct ObstacleDesc {
    ObstacleKind     kind;
    bool             animated;
    std::string_view textureKey;

    // Animation source as a grid on a spritesheet
    sf::Vector2i frameSize{0, 0};
    sf::Vector2i startCell{0, 0};
    sf::Vector2i endCell{0, 0};
    float        fps  = 0.f;
    bool         loop = true;

    // Rendering + collision
    sf::Vector2f visualOffset{0.f, 0.f};
    sf::Vector2f colliderSize{0.f, 0.f};
    sf::Vector2f scale{1.f, 1.f};
    float        dps = 0.f;
};

static const std::array<ObstacleDesc, static_cast<size_t>(ObstacleKind::Count)> kTable = {{
    // Altar1
    ObstacleDesc{ObstacleKind::Altar1, true, Assets::Tex::Obstacle::Altar1,
                 /*frameSize*/ {80, 112}, /*start*/ {0, 0}, /*end*/ {5, 2},
                 /*fps*/ 8.f, /*loop*/ true,
                 /*visualOffset*/ {0.f, -120.f},
                 /*colliderSize*/ {30.f, 40.f},
                 /*scale*/ {4.f, 4.f},
                 /*dps*/ 10.f},
    // Altar2
    ObstacleDesc{ObstacleKind::Altar2, true, Assets::Tex::Obstacle::Altar2,
                 /*frameSize*/ {96, 112}, /*start*/ {0, 0}, /*end*/ {5, 2},
                 /*fps*/ 8.f, /*loop*/ true,
                 /*visualOffset*/ {0.f, -120.f},
                 /*colliderSize*/ {40.f, 50.f},
                 /*scale*/ {4.f, 4.f},
                 /*dps*/ 10.f},
    // Tree (static)
    ObstacleDesc{ObstacleKind::Tree, false, Assets::Tex::Obstacle::Tree,
                 /*frameSize*/ {128, 128}, /*start*/ {0, 0}, /*end*/ {0, 0},
                 /*fps*/ 0.f, /*loop*/ false,
                 /*visualOffset*/ {0.f, 20.f},
                 /*colliderSize*/ {20.f, 90.f},
                 /*scale*/ {2.f, 2.f},
                 /*dps*/ 10.f},
    // Lich statue (static)
    ObstacleDesc{ObstacleKind::Lich, false, Assets::Tex::Obstacle::Lich,
                 /*frameSize*/ {256, 256}, /*start*/ {0, 0}, /*end*/ {0, 0},
                 /*fps*/ 0.f, /*loop*/ false,
                 /*visualOffset*/ {0.f, 30.f},
                 /*colliderSize*/ {60.f, 80.f},
                 /*scale*/ {4.f, 4.f},
                 /*dps*/ 10.f},
    // Skull pile (static)
    ObstacleDesc{ObstacleKind::SkullPile, false, Assets::Tex::Obstacle::SkullPile,
                 /*frameSize*/ {128, 128}, /*start*/ {0, 0}, /*end*/ {0, 0},
                 /*fps*/ 0.f, /*loop*/ false,
                 /*visualOffset*/ {0.f, -40.f},
                 /*colliderSize*/ {60.f, 40.f},
                 /*scale*/ {4.f, 4.f},
                 /*dps*/ 10.f},
}};

inline const ObstacleDesc& getObstacleDesc(ObstacleKind kind) {
    return kTable.at(static_cast<size_t>(kind));
}

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/entities/obstacle/ObstacleTypes.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/entities/platform/Platform.h =====
#pragma once

#include "collision/CollisionLayers.h"
#include "core/Config.h"
#include "core/Debug.h"
#include "core/ResourceManager.h"
#include "entities/Entity.h"
#include "entities/platform/PlatformTypes.h"

// Minimal static-image platform entity. No animation.
class Platform final : public Entity {
  public:
    explicit Platform(const PlatformDesc& desc) : m_desc(desc) {
        setCollisionLayer(CollisionLayer::Platform);
        setCollisionMask(maskFrom({CollisionLayer::Player}));
    }

    bool init() override {
        // Load texture
        const sf::Texture& tex = ResourceManager::getTexture(m_desc.textureKey);

        // Sprite setup
        m_pSprite     = std::make_unique<sf::Sprite>(tex);
        m_spriteScale = m_desc.scale;
        applyFacingScale();
        m_pSprite->setOrigin({m_desc.frameSize.x * 0.5f, m_desc.frameSize.y * 0.5f});

        // Collider setup
        sf::Vector2f spritePos = m_pSprite->getPosition();
        setColliderSize(m_desc.colliderSize);
        setColliderOffset(spritePos);

        return true;
    }

    void update(float dt) override {
        (void)dt;
        if (m_pSprite)
            m_pSprite->setPosition(m_position);
    }

    void render(sf::RenderTarget& target) const override {
        if (m_pSprite)
            target.draw(*m_pSprite);
        if constexpr (Config::kDebugDraw) {
            Debug::drawColliderBounds(target, getCollider(), sf::Color::Cyan, 1.f);
            Debug::drawSpriteBounds(target, *m_pSprite, sf::Color::Magenta, 1.f);
            Debug::drawSpriteOrigin(target, *m_pSprite, sf::Color::Yellow, 10.f, 2.f);
        }
    }

    const PlatformDesc& getDesc() const { return m_desc; }

  private:
    PlatformDesc m_desc;
};

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/entities/platform/Platform.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/entities/platform/PlatformFactory.h =====
#pragma once

#include "entities/platform/Platform.h"
#include "entities/platform/PlatformTypes.h"

class World;

// Inline spawn helper
inline Platform* spawnPlatform(World& world, PlatformKind kind, const sf::Vector2f& pos) {
    const PlatformDesc& desc = getPlatformDesc(kind);
    auto*               p    = world.createEntity<Platform>(desc);
    if (!p || !p->init())
        return nullptr;
    p->setPosition({pos + desc.visualOffset});
    p->update(0.f);
    return p;
}

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/entities/platform/PlatformFactory.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/entities/platform/PlatformTypes.h =====
#pragma once

#include "core/Assets.h"

#include <SFML/Graphics.hpp>
#include <array>
#include <cstdint>
#include <string_view>

// Static-image platforms you can stand on.
enum class PlatformKind : uint8_t { Platform1, Platform2, Count };

struct PlatformDesc {
    PlatformKind     kind;
    std::string_view textureKey; // key for ResourceManager
    sf::Vector2i     frameSize{0, 0};
    sf::Vector2f     visualOffset{0.f, 0.f};
    sf::Vector2f     colliderSize{0.f, 0.f};
    sf::Vector2f     scale{1.f, 1.f};
};

static const std::array<PlatformDesc, static_cast<size_t>(PlatformKind::Count)> kPlatformTable = {{
    PlatformDesc{PlatformKind::Platform1, Assets::Tex::Platform::Rock1,
                 /*frameSize*/ {64, 64},
                 /*visualOffset*/ {0.f, -180.f},
                 /*colliderSize*/ {24.f, 16.f},
                 /*scale*/ {2.f, 2.f}},
    PlatformDesc{PlatformKind::Platform2, Assets::Tex::Platform::Rock2,
                 /*frameSize*/ {64, 64},
                 /*visualOffset*/ {0.f, -150.f},
                 /*colliderSize*/ {24.f, 16.f},
                 /*scale*/ {2.f, 2.f}},
}};

inline const PlatformDesc& getPlatformDesc(PlatformKind k) {
    return kPlatformTable.at(static_cast<size_t>(k));
}

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/entities/platform/PlatformTypes.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/environment/AnimatedParallaxStrip.h =====
#pragma once
#include "core/ResourceManager.h"
#include "environment/StripUtil.h"

#include <SFML/Graphics.hpp>
#include <cmath>
#include <string_view>
#include <vector>

class AnimatedParallaxStrip : public sf::Drawable {
  public:
    AnimatedParallaxStrip(std::vector<std::string_view> frames, float factor, float fps)
        : m_frames(std::move(frames)), m_factor(factor), m_fps(fps) {}

    void update(float dt) { m_time += dt; }

    void drawForView(sf::RenderTarget& target, const sf::View& view) const {
        if (m_frames.empty())
            return;
        const std::size_t idx = static_cast<std::size_t>(m_time * m_fps) % m_frames.size();
        sf::Texture&      tex = ResourceManager::getRepeatedTexture(m_frames[idx]);
        strip::drawStrip(target, view, tex, m_factor);
    }

  private:
    void draw(sf::RenderTarget&, sf::RenderStates) const override {}

    std::vector<std::string_view> m_frames;
    float                         m_factor = 0.15f;
    float                         m_fps    = 6.f;
    float                         m_time   = 0.f;
};

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/environment/AnimatedParallaxStrip.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/environment/EnvConfig.h =====
#pragma once

#include <array>

namespace EnvConfig {
    namespace VolcanoDay {
        // How fast the animated BG strip scrolls and how fast it animates
        inline constexpr float kBgAnimFactor = 0.15f;
        inline constexpr float kBgAnimFps    = 6.f;

        // Parallax factors for each layer, ordered to match Layer01..Layer08
        inline constexpr std::array<float, 8> kLayerFactors = {
            0.16f, // Layer01
            0.22f, // Layer02
            0.28f, // Layer03
            0.34f, // Layer04
            0.50f, // Layer05
            0.62f, // Layer06
            1.00f, // Layer07 (ground speed)
            0.76f, // Layer08 (foreground)
        };
    } // namespace VolcanoDay
} // namespace EnvConfig

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/environment/EnvConfig.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/environment/Environment.cpp =====
#include "environment/Environment.h"

#include "core/Assets.h"
#include "core/ResourceManager.h"
#include "environment/EnvConfig.h"
#include "environment/StripUtil.h"
#include "environment/ground/GroundHazardCatalog.h"

#include <algorithm>
#include <initializer_list>
#include <string_view>
#include <vector>

bool Environment::initVolcanoDay() {
    using namespace EnvConfig::VolcanoDay;

    m_bg = std::make_unique<ParallaxBackground>(std::initializer_list<strip::ParallaxLayerDesc>{
        {Assets::Tex::Environment::Parallax::VolcanoDay::Layer01, kLayerFactors[0]},
        {Assets::Tex::Environment::Parallax::VolcanoDay::Layer02, kLayerFactors[1]},
        {Assets::Tex::Environment::Parallax::VolcanoDay::Layer03, kLayerFactors[2]},
        {Assets::Tex::Environment::Parallax::VolcanoDay::Layer04, kLayerFactors[3]},
        {Assets::Tex::Environment::Parallax::VolcanoDay::Layer05, kLayerFactors[4]},
        {Assets::Tex::Environment::Parallax::VolcanoDay::Layer06, kLayerFactors[5]},
        {Assets::Tex::Environment::Parallax::VolcanoDay::Layer08, kLayerFactors[7]},
    });

    m_bgAnim = std::make_unique<AnimatedParallaxStrip>(
        std::vector<std::string_view>{
            Assets::Tex::Environment::Parallax::VolcanoDay::Bg01,
            Assets::Tex::Environment::Parallax::VolcanoDay::Bg02,
            Assets::Tex::Environment::Parallax::VolcanoDay::Bg03,
        },
        kBgAnimFactor, kBgAnimFps);

    m_groundLayer = strip::ParallaxLayerDesc{
        Assets::Tex::Environment::Parallax::VolcanoDay::Layer07, kLayerFactors[6]};

    const GroundHazardDef& lavaDef = getGroundHazardDef(HazardType::Lava);
    const GroundHazardDef& holeDef = getGroundHazardDef(HazardType::Hole);

    HazardConfig hazardCfg;
    hazardCfg.enabled    = true;
    hazardCfg.holeChance = 0.5f;
    hazardCfg.lava       = lavaDef.style;
    hazardCfg.hole       = holeDef.style;

    GroundStreamConfig groundCfg = GroundPresets::gapsWithHazard(m_groundLayer, hazardCfg);
    m_ground                     = std::make_unique<GroundBand>(groundCfg);
    m_hazard                     = std::make_unique<HazardLayer>(groundCfg.hazard);
    m_hazard->init();

    return true;
}

void Environment::update(float dt, const sf::View& view) {
    m_bgAnim->update(dt);
    m_hazard->update(dt);
    m_ground->updateForView(view);
}

void Environment::renderBackground(sf::RenderTarget& target, const sf::View& view) const {
    m_bgAnim->drawForView(target, view);
    const std::size_t lastBack = std::min<std::size_t>(5, m_bg->size() - 1);
    m_bg->drawRangeForView(target, view, 0, lastBack);
}

void Environment::renderForeground(sf::RenderTarget& target, const sf::View& view) const {
    // Ground visual strip (independent of gameplay colliders)
    if (!m_groundLayer.texturePath.empty()) {
        sf::Texture& tex = ResourceManager::getRepeatedTexture(m_groundLayer.texturePath);
        strip::drawStrip(target, view, tex, m_groundLayer.factor);
    }

    // Hazard visuals occupying the gaps
    if (m_ground && m_hazard && m_hazard->hasHazard()) {
        std::vector<GroundGap> gaps;
        m_ground->gapsForView(view, gaps);
        m_hazard->drawForView(target, view, gaps);
    }

    if (m_bg && m_bg->size() >= 7)
        m_bg->drawRangeForView(target, view, 6, 6);
}

const MultiRectCollider* Environment::getGroundCollider() const {
    if (!m_ground)
        return nullptr;
    return &m_ground->getCollider();
}

float Environment::getGroundTopY(const sf::View& view) const {
    if (!m_ground)
        return 0.f;
    return m_ground->getTopYForView(view);
}

bool Environment::intersectsHazard(const sf::FloatRect& aabb, const sf::View& view) const {
    if (!m_ground || !m_hazard || !m_hazard->hasHazard())
        return false;

    std::vector<GroundGap> gaps;
    m_ground->gapsForView(view, gaps);
    return m_hazard->intersectsHazard(aabb, gaps);
}

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/environment/Environment.cpp =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/environment/Environment.h =====
#pragma once

#include "environment/AnimatedParallaxStrip.h"
#include "environment/ParallaxBackground.h"
#include "environment/ground/GroundBand.h"
#include "environment/ground/HazardLayer.h"

#include <SFML/Graphics/Rect.hpp>
#include <SFML/Graphics/RenderTarget.hpp>
#include <SFML/Graphics/View.hpp>
#include <memory>

class Environment {
  public:
    Environment() = default;

    bool initVolcanoDay();

    void update(float dt, const sf::View& view);
    void renderBackground(sf::RenderTarget& target, const sf::View& view) const;
    void renderForeground(sf::RenderTarget& target, const sf::View& view) const;

    const MultiRectCollider* getGroundCollider() const;
    float                    getGroundTopY(const sf::View& view) const;
    bool intersectsHazard(const sf::FloatRect& aabb, const sf::View& view) const;

  private:
    std::unique_ptr<ParallaxBackground>    m_bg;
    std::unique_ptr<AnimatedParallaxStrip> m_bgAnim;
    std::unique_ptr<GroundBand>            m_ground;
    std::unique_ptr<HazardLayer>           m_hazard;
    strip::ParallaxLayerDesc               m_groundLayer{};
};

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/environment/Environment.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/environment/ParallaxBackground.h =====
#pragma once

#include "core/ResourceManager.h"
#include "environment/StripUtil.h"

#include <SFML/Graphics.hpp>
#include <vector>

class ParallaxBackground : public sf::Drawable {
  public:
    ParallaxBackground(std::initializer_list<strip::ParallaxLayerDesc> layers) : m_layers(layers) {}

    void add(const strip::ParallaxLayerDesc& desc) { m_layers.push_back(desc); }

    void drawRangeForView(sf::RenderTarget& target, const sf::View& view, std::size_t first,
                          std::size_t last) const {
        if (m_layers.empty())
            return;
        if (first >= m_layers.size())
            return;
        const std::size_t lastClamped = std::min(last, m_layers.size() - 1);
        for (std::size_t i = first; i <= lastClamped; ++i) {
            const auto&  layer = m_layers[i];
            sf::Texture& tex   = ResourceManager::getRepeatedTexture(layer.texturePath);
            strip::drawStrip(target, view, tex, layer.factor);
        }
    }

    std::size_t size() const { return m_layers.size(); }

  private:
    void draw(sf::RenderTarget&, sf::RenderStates) const override {}

    std::vector<strip::ParallaxLayerDesc> m_layers;
};

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/environment/ParallaxBackground.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/environment/StripUtil.h =====
#pragma once

#include <SFML/Graphics.hpp>
#include <algorithm>
#include <cmath>
#include <string_view>

namespace strip {

    struct ParallaxLayerDesc {
        std::string_view texturePath;
        float            factor = 0.f;
    };

    // Draw a horizontally repeating strip aligned to the view's bottom edge.
    inline void drawStrip(sf::RenderTarget& target, const sf::View& view,
                          const sf::Texture& texture, float parallaxFactor) {
        // View geometry
        const float viewWidthWorld  = view.getSize().x;
        const float viewHeightWorld = view.getSize().y;
        const float viewLeftWorld   = view.getCenter().x - 0.5f * viewWidthWorld;
        const float viewTopWorld    = 0.f; // always anchored to bottom

        // Slight overdraw to avoid edge artifacts
        constexpr float paddingPixels = 2.f;

        // Screen-space quad we'll draw into
        sf::RectangleShape stripQuad({viewWidthWorld + 2.f * paddingPixels, viewHeightWorld});
        stripQuad.setPosition({viewLeftWorld - paddingPixels, viewTopWorld});
        stripQuad.setTexture(&texture, true);

        // Texture info
        const sf::Vector2u textureSizePx   = texture.getSize();
        const int          textureHeightPx = static_cast<int>(textureSizePx.y);

        // Convert world/screen size to texture space using a uniform vertical scale
        const float pixelsPerTexel = viewHeightWorld / static_cast<float>(textureHeightPx);

        // Horizontal scrolling in texture space
        const float texUStartF = (viewLeftWorld * parallaxFactor) / pixelsPerTexel;
        const float texUWidthF = stripQuad.getSize().x / pixelsPerTexel;

        // Bottom-aligned vertical slice in texture space
        const int texVHeight = static_cast<int>(viewHeightWorld / pixelsPerTexel);
        const int texVStart  = textureHeightPx - texVHeight;

        // Truncate to ints for the texture rect
        const int texUStart = static_cast<int>(texUStartF);
        const int texUWidth = static_cast<int>(texUWidthF);

        sf::IntRect texRect({texUStart, texVStart}, {texUWidth, texVHeight});
        stripQuad.setTextureRect(texRect);
        target.draw(stripQuad);
    }

} // namespace strip

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/environment/StripUtil.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/environment/ground/GroundBand.h =====
#pragma once

#include "collision/MultiRectCollider.h"
#include "environment/ground/GroundTypes.h"
#include "utils/Geom.h"
#include "utils/Math.h"

#include <SFML/Graphics/Rect.hpp>
#include <SFML/Graphics/View.hpp>
#include <algorithm>
#include <cmath>
#include <optional>
#include <vector>

class GroundBand {
  public:
    explicit GroundBand(const GroundStreamConfig& cfg)
        : m_bandHeightRatio(cfg.bandHeightRatio), m_cellWidth(cfg.cellWidth),
          m_cellsPerBlock(cfg.cellsPerBlock), m_gapPattern(cfg.gapPattern) {}

    // Rebuild the set of collidable ground rectangles for the current camera view.
    void updateForView(const sf::View& view) {
        const ViewBandInfo info = computeViewBandInfo(view);

        std::vector<sf::FloatRect> solids;
        const int                  blockCount = std::max(0, info.lastBlock - info.firstBlock + 1);
        // Worst case: 2 solids per block (left + right of gap).
        solids.reserve(blockCount * 2);

        for (int block = info.firstBlock; block <= info.lastBlock; ++block)
            appendSolidsForBlock(block, info, solids);

        m_collider.setRectColliders(std::move(solids));
    }

    // Access to ground collider used by physics / actors
    const MultiRectCollider& getCollider() const { return m_collider; }

    // Top Y of the collidable band for a given view.
    float getTopYForView(const sf::View& view) const { return computeViewBandInfo(view).y; }

    // Computes gap rectangles for the given view in world space.
    void gapsForView(const sf::View& view, std::vector<GroundGap>& outGaps) const {
        outGaps.clear();

        const ViewBandInfo info = computeViewBandInfo(view);

        for (int block = info.firstBlock; block <= info.lastBlock; ++block) {
            const std::optional<sf::FloatRect> gapOpt =
                computeGapForBlock(block, info.y, info.height);
            if (!gapOpt)
                continue;

            const sf::FloatRect& gap              = *gapOpt;
            const float          gapL             = geom::left(gap);
            const float          gapR             = gapL + geom::width(gap);
            const bool           gapIsLeftOfView  = gapR < info.viewLeft;
            const bool           gapIsRightOfView = gapL > info.viewRight;
            if (gapIsLeftOfView || gapIsRightOfView)
                continue;

            GroundGap groundGap;
            groundGap.rect       = gap;
            groundGap.blockIndex = block;
            outGaps.push_back(groundGap);
        }
    }

  private:
    struct ViewBandInfo {
        float y          = 0.f;
        float height     = 0.f;
        float viewLeft   = 0.f;
        float viewRight  = 0.f;
        int   firstBlock = 0;
        int   lastBlock  = -1;
    };

    ViewBandInfo computeViewBandInfo(const sf::View& view) const {
        ViewBandInfo info;

        const sf::Vector2f viewSize   = view.getSize();
        const sf::Vector2f viewCenter = view.getCenter();

        info.viewLeft  = viewCenter.x - 0.5f * viewSize.x;
        info.viewRight = info.viewLeft + viewSize.x;

        info.height = viewSize.y * m_bandHeightRatio;
        info.y      = (viewCenter.y - 0.5f * viewSize.y) + (viewSize.y - info.height);

        const int firstCell = static_cast<int>(std::floor(info.viewLeft / m_cellWidth));
        const int lastCell  = static_cast<int>(std::ceil(info.viewRight / m_cellWidth));

        info.firstBlock = math::floorDivInt(firstCell, m_cellsPerBlock) - 1;
        info.lastBlock  = math::floorDivInt(lastCell, m_cellsPerBlock) + 1;

        return info;
    }

    // Returns the world-space rectangle of the gap within this block, if any.
    // - Gap width/position is fully decided by m_gapPattern
    // - Pattern can decide per-block to have or not have a gap (nullopt).
    std::optional<sf::FloatRect> computeGapForBlock(int blockIdx, float y, float h) const {
        if (m_cellsPerBlock <= 1)
            return std::nullopt;

        // By design, m_gapPattern is always set (defaults to "no gaps").
        return m_gapPattern(blockIdx, y, h, m_cellWidth, m_cellsPerBlock);
    }

    // Appends solid segments of a block, clipped to [viewLeft, viewRight].
    void appendSolidsForBlock(int blockIdx, const ViewBandInfo& info,
                              std::vector<sf::FloatRect>& out) const {
        const int   anchor = blockIdx * m_cellsPerBlock;
        const float blockL = anchor * m_cellWidth;
        const float blockR = (anchor + m_cellsPerBlock) * m_cellWidth;

        auto clipPush = [&](float L, float R) {
            const float left  = std::max(L, info.viewLeft);
            const float right = std::min(R, info.viewRight);
            if (right > left)
                out.emplace_back(sf::FloatRect{{left, info.y}, {right - left, info.height}});
        };

        const std::optional<sf::FloatRect> gapOpt =
            computeGapForBlock(blockIdx, info.y, info.height);

        if (gapOpt) {
            const sf::FloatRect& gap  = *gapOpt;
            const float          gapL = geom::left(gap);
            const float          gapR = gapL + geom::width(gap);

            clipPush(blockL, gapL); // left solid
            clipPush(gapR, blockR); // right solid
        } else {
            clipPush(blockL, blockR); // full block solid
        }
    }

  private:
    float        m_bandHeightRatio;
    float        m_cellWidth;
    int          m_cellsPerBlock;
    GapPatternFn m_gapPattern;

    MultiRectCollider m_collider;
};

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/environment/ground/GroundBand.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/environment/ground/GroundHazardCatalog.cpp =====
#include "environment/ground/GroundHazardCatalog.h"

#include "core/Assets.h"

const GroundHazardDef& getGroundHazardDef(HazardType type) {
    static const GroundHazardDef kNone{
        HazardType::None,
        HazardStyle{},
        false,
    };

    static const GroundHazardDef kLava{
        HazardType::Lava,
        HazardStyle{Assets::Tex::Environment::Ground::Lava, 6.f, 85.f},
        true,
    };

    static const GroundHazardDef kHole{
        HazardType::Hole,
        HazardStyle{{}, 1.f, 0.f},
        true,
    };

    switch (type) {
    case HazardType::Lava:
        return kLava;
    case HazardType::Hole:
        return kHole;
    case HazardType::None:
    default:
        return kNone;
    }
}

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/environment/ground/GroundHazardCatalog.cpp =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/environment/ground/GroundHazardCatalog.h =====
#pragma once

#include "environment/ground/GroundTypes.h"

// Data defining how a particular ground hazard should look and behave.
struct GroundHazardDef {
    HazardType  type = HazardType::None;
    HazardStyle style{};
    bool        lethal = true;
};

// Returns a shared definition for the given hazard type.
// Callers should not modify the returned object.
const GroundHazardDef& getGroundHazardDef(HazardType type);

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/environment/ground/GroundHazardCatalog.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/environment/ground/GroundTypes.h =====
#pragma once

#include "environment/StripUtil.h"
#include "utils/Math.h"

#include <SFML/Graphics/Rect.hpp>
#include <cstdint>
#include <functional>
#include <optional>
#include <string_view>

// Types of hazards that can fill ground gaps.
enum class HazardType {
    None, // gaps are just empty pits, no separate hazard band
    Lava,
    Hole,
    Water,
    Spikes,
};

// A single gap instance in world space, with its originating block index.
struct GroundGap {
    sf::FloatRect rect{};
    int           blockIndex = 0;
};

struct HazardStyle {
    std::string_view texturePath{};
    float            scale   = 1.f;
    float            yOffset = 0.f;
};

struct HazardConfig {
    HazardStyle lava;              // animated lava band
    HazardStyle hole;              // simple filled gap (no texture)
    float       holeChance = 0.5f; // [0,1]: fraction of gaps rendered as holes
    bool        enabled    = false;
};

// Function type used to customize how gaps are placed inside blocks.
// Returning std::nullopt means "no gap for this block".
using GapPatternFn = std::function<std::optional<sf::FloatRect>(
    int blockIdx, float y, float h, float cellWidth, int cellsPerBlock)>;

// --- Standard gap patterns --------------------------------------------------

// "No gaps anywhere" => continuous solid ground.
inline GapPatternFn makeNoGapPattern() {
    return [](int /*blockIdx*/, float /*y*/, float /*h*/, float /*cellWidth*/,
              int /*cellsPerBlock*/) -> std::optional<sf::FloatRect> { return std::nullopt; };
}

// Default deterministic pseudo-random "one gap per block" pattern.
// - Gap width = 1 cell
// - Uses block index as seed, so layout is stable across runs.
inline GapPatternFn makeDefaultRandomGapPattern() {
    return [](int blockIdx, float y, float h, float cellWidth,
              int cellsPerBlock) -> std::optional<sf::FloatRect> {
        if (cellsPerBlock <= 1)
            return std::nullopt;

        const int anchor = blockIdx * cellsPerBlock;

        // Hash the anchor so gaps are pseudo-random but deterministic
        const std::uint32_t random = math::mix32(static_cast<std::uint32_t>(anchor));

        // Choose an offset in [1..cellsPerBlock-1] -> keeps gap away from anchor cell
        const int positions = cellsPerBlock - 1;
        const int gapOffset = 1 + static_cast<int>(random % positions);

        // X coordinate of gap's left edge (cell-based)
        const float left = (anchor + gapOffset) * cellWidth;

        // Rect representing the whole vertical band in that gap cell
        return sf::FloatRect{{left, y}, {cellWidth, h}};
    };
}

struct GroundStreamConfig {
    strip::ParallaxLayerDesc visualLayer;

    float bandHeightRatio = 0.05f; // fraction of view height used for the ground band
    float cellWidth       = 220.f; // world units per "cell"
    int   cellsPerBlock   = 5;     // cells per block (potentially 1 gap per block)

    // Always-present pattern. Default: "no gaps".
    GapPatternFn gapPattern = makeNoGapPattern();

    HazardConfig hazard; // what fills the gaps visually / as a hazard
};

namespace GroundPresets {

    inline GroundStreamConfig solidFloor(const strip::ParallaxLayerDesc& visualLayer) {
        GroundStreamConfig cfg;
        cfg.visualLayer = visualLayer;
        cfg.gapPattern  = makeNoGapPattern(); // explicit: continuous floor
        cfg.hazard      = HazardConfig{};
        return cfg;
    }

    inline GroundStreamConfig gapsWithoutHazard(const strip::ParallaxLayerDesc& visualLayer) {
        GroundStreamConfig cfg = solidFloor(visualLayer);
        cfg.gapPattern         = makeDefaultRandomGapPattern(); // now actually has gaps
        return cfg;
    }

    inline GroundStreamConfig gapsWithHazard(const strip::ParallaxLayerDesc& visualLayer,
                                             const HazardConfig&             hazard) {
        GroundStreamConfig cfg = gapsWithoutHazard(visualLayer);
        cfg.hazard             = hazard;
        return cfg;
    }

} // namespace GroundPresets

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/environment/ground/GroundTypes.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/environment/ground/HazardLayer.h =====
#pragma once

#include "animation/Animation.h"
#include "core/Assets.h"
#include "core/ResourceManager.h"
#include "environment/ground/GroundTypes.h"
#include "utils/Geom.h"
#include "utils/Math.h"

#include <SFML/Graphics.hpp>
#include <algorithm>
#include <limits>
#include <memory>
#include <vector>

// Handles rendering and collision detection for hazards that occupy ground gaps.
class HazardLayer {
  public:
    explicit HazardLayer(const HazardConfig& config) : m_cfg(config) {}

    // Call once after construction.
    bool init() {
        if (!m_cfg.enabled)
            return true; // Nothing to set up.

        if (m_cfg.lava.texturePath.empty())
            return true; // Only hole hazards enabled; no texture to load.

        sf::Texture& texture = ResourceManager::getTexture(m_cfg.lava.texturePath);

        // Build an animation clip from a sheet (50x50 frames, first 2x2 area, 6 fps, looping).
        m_clip = Animation::makeClipFromSheet("hazard", texture, {50, 50}, // frame size
                                              {0, 0},                      // first cell
                                              {1, 1},                      // last cell
                                              6.f,                         // fps
                                              true);                       // looping

        // Create sprite + animator bound to that sprite.
        m_sprite   = std::make_unique<sf::Sprite>(texture);
        m_animator = std::make_unique<SpriteAnimator>(*m_sprite);

        // Register clip and start playing it.
        m_clipId = m_animator->addClip(m_clip);
        m_animator->playClip(m_clipId);

        return true;
    }

    void update(float dt) {
        if (m_animator)
            m_animator->update(dt);
    }

    bool hasHazard() const { return m_cfg.enabled; }

    void drawForView(sf::RenderTarget&             target, const sf::View& /*view*/,
                     const std::vector<GroundGap>& gaps) {
        if (!m_cfg.enabled)
            return;

        for (const auto& gap : gaps) {
            const HazardType type = pickHazardForBlock(gap.blockIndex);
            switch (type) {
            case HazardType::Hole:
                drawHoleGap(target, gap.rect);
                break;
            case HazardType::Lava:
                drawLavaGap(target, gap.rect);
                break;
            default:
                break;
            }
        }
    }

    bool intersectsHazard(const sf::FloatRect& aabb, const std::vector<GroundGap>& gaps) const {
        if (!m_cfg.enabled)
            return false;

        for (const auto& gap : gaps) {
            if (geom::aabbIntersects(aabb, gap.rect))
                return true;
        }
        return false;
    }

  private:
    HazardType pickHazardForBlock(int blockIndex) const {
        if (!m_cfg.enabled)
            return HazardType::None;

        const float clampedHoleChance = std::clamp(m_cfg.holeChance, 0.f, 1.f);
        if (clampedHoleChance <= 0.f)
            return HazardType::Lava;
        if (clampedHoleChance >= 1.f)
            return HazardType::Hole;

        const std::uint32_t hash       = math::mix32(static_cast<std::uint32_t>(blockIndex));
        const float         unitRandom = static_cast<float>(hash) /
                                 static_cast<float>(std::numeric_limits<std::uint32_t>::max());
        if (unitRandom < clampedHoleChance)
            return HazardType::Hole;

        return HazardType::Lava;
    }

    void drawLavaGap(sf::RenderTarget& target, const sf::FloatRect& gap) const {
        if (!m_sprite)
            return;

        const sf::IntRect frame       = m_sprite->getTextureRect();
        const float       frameWidth  = static_cast<float>(std::max(1, frame.size.x));
        const float       frameHeight = static_cast<float>(std::max(1, frame.size.y));

        m_sprite->setOrigin({frameWidth * 0.5f, frameHeight * 0.5f});
        m_sprite->setScale({m_cfg.lava.scale, m_cfg.lava.scale});

        const float centerX = gap.position.x + 0.5f * gap.size.x;
        const float centerY = gap.position.y + 0.5f * gap.size.y - m_cfg.lava.yOffset;

        m_sprite->setPosition({centerX, centerY});
        target.draw(*m_sprite);
    }

    void drawHoleGap(sf::RenderTarget& target, const sf::FloatRect& gap) const {
        sf::RectangleShape holeShape;
        holeShape.setPosition(gap.position);
        holeShape.setSize(gap.size);
        holeShape.setFillColor(sf::Color::Black);
        target.draw(holeShape);
    }

    HazardConfig m_cfg;

    std::unique_ptr<sf::Sprite>     m_sprite;
    std::unique_ptr<SpriteAnimator> m_animator;
    AnimationClip                   m_clip;
    SpriteAnimator::ClipId          m_clipId = SpriteAnimator::kInvalidClip;
};

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/environment/ground/HazardLayer.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/gameplay/Damage.h =====
#pragma once

#include "collision/CollisionLayers.h"
#include "utils/Geom.h"
#include "utils/Math.h"

#include <SFML/System/Vector2.hpp>

class Entity;

// Basic damage payload passed from collision/system code to actors.
// Kept small on purpose; extend with knockback, damage types, etc. when needed.
struct DamageInfo {
    float          amount = 0.f;                       // raw HP loss for this hit
    sf::Vector2f   hitPoint{0.f, 0.f};                 // world-space point of impact (best-effort)
    sf::Vector2f   hitDir{0.f, 0.f};                   // normalized direction into the victim
    const Entity*  source      = nullptr;              // non-owning pointer to the damage source
    CollisionLayer collideWith = CollisionLayer::None; // layer of the source

    // Future extensions:
    // float      knockbackStrength = 0.f;       // scalar used by actors for physics response
    // float      bloodAmount       = 0.f;       // hints for VFX systems
    // DamageType type              = DamageType::Generic;
};

// Helper to build a basic DamageInfo from two AABBs and an optional damage source.
inline DamageInfo buildDamageInfo(float amount, const Entity* source,
                                  const sf::FloatRect& victimAabb,
                                  const sf::FloatRect* sourceAabb = nullptr) {
    DamageInfo info{};
    info.amount      = amount;
    info.source      = source;
    info.collideWith = source ? source->getCollisionLayer() : CollisionLayer::None;

    // Approximate hit point: center of overlap if possible, otherwise victim center.
    if (sourceAabb) {
        sf::FloatRect overlap;
        if (geom::aabbIntersects(*sourceAabb, victimAabb, overlap)) {
            info.hitPoint = {overlap.position.x + overlap.size.x * 0.5f,
                             overlap.position.y + overlap.size.y * 0.5f};
        } else {
            info.hitPoint = {victimAabb.position.x + victimAabb.size.x * 0.5f,
                             victimAabb.position.y + victimAabb.size.y * 0.5f};
        }
    } else {
        info.hitPoint = {victimAabb.position.x + victimAabb.size.x * 0.5f,
                         victimAabb.position.y + victimAabb.size.y * 0.5f};
    }

    // Hit direction points into the victim from the impact point (best-effort).
    const sf::Vector2f victimCenter{victimAabb.position.x + victimAabb.size.x * 0.5f,
                                    victimAabb.position.y + victimAabb.size.y * 0.5f};
    info.hitDir = math::normalizeVec(victimCenter - info.hitPoint);

    return info;
}

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/gameplay/Damage.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/gameplay/Faction.h =====
// src/game/Faction.h
#pragma once

enum class Faction { Player, Enemy };

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/gameplay/Faction.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/gameplay/GameSession.h =====
#pragma once

#include "utils/Stopwatch.h"

class GameSession {
  public:
    void start() {
        m_clock.reset();
        m_score      = 0;
        m_scoreAccum = 0.f;
    }

    void update(float dt) { m_clock.tick(dt); }

    float elapsedSeconds() const { return m_clock.getElapsed(); }

    void addScore(int pts) {
        if (pts <= 0)
            return;
        m_score += pts;
    }

    void addScorePerSecond(float dt, int ratePerSecond) {
        m_scoreAccum += dt;
        while (m_scoreAccum >= 1.f) {
            m_score += ratePerSecond;
            m_scoreAccum -= 1.f;
        }
    }

    int score() const { return m_score; }

  private:
    Stopwatch m_clock;
    int       m_score      = 0;
    float     m_scoreAccum = 0.f;
    // Level data can be added later.
};

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/gameplay/GameSession.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/physics/PhysicsBody.h =====
#pragma once

#include <SFML/System/Vector2.hpp>
#include <cstdint>

class Entity;

// Configuration for how a body participates in physics.
struct PhysicsBodyConfig {
    bool enabled       = true;
    bool isKinematic   = false; // if true, physics does not integrate position/velocity
    bool useGravity    = true;
    bool topOnlyGround = true; // if true, only resolve top contacts (platformer-style)

    // Scale applied to the global gravity configured on PhysicsSystem.
    // 1.0 = normal gravity, 0.0 = no gravity, >1.0 = stronger gravity.
    float gravityScale = 1.f;

    float maxVelX = 3000.f;
    float maxVelY = 3000.f;

    // Bitmask of StaticSolidSide flags representing which sides of static solids this body
    // collides against horizontally (left/right). A value of 0 disables side collisions.
    std::uint8_t sideMask = 0;
};

// Per-entity physics state owned by PhysicsSystem.
struct PhysicsBody {
    Entity*           owner = nullptr; // non-owning
    PhysicsBodyConfig config;

    bool grounded = false;
};

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/physics/PhysicsBody.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/physics/PhysicsSystem.cpp =====
#include "physics/PhysicsSystem.h"

#include "collision/RectCollider.h"
#include "entities/Entity.h"
#include "physics/StaticWorldGeometry.h"
#include "utils/Geom.h"
#include "utils/Math.h"

#include <SFML/Graphics/Rect.hpp>
#include <algorithm>
#include <limits>

void PhysicsSystem::registerBody(Entity& owner, const PhysicsBodyConfig& config) {
    // If already present, just update config.
    for (auto& body : m_bodies) {
        if (body.owner == &owner) {
            body.config = config;
            return;
        }
    }

    PhysicsBody body;
    body.owner    = &owner;
    body.config   = config;
    body.grounded = false;
    m_bodies.push_back(body);
}

void PhysicsSystem::unregisterBody(const Entity& owner) {
    m_bodies.erase(
        std::remove_if(m_bodies.begin(), m_bodies.end(),
                       [&owner](const PhysicsBody& body) { return body.owner == &owner; }),
        m_bodies.end());
}

PhysicsBody* PhysicsSystem::findBody(Entity& owner) {
    for (auto& body : m_bodies) {
        if (body.owner == &owner)
            return &body;
    }
    return nullptr;
}

const PhysicsBody* PhysicsSystem::findBody(const Entity& owner) const {
    for (const auto& body : m_bodies) {
        if (body.owner == &owner)
            return &body;
    }
    return nullptr;
}

void PhysicsSystem::step(float dt, const StaticWorldGeometry* staticWorld) {
    if (dt <= 0.f || !staticWorld)
        return;

    for (auto& body : m_bodies) {
        if (!body.owner || !body.config.enabled)
            continue;
        if (!body.owner->isAlive())
            continue;

        integrateBody(body, dt, staticWorld);
    }
}

void PhysicsSystem::integrateBody(PhysicsBody& body, float dt,
                                  const StaticWorldGeometry* staticWorld) {
    Entity& owner = *body.owner;

    if (body.config.isKinematic) {
        // Kinematic bodies are controlled entirely by gameplay code.
        // Clear grounded flag; callers can override if they treat themselves as grounded.
        body.grounded = false;
        return;
    }

    // Fetch current state from the entity.
    sf::Vector2f position = owner.getPosition();
    sf::Vector2f velocity = owner.getVelocity();

    // Forces + clamping.
    applyForces(body, velocity, dt);

    // Cache vertical delta for ground resolution.
    const float dy = velocity.y * dt;

    body.grounded = false;

    // Integrate position on both axes.
    integratePosition(owner, position, velocity, dt);

    // Top-only ground resolution matches previous Actor::applyPhysics() behavior.
    if (body.config.topOnlyGround && velocity.y >= 0.f) {
        resolveVerticalGroundContacts(body, owner, position, velocity, dy, *staticWorld);
    }

    // Horizontal side collisions against static world walls.
    if (body.config.sideMask != 0 && velocity.x != 0.f) {
        resolveHorizontalContacts(body, owner, position, velocity, *staticWorld);
    }

    // Push updated velocity back to the entity.
    owner.setVelocity(velocity);
}

void PhysicsSystem::applyForces(PhysicsBody& body, sf::Vector2f& velocity, float dt) {
    // Apply gravity using global gravity magnitude scaled per body.
    if (body.config.useGravity) {
        velocity.y += m_gravity * body.config.gravityScale * dt;
    }

    // Clamp speeds to configured maximum magnitudes.
    velocity.x = math::clampToMagnitude(velocity.x, body.config.maxVelX);
    velocity.y = math::clampToMagnitude(velocity.y, body.config.maxVelY);
}

void PhysicsSystem::integratePosition(Entity& owner, sf::Vector2f& position,
                                      const sf::Vector2f& velocity, float dt) {
    const float dx = velocity.x * dt;
    const float dy = velocity.y * dt;

    if (dx != 0.f || dy != 0.f) {
        if (dx != 0.f) {
            position.x += dx;
            owner.setPosition(position);
        }

        if (dy != 0.f) {
            position.y += dy;
            owner.setPosition(position);
        }
    } else {
        // No movement this frame; still need collider below for precise grounding.
        owner.setPosition(position);
    }
}

void PhysicsSystem::resolveVerticalGroundContacts(PhysicsBody& body, Entity& owner,
                                                  sf::Vector2f& position, sf::Vector2f& velocity,
                                                  float                      dy,
                                                  const StaticWorldGeometry& staticWorld) {
    const sf::FloatRect actorCollider = owner.getCollider().worldAabb();

    // Previous frame actor position on Y.
    sf::FloatRect prevActor = actorCollider;
    prevActor.position.y -= dy;

    float bestLiftDy  = -std::numeric_limits<float>::infinity();
    bool  touchingTop = false;

    auto consider = [&](const sf::FloatRect& groundCollider) {
        // Track exact top contact for zero-motion cases.
        if (velocity.y == 0.f && geom::touchTop(actorCollider, groundCollider, 0.75f))
            touchingTop = true;

        const float groundTop    = geom::top(groundCollider);
        const float prevBottom   = geom::bottom(prevActor);
        const float currentB     = geom::bottom(actorCollider);
        const float currentLeft  = geom::left(actorCollider);
        const float currentRight = geom::right(actorCollider);
        const float groundLeft   = geom::left(groundCollider);
        const float groundRight  = geom::right(groundCollider);

        // Require horizontal overlap to stand on top.
        if (currentRight <= groundLeft || currentLeft >= groundRight)
            return;

        constexpr float kTopEps = 0.001f;
        if (prevBottom > groundTop + kTopEps)
            return; // not a landing from above
        if (currentB < groundTop - kTopEps)
            return; // still above top

        const float deltaY = groundTop - currentB;
        if (deltaY > bestLiftDy)
            bestLiftDy = deltaY;
    };

    for (const StaticSolid& solid : staticWorld.solids) {
        if (!hasSide(solid.sides, StaticSolidSide::SolidSide_Top))
            continue;
        consider(solid.rect);
    }

    if (bestLiftDy > -std::numeric_limits<float>::infinity()) {
        position.y += bestLiftDy;
        owner.setPosition(position);
        velocity.y    = 0.f;
        body.grounded = true;
    } else if (touchingTop) {
        body.grounded = true;
    }
}

void PhysicsSystem::resolveHorizontalContacts(PhysicsBody& body, Entity& owner,
                                              sf::Vector2f& position, sf::Vector2f& velocity,
                                              const StaticWorldGeometry& staticWorld) {
    if (velocity.x == 0.f)
        return;

    const bool movingRight = velocity.x > 0.f;
    const bool movingLeft  = velocity.x < 0.f;
    if (!movingRight && !movingLeft)
        return;

    sf::FloatRect actorCollider = owner.getCollider().worldAabb();

    float bestPushX = 0.f;
    bool  collided  = false;

    for (const StaticSolid& solid : staticWorld.solids) {
        // Treat ground band, obstacles as walls.
        if (solid.kind != StaticSolidKind::Obstacle
            /* && solid.kind != StaticSolidKind::Platform */
            && solid.kind != StaticSolidKind::GroundBand)
            continue;

        if (movingRight) {
            if (!hasSide(body.config.sideMask, StaticSolidSide::SolidSide_Left))
                continue;
            if (!hasSide(solid.sides, StaticSolidSide::SolidSide_Left))
                continue;
        } else if (movingLeft) {
            if (!hasSide(body.config.sideMask, StaticSolidSide::SolidSide_Right))
                continue;
            if (!hasSide(solid.sides, StaticSolidSide::SolidSide_Right))
                continue;
        }

        sf::FloatRect overlap;
        if (!geom::aabbIntersects(actorCollider, solid.rect, overlap))
            continue;

        float pushX = 0.f;
        if (movingRight) {
            pushX = -overlap.size.x;
            if (!collided || pushX < bestPushX) {
                bestPushX = pushX;
                collided  = true;
            }
        } else if (movingLeft) {
            pushX = overlap.size.x;
            if (!collided || pushX > bestPushX) {
                bestPushX = pushX;
                collided  = true;
            }
        }
    }

    if (collided && bestPushX != 0.f) {
        position.x += bestPushX;
        owner.setPosition(position);
        velocity.x = 0.f;
    }
}

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/physics/PhysicsSystem.cpp =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/physics/PhysicsSystem.h =====
#pragma once

#include "physics/PhysicsBody.h"

#include <SFML/System/Vector2.hpp>
#include <vector>

struct StaticWorldGeometry;

class Entity;

// Lightweight physics system responsible for integrating velocities and
// resolving collisions against static world solids (ground, obstacles, platforms).
//
// It operates purely on Entity position/velocity and collider AABBs; gameplay
// systems remain responsible for damage, scoring, etc.
class PhysicsSystem {
  public:
    PhysicsSystem()  = default;
    ~PhysicsSystem() = default;

    // Registers a body for the given entity. If the entity is already registered,
    // its config is updated.
    void registerBody(Entity& owner, const PhysicsBodyConfig& config);

    // Removes any body associated with the given entity.
    void unregisterBody(const Entity& owner);

    // Returns the physics body for the entity, or nullptr if none.
    PhysicsBody*       findBody(Entity& owner);
    const PhysicsBody* findBody(const Entity& owner) const;

    // Steps physics for all registered bodies.
    //
    // dt:          frame delta time in seconds.
    // staticWorld: combined geometry for all static solids (ground, obstacles, platforms).
    void step(float dt, const StaticWorldGeometry* staticWorld);

    // Global gravity magnitude in pixels per second^2.
    // Bodies use this multiplied by their gravityScale when useGravity is true.
    void  setGravity(float g) { m_gravity = g; }
    float getGravity() const { return m_gravity; }

  private:
    std::vector<PhysicsBody> m_bodies;

    float m_gravity = 2400.f;

    // Integrates a single body for one frame: forces, position, and contacts.
    void integrateBody(PhysicsBody& body, float dt, const StaticWorldGeometry* staticWorld);

    // Apply per-body forces (currently gravity) and clamp velocity.
    void applyForces(PhysicsBody& body, sf::Vector2f& velocity, float dt);

    // Integrate position from velocity and write back via Entity::setPosition.
    void integratePosition(Entity& owner, sf::Vector2f& position, const sf::Vector2f& velocity,
                           float dt);

    // Resolve vertical top-only contacts against static world and update grounded/velocity.
    void resolveVerticalGroundContacts(PhysicsBody& body, Entity& owner, sf::Vector2f& position,
                                       sf::Vector2f& velocity, float dy,
                                       const StaticWorldGeometry& staticWorld);

    // Resolve horizontal collisions against static world walls (left/right sides of solids).
    void resolveHorizontalContacts(PhysicsBody& body, Entity& owner, sf::Vector2f& position,
                                   sf::Vector2f& velocity, const StaticWorldGeometry& staticWorld);
};

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/physics/PhysicsSystem.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/physics/StaticWorldGeometry.h =====
#pragma once

#include <SFML/Graphics/Rect.hpp>
#include <cstdint>
#include <vector>

// Kind of static solid in the world: environment ground band, platforms, obstacles.
enum class StaticSolidKind : std::uint8_t {
    GroundBand,
    Platform,
    Obstacle,
};

// Which side(s) of a solid are collidable.
enum StaticSolidSide : std::uint8_t {
    SolidSide_None   = 0,
    SolidSide_Top    = 1u << 0,
    SolidSide_Bottom = 1u << 1,
    SolidSide_Left   = 1u << 2,
    SolidSide_Right  = 1u << 3,
};

inline StaticSolidSide operator|(StaticSolidSide a, StaticSolidSide b) {
    return static_cast<StaticSolidSide>(static_cast<std::uint8_t>(a) |
                                        static_cast<std::uint8_t>(b));
}

inline bool hasSide(std::uint8_t flags, StaticSolidSide side) {
    return (flags & static_cast<std::uint8_t>(side)) != 0;
}

// One static solid piece in the world.
struct StaticSolid {
    sf::FloatRect   rect;
    StaticSolidKind kind  = StaticSolidKind::GroundBand;
    std::uint8_t    sides = static_cast<std::uint8_t>(StaticSolidSide::SolidSide_None);
};

// Aggregated static world geometry consumed by the physics system.
struct StaticWorldGeometry {
    std::vector<StaticSolid> solids;
};

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/physics/StaticWorldGeometry.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/physics/StaticWorldGeometryBuilder.cpp =====
#include "physics/StaticWorldGeometryBuilder.h"

#include "collision/CollisionLayers.h"
#include "collision/MultiRectCollider.h"
#include "entities/Entity.h"

namespace physics {
    StaticWorldGeometry
    buildStaticWorldGeometry(const MultiRectCollider*                    groundCollider,
                             const std::vector<std::unique_ptr<Entity>>& entities) {
        StaticWorldGeometry geometry;
        auto&               solids = geometry.solids;

        constexpr float kSideThickness = 4.f;

        const auto appendTopAndWalls = [&](const sf::FloatRect& rect, StaticSolidKind kind,
                                           bool fullTopRect) {
            const float left   = rect.position.x;
            const float top    = rect.position.y;
            const float width  = rect.size.x;
            const float height = rect.size.y;

            // Top surface: used for grounding. For ground band we keep the full rect (top-only)
            // since vertical resolution only cares about `top()`, but other solids can use a thin
            // strip.
            solids.push_back(StaticSolid{
                fullTopRect ? rect : sf::FloatRect{{left, top}, {width, kSideThickness}},
                kind,
                static_cast<std::uint8_t>(StaticSolidSide::SolidSide_Top),
            });

            // Left wall.
            solids.push_back(StaticSolid{
                sf::FloatRect{{left, top}, {kSideThickness, height}},
                kind,
                static_cast<std::uint8_t>(StaticSolidSide::SolidSide_Left),
            });

            // Right wall.
            solids.push_back(StaticSolid{
                sf::FloatRect{{left + width - kSideThickness, top}, {kSideThickness, height}},
                kind,
                static_cast<std::uint8_t>(StaticSolidSide::SolidSide_Right),
            });
        };

        // 1) Ground band -> top-only surfaces + walls for the physics side-collisions.
        if (groundCollider) {
            const auto& colliderRects = groundCollider->getRectColliders();
            solids.reserve(solids.size() + (colliderRects.size() * 3u));
            for (const auto& groundRect : colliderRects)
                appendTopAndWalls(groundRect, StaticSolidKind::GroundBand, /*fullTopRect=*/true);
        }

        // 2) Platforms and obstacles -> split into top + walls.
        solids.reserve(solids.size() + (entities.size() * 3u));
        for (const auto& entity : entities) {
            if (!entity || !entity->isAlive())
                continue;

            const CollisionLayer layer = entity->getCollisionLayer();
            if (layer != CollisionLayer::Obstacle && layer != CollisionLayer::Platform)
                continue;

            const sf::FloatRect bounds = entity->getCollider().worldAabb();
            StaticSolidKind     kind   = StaticSolidKind::Platform;
            if (layer == CollisionLayer::Obstacle)
                kind = StaticSolidKind::Obstacle;
            appendTopAndWalls(bounds, kind, /*fullTopRect=*/false);
        }

        return geometry;
    }
} // namespace physics

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/physics/StaticWorldGeometryBuilder.cpp =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/physics/StaticWorldGeometryBuilder.h =====
#pragma once

#include "physics/StaticWorldGeometry.h"

#include <memory>
#include <vector>

class Entity;
class MultiRectCollider;

namespace physics {
    StaticWorldGeometry
    buildStaticWorldGeometry(const MultiRectCollider*                    groundCollider,
                             const std::vector<std::unique_ptr<Entity>>& entities);
} // namespace physics

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/physics/StaticWorldGeometryBuilder.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/spell/CastRequest.h =====
#pragma once
#include "gameplay/Faction.h"
#include "spell/SpellCatalog.h"

#include <SFML/Graphics.hpp>

struct CastRequest {
    bool         hasValue = false;
    SpellId      spellId  = SpellId::IceBolt;
    Faction      faction  = Faction::Player;
    sf::Vector2f origin{0.f, 0.f};
    sf::Vector2f direction{1.f, 0.f};
};

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/spell/CastRequest.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/spell/SpellCatalog.cpp =====
#include "spell/SpellCatalog.h"

#include "core/Assets.h"

// Ice Bolt
static SpellDef makeIceBolt() {
    SpellDef def;
    def.type = SpellType::Projectile;

    // Gameplay
    def.stats.damage       = 25.f;
    def.stats.manaCost     = 10.f;
    def.stats.applySlow    = true;
    def.stats.slowPercent  = 0.50f;
    def.stats.slowDuration = 5.0f;

    def.stats.projectile.speed        = 1600.f;
    def.stats.projectile.lifetime     = 1.0f;
    def.stats.projectile.colliderSize = {18.f, 8.f};

    // Visuals
    def.visuals.start = {std::string(Assets::Tex::Spell::Icebolt::Start), {48, 32}, 3, 16.f, false};
    def.visuals.loop  = {std::string(Assets::Tex::Spell::Icebolt::Loop), {48, 32}, 10, 16.f, true};
    def.visuals.hit   = {std::string(Assets::Tex::Spell::Icebolt::Hit), {48, 32}, 7, 16.f, false};
    return def;
}

// Lightning
static SpellDef makeLightning() {
    SpellDef def;
    def.type = SpellType::Projectile;

    // Gameplay
    def.stats.damage   = 10.f;
    def.stats.manaCost = 10.f;

    def.stats.projectile.speed        = 900.f;
    def.stats.projectile.lifetime     = 1.2f;
    def.stats.projectile.colliderSize = {16.f, 8.f};

    // Visuals
    def.visuals.start = {
        std::string(Assets::Tex::Spell::Lightning::Start), {32, 32}, 5, 16.f, false};
    def.visuals.loop = {std::string(Assets::Tex::Spell::Lightning::Loop), {32, 32}, 5, 12.f, true};
    def.visuals.hit  = {std::string(Assets::Tex::Spell::Lightning::Hit), {32, 32}, 6, 16.f, false};
    return def;
}

/* static SpellDef makeFireball() {
    SpellDef def;
    def.type = SpellType::Projectile;

    // Gameplay
    def.stats.damage       = 15.f;
    def.stats.manaCost     = 15.f;

    def.stats.projectile.speed        = 800.f;
    def.stats.projectile.lifetime     = 1.2f;
    def.stats.projectile.colliderSize = {16.f, 8.f};

    // Visuals
    def.visuals.start = {
        std::string(Assets::Tex::Spell::Fireball::Start), {32, 32}, 5, 16.f, false};
    def.visuals.loop = {std::string(Assets::Tex::Spell::Fireball::Loop), {32, 32}, 5, 12.f, true};
    def.visuals.hit  = {std::string(Assets::Tex::Spell::Fireball::Hit), {32, 32}, 6, 16.f, false};
    return def;
} */

const SpellDef& getSpellDef(SpellId id) {
    static const SpellDef ICE       = makeIceBolt();
    static const SpellDef LIGHTNING = makeLightning();
    switch (id) {
    case SpellId::IceBolt:
        return ICE;
    case SpellId::Lightning:
        return LIGHTNING;
    }
    return ICE;
}

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/spell/SpellCatalog.cpp =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/spell/SpellCatalog.h =====
#pragma once
#include <SFML/Graphics.hpp>
#include <string>

// Type of spell
enum class SpellType { Projectile, CallDownBeam };

// Visual
struct SpellClip {
    std::string  textureKey;
    sf::Vector2i frameSize;
    int          frameCount;
    float        fps;
    bool         loop;
};

struct SpellVisuals {
    SpellClip start, loop, hit;
};

// Stats
struct SpellStats {
    // Common
    float manaCost     = 20.f;
    float damage       = 10.f;
    bool  applySlow    = false;
    float slowPercent  = 0.f; // 0..1
    float slowDuration = 0.f; // seconds

    // Projectile
    struct Projectile {
        float        speed    = 600.f;
        float        lifetime = 1.0f;
        sf::Vector2f colliderSize{12.f, 4.f};
        bool         impactSpawnsAoe = false;
        float        impactAoeRadius = 0.f;
    } projectile;
};

// Spell identifier
enum class SpellId { IceBolt, Lightning };

// Spell definition
struct SpellDef {
    SpellType    type;
    SpellStats   stats;
    SpellVisuals visuals;
};

// Retrieve spell definition by ID
const SpellDef& getSpellDef(SpellId id);

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/spell/SpellCatalog.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/spell/projectile/Projectile.cpp =====
#include "spell/projectile/Projectile.h"

#include "collision/CollisionLayers.h"
#include "core/Config.h"
#include "core/Debug.h"
#include "core/ResourceManager.h"
#include "entities/Entity.h"
#include "utils/Math.h"

static inline AnimationClip makeClipFromSpell(const std::string& name, const SpellClip& spell) {
    const sf::Texture& tex = ResourceManager::getTexture(spell.textureKey);
    auto clip = Animation::makeClipFromRow(name, tex, spell.frameSize, spell.frameCount, spell.fps,
                                           spell.loop);
    return clip;
}

Projectile::Projectile(SpellId spellId, Faction faction, const sf::Vector2f& origin,
                       const sf::Vector2f& direction)
    : m_spellId(spellId), m_faction(faction), m_def(getSpellDef(spellId)) {
    const CollisionLayer layer = (faction == Faction::Enemy) ? CollisionLayer::EnemyProjectile
                                                             : CollisionLayer::PlayerProjectile;
    setCollisionLayer(layer);
    if (layer == CollisionLayer::EnemyProjectile) {
        setCollisionMask(maskFrom({CollisionLayer::Player}));
    } else {
        setCollisionMask(maskFrom({CollisionLayer::Enemy, CollisionLayer::Collectible}));
    }

    // Direction / velocity (normalize; fallback +X)
    sf::Vector2f dir = math::normalizeVec(direction);
    if (dir.x == 0.f && dir.y == 0.f)
        dir = {1.f, 0.f};
    m_velocity = dir * m_def.stats.projectile.speed;
    m_lifetime = m_def.stats.projectile.lifetime;

    // Sprite + animator
    const sf::Texture& pStart = ResourceManager::getTexture(m_def.visuals.start.textureKey);
    m_pSprite                 = std::make_unique<sf::Sprite>(pStart);
    m_pAnimator               = std::make_unique<SpriteAnimator>(*m_pSprite);

    // Build animation clips
    buildClips();

    // Initial placement
    m_pSprite->setPosition(origin);
    m_pSprite->setOrigin(sf::Vector2f(static_cast<float>(m_def.visuals.loop.frameSize.x) * 0.5f,
                                      static_cast<float>(m_def.visuals.loop.frameSize.y) * 0.5f));
    const float ang = std::atan2(dir.y, dir.x) * 180.f / 3.14159265f;
    m_pSprite->setRotation(sf::degrees(ang));
    m_pSprite->setScale(sf::Vector2f(2.f, 2.f));

    // Collider
    setColliderSize(m_def.stats.projectile.colliderSize);

    // Enter START phase
    enterStart();
}

void Projectile::buildClips() {
    // Create and register start/loop/hit clips
    m_startClip = m_pAnimator->addClip(makeClipFromSpell("start", m_def.visuals.start));
    m_loopClip  = m_pAnimator->addClip(makeClipFromSpell("loop", m_def.visuals.loop));
    m_hitClip   = m_pAnimator->addClip(makeClipFromSpell("hit", m_def.visuals.hit));
}

void Projectile::enterStart() {
    m_phase = Phase::Start;

    m_pAnimator->playClip(m_startClip, [this]() { enterLoop(); });
}

void Projectile::enterLoop() {
    if (m_phase == Phase::Dead)
        return;
    m_phase = Phase::Loop;
    m_pAnimator->playClip(m_loopClip);
}

void Projectile::enterHit() {
    if (m_phase == Phase::Dead)
        return;
    m_phase = Phase::Hit;

    // Stop moving during the hit
    m_velocity = {0.f, 0.f};

    // When HIT completes, mark dead
    m_pAnimator->playClip(m_hitClip, [this]() {
        m_phase = Phase::Dead;
        setAlive(false);
    });
}

void Projectile::requestImpact() {
    if (!isAlive())
        return;
    if (m_phase == Phase::Hit || m_phase == Phase::Dead)
        return;
    m_hitRequested = true;
}

void Projectile::update(float dt) {
    if (!isAlive())
        return;

    // Lifetime
    if (m_phase != Phase::Hit) {
        m_lifetime -= dt;
        if (m_lifetime <= 0.f) {
            enterHit();
            m_pAnimator->update(dt);
            return;
        }
    }

    // Movement only during Start/Loop
    if (m_phase == Phase::Start || m_phase == Phase::Loop) {
        if (m_pSprite)
            m_pSprite->move(m_velocity * dt);
    }

    // If an impact was requested (by World collision), switch to Hit once
    if (m_hitRequested) {
        m_hitRequested = false;
        enterHit();
    }

    // Animate
    m_pAnimator->update(dt);
}

void Projectile::render(sf::RenderTarget& t) const {
    if (m_pSprite)
        t.draw(*m_pSprite);
    if constexpr (Config::kDebugDraw) {
        Debug::drawSpriteBounds(t, *m_pSprite, sf::Color::Red, 1.f);
        Debug::drawColliderBounds(t, getCollider(), sf::Color::Green, 1.f);
    }
}

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/spell/projectile/Projectile.cpp =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/spell/projectile/Projectile.h =====
#pragma once
#include "animation/Animation.h"
#include "entities/Entity.h"
#include "gameplay/Faction.h"
#include "spell/SpellCatalog.h"
#include "utils/Math.h"

#include <SFML/Graphics.hpp>

class Projectile final : public Entity {
  public:
    Projectile(SpellId spellId, Faction faction, const sf::Vector2f& origin,
               const sf::Vector2f& direction);

    bool init() override { return true; }

    void update(float dt) override;

    // Trigger the impact sequence (World call this on collision)
    void requestImpact();

    // Accessors
    SpellId           getSpellId() const { return m_spellId; }
    Faction           getFaction() const { return m_faction; }
    const SpellStats& getStats() const { return m_def.stats; }

    // Expose current velocity so collision code can derive knockback directions later if needed.
    sf::Vector2f getVelocity() const { return m_velocity; }

    // Hit only one time
    bool isDamageActive() const { return m_phase == Phase::Start || m_phase == Phase::Loop; }

  private:
    void render(sf::RenderTarget& t) const override;

    // Bolt state
    enum class Phase { Start, Loop, Hit, Dead };
    void enterStart();
    void enterLoop();
    void enterHit();

    // Animation setup
    void buildClips();

  private:
    // Properties
    SpellId         m_spellId;
    Faction         m_faction;
    const SpellDef& m_def;

    // Lifetime
    float m_lifetime = 0.f;

    // Phase
    Phase m_phase        = Phase::Start;
    bool  m_hitRequested = false;

    // Animation clip ids
    SpriteAnimator::ClipId m_startClip = SpriteAnimator::kInvalidClip;
    SpriteAnimator::ClipId m_loopClip  = SpriteAnimator::kInvalidClip;
    SpriteAnimator::ClipId m_hitClip   = SpriteAnimator::kInvalidClip;
};

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/spell/projectile/Projectile.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/states/IState.h =====
#pragma once

#include <SFML/Window/Event.hpp>
#include <SFML/Window/Keyboard.hpp>

namespace sf {
    class RenderTarget;
};

class StateStack;

class IState {
  public:
    virtual ~IState() = default;

    virtual bool init()                                 = 0;
    virtual void handleEvent(const sf::Event& event)    = 0;
    virtual void update(float dt)                       = 0;
    virtual void render(sf::RenderTarget& target) const = 0;
};

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/states/IState.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/states/StateMenu.cpp =====
#include "states/StateMenu.h"

#include "core/Assets.h"
#include "core/ResourceManager.h"
#include "states/StatePlaying.h"
#include "states/StateStack.h"

#include <SFML/Graphics/Font.hpp>
#include <SFML/Graphics/RenderTarget.hpp>
#include <SFML/Graphics/Text.hpp>
#include <SFML/Window/Event.hpp>
#include <SFML/Window/Keyboard.hpp>

StateMenu::StateMenu(StateStack& stateStack, sf::RenderWindow& window)
    : m_stateStack(stateStack), m_window(window) {}

bool StateMenu::init() {
    const sf::Font& font = ResourceManager::getFont(Assets::Font::Lavigne);

    m_pText = std::make_unique<sf::Text>(font);

    m_pText->setString("PRESS <ENTER> TO PLAY");
    m_pText->setStyle(sf::Text::Bold);
    sf::FloatRect localBounds = m_pText->getLocalBounds();
    m_pText->setOrigin({localBounds.size.x / 2.0f, localBounds.size.y / 2.0f});

    m_pSubText = std::make_unique<sf::Text>(font);

    m_pSubText->setString("Use WASD to move\n SPACE to jump\n Mouse left click to cast a spell\n "
                          "Aim with the mouse\n Dash with mouse wheel click button\n Avoid demons "
                          "and obstacles!\n Collect red squares "
                          "and survive to gain score\n Be careful a big wave of lava is coming!");
    m_pSubText->setStyle(sf::Text::Regular);
    localBounds = m_pSubText->getLocalBounds();
    m_pSubText->setOrigin({localBounds.size.x / 2.0f, localBounds.size.y / 2.0f});

    return true;
}

void StateMenu::handleEvent(const sf::Event& event) {
    if (const auto* pKeyEvent = event.getIf<sf::Event::KeyPressed>()) {
        if (pKeyEvent->scancode == sf::Keyboard::Scan::Enter) {
            m_stateStack.push<StatePlaying>(m_window);
        }
    }
}

void StateMenu::update(float dt) { (void)dt; }

void StateMenu::render(sf::RenderTarget& target) const {
    m_pText->setPosition({target.getSize().x * 0.5f, target.getSize().y * 0.8f});
    target.draw(*m_pText);
    m_pSubText->setPosition({target.getSize().x * 0.5f, target.getSize().y * 0.2f});
    target.draw(*m_pSubText);
}

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/states/StateMenu.cpp =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/states/StateMenu.h =====
#pragma once

#include "states/IState.h"

#include <SFML/Graphics/RenderWindow.hpp>
#include <SFML/Graphics/Text.hpp>
#include <memory>

namespace sf {
    class Text;
};

class StateMenu : public IState {
  public:
    StateMenu(StateStack& stateStack, sf::RenderWindow& window);
    ~StateMenu() = default;

    bool init() override;
    void handleEvent(const sf::Event& event) override;
    void update(float dt) override;
    void render(sf::RenderTarget& target) const override;

  public:
    StateStack&               m_stateStack;
    sf::RenderWindow&         m_window;
    std::unique_ptr<sf::Text> m_pText;
    std::unique_ptr<sf::Text> m_pSubText;
};

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/states/StateMenu.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/states/StatePaused.cpp =====
#include "states/StatePaused.h"

#include "core/Assets.h"
#include "core/ResourceManager.h"
#include "states/StateStack.h"

#include <SFML/Graphics/Font.hpp>
#include <SFML/Graphics/RenderTarget.hpp>
#include <SFML/Graphics/Text.hpp>

StatePaused::StatePaused(StateStack& stateStack) : m_stateStack(stateStack) {}

bool StatePaused::init() {
    m_pPrevState = m_stateStack.getCurrentState();

    const sf::Font& font = ResourceManager::getFont(Assets::Font::Lavigne);

    m_pText = std::make_unique<sf::Text>(font);

    m_pText->setString("PRESS <ESC> TO UNPAUSE");
    m_pText->setStyle(sf::Text::Bold);
    sf::FloatRect localBounds = m_pText->getLocalBounds();
    m_pText->setOrigin({localBounds.size.x / 2.0f, localBounds.size.y / 2.0f});

    return true;
}

void StatePaused::handleEvent(const sf::Event& event) {
    if (const auto* pKeyEvent = event.getIf<sf::Event::KeyPressed>()) {
        if (pKeyEvent->scancode == sf::Keyboard::Scan::Escape) {
            m_stateStack.requestPop();
        }
    }
}

void StatePaused::update(float dt) { (void)dt; }

void StatePaused::render(sf::RenderTarget& target) const {
    if (m_pPrevState != nullptr)
        m_pPrevState->render(target);

    m_pText->setPosition({target.getSize().x * 0.5f, target.getSize().y * 0.2f});
    target.draw(*m_pText);
}

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/states/StatePaused.cpp =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/states/StatePaused.h =====
#pragma once

#include "states/IState.h"

#include <SFML/Graphics/Text.hpp>
#include <memory>

namespace sf {
    class Text;
};

class StatePaused : public IState {
  public:
    StatePaused(StateStack& stateStack);
    ~StatePaused() = default;

    bool init() override;
    void handleEvent(const sf::Event& event) override;
    void update(float dt) override;
    void render(sf::RenderTarget& target) const override;

  public:
    StateStack&               m_stateStack;
    const IState*             m_pPrevState = nullptr;
    std::unique_ptr<sf::Text> m_pText;
};

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/states/StatePaused.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/states/StatePlaying.cpp =====
#include "states/StatePlaying.h"

#include "states/StatePaused.h"
#include "states/StateStack.h"

#include <SFML/Graphics/RenderTarget.hpp>
#include <SFML/Window/Mouse.hpp>

StatePlaying::StatePlaying(StateStack& stateStack, sf::RenderWindow& window)
    : m_stateStack(stateStack), m_window(window), m_world(*this, m_session, window) {}

void StatePlaying::requestExitToMenu() {
    // Pop this state; the menu remains underneath.
    m_stateStack.requestPop();
}

bool StatePlaying::init() {
    m_session.start();
    if (!m_world.init())
        return false;

    if (auto* player = m_world.getPlayer())
        m_hud.setPlayer(player);
    return true;
}

void StatePlaying::handleEvent(const sf::Event& event) {
    if (const auto* pKeyEvent = event.getIf<sf::Event::KeyPressed>()) {
        if (pKeyEvent->scancode == sf::Keyboard::Scan::Escape) {
            m_stateStack.push<StatePaused>();
        }
        switch (pKeyEvent->scancode) {
        case sf::Keyboard::Scan::A:
        case sf::Keyboard::Scan::Left:
            m_input.moveLeft = true;
            break;
        case sf::Keyboard::Scan::D:
        case sf::Keyboard::Scan::Right:
            m_input.moveRight = true;
            break;
        case sf::Keyboard::Scan::Space:
            m_input.jumpPressed = true;
            break;
        default:
            break;
        }
    } else if (const auto* pKeyReleased = event.getIf<sf::Event::KeyReleased>()) {
        switch (pKeyReleased->scancode) {
        case sf::Keyboard::Scan::A:
        case sf::Keyboard::Scan::Left:
            m_input.moveLeft = false;
            break;
        case sf::Keyboard::Scan::D:
        case sf::Keyboard::Scan::Right:
            m_input.moveRight = false;
            break;
        default:
            break;
        }
    } else if (const auto* pMouseEvent = event.getIf<sf::Event::MouseButtonPressed>()) {
        if (pMouseEvent->button == sf::Mouse::Button::Middle) {
            m_input.dashPressed = true;
        } else if (pMouseEvent->button == sf::Mouse::Button::Left) {
            m_input.castPressed = true;
        }
    }
}

void StatePlaying::update(float dt) {
    m_session.update(dt);
    m_session.addScorePerSecond(dt, 10);

    if (auto* player = m_world.getPlayer(); player && player->isAlive()) {
        player->setInput(m_input);
    }

    m_world.update(dt);

    m_hud.update(dt);
    m_hud.setElapsedSeconds(m_session.elapsedSeconds());
    m_hud.setScore(m_session.score());

    // One-shot actions get cleared once consumed by update
    m_input.jumpPressed = false;
    m_input.dashPressed = false;
    m_input.castPressed = false;
}

void StatePlaying::render(sf::RenderTarget& target) const {
    m_world.render(target);
    target.draw(m_hud);
}

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/states/StatePlaying.cpp =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/states/StatePlaying.h =====
#pragma once

#include "core/World.h"
#include "entities/actor/player/Player.h"
#include "gameplay/GameSession.h"
#include "states/IState.h"
#include "ui/game/GameHUD.h"

#include <SFML/Graphics/RenderWindow.hpp>
#include <SFML/Graphics/View.hpp>

class StatePlaying : public IState {
  public:
    StatePlaying(StateStack& stateStack, sf::RenderWindow& window);
    ~StatePlaying() = default;

    bool init() override;
    void handleEvent(const sf::Event& event) override;
    void update(float dt) override;
    void render(sf::RenderTarget& target) const override;

    // Lifecycle
    void requestExitToMenu();

  private:
    StateStack&       m_stateStack;
    sf::RenderWindow& m_window;
    GameSession       m_session;
    World             m_world;
    PlayerInput       m_input;
    GameHUD           m_hud;
};

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/states/StatePlaying.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/states/StateStack.h =====
#pragma once

#include "states/IState.h"

#include <cassert>
#include <memory>
#include <typeinfo>
#include <vector>

class StateStack {
  public:
    IState* getCurrentState() { return m_states.empty() ? nullptr : m_states.back().get(); }

    template <typename T, typename... Args> void push(Args&&... args) {
        std::unique_ptr<IState> state = std::make_unique<T>(*this, std::forward<Args>(args)...);
        if (!state->init())
            throw std::runtime_error(std::string("Failed to initialize state: ") +
                                     typeid(T).name());

        m_states.push_back(std::move(state));
    }

    std::unique_ptr<IState> pop() {
        std::unique_ptr<IState> pState = std::move(m_states.back());
        m_states.pop_back();
        return pState;
    }

    void requestPop() { m_requestPopCount++; }

    void performPendingPops() {
        while (m_requestPopCount > 0) {
            --m_requestPopCount;
            assert(!m_states.empty());
            if (m_states.empty())
                break;
            m_states.pop_back();
        }
    }

  private:
    std::vector<std::unique_ptr<IState>> m_states;
    size_t                               m_requestPopCount = 0;
};

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/states/StateStack.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/ui/game/GameHUD.cpp =====
// GameHUD.cpp
#include "ui/game/GameHUD.h"

#include "core/Assets.h"
#include "core/Config.h"
#include "core/ResourceManager.h"
#include "entities/actor/player/Player.h"
#include "utils/Palette.h"
#include "utils/utils.h"

GameHUD::GameHUD() {
    // Stats Bars
    // HP bar
    m_hpBar.setColors(Palette::kHpFill, Palette::kUiBack, Palette::kUiOutline);
    m_hpBar.setSize(kBarSize);
    m_hpBar.setOutlineThickness(kOutlinePx);
    // Mana bar
    m_manaBar.setColors(Palette::kManaFill, Palette::kUiBack, Palette::kUiOutline);
    m_manaBar.setSize(kBarSize);
    m_manaBar.setOutlineThickness(kOutlinePx);
    // Stamina bar
    m_staminaBar.setColors(Palette::kStaminaFill, Palette::kUiBack, Palette::kUiOutline);
    m_staminaBar.setSize(kBarSize);
    m_staminaBar.setOutlineThickness(kOutlinePx);

    // Timer text
    const sf::Font& font = ResourceManager::getFont(Assets::Font::Lavigne);
    m_pTimerText         = std::make_unique<sf::Text>(font, "00:00", 28);
    m_pTimerText->setFillColor(Palette::kUiOutline);
    m_pTimerText->setOutlineColor(Palette::kUiBack);
    m_pTimerText->setOutlineThickness(2.f);
    // Center origin for top-center anchor
    const auto bounds = m_pTimerText->getLocalBounds();
    m_pTimerText->setOrigin(
        {bounds.size.x * 0.5f + bounds.position.x, bounds.size.y * 0.5f + bounds.position.y});
    m_pTimerText->setPosition({Config::windowWidth * 0.5f, m_timerTopY});

    // Score text (top-right)
    m_pScoreText = std::make_unique<sf::Text>(font, "Score 0", 28);
    m_pScoreText->setFillColor(Palette::kUiOutline);
    m_pScoreText->setOutlineColor(Palette::kUiBack);
    m_pScoreText->setOutlineThickness(2.f);
    const auto sb = m_pScoreText->getLocalBounds();
    // Top-right anchor
    m_pScoreText->setOrigin({sb.size.x + sb.position.x, sb.position.y});
    m_pScoreText->setPosition({static_cast<float>(Config::windowWidth) - 20.f, m_timerTopY});

    layout();
}

void GameHUD::setPlayer(const Player* player) { m_pPlayer = player; }

void GameHUD::update(float dt) {
    (void)dt;
    if (!m_pPlayer)
        return;

    m_hpBar.setValue(m_pPlayer->getHp(), m_pPlayer->getHpMax());
    m_manaBar.setValue(m_pPlayer->getMana(), m_pPlayer->getManaMax());
    m_staminaBar.setValue(m_pPlayer->getStamina(), m_pPlayer->getStaminaMax());
}

void GameHUD::layout() {
    const float x = m_topLeft.x;
    float       y = m_topLeft.y;

    m_hpBar.setPosition({x, y});
    y += kBarSize.y + kBarSpacing;
    m_manaBar.setPosition({x, y});
    y += kBarSize.y + kBarSpacing;
    m_staminaBar.setPosition({x, y});
}

void GameHUD::setElapsedSeconds(float seconds) {
    if (!m_pTimerText)
        return;
    const std::string text = formatMMSS(seconds);
    if (m_pTimerText->getString() == text)
        return;
    m_pTimerText->setString(text);
    const auto bounds = m_pTimerText->getLocalBounds();
    m_pTimerText->setOrigin(
        {bounds.size.x * 0.5f + bounds.position.x, bounds.size.y * 0.5f + bounds.position.y});
    m_pTimerText->setPosition({Config::windowWidth * 0.5f, m_timerTopY});
}

void GameHUD::setScore(int score) {
    if (!m_pScoreText)
        return;
    const std::string text = std::string("Score ") + std::to_string(score);
    if (m_pScoreText->getString() == text)
        return;
    m_pScoreText->setString(text);
    // Maintain top-right anchor when length changes
    const auto sb = m_pScoreText->getLocalBounds();
    m_pScoreText->setOrigin({sb.size.x + sb.position.x, sb.position.y});
    m_pScoreText->setPosition({static_cast<float>(Config::windowWidth) - 20.f, m_timerTopY});
}

void GameHUD::draw(sf::RenderTarget& target, sf::RenderStates states) const {
    target.draw(m_hpBar, states);
    target.draw(m_manaBar, states);
    target.draw(m_staminaBar, states);
    if (m_pTimerText)
        target.draw(*m_pTimerText, states);
    if (m_pScoreText)
        target.draw(*m_pScoreText, states);
}

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/ui/game/GameHUD.cpp =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/ui/game/GameHUD.h =====
#pragma once

#include "ui/game/StatBar.h"

#include <SFML/Graphics/Drawable.hpp>
#include <SFML/Graphics/RenderTarget.hpp>
#include <SFML/Graphics/Text.hpp>

class Player;

class GameHUD final : public sf::Drawable {
  public:
    GameHUD();

    void setPlayer(const Player* player);

    void update(float dt);

    // Timer text API
    void setElapsedSeconds(float seconds);
    // Score text API
    void setScore(int score);

  private:
    void layout();
    void draw(sf::RenderTarget& target, sf::RenderStates states) const override;

    // Player reference
    const Player* m_pPlayer = nullptr;

    // Stats bar
    StatBar m_hpBar;
    StatBar m_manaBar;
    StatBar m_staminaBar;

    // Layout
    sf::Vector2f m_topLeft{20.f, 20.f};
    float        m_timerTopY = 16.f;

    inline static const sf::Vector2f kBarSize{240.f, 18.f};
    inline static constexpr float    kBarSpacing = 6.f;
    inline static constexpr float    kOutlinePx  = 1.f;

    // Text
    std::unique_ptr<sf::Text> m_pTimerText;
    std::unique_ptr<sf::Text> m_pScoreText;
};

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/ui/game/GameHUD.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/ui/game/StatBar.cpp =====
// StatBar.cpp
#include "ui/game/StatBar.h"

#include <algorithm>

StatBar::StatBar() {
    m_back.setFillColor(sf::Color::Black);
    m_back.setOutlineColor(sf::Color::White);
    m_back.setOutlineThickness(kDefaultOutline);

    m_fill.setFillColor(sf::Color::Green);

    m_back.setSize(m_size);
    updateVisual();
}

void StatBar::setValue(float current, float max) {
    float fraction = 0.f;

    if (max > 0.f) {
        fraction = current / max;

        if (fraction < 0.f) {
            fraction = 0.f;
        } else if (fraction > 1.f) {
            fraction = 1.f;
        }
    }

    setFraction(fraction);
}

void StatBar::setFraction(float fraction) {
    const float clamped = std::clamp(fraction, 0.f, 1.f);
    if (clamped == m_fraction)
        return;
    m_fraction = clamped;
    updateVisual();
}

void StatBar::setColors(const sf::Color& fill, const sf::Color& back, const sf::Color& outline) {
    m_fill.setFillColor(fill);
    m_back.setFillColor(back);
    m_back.setOutlineColor(outline);
}

void StatBar::setSize(sf::Vector2f size) {
    if (size == m_size)
        return;
    m_size = size;
    m_back.setSize(size);
    updateVisual();
}

void StatBar::setPosition(sf::Vector2f pos) {
    m_back.setPosition(pos);
    m_fill.setPosition(pos);
}

void StatBar::setOutlineThickness(float px) { m_back.setOutlineThickness(px); }

void StatBar::updateVisual() {
    const float w = std::max(0.f, m_size.x * m_fraction);
    m_fill.setSize({w, m_size.y});
}

void StatBar::draw(sf::RenderTarget& target, sf::RenderStates states) const {
    target.draw(m_back, states);
    target.draw(m_fill, states);
}

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/ui/game/StatBar.cpp =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/ui/game/StatBar.h =====
#pragma once
#include <SFML/Graphics.hpp>

class StatBar : public sf::Drawable {
  public:
    StatBar();

    void setValue(float current, float max);
    void setFraction(float fraction);

    void setColors(const sf::Color& fill, const sf::Color& back, const sf::Color& outline);
    void setSize(sf::Vector2f size);
    void setPosition(sf::Vector2f pos);
    void setOutlineThickness(float px);

  private:
    void updateVisual();
    void draw(sf::RenderTarget& target, sf::RenderStates states) const override;

    inline static const sf::Vector2f kDefaultSize{240.f, 18.f};
    inline static const float        kDefaultOutline = 1.f;

    sf::RectangleShape m_back;
    sf::RectangleShape m_fill;

    float        m_fraction = 1.f;
    sf::Vector2f m_size     = kDefaultSize;
};

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/ui/game/StatBar.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/utils/Geom.h =====
#pragma once
#include "utils/Math.h"

#include <SFML/Graphics/Rect.hpp>

namespace geom {

    // Basic accessors for SFML 3 FloatRect, kept for readability and
    // to avoid repeating r.position.x / r.size.y everywhere.
    inline float left(const sf::FloatRect& r) { return r.position.x; }
    inline float top(const sf::FloatRect& r) { return r.position.y; }
    inline float width(const sf::FloatRect& r) { return r.size.x; }
    inline float height(const sf::FloatRect& r) { return r.size.y; }

    // Derived edges, built from the accessors above.
    // Used by collision helpers (touchTop / touchSide).
    inline float right(const sf::FloatRect& r) { return left(r) + width(r); }
    inline float bottom(const sf::FloatRect& r) { return top(r) + height(r); }

    // 1-D interval overlap test, used by the AABB touch checks.
    // Returns true when [aL,aR] and [bL,bR] overlap on a single axis.
    inline bool overlap1D(float aL, float aR, float bL, float bR) { return (aR > bL) && (aL < bR); }

    // Basic AABB intersection using SFMLs helper.
    // Used when you just need do these two rectangles intersect?
    inline bool aabbIntersects(const sf::FloatRect& a, const sf::FloatRect& b) {
        return a.findIntersection(b).has_value();
    }

    // Same as above but also returns the intersection rectangle in `out`.
    // Used where you need the overlap area (e.g. for more detailed collision response).
    inline bool aabbIntersects(const sf::FloatRect& a, const sf::FloatRect& b, sf::FloatRect& out) {
        if (auto inter = a.findIntersection(b)) {
            out = *inter;
            return true;
        }
        return false;
    }

    // Returns true if A is (approximately) resting on top of B.
    //
    // Project usage:
    // - Ground / obstacle checks (e.g. is the player standing on this collider?)
    //
    // Logic:
    // - bottom(A) is ~ equal to top(B) on Y (with epsilon, via math::nearEq)
    // - and they overlap on X (using overlap1D).
    inline bool touchTop(const sf::FloatRect& a, const sf::FloatRect& b, float eps = 1.0f) {
        return math::nearEq(bottom(a), top(b), eps) &&
               overlap1D(left(a), right(a), left(b), right(b));
    }

    // Returns true if A is touching B on the left or right side.
    //
    // Project usage:
    // - Side collision checks (e.g. player hitting obstacles from the side).
    //
    // Logic:
    // - Either right(A)  left(B) or left(A)  right(B) on X (with epsilon)
    // - and they overlap on Y (using overlap1D).
    inline bool touchSide(const sf::FloatRect& a, const sf::FloatRect& b, float eps = 1.0f) {
        const bool leftTouch  = math::nearEq(right(a), left(b), eps);
        const bool rightTouch = math::nearEq(left(a), right(b), eps);
        return (leftTouch || rightTouch) && overlap1D(top(a), bottom(a), top(b), bottom(b));
    }

} // namespace geom

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/utils/Geom.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/utils/Math.h =====
#pragma once
#include <SFML/System/Vector2.hpp>
#include <algorithm> // std::clamp
#include <cmath>     // std::expm1, std::abs
#include <cstdint>   // std::uint32_t

namespace math {

    // Exponential smoothing factor for frame-rateindependent easing.
    //
    // Usage in this project:
    // - World::update(): used to compute the "alpha" when easing:
    //   * the camera target X toward the player (kTargetCatchupLerp)
    //   * the actual camera center X toward the target (kCatchupLerp)
    //
    // Intuition:
    // - lambda: responsiveness (bigger => snappier).
    // - dt: frame time.
    // - Return value in [0,1] suitable for: new = old + alpha * (target - old).
    inline float expSmoothingFactor(float lambda, float dt) {
        if (dt <= 0.f || lambda <= 0.f)
            return 0.f;
        const float a = -std::expm1(-lambda * dt);
        return std::clamp(a, 0.f, 1.f);
    }

    // Approximate float comparison with an epsilon.
    //
    // Usage in this project:
    // - utils/Geom.h:
    //   * geom::touchTop() and geom::touchSide() use nearEq() to treat
    //     "almost touching" AABBs as touching, despite float error.
    // - Indirectly used in:
    //   * World::update(): DPS when the player stands on top of an obstacle
    //     via geom::touchTop().
    //   * PhysicsSystem::integrateBody(): detecting when physics bodies are
    //     resting on top of ground colliders (via geom helpers).
    //
    // Purpose:
    // - Avoid flaky collisions due to tiny float discrepancies when objects
    //   are supposed to rest exactly on top of each other.
    inline bool nearEq(float a, float b, float eps = 1e-5f) { return std::abs(a - b) <= eps; }

    // Clamp x into [0, 1].
    //
    // Usage in this project:
    // - Currently only used inside math::remap().
    //
    // Purpose:
    // - Generic helper for normalizing values into the [0,1] range, useful
    //   for interpolation, UI ratios, and tunable parameters.
    template <typename T> inline T saturate(T x) {
        return std::clamp(x, static_cast<T>(0), static_cast<T>(1));
    }

    // Linear interpolation between a and b.
    //
    // Usage in this project:
    // - Currently only used by math::remap().
    //
    // Purpose:
    // - Fundamental building block for any "blend" between two scalar values.
    //   (We use expSmoothingFactor + manual lerp in the camera logic.)
    inline float lerp(float a, float b, float t) { return a + (b - a) * t; }

    // Inverse linear interpolation: given a range [a,b] and a value x,
    // return t such that lerp(a, b, t) == x.
    //
    // Usage in this project:
    // - Currently only used by math::remap().
    //
    // Purpose:
    // - Convert from a world-space range into a normalized [0,1] space
    //   before clamping / re-scaling.
    inline float unlerp(float a, float b, float x) {
        const float denom = (b - a);
        if (std::abs(denom) <= 1e-6f)
            return 0.f;
        return (x - a) / denom;
    }

    // Remap x from [inMin, inMax] to [outMin, outMax], with clamping.
    //
    // Typical use cases:
    // - Mapping world distances to UI progress bars.
    // - Turning raw stat ranges into 0..1 parameters for shaders / effects.
    inline float remap(float x, float inMin, float inMax, float outMin, float outMax) {
        return lerp(outMin, outMax, saturate(unlerp(inMin, inMax, x)));
    }

    // Clamp a signed value to a symmetric range [-maxMagnitude, +maxMagnitude].
    //
    // Usage in this project:
    // - PhysicsSystem: clamping horizontal and vertical velocities to a maximum magnitude.
    inline float clampToMagnitude(float v, float maxMagnitude) {
        if (v > maxMagnitude)
            return maxMagnitude;
        if (v < -maxMagnitude)
            return -maxMagnitude;
        return v;
    }

    // Integer division with floor semantics, even for negative values.
    //
    // Usage in this project:
    // - environment/GroundStream.h:
    //   * blockIndexForCell() calls floorDivInt(cell, kBlockCells) to
    //     map a cell index (can be negative if the view goes left of 0)
    //     to a stable block index.
    //
    // Purpose:
    // - Ensure that procedural ground blocks and their lava gaps line up
    //   consistently across the whole world, regardless of sign of the
    //   cell index.
    inline int floorDivInt(int a, int b) {
        int q = a / b;
        int r = a % b;
        if ((r != 0) && ((r > 0) != (b > 0)))
            --q;
        return q;
    }

    // Fast 32-bit integer mixing function (hash).
    //
    // Usage in this project:
    // - environment/GroundStream.h:
    //   * gapRectForBlock() uses mix32(anchor) to get a pseudo-random
    //     but deterministic gap offset per block.
    //
    // Purpose:
    // - Generate repeatable, deterministic "random" lava gap placement
    //   based solely on block index -> procedural level layout that is
    //   stable between runs.
    inline std::uint32_t mix32(std::uint32_t x) {
        x ^= x >> 16;
        x *= 0x7feb352du;
        x ^= x >> 15;
        x *= 0x846ca68bu;
        x ^= x >> 16;
        return x;
    }

    // Vector length (Euclidean norm) for sf::Vector2f.
    inline float length(const sf::Vector2f& vec) {
        return std::sqrt(vec.x * vec.x + vec.y * vec.y);
    }

    // Return a normalized vector; (0,0) if the input has zero length.
    inline sf::Vector2f normalizeVec(const sf::Vector2f& vec) {
        float len = length(vec);
        if (len > 0) {
            return vec / len;
        } else {
            return sf::Vector2f(0, 0);
        }
    }

} // namespace math

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/utils/Math.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/utils/Palette.h =====
#pragma once

#include <SFML/Graphics/Color.hpp>

namespace Palette {
    // UI elements
    inline constexpr sf::Color kUiBack{24, 24, 24, 255};       // dark gray
    inline constexpr sf::Color kUiOutline{240, 240, 240, 255}; // light gray

    // Player stats
    inline constexpr sf::Color kHpFill{220, 68, 64, 255};      // red
    inline constexpr sf::Color kManaFill{45, 152, 218, 255};   // blue
    inline constexpr sf::Color kStaminaFill{76, 209, 55, 255}; // green

    // Debug: static world geometry (tops)
    inline constexpr sf::Color kDebugStaticGroundTop{0, 255, 0, 255};     // bright green
    inline constexpr sf::Color kDebugStaticPlatformTop{0, 255, 255, 255}; // cyan
    inline constexpr sf::Color kDebugStaticObstacleTop{255, 0, 255, 255}; // magenta

    // Debug: static world geometry (walls)
    inline constexpr sf::Color kDebugStaticGroundWall{0, 200, 0, 255};     // darker green
    inline constexpr sf::Color kDebugStaticPlatformWall{0, 180, 180, 255}; // teal
    inline constexpr sf::Color kDebugStaticObstacleWall{200, 0, 200, 255}; // purple

} // namespace Palette

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/utils/Palette.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/utils/Random.h =====
#pragma once

#include <cassert>
#include <chrono>
#include <cstdint>
#include <random>
#include <vector>

namespace Random {

    // Pseudorandom engine used everywhere in the game.
    using Engine = std::mt19937;

    // Single global engine instance.
    // Default-seeded with a fixed constant => fully deterministic by default.
    inline Engine g_engine{[] {
        // Chosen arbitrary fixed seed;
        return Engine{0x12345678u};
    }()};

    // Accessor for the global engine.
    inline Engine& engine() noexcept { return g_engine; }

    // Seed the engine from a 64-bit value (we mix down to 32 bits).
    inline void seed(std::uint64_t s) {
        std::uint32_t hi    = static_cast<std::uint32_t>(s >> 32);
        std::uint32_t lo    = static_cast<std::uint32_t>(s & 0xFFFFFFFFu);
        std::uint32_t mixed = hi ^ (lo * 0x9e3779B1u); // cheap 64->32 mixing
        engine().seed(mixed);
    }

    // Time-based seed.
    inline std::uint64_t timeSeed() {
        using namespace std::chrono;
        return static_cast<std::uint64_t>(
            duration_cast<nanoseconds>(steady_clock::now().time_since_epoch()).count());
    }

    // Uniform integer in [minInclusive, maxInclusive].
    inline int rangei(int minInclusive, int maxInclusive) {
        if (minInclusive > maxInclusive)
            std::swap(minInclusive, maxInclusive);
        std::uniform_int_distribution<int> dist(minInclusive, maxInclusive);
        return dist(engine());
    }

    // Uniform float in [minInclusive, maxInclusive].
    inline float rangef(float minInclusive, float maxInclusive) {
        if (minInclusive > maxInclusive)
            std::swap(minInclusive, maxInclusive);
        std::uniform_real_distribution<float> dist(minInclusive, maxInclusive);
        return dist(engine());
    }

    // Returns true with probability in [0, 1].
    inline bool chance(float probability01) {
        if (probability01 <= 0.f)
            return false;
        if (probability01 >= 1.f)
            return true;
        std::bernoulli_distribution dist(probability01);
        return dist(engine());
    }

    // Pick a random element from a non-empty vector.
    template <typename T> inline const T& pick(const std::vector<T>& v) {
        assert(!v.empty() && "Random::pick called with empty vector");
        const int idx = rangei(0, static_cast<int>(v.size() - 1));
        return v[static_cast<std::size_t>(idx)];
    }

} // namespace Random

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/utils/Random.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/utils/Stopwatch.h =====
#pragma once

class Stopwatch {
  public:
    void reset() { m_elapsed = 0.f; }
    void tick(float dt) {
        if (!m_paused)
            m_elapsed += dt * m_scale;
    }
    void  setPaused(bool paused) { m_paused = paused; }
    bool  isPaused() const { return m_paused; }
    void  setScale(float scale) { m_scale = scale; }
    void  resetScale() { m_scale = m_defaultScale; }
    float getElapsed() const { return m_elapsed; }

  private:
    float m_elapsed      = 0.f;
    float m_scale        = 1.f;
    float m_defaultScale = 1.f;
    bool  m_paused       = false;
};

===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/utils/Stopwatch.h =====

===== BEGIN /home/toonsa/myProjects/hive-internship-challenge-2026/src/utils/utils.h =====
#pragma once

#include <string>

static inline std::string formatMMSS(float seconds) {
    int  totalSeconds = static_cast<int>(seconds);
    int  minutes      = totalSeconds / 60;
    int  secs         = totalSeconds % 60;
    char buffer[14];
    std::snprintf(buffer, sizeof(buffer), "%02d:%02d", minutes, secs);
    return std::string(buffer);
}
===== END /home/toonsa/myProjects/hive-internship-challenge-2026/src/utils/utils.h =====

