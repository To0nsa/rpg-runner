REPO: C:\dev\rpg_runner
COMMIT: 8e7e39231403
DATE: 2026-01-31 14:41:03


===== FILE: lib/AGENTS.md =====
# AGENTS.md

Instructions for AI coding agents working in the `lib/` directory.

## Project Mission

Build a **complete vertical slice** of a production-grade Flutter + Flame runner game with:

**Core Features:**
- **Advanced combat & abilities** - Mobility skills, spells, weapons, and ultimate abilities
- **Character system** - 2 playable characters with unique traits
- **Loadout customization** - Pre-run ability selection menu
- **Content variety** - 2-3 distinct levels, 5-6 enemy types
- **Narrative integration** - Light story elements enhancing engagement

**Technical Excellence:**
- **Deterministic Core** - Enables ghost replay, multiplayer races, and eventual battle royale
- **Firebase backend** - Player data, progression, leaderboards
- **Multiplayer-ready** - Architecture supports online races and competitive modes
- **Monetization pipeline** - IAP and progression hooks
- **Mobile performance** - 60 FPS, clean architecture, scalable design

**Implementation phases** (step-by-step):
1. **Combat & Abilities** - Implement mobility, spells, weapons, ultimates (foundation for customization)
2. **Character & Loadout** - Character selection, loadout menu, customization system
3. **Content Scale** - Additional levels, enemy variety, balancing
4. **Backend & Ghost Run** - Firebase integration, replay system
5. **Narrative & Monetization** - Story elements, IAP pipeline
6. **Multiplayer Foundation** - Online race infrastructure, leaderboards

## Clean Architecture & Modularization Principles

**Senior-level engineering standards apply throughout this codebase.**

### Dependency Management

**Dependency Rule**: Dependencies point inward (UI → Game → Core, never reversed).

- **Core** has ZERO dependencies on Game or UI layers
- **Game** depends on Core contracts (snapshots, events), not Core internals
- **UI** depends on Game controller interfaces, not Core directly
- Use **dependency inversion** when lower layers need to notify upper layers (events, callbacks)

**Example violation to avoid**:
```dart
// ❌ BAD: Core importing Flutter
import 'package:flutter/material.dart'; // in lib/core/**

// ✅ GOOD: Core defines contracts, UI implements
abstract class GameEventListener {
  void onPlayerDeath(PlayerDeathEvent event);
}
```

### SOLID Principles

**Single Responsibility**:
- Each system/component has ONE reason to change
- `MovementSystem` does movement, not collision or damage
- Separate read operations from write operations where it improves clarity

**Open/Closed**:
- Extend behavior via composition, not modification
- Use strategy pattern for abilities (don't hardcode in player class)
- Level definitions extend base contracts without modifying core loading logic

**Liskov Substitution**:
- Subclasses must be substitutable for base types
- All `LevelDefinition` implementations must work with same loading logic
- All `Ability` implementations must work with same activation system

**Interface Segregation**:
- Narrow interfaces over fat ones
- Don't force systems to depend on methods they don't use
- Split large interfaces into focused contracts

**Dependency Inversion**:
- Depend on abstractions, not concrete implementations
- Core defines event interfaces, Game/UI implement handlers
- Use factory patterns for entity creation

### Decision-Making Standards

When approaching any implementation task, follow these standards:

**1. Consider Edge Cases First**
- What happens on different screen sizes, orientations, lifecycle events?
- What if the user backgrounds the app? Rotates the device? Loses network?
- What if this feature scales to 10x the current usage?

**2. Apply DRY Proactively**
- Before writing code, ask: "Does a similar pattern already exist?"
- If a pattern appears twice, extract it immediately into a reusable component
- Create shared utilities/widgets rather than duplicating logic

**3. Prefer Reusable Solutions**
- Create components that can be configured, not specialized one-offs
- Use composition over inheritance for flexibility
- Design for the 80% case but make the 20% possible via parameters

**4. Think About Future Changes**
- Will this pattern need to scale? What if we add 10 more pages/entities?
- Is the API stable enough for others to depend on?
- Are there implicit assumptions that could break later?

**5. Propose Alternatives for Non-Trivial Changes**
- Present 2-3 approaches with tradeoffs for architectural decisions
- Explain why one approach is preferred over others
- Call out risks and mitigation strategies

**6. Validate Before Implementing**
- Check if the solution handles lifecycle events (pause, resume, navigation)
- Consider platform-specific behaviors (iOS vs Android vs Web)
- Think about error states and graceful degradation

### Domain Separation

**Core domains** (organize by feature, not layer):
- **Combat** - Damage calculation, abilities, weapons, status effects
- **Movement** - Physics, velocity, collision response
- **Character** - Character definitions, stats, loadouts
- **Level** - Level data, spawning, progression
- **Inventory/Progression** - Items, unlocks, player progression

**Rules**:
- Keep domains loosely coupled
- Use events for cross-domain communication
- Define clear contracts between domains
- Avoid circular dependencies between domains

### Code Organization

**Module structure**:
```
lib/core/
  combat/          # Combat domain
    abilities/
    weapons/
    damage_system.dart
  character/       # Character domain
    character_definition.dart
    loadout.dart
  ecs/             # ECS framework (infrastructure)
    world.dart
    query.dart
```

**File size limits**:
- Keep files under 300 lines (ideally under 200)
- Extract helpers/utilities when files grow
- Split large systems into sub-systems

**Naming conventions**:
- Systems: `XxxSystem` (e.g., `CombatSystem`)
- Components: `XxxComponent` (e.g., `HealthComponent`)
- Events: `XxxEvent` (e.g., `PlayerDeathEvent`)
- Commands: `XxxCommand` (e.g., `UseAbilityCommand`)

### Testing Strategy

**Test coverage priorities**:
1. **Critical path** - Core gameplay loop, combat, movement (MUST have tests)
2. **Complex logic** - Ability interactions, damage calculations, AI decisions
3. **Edge cases** - Boundary conditions, error states, race conditions
4. **Regression** - Add tests for every bug fix

**Test types**:
- **Unit tests** (`test/core/**`) - Pure logic, systems, components
- **Integration tests** (`test/integration/**`) - Multi-system interactions
- **Widget tests** (`test/ui/**`) - UI behavior, interactions
- **Determinism tests** - Same seed → same results (critical for multiplayer)

**Test quality standards**:
- Tests must be fast (< 1s per test)
- Tests must be isolated (no shared state)
- Use meaningful test names: `test('shield recharges after cooldown expires')`
- Arrange-Act-Assert pattern

### Performance & Scalability

**Core performance rules**:
- **No allocations in hot loops** (per-tick systems)
- **Object pooling** for frequently created/destroyed entities
- **Batch operations** where possible (process arrays, not individual items)
- **Profile before optimizing** - measure, don't guess

**Scalability patterns**:
- Design systems to handle 100+ entities efficiently
- Use spatial partitioning for collision (quadtree/grid)
- Limit entity counts with object pools
- Async loading for heavy operations (assets, save data)

### Code Review Standards

When implementing/reviewing code, ensure:

- ✅ **No layer violations** (Core importing Flutter/Flame)
- ✅ **Single Responsibility** maintained
- ✅ **Tests included** for new behavior
- ✅ **Documentation updated** when contracts change
- ✅ **Performance considered** in hot paths
- ✅ **Error handling** for edge cases
- ✅ **Type safety** (no `dynamic` in gameplay code)
- ✅ **Consistent style** with existing codebase

## Architecture Overview

This project has **three hard layers**:

1. **Core** (`lib/core/`) - Pure Dart simulation: deterministic gameplay, physics, AI, RNG
2. **Game** (`lib/game/`) - Flame rendering: visuals only (sprites, animations, camera, parallax, VFX)
3. **UI** (`lib/ui/`) - Flutter widgets: menus, overlays, navigation, settings

**Hard rules:**
- **Core must not import Flutter or Flame.**
- Flame must not be authoritative for gameplay/collision.
- UI must not modify gameplay state directly; it sends **Commands** to the controller.
- The game must be embeddable: expose a reusable widget/route entrypoint; keep `lib/main.dart` as a dev host/demo only.

**For layer-specific implementation details**, see:
- **[lib/core/AGENTS.md](file:///c:/dev/rpg_runner/lib/core/AGENTS.md)** - ECS patterns, determinism, Core contracts
- **[lib/game/AGENTS.md](file:///c:/dev/rpg_runner/lib/game/AGENTS.md)** - Flame components, rendering, snapshot consumption
- **[lib/ui/AGENTS.md](file:///c:/dev/rpg_runner/lib/ui/AGENTS.md)** - Widget structure, command patterns, UI state

## Level System

**Goal**: Support multiple distinct levels (2-3 for vertical slice) as part of a scalable content pipeline.

**Rules:**
- Levels are **data-first**: define a `LevelId` + `LevelDefinition` (and optional level-specific systems) behind stable Core contracts.
- Level switching resets Core deterministically (seeded RNG, tick counter, entity world) and is driven by a **Command** from UI.
- Spawning/layout rules live in **Core** (authoritative). Render/UI only visualize and present selection/progress.
- Assets are organized and loaded **per level/scene**; avoid global "load everything at boot".
- Levels can have unique enemy compositions, difficulty curves, and environmental mechanics.

## Determinism Contract

- Simulation runs in **fixed ticks** (e.g. 60 Hz). Ticks are the only time authority.
- Inputs are **Commands** queued for a specific tick.
- RNG is seeded and owned by the Core. No wall-clock randomness.
- On app resume, clamp frame dt and **never** try to "catch up" thousands of ticks.

## Data Flow

### Commands → Core → Snapshots/Events

- **Input**: UI and Game layers send `Command` objects to the controller
- **Processing**: Core processes commands during tick execution
- **Output**: Core produces:
  - Immutable `GameStateSnapshot` for render/UI (serializable, renderer-friendly)
  - Transient `GameEvent`s (spawn/despawn/hit/sfx/screenshake/reward, etc.)

### Animation Resolution

Animation selection is resolved in Core via `AnimSystem` using `AnimResolver` + `AnimProfile`, and stored in `AnimStateStore` for snapshot consumption.

Renderer/UI must:
- Treat snapshots as read-only.
- Interpolate visuals using (`prevSnapshot`, `currSnapshot`, `alpha`) but **never simulate**.

## Prefer Existing Solutions

Before building something custom, check if a better solution already exists:

- In this repo (search for an existing pattern/component first)
- In Flame APIs (camera, viewport, parallax, input, effects)
- In well-maintained Dart/Flutter packages

**Rule of thumb:**
- Prefer **Flame** for *render concerns* (camera components, parallax rendering, effects).
- Prefer **UI (Flutter)** for *UI/input widgets* (joystick/buttons/menus/overlays).
- Prefer **Core** for *authoritative gameplay concerns* (movement/physics/collision, ability timing, damage rules), especially when determinism/networking is a goal.

## Implementation Sequencing

Prefer small, testable increments that move toward "multiple levels":

1. Define the Core level contracts (`LevelId`/`LevelDefinition`, load/reset flow).
2. Add level selection entry points (UI + dev menu) that send Commands only.
3. Make level-specific spawning/layout data-driven and deterministic.
4. Ship a second level that differs meaningfully (layout/spawns/tempo) without special-casing.
5. Add/extend Core tests to lock determinism per level (same seed ⇒ same snapshots/events).

## Code Quality Rules

- **Keep the codebase modular and scalable:**
  - Prefer small, cohesive modules with clear boundaries
  - Avoid tight coupling across Core/Game/UI; depend on stable contracts instead
  - Keep public embedding API stable (`lib/runner.dart`), treat internal folders as refactorable
- **Keep responsibilities narrow**: Avoid "god" classes that mix input/sim/render.
- **Prefer explicit data flow**: Commands in, snapshots/events out.
- **Keep Core allocation-light**: Avoid per-tick new Lists/Maps in hot loops.
- **Prefer `final`, `const`, and value types** for small structs (e.g. `Vec2`).
- **No `dynamic` in gameplay code**: Prefer typed payloads; if a temporary map is unavoidable, confine it to UI/debug only.
- **Make side effects explicit**: Core returns events; render/UI consume them.
- **Keep changes consistent** with existing style; avoid renames/reformatting unrelated code.
- **Add/extend tests** when relevant (especially when new behavior is introduced or existing behavior changes):
  - Core behavior: unit tests in `test/core/**` (`dart test`)
  - UI/viewport/widget behavior: widget tests where appropriate
- **Keep docs in sync** with code: update relevant docs whenever behavior, contracts, milestones, or public APIs change.

## What an Agent Must Do on Each Task

When asked to implement/fix something:

1. **Identify which layer** it belongs to (Core vs Game vs UI).
2. **Check for an existing solution/pattern** that already fits the goal (repo + Flame + packages).
3. **Propose a minimal plan** (1-3 steps) and acceptance criteria.
4. **Implement** with deterministic rules intact.
5. **Update docs/comments** whenever a change affects behavior, contracts, milestones, or usage:
   - Update `docs/building/plan.md` if architecture rules/contracts change
   - If no existing doc fits, add a short doc under `docs/building/` and link it from `docs/building/plan.md`
   - Update `docs/building/TODO.md` if milestone checklist/follow-ups change
   - Treat `docs/building/v0-implementation-plan.md` as historical unless asked to revise it
   - Update top-of-file docs and public API docs (`lib/runner.dart`, route/widget docs) when embedding/API expectations change
6. **Add/extend relevant tests** when new behavior is introduced or existing behavior changes (especially Core determinism and systems).
7. **Provide:**
   - Files changed + why
   - How to run/verify (build + quick sanity checks)
   - Follow-ups (next incremental step)

## What NOT to Do

- Don't add Flutter/Flame imports into `lib/core/**`.
- Don't use Flame collision callbacks as gameplay truth.
- Don't introduce wall-clock timing in simulation (no `DateTime.now()`, no frame-dt gameplay).
- Don't "just make it work" by mixing UI/render/core responsibilities.

---

**For detailed layer-specific implementation guidance**, see the `AGENTS.md` file in each subdirectory (`core/`, `game/`, `ui/`).


===== FILE: lib/core/abilities/ability_catalog.dart =====
import '../combat/damage_type.dart';
import '../combat/status/status.dart';
import '../projectiles/projectile_id.dart';
import '../snapshots/enums.dart';
import '../weapons/weapon_proc.dart';
import 'ability_def.dart';

/// Static registry of all available abilities.
/// In a real production app, this might be loaded from JSON/YAML.
class AbilityCatalog {
  const AbilityCatalog();

  static const Map<AbilityKey, AbilityDef> abilities = {
    // ------------------------------------------------------------------------
    // FALLBACKS
    // ------------------------------------------------------------------------
    'common.unarmed_strike': AbilityDef(
      id: 'common.unarmed_strike',
      category: AbilityCategory.melee,
      allowedSlots: {AbilitySlot.primary, AbilitySlot.bonus},
      targetingModel: TargetingModel.directional,
      hitDelivery: MeleeHitDelivery(
        sizeX: 1.0, sizeY: 1.0, offsetX: 0.5, offsetY: 0.0, 
        hitPolicy: HitPolicy.oncePerTarget,
      ),
      windupTicks: 4, activeTicks: 2, recoveryTicks: 4,
      staminaCost: 0, manaCost: 0,
      cooldownTicks: 0,
      interruptPriority: InterruptPriority.combat,
      animKey: AnimKey.punch,
      tags: {AbilityTag.melee, AbilityTag.light},
      payloadSource: AbilityPayloadSource.primaryWeapon,
      baseDamage: 1500, // Fallback melee damage
    ),
    'common.enemy_strike': AbilityDef(
      id: 'common.enemy_strike',
      category: AbilityCategory.melee,
      allowedSlots: {AbilitySlot.primary},
      targetingModel: TargetingModel.directional,
      hitDelivery: MeleeHitDelivery(
        sizeX: 1.0, sizeY: 1.0, offsetX: 0.5, offsetY: 0.0,
        hitPolicy: HitPolicy.oncePerTarget,
      ),
      windupTicks: 8, activeTicks: 4, recoveryTicks: 24,
      staminaCost: 0, manaCost: 0,
      cooldownTicks: 0,
      interruptPriority: InterruptPriority.combat,
      animKey: AnimKey.strike,
      tags: {AbilityTag.melee, AbilityTag.physical},
      baseDamage: 0,
    ),
    'common.enemy_cast': AbilityDef(
      id: 'common.enemy_cast',
      category: AbilityCategory.magic,
      allowedSlots: {AbilitySlot.projectile},
      targetingModel: TargetingModel.aimed,
      hitDelivery: ProjectileHitDelivery(
        projectileId: ProjectileId.thunderBolt,
        hitPolicy: HitPolicy.oncePerTarget,
      ),
      windupTicks: 6, activeTicks: 2, recoveryTicks: 12,
      staminaCost: 0, manaCost: 0,
      cooldownTicks: 0,
      interruptPriority: InterruptPriority.combat,
      animKey: AnimKey.cast,
      tags: {AbilityTag.projectile},
      requiredWeaponTypes: {WeaponType.projectileSpell},
      payloadSource: AbilityPayloadSource.projectileItem,
      baseDamage: 500, // Thunder bolt legacy damage 5.0
      baseDamageType: DamageType.physical,
    ),

    // ------------------------------------------------------------------------
    // ELOISE: PRIMARY (Sword)
    // ------------------------------------------------------------------------
    'eloise.sword_strike': AbilityDef(
      id: 'eloise.sword_strike',
      category: AbilityCategory.melee,
      allowedSlots: {AbilitySlot.primary, AbilitySlot.bonus},
      targetingModel: TargetingModel.directional,
      hitDelivery: MeleeHitDelivery(
        sizeX: 1.5, sizeY: 1.5, offsetX: 1.0, offsetY: 0.0,
        hitPolicy: HitPolicy.oncePerTarget,
      ),
      // 6 frames @ 0.06s = 0.36s -> ~22 ticks
      // Tuning: Active 0.10s (6 ticks)
      windupTicks: 8, activeTicks: 6, recoveryTicks: 8,
      staminaCost: 500, manaCost: 0, // 5.0 stamina
      cooldownTicks: 18, // 0.30s
      interruptPriority: InterruptPriority.combat,
      animKey: AnimKey.strike,
      tags: {AbilityTag.melee, AbilityTag.physical},
      requiredTags: {AbilityTag.melee, AbilityTag.physical},
      requiredWeaponTypes: {WeaponType.oneHandedSword},
      payloadSource: AbilityPayloadSource.primaryWeapon,
      procs: <WeaponProc>[
        WeaponProc(
          hook: ProcHook.onHit,
          statusProfileId: StatusProfileId.meleeBleed,
          chanceBp: 10000,
        ),
      ],
      baseDamage: 1500, // PlayerTuning meleeDamage 15.0
    ),

    'eloise.sword_parry': AbilityDef(
      id: 'eloise.sword_parry',
      category: AbilityCategory.defense,
      allowedSlots: {AbilitySlot.primary, AbilitySlot.bonus},
      targetingModel: TargetingModel.none,
      hitDelivery: SelfHitDelivery(),
      // 6 frames @ 0.06s = 0.36s -> ~22 ticks
      windupTicks: 2, activeTicks: 18, recoveryTicks: 2,
      staminaCost: 700, manaCost: 0,
      cooldownTicks: 30, // 0.50s
      interruptPriority: InterruptPriority.combat,
      animKey: AnimKey.parry,
      tags: {AbilityTag.melee, AbilityTag.physical, AbilityTag.opener},
      requiredTags: {AbilityTag.melee, AbilityTag.physical},
      requiredWeaponTypes: {WeaponType.oneHandedSword},
      payloadSource: AbilityPayloadSource.primaryWeapon,
      baseDamage: 0,
    ),

    // ------------------------------------------------------------------------
    // ELOISE: SECONDARY (Shield)
    // ------------------------------------------------------------------------
    'eloise.shield_bash': AbilityDef(
      id: 'eloise.shield_bash',
      category: AbilityCategory.defense,
      allowedSlots: {AbilitySlot.secondary, AbilitySlot.bonus},
      targetingModel: TargetingModel.directional,
      hitDelivery: MeleeHitDelivery(
        sizeX: 1.5, sizeY: 1.5, offsetX: 1.0, offsetY: 0.0,
        hitPolicy: HitPolicy.oncePerTarget,
      ),
      windupTicks: 8, activeTicks: 6, recoveryTicks: 8,
      staminaCost: 500, manaCost: 0,
      cooldownTicks: 18, // 0.30s
      interruptPriority: InterruptPriority.combat,
      animKey: AnimKey.shieldBash,
      tags: {AbilityTag.melee, AbilityTag.physical, AbilityTag.heavy},
      requiredTags: {AbilityTag.buff, AbilityTag.physical},
      requiredWeaponTypes: {WeaponType.shield},
      payloadSource: AbilityPayloadSource.secondaryWeapon,
      procs: <WeaponProc>[
        WeaponProc(
          hook: ProcHook.onHit,
          statusProfileId: StatusProfileId.stunOnHit,
          chanceBp: 10000,
        ),
      ],
      baseDamage: 1500, // Assuming standardized melee damage
    ),

    'eloise.shield_block': AbilityDef(
      id: 'eloise.shield_block',
      category: AbilityCategory.defense,
      allowedSlots: {AbilitySlot.secondary, AbilitySlot.bonus},
      targetingModel: TargetingModel.none,
      hitDelivery: SelfHitDelivery(),
      // Match Sword Parry exactly (only required weapon differs).
      // 7 frames x ~0.052s ~= 0.364s -> ~22 ticks @ 60Hz
      windupTicks: 2, activeTicks: 18, recoveryTicks: 2,
      staminaCost: 700, manaCost: 0,
      cooldownTicks: 30,
      interruptPriority: InterruptPriority.combat,
      animKey: AnimKey.shieldBlock,
      tags: {AbilityTag.buff, AbilityTag.physical},
      requiredTags: {AbilityTag.buff},
      requiredWeaponTypes: {WeaponType.shield},
      payloadSource: AbilityPayloadSource.secondaryWeapon,
      baseDamage: 0,
    ),

    // ------------------------------------------------------------------------
    // ELOISE: PROJECTILE
    // ------------------------------------------------------------------------
    'eloise.throwing_knife': AbilityDef(
      id: 'eloise.throwing_knife',
      category: AbilityCategory.ranged,
      allowedSlots: {AbilitySlot.projectile, AbilitySlot.bonus},
      targetingModel: TargetingModel.aimed,
      hitDelivery: ProjectileHitDelivery(
        projectileId: ProjectileId.throwingKnife,
        hitPolicy: HitPolicy.oncePerTarget,
      ),
      // Cooldown 0.30s -> 18 ticks
      // Cost 5.0 -> 500
      windupTicks: 4, activeTicks: 2, recoveryTicks: 6,
      staminaCost: 500, manaCost: 0,
      cooldownTicks: 18,
      interruptPriority: InterruptPriority.combat,
      animKey: AnimKey.throwItem,
      tags: {AbilityTag.projectile, AbilityTag.physical},
      requiredTags: {AbilityTag.projectile},
      requiredWeaponTypes: {WeaponType.throwingWeapon},
      payloadSource: AbilityPayloadSource.projectileItem,
      baseDamage: 1000, // RangedWeaponCatalog.throwingKnife legacyDamage 10.0
    ),

    'eloise.ice_bolt': AbilityDef(
      id: 'eloise.ice_bolt',
      category: AbilityCategory.magic,
      allowedSlots: {AbilitySlot.projectile, AbilitySlot.bonus},
      targetingModel: TargetingModel.aimed,
      hitDelivery: ProjectileHitDelivery(
        projectileId: ProjectileId.iceBolt,
        hitPolicy: HitPolicy.oncePerTarget,
      ),
      // Cost 10.0 -> 1000
      windupTicks: 6, activeTicks: 2, recoveryTicks: 8,
      staminaCost: 0, manaCost: 1000,
      cooldownTicks: 24,
      interruptPriority: InterruptPriority.combat,
      animKey: AnimKey.cast,
      tags: {AbilityTag.projectile, AbilityTag.ice},
      requiredWeaponTypes: {WeaponType.projectileSpell},
      payloadSource: AbilityPayloadSource.projectileItem,
      baseDamage: 1500, // SpellCatalog.iceBolt damage 15.0
      baseDamageType: DamageType.ice,
    ),

    'eloise.fire_bolt': AbilityDef(
      id: 'eloise.fire_bolt',
      category: AbilityCategory.magic,
      allowedSlots: {AbilitySlot.projectile, AbilitySlot.bonus},
      targetingModel: TargetingModel.aimed,
      hitDelivery: ProjectileHitDelivery(
        projectileId: ProjectileId.fireBolt,
      ),
      // Cost 12.0 -> 1200
      windupTicks: 6, activeTicks: 2, recoveryTicks: 8,
      staminaCost: 0, manaCost: 1200,
      cooldownTicks: 15, // 0.25s @ 60Hz (matches legacy cast cooldown)
      interruptPriority: InterruptPriority.combat,
      animKey: AnimKey.cast,
      tags: {AbilityTag.projectile, AbilityTag.fire},
      requiredWeaponTypes: {WeaponType.projectileSpell},
      payloadSource: AbilityPayloadSource.projectileItem,
      baseDamage: 1800, // SpellCatalog.fireBolt damage 18.0
      baseDamageType: DamageType.fire,
    ),

    'eloise.thunder_bolt': AbilityDef(
      id: 'eloise.thunder_bolt',
      category: AbilityCategory.magic,
      allowedSlots: {AbilitySlot.projectile, AbilitySlot.bonus},
      targetingModel: TargetingModel.aimed,
      hitDelivery: ProjectileHitDelivery(
        projectileId: ProjectileId.thunderBolt,
      ),
      // Cost 10.0 -> 1000
      windupTicks: 6, activeTicks: 2, recoveryTicks: 8,
      staminaCost: 0, manaCost: 1000,
      cooldownTicks: 15, // 0.25s @ 60Hz (matches legacy cast cooldown)
      interruptPriority: InterruptPriority.combat,
      animKey: AnimKey.cast,
      tags: {AbilityTag.projectile, AbilityTag.lightning},
      requiredWeaponTypes: {WeaponType.projectileSpell},
      payloadSource: AbilityPayloadSource.projectileItem,
      baseDamage: 1200, // SpellCatalog.thunderBolt damage 12.0
      baseDamageType: DamageType.thunder,
    ),

    // ------------------------------------------------------------------------
    // ELOISE: MOBILITY
    // ------------------------------------------------------------------------
    'eloise.jump': AbilityDef(
      id: 'eloise.jump',
      category: AbilityCategory.mobility,
      allowedSlots: {AbilitySlot.jump},
      targetingModel: TargetingModel.none,
      hitDelivery: SelfHitDelivery(),
      payloadSource: AbilityPayloadSource.none,
      windupTicks: 0,
      activeTicks: 0,
      recoveryTicks: 0,
      staminaCost: 200, // 2.0 stamina (matches default jump tuning)
      manaCost: 0,
      cooldownTicks: 0,
      interruptPriority: InterruptPriority.mobility,
      animKey: AnimKey.jump,
      tags: {AbilityTag.light},
      baseDamage: 0,
    ),

    'eloise.dash': AbilityDef(
      id: 'eloise.dash',
      category: AbilityCategory.mobility,
      allowedSlots: {AbilitySlot.mobility},
      targetingModel: TargetingModel.directional,
      hitDelivery: SelfHitDelivery(),
      payloadSource: AbilityPayloadSource.none,
      // 4 frames @ 0.05s = 0.20s -> 12 ticks
      // Cooldown 2.0s -> 120 ticks
      // Cost 2.0 -> 200
      windupTicks: 0, activeTicks: 12, recoveryTicks: 0,
      staminaCost: 200, manaCost: 0,
      cooldownTicks: 120,
      interruptPriority: InterruptPriority.mobility,
      canBeInterruptedBy: {}, 
      animKey: AnimKey.dash,
      tags: {AbilityTag.light, AbilityTag.buff},
      baseDamage: 0,
    ),

    'eloise.roll': AbilityDef(
      id: 'eloise.roll',
      category: AbilityCategory.mobility,
      allowedSlots: {AbilitySlot.mobility},
      targetingModel: TargetingModel.directional,
      hitDelivery: SelfHitDelivery(),
      payloadSource: AbilityPayloadSource.none,
      // 10 frames @ 0.05s = 0.50s -> 30 ticks
      // Cost ~200? (Same as dash for now?)
      windupTicks: 3, activeTicks: 24, recoveryTicks: 3,
      staminaCost: 200, manaCost: 0,
      cooldownTicks: 120,
      interruptPriority: InterruptPriority.mobility,
      animKey: AnimKey.roll,
      tags: {AbilityTag.light, AbilityTag.buff},
      baseDamage: 0,
    ),
  };

  static AbilityDef? tryGet(AbilityKey key) => abilities[key];

  /// Instance helper for dependency-injected call sites.
  AbilityDef? resolve(AbilityKey key) => abilities[key];
}


===== FILE: lib/core/abilities/ability_def.dart =====
import '../projectiles/projectile_id.dart';
import '../combat/damage_type.dart';
import '../snapshots/enums.dart';
import '../weapons/weapon_proc.dart';

// Validates strict format: "character.ability_name" (lower snake case)
// Must have at least one dot, segments must be non-empty [a-z0-9_].
// Example: "eloise.sword_strike_1"
typedef AbilityKey = String;

bool isValidAbilityKey(AbilityKey key) {
  final RegExp validKey = RegExp(r'^[a-z0-9_]+\.[a-z0-9_]+$');
  return validKey.hasMatch(key);
}

enum AbilitySlot {
  primary, // Button A (Melee)
  secondary, // Button B (Off-hand/Defensive)
  projectile, // Button C (Cast/Throw)
  mobility, // Button D (Dash)
  bonus, // Button E (Potion/Ultimate)
  jump, // Fixed slot (reserved)
}

enum AbilityCategory { melee, ranged, magic, mobility, defense, utility }

enum AbilityTag {
  // Mechanics
  melee,
  projectile,
  hitscan,
  aoe,
  buff,
  debuff,

  // Elements
  physical,
  fire,
  ice,
  lightning,

  // Properties
  heavy,
  light,
  finisher,
  opener,
}

/// Weapon family classification used for ability gating.
enum WeaponType { oneHandedSword, shield, throwingWeapon, projectileSpell }

/// Where this ability should fetch its combat payload from at commit-time.
///
/// This is the missing "source of truth" that decouples:
/// - which button/slot triggers an ability
/// - from where the ability derives weapon/projectile stats/procs/damage-type.
///
/// Critical for Bonus slot (can host anything).
enum AbilityPayloadSource {
  none,
  primaryWeapon,
  secondaryWeapon, // off-hand unless primary is two-handed (then primary)
  projectileItem,
}

enum TargetingModel {
  none, // Instant self-cast / buff
  directional, // Uses input direction (melee)
  aimed, // Uses explicit aim cursor (ranged)
  homing, // Auto-locks nearest target
  groundTarget, // AOE circle on ground
}

enum AbilityPhase { idle, windup, active, recovery }

enum InterruptPriority {
  low, // e.g. passive stance
  combat, // standard attacks (strike/cast)
  mobility, // dash/jump/roll
  forced, // system-only (stun/death)
}

// --------------------------------------------------------------------------
// HIT DELIVERY
// --------------------------------------------------------------------------

enum HitPolicy {
  once, // Hit once per activation (e.g. explosion)
  oncePerTarget, // Hit each target once (e.g. sword swing)
  everyTick, // Hit every frame (e.g. beam)
}

abstract class HitDeliveryDef {
  const HitDeliveryDef();
}

class MeleeHitDelivery extends HitDeliveryDef {
  const MeleeHitDelivery({
    required this.sizeX,
    required this.sizeY,
    required this.offsetX,
    required this.offsetY,
    required this.hitPolicy,
  });

  // Dimensions in World Units
  final double sizeX;
  final double sizeY;
  final double offsetX;
  final double offsetY;
  final HitPolicy hitPolicy;
}

class ProjectileHitDelivery extends HitDeliveryDef {
  const ProjectileHitDelivery({
    required this.projectileId,
    this.pierce = false,
    this.chain = false,
    this.chainCount = 0,
    this.hitPolicy = HitPolicy.oncePerTarget,
  }) : assert(chainCount >= 0, 'Chain count must be non-negative'),
       assert(!chain || chainCount > 0, 'If chain is true, count must be > 0');

  final ProjectileId projectileId;
  final bool pierce;
  final bool chain;
  final int chainCount;
  final HitPolicy hitPolicy;
}

/// For abilities that affect the user (Buff/Block) or have no hitbox (Dash).
class SelfHitDelivery extends HitDeliveryDef {
  const SelfHitDelivery();
}

// --------------------------------------------------------------------------
// RUNTIME DATA STRUCTS
// --------------------------------------------------------------------------

class AimSnapshot {
  const AimSnapshot({
    required this.angleRad,
    this.hasAngle = true,
    required this.capturedTick,
  });

  static const AimSnapshot empty = AimSnapshot(
    angleRad: 0.0,
    hasAngle: false,
    capturedTick: 0,
  );

  final double angleRad;
  final bool hasAngle;
  final int capturedTick;

  @override
  String toString() =>
      'AimSnapshot(rad: ${angleRad.toStringAsFixed(2)}, tick: $capturedTick)';
}

// --------------------------------------------------------------------------
// COOLDOWN GROUPS
// --------------------------------------------------------------------------

/// Maximum supported cooldown groups per entity.
const int kMaxCooldownGroups = 8;

/// Semantic constants for cooldown group IDs.
///
/// Abilities sharing a group share a cooldown. Use these constants
/// for clarity, or use raw integers for custom groupings.
abstract final class CooldownGroup {
  /// Primary melee abilities (sword strike, etc.)
  static const int primary = 0;

  /// Secondary/off-hand abilities (shield bash, shield block, etc.)
  static const int secondary = 1;

  /// Projectile abilities (spells, throwing weapons)
  static const int projectile = 2;

  /// Mobility abilities (dash, roll)
  static const int mobility = 3;

  /// Jump ability
  static const int jump = 4;

  /// Bonus slot abilities (5-7 reserved for future/bonus)
  static const int bonus0 = 5;
  static const int bonus1 = 6;
  static const int bonus2 = 7;

  /// Returns the default cooldown group for a given slot.
  static int fromSlot(AbilitySlot slot) {
    switch (slot) {
      case AbilitySlot.primary:
        return primary;
      case AbilitySlot.secondary:
        return secondary;
      case AbilitySlot.projectile:
        return projectile;
      case AbilitySlot.mobility:
        return mobility;
      case AbilitySlot.jump:
        return jump;
      case AbilitySlot.bonus:
        return bonus0;
    }
  }
}

// --------------------------------------------------------------------------
// ABILITY DEFINITION
// --------------------------------------------------------------------------

class AbilityDef {
  const AbilityDef({
    required this.id,
    required this.category,
    required this.allowedSlots,
    required this.targetingModel,
    required this.hitDelivery,
    this.payloadSource = AbilityPayloadSource.none,
    required this.windupTicks,
    required this.activeTicks,
    required this.recoveryTicks,
    required this.staminaCost,
    required this.manaCost,
    required this.cooldownTicks,
    this.cooldownGroupId,
    required this.interruptPriority,
    this.canBeInterruptedBy = const {},
    required this.animKey,
    this.tags = const {},
    this.requiredTags = const {},
    this.requiredWeaponTypes = const {},
    this.requiresEquippedWeapon = false,
    this.procs = const <WeaponProc>[],
    required this.baseDamage,
    this.baseDamageType = DamageType.physical,
  }) : assert(
         windupTicks >= 0 && activeTicks >= 0 && recoveryTicks >= 0,
         'Ticks cannot be negative',
       ),
       assert(cooldownTicks >= 0, 'Cooldown cannot be negative'),
       assert(staminaCost >= 0 && manaCost >= 0, 'Costs cannot be negative'),
       assert(
         interruptPriority != InterruptPriority.forced,
         'Forced priority is reserved for system events.',
       ),
       assert(
         cooldownGroupId == null ||
             (cooldownGroupId >= 0 && cooldownGroupId < kMaxCooldownGroups),
         'Cooldown group must be in range [0, $kMaxCooldownGroups)',
       );

  final AbilityKey id;

  // UI grouping only
  final AbilityCategory category;

  // Explicit equip legality
  final Set<AbilitySlot> allowedSlots;

  // Targeting
  final TargetingModel targetingModel;

  // Hit mechanics
  final HitDeliveryDef hitDelivery;

  // Payload source
  final AbilityPayloadSource payloadSource;

  // Timing (ticks @ 60hz)
  final int windupTicks;
  final int activeTicks;
  final int recoveryTicks;

  // Costs (fixed point: 100 = 1.0)
  final int staminaCost;
  final int manaCost;

  // Cooldown
  final int cooldownTicks;

  /// Cooldown group index (0-7). Abilities sharing a group share a cooldown.
  ///
  /// If null, defaults to the slot's default group via [CooldownGroup.fromSlot].
  /// Suggested defaults:
  ///   0 = primary melee
  ///   1 = secondary melee
  ///   2 = projectile
  ///   3 = mobility
  ///   4 = jump
  ///   5-7 = future/bonus
  final int? cooldownGroupId;

  // Interrupt rules
  final InterruptPriority interruptPriority;
  final Set<InterruptPriority> canBeInterruptedBy;

  // Presentation
  final AnimKey animKey;

  // Metadata
  final Set<AbilityTag> tags;
  final Set<AbilityTag> requiredTags;
  final Set<WeaponType> requiredWeaponTypes;

  /// If true, this ability requires *some* weapon to be equipped in its slot,
  /// even if [requiredWeaponTypes] is empty.
  final bool requiresEquippedWeapon;

  /// Guaranteed or probabilistic effects applied on hit (ability-owned).
  /// Merged deterministically with item procs in [HitPayloadBuilder].
  final List<WeaponProc> procs;

  /// Base damage for this ability.
  /// Fixed-point: 100 = 1.0 damage.
  /// - Melee: Base damage of the swing.
  /// - Thrown: Base damage of the throw.
  /// - Spell: Base damage of the spell projectile.
  final int baseDamage;

  /// Base damage type (element) for this ability.
  /// Explicitly defined (Phase 5), no inference from tags.
  final DamageType baseDamageType;

  /// Returns the effective cooldown group for this ability.
  ///
  /// Uses [cooldownGroupId] if set, otherwise falls back to slot default.
  int effectiveCooldownGroup(AbilitySlot slot) {
    if (cooldownGroupId != null) return cooldownGroupId!;

    // Important: Bonus should NOT get a "free extra cooldown lane" by default.
    // If an ability is equipped in Bonus, it should default to its canonical slot group.
    if (slot != AbilitySlot.bonus) {
      return CooldownGroup.fromSlot(slot);
    }

    // Derive canonical group from allowedSlots (today, your abilities are effectively single-slot).
    // If you later allow multi-slot abilities, set cooldownGroupId explicitly for those.
    if (allowedSlots.contains(AbilitySlot.primary)) return CooldownGroup.primary;
    if (allowedSlots.contains(AbilitySlot.secondary)) return CooldownGroup.secondary;
    if (allowedSlots.contains(AbilitySlot.projectile)) return CooldownGroup.projectile;
    if (allowedSlots.contains(AbilitySlot.mobility)) return CooldownGroup.mobility;
    if (allowedSlots.contains(AbilitySlot.jump)) return CooldownGroup.jump;

    // Fallback (shouldn't happen if allowedSlots is sane)
    return CooldownGroup.bonus0;
  }

  // Runtime Validation (Helper)
  bool get isValid {
    return isValidAbilityKey(id) &&
        !canBeInterruptedBy.contains(interruptPriority);
  }

  @override
  String toString() => 'AbilityDef($id)';
}


===== FILE: lib/core/abilities/ability_gate.dart =====
import '../ecs/entity_id.dart';
import '../ecs/world.dart';

enum AbilityGateFail {
  stunned,
  onCooldown,
  missingMana,
  insufficientMana,
  missingStamina,
  insufficientStamina,

  // Mobility-only
  missingMovement,
  missingBody,
  bodyDisabledOrKinematic,
  dashAlreadyActive,
  aimingHeld,
}

abstract class AbilityGate {
  static AbilityGateFail? canCommitCombat(
    EcsWorld world, {
    required EntityId entity,
    required int currentTick,
    required int cooldownGroupId,
    required int manaCost100,
    required int staminaCost100,
  }) {
    if (world.controlLock.isStunned(entity, currentTick)) {
      return AbilityGateFail.stunned;
    }
    if (world.cooldown.isOnCooldown(entity, cooldownGroupId)) {
      return AbilityGateFail.onCooldown;
    }

    if (manaCost100 > 0) {
      final mi = world.mana.tryIndexOf(entity);
      if (mi == null) return AbilityGateFail.missingMana;
      if (world.mana.mana[mi] < manaCost100) {
        return AbilityGateFail.insufficientMana;
      }
    }

    if (staminaCost100 > 0) {
      final si = world.stamina.tryIndexOf(entity);
      if (si == null) return AbilityGateFail.missingStamina;
      if (world.stamina.stamina[si] < staminaCost100) {
        return AbilityGateFail.insufficientStamina;
      }
    }

    return null;
  }

  static AbilityGateFail? canCommitMobility(
    EcsWorld world, {
    required EntityId entity,
    required int currentTick,
    required int cooldownGroupId,
    required int staminaCost100,
  }) {
    if (world.controlLock.isStunned(entity, currentTick)) {
      return AbilityGateFail.stunned;
    }

    final mi = world.movement.tryIndexOf(entity);
    if (mi == null) return AbilityGateFail.missingMovement;

    final bi = world.body.tryIndexOf(entity);
    if (bi == null) return AbilityGateFail.missingBody;

    if (!world.body.enabled[bi] || world.body.isKinematic[bi]) {
      return AbilityGateFail.bodyDisabledOrKinematic;
    }

    if (world.movement.dashTicksLeft[mi] > 0) {
      return AbilityGateFail.dashAlreadyActive;
    }

    if (world.cooldown.isOnCooldown(entity, cooldownGroupId)) {
      return AbilityGateFail.onCooldown;
    }

    // Mobility cannot start while aiming (existing behavior from MobilitySystem commit block).
    final ii = world.playerInput.tryIndexOf(entity);
    if (ii != null) {
      final aimHeld =
          (world.playerInput.projectileAimDirX[ii].abs() > 1e-6) ||
          (world.playerInput.projectileAimDirY[ii].abs() > 1e-6) ||
          (world.playerInput.meleeAimDirX[ii].abs() > 1e-6) ||
          (world.playerInput.meleeAimDirY[ii].abs() > 1e-6);
      if (aimHeld) return AbilityGateFail.aimingHeld;
    }

    if (staminaCost100 > 0) {
      final si = world.stamina.tryIndexOf(entity);
      if (si == null) return AbilityGateFail.missingStamina;
      if (world.stamina.stamina[si] < staminaCost100) {
        return AbilityGateFail.insufficientStamina;
      }
    }

    return null;
  }
}


===== FILE: lib/core/AGENTS.md =====
# AGENTS.md - Core Layer

Instructions for AI coding agents working in the **Core** simulation layer (`lib/core/`).

## Core Responsibility

The Core layer is a **pure Dart simulation engine**. It is the single source of truth for all gameplay logic, physics, AI, and state management.

**Hard rule:** Core must **never import Flutter or Flame**. This ensures determinism, testability, and future network-readiness.

## ECS Architecture

### Entity Storage

Core uses **SoA (Structure of Arrays) + SparseSet** per component type.

**Entity ID rules:**
- Entity IDs are **monotonic** and **never reused**
- IDs increment sequentially as entities are spawned
- Destroyed entity IDs are not recycled

### Component Iteration

**Query-based iteration:**
- Systems iterate via queries (e.g., `world.query<Position, Velocity>()`)
- Never directly access sparse/dense arrays unless implementing a new storage mechanism

**Structural change rules:**
- **Do not add/remove components or destroy entities mid-iteration**
- Queue structural changes and apply them after system execution
- Use deferred operations or command buffers for mid-tick mutations
- Do not keep references to dense arrays across ticks

### System Patterns

Systems should follow these patterns:

```dart
class ExampleSystem {
  void execute(World world, double dt) {
    // Query entities with required components
    final entities = world.query<ComponentA, ComponentB>();
    
    // Process entities (read-only iteration)
    for (final entity in entities) {
      final a = world.get<ComponentA>(entity);
      final b = world.get<ComponentB>(entity);
      
      // Update components in-place (safe)
      a.value += b.delta;
      
      // NEVER: world.destroyEntity(entity) here!
      // NEVER: world.addComponent(entity, newComponent) here!
    }
    
    // Apply structural changes after iteration
    // (queued during iteration, applied here)
  }
}
```

## Determinism Requirements

### Fixed Tick Simulation

- Simulation runs at a **fixed tick rate** (e.g., 60 Hz / 16.67ms per tick)
- Ticks are the **only time authority** in Core
- Use tick count for all timing logic, not wall-clock time

### Seeded RNG

- RNG is owned by Core and **must be seeded**
- Use a seeded `Random` instance stored in the game state
- Never use `Random()` without a seed in Core code
- Never use `DateTime.now()` or any wall-clock source for randomness

### Command Queueing

- Inputs are represented as **Command objects**
- Commands are queued for a specific tick
- Commands are processed deterministically during tick execution
- Example: `JumpCommand(tickNumber: 1234, playerId: 0)`

### Resumption Behavior

- On app resume, **clamp the frame delta-time**
- **Never** try to "catch up" thousands of ticks after backgrounding
- Skip or fast-forward deterministically if catch-up is needed

## Core Outputs

### GameStateSnapshot

- **Immutable** representation of the current game state
- Serializable and renderer-friendly
- Contains all data needed for rendering (positions, animations, health, etc.)
- Produced once per tick
- Consumer layers (Game/UI) must treat this as **read-only**

### GameEvents

- **Transient** events emitted during tick execution
- Examples: spawn, despawn, hit, sfx, screenshake, reward, level-up
- Events have a short lifetime (typically one frame)
- Consumed by Game layer for VFX, sound effects, camera shake, etc.
- Not part of the persistent state

### Animation State

- Animation selection is resolved **in Core** via `AnimSystem`
- Uses `AnimResolver` + `AnimProfile` to determine which animation to play
- Stored in `AnimStateStore` for snapshot consumption
- Game layer reads animation state from snapshots and updates Flame sprite components accordingly

## Data Flow Pattern

**Commands → Core → Snapshots + Events**

1. **Input**: Game and UI layers create `Command` objects
2. **Queue**: Commands are queued for the next tick
3. **Process**: Core executes the tick, processing all queued commands
4. **Output**: Core produces:
   - One `GameStateSnapshot` (read by Game/UI for rendering)
   - Zero or more `GameEvent`s (consumed by Game for VFX/SFX)

## Performance Considerations

### Allocation-Light Hot Loops

- Avoid creating new `List`, `Map`, or objects in per-tick hot loops
- Prefer reusing buffers or pre-allocated pools
- Profile and optimize allocation-heavy systems

### Value Types

- Prefer **value types** for small structs (e.g., `Vec2`, `Rect`, `Color`)
- Use `final` and `const` where possible to prevent accidental mutations
- Avoid boxing primitives unnecessarily

### No Dynamic Types

- **Never use `dynamic`** in Core gameplay code
- Prefer strongly-typed payloads for all data structures
- If a temporary map is unavoidable, confine it to debug/tooling only

## Testing Core

### Unit Tests

- Core behavior should be covered by **unit tests** in `test/core/**`
- Run tests with: `dart test`
- Focus on:
  - Determinism (same seed → same results)
  - System behavior (physics, collision, AI)
  - Command processing
  - Edge cases (entity destruction, spawn limits, etc.)

### Determinism Tests

Example determinism test pattern:

```dart
test('same seed produces same results', () {
  final game1 = GameCore(seed: 12345);
  final game2 = GameCore(seed: 12345);
  
  for (int i = 0; i < 100; i++) {
    game1.tick();
    game2.tick();
    
    expect(game1.snapshot, equals(game2.snapshot));
  }
});
```

## Common Core Subsystems

- **ECS** (`lib/core/ecs/`) - Entity-Component-System framework
- **Commands** (`lib/core/commands/`) - Input command definitions
- **Snapshots** (`lib/core/snapshots/`) - Snapshot data structures
- **Events** (`lib/core/events/`) - Game event definitions
- **Collision** (`lib/core/collision/`) - Authoritative collision detection
- **Combat** (`lib/core/combat/`) - Damage, health, abilities
- **Levels** (`lib/core/levels/`) - Level definitions and loading
- **Navigation** (`lib/core/navigation/`) - Pathfinding, AI movement
- **Track** (`lib/core/track/`) - Track/lane system
- **Tuning** (`lib/core/tuning/`) - Gameplay constants and balance values
- **Util** (`lib/core/util/`) - Pure Dart utilities (math, geometry, RNG helpers)

## What NOT to Do in Core

- ❌ **Do not import Flutter** (`package:flutter/...`)
- ❌ **Do not import Flame** (`package:flame/...`)
- ❌ **Do not use wall-clock time** (`DateTime.now()`, `Stopwatch`, frame delta-time)
- ❌ **Do not mutate structure mid-iteration** (adding/removing components, destroying entities)
- ❌ **Do not make rendering decisions** (that's Game layer's job)
- ❌ **Do not read user input directly** (use Commands instead)

---

**For cross-layer architecture and general rules**, see [lib/AGENTS.md](file:///c:/dev/rpg_runner/lib/AGENTS.md).


===== FILE: lib/core/anim/anim_resolver.dart =====
/// Shared animation resolver for Core entities.
library;

import '../enemies/death_behavior.dart';
import '../snapshots/enums.dart';

/// Configuration profile for an entity's animation capabilities and key mappings.
///
/// Defines which animations are supported (walk, jump, cast, etc.) and maps them
/// to specific [AnimKey]s in the animation atlas.
class AnimProfile {
  const AnimProfile({
    required this.minMoveSpeed,
    required this.runSpeedThresholdX,
    this.supportsWalk = true,
    this.supportsJumpFall = true,
    this.supportsDash = false,
    this.supportsCast = false,
    this.supportsRanged = false,
    this.supportsSpawn = false,
    this.supportsStun = false,
    this.directionalStrike = false,
    this.strikeAnimKey = AnimKey.strike,
    this.idleAnimKey = AnimKey.idle,
    this.walkAnimKey = AnimKey.walk,
    this.runAnimKey = AnimKey.run,
    this.jumpAnimKey = AnimKey.jump,
    this.fallAnimKey = AnimKey.fall,
    this.castAnimKey = AnimKey.cast,
    this.rangedAnimKey = AnimKey.ranged,
    this.dashAnimKey = AnimKey.dash,
    this.hitAnimKey = AnimKey.hit,
    this.deathAnimKey = AnimKey.death,
    this.spawnAnimKey = AnimKey.spawn,
    this.stunAnimKey = AnimKey.stun,
  });

  final double minMoveSpeed;
  final double runSpeedThresholdX;
  final bool supportsWalk;
  final bool supportsJumpFall;
  final bool supportsDash;
  final bool supportsCast;
  final bool supportsRanged;
  final bool supportsSpawn;
  final bool supportsStun;
  final bool directionalStrike;

  final AnimKey strikeAnimKey;
  final AnimKey idleAnimKey;
  final AnimKey walkAnimKey;
  final AnimKey runAnimKey;
  final AnimKey jumpAnimKey;
  final AnimKey fallAnimKey;
  final AnimKey castAnimKey;
  final AnimKey rangedAnimKey;
  final AnimKey dashAnimKey;
  final AnimKey hitAnimKey;
  final AnimKey deathAnimKey;
  final AnimKey spawnAnimKey;
  final AnimKey stunAnimKey;
}

/// Input state signals required to resolve the current animation frame.
///
/// Contains all relevant entity state (velocity, flags, timers) that affects
/// animation selection. This class is immutable and typically constructed
/// via [AnimSignals.player] or [AnimSignals.enemy] factories.
class AnimSignals {
  const AnimSignals._({
    required this.tick,
    required this.hp,
    required this.deathPhase,
    this.deathStartTick = -1,
    this.grounded = false,
    this.velX = 0.0,
    this.velY = 0.0,
    this.lastDamageTick = -1,
    this.hitAnimTicks = 0,
    this.lastStrikeTick = -1,
    this.strikeAnimTicks = 0,
    this.backStrikeAnimTicks = 0,
    this.lastStrikeFacing = Facing.right,
    this.lastCastTick = -1,
    this.castAnimTicks = 0,
    this.lastRangedTick = -1,
    this.rangedAnimTicks = 0,
    this.dashTicksLeft = 0,
    this.dashDurationTicks = 0,
    this.facing = Facing.right,
    this.spawnStartTick = -1,
    this.spawnAnimTicks = 0,
    this.stunLocked = false,
    this.activeActionAnim,
    this.activeActionFrame = 0,
  });

  factory AnimSignals.player({
    required int tick,
    required int hp,
    bool grounded = false,
    double velX = 0.0,
    double velY = 0.0,
    int lastDamageTick = -1,
    int hitAnimTicks = 0,
    int lastStrikeTick = -1,
    int strikeAnimTicks = 0,
    int backStrikeAnimTicks = 0,
    Facing lastStrikeFacing = Facing.right,
    int lastCastTick = -1,
    int castAnimTicks = 0,
    int lastRangedTick = -1,
    int rangedAnimTicks = 0,
    int dashTicksLeft = 0,
    int dashDurationTicks = 0,
    Facing facing = Facing.right,
    int spawnStartTick = -1,
    int spawnAnimTicks = 0,
    bool stunLocked = false,
    AnimKey? activeActionAnim,
    int activeActionFrame = 0,
  }) {
    return AnimSignals._(
      tick: tick,
      hp: hp,
      deathPhase: DeathPhase.none,
      grounded: grounded,
      velX: velX,
      velY: velY,
      lastDamageTick: lastDamageTick,
      hitAnimTicks: hitAnimTicks,
      lastStrikeTick: lastStrikeTick,
      strikeAnimTicks: strikeAnimTicks,
      backStrikeAnimTicks: backStrikeAnimTicks,
      lastStrikeFacing: lastStrikeFacing,
      lastCastTick: lastCastTick,
      castAnimTicks: castAnimTicks,
      lastRangedTick: lastRangedTick,
      rangedAnimTicks: rangedAnimTicks,
      dashTicksLeft: dashTicksLeft,
      dashDurationTicks: dashDurationTicks,
      facing: facing,
      spawnStartTick: spawnStartTick,
      spawnAnimTicks: spawnAnimTicks,
      stunLocked: stunLocked,
      activeActionAnim: activeActionAnim,
      activeActionFrame: activeActionFrame,
    );
  }

  factory AnimSignals.enemy({
    required int tick,
    required int hp,
    required DeathPhase deathPhase,
    int deathStartTick = -1,
    bool grounded = false,
    double velX = 0.0,
    double velY = 0.0,
    int lastDamageTick = -1,
    int hitAnimTicks = 0,
    int lastStrikeTick = -1,
    int strikeAnimTicks = 0,
    Facing lastStrikeFacing = Facing.right,
    bool stunLocked = false,
    AnimKey? activeActionAnim,
    int activeActionFrame = 0,
  }) {
    return AnimSignals._(
      tick: tick,
      hp: hp,
      deathPhase: deathPhase,
      deathStartTick: deathStartTick,
      grounded: grounded,
      velX: velX,
      velY: velY,
      lastDamageTick: lastDamageTick,
      hitAnimTicks: hitAnimTicks,
      lastStrikeTick: lastStrikeTick,
      strikeAnimTicks: strikeAnimTicks,
      lastStrikeFacing: lastStrikeFacing,
      stunLocked: stunLocked,
      activeActionAnim: activeActionAnim,
      activeActionFrame: activeActionFrame,
    );
  }
  final int tick;
  final int hp;
  final DeathPhase deathPhase;
  final int deathStartTick;
  final bool grounded;
  final double velX;
  final double velY;
  final int lastDamageTick;
  final int hitAnimTicks;
  final int lastStrikeTick;
  final int strikeAnimTicks;
  final int backStrikeAnimTicks;
  final Facing lastStrikeFacing;
  final int lastCastTick;
  final int castAnimTicks;
  final int lastRangedTick;
  final int rangedAnimTicks;
  final int dashTicksLeft;
  final int dashDurationTicks;
  final Facing facing;
  final int spawnStartTick;
  final int spawnAnimTicks;
  final bool stunLocked;
  final AnimKey? activeActionAnim;
  final int activeActionFrame;
}

/// The result of the animation resolution process.
///
/// Contains the resolved [AnimKey] and the specific frame index (or tick) to render.
class AnimResult {
  const AnimResult({required this.anim, required this.animFrame});

  final AnimKey anim;
  final int animFrame;
}

/// Pure logic resolver for determining the current animation.
///
/// Takes a static [AnimProfile] and dynamic [AnimSignals] to determine
/// the correct [AnimResult] based on a strictly prioritized state machine.
class AnimResolver {
  /// Resolves the current animation based on the provided profile and signals.
  ///
  /// Priority Order:
  /// 1. Stun (if stun locked)
  /// 2. Death (if dying or dead)
  /// 3. Hit React (if taking damage)
  /// 4. Active Action (manual overrides from abilities)
  /// 5. Legacy Actions (Strike, Cast, Ranged - if active)
  /// 6. Movement (Dash > Jump/Fall > Spawn > Run > Walk > Idle)
  static AnimResult resolve(AnimProfile profile, AnimSignals signals) {
    final tick = signals.tick;
    final lastDamageTick = signals.lastDamageTick;
    final showHit =
        signals.hitAnimTicks > 0 &&
        lastDamageTick >= 0 &&
        (tick - lastDamageTick) < signals.hitAnimTicks;

    // 1. Stun
    if (profile.supportsStun && signals.stunLocked) {
      return AnimResult(anim: profile.stunAnimKey, animFrame: signals.tick);
    }

    // 2. Actions Pre-calculation
    final strikeTicks =
        profile.directionalStrike && signals.lastStrikeFacing == Facing.left
        ? signals.backStrikeAnimTicks
        : signals.strikeAnimTicks;
    final showStrike =
        strikeTicks > 0 &&
        signals.lastStrikeTick >= 0 &&
        (tick - signals.lastStrikeTick) < strikeTicks;
    final showCast =
        profile.supportsCast &&
        signals.castAnimTicks > 0 &&
        signals.lastCastTick >= 0 &&
        (tick - signals.lastCastTick) < signals.castAnimTicks;
    final showRanged =
        profile.supportsRanged &&
        signals.rangedAnimTicks > 0 &&
        signals.lastRangedTick >= 0 &&
        (tick - signals.lastRangedTick) < signals.rangedAnimTicks;

    // 3. Death
    if (signals.deathPhase == DeathPhase.deathAnim) {
      return AnimResult(
        anim: profile.deathAnimKey,
        animFrame: _frameFromTick(tick, signals.deathStartTick),
      );
    }
    if (signals.deathPhase == DeathPhase.fallingUntilGround) {
      if (profile.supportsJumpFall && !signals.grounded) {
        return AnimResult(
          anim: signals.velY < 0 ? profile.jumpAnimKey : profile.fallAnimKey,
          animFrame: tick,
        );
      }
      return AnimResult(anim: profile.idleAnimKey, animFrame: tick);
    }
    if (signals.hp <= 0) {
      return AnimResult(
        anim: profile.deathAnimKey,
        animFrame: _frameFromTick(tick, lastDamageTick),
      );
    }

    // 4. Hit React
    if (showHit) {
      return AnimResult(
        anim: profile.hitAnimKey,
        animFrame: _frameFromTick(tick, lastDamageTick),
      );
    }

    // 5. Active Action Layer
    // Overrides legacy action logic (Strike, Cast, Ranged, Dash).
    if (signals.activeActionAnim != null) {
      final actionKey = _mapActiveActionKey(profile, signals.activeActionAnim!);
      if (actionKey != null) {
        return AnimResult(
          anim: actionKey,
          animFrame: signals.activeActionFrame,
        );
      }
    }

    if (showStrike) {
      final strikeKey =
          profile.directionalStrike && signals.lastStrikeFacing == Facing.left
          ? AnimKey.backStrike
          : profile.strikeAnimKey;
      return AnimResult(
        anim: strikeKey,
        animFrame: _frameFromTick(tick, signals.lastStrikeTick),
      );
    }
    if (showCast) {
      return AnimResult(
        anim: profile.castAnimKey,
        animFrame: _frameFromTick(tick, signals.lastCastTick),
      );
    }
    if (showRanged) {
      return AnimResult(
        anim: profile.rangedAnimKey,
        animFrame: _frameFromTick(tick, signals.lastRangedTick),
      );
    }
    if (profile.supportsDash && signals.dashTicksLeft > 0) {
      final frame = signals.dashDurationTicks - signals.dashTicksLeft;
      return AnimResult(
        anim: profile.dashAnimKey,
        animFrame: frame < 0 ? 0 : frame,
      );
    }
    if (profile.supportsJumpFall && !signals.grounded) {
      return AnimResult(
        anim: signals.velY < 0 ? profile.jumpAnimKey : profile.fallAnimKey,
        animFrame: tick,
      );
    }
    if (profile.supportsSpawn &&
        signals.spawnAnimTicks > 0 &&
        tick < signals.spawnAnimTicks) {
      return AnimResult(anim: profile.spawnAnimKey, animFrame: tick);
    }

    final speedX = signals.velX.abs();
    if (speedX <= profile.minMoveSpeed) {
      return AnimResult(anim: profile.idleAnimKey, animFrame: tick);
    }
    if (profile.supportsWalk && speedX < profile.runSpeedThresholdX) {
      return AnimResult(anim: profile.walkAnimKey, animFrame: tick);
    }
    return AnimResult(anim: profile.runAnimKey, animFrame: tick);
  }

  /// Maps a tick to a frame index.
  static int _frameFromTick(int tick, int startTick) {
    return startTick >= 0 ? tick - startTick : tick;
  }

  /// Maps an [AnimKey] to the corresponding [AnimKey] for the given [AnimProfile].
  static AnimKey? _mapActiveActionKey(AnimProfile profile, AnimKey key) {
    switch (key) {
      case AnimKey.strike:
        return profile.strikeAnimKey;
      case AnimKey.backStrike:
        return profile.directionalStrike
            ? AnimKey.backStrike
            : profile.strikeAnimKey;
      case AnimKey.cast:
        return profile.supportsCast ? profile.castAnimKey : null;
      case AnimKey.ranged:
        return profile.supportsRanged ? profile.rangedAnimKey : null;
      case AnimKey.throwItem:
        return profile.supportsRanged ? key : null;
      case AnimKey.dash:
        return profile.supportsDash ? profile.dashAnimKey : null;
      default:
        return key;
    }
  }
}


===== FILE: lib/core/anim/TODO.md =====
# TODO — `lib/core/anim/anim_resolver.dart`

> Goal: make animation selection **correct + deterministic**, eliminate “global tick” frame drift, and harden the resolver against missing/invalid start ticks.

---

## P0 — Must fix (will cause visible glitches)

### [ ] Fix Spawn timing (currently assumes spawn starts at tick 0)

**Problem**: spawn condition uses `tick < spawnAnimTicks`, so any entity spawning after tick 0 will either:

* never show spawn anim, or
* show spawn anim at the wrong time window.

**Patch (core idea)**:

* Use `spawnStartTick` as the reference.
* Only show spawn if `spawnStartTick >= 0`.

**Acceptance**:

* Spawn anim plays for exactly `spawnAnimTicks` after `spawnStartTick`.
* Entities that spawn mid-run still show the spawn anim.

**Implementation sketch**:

* `final showSpawn = profile.supportsSpawn && signals.spawnAnimTicks > 0 && signals.spawnStartTick >= 0 && (tick - signals.spawnStartTick) < signals.spawnAnimTicks;`
* Resolve spawn using `animFrame: _frameFromTick(tick, signals.spawnStartTick)`.

---

### [ ] Stabilize Death timing (avoid falling back to `lastDamageTick`)

**Problem**:

* When `hp <= 0` but `deathPhase` is not set, resolver falls back to `_frameFromTick(tick, lastDamageTick)`.
* That’s fragile: `lastDamageTick` can be stale / missing / from a previous hit (esp. pooled entities or multi-hit sequences).

**Fix policy**:

1. Prefer `deathStartTick` whenever the entity is dead/dying.
2. Only fallback to `lastDamageTick` if you *must* support legacy cases, but make that path safe.

**Acceptance**:

* Death anim starts on the correct tick (first tick of death).
* No “death anim jumps forward” on spawn/despawn or after delayed kills.

**Tasks**:

* Update the `hp <= 0` branch to reference `deathStartTick` when available.
* Add a **strict invariant**: systems should always set `deathStartTick` when entering any death state.

---

### [ ] Make Active Action mapping strict (don’t return unknown keys)

**Problem**: `_mapActiveActionKey()` returns `key` by default.

* If a profile doesn’t actually support that key (or there’s no atlas entry), the renderer will try to play a non-existent animation.
* This can cause flicker, silent fallback, or asset lookup failures.

**Fix**:

* Default should be `null`, not `key`.
* Only pass through keys you *explicitly* whitelist.

**Acceptance**:

* If the action key isn’t supported/mapped → resolver falls through to normal locomotion/idle.

**Tasks**:

* Update `_mapActiveActionKey()`:

  * Keep explicit cases.
  * `default: return null;`
* (Optional) add an assert/log in debug builds when an unknown active action key is requested.

---

## P1 — Determinism upgrades (removes subtle drift)

### [ ] Make Stun animation deterministic relative to stun start

**Problem**: stun returns `animFrame: signals.tick`.

* That makes stun frames depend on global time.
* Two identical stuns starting on different ticks will appear in different phases, which looks noisy and breaks determinism assumptions if you ever re-sim/seek.

**Fix**:

* Add `stunStartTick` to `AnimSignals` and use `_frameFromTick(tick, stunStartTick)`.

**Acceptance**:

* On the first tick of stun lock, stun anim starts at frame 0.
* Multiple stuns always start from frame 0.

**Related changes (outside this file)**:

* Where `stunLocked` is computed, also compute `stunStartTick` (or store it in a lock/store).

---

### [ ] Stop using raw `tick` as `animFrame` for jump/fall (optional but cleaner)

**Problem**: jump/fall uses `animFrame: tick`.

* This is “global time driven” again. If jump/fall is looping it’s fine-ish, but if it’s authored as one-shot it’s wrong.

**Options**:

* **Option A (minimal)**: keep as-is for looped jump/fall strips.
* **Option B (better)**: add `airStartTick` or `jumpStartTick` and resolve frames relative.

**Acceptance**:

* If jump/fall is authored as one-shot, it progresses from frame 0 at start.

---

## P2 — Correctness hardening + maintainability

### [ ] Centralize “frame origin semantics”

Right now different branches use different semantics:

* Some use `_frameFromTick(tick, startTick)` (strike/cast/hit/death)
* Some use `tick` directly (stun/jump/fall/spawn currently)
* Some use a computed delta (dash)

**Task**:

* Create a clear convention in comments:

  * `animFrame` is always **relative tick since animation started** (preferred).
  * If an animation is looped and doesn’t need start tick, explain why you’re using `tick`.

---

### [ ] Clamp negative deltas defensively

**Problem**: in dash, you already clamp negative to 0. For other `_frameFromTick` uses, if a bad `startTick` sneaks in you can get negative frames.

**Task**:

* Consider making `_frameFromTick()` clamp at 0:

  * `final dt = startTick >= 0 ? tick - startTick : tick; return dt < 0 ? 0 : dt;`

**Acceptance**:

* No negative `animFrame` reaches renderer.

---

### [ ] Add resolver unit tests (cheap + high ROI)

Add tests covering the exact bugs you’re fixing:

**Tests**:

* Spawn: `tick=100`, `spawnStartTick=95`, `spawnAnimTicks=10` → spawn plays for ticks 95..104 and stops at 105.
* Death: `hp=0`, `deathStartTick=200`, `lastDamageTick=10` → death anim frame is `tick-200` not `tick-10`.
* ActiveAction mapping: unknown key returns `null` and resolver falls through.
* Stun: if you add `stunStartTick`, stun anim frame is `tick-stunStartTick`.

---

## Notes / Quick audit checklist

* [ ] Ensure `deathStartTick` is reliably populated for enemies AND player paths (don’t let “hp<=0 without deathPhase” happen long-term).
* [ ] Ensure spawn start tick is set at entity creation and survives snapshotting (if pooled entities exist).
* [ ] Ensure Active Action `frame` passed into resolver is already a relative frame/tick (document it).

---

## Suggested implementation order

1. Spawn fix (P0)
2. Death fix (P0)
3. Active action strict mapping (P0)
4. Stun start tick plumbing (P1)
5. Optional: unify tick-relative semantics + clamps + tests (P2)


===== FILE: lib/core/camera/autoscroll_camera.dart =====
import '../util/smoothing.dart';
import '../util/double_math.dart';
import '../tuning/camera_tuning.dart';

class CameraState {
  const CameraState({
    required this.centerX,
    required this.targetX,
    required this.speedX,
  });

  /// Current visual center X of the camera view.
  final double centerX;

  /// The "ideal" center position the camera is trying to reach.
  /// This leads [centerX] and pulls it forward via smoothing.
  final double targetX;

  /// Current scroll speed (pixels/second).
  final double speedX;

  /// Creates a copy with updated fields.
  CameraState copyWith({
    double? centerX,
    double? targetX,
    double? speedX,
  }) {
    return CameraState(
      centerX: centerX ?? this.centerX,
      targetX: targetX ?? this.targetX,
      speedX: speedX ?? this.speedX,
    );
  }
}

/// Deterministic auto-scroll camera (Core).
///
/// Mirrors the reference behavior:
/// - baseline target speed with ease-in acceleration
/// - camera center eases toward a monotonic target X (never moves backward)
/// - player can pull the target forward only after passing a follow threshold
class AutoscrollCamera {
  AutoscrollCamera({
    required this.viewWidth,
    required CameraTuningDerived tuning,
    required CameraState initial,
  })  : _tuning = tuning,
        _state = initial;

  final double viewWidth;
  final CameraTuningDerived _tuning;

  CameraState get state => _state;
  CameraState _state;

  double left() => _state.centerX - viewWidth * 0.5;
  double right() => _state.centerX + viewWidth * 0.5;

  /// The X coordinate where the player starts pushing the camera forward.
  ///
  /// Calculated as a ratio of the viewport width from the left edge.
  double followThresholdX() => left() + _tuning.followThresholdRatio * viewWidth;

  /// Advances camera simulation by [dtSeconds].
  ///
  /// [playerX] is nullable to handle cases where the player is dead or despawned.
  void updateTick({
    required double dtSeconds,
    required double? playerX,
  }) {
    final t = _tuning;

    // 1. Update base scroll speed (accelerate/decelerate towards target speed).
    var speedX = _state.speedX;
    if (speedX < t.targetSpeedX) {
      speedX = clampDouble(speedX + t.accelX * dtSeconds, 0.0, t.targetSpeedX);
    } else if (speedX > t.targetSpeedX) {
      speedX = clampDouble(speedX - t.accelX * dtSeconds, t.targetSpeedX, speedX);
    }

    // 2. Integrate target position based on speed.
    var targetX = _state.targetX + speedX * dtSeconds;

    // 3. Player catch-up logic.
    // If the player pushes past the threshold, the target point is pulled forward.
    // This allows the player to run faster than the scroll speed without staying
    // pinned to the edge (camera speeds up to catch them).
    if (playerX != null) {
      final threshold = followThresholdX();
      if (playerX > threshold) {
        final alphaT = expSmoothingFactor(t.targetCatchupLerp, dtSeconds);
        final newTarget = targetX + (playerX - targetX) * alphaT;
        targetX = targetX > newTarget ? targetX : newTarget;
      }
    }

    // 4. Smooth the actual camera center towards the target.
    final alpha = expSmoothingFactor(t.catchupLerp, dtSeconds);
    var centerX = _state.centerX + (targetX - _state.centerX) * alpha;

    // 5. Monotonicity clamp: the camera is an auto-scroller, it never goes left.
    if (centerX < _state.centerX) centerX = _state.centerX;
    if (targetX < _state.targetX) targetX = _state.targetX;

    _state = _state.copyWith(centerX: centerX, targetX: targetX, speedX: speedX);
  }
}


===== FILE: lib/core/camera/TODO.md =====
# TODO — Autoscroll Camera Review & Hardening

---

## P0 — Correctness / Gameplay Feel

### [ ] Unify the player reference point used by camera *and* gameplay rules

**Problem (real in your code):**

* Camera pull uses **transform.posX** (`playerPosX`)
* Death rule uses **collider right edge** 
  So tuning thresholds will feel “off” depending on collider offset/size.

**Task**

* Pick ONE canonical driver for “player pushing camera”, recommended:

  * **Runner default:** `playerRightX` (collider front) — matches your death rule and visual intuition.
* Change `AutoscrollCamera.updateTick` signature to reflect semantics:

  * `playerX` → `playerRightX` (or `playerCenterX`, but then change death/culling rules too).
* Update the call site to pass collider-derived value (same math used in `_checkFellBehindCamera`).

**Acceptance**

* Camera pull begins exactly when **the same point** used for death checks crosses the threshold line.
* No hidden offset caused by `colliderAabb.offsetX/halfX`.

---

## P0 — “Autoscroll” sanity check (tuning intent)

### [ ] Confirm whether camera should have baseline autoscroll speed in V0

Right now the camera supports baseline scroll (`targetSpeedX`, `accelX`) inside `updateTick`. 
But your actual tuning values determine whether it truly autoscrolls.

**Task**

* Verify current `CameraTuningDerived.targetSpeedX` behavior and ensure the tuning actually sets a non-zero baseline if intended.
* If autoscroll is intended: set a baseline such as `targetSpeedX = maxSpeedX * speedLagMulX` with a sensible `speedLagMulX` (runner typical: `< 1.0` so player can catch up).

**Acceptance**

* With no input, camera still moves if “autoscroll runner” is the goal.
* If “follow-only” is intended, rename the module accordingly (don’t call it autoscroll).

---

## P1 — Maintainability / API clarity

### [ ] Rename parameters to reflect semantics (no more “playerX” ambiguity)

**Task**

* Rename `playerX` → `playerRightX` (or `playerCenterX`, whichever you pick). 
* Add doc comment: what coordinate space, what point, and why.

**Acceptance**

* Call sites self-document the semantics (no guessing).

### [ ] Document threshold math explicitly

Camera math today:

* `threshold = left() + followThresholdRatio * viewWidth` 

**Task**

* Add doc comment showing this exact formula.
* Add tuning guidance range (runner typical values).

---

## P1 — Performance / Allocation hygiene (only if profiling says it’s hot)

### [ ] Remove per-tick `CameraState.copyWith()` allocation

Currently every tick ends with `_state = _state.copyWith(...)`. 

**Options**

* **Option A (cleanest hot-loop):** make `_state` mutable (fields not `final`).
* **Option B (best API separation):** keep `CameraState` as an immutable snapshot, but store `centerX/targetX/speedX` as primitive fields in `AutoscrollCamera` and only materialize `CameraState` for snapshot export/debug.

**Acceptance**

* No per-tick CameraState allocations (confirm with DevTools allocations).

---

## P2 — Consistency with gameplay systems (culling + death)

### [ ] Standardize camera edge usage across systems

Right now:

* Death uses `_camera.left()` 
* Collectible/restoration use `_camera.left()` 

**Task**

* Ensure every “behind camera” rule uses the same edge definition + same player point definition (right edge, center, etc).
* Decide whether margins should be consistent across:

  * player death
  * enemy culling
  * pickups/items culling

**Acceptance**

* What you see on screen matches despawns and run-end rules exactly.

---

## P2 — Determinism / Stability tests (small but valuable)

### [ ] Add unit tests for camera invariants

**Test cases**

* `centerX` monotonic non-decreasing (camera never moves backward). 
* `targetX` monotonic non-decreasing. 
* `speedX` eases toward `targetSpeedX` under `accelX`. 
* Player pull only happens when `player*X > threshold`. 

**Acceptance**

* Tests guard future refactors and tuning changes.

---

## Notes — behavior worth keeping

* The monotonic clamp is correct for strict runner feel. 
* Two-stage smoothing (target and center) is a good approach for “player can push camera forward” behavior. 


===== FILE: lib/core/collision/static_world_geometry.dart =====
/// Static collision geometry owned by the Core simulation.
///
/// Starts with a set of base geometry (ground band), and extended with
/// deterministic chunk spawning.
class StaticGroundPlane {
  const StaticGroundPlane({required this.topY});

  /// World-space Y coordinate of the ground surface (solid top).
  final double topY;
}

/// A "hole" in the infinite ground plane where the player can fall through.
///
/// Use this to create pits or interruptions in the otherwise continuous ground.
class StaticGroundGap {
  const StaticGroundGap({required this.minX, required this.maxX})
    : assert(maxX >= minX);

  /// Start X coordinate of the gap (inclusive start of hole).
  final double minX;

  /// End X coordinate of the gap (inclusive end of hole).
  final double maxX;
}

/// A pre-computed walkable 1D segment for faster collision and navigation.
///
/// These are typically generated from the [StaticGroundPlane] minus any
/// [StaticGroundGap]s.
class StaticGroundSegment {
  const StaticGroundSegment({
    required this.minX,
    required this.maxX,
    required this.topY,
    this.chunkIndex = StaticSolid.groundChunk,
    this.localSegmentIndex = -1,
  }) : assert(maxX >= minX);

  /// Start X coordinate of the walkable surface.
  final double minX;

  /// End X coordinate of the walkable surface.
  final double maxX;

  /// Y coordinate of the surface (constant height).
  final double topY;

  /// Chunk index this segment was generated from, or [StaticSolid.groundChunk].
  final int chunkIndex;

  /// Stable local index within the chunk pattern authoring list.
  final int localSegmentIndex;
}

/// A generic AABB obstacle or platform in the world.
///
/// Can represent solid blocks, walls, floating platforms (one-way), or ceilings.
class StaticSolid {
  const StaticSolid({
    required this.minX,
    required this.minY,
    required this.maxX,
    required this.maxY,
    this.sides = sideTop,
    this.oneWayTop = true,
    this.chunkIndex = noChunk,
    this.localSolidIndex = -1,
  }) : assert(maxX >= minX),
       assert(maxY >= minY);

  /// Left edge world coordinate.
  final double minX;

  /// Bottom edge world coordinate.
  final double minY;

  /// Right edge world coordinate.
  final double maxX;

  /// Top edge world coordinate.
  final double maxY;

  /// Which faces of this solid participate in collision resolution.
  ///
  /// - one-way platforms typically use `sideTop` only
  /// - obstacles typically use `sideAll`
  final int sides;

  /// If true, the top surface only collides while falling (platform behavior).
  ///
  /// This only applies when [sides] includes [sideTop].
  final bool oneWayTop;

  /// Chunk index this solid was generated from (streaming), or [noChunk] for
  /// base/static geometry.
  final int chunkIndex;

  /// Stable local index within the chunk pattern authoring list.
  ///
  /// If negative, callers should derive a stable index from the owning list.
  final int localSolidIndex;

  /// Collision side flags.
  static const int sideNone = 0;
  static const int sideTop = 1 << 0;
  static const int sideBottom = 1 << 1;
  static const int sideLeft = 1 << 2;
  static const int sideRight = 1 << 3;
  static const int sideAll = sideTop | sideBottom | sideLeft | sideRight;

  /// Sentinel for solids not tied to a streamed chunk.
  static const int noChunk = -2;

  /// Reserved chunk index for always-on surfaces (e.g. ground plane).
  static const int groundChunk = -1;
}

/// Immutable bundle of static solids for a run/session.
class StaticWorldGeometry {
  const StaticWorldGeometry({
    this.groundPlane,
    this.groundSegments = const <StaticGroundSegment>[],
    this.solids = const <StaticSolid>[],
    this.groundGaps = const <StaticGroundGap>[],
  });

  /// Optional infinite ground plane (top surface only).
  final StaticGroundPlane? groundPlane;

  /// Walkable ground segments (used for collision + navigation).
  final List<StaticGroundSegment> groundSegments;

  /// Arbitrary static solids (platforms, walls, blocks).
  final List<StaticSolid> solids;

  /// Holes in the ground plane (world-space X ranges).
  final List<StaticGroundGap> groundGaps;
}


===== FILE: lib/core/collision/static_world_geometry_index.dart =====
import 'static_world_geometry.dart';
export 'static_world_geometry.dart';

/// Pre-indexed view of static world geometry for faster collision queries.
///
/// This is constructed once (per run/session) and preserves the original solid
/// ordering in each face list to keep behavior deterministic.
class StaticWorldGeometryIndex {
  StaticWorldGeometryIndex._({
    required this.geometry,
    required this.groundPlane,
    required this.groundSegments,
    required this.groundGaps,
    required List<StaticSolid> tops,
    required List<StaticSolid> bottoms,
    required List<StaticSolid> leftWalls,
    required List<StaticSolid> rightWalls,
    required double maxTopWidth,
    required double maxBottomWidth,
    required double maxLeftWidth,
    required double maxRightWidth,
  })  : _tops = tops,
        _bottoms = bottoms,
        _leftWalls = leftWalls,
        _rightWalls = rightWalls,
        _maxTopWidth = maxTopWidth,
        _maxBottomWidth = maxBottomWidth,
        _maxLeftWidth = maxLeftWidth,
        _maxRightWidth = maxRightWidth;

  /// Creates a spatial index from the raw static geometry.
  ///
  /// This process involves:
  /// 1. Categorizing solids by their active sides (top, bottom, left, right).
  /// 2. Sorting each list by [minX] to enable binary search.
  /// 3. Computing max widths for each list to optimize overlap queries.
  /// 4. Merging the ground plane and gaps into a unified list of walkable segments.
  factory StaticWorldGeometryIndex.from(StaticWorldGeometry geometry) {
    final tops = <StaticSolid>[];
    final bottoms = <StaticSolid>[];
    final leftWalls = <StaticSolid>[];
    final rightWalls = <StaticSolid>[];

    for (final solid in geometry.solids) {
      final sides = solid.sides;
      if ((sides & StaticSolid.sideTop) != 0) tops.add(solid);
      if ((sides & StaticSolid.sideBottom) != 0) bottoms.add(solid);
      if ((sides & StaticSolid.sideLeft) != 0) leftWalls.add(solid);
      if ((sides & StaticSolid.sideRight) != 0) rightWalls.add(solid);
    }

    // Sort for binary search.
    _sortByMinX(tops);
    _sortByMinX(bottoms);
    _sortByMinX(leftWalls);
    _sortByMinX(rightWalls);

    final groundSegments = _buildGroundSegments(geometry);
    // Ground segments are already sorted by _buildGroundSegments.

    final groundGaps = geometry.groundGaps.isEmpty
        ? const <StaticGroundGap>[]
        : List<StaticGroundGap>.unmodifiable(
            List<StaticGroundGap>.from(geometry.groundGaps),
          );

    return StaticWorldGeometryIndex._(
      geometry: geometry,
      groundPlane: geometry.groundPlane,
      groundSegments: groundSegments,
      groundGaps: groundGaps,
      tops: List<StaticSolid>.unmodifiable(tops),
      bottoms: List<StaticSolid>.unmodifiable(bottoms),
      leftWalls: List<StaticSolid>.unmodifiable(leftWalls),
      rightWalls: List<StaticSolid>.unmodifiable(rightWalls),
      maxTopWidth: _computeMaxWidth(tops),
      maxBottomWidth: _computeMaxWidth(bottoms),
      maxLeftWidth: _computeMaxWidth(leftWalls),
      maxRightWidth: _computeMaxWidth(rightWalls),
    );
  }

  /// Source geometry (unchanged).
  final StaticWorldGeometry geometry;

  /// Optional infinite ground plane.
  final StaticGroundPlane? groundPlane;

  /// Walkable ground segments (used for collision + navigation).
  final List<StaticGroundSegment> groundSegments;

  /// Ground gaps (holes in the ground plane).
  final List<StaticGroundGap> groundGaps;

  /// Solids with an enabled top face.
  final List<StaticSolid> _tops;

  /// Solids with an enabled bottom face (ceilings).
  final List<StaticSolid> _bottoms;

  /// Solids with an enabled left face (walls hit when moving right).
  final List<StaticSolid> _leftWalls;

  /// Solids with an enabled right face (walls hit when moving left).
  final List<StaticSolid> _rightWalls;

  final double _maxTopWidth;
  final double _maxBottomWidth;
  final double _maxLeftWidth;
  final double _maxRightWidth;

  /// Fills [out] with solids overlapping the range [minX, maxX].
  ///
  /// Uses binary search to find potential candidates in O(log N) time.
  void queryTops(double minX, double maxX, List<StaticSolid> out) {
    _query(_tops, minX, maxX, _maxTopWidth, out);
  }

  /// Fills [out] with solids overlapping the range [minX, maxX].
  ///
  /// Uses binary search to find potential candidates in O(log N) time.
  void queryBottoms(double minX, double maxX, List<StaticSolid> out) {
    _query(_bottoms, minX, maxX, _maxBottomWidth, out);
  }

  /// Fills [out] with solids overlapping the range [minX, maxX].
  ///
  /// Uses binary search to find potential candidates in O(log N) time.
  void queryLeftWalls(double minX, double maxX, List<StaticSolid> out) {
    _query(_leftWalls, minX, maxX, _maxLeftWidth, out);
  }

  /// Fills [out] with solids overlapping the range [minX, maxX].
  ///
  /// Uses binary search to find potential candidates in O(log N) time.
  void queryRightWalls(double minX, double maxX, List<StaticSolid> out) {
    _query(_rightWalls, minX, maxX, _maxRightWidth, out);
  }

  /// Fills [out] with ground segments overlapping the range [minX, maxX].
  ///
  /// Ground segments are guaranteed to be sorted and disjoint, allowing efficient
  /// traversal.
  void queryGroundSegments(double minX, double maxX, List<StaticGroundSegment> out) {
    final start = _lowerBoundSegments(groundSegments, minX);
    for (var i = start; i < groundSegments.length; i += 1) {
      final seg = groundSegments[i];
      if (seg.minX >= maxX) break;
      if (seg.maxX > minX) {
        out.add(seg);
      }
    }
  }

  /// Internal helper to query a sorted list of solids.
  ///
  /// [maxWidth] is used to determine the search window. Since the list is sorted
  /// by [minX], a solid can only overlap if its [minX] is within [maxWidth] of
  /// the query's [minX].
  static void _query(
    List<StaticSolid> list,
    double minX,
    double maxX,
    double maxWidth,
    List<StaticSolid> out,
  ) {
    final lowerBoundX = minX - maxWidth;
    final start = _lowerBound(list, lowerBoundX);

    for (var i = start; i < list.length; i += 1) {
      final s = list[i];
      if (s.minX >= maxX) break;
      if (s.maxX > minX) {
        out.add(s);
      }
    }
  }
}

void _sortByMinX(List<StaticSolid> list) {
  list.sort((a, b) => a.minX.compareTo(b.minX));
}

double _computeMaxWidth(List<StaticSolid> list) {
  var maxW = 0.0;
  for (final s in list) {
    final w = s.maxX - s.minX;
    if (w > maxW) maxW = w;
  }
  return maxW;
}

/// Standard binary search (lower bound) for `List<StaticSolid>`.
/// Returns the first index where `list[i].minX >= xValue`.
int _lowerBound(List<StaticSolid> list, double xValue) {
  var min = 0;
  var max = list.length;
  while (min < max) {
    final mid = min + ((max - min) >> 1);
    final element = list[mid];
    if (element.minX < xValue) {
      min = mid + 1;
    } else {
      max = mid;
    }
  }
  return min;
}

/// Specialized search for ground segments.
/// Returns the first index where `list[i].maxX > xValue`.
/// Since ground segments are disjoint, finding where they end relative to the
/// query start is a good entry point.
int _lowerBoundSegments(List<StaticGroundSegment> list, double xValue) {
  var min = 0;
  var max = list.length;
  while (min < max) {
    final mid = min + ((max - min) >> 1);
    if (list[mid].maxX <= xValue) {
      min = mid + 1;
    } else {
      max = mid;
    }
  }
  return min;
}

/// Helper to unify the ground plane and gaps into a single sorted list of
/// walkable segments.
List<StaticGroundSegment> _buildGroundSegments(StaticWorldGeometry geometry) {
  // If segments are already provided (e.g. from a chunk generator), use them.
  if (geometry.groundSegments.isNotEmpty) {
    return List<StaticGroundSegment>.unmodifiable(geometry.groundSegments);
  }

  // If no ground plane exists, there are no segments (void world).
  final groundPlane = geometry.groundPlane;
  if (groundPlane == null) {
    return const <StaticGroundSegment>[];
  }

  // If there are no gaps, the ground is a single infinite plane.
  if (geometry.groundGaps.isEmpty) {
    return List<StaticGroundSegment>.unmodifiable(<StaticGroundSegment>[
      StaticGroundSegment(
        minX: double.negativeInfinity,
        maxX: double.infinity,
        topY: groundPlane.topY,
        chunkIndex: StaticSolid.groundChunk,
        localSegmentIndex: 0,
      ),
    ]);
  }

  // 1. Sort gaps by minX to process them in order.
  final gaps = List<StaticGroundGap>.from(geometry.groundGaps)
    ..sort((a, b) => a.minX.compareTo(b.minX));

  // 2. Merge overlapping or adjacent gaps into fewer, larger gaps.
  final merged = <StaticGroundGap>[];
  for (final gap in gaps) {
    if (merged.isEmpty) {
      merged.add(gap);
      continue;
    }
    final last = merged.last;
    if (gap.minX <= last.maxX) {
      // Overlapping or touching gap. Extend the last gap if needed.
      if (gap.maxX > last.maxX) {
        merged[merged.length - 1] =
            StaticGroundGap(minX: last.minX, maxX: gap.maxX);
      }
    } else {
      // Disjoint gap.
      merged.add(gap);
    }
  }

  // 3. Create segments strictly *between* the merged gaps.
  final segments = <StaticGroundSegment>[];
  var cursor = double.negativeInfinity;
  var localIndex = 0;
  for (final gap in merged) {
    // If there is space between the current cursor (end of last gap) and
    // the start of this gap, create a segment.
    if (gap.minX > cursor) {
      segments.add(
        StaticGroundSegment(
          minX: cursor,
          maxX: gap.minX,
          topY: groundPlane.topY,
          chunkIndex: StaticSolid.groundChunk,
          localSegmentIndex: localIndex,
        ),
      );
      localIndex += 1;
    }
    // Move cursor to the end of this gap.
    cursor = gap.maxX > cursor ? gap.maxX : cursor;
  }

  // 4. Create the final segment from the last gap to infinity.
  if (cursor < double.infinity) {
    segments.add(
      StaticGroundSegment(
        minX: cursor,
        maxX: double.infinity,
        topY: groundPlane.topY,
        chunkIndex: StaticSolid.groundChunk,
        localSegmentIndex: localIndex,
      ),
    );
  }

  return List<StaticGroundSegment>.unmodifiable(segments);
}


===== FILE: lib/core/combat/control_lock.dart =====
/// Lock flag bit constants for ability/action gating.
///
/// These flags control what actions an entity can perform.
/// Multiple locks can be active simultaneously with independent expiry times.
///
/// Use [LockFlag.stun] as a "master lock" that blocks everything.
library;

/// Bit flag constants for control locks.
abstract class LockFlag {
  /// Stun lock - blocks ALL actions and movement.
  /// This is the "master lock" - systems should check isStunned() first.
  static const int stun = 1 << 0;

  /// Movement lock - blocks horizontal control input.
  static const int move = 1 << 1;

  /// Jump lock - blocks jump input.
  static const int jump = 1 << 2;

  /// Dash lock - blocks dash ability.
  static const int dash = 1 << 3;

  /// Strike lock - blocks melee attacks.
  static const int strike = 1 << 4;

  /// Cast lock - blocks spell casting.
  static const int cast = 1 << 5;

  /// Ranged lock - blocks ranged weapon attacks.
  static const int ranged = 1 << 6;

  /// Nav lock - blocks enemy navigation/pathfinding.
  static const int nav = 1 << 7;

  // ─────────────────────────────────────────────────────────────────────────
  // Composite masks for convenience
  // ─────────────────────────────────────────────────────────────────────────

  /// All offensive actions (strike, cast, ranged).
  static const int allActions = strike | cast | ranged;

  /// All movement abilities (move, jump, dash).
  static const int allMovement = move | jump | dash;

  /// Everything except stun.
  static const int allExceptStun = allActions | allMovement | nav;

  /// All flags combined.
  static const int all = stun | allExceptStun;
}


===== FILE: lib/core/combat/creature_tag.dart =====
/// Broad classification tags shared across enemies and player variants.
enum CreatureTag {
  humanoid,
  demon,
  flying,
  undead,
}

/// Bitmask constants for [CreatureTag].
class CreatureTagMask {
  const CreatureTagMask._();

  static const int humanoid = 1 << 0;
  static const int demon = 1 << 1;
  static const int flying = 1 << 2;
  static const int undead = 1 << 3;

  static int forTag(CreatureTag tag) {
    switch (tag) {
      case CreatureTag.humanoid:
        return humanoid;
      case CreatureTag.demon:
        return demon;
      case CreatureTag.flying:
        return flying;
      case CreatureTag.undead:
        return undead;
    }
  }
}



===== FILE: lib/core/combat/damage.dart =====
import '../ecs/entity_id.dart';
import '../enemies/enemy_id.dart';
import '../events/game_event.dart';
import '../projectiles/projectile_id.dart';
import '../projectiles/projectile_item_id.dart';
import '../weapons/weapon_proc.dart';
import 'damage_type.dart';

/// Represents a request to apply damage to an entity.
///
/// This structure captures the target, the amount of damage, and comprehensive
  /// metadata about the source of the damage (entity, enemy type, projectile, projectile item)
/// to be used for combat logic, death events, and statistics.
class DamageRequest {
  const DamageRequest({
    required this.target,
    required this.amount100,
    this.damageType = DamageType.physical,
    this.procs = const <WeaponProc>[],
    this.source,
    this.sourceKind = DeathSourceKind.unknown,
    this.sourceEnemyId,
    this.sourceProjectileId,
    this.sourceProjectileItemId,
  });

  /// The entity receiving the damage.
  final EntityId target;

  /// The amount of health points to deduct.
  ///
  /// Fixed-point: 100 = 1.0
  final int amount100;

  /// Category used for resistance/vulnerability lookup.
  final DamageType damageType;

  /// Potential on-hit procs to roll at application time.
  final List<WeaponProc> procs;

  /// The optional entity responsible for dealing the damage (e.g. the shooter).
  final EntityId? source;

  /// Categorization of the damage source for death messages or analytics.
  final DeathSourceKind sourceKind;

  /// If the dissolved source was an enemy, its static ID.
  final EnemyId? sourceEnemyId;

  /// If the damage came from a projectile, its static ID.
  final ProjectileId? sourceProjectileId;

  /// If the damage came from a projectile item, its static ID.
  final ProjectileItemId? sourceProjectileItemId;
}


===== FILE: lib/core/combat/damage_type.dart =====
/// High-level damage categories for resistance/vulnerability rules.
enum DamageType {
  physical,
  fire,
  ice,
  thunder,
  bleed,
}



===== FILE: lib/core/combat/faction.dart =====
/// Defines the side an entity belongs to in combat.
///
/// Factions determine friend-or-foe relationships for targeting and collision.
enum Faction {
  /// The player and their allies/summons.
  player,

  /// Hostile entities that strike the player.
  enemy
}



===== FILE: lib/core/combat/hit_payload.dart =====
import '../abilities/ability_def.dart' show AbilityKey;
import '../ecs/entity_id.dart';
import '../weapons/weapon_id.dart';
import '../weapons/weapon_proc.dart';
import 'damage_type.dart';

/// Resolved payload for a damaging action.
///
/// This is the "Frozen Snapshot" of an attack, constructed by [HitPayloadBuilder].
/// It carries all necessary data for the consumer (Projectile/Melee System) to
/// execute the hit.
///
/// **Design Pillars:**
/// *   **Integer Determinism**: [damage100] is in fixed-point (100 = 1.0).
/// *   **Explicit Type**: [damageType] is fully resolved.
/// *   **Potential Procs**: [procs] list candidate effects (rng roll happens at hit time).
class HitPayload {
  const HitPayload({
    required this.damage100,
    required this.damageType,
    required this.procs,
    required this.sourceId,
    this.abilityId,
    this.weaponId,
  });

  /// Final calculated damage in fixed-point units (100 = 1.0 visual damage).
  ///
  /// Includes base ability damage + weapon scaling + any intent-time modifiers.
  final int damage100;

  /// The elemental type of the damage (resolved from Ability vs Weapon priority).
  final DamageType damageType;

  /// List of potential on-hit effects contributed by the weapon/ability.
  ///
  /// The consumer is responsible for rolling the chance (bp) to apply these.
  final List<WeaponProc> procs;

  /// The entity that originated this hit (Player/Enemy).
  final EntityId sourceId;

  // Debugging / Logging
  final AbilityKey? abilityId;
  final WeaponId? weaponId;
}


===== FILE: lib/core/combat/hit_payload_builder.dart =====
import '../weapons/weapon_proc.dart';
import '../weapons/weapon_stats.dart';
import '../abilities/ability_def.dart';
import '../ecs/entity_id.dart';
import 'damage_type.dart';
import 'hit_payload.dart';

/// Canonical builder for [HitPayload].
///
/// Encapsulates the logic for combining an [AbilityDef] (Base) with a
/// set of Modifiers (Stats/Procs) to produce a deterministic damage snapshot.
///
/// **Usage:**
/// *   **Producers** (Intent Systems): Call `build` to freeze the payload into the intent.
/// *   **UI** (Tooltip/Preview): Call `build` to show predicted damage.
class HitPayloadBuilder {
  static HitPayload build({
    required AbilityDef ability,
    required EntityId source,
    // Modifiers (extracted from WeaponDef or ProjectileItemDef or Buffs)
    WeaponStats? weaponStats,
    DamageType? weaponDamageType,
    List<WeaponProc> weaponProcs = const [],
    List<WeaponProc> buffProcs = const [],
    List<WeaponProc> passiveProcs = const [],
  }) {
    // 1. Start with Ability Base
    int finalDamage100 = ability.baseDamage; // Fixed-point (e.g. 1500 = 15.0)
    DamageType finalDamageType = ability.baseDamageType;
    final List<WeaponProc> finalProcs = [];

    // 2. Apply Weapon Modifiers
    if (weaponStats != null) {
      // A. Power Scaling (Integer Math)
      // Math: damage = base * (1 + bonusBp/10000)
      // Impl: (base * (10000 + bonusBp)) ~/ 10000
      final bonusBp = weaponStats.powerBonusBp;
      if (bonusBp > 0) {
        // e.g. 1500 * 12000 ~/ 10000 = 1800
        finalDamage100 = (finalDamage100 * (10000 + bonusBp)) ~/ 10000;
      }
    }

    if (weaponDamageType != null) {
      // B. Damage Type Override
      // Rule: Weapon overrides Physical ability. Elemental ability (Fire/Ice) keeps its element.
      if (finalDamageType == DamageType.physical) {
        finalDamageType = weaponDamageType;
      }
    }

    // C. Procs (deterministic merge + dedupe)
    // Order is canonical: ability -> item -> buffs -> passives.
    final Set<int> seen = <int>{};
    void addProcs(List<WeaponProc> procs) {
      for (final proc in procs) {
        final key = (proc.hook.index << 16) | proc.statusProfileId.index;
        if (!seen.add(key)) continue;
        finalProcs.add(proc);
      }
    }

    if (ability.procs.isNotEmpty) {
      addProcs(ability.procs);
    }
    if (weaponProcs.isNotEmpty) {
      addProcs(weaponProcs);
    }
    if (buffProcs.isNotEmpty) {
      addProcs(buffProcs);
    }
    if (passiveProcs.isNotEmpty) {
      addProcs(passiveProcs);
    }

    return HitPayload(
      damage100: finalDamage100,
      damageType: finalDamageType,
      procs: finalProcs,
      sourceId: source,
      abilityId: ability.id,
      // Removed weaponId debug field to decouple? Or keep optional?
      // Let's remove weaponId from builder logic, caller can add if needed via 'copyWith'? 
      // Or just omit relevant debug info for now.
    );
  }
}


===== FILE: lib/core/combat/middleware/parry_middleware.dart =====
import '../../abilities/ability_def.dart';
import '../../ecs/stores/damage_queue_store.dart';
import '../../ecs/systems/damage_middleware_system.dart';
import '../../ecs/world.dart';
import '../../events/game_event.dart';

/// Cancels incoming hits while a parry-like ability is active and grants a one-shot riposte buff.
///
/// This is used by multiple abilities (e.g. sword parry, shield block) to keep
/// defense rules centralized and deterministic.
class ParryMiddleware implements DamageMiddleware {
  ParryMiddleware({
    required Set<AbilityKey> abilityIds,
    this.riposteBonusBp = 10000,
    this.riposteLifetimeTicks = 60,
  }) : _abilityIds = abilityIds;

  final Set<AbilityKey> _abilityIds;
  final int riposteBonusBp;
  final int riposteLifetimeTicks;

  @override
  void apply(EcsWorld world, DamageQueueStore queue, int index, int currentTick) {
    final target = queue.target[index];

    if (world.deathState.has(target)) return;
    final ai = world.activeAbility.tryIndexOf(target);
    if (ai == null) return;
    if (!_abilityIds.contains(world.activeAbility.abilityId[ai])) return;

    if (world.activeAbility.phase[ai] != AbilityPhase.active) return;

    // "Hit" only: do not block tick-based damage that comes from already-applied statuses.
    if (queue.sourceKind[index] == DeathSourceKind.statusEffect) return;

    final startTick = world.activeAbility.startTick[ai];

    final elapsed = currentTick - startTick;
    final windup = world.activeAbility.windupTicks[ai];
    final activeElapsed = elapsed - windup;
    if (activeElapsed < 0) return;

    // Always cancel hits during the active parry window.
    queue.flags[index] |= DamageQueueFlags.canceled;

    // Grant riposte only once per activation (first blocked hit),
    // while still canceling subsequent hits during the same activation.
    final consumeIndex = world.parryConsume.indexOfOrAdd(target);
    if (world.parryConsume.consumedStartTick[consumeIndex] == startTick) {
      return;
    }
    world.parryConsume.consumedStartTick[consumeIndex] = startTick;

    // Grant a one-shot bonus that is consumed on the next landed melee hit.
    world.riposte.grant(
      target,
      expiresAtTick: currentTick + riposteLifetimeTicks,
      bonusBp: riposteBonusBp,
    );
  }
}



===== FILE: lib/core/combat/status/status.dart =====
import '../../ecs/entity_id.dart';
import '../damage_type.dart';

/// Runtime status effect categories.
enum StatusEffectType {
  burn,
  slow,
  bleed,
  stun,
}

/// Stable identifiers for status application profiles.
enum StatusProfileId {
  none,
  iceBolt,
  fireBolt,
  meleeBleed,
  stunOnHit,
}

/// A single status application inside a profile.
class StatusApplication {
  const StatusApplication({
    required this.type,
    required this.magnitude,
    required this.durationSeconds,
    this.periodSeconds = 0.0,
    this.scaleByDamageType = false,
  });

  final StatusEffectType type;

  /// Effect strength:
  /// - Slow: basis points (100 = 1%)
  /// - DoT: damage per second in fixed-point (100 = 1.0)
  final int magnitude;

  /// Total duration (seconds).
  final double durationSeconds;

  /// Tick period for DoT effects (seconds). Ignored for non-DoTs.
  final double periodSeconds;

  /// Whether to scale magnitude by damage resistance/vulnerability.
  final bool scaleByDamageType;
}

/// A bundle of status applications applied on hit.
class StatusProfile {
  const StatusProfile(this.applications);

  final List<StatusApplication> applications;
}

/// Lookup table for status profiles.
class StatusProfileCatalog {
  const StatusProfileCatalog();

  StatusProfile get(StatusProfileId id) {
    switch (id) {
      case StatusProfileId.none:
        return const StatusProfile(<StatusApplication>[]);
      case StatusProfileId.iceBolt:
        return const StatusProfile(
          <StatusApplication>[
            StatusApplication(
              type: StatusEffectType.slow,
              magnitude: 2500, // 25%
              durationSeconds: 3.0,
              scaleByDamageType: true,
            ),
          ],
        );
      case StatusProfileId.meleeBleed:
        return const StatusProfile(
          <StatusApplication>[
            StatusApplication(
              type: StatusEffectType.bleed,
              magnitude: 300, // 3.0 DPS
              durationSeconds: 4.0,
              periodSeconds: 1.0,
              scaleByDamageType: true,
            ),
          ],
        );
      case StatusProfileId.fireBolt:
        return const StatusProfile(
          <StatusApplication>[
            StatusApplication(
              type: StatusEffectType.burn,
              magnitude: 500, // 5.0 DPS
              durationSeconds: 5.0,
              periodSeconds: 1.0,
              scaleByDamageType: true,
            ),
          ],
        );
      case StatusProfileId.stunOnHit:
        return const StatusProfile(
          <StatusApplication>[
            StatusApplication(
              type: StatusEffectType.stun,
              magnitude: 100, // placeholder (stun uses duration ticks)
              durationSeconds: 0.5,
              scaleByDamageType: false,
            ),
          ],
        );
    }
  }
}

/// Runtime request for applying a status profile to a target.
class StatusRequest {
  const StatusRequest({
    required this.target,
    required this.profileId,
    this.damageType = DamageType.physical,
  });

  final EntityId target;
  final StatusProfileId profileId;
  final DamageType damageType;
}


===== FILE: lib/core/commands/command.dart =====
/// Core input command model for the deterministic simulation.
///
/// Commands represent discrete user inputs scheduled for a specific simulation tick.
/// To ensure determinism, the UI must schedule commands in advance (via `GameController.enqueue`),
/// and the Core processes them only when the simulation clock reaches the specified [tick].
sealed class Command {
  const Command({required this.tick});

  /// Simulation tick at which this command must be applied.
  final int tick;
}

/// Player movement input for the given tick.
///
/// `axis` is typically in `[-1, 1]` (left/right), originating from a joystick.
final class MoveAxisCommand extends Command {
  const MoveAxisCommand({required super.tick, required this.axis});

  /// Horizontal movement axis, usually in `[-1, 1]`.
  final double axis;
}

/// One-shot jump press event for the given tick.
final class JumpPressedCommand extends Command {
  const JumpPressedCommand({required super.tick});
}

/// One-shot dash press event for the given tick.
final class DashPressedCommand extends Command {
  const DashPressedCommand({required super.tick});
}

/// One-shot strike press event for the given tick.
final class StrikePressedCommand extends Command {
  const StrikePressedCommand({required super.tick});
}

/// One-shot secondary press event for the given tick.
final class SecondaryPressedCommand extends Command {
  const SecondaryPressedCommand({required super.tick});
}

/// Continuous projectile aim direction for the given tick.
///
/// The direction should be normalized (or near-normalized). It is expressed in
/// world space and used by casting/abilities.
final class ProjectileAimDirCommand extends Command {
  const ProjectileAimDirCommand({required super.tick, required this.x, required this.y});

  final double x;
  final double y;
}

/// Continuous melee aim direction for the given tick.
///
/// The direction should be normalized (or near-normalized). It is expressed in
/// world space and used by melee strikes.
final class MeleeAimDirCommand extends Command {
  const MeleeAimDirCommand({
    required super.tick,
    required this.x,
    required this.y,
  });

  final double x;
  final double y;
}

/// Clears any held projectile aim direction for the given tick.
///
/// This exists so input schedulers that pre-buffer future ticks can overwrite
/// previously-scheduled aim commands when the player releases aim input.
final class ClearProjectileAimDirCommand extends Command {
  const ClearProjectileAimDirCommand({required super.tick});
}

/// Clears any held melee aim direction for the given tick.
final class ClearMeleeAimDirCommand extends Command {
  const ClearMeleeAimDirCommand({required super.tick});
}

/// One-shot projectile slot press event for the given tick.
///
/// Preferred over spell/ranged-specific presses when using slot-based input.
final class ProjectilePressedCommand extends Command {
  const ProjectilePressedCommand({required super.tick});
}

/// One-shot bonus press event for the given tick.
final class BonusPressedCommand extends Command {
  const BonusPressedCommand({required super.tick});
}


===== FILE: lib/core/contracts/render_anim_set_definition.dart =====
/// Render animation strip metadata shared between Core and Render.
library;

import '../snapshots/enums.dart';
import '../util/vec2.dart';

/// Data-driven animation strip definition (frame size, paths, timing).
class RenderAnimSetDefinition {
  const RenderAnimSetDefinition({
    required this.frameWidth,
    required this.frameHeight,
    required this.sourcesByKey,
    this.rowByKey = const <AnimKey, int>{},
    this.anchorInFramePx,
    this.frameStartByKey = const <AnimKey, int>{},
    required this.frameCountsByKey,
    required this.stepTimeSecondsByKey,
  });

  final int frameWidth;
  final int frameHeight;

  /// Asset paths (relative to `assets/images/`) for each animation source.
  ///
  /// A single path can be reused for multiple keys:
  /// - **Strip format**: each key points to a single-row horizontal strip (row 0).
  /// - **Sheet format**: multiple keys point to one multi-row sheet, using
  ///   [rowByKey] to select the row for each [AnimKey].
  final Map<AnimKey, String> sourcesByKey;

  /// Optional 0-based row index per [AnimKey] when using a multi-row sheet.
  ///
  /// If a key is missing, render assumes row 0 (strip compatibility).
  final Map<AnimKey, int> rowByKey;

  /// Optional anchor/pivot location inside a single source frame (in pixels).
  ///
  /// When null, render uses `Anchor.center`.
  ///
  /// This is useful when the authored art is not centered on the logical
  /// collider (e.g. enemies with long weapons/tails). The renderer treats the
  /// Core snapshot position as the world-space position of this anchor.
  final Vec2? anchorInFramePx;

  /// Optional 0-based frame start offset per [AnimKey] for strip reuse.
  ///
  /// Defaults to 0 (start of the strip). Use this when multiple animations
  /// share a single horizontal strip but start at different frame indices.
  final Map<AnimKey, int> frameStartByKey;

  final Map<AnimKey, int> frameCountsByKey;
  final Map<AnimKey, double> stepTimeSecondsByKey;
}


===== FILE: lib/core/contracts/render_contract.dart =====
/// Defines the virtual resolution and coordinate system constants for the valid
/// gameplay area.
///
/// These values are the "truth" for the simulation and the renderer.
/// The renderer scales this virtual viewport to fit the actual screen.
library;

/// The fixed virtual width of the gameplay view in logic units (pixels).
const int virtualWidth = 600;

/// The fixed virtual height of the gameplay view in logic units (pixels).
const int virtualHeight = 270;

// -- Asset / Layer dimensions --

/// Width of the background/field layer images.
const int fieldLayerImageWidth = 512;

/// Height of the background/field layer images.
const int fieldLayerImageHeight = 256;

/// Vertical offset to align the bottom of the field layer image with the
/// bottom of the virtual viewport.
///
/// `virtualHeight (270) - fieldLayerImageHeight (256) = 14`.
const int fieldLayerBottomAlignedOffsetY =
    virtualHeight - fieldLayerImageHeight; // 14

/// The Y-coordinate within the field layer image where the ground visual
/// starts (opaque top). Based on asset analysis.
/// used to calculate [groundTopY].
const int fieldLayer09OpaqueTopInImageY = 241;

/// The world-space Y coordinate of the ground surface.
///
/// Calculated as `fieldLayerBottomAlignedOffsetY + fieldLayer09OpaqueTopInImageY`.
/// Entities standing on the ground will have their `maxY` at this value.
const int groundTopY =
    fieldLayerBottomAlignedOffsetY + fieldLayer09OpaqueTopInImageY; // 255

/// The fixed Y coordinate for the camera center.
///
/// The camera only scrolls horizontally.
const double cameraFixedY = virtualHeight / 2; // 135.0

// -- Gameplay Constants --

/// Length of the ray cast for projectile aiming.
const double projectileAimRayLength = virtualWidth * 0.5;

/// Length of the ray cast for melee aiming.
const double meleeAimRayLength = virtualWidth * 0.20;


===== FILE: lib/core/ecs/components/abilities/active_ability_state.dart =====
import 'package:rpg_runner/core/abilities/ability_def.dart';

class ActiveAbilityState {
  AbilityKey? abilityId; // null when idle
  AbilitySlot slot = AbilitySlot.primary;

  AbilityPhase phase = AbilityPhase.idle;
  int phaseTicksRemaining = 0;
  int totalDurationTicks = 0;

  int commitTick = 0; // Tick when the ability committed (costs paid)
  AimSnapshot aim = AimSnapshot.empty;
  
  bool get isIdle => phase == AbilityPhase.idle;
  bool get isBusy => phase != AbilityPhase.idle;

  void reset() {
    abilityId = null;
    slot = AbilitySlot.primary;
    phase = AbilityPhase.idle;
    phaseTicksRemaining = 0;
    totalDurationTicks = 0;
    commitTick = 0;
    aim = AimSnapshot.empty;
  }
}


===== FILE: lib/core/ecs/components/abilities/buffered_input_state.dart =====
import 'package:rpg_runner/core/abilities/ability_def.dart';

class BufferedInputState {
  bool hasValue = false;
  AbilitySlot slot = AbilitySlot.primary;
  int pressedTick = 0;
  AimSnapshot aim = AimSnapshot.empty;

  void set(AbilitySlot s, int tick, AimSnapshot a) {
    hasValue = true;
    slot = s;
    pressedTick = tick;
    aim = a;
  }

  void clear() {
    hasValue = false;
    aim = AimSnapshot.empty;
  }
}


===== FILE: lib/core/ecs/components/death_state.dart =====
class DeathState {
  DeathState({
    required this.phase,
    required this.deathStartTick,
    required this.despawnTick,
    required this.maxFallDespawnTick,
  });

  DeathPhase phase;
  int deathStartTick;
  int despawnTick;
  int maxFallDespawnTick;
}

enum DeathPhase {
  fallingUntilGround,
  deathAnim,
}

class DeathStateComponent {
  final Map<int, DeathState> _data = {};

  bool has(int entity) => _data.containsKey(entity);
  int indexOf(int entity) => entity;
  int? tryIndexOf(int entity) => _data.containsKey(entity) ? entity : null;

  void add(int entity, DeathState state) {
    _data[entity] = state;
  }

  DeathPhase get phase => throw UnimplementedError('Use entity index');
  // This component structure seems to be property-based in the system.
  // Let's look at how other components are used in world.dart or other systems.
}

// Based on the system usage, it expects:
// deathState.phase[di]
// deathState.deathStartTick[di]
// deathState.despawnTick[di]
// deathState.maxFallDespawnTick[di]
// This suggests deathState is a component with multiple arrays or maps.

class DeathStateDef {
  const DeathStateDef({
    required this.phase,
    required this.deathStartTick,
    required this.despawnTick,
    required this.maxFallDespawnTick,
  });

  final DeathPhase phase;
  final int deathStartTick;
  final int despawnTick;
  final int maxFallDespawnTick;
}

===== FILE: lib/core/ecs/entity_factory.dart =====
import '../combat/faction.dart';
import '../enemies/enemy_id.dart';
import '../snapshots/enums.dart';
import '../util/deterministic_rng.dart';
import 'entity_id.dart';
import 'stores/body_store.dart';
import 'stores/collider_aabb_store.dart';
import 'stores/combat/creature_tag_store.dart';
import 'stores/combat/damage_resistance_store.dart';
import 'stores/combat/equipped_loadout_store.dart';
import 'stores/combat/stat_modifier_store.dart';
import 'stores/combat/status_immunity_store.dart';
import 'stores/enemies/enemy_store.dart';
import 'stores/faction_store.dart';
import 'stores/enemies/flying_enemy_steering_store.dart';
import 'stores/enemies/ground_enemy_chase_offset_store.dart';
import 'stores/health_store.dart';
import 'stores/mana_store.dart';
import 'stores/stamina_store.dart';
import 'world.dart';

/// Factory for creating complex entities composed of multiple components.
///
/// This class encapsulates the logic for assembling entities from their constituent
/// components. It ensures that all necessary components are added and initialized
/// correctly for each entity type (e.g., Player, Enemy).
class EntityFactory {
  /// Creates a factory bound to the given [world].
  EntityFactory(this.world);

  /// The [EcsWorld] into which entities will be created.
  final EcsWorld world;

  /// Creates a fully assembled Player entity.
  ///
  /// Adds the following components:
  /// - [TransformStore]: Position and velocity.
  /// - [PlayerInputStore]: Marks this entity as controllable by player input.
  /// - [AnimStateStore]: Stores resolved animation state for rendering.
  /// - [MovementStore]: Handles movement logic and facing direction.
  /// - [BodyStore]: Physics body properties (mass, friction, etc.).
  /// - [ColliderAabbStore]: Axis-aligned bounding box for collision detection.
  /// - [CollisionStateStore]: Tracks current collision state.
  /// - [CooldownStore]: Manages ability cooldowns.
  /// - [ProjectileIntentStore]: Tracks intent to fire projectile items.
  /// - [CreatureTagStore]: Broad combat classification tags.
  /// - [FactionStore]: Sets the faction to [Faction.player].
  /// - [HealthStore]: Health points and max health.
  /// - [DamageResistanceStore]: Damage modifiers per type.
  /// - [InvulnerabilityStore]: Grants temporary invulnerability after damage.
  /// - [LastDamageStore]: Tracks the last source of damage for UI/effects.
  /// - [StatusImmunityStore]: Status effect immunities.
  /// - [ManaStore]: Mana points and max mana.
  /// - [EquippedLoadoutStore]: Equipped abilities and gear.
  /// - [MeleeIntentStore]: Tracks intent to perform melee strikes.
  /// - [MobilityIntentStore]: Tracks intent to perform mobility actions.
  /// - [StatModifierStore]: Runtime stat modifiers from statuses.
  /// - [StaminaStore]: Stamina points and max stamina.
  ///
  /// The [grounded] parameter sets the initial ground state in the collision store.
  EntityId createPlayer({
    required double posX,
    required double posY,
    required double velX,
    required double velY,
    required Facing facing,
    required bool grounded,
    required BodyDef body,
    required ColliderAabbDef collider,
    required HealthDef health,
    required ManaDef mana,
    required StaminaDef stamina,
    CreatureTagDef tags = const CreatureTagDef(),
    DamageResistanceDef resistance = const DamageResistanceDef(),
    StatusImmunityDef statusImmunity = const StatusImmunityDef(),
    EquippedLoadoutDef equippedLoadout = const EquippedLoadoutDef(),
  }) {
    final id = world.createEntity();
    world.transform.add(id, posX: posX, posY: posY, velX: velX, velY: velY);
    world.playerInput.add(id);
    world.abilityInputBuffer.add(id);
    world.activeAbility.add(id);
    world.animState.add(id);
    world.movement.add(id, facing: facing);
    world.body.add(id, body);
    world.colliderAabb.add(id, collider);
    world.collision.add(id);
    world.cooldown.add(id);
    world.creatureTag.add(id, tags);
    world.faction.add(id, const FactionDef(faction: Faction.player));
    world.health.add(id, health);
    world.damageResistance.add(id, resistance);
    world.invulnerability.add(id);
    world.lastDamage.add(id);
    world.statusImmunity.add(id, statusImmunity);
    world.mana.add(id, mana);
    world.meleeIntent.add(id);
    world.mobilityIntent.add(id);
    world.projectileIntent.add(id);
    world.selfIntent.add(id);
    world.equippedLoadout.add(id, equippedLoadout);
    world.statModifier.add(id);
    world.stamina.add(id, stamina);
    world.collision.grounded[world.collision.indexOf(id)] = grounded;
    return id;
  }

  /// Creates an Enemy entity based on the provided [enemyId].
  ///
  /// Adds common components for all enemies:
  /// - [TransformStore]: Position and velocity.
  /// - [BodyStore]: Physics properties.
  /// - [ColliderAabbStore]: Collision boounding box.
  /// - [CollisionStateStore]: Collision state tracking.
  /// - [CooldownStore]: Ability cooldowns.
  /// - [ProjectileIntentStore]: Projectile intent.
  /// - [CreatureTagStore]: Broad combat classification tags.
  /// - [FactionStore]: Sets faction to [Faction.enemy].
  /// - [HealthStore], [ManaStore], [StaminaStore]: Vital stats.
  /// - [MeleeIntentStore]: Melee strike intent.
  /// - [DamageResistanceStore]: Damage modifiers per type.
  /// - [StatusImmunityStore]: Status effect immunities.
  /// - [StatModifierStore]: Runtime stat modifiers from statuses.
  /// - [EnemyStore]: Identifies the entity as an enemy and stores its type.
  /// - [AnimStateStore]: Animation state computed by [AnimSystem].
  /// - [MeleeEngagementStore]: Engagement state for melee AI.
  /// - [NavIntentStore]: Navigation output for ground enemies.
  /// - [EngagementIntentStore]: Engagement output for melee enemies.
  ///
  /// Adds specific components based on [enemyId]:
  /// - [EnemyId.unocoDemon]: Adds [FlyingEnemySteeringStore] for air movement.
  /// - [EnemyId.grojib]: Adds [SurfaceNavStateStore], [GroundEnemyChaseOffsetStore],
  ///   [NavIntentStore], and [EngagementIntentStore] for ground navigation/engagement.
  EntityId createEnemy({
    required EnemyId enemyId,
    required double posX,
    required double posY,
    required double velX,
    required double velY,
    required Facing facing,
    required BodyDef body,
    required ColliderAabbDef collider,
    required HealthDef health,
    required ManaDef mana,
    required StaminaDef stamina,
    CreatureTagDef tags = const CreatureTagDef(),
    DamageResistanceDef resistance = const DamageResistanceDef(),
    StatusImmunityDef statusImmunity = const StatusImmunityDef(),
  }) {
    final id = world.createEntity();
    world.transform.add(id, posX: posX, posY: posY, velX: velX, velY: velY);
    world.body.add(id, body);
    world.colliderAabb.add(id, collider);
    world.collision.add(id);
    world.cooldown.add(id);
    world.projectileIntent.add(id);
    world.creatureTag.add(id, tags);
    world.faction.add(id, const FactionDef(faction: Faction.enemy));
    world.health.add(id, health);
    world.damageResistance.add(id, resistance);
    world.mana.add(id, mana);
    world.meleeIntent.add(id);
    world.meleeEngagement.add(id);
    world.statModifier.add(id);
    world.stamina.add(id, stamina);
    world.enemy.add(id, EnemyDef(enemyId: enemyId, facing: facing));
    world.activeAbility.add(id);
    world.animState.add(id);
    world.statusImmunity.add(id, statusImmunity);
    if (enemyId == EnemyId.unocoDemon) {
      world.flyingEnemySteering.add(
        id,
        FlyingEnemySteeringDef(rngState: seedFrom(world.seed, id)),
      );
    }
    if (enemyId == EnemyId.grojib) {
      world.surfaceNav.add(id);
      world.groundEnemyChaseOffset.add(
        id,
        GroundEnemyChaseOffsetDef(rngState: seedFrom(world.seed, id)),
      );
      world.navIntent.add(id);
      world.engagementIntent.add(id);
    }
    return id;
  }
}


===== FILE: lib/core/ecs/entity_id.dart =====
/// Opaque identifier for entities in the Core simulation.
///
/// An [EntityId] is a simple integer that uniquely identifies an entity within
/// the [EcsWorld]. It serves as a key to access components associated with
/// the entity across different [SparseSet] stores.
///
/// Entity IDs are managed by the [EcsWorld]. When an entity is destroyed, its
/// ID is recycled and may be assigned to a new entity in the future to keep the
/// range of active IDs compact, which benefits the performance of sparse sets.
typedef EntityId = int;


===== FILE: lib/core/ecs/hit/aabb_hit_utils.dart =====
import '../../combat/faction.dart';
import '../entity_id.dart';
import '../world.dart';

/// Shared helpers for hit resolution math + filtering.
///
/// IMPORTANT:
/// - Keep these helpers allocation-free and deterministic.
/// - Systems still own iteration/selection rules (e.g. "first hit wins") until
///   Hit Resolution Module is fully unified.

/// Checks if two factions are allied.
///
/// Used for friendly-fire logic (skipping hits on allies).
bool areAllies(Faction a, Faction b) => a == b;

/// Per-tick cache of "damageable collider targets" to reduce repeated sparse
/// lookups in hot loops.
///
/// A target is included if it has:
/// - `HealthStore` (source list)
/// - `FactionStore` (for friendly-fire filtering)
/// - `TransformStore` + `ColliderAabbStore` (for overlap tests)
///
/// Determinism: preserves `HealthStore.denseEntities` iteration order.
class DamageableTargetCache {
  /// The [EntityId] of the target.
  final List<EntityId> entities = <EntityId>[];
  /// The [Faction] of the target.
  final List<Faction> factions = <Faction>[];

  // World-space collider center and half extents (Parallel arrays).
  final List<double> centerX = <double>[];
  final List<double> centerY = <double>[];
  final List<double> halfX = <double>[];
  final List<double> halfY = <double>[];

  int get length => entities.length;
  bool get isEmpty => entities.isEmpty;

  /// Rebuilds the cache by iterating directly over all entities with Health.
  ///
  /// This is an O(N) operation where N is the number of entities with Health,
  /// but it avoids O(log N) or hashing costs during the hot hit-check loop.
  void rebuild(EcsWorld world) {
    // 1. Reset state.
    entities.clear();
    factions.clear();
    centerX.clear();
    centerY.clear();
    halfX.clear();
    halfY.clear();

    final health = world.health;
    if (health.denseEntities.isEmpty) return;

    // 2. Iterate source (HealthStore) to find potential targets.
    for (var i = 0; i < health.denseEntities.length; i += 1) {
      final e = health.denseEntities[i];

      if (world.deathState.has(e)) continue;

      // 3. Filter: Must have Faction, Transform, and Collider.
      // (Using tryIndexOf avoids exception overhead for missing components)
      final fi = world.faction.tryIndexOf(e);
      if (fi == null) continue;
      final ti = world.transform.tryIndexOf(e);
      if (ti == null) continue;
      final aabbi = world.colliderAabb.tryIndexOf(e);
      if (aabbi == null) continue;

      // 4. Pre-calculate world-space AABB to save work during hit tests.
      // (Transform Pos + Collider Offset)
      final cx = world.transform.posX[ti] + world.colliderAabb.offsetX[aabbi];
      final cy = world.transform.posY[ti] + world.colliderAabb.offsetY[aabbi];

      // 5. Commit valid target to cache.
      entities.add(e);
      factions.add(world.faction.faction[fi]);
      centerX.add(cx);
      centerY.add(cy);
      halfX.add(world.colliderAabb.halfX[aabbi]);
      halfY.add(world.colliderAabb.halfY[aabbi]);
    }
  }
}

/// Checks strict overlap between two AABBs defined by Min/Max coordinates.
///
/// Returns true if they overlap. Touching edges does NOT count as overlap.
bool aabbOverlapsMinMax({
  required double aMinX,
  required double aMaxX,
  required double aMinY,
  required double aMaxY,
  required double bMinX,
  required double bMaxX,
  required double bMinY,
  required double bMaxY,
}) {
  // Classic Separating Axis Theorem (SAT):
  // Overlap exists if and only if ranges overlap on BOTH X and Y axes.
  // (Start of A < End of B) AND (End of A > Start of B)
  return aMinX < bMaxX && aMaxX > bMinX && aMinY < bMaxY && aMaxY > bMinY;
}

/// Checks strict overlap between two AABBs defined by Center/Half-Extents.
bool aabbOverlapsCenters({
  required double aCenterX,
  required double aCenterY,
  required double aHalfX,
  required double aHalfY,
  required double bCenterX,
  required double bCenterY,
  required double bHalfX,
  required double bHalfY,
}) {
  return aabbOverlapsMinMax(
    aMinX: aCenterX - aHalfX,
    aMaxX: aCenterX + aHalfX,
    aMinY: aCenterY - aHalfY,
    aMaxY: aCenterY + aHalfY,
    bMinX: bCenterX - bHalfX,
    bMaxX: bCenterX + bHalfX,
    bMinY: bCenterY - bHalfY,
    bMaxY: bCenterY + bHalfY,
  );
}

/// Helper that resolves entity indices to world components and checks overlap.
bool aabbOverlapsWorldColliders(
  EcsWorld world, {
  required int aTransformIndex,
  required int aAabbIndex,
  required int bTransformIndex,
  required int bAabbIndex,
}) {
  // 1. Resolve world-space AABB for Entity A.
  final aCenterX = world.transform.posX[aTransformIndex] +
      world.colliderAabb.offsetX[aAabbIndex];
  final aCenterY = world.transform.posY[aTransformIndex] +
      world.colliderAabb.offsetY[aAabbIndex];
  final aHalfX = world.colliderAabb.halfX[aAabbIndex];
  final aHalfY = world.colliderAabb.halfY[aAabbIndex];

  // 2. Resolve world-space AABB for Entity B.
  final bCenterX = world.transform.posX[bTransformIndex] +
      world.colliderAabb.offsetX[bAabbIndex];
  final bCenterY = world.transform.posY[bTransformIndex] +
      world.colliderAabb.offsetY[bAabbIndex];
  final bHalfX = world.colliderAabb.halfX[bAabbIndex];
  final bHalfY = world.colliderAabb.halfY[bAabbIndex];

  // 3. Check overlap.
  return aabbOverlapsCenters(
    aCenterX: aCenterX,
    aCenterY: aCenterY,
    aHalfX: aHalfX,
    aHalfY: aHalfY,
    bCenterX: bCenterX,
    bCenterY: bCenterY,
    bHalfX: bHalfX,
    bHalfY: bHalfY,
  );
}


===== FILE: lib/core/ecs/hit/capsule_hit_utils.dart =====
import 'dart:math' as math;

const double _segmentEps = 1e-12;

/// Checks if a capsule (line segment + radius) intersects an Axis-Aligned Bounding Box (AABB).
///
/// The capsule is defined by start point ([ax], [ay]), end point ([bx], [by]),
/// and [radius]. The AABB is defined by min/max coordinates.
///
/// This works by padding the AABB by the capsule radius and performing a segment-to-box
/// intersection test.
bool capsuleIntersectsAabb({
  required double ax,
  required double ay,
  required double bx,
  required double by,
  required double radius,
  required double minX,
  required double minY,
  required double maxX,
  required double maxY,
}) {
  final r = radius < 0 ? 0.0 : radius;
  // Expanding the AABB by the radius allows us to treat the capsule as a simple
  // line segment against the larger box.
  return _segmentIntersectsAabb(
    ax: ax,
    ay: ay,
    bx: bx,
    by: by,
    minX: minX - r,
    minY: minY - r,
    maxX: maxX + r,
    maxY: maxY + r,
  );
}

/// Core segment-AABB intersection test using slab method logic.
///
/// Checks if the line segment from A to B intersects the given AABB.
bool _segmentIntersectsAabb({
  required double ax,
  required double ay,
  required double bx,
  required double by,
  required double minX,
  required double minY,
  required double maxX,
  required double maxY,
}) {
  final dx = bx - ax;
  final dy = by - ay;
  var t0 = 0.0;
  var t1 = 1.0;

  // --- X-axis slab test ---
  if (dx.abs() < _segmentEps) {
    // Segment is parallel to Y-axis. If X is outside, no intersection.
    if (ax < minX || ax > maxX) return false;
  } else {
    // Compute intersection times (t) with X-planes.
    final inv = 1.0 / dx;
    var tNear = (minX - ax) * inv;
    var tFar = (maxX - ax) * inv;
    if (tNear > tFar) {
      final tmp = tNear;
      tNear = tFar;
      tFar = tmp;
    }
    // Narrow the valid segment range [t0, t1].
    t0 = math.max(t0, tNear);
    t1 = math.min(t1, tFar);
    // If range becomes invalid, segment missed.
    if (t0 > t1) return false;
  }

  // --- Y-axis slab test ---
  if (dy.abs() < _segmentEps) {
    // Segment is parallel to X-axis. If Y is outside, no intersection.
    if (ay < minY || ay > maxY) return false;
  } else {
    // Compute intersection times (t) with Y-planes.
    final inv = 1.0 / dy;
    var tNear = (minY - ay) * inv;
    var tFar = (maxY - ay) * inv;
    if (tNear > tFar) {
      final tmp = tNear;
      tNear = tFar;
      tFar = tmp;
    }
    // Further narrow the valid segment range.
    t0 = math.max(t0, tNear);
    t1 = math.min(t1, tFar);
    // If range becomes invalid, segment missed.
    if (t0 > t1) return false;
  }

  // Intersection confirmed if we survived both slab tests.
  return true;
}


===== FILE: lib/core/ecs/hit/hit_resolver.dart =====
import 'dart:math' as math;

import '../../combat/faction.dart';
import '../entity_id.dart';
import '../spatial/broadphase_grid.dart';
import 'aabb_hit_utils.dart';
import 'capsule_hit_utils.dart';

/// Shared narrowphase + deterministic hit candidate ordering.
///
/// Responsibilities:
/// - broadphase query
/// - filtering (owner exclusion + friendly-fire)
/// - AABB overlap test
/// - deterministic ordering (EntityId ascending)
///
/// Non-responsibilities:
/// - world mutation (damage, despawns, HitOnce marking)
class HitResolver {
  // Temporary list to hold candidates from the broadphase before processing.
  final List<int> _candidates = <int>[];

  /// Collects ALL entities intersecting the given AABB into [outTargetIndices].
  ///
  /// The results are filtered strictly (overlaps only) and loosely (owner/friendly fire),
  /// and are guaranteed to be sorted by [EntityId].
  void collectOrderedOverlapsCenters({
    required BroadphaseGrid broadphase,
    required double centerX,
    required double centerY,
    required double halfX,
    required double halfY,
    required EntityId owner,
    required Faction sourceFaction,
    required List<int> outTargetIndices,
  }) {
    outTargetIndices.clear();

    // 1. Broadphase Query + deterministic sort.
    final hasCandidates = _prepareCandidates(
      broadphase: broadphase,
      minX: centerX - halfX,
      minY: centerY - halfY,
      maxX: centerX + halfX,
      maxY: centerY + halfY,
    );
    if (!hasCandidates) return;

    // 2. Narrowphase Check on processed candidates.
    for (var i = 0; i < _candidates.length; i += 1) {
      final targetIndex = _candidates[i];

      // 2a. Filter logic (Owner + Faction).
      if (!_isValidTarget(targetIndex, broadphase, owner, sourceFaction)) {
        continue;
      }

      // 2b. Exact AABB overlap test.
      if (!aabbOverlapsCenters(
        aCenterX: centerX,
        aCenterY: centerY,
        aHalfX: halfX,
        aHalfY: halfY,
        bCenterX: broadphase.targets.centerX[targetIndex],
        bCenterY: broadphase.targets.centerY[targetIndex],
        bHalfX: broadphase.targets.halfX[targetIndex],
        bHalfY: broadphase.targets.halfY[targetIndex],
      )) {
        continue;
      }

      // 3. Collect valid hit.
      outTargetIndices.add(targetIndex);
    }
  }

  /// Returns the FIRST entity intersecting the given AABB (lowest EntityId).
  int? firstOrderedOverlapCenters({
    required BroadphaseGrid broadphase,
    required double centerX,
    required double centerY,
    required double halfX,
    required double halfY,
    required EntityId owner,
    required Faction sourceFaction,
  }) {
    // 1. Broadphase Query.
    final hasCandidates = _prepareCandidates(
      broadphase: broadphase,
      minX: centerX - halfX,
      minY: centerY - halfY,
      maxX: centerX + halfX,
      maxY: centerY + halfY,
    );
    if (!hasCandidates) return null;

    // 2. Determine the first valid hit.
    for (var i = 0; i < _candidates.length; i += 1) {
      final targetIndex = _candidates[i];

      // 2a. Filter logic.
      if (!_isValidTarget(targetIndex, broadphase, owner, sourceFaction)) {
        continue;
      }

      // 2b. Exact AABB overlap test.
      if (!aabbOverlapsCenters(
        aCenterX: centerX,
        aCenterY: centerY,
        aHalfX: halfX,
        aHalfY: halfY,
        bCenterX: broadphase.targets.centerX[targetIndex],
        bCenterY: broadphase.targets.centerY[targetIndex],
        bHalfX: broadphase.targets.halfX[targetIndex],
        bHalfY: broadphase.targets.halfY[targetIndex],
      )) {
        continue;
      }

      // 3. Return immediately on first hit (Sorted by EntityId).
      return targetIndex;
    }

    return null;
  }

  /// Collects ALL entities intersecting the given capsule into [outTargetIndices].
  void collectOrderedOverlapsCapsule({
    required BroadphaseGrid broadphase,
    required double ax,
    required double ay,
    required double bx,
    required double by,
    required double radius,
    required EntityId owner,
    required Faction sourceFaction,
    required List<int> outTargetIndices,
  }) {
    outTargetIndices.clear();

    // 1. Broadphase Query using capsule AABB bounds.
    final hasCandidates = _prepareCandidates(
      broadphase: broadphase,
      minX: math.min(ax, bx) - radius,
      minY: math.min(ay, by) - radius,
      maxX: math.max(ax, bx) + radius,
      maxY: math.max(ay, by) + radius,
    );
    if (!hasCandidates) return;

    // 2. Narrowphase Check.
    for (var i = 0; i < _candidates.length; i += 1) {
      final targetIndex = _candidates[i];

      // 2a. Filter logic.
      if (!_isValidTarget(targetIndex, broadphase, owner, sourceFaction)) {
        continue;
      }

      final targetCenterX = broadphase.targets.centerX[targetIndex];
      final targetCenterY = broadphase.targets.centerY[targetIndex];
      final targetHalfX = broadphase.targets.halfX[targetIndex];
      final targetHalfY = broadphase.targets.halfY[targetIndex];

      // 2b. Capsule vs AABB intersection test.
      if (!capsuleIntersectsAabb(
        ax: ax,
        ay: ay,
        bx: bx,
        by: by,
        radius: radius,
        minX: targetCenterX - targetHalfX,
        minY: targetCenterY - targetHalfY,
        maxX: targetCenterX + targetHalfX,
        maxY: targetCenterY + targetHalfY,
      )) {
        continue;
      }

      // 3. Collect valid hit.
      outTargetIndices.add(targetIndex);
    }
  }

  /// Returns the FIRST entity intersecting the given capsule (lowest EntityId).
  int? firstOrderedOverlapCapsule({
    required BroadphaseGrid broadphase,
    required double ax,
    required double ay,
    required double bx,
    required double by,
    required double radius,
    required EntityId owner,
    required Faction sourceFaction,
  }) {
    // 1. Broadphase Query.
    final hasCandidates = _prepareCandidates(
      broadphase: broadphase,
      minX: math.min(ax, bx) - radius,
      minY: math.min(ay, by) - radius,
      maxX: math.max(ax, bx) + radius,
      maxY: math.max(ay, by) + radius,
    );
    if (!hasCandidates) return null;

    // 2. Determine the first valid hit.
    for (var i = 0; i < _candidates.length; i += 1) {
      final targetIndex = _candidates[i];

      // 2a. Filter logic.
      if (!_isValidTarget(targetIndex, broadphase, owner, sourceFaction)) {
        continue;
      }

      final targetCenterX = broadphase.targets.centerX[targetIndex];
      final targetCenterY = broadphase.targets.centerY[targetIndex];
      final targetHalfX = broadphase.targets.halfX[targetIndex];
      final targetHalfY = broadphase.targets.halfY[targetIndex];

      // 2b. Capsule vs AABB intersection test.
      if (!capsuleIntersectsAabb(
        ax: ax,
        ay: ay,
        bx: bx,
        by: by,
        radius: radius,
        minX: targetCenterX - targetHalfX,
        minY: targetCenterY - targetHalfY,
        maxX: targetCenterX + targetHalfX,
        maxY: targetCenterY + targetHalfY,
      )) {
        continue;
      }

      // 3. Return immediately on first hit.
      return targetIndex;
    }

    return null;
  }

  /// Helper: Runs broadphase query and sorts results by EntityId.
  ///
  /// Returns `false` if no candidates were found.
  bool _prepareCandidates({
    required BroadphaseGrid broadphase,
    required double minX,
    required double minY,
    required double maxX,
    required double maxY,
  }) {
    // 1. Get raw cell-based candidates (contains duplicates if spanning cells).
    broadphase.queryAabbMinMax(
      minX: minX,
      minY: minY,
      maxX: maxX,
      maxY: maxY,
      outTargetIndices: _candidates,
    );
    if (_candidates.isEmpty) return false;

    // 2. Sort by EntityId to ensure deterministic order (1, 2, 3...)
    // regardless of cell iteration order.
    _sortCandidatesByEntityId(broadphase);
    return true;
  }

  /// Helper: Checks non-geometric filtering rules.
  ///
  /// - Excludes [owner] (can't hit self).
  /// - Excludes allies of [sourceFaction] (friendly fire).
  bool _isValidTarget(
    int targetIndex,
    BroadphaseGrid broadphase,
    EntityId owner,
    Faction sourceFaction,
  ) {
    final target = broadphase.targets.entities[targetIndex];
    if (target == owner) return false;

    return !areAllies(
      sourceFaction,
      broadphase.targets.factions[targetIndex],
    );
  }

  void _sortCandidatesByEntityId(BroadphaseGrid broadphase) {
    _candidates.sort(
      (a, b) => broadphase.targets.entities[a].compareTo(
        broadphase.targets.entities[b],
      ),
    );
  }
}


===== FILE: lib/core/ecs/queries.dart =====
import 'entity_id.dart';
import 'world.dart';

/// Callback signature for iterating over entities with movement-related components.
///
/// [e] is the Entity ID.
/// [mi], [ti], [ii], [bi], [ci], [si] are the **dense indices** for:
/// - [mi]: MovementStore
/// - [ti]: TransformStore
/// - [ii]: PlayerInputStore
/// - [bi]: BodyStore
/// - [ci]: CollisionStateStore
/// - [si]: StaminaStore
typedef MovementQueryFn =
    void Function(EntityId e, int mi, int ti, int ii, int bi, int ci, int si);

/// Callback signature for iterating over entities with collision-related components.
///
/// [e] is the Entity ID.
/// [ti], [bi], [coli], [aabbi] are the **dense indices** for:
/// - [ti]: TransformStore
/// - [bi]: BodyStore
/// - [coli]: CollisionStateStore
/// - [aabbi]: ColliderAabbStore
typedef ColliderQueryFn =
    void Function(EntityId e, int ti, int bi, int coli, int aabbi);

/// Provides optimized iteration methods for groups of components used in common systems.
///
/// These static methods perform "joins" across multiple component stores. They iterate
/// efficiently by driving the loop with the "primary" store (usually the one expected
/// to have the fewest entities or the one we want to iterate linearly) and checking
/// for the presence of other required components.
class EcsQueries {
  /// Iterates over all entities that have [MovementStore], [TransformStore],
  /// [PlayerInputStore], [BodyStore], [CollisionStateStore], and [StaminaStore].
  ///
  /// This query is typically used by the [MovementSystem] to process player movement.
  /// It effectively filters for "controllable physics bodies".
  static void forMovementBodies(EcsWorld world, MovementQueryFn fn) {
    // We drive iteration with the MovementStore.
    final movement = world.movement;
    final entities = movement.denseEntities;

    for (var mi = 0; mi < entities.length; mi += 1) {
      final e = entities[mi];

      // Check existence and get indices for all other required components.
      final ti = world.transform.tryIndexOf(e);
      if (ti == null) continue;
      final ii = world.playerInput.tryIndexOf(e);
      if (ii == null) continue;
      final bi = world.body.tryIndexOf(e);
      if (bi == null) continue;
      final ci = world.collision.tryIndexOf(e);
      if (ci == null) continue;
      final si = world.stamina.tryIndexOf(e);
      if (si == null) continue;

      fn(e, mi, ti, ii, bi, ci, si);
    }
  }

  /// Iterates over all entities that have [ColliderAabbStore], [TransformStore],
  /// [BodyStore], and [CollisionStateStore].
  ///
  /// This query finds all physical objects that can collide. It is used by the
  /// [CollisionSystem] to resolve physics interactions.
  static void forColliders(EcsWorld world, ColliderQueryFn fn) {
    // Drive iteration with the ColliderAabbStore.
    final aabb = world.colliderAabb;
    final entities = aabb.denseEntities;

    for (var aabbi = 0; aabbi < entities.length; aabbi += 1) {
      final e = entities[aabbi];

      final ti = world.transform.tryIndexOf(e);
      if (ti == null) continue;
      final bi = world.body.tryIndexOf(e);
      if (bi == null) continue;
      final coli = world.collision.tryIndexOf(e);
      if (coli == null) continue;

      fn(e, ti, bi, coli, aabbi);
    }
  }
}


===== FILE: lib/core/ecs/sparse_set.dart =====
import 'entity_id.dart';

/// Base sparse-set bookkeeping for component stores.
///
/// A sparse set is a data structure that efficiently maps a potentially sparse range
/// of integers (the entity IDs) to a dense, contiguous array of data.
///
/// Internally, it maintains two lists:
/// - `_sparse`: An array indexed by [EntityId]. `_sparse[entity]` stores the
///   index into `denseEntities` plus 1 (0 indicates the entity is not present).
/// - `denseEntities`: A list of [EntityId]s packed contiguously. This allows for
///   fast iteration over all entities that possess this component.
///
/// Subclasses (Component Stores) will maintain their own component data in parallel
/// arrays, also indexed by the values stored in `_sparse` (the "dense index").
///
/// Capabilities:
/// - O(1) membership check (`has`).
/// - O(1) lookup of component data index (`indexOf`).
/// - O(1) insertion (`addEntity`).
/// - O(1) removal (`removeEntity`) using the "swap-and-pop" technique.
/// - Cache-friendly iteration over `denseEntities`.
abstract class SparseSet {
  /// The list of entities that have this component, packed densely.
  /// Iterating this list is the standard way to process all components of this type.
  final List<EntityId> denseEntities = <EntityId>[];

  /// The sparse array mapping EntityId to (denseIndex + 1).
  /// A value of 0 means the entity does not have this component.
  final List<int> _sparse = <int>[];

  /// Returns true if [entity] has this component.
  bool has(EntityId entity) {
    if (entity < 0) return false;
    if (entity >= _sparse.length) return false;
    return _sparse[entity] != 0;
  }

  /// Returns the dense index for [entity].
  ///
  /// Throws if the entity does not have this component. Use [has] or [tryIndexOf] to check.
  int indexOf(EntityId entity) {
    final idxPlus1 = _sparse[entity];
    return idxPlus1 - 1;
  }

  /// Returns the dense index for [entity], or null if it doesn't have this component.
  int? tryIndexOf(EntityId entity) {
    if (entity < 0 || entity >= _sparse.length) return null;
    final idxPlus1 = _sparse[entity];
    if (idxPlus1 == 0) return null;
    return idxPlus1 - 1;
  }

  /// Ensures the internal sparse array is large enough to hold [entity].
  void ensureCapacity(EntityId entity) {
    if (entity < _sparse.length) return;
    final toAdd = entity + 1 - _sparse.length;
    if (toAdd <= 0) return;
    _sparse.addAll(List<int>.filled(toAdd, 0));
  }

  /// Registers [entity] with this store.
  ///
  /// Returns the new stable dense index for this entity's component data.
  /// If the entity is already present, returns its existing dense index.
  ///
  /// Subclasses should call this first, then add their data to their parallel arrays.
  int addEntity(EntityId entity) {
    ensureCapacity(entity);
    final existing = _sparse[entity];
    if (existing != 0) return existing - 1;

    final denseIndex = denseEntities.length;
    denseEntities.add(entity);
    _sparse[entity] = denseIndex + 1;
    onDenseAdded(denseIndex);
    return denseIndex;
  }

  /// Removes [entity] from this store.
  ///
  /// Uses "swap-and-pop" to remove in O(1):
  /// 1. The component data for the entity to be removed is swapped with the
  ///    last component in the dense arrays.
  /// 2. The mapping in `_sparse` for the swapped entity is updated.
  /// 3. The last element is removed (popped).
  ///
  /// This operation changes the dense index of the entity that was at the end.
  void removeEntity(EntityId entity) {
    if (!has(entity)) return;

    final removeIndex = indexOf(entity);
    final lastIndex = denseEntities.length - 1;

    // Hook for subclasses to swap their data arrays before we modify indices.
    onSwapRemove(removeIndex, lastIndex);

    final lastEntity = denseEntities[lastIndex];
    denseEntities[removeIndex] = lastEntity;
    denseEntities.removeLast();

    _sparse[entity] = 0;
    if (removeIndex != lastIndex) {
      // Update the sparse map for the entity that was moved into the empty slot.
      _sparse[lastEntity] = removeIndex + 1;
    }
  }

  /// Called after a new dense slot has been appended.
  /// Subclasses should rely on this to know when a valid index has been established,
  /// though usually they just push data to their lists.
  void onDenseAdded(int denseIndex);

  /// Called before dense arrays are swap-removed from [removeIndex] and [lastIndex].
  ///
  /// Subclasses MUST perform the swap on their parallel data lists inside this method:
  /// `dataList[removeIndex] = dataList[lastIndex]; dataList.removeLast();`
  void onSwapRemove(int removeIndex, int lastIndex);
}


===== FILE: lib/core/ecs/spatial/broadphase_grid.dart =====
import '../hit/aabb_hit_utils.dart';
import '../world.dart';
import 'grid_index_2d.dart';

/// Deterministic broadphase grid rebuilt each tick from dynamic damageable AABBs.
///
/// This grid implementation uses spatial hashing to bucket entities into cells.
/// AABBs that overlap multiple cells are added to all corresponding buckets.
///
/// **Memory Strategy**:
/// - [targets]: Rebuilt every frame to store flat arrays of AABB components.
/// - [_buckets]: Map of cell keys to lists of target indices. Keys are removed
///   when buckets become empty to keep the map size bounded to the visible/active
///   world (vital for infinite runners).
/// - [_bucketPool]: Reuses `List<int>` instances to avoid allocation churn.
/// - [_seenStampByTargetIndex]: Used for O(1) deduplication during queries (avoiding `Set`).
///
/// **Determinism**:
/// - The grid structure itself is order-independent for population.
/// - [queryAabbMinMax] iterates cells in a strict (Y then X) order.
/// - Note: The order of indices *within* a bucket is insertion order (index order in [targets]).
///   Since [targets] is rebuilt by iterating the [EcsWorld], this order depends on
///   Entity ID iteration order.
class BroadphaseGrid {
  BroadphaseGrid({required GridIndex2D index}) : _index = index;

  /// Helper for grid math (coordinate conversion, key packing).
  final GridIndex2D _index;

  /// Stores component data for all damageable entities in the current frame.
  /// Rebuilt at the start of `rebuild()`.
  final DamageableTargetCache targets = DamageableTargetCache();

  // cellKey -> list of target indices into `targets`.
  final Map<int, List<int>> _buckets = <int, List<int>>{};
  // Tracks keys currently in `_buckets` to allow fast iteration/clearing without
  // scanning the whole map (if it were sparse/large).
  final List<int> _activeKeys = <int>[];
  // Pool of lists to avoid allocating new Lists every frame.
  final List<List<int>> _bucketPool = <List<int>>[];

  // Per-query dedup for targets that span multiple cells.
  // We use a "timestamp" strategy: each query increments `_stamp`.
  // If `seen[target] == _stamp`, we've already added it this query.
  final List<int> _seenStampByTargetIndex = <int>[];
  int _stamp = 0;

  /// Rebuilds the spatial grid from the current state of [world].
  ///
  /// This must be called once per tick before any queries are performed.
  void rebuild(EcsWorld world) {
    targets.rebuild(world);

    // clear() old buckets and return lists to the pool.
    // We remove keys from the map to keep the map size small (only active cells).
    for (var i = 0; i < _activeKeys.length; i += 1) {
      final key = _activeKeys[i];
      final bucket = _buckets.remove(key);
      if (bucket == null) continue;
      bucket.clear();
      _bucketPool.add(bucket);
    }
    _activeKeys.clear();

    if (targets.isEmpty) return;

    // Populate buckets.
    for (var ti = 0; ti < targets.length; ti += 1) {
      final cx = targets.centerX[ti];
      final cy = targets.centerY[ti];
      final hx = targets.halfX[ti];
      final hy = targets.halfY[ti];

      // Calculate AABB min/max in world space.
      final minX = cx - hx;
      final maxX = cx + hx;
      final minY = cy - hy;
      final maxY = cy + hy;

      // Convert world AABB to cell index range (inclusive).
      final minCx = _index.worldToCellX(minX);
      final maxCx = _index.worldToCellX(maxX);
      final minCy = _index.worldToCellY(minY);
      final maxCy = _index.worldToCellY(maxY);

      // Add target to every cell its AABB overlaps.
      // This handles "large" entities that span multiple grid cells.
      for (var cellY = minCy; cellY <= maxCy; cellY += 1) {
        for (var cellX = minCx; cellX <= maxCx; cellX += 1) {
          final key = _index.cellKey(cellX, cellY);
          var bucket = _buckets[key];
          if (bucket == null) {
            // Get a list from the pool or allocate new.
            bucket = _bucketPool.isNotEmpty ? _bucketPool.removeLast() : <int>[];
            _buckets[key] = bucket;
            _activeKeys.add(key);
          }
          // Store the target index (not EntityId) for fast lookups.
          bucket.add(ti);
        }
      }
    }
  }

  /// Fills [outTargetIndices] with unique target indices whose AABBs may overlap
  /// the query AABB.
  ///
  /// This involves a broadphase lookup (finding grid cells) and deduplication.
  ///
  /// IMPORTANT (determinism):
  /// - Cell scan order is stable (y then x, increasing).
  /// - The output order depends on bucket insertion order (which depends on entity order).
  /// - Callers must sort by `targets.entities[targetIndex]` if they need a stable
  ///   per-query hit selection order.
  void queryAabbMinMax({
    required double minX,
    required double minY,
    required double maxX,
    required double maxY,
    required List<int> outTargetIndices,
  }) {
    outTargetIndices.clear();
    if (targets.isEmpty) return;

    _stamp += 1;

    // Handle stamp overflow (wrap around)
    if (_stamp == 0x7FFFFFFF) {
      // Reset all seen stamps to 0 so we can safely start over at 1
      for (var i = 0; i < _seenStampByTargetIndex.length; i += 1) {
        _seenStampByTargetIndex[i] = 0;
      }
      _stamp = 1;
    }

    final minCx = _index.worldToCellX(minX);
    final maxCx = _index.worldToCellX(maxX);
    final minCy = _index.worldToCellY(minY);
    final maxCy = _index.worldToCellY(maxY);

    // Ensure strict capacity for the seen array to match current targets.
    // This handles the case where new targets were added in `rebuild`.
    if (_seenStampByTargetIndex.length < targets.length) {
      final missing = targets.length - _seenStampByTargetIndex.length;
      for (var i = 0; i < missing; i += 1) {
        _seenStampByTargetIndex.add(0);
      }
    }

    // Iterate over all cells touched by the query AABB.
    // Order: Row by row (Y), then column by column (X).
    for (var cellY = minCy; cellY <= maxCy; cellY += 1) {
      for (var cellX = minCx; cellX <= maxCx; cellX += 1) {
        final key = _index.cellKey(cellX, cellY);
        final bucket = _buckets[key];
        
        // Skip empty cells.
        if (bucket == null || bucket.isEmpty) continue;

        // Iterate contents of the bucket.
        // Elements are roughly sorted by insertion order (EntityId order).
        for (var bi = 0; bi < bucket.length; bi += 1) {
          final targetIndex = bucket[bi];
          
          // Use stamp to check if already visited this query.
          // This avoids adding the same entity multiple times if it spans multiple cells.
          if (_seenStampByTargetIndex[targetIndex] == _stamp) continue;
          _seenStampByTargetIndex[targetIndex] = _stamp;
          outTargetIndices.add(targetIndex);
        }
      }
    }
  }
}


===== FILE: lib/core/ecs/spatial/grid_index_2d.dart =====
import '../../util/vec2.dart';

class CellAabb {
  const CellAabb({
    required this.minX,
    required this.minY,
    required this.maxX,
    required this.maxY,
  });

  /// World space minimum X coordinate of the cell.
  final double minX;

  /// World space minimum Y coordinate of the cell.
  final double minY;

  /// World space maximum X coordinate of the cell.
  final double maxX;

  /// World space maximum Y coordinate of the cell.
  final double maxY;
}

/// Generic 2D grid math + hashing utility.
///
/// This is intentionally reusable for both:
/// - dynamic broadphase buckets (Milestone 9), and
/// - future nav/cost grids (later milestone).
///
/// IMPORTANT (determinism):
/// - `cellKey(cx, cy)` must be stable and must not use Dart `hashCode`.
class GridIndex2D {
  GridIndex2D({required this.cellSize}) : invCellSize = 1.0 / cellSize;

  /// The width/height of a single square grid cell in world units.
  final double cellSize;

  /// Precomputed `1.0 / cellSize` to avoid divisions in tight loops.
  final double invCellSize;

  /// Converts world X coordinate to grid cell X index.
  /// Uses floor() to handle negative coordinates correctly.
  int worldToCellX(double x) => (x * invCellSize).floor();

  /// Converts world Y coordinate to grid cell Y index.
  int worldToCellY(double y) => (y * invCellSize).floor();

  /// returns the top-left (min) world position of the cell at [cx], [cy].
  Vec2 cellToWorldMin(int cx, int cy) => Vec2(cx * cellSize, cy * cellSize);

  CellAabb cellAabb(int cx, int cy) {
    final minX = cx * cellSize;
    final minY = cy * cellSize;
    return CellAabb(
      minX: minX,
      minY: minY,
      maxX: minX + cellSize,
      maxY: minY + cellSize,
    );
  }

  /// Packs signed (cx, cy) into a single int key (two 32-bit lanes).
  ///
  /// The key is constructed by placing `cy` in the upper 32 bits and `cx` in the
  /// lower 32 bits.
  ///
  /// **Platform Note**: This logic relies on Dart's 64-bit integers (VM/Native).
  /// On the web, where `int` is a double and bitwise operations are 32-bit,
  /// this will lose data (collisions) for keys requiring >32 bits.
  /// For cross-platform safety use a String key or customized class, or ensure
  /// coordinates fit in 16 bits (packed to 32).
  int cellKey(int cx, int cy) {
    // Mask to 32 bits to treat as unsigned for packing, then shift.
    return ((cy & 0xFFFFFFFF) << 32) | (cx & 0xFFFFFFFF);
  }

  /// Iterates 4 neighbors (or 8 if [diagonal] is true) around [cx], [cy].
  ///
  /// Order is guaranteed for determinism:
  /// 1. Cardinals: N, W, E, S
  /// 2. Diagonals (if enabled): NW, NE, SW, SE
  void forNeighbors(
    int cx,
    int cy, {
    bool diagonal = false,
    required void Function(int nx, int ny) visit,
  }) {
    // Stable order (N, W, E, S), then diagonals (NW, NE, SW, SE).
    visit(cx, cy - 1); // North
    visit(cx - 1, cy); // West
    visit(cx + 1, cy); // East
    visit(cx, cy + 1); // South

    if (!diagonal) return;
    
    visit(cx - 1, cy - 1); // NW
    visit(cx + 1, cy - 1); // NE
    visit(cx - 1, cy + 1); // SW
    visit(cx + 1, cy + 1); // SE
  }
}



===== FILE: lib/core/ecs/stores/ability_input_buffer_store.dart =====
import '../../abilities/ability_def.dart';
import '../../snapshots/enums.dart';
import '../entity_id.dart';
import '../sparse_set.dart';

/// Stores a single buffered ability input per entity.
///
/// Buffering is used when an input is pressed during an ability's Recovery phase.
/// The latest press overwrites any previous buffer.
class AbilityInputBufferStore extends SparseSet {
  final List<bool> hasBuffered = <bool>[];
  final List<AbilitySlot> slot = <AbilitySlot>[];
  final List<AbilityKey> abilityId = <AbilityKey>[];
  final List<double> aimDirX = <double>[];
  final List<double> aimDirY = <double>[];
  final List<Facing> facing = <Facing>[];
  final List<int> commitTick = <int>[];
  final List<int> expiresTick = <int>[];

  /// Ensures entity has this component. Idempotent.
  void ensure(EntityId entity) {
    if (!has(entity)) {
      addEntity(entity);
    }
  }

  /// Strict add — asserts entity is NOT already present.
  void add(EntityId entity) {
    assert(!has(entity), 'Entity $entity already has AbilityInputBufferStore');
    addEntity(entity);
  }

  void setBuffer(
    EntityId entity, {
    required AbilitySlot slot,
    required AbilityKey abilityId,
    required double aimDirX,
    required double aimDirY,
    required Facing facing,
    required int commitTick,
    required int expiresTick,
  }) {
    assert(
      has(entity),
      'AbilityInputBufferStore.setBuffer called for entity without AbilityInputBufferStore.',
    );
    final i = indexOf(entity);
    hasBuffered[i] = true;
    this.slot[i] = slot;
    this.abilityId[i] = abilityId;
    this.aimDirX[i] = aimDirX;
    this.aimDirY[i] = aimDirY;
    this.facing[i] = facing;
    this.commitTick[i] = commitTick;
    this.expiresTick[i] = expiresTick;
  }

  void clear(EntityId entity) {
    if (!has(entity)) return;
    final i = indexOf(entity);
    hasBuffered[i] = false;
    commitTick[i] = -1;
    expiresTick[i] = -1;
  }

  @override
  void onDenseAdded(int denseIndex) {
    hasBuffered.add(false);
    slot.add(AbilitySlot.primary);
    abilityId.add('common.unarmed_strike');
    aimDirX.add(0.0);
    aimDirY.add(0.0);
    facing.add(Facing.right);
    commitTick.add(-1);
    expiresTick.add(-1);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    hasBuffered[removeIndex] = hasBuffered[lastIndex];
    slot[removeIndex] = slot[lastIndex];
    abilityId[removeIndex] = abilityId[lastIndex];
    aimDirX[removeIndex] = aimDirX[lastIndex];
    aimDirY[removeIndex] = aimDirY[lastIndex];
    facing[removeIndex] = facing[lastIndex];
    commitTick[removeIndex] = commitTick[lastIndex];
    expiresTick[removeIndex] = expiresTick[lastIndex];

    hasBuffered.removeLast();
    slot.removeLast();
    abilityId.removeLast();
    aimDirX.removeLast();
    aimDirY.removeLast();
    facing.removeLast();
    commitTick.removeLast();
    expiresTick.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/active_ability_state_store.dart =====
import '../../abilities/ability_def.dart';
import '../../snapshots/enums.dart'; // For Facing
import '../sparse_set.dart';
import '../entity_id.dart';

/// Tracks the state of the currently active "Action Ability" for animation purposes.
///
/// This store is the single source of truth for "what action is the character doing?".
/// It replaces disparate timestamps like `lastCastTick`, `lastMeleeTick`, etc.
/// in the Animation System.
///
/// **Design Pillar**:
/// - **Single Channel**: Only one Action Ability active at a time.
/// - **Layering**: Overridden by Death, Stun, and potentially Hit Reactions.
/// - **Lifecycle**: Must be explicitly cleared when the action completes.
class ActiveAbilityStateStore extends SparseSet {
  /// The ID of the ability currently controlling the character.
  /// Null (or empty string/special value) if no ability is active.
  /// Using String (AbilityKey) here. Nullable?
  /// SparseSet usage usually implies non-nullable defaults in lists?
  /// Let's use nullable for logic, or empty string.
  /// Pattern in other stores: List<AbilityKey> with default.
  final List<AbilityKey?> abilityId = [];

  /// The tick when this ability was committed.
  /// Used to calculate (currentTick - commitTick) for phase timing.
  final List<int> startTick = [];

  /// The facing direction at the moment of commitment.
  final List<Facing> facing = [];

  /// Slot that owns this ability (Primary/Secondary/Projectile/Mobility/Bonus).
  final List<AbilitySlot> slot = [];

  /// Current phase of the active ability.
  final List<AbilityPhase> phase = [];

  /// Phase durations (scaled to tickHz at commit time).
  final List<int> windupTicks = [];
  final List<int> activeTicks = [];
  final List<int> recoveryTicks = [];
  final List<int> totalTicks = [];

  /// Cached elapsed ticks since commit (updated by phase system).
  final List<int> elapsedTicks = [];

  // Future: aimDir for multi-directional sprites.

  void add(EntityId entity) {
    addEntity(entity);
  }

  /// Sets the active ability for [entity].
  /// Overwrites any existing ability.
  void set(
    EntityId entity, {
    required AbilityKey id,
    required AbilitySlot slot,
    required int commitTick,
    required int windupTicks,
    required int activeTicks,
    required int recoveryTicks,
    required Facing facingDir,
  }) {
    if (!has(entity)) {
      // Auto-add if missing? Or should it be added at spawn?
      // Best practice: Add at spawn. But here we can safe-guard.
      // EcsWorld usually adds components via add().
      // If we assume it's added, we just assert.
      // But for robustness in this refactor, let's assert.
      assert(has(entity), 'Entity $entity missing ActiveAbilityStateStore');
      return;
    }
    final i = indexOf(entity);
    abilityId[i] = id;
    this.slot[i] = slot;
    startTick[i] = commitTick;
    facing[i] = facingDir;
    this.windupTicks[i] = windupTicks;
    this.activeTicks[i] = activeTicks;
    this.recoveryTicks[i] = recoveryTicks;
    totalTicks[i] = windupTicks + activeTicks + recoveryTicks;
    if (windupTicks > 0) {
      phase[i] = AbilityPhase.windup;
    } else if (activeTicks > 0) {
      phase[i] = AbilityPhase.active;
    } else if (recoveryTicks > 0) {
      phase[i] = AbilityPhase.recovery;
    } else {
      phase[i] = AbilityPhase.idle;
    }
    elapsedTicks[i] = 0;
  }

  /// Clears the active ability state for [entity].
  void clear(EntityId entity) {
    if (has(entity)) {
      final i = indexOf(entity);
      abilityId[i] = null;
      startTick[i] = -1;
      phase[i] = AbilityPhase.idle;
      elapsedTicks[i] = 0;
    }
  }

  /// Checks if [entity] has an active ability.
  bool hasActiveAbility(EntityId entity) {
    if (!has(entity)) return false;
    final i = indexOf(entity);
    return abilityId[i] != null;
  }

  @override
  void onDenseAdded(int denseIndex) {
    abilityId.add(null);
    startTick.add(-1);
    facing.add(Facing.right);
    slot.add(AbilitySlot.primary);
    phase.add(AbilityPhase.idle);
    windupTicks.add(0);
    activeTicks.add(0);
    recoveryTicks.add(0);
    totalTicks.add(0);
    elapsedTicks.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    abilityId[removeIndex] = abilityId[lastIndex];
    startTick[removeIndex] = startTick[lastIndex];
    facing[removeIndex] = facing[lastIndex];
    slot[removeIndex] = slot[lastIndex];
    phase[removeIndex] = phase[lastIndex];
    windupTicks[removeIndex] = windupTicks[lastIndex];
    activeTicks[removeIndex] = activeTicks[lastIndex];
    recoveryTicks[removeIndex] = recoveryTicks[lastIndex];
    totalTicks[removeIndex] = totalTicks[lastIndex];
    elapsedTicks[removeIndex] = elapsedTicks[lastIndex];

    abilityId.removeLast();
    startTick.removeLast();
    facing.removeLast();
    slot.removeLast();
    phase.removeLast();
    windupTicks.removeLast();
    activeTicks.removeLast();
    recoveryTicks.removeLast();
    totalTicks.removeLast();
    elapsedTicks.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/anim/anim_state_store.dart =====
import '../../../snapshots/enums.dart';
import '../../entity_id.dart';
import '../../sparse_set.dart';

/// Per-entity animation state computed by [AnimSystem].
class AnimStateStore extends SparseSet {
  /// Current animation key (idle, run, hit, death, etc.).
  final List<AnimKey> anim = <AnimKey>[];

  /// Frame offset for the current animation (ticks since anim start).
  final List<int> animFrame = <int>[];

  void add(EntityId entity) {
    final i = addEntity(entity);
    anim[i] = AnimKey.idle;
    animFrame[i] = 0;
  }

  @override
  void onDenseAdded(int denseIndex) {
    anim.add(AnimKey.idle);
    animFrame.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    anim[removeIndex] = anim[lastIndex];
    animFrame[removeIndex] = animFrame[lastIndex];

    anim.removeLast();
    animFrame.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/anim/TODO.md =====
# TODO — `lib/core/ecs/stores/anim_state_store.dart`

> Goal: keep `AnimStateStore` **SoA-fast**, safe against misuse (silent resets), and aligned with how AnimSystem writes animation state.

---

## P0 — Correctness / misuse prevention

### [ ] Prevent silent state reset when `add()` is called for an existing entity

**Problem**: `addEntity(entity)` returns an index even if the entity already exists. Calling `add()` twice will overwrite current anim state (idle/0) and hide bugs.

**Fix options** (pick one):

**Option A (recommended): split intent explicitly**

* `ensure(int entity)` → add if missing, do not modify state if already present
* `reset(int entity)` → force idle + frame 0
* Keep `add()` private or remove it.

**Option B: strict add**

* `add(int entity)` asserts `!has(entity)` in debug builds (and/or throws in release if you want to be strict).

**Acceptance**

* Calling “add/ensure” twice never accidentally resets animation.
* Resets are explicit.

---

### [ ] Reduce redundancy between `add()` and `onDenseAdded()`

**Problem**: both set the default state to idle/0 (duplication).

**Task**

* Centralize default initialization in one place.

  * Usually: `onDenseAdded()` initializes arrays, and callers use `ensure()`.

**Acceptance**

* Only one initialization path exists.

---

## P1 — API clarity & ergonomics

### [ ] Provide explicit setters used by systems

AnimSystem likely does something like `store.anim[i]=...; store.animFrame[i]=...`.

**Task**

* Add small helpers for clarity and future invariants:

  * `setByIndex(int dense, AnimKey key, int frame)`
  * `set(int entity, AnimKey key, int frame)`

**Why**

* Makes it trivial to add clamps/invariants later without rewriting every call site.

**Acceptance**

* Systems don’t manually poke arrays everywhere.

---

### [ ] Consider adding getters with safe defaults

**Task**

* `AnimKey getAnim(int entity, {AnimKey defaultKey = AnimKey.idle})`
* `int getFrame(int entity, {int defaultFrame = 0})`

**Acceptance**

* Render path doesn’t need to special-case missing anim state.

---

## P2 — Invariants & safety

### [ ] Clamp/validate `animFrame` (debug)

**Problem**: negative frames or huge frames indicate broken start ticks upstream.

**Task**

* In debug builds:

  * assert `animFrame >= 0`
  * optionally assert `animFrame < someReasonableMax` (or leave unbounded but log)

**Acceptance**

* Broken upstream timing is caught early.

---

### [ ] Document store semantics

Add a short comment describing:

* What `animFrame` means (tick-relative frame hint)
* Whether it can be absolute tick (should converge to “relative ticks since anim start”)
* Who writes it (AnimSystem only)

**Acceptance**

* Future systems don’t mutate anim state.

---

## P3 — Performance (only if needed)

### [ ] Keep arrays tight and reuse memory

Already good: `ensureDenseLength` + `swapRemoveDense`.

**Task**

* If you start storing more fields, keep them SoA and avoid per-entity objects.

---

### [ ] Optional: expose a `writeView` for batched updates

If you want ultra-hot-loop writing:

* expose references or a tiny struct wrapper to avoid repeated bounds checks.

**Only do this after profiling.**

---

## Suggested implementation order

1. Add `ensure()` + `reset()` (or strict `add()`) (P0)
2. Remove redundant init path (P0)
3. Add `set()/setByIndex()` helpers (P1)
4. Add debug asserts + comments (P2)
5. Perf-only changes after profiling (P3)


===== FILE: lib/core/ecs/stores/body_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

/// Configuration for how an entity participates in physics.
///
/// This is intentionally "config-like" and reusable across players/enemies:
/// - `Transform` holds state (pos/vel)
/// - `Movement` holds controller-specific timers/state (coyote, dash, etc.)
/// - `Body` holds physics participation and constraints (gravity, clamps, kinematic)
class BodyDef {
  const BodyDef({
    this.enabled = true,
    this.isKinematic = false,
    this.useGravity = true,
    this.ignoreCeilings = false,
    this.topOnlyGround = true,
    this.gravityScale = 1.0,
    this.maxVelX = defaultMaxVelX,
    this.maxVelY = defaultMaxVelY,
    this.sideMask = sideLeft | sideRight,
  });

  /// Default velocity cap (safety limit).
  static const double defaultMaxVelX = 3000.0;
  static const double defaultMaxVelY = 3000.0;

  /// Master on/off switch for physics on this entity.
  final bool enabled;

  /// If true, physics does not integrate position/velocity (gameplay code drives it).
  final bool isKinematic;

  /// Whether gravity affects this body.
  final bool useGravity;

  /// If true, upward motion ignores bottom faces (ceilings).
  final bool ignoreCeilings;

  /// If true, collision should resolve only top contacts (platformer-style).
  /// Used by `CollisionSystem` (later milestone).
  final bool topOnlyGround;

  /// Scale applied to global/tuning gravity (1.0 = normal gravity).
  final double gravityScale;

  /// Per-axis velocity clamps (safety caps).
  final double maxVelX;
  final double maxVelY;

  /// Horizontal collision sides bitmask (used by `CollisionSystem` later).
  final int sideMask;

  static const int sideNone = 0;
  static const int sideLeft = 1 << 0;
  static const int sideRight = 1 << 1;
}

/// SoA store for `Body` configuration.
class BodyStore extends SparseSet {
  final List<bool> enabled = <bool>[];
  final List<bool> isKinematic = <bool>[];
  final List<bool> useGravity = <bool>[];
  final List<bool> ignoreCeilings = <bool>[];
  final List<bool> topOnlyGround = <bool>[];

  final List<double> gravityScale = <double>[];
  final List<double> maxVelX = <double>[];
  final List<double> maxVelY = <double>[];

  final List<int> sideMask = <int>[];

  void add(EntityId entity, BodyDef def) {
    final i = addEntity(entity);
    enabled[i] = def.enabled;
    isKinematic[i] = def.isKinematic;
    useGravity[i] = def.useGravity;
    ignoreCeilings[i] = def.ignoreCeilings;
    topOnlyGround[i] = def.topOnlyGround;
    gravityScale[i] = def.gravityScale;
    maxVelX[i] = def.maxVelX;
    maxVelY[i] = def.maxVelY;
    sideMask[i] = def.sideMask;
  }

  @override
  void onDenseAdded(int denseIndex) {
    enabled.add(true);
    isKinematic.add(false);
    useGravity.add(true);
    ignoreCeilings.add(false);
    topOnlyGround.add(true);
    gravityScale.add(1);
    maxVelX.add(BodyDef.defaultMaxVelX);
    maxVelY.add(BodyDef.defaultMaxVelY);
    sideMask.add(BodyDef.sideLeft | BodyDef.sideRight);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    enabled[removeIndex] = enabled[lastIndex];
    isKinematic[removeIndex] = isKinematic[lastIndex];
    useGravity[removeIndex] = useGravity[lastIndex];
    ignoreCeilings[removeIndex] = ignoreCeilings[lastIndex];
    topOnlyGround[removeIndex] = topOnlyGround[lastIndex];
    gravityScale[removeIndex] = gravityScale[lastIndex];
    maxVelX[removeIndex] = maxVelX[lastIndex];
    maxVelY[removeIndex] = maxVelY[lastIndex];
    sideMask[removeIndex] = sideMask[lastIndex];

    enabled.removeLast();
    isKinematic.removeLast();
    useGravity.removeLast();
    ignoreCeilings.removeLast();
    topOnlyGround.removeLast();
    gravityScale.removeLast();
    maxVelX.removeLast();
    maxVelY.removeLast();
    sideMask.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/collectible_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

class CollectibleDef {
  const CollectibleDef({required this.value});

  final int value;
}

/// SoA store for collectible metadata.
///
/// Holds the value/score of the collectible.
class CollectibleStore extends SparseSet {
  final List<int> value = <int>[];

  void add(EntityId entity, CollectibleDef def) {
    final i = addEntity(entity);
    value[i] = def.value;
  }

  @override
  void onDenseAdded(int denseIndex) {
    value.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    value[removeIndex] = value[lastIndex];
    value.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/collider_aabb_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

/// AABB collider configuration for an entity.
///
/// Representation is center-based for stability:
/// - `Transform.pos` is treated as the entity center
/// - collider center is `pos + offset`
/// - extents are half-sizes in world units (virtual pixels)
class ColliderAabbDef {
  const ColliderAabbDef({
    required this.halfX,
    required this.halfY,
    this.offsetX = 0,
    this.offsetY = 0,
  });

  final double halfX;
  final double halfY;
  final double offsetX;
  final double offsetY;
}

/// SoA store for AABB collider config (half extents + offset).
///
/// Collision bounds are distinct from render bounds or hitbox bounds (which are temporary).
class ColliderAabbStore extends SparseSet {
  final List<double> halfX = <double>[];
  final List<double> halfY = <double>[];
  final List<double> offsetX = <double>[];
  final List<double> offsetY = <double>[];

  void add(EntityId entity, ColliderAabbDef def) {
    final i = addEntity(entity);
    halfX[i] = def.halfX;
    halfY[i] = def.halfY;
    offsetX[i] = def.offsetX;
    offsetY[i] = def.offsetY;
  }

  @override
  void onDenseAdded(int denseIndex) {
    halfX.add(0);
    halfY.add(0);
    offsetX.add(0);
    offsetY.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    halfX[removeIndex] = halfX[lastIndex];
    halfY[removeIndex] = halfY[lastIndex];
    offsetX[removeIndex] = offsetX[lastIndex];
    offsetY[removeIndex] = offsetY[lastIndex];

    halfX.removeLast();
    halfY.removeLast();
    offsetX.removeLast();
    offsetY.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/collision_state_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

/// Per-tick collision results for an entity.
///
/// This is reset each tick by the CollisionSystem.
/// These flags track *physical* collision (blocking), not combat hits.
class CollisionStateStore extends SparseSet {
  final List<bool> grounded = <bool>[];
  final List<bool> hitCeiling = <bool>[];
  final List<bool> hitLeft = <bool>[];
  final List<bool> hitRight = <bool>[];

  void add(EntityId entity) {
    addEntity(entity);
  }

  void resetTick(EntityId entity) {
    final i = indexOf(entity);
    grounded[i] = false;
    hitCeiling[i] = false;
    hitLeft[i] = false;
    hitRight[i] = false;
  }

  @override
  void onDenseAdded(int denseIndex) {
    grounded.add(false);
    hitCeiling.add(false);
    hitLeft.add(false);
    hitRight.add(false);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    grounded[removeIndex] = grounded[lastIndex];
    hitCeiling[removeIndex] = hitCeiling[lastIndex];
    hitLeft[removeIndex] = hitLeft[lastIndex];
    hitRight[removeIndex] = hitRight[lastIndex];

    grounded.removeLast();
    hitCeiling.removeLast();
    hitLeft.removeLast();
    hitRight.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/combat/creature_tag_store.dart =====
import '../../../combat/creature_tag.dart';
import '../../entity_id.dart';
import '../../sparse_set.dart';

class CreatureTagDef {
  const CreatureTagDef({this.mask = 0});

  final int mask;
}

/// Broad tag classifications for creatures (enemies + player variants).
class CreatureTagStore extends SparseSet {
  final List<int> tagsMask = <int>[];

  void add(EntityId entity, [CreatureTagDef def = const CreatureTagDef()]) {
    final i = addEntity(entity);
    tagsMask[i] = def.mask;
  }

  bool hasTag(EntityId entity, CreatureTag tag) {
    final i = tryIndexOf(entity);
    if (i == null) return false;
    return (tagsMask[i] & CreatureTagMask.forTag(tag)) != 0;
  }

  void addTag(EntityId entity, CreatureTag tag) {
    final i = tryIndexOf(entity);
    if (i == null) return;
    tagsMask[i] |= CreatureTagMask.forTag(tag);
  }

  @override
  void onDenseAdded(int denseIndex) {
    tagsMask.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    tagsMask[removeIndex] = tagsMask[lastIndex];
    tagsMask.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/combat/damage_resistance_store.dart =====
import '../../../combat/damage_type.dart';
import '../../entity_id.dart';
import '../../sparse_set.dart';

class DamageResistanceDef {
  const DamageResistanceDef({
    this.physicalBp = 0,
    this.fireBp = 0,
    this.iceBp = 0,
    this.thunderBp = 0,
    this.bleedBp = 0,
  });

  /// Basis points (100 = 1%).
  final int physicalBp;
  final int fireBp;
  final int iceBp;
  final int thunderBp;
  final int bleedBp;

  int modBpFor(DamageType type) {
    switch (type) {
      case DamageType.physical:
        return physicalBp;
      case DamageType.fire:
        return fireBp;
      case DamageType.ice:
        return iceBp;
      case DamageType.thunder:
        return thunderBp;
      case DamageType.bleed:
        return bleedBp;
    }
  }
}

/// Per-entity resistance/vulnerability modifiers by [DamageType].
class DamageResistanceStore extends SparseSet {
  /// Basis points (100 = 1%).
  final List<int> physicalBp = <int>[];
  final List<int> fireBp = <int>[];
  final List<int> iceBp = <int>[];
  final List<int> thunderBp = <int>[];
  final List<int> bleedBp = <int>[];

  void add(EntityId entity, [DamageResistanceDef def = const DamageResistanceDef()]) {
    final i = addEntity(entity);
    physicalBp[i] = def.physicalBp;
    fireBp[i] = def.fireBp;
    iceBp[i] = def.iceBp;
    thunderBp[i] = def.thunderBp;
    bleedBp[i] = def.bleedBp;
  }

  int modBpForEntity(EntityId entity, DamageType type) {
    final i = tryIndexOf(entity);
    if (i == null) return 0;
    return modBpForIndex(i, type);
  }

  int modBpForIndex(int index, DamageType type) {
    switch (type) {
      case DamageType.physical:
        return physicalBp[index];
      case DamageType.fire:
        return fireBp[index];
      case DamageType.ice:
        return iceBp[index];
      case DamageType.thunder:
        return thunderBp[index];
      case DamageType.bleed:
        return bleedBp[index];
    }
  }

  @override
  void onDenseAdded(int denseIndex) {
    physicalBp.add(0);
    fireBp.add(0);
    iceBp.add(0);
    thunderBp.add(0);
    bleedBp.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    physicalBp[removeIndex] = physicalBp[lastIndex];
    fireBp[removeIndex] = fireBp[lastIndex];
    iceBp[removeIndex] = iceBp[lastIndex];
    thunderBp[removeIndex] = thunderBp[lastIndex];
    bleedBp[removeIndex] = bleedBp[lastIndex];

    physicalBp.removeLast();
    fireBp.removeLast();
    iceBp.removeLast();
    thunderBp.removeLast();
    bleedBp.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/combat/equipped_loadout_store.dart =====
import '../../../projectiles/projectile_item_id.dart';
import '../../../weapons/weapon_id.dart';
import '../../entity_id.dart';
import '../../sparse_set.dart';
import '../../../abilities/ability_def.dart';

/// Bitmask constants for loadout slots.
///
/// Each bit represents a slot that a character may or may not have access to.
/// Use these to check/set which equipment slots are enabled for an entity.
class LoadoutSlotMask {
  const LoadoutSlotMask._();

  /// Main hand weapon slot (melee).
  static const int mainHand = 1 << 0;

  /// Off-hand slot (shield or secondary weapon).
  static const int offHand = 1 << 1;

  /// Projectile slot (spells or throwing weapons).
  static const int projectile = 1 << 2;

  /// All slots enabled.
  static const int all = mainHand | offHand | projectile;

  /// Default slots for most characters (no off-hand).
  static const int defaultMask = mainHand | projectile;
}

/// Definition for creating an equipped loadout component.
class EquippedLoadoutDef {
  const EquippedLoadoutDef({
    this.mask = LoadoutSlotMask.defaultMask,
    this.mainWeaponId = WeaponId.basicSword,
    this.offhandWeaponId = WeaponId.basicShield,
    this.projectileItemId = ProjectileItemId.iceBolt,
    // Default abilities (Eloise defaults for now)
    this.abilityPrimaryId = 'eloise.sword_strike',
    this.abilitySecondaryId = 'eloise.shield_block',
    this.abilityProjectileId = 'eloise.ice_bolt',
    this.abilityBonusId = 'eloise.ice_bolt',
    this.abilityMobilityId = 'eloise.dash',
    this.abilityJumpId = 'eloise.jump',
  });

  /// Bitmask of enabled slots (see [LoadoutSlotMask]).
  final int mask;

  /// Main hand weapon.
  final WeaponId mainWeaponId;

  /// Off-hand weapon or shield.
  final WeaponId offhandWeaponId;

  /// Equipped projectile item (spell or throwing weapon).
  final ProjectileItemId projectileItemId;

  // New Ability System IDs
  final AbilityKey abilityPrimaryId;
  final AbilityKey abilitySecondaryId;
  final AbilityKey abilityProjectileId;
  final AbilityKey abilityBonusId;
  final AbilityKey abilityMobilityId;
  final AbilityKey abilityJumpId;
}

/// Per-entity equipment loadout (single source of truth).
///
/// This store holds all equipped items for an entity in a unified structure.
/// Systems should read from this store for equipment info.
///
/// **Slot mask**: Determines which slots are available for this entity.
/// Use [hasSlot] to check if an entity has a specific slot enabled.
class EquippedLoadoutStore extends SparseSet {
  // SoA fields for each component.
  final List<int> mask = <int>[];
  final List<WeaponId> mainWeaponId = <WeaponId>[];
  final List<WeaponId> offhandWeaponId = <WeaponId>[];
  final List<ProjectileItemId> projectileItemId = <ProjectileItemId>[];
  
  // New Ability System Lists
  final List<AbilityKey> abilityPrimaryId = <AbilityKey>[];
  final List<AbilityKey> abilitySecondaryId = <AbilityKey>[];
  final List<AbilityKey> abilityProjectileId = <AbilityKey>[];
  final List<AbilityKey> abilityBonusId = <AbilityKey>[];
  final List<AbilityKey> abilityMobilityId = <AbilityKey>[];
  final List<AbilityKey> abilityJumpId = <AbilityKey>[];

  void add(EntityId entity, [EquippedLoadoutDef def = const EquippedLoadoutDef()]) {
    final i = addEntity(entity);
    mask[i] = def.mask;
    mainWeaponId[i] = def.mainWeaponId;
    offhandWeaponId[i] = def.offhandWeaponId;
    projectileItemId[i] = def.projectileItemId;
    abilityPrimaryId[i] = def.abilityPrimaryId;
    abilitySecondaryId[i] = def.abilitySecondaryId;
    abilityProjectileId[i] = def.abilityProjectileId;
    abilityBonusId[i] = def.abilityBonusId;
    abilityMobilityId[i] = def.abilityMobilityId;
    abilityJumpId[i] = def.abilityJumpId;
  }

  /// Updates the loadout for an existing entity.
  void set(EntityId entity, EquippedLoadoutDef def) {
    final i = indexOf(entity);
    mask[i] = def.mask;
    mainWeaponId[i] = def.mainWeaponId;
    offhandWeaponId[i] = def.offhandWeaponId;
    projectileItemId[i] = def.projectileItemId;
    abilityPrimaryId[i] = def.abilityPrimaryId;
    abilitySecondaryId[i] = def.abilitySecondaryId;
    abilityProjectileId[i] = def.abilityProjectileId;
    abilityBonusId[i] = def.abilityBonusId;
    abilityMobilityId[i] = def.abilityMobilityId;
    abilityJumpId[i] = def.abilityJumpId;
  }

  /// Returns true if [entity] has the given [slotBit] enabled.
  bool hasSlot(EntityId entity, int slotBit) {
    final i = tryIndexOf(entity);
    if (i == null) return false;
    return (mask[i] & slotBit) != 0;
  }

  @override
  void onDenseAdded(int denseIndex) {
    mask.add(LoadoutSlotMask.defaultMask);
    mainWeaponId.add(WeaponId.basicSword);
    offhandWeaponId.add(WeaponId.basicShield);
    projectileItemId.add(ProjectileItemId.iceBolt);
    abilityPrimaryId.add('eloise.sword_strike');
    abilitySecondaryId.add('eloise.shield_block');
    abilityProjectileId.add('eloise.ice_bolt');
    abilityBonusId.add('eloise.ice_bolt');
    abilityMobilityId.add('eloise.dash');
    abilityJumpId.add('eloise.jump');
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    mask[removeIndex] = mask[lastIndex];
    mainWeaponId[removeIndex] = mainWeaponId[lastIndex];
    offhandWeaponId[removeIndex] = offhandWeaponId[lastIndex];
    projectileItemId[removeIndex] = projectileItemId[lastIndex];
    abilityPrimaryId[removeIndex] = abilityPrimaryId[lastIndex];
    abilitySecondaryId[removeIndex] = abilitySecondaryId[lastIndex];
    abilityProjectileId[removeIndex] = abilityProjectileId[lastIndex];
    abilityBonusId[removeIndex] = abilityBonusId[lastIndex];
    abilityMobilityId[removeIndex] = abilityMobilityId[lastIndex];
    abilityJumpId[removeIndex] = abilityJumpId[lastIndex];

    mask.removeLast();
    mainWeaponId.removeLast();
    offhandWeaponId.removeLast();
    projectileItemId.removeLast();
    abilityPrimaryId.removeLast();
    abilitySecondaryId.removeLast();
    abilityProjectileId.removeLast();
    abilityBonusId.removeLast();
    abilityMobilityId.removeLast();
    abilityJumpId.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/combat/stat_modifier_store.dart =====
import '../../entity_id.dart';
import '../../sparse_set.dart';

class StatModifierDef {
  const StatModifierDef({this.moveSpeedMul = 1.0});

  final double moveSpeedMul;
}

/// Runtime modifiers derived from status effects and buffs.
class StatModifierStore extends SparseSet {
  final List<double> moveSpeedMul = <double>[];

  void add(EntityId entity, [StatModifierDef def = const StatModifierDef()]) {
    final i = addEntity(entity);
    moveSpeedMul[i] = def.moveSpeedMul;
  }

  @override
  void onDenseAdded(int denseIndex) {
    moveSpeedMul.add(1.0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    moveSpeedMul[removeIndex] = moveSpeedMul[lastIndex];
    moveSpeedMul.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/combat/status_immunity_store.dart =====
import '../../../combat/status/status.dart';
import '../../entity_id.dart';
import '../../sparse_set.dart';

class StatusImmunityMask {
  const StatusImmunityMask._();

  static const int burn = 1 << 0;
  static const int slow = 1 << 1;
  static const int bleed = 1 << 2;
  static const int stun = 1 << 3;
  static int forType(StatusEffectType type) {
    switch (type) {
      case StatusEffectType.burn:
        return burn;
      case StatusEffectType.slow:
        return slow;
      case StatusEffectType.bleed:
        return bleed;
      case StatusEffectType.stun:
        return stun;
    }
  }
}

class StatusImmunityDef {
  const StatusImmunityDef({this.mask = 0});

  final int mask;
}

/// Per-entity status immunities (bitmask of [StatusEffectType]).
class StatusImmunityStore extends SparseSet {
  final List<int> mask = <int>[];

  void add(EntityId entity, [StatusImmunityDef def = const StatusImmunityDef()]) {
    final i = addEntity(entity);
    mask[i] = def.mask;
  }

  bool isImmune(EntityId entity, StatusEffectType type) {
    final i = tryIndexOf(entity);
    if (i == null) return false;
    return (mask[i] & StatusImmunityMask.forType(type)) != 0;
  }

  @override
  void onDenseAdded(int denseIndex) {
    mask.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    mask[removeIndex] = mask[lastIndex];
    mask.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/control_lock_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';
import '../../combat/control_lock.dart';

/// SoA store for control locks with per-flag expiry.
///
/// Each flag has its own `untilTick` field. A lock is active if
/// `currentTick < untilTick`. The [activeMask] is recomputed each tick
/// by [ControlLockSystem].
///
/// **Refresh rule**: When adding a lock, use `max(existing, new)` for the
/// untilTick to handle overlapping/refreshing locks correctly.
class ControlLockStore extends SparseSet {
  /// Cached active mask (refreshed each tick by ControlLockSystem).
  final List<int> activeMask = <int>[];

  /// Per-flag expiry ticks.
  final List<int> untilTickStun = <int>[];
  final List<int> untilTickMove = <int>[];
  final List<int> untilTickJump = <int>[];
  final List<int> untilTickDash = <int>[];
  final List<int> untilTickStrike = <int>[];
  final List<int> untilTickCast = <int>[];
  final List<int> untilTickRanged = <int>[];
  final List<int> untilTickNav = <int>[];

  // ─────────────────────────────────────────────────────────────────────────
  // Public API
  // ─────────────────────────────────────────────────────────────────────────

  /// Adds or refreshes a lock on [entity].
  ///
  /// Uses `max(existing, new)` for the untilTick to correctly handle
  /// refreshing or overlapping locks with different durations.
  void addLock(EntityId entity, int flag, int durationTicks, int currentTick) {
    if (durationTicks <= 0) return;

    final newUntilTick = currentTick + durationTicks;

    int idx = tryIndexOf(entity) ?? addEntity(entity);

    // Apply lock(s) using max() for refresh behavior
    if ((flag & LockFlag.stun) != 0) {
      untilTickStun[idx] = _max(untilTickStun[idx], newUntilTick);
    }
    if ((flag & LockFlag.move) != 0) {
      untilTickMove[idx] = _max(untilTickMove[idx], newUntilTick);
    }
    if ((flag & LockFlag.jump) != 0) {
      untilTickJump[idx] = _max(untilTickJump[idx], newUntilTick);
    }
    if ((flag & LockFlag.dash) != 0) {
      untilTickDash[idx] = _max(untilTickDash[idx], newUntilTick);
    }
    if ((flag & LockFlag.strike) != 0) {
      untilTickStrike[idx] = _max(untilTickStrike[idx], newUntilTick);
    }
    if ((flag & LockFlag.cast) != 0) {
      untilTickCast[idx] = _max(untilTickCast[idx], newUntilTick);
    }
    if ((flag & LockFlag.ranged) != 0) {
      untilTickRanged[idx] = _max(untilTickRanged[idx], newUntilTick);
    }
    if ((flag & LockFlag.nav) != 0) {
      untilTickNav[idx] = _max(untilTickNav[idx], newUntilTick);
    }

    // Update cached mask immediately
    _refreshMaskAt(idx, currentTick);
  }

  /// Returns true if [entity] has [flag] locked.
  bool isLocked(EntityId entity, int flag, int currentTick) {
    final idx = tryIndexOf(entity);
    if (idx == null) return false;

    // Check stun first (master lock)
    if (currentTick < untilTickStun[idx]) return true;

    // Then check specific flag
    return _isFlagActiveAt(idx, flag, currentTick);
  }

  /// Returns true if [entity] is stunned.
  ///
  /// This is the primary check for gameplay systems. Stun blocks everything.
  bool isStunned(EntityId entity, int currentTick) {
    final idx = tryIndexOf(entity);
    if (idx == null) return false;
    return currentTick < untilTickStun[idx];
  }

  /// Returns the cached active mask for [entity].
  ///
  /// Note: This mask is refreshed by ControlLockSystem each tick.
  /// For immediate checks, use [isLocked] or [isStunned].
  int getActiveMask(EntityId entity) {
    final idx = tryIndexOf(entity);
    if (idx == null) return 0;
    return activeMask[idx];
  }

  /// Refreshes the active mask for entity at [idx] based on [currentTick].
  ///
  /// Called by ControlLockSystem each tick and after addLock.
  void refreshMask(int idx, int currentTick) {
    _refreshMaskAt(idx, currentTick);
  }

  // ─────────────────────────────────────────────────────────────────────────
  // SparseSet overrides
  // ─────────────────────────────────────────────────────────────────────────

  @override
  void onDenseAdded(int denseIndex) {
    activeMask.add(0);
    untilTickStun.add(0);
    untilTickMove.add(0);
    untilTickJump.add(0);
    untilTickDash.add(0);
    untilTickStrike.add(0);
    untilTickCast.add(0);
    untilTickRanged.add(0);
    untilTickNav.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    activeMask[removeIndex] = activeMask[lastIndex];
    untilTickStun[removeIndex] = untilTickStun[lastIndex];
    untilTickMove[removeIndex] = untilTickMove[lastIndex];
    untilTickJump[removeIndex] = untilTickJump[lastIndex];
    untilTickDash[removeIndex] = untilTickDash[lastIndex];
    untilTickStrike[removeIndex] = untilTickStrike[lastIndex];
    untilTickCast[removeIndex] = untilTickCast[lastIndex];
    untilTickRanged[removeIndex] = untilTickRanged[lastIndex];
    untilTickNav[removeIndex] = untilTickNav[lastIndex];

    activeMask.removeLast();
    untilTickStun.removeLast();
    untilTickMove.removeLast();
    untilTickJump.removeLast();
    untilTickDash.removeLast();
    untilTickStrike.removeLast();
    untilTickCast.removeLast();
    untilTickRanged.removeLast();
    untilTickNav.removeLast();
  }

  // ─────────────────────────────────────────────────────────────────────────
  // Private helpers
  // ─────────────────────────────────────────────────────────────────────────

  void _refreshMaskAt(int idx, int currentTick) {
    int mask = 0;
    if (currentTick < untilTickStun[idx]) mask |= LockFlag.stun;
    if (currentTick < untilTickMove[idx]) mask |= LockFlag.move;
    if (currentTick < untilTickJump[idx]) mask |= LockFlag.jump;
    if (currentTick < untilTickDash[idx]) mask |= LockFlag.dash;
    if (currentTick < untilTickStrike[idx]) mask |= LockFlag.strike;
    if (currentTick < untilTickCast[idx]) mask |= LockFlag.cast;
    if (currentTick < untilTickRanged[idx]) mask |= LockFlag.ranged;
    if (currentTick < untilTickNav[idx]) mask |= LockFlag.nav;
    activeMask[idx] = mask;
  }

  bool _isFlagActiveAt(int idx, int flag, int currentTick) {
    if ((flag & LockFlag.move) != 0 && currentTick < untilTickMove[idx]) {
      return true;
    }
    if ((flag & LockFlag.jump) != 0 && currentTick < untilTickJump[idx]) {
      return true;
    }
    if ((flag & LockFlag.dash) != 0 && currentTick < untilTickDash[idx]) {
      return true;
    }
    if ((flag & LockFlag.strike) != 0 && currentTick < untilTickStrike[idx]) {
      return true;
    }
    if ((flag & LockFlag.cast) != 0 && currentTick < untilTickCast[idx]) {
      return true;
    }
    if ((flag & LockFlag.ranged) != 0 && currentTick < untilTickRanged[idx]) {
      return true;
    }
    if ((flag & LockFlag.nav) != 0 && currentTick < untilTickNav[idx]) {
      return true;
    }
    return false;
  }

  static int _max(int a, int b) => a > b ? a : b;
}


===== FILE: lib/core/ecs/stores/cooldown_store.dart =====
import '../../abilities/ability_def.dart';
import '../entity_id.dart';
import '../sparse_set.dart';

/// Tracks ability cooldowns by group index.
///
/// Each entity has [kMaxCooldownGroups] cooldown slots (default 8).
/// Abilities sharing a group share a cooldown.
///
/// **SoA Layout**: `ticksLeft[entityIndex * kMaxCooldownGroups + groupId]`
class CooldownStore extends SparseSet {
  /// Ticks remaining per group.
  /// Access via: ticksLeft[entityIndex * kMaxCooldownGroups + groupId]
  final List<int> _ticksLeft = <int>[];

  /// Ensures entity has this component. Idempotent.
  void ensure(EntityId entity) {
    if (!has(entity)) {
      addEntity(entity);
    }
  }

  /// Strict add — asserts entity is NOT already present.
  void add(EntityId entity) {
    assert(!has(entity), 'Entity $entity already has CooldownStore');
    addEntity(entity);
  }

  /// Resets all cooldowns for entity to 0.
  void reset(EntityId entity) {
    if (!has(entity)) return;
    final i = indexOf(entity);
    for (var g = 0; g < kMaxCooldownGroups; g++) {
      _ticksLeft[i * kMaxCooldownGroups + g] = 0;
    }
  }

  /// Gets ticks remaining for a specific cooldown group.
  int getTicksLeft(EntityId entity, int groupId) {
    assert(
      groupId >= 0 && groupId < kMaxCooldownGroups,
      'Group ID must be in range [0, $kMaxCooldownGroups)',
    );
    if (!has(entity)) return 0;
    final i = indexOf(entity);
    return _ticksLeft[i * kMaxCooldownGroups + groupId];
  }

  /// Sets ticks remaining for a specific cooldown group.
  void setTicksLeft(EntityId entity, int groupId, int ticks) {
    assert(
      groupId >= 0 && groupId < kMaxCooldownGroups,
      'Group ID must be in range [0, $kMaxCooldownGroups)',
    );
    assert(has(entity), 'Entity $entity missing CooldownStore');
    final i = indexOf(entity);
    _ticksLeft[i * kMaxCooldownGroups + groupId] = ticks;
  }

  /// Starts a cooldown for the given group.
  ///
  /// Uses "max refresh" semantics: if the group is already on cooldown,
  /// the new duration is applied only if it is longer than the current remaining ticks.
  /// This prevents accidental shortening of cooldowns.
  void startCooldown(EntityId entity, int groupId, int durationTicks) {
    final i = indexOf(entity);
    final idx = i * kMaxCooldownGroups + groupId;
    final current = _ticksLeft[idx];
    if (durationTicks > current) {
      _ticksLeft[idx] = durationTicks;
    }
  }

  /// Checks if a cooldown group is active (ticks remaining > 0).
  bool isOnCooldown(EntityId entity, int groupId) {
    return getTicksLeft(entity, groupId) > 0;
  }

  /// Decrements all cooldowns by 1 tick for all entities.
  /// Called by CooldownSystem each tick.
  void tickAll() {
    final count = denseEntities.length;
    for (var i = 0; i < count; i++) {
      for (var g = 0; g < kMaxCooldownGroups; g++) {
        final idx = i * kMaxCooldownGroups + g;
        if (_ticksLeft[idx] > 0) {
          _ticksLeft[idx] -= 1;
        }
      }
    }
  }

  // SparseSet overrides
  // ---------------------------------------------------------------------------

  @override
  void onDenseAdded(int denseIndex) {
    // Add kMaxCooldownGroups slots for new entity, all initialized to 0
    for (var g = 0; g < kMaxCooldownGroups; g++) {
      _ticksLeft.add(0);
    }
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    // Swap all group slots
    for (var g = 0; g < kMaxCooldownGroups; g++) {
      final ri = removeIndex * kMaxCooldownGroups + g;
      final li = lastIndex * kMaxCooldownGroups + g;
      _ticksLeft[ri] = _ticksLeft[li];
    }
    // Remove last kMaxCooldownGroups entries
    _ticksLeft.length -= kMaxCooldownGroups;
  }
}


===== FILE: lib/core/ecs/stores/damage_queue_store.dart =====
import '../../combat/damage.dart';
import '../../combat/damage_type.dart';
import '../../enemies/enemy_id.dart';
import '../../events/game_event.dart';
import '../../projectiles/projectile_id.dart';
import '../../projectiles/projectile_item_id.dart';
import '../../weapons/weapon_proc.dart';
import '../entity_id.dart';

/// Flags stored alongside queued damage requests.
class DamageQueueFlags {
  static const int canceled = 1 << 0;
}

/// World-level queue for pending damage requests (SoA).
///
/// This queue is populated by hit resolution systems and processed by
/// [DamageMiddlewareSystem] and [DamageSystem].
class DamageQueueStore {
  final List<EntityId> target = <EntityId>[];
  final List<int> amount100 = <int>[];
  final List<DamageType> damageType = <DamageType>[];
  final List<List<WeaponProc>> procs = <List<WeaponProc>>[];
  final List<DeathSourceKind> sourceKind = <DeathSourceKind>[];
  final List<EntityId?> sourceEntity = <EntityId?>[];
  final List<EnemyId?> sourceEnemyId = <EnemyId?>[];
  final List<ProjectileId?> sourceProjectileId = <ProjectileId?>[];
  final List<ProjectileItemId?> sourceProjectileItemId = <ProjectileItemId?>[];
  final List<int> flags = <int>[];

  int get length => target.length;

  /// Adds a damage request, returning its index or -1 if ignored.
  int add(DamageRequest request) {
    if (request.amount100 <= 0) {
      return -1;
    }

    final index = target.length;
    target.add(request.target);
    amount100.add(request.amount100);
    damageType.add(request.damageType);
    procs.add(request.procs);
    sourceKind.add(request.sourceKind);
    sourceEntity.add(request.source);
    sourceEnemyId.add(request.sourceEnemyId);
    sourceProjectileId.add(request.sourceProjectileId);
    sourceProjectileItemId.add(request.sourceProjectileItemId);
    flags.add(0);
    return index;
  }

  void cancel(int index) {
    flags[index] |= DamageQueueFlags.canceled;
  }

  void clear() {
    target.clear();
    amount100.clear();
    damageType.clear();
    procs.clear();
    sourceKind.clear();
    sourceEntity.clear();
    sourceEnemyId.clear();
    sourceProjectileId.clear();
    sourceProjectileItemId.clear();
    flags.clear();
  }
}


===== FILE: lib/core/ecs/stores/death_state_store.dart =====
import '../../enemies/death_behavior.dart';
import '../entity_id.dart';
import '../sparse_set.dart';

class DeathStateDef {
  const DeathStateDef({
    required this.phase,
    this.deathStartTick = -1,
    this.despawnTick = -1,
    this.maxFallDespawnTick = -1,
  });

  final DeathPhase phase;
  final int deathStartTick;
  final int despawnTick;
  final int maxFallDespawnTick;
}

/// Per-entity death lifecycle state (enemy-only for now).
class DeathStateStore extends SparseSet {
  final List<DeathPhase> phase = <DeathPhase>[];
  final List<int> deathStartTick = <int>[];
  final List<int> despawnTick = <int>[];
  final List<int> maxFallDespawnTick = <int>[];

  void add(EntityId entity, DeathStateDef def) {
    final i = addEntity(entity);
    phase[i] = def.phase;
    deathStartTick[i] = def.deathStartTick;
    despawnTick[i] = def.despawnTick;
    maxFallDespawnTick[i] = def.maxFallDespawnTick;
  }

  @override
  void onDenseAdded(int denseIndex) {
    phase.add(DeathPhase.none);
    deathStartTick.add(-1);
    despawnTick.add(-1);
    maxFallDespawnTick.add(-1);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    phase[removeIndex] = phase[lastIndex];
    deathStartTick[removeIndex] = deathStartTick[lastIndex];
    despawnTick[removeIndex] = despawnTick[lastIndex];
    maxFallDespawnTick[removeIndex] = maxFallDespawnTick[lastIndex];

    phase.removeLast();
    deathStartTick.removeLast();
    despawnTick.removeLast();
    maxFallDespawnTick.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/enemies/enemy_store.dart =====
import '../../../enemies/enemy_id.dart';
import '../../../snapshots/enums.dart';
import '../../entity_id.dart';
import '../../sparse_set.dart';

class EnemyDef {
  const EnemyDef({
    required this.enemyId,
    this.facing = Facing.left,
  });

  final EnemyId enemyId;
  final Facing facing;
}

/// Minimal enemy marker + per-enemy state.
///
/// Indicates this entity is an enemy and which type it is.
/// Also holds facing direction.
class EnemyStore extends SparseSet {
  final List<EnemyId> enemyId = <EnemyId>[];
  final List<Facing> facing = <Facing>[];
  final List<int> lastMeleeTick = <int>[];
  final List<Facing> lastMeleeFacing = <Facing>[];
  final List<int> lastMeleeAnimTicks = <int>[];

  void add(EntityId entity, EnemyDef def) {
    final i = addEntity(entity);
    enemyId[i] = def.enemyId;
    facing[i] = def.facing;
    lastMeleeTick[i] = -1;
    lastMeleeFacing[i] = def.facing;
    lastMeleeAnimTicks[i] = 0;
  }

  @override
  void onDenseAdded(int denseIndex) {
    enemyId.add(EnemyId.unocoDemon);
    facing.add(Facing.left);
    lastMeleeTick.add(-1);
    lastMeleeFacing.add(Facing.left);
    lastMeleeAnimTicks.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    enemyId[removeIndex] = enemyId[lastIndex];
    facing[removeIndex] = facing[lastIndex];
    lastMeleeTick[removeIndex] = lastMeleeTick[lastIndex];
    lastMeleeFacing[removeIndex] = lastMeleeFacing[lastIndex];
    lastMeleeAnimTicks[removeIndex] = lastMeleeAnimTicks[lastIndex];

    enemyId.removeLast();
    facing.removeLast();
    lastMeleeTick.removeLast();
    lastMeleeFacing.removeLast();
    lastMeleeAnimTicks.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/enemies/engagement_intent_store.dart =====
import '../../entity_id.dart';
import '../../sparse_set.dart';

/// Engagement intent for melee enemies (desired slot + movement modifiers).
class EngagementIntentStore extends SparseSet {
  /// Desired target X for locomotion when not following a nav plan.
  final List<double> desiredTargetX = <double>[];

  /// Arrival slow radius used to dampen speed near the slot.
  final List<double> arrivalSlowRadiusX = <double>[];

  /// Speed multiplier for the current engagement state.
  final List<double> stateSpeedMul = <double>[];

  /// Speed scale to apply when chasing without a nav plan.
  final List<double> speedScale = <double>[];

  void add(EntityId entity) {
    final i = addEntity(entity);
    desiredTargetX[i] = 0.0;
    arrivalSlowRadiusX[i] = 0.0;
    stateSpeedMul[i] = 1.0;
    speedScale[i] = 1.0;
  }

  @override
  void onDenseAdded(int denseIndex) {
    desiredTargetX.add(0.0);
    arrivalSlowRadiusX.add(0.0);
    stateSpeedMul.add(1.0);
    speedScale.add(1.0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    desiredTargetX[removeIndex] = desiredTargetX[lastIndex];
    arrivalSlowRadiusX[removeIndex] = arrivalSlowRadiusX[lastIndex];
    stateSpeedMul[removeIndex] = stateSpeedMul[lastIndex];
    speedScale[removeIndex] = speedScale[lastIndex];

    desiredTargetX.removeLast();
    arrivalSlowRadiusX.removeLast();
    stateSpeedMul.removeLast();
    speedScale.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/enemies/flying_enemy_steering_store.dart =====
import '../../entity_id.dart';
import '../../sparse_set.dart';

class FlyingEnemySteeringDef {
  const FlyingEnemySteeringDef({
    required this.rngState,
  });

  final int rngState;
}

/// Per flying enemy steering state for deterministic hover behavior.
///
/// Holds RNG state and smoothed target ranges to make enemies wobble nicely.
class FlyingEnemySteeringStore extends SparseSet {
  final List<int> rngState = <int>[];
  final List<bool> initialized = <bool>[];
  final List<double> desiredRange = <double>[];
  final List<double> desiredRangeHoldLeftS = <double>[];
  final List<double> flightTargetAboveGround = <double>[];
  final List<double> flightTargetHoldLeftS = <double>[];

  void add(EntityId entity, FlyingEnemySteeringDef def) {
    final i = addEntity(entity);
    rngState[i] = def.rngState;
    initialized[i] = false;
    desiredRange[i] = 0.0;
    desiredRangeHoldLeftS[i] = 0.0;
    flightTargetAboveGround[i] = 0.0;
    flightTargetHoldLeftS[i] = 0.0;
  }

  @override
  void onDenseAdded(int denseIndex) {
    rngState.add(1);
    initialized.add(false);
    desiredRange.add(0.0);
    desiredRangeHoldLeftS.add(0.0);
    flightTargetAboveGround.add(0.0);
    flightTargetHoldLeftS.add(0.0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    rngState[removeIndex] = rngState[lastIndex];
    initialized[removeIndex] = initialized[lastIndex];
    desiredRange[removeIndex] = desiredRange[lastIndex];
    desiredRangeHoldLeftS[removeIndex] = desiredRangeHoldLeftS[lastIndex];
    flightTargetAboveGround[removeIndex] = flightTargetAboveGround[lastIndex];
    flightTargetHoldLeftS[removeIndex] = flightTargetHoldLeftS[lastIndex];

    rngState.removeLast();
    initialized.removeLast();
    desiredRange.removeLast();
    desiredRangeHoldLeftS.removeLast();
    flightTargetAboveGround.removeLast();
    flightTargetHoldLeftS.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/enemies/ground_enemy_chase_offset_store.dart =====
import '../../entity_id.dart';
import '../../sparse_set.dart';

class GroundEnemyChaseOffsetDef {
  const GroundEnemyChaseOffsetDef({
    required this.rngState,
  });

  final int rngState;
}

/// Per ground enemy chase offset state for deterministic path separation.
///
/// Ensures multiple enemies don't stack perfectly on top of one another while chasing.
class GroundEnemyChaseOffsetStore extends SparseSet {
  final List<int> rngState = <int>[];
  final List<double> chaseOffsetX = <double>[];
  final List<double> chaseSpeedScale = <double>[];
  final List<bool> initialized = <bool>[];

  void add(EntityId entity, GroundEnemyChaseOffsetDef def) {
    final i = addEntity(entity);
    rngState[i] = def.rngState;
    chaseOffsetX[i] = 0.0;
    chaseSpeedScale[i] = 1.0;
    initialized[i] = false;
  }

  @override
  void onDenseAdded(int denseIndex) {
    rngState.add(1);
    chaseOffsetX.add(0.0);
    chaseSpeedScale.add(1.0);
    initialized.add(false);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    rngState[removeIndex] = rngState[lastIndex];
    chaseOffsetX[removeIndex] = chaseOffsetX[lastIndex];
    chaseSpeedScale[removeIndex] = chaseSpeedScale[lastIndex];
    initialized[removeIndex] = initialized[lastIndex];

    rngState.removeLast();
    chaseOffsetX.removeLast();
    chaseSpeedScale.removeLast();
    initialized.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/enemies/melee_engagement_store.dart =====
import '../../entity_id.dart';
import '../../sparse_set.dart';

/// Engagement state for melee-focused enemies.
///
/// Keeps lightweight state so AI can avoid oscillating around the target and
/// apply different movement rules during strike/recover windows.
class MeleeEngagementStore extends SparseSet {
  /// Current engagement state.
  final List<MeleeEngagementState> state = <MeleeEngagementState>[];

  /// Remaining ticks in the current state (used for strike/recover windows).
  final List<int> ticksLeft = <int>[];

  /// Preferred side relative to the target (+1 right, -1 left, 0 unset).
  final List<int> preferredSide = <int>[];

  /// Tick when the current strike started (edge-trigger).
  ///
  /// Used to start telegraph animations once and schedule future hit ticks.
  final List<int> strikeStartTick = <int>[];

  /// Tick when the melee hitbox should spawn for the current strike.
  final List<int> plannedHitTick = <int>[];

  void add(EntityId entity) {
    final i = addEntity(entity);
    state[i] = MeleeEngagementState.approach;
    ticksLeft[i] = 0;
    preferredSide[i] = 0;
    strikeStartTick[i] = -1;
    plannedHitTick[i] = -1;
  }

  @override
  void onDenseAdded(int denseIndex) {
    state.add(MeleeEngagementState.approach);
    ticksLeft.add(0);
    preferredSide.add(0);
    strikeStartTick.add(-1);
    plannedHitTick.add(-1);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    state[removeIndex] = state[lastIndex];
    ticksLeft[removeIndex] = ticksLeft[lastIndex];
    preferredSide[removeIndex] = preferredSide[lastIndex];
    strikeStartTick[removeIndex] = strikeStartTick[lastIndex];
    plannedHitTick[removeIndex] = plannedHitTick[lastIndex];

    state.removeLast();
    ticksLeft.removeLast();
    preferredSide.removeLast();
    strikeStartTick.removeLast();
    plannedHitTick.removeLast();
  }
}

enum MeleeEngagementState {
  approach,
  engage,
  strike,
  recover,
}


===== FILE: lib/core/ecs/stores/enemies/nav_intent_store.dart =====
import '../../entity_id.dart';
import '../../sparse_set.dart';

/// Navigation intent produced by pathfinding for ground enemies.
class NavIntentStore extends SparseSet {
  /// Target X used for path planning (player or predicted landing).
  final List<double> navTargetX = <double>[];

  /// Desired X from the navigator (immediate movement goal).
  final List<double> desiredX = <double>[];

  /// Whether the enemy should jump this tick.
  final List<bool> jumpNow = <bool>[];

  /// Whether a valid navigation plan exists.
  final List<bool> hasPlan = <bool>[];

  /// Committed move direction for plan execution (-1, 0, 1).
  final List<int> commitMoveDirX = <int>[];

  /// Safe surface bounds for no-plan movement.
  final List<double> safeSurfaceMinX = <double>[];
  final List<double> safeSurfaceMaxX = <double>[];
  final List<bool> hasSafeSurface = <bool>[];

  void add(EntityId entity) {
    final i = addEntity(entity);
    navTargetX[i] = 0.0;
    desiredX[i] = 0.0;
    jumpNow[i] = false;
    hasPlan[i] = false;
    commitMoveDirX[i] = 0;
    safeSurfaceMinX[i] = 0.0;
    safeSurfaceMaxX[i] = 0.0;
    hasSafeSurface[i] = false;
  }

  @override
  void onDenseAdded(int denseIndex) {
    navTargetX.add(0.0);
    desiredX.add(0.0);
    jumpNow.add(false);
    hasPlan.add(false);
    commitMoveDirX.add(0);
    safeSurfaceMinX.add(0.0);
    safeSurfaceMaxX.add(0.0);
    hasSafeSurface.add(false);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    navTargetX[removeIndex] = navTargetX[lastIndex];
    desiredX[removeIndex] = desiredX[lastIndex];
    jumpNow[removeIndex] = jumpNow[lastIndex];
    hasPlan[removeIndex] = hasPlan[lastIndex];
    commitMoveDirX[removeIndex] = commitMoveDirX[lastIndex];
    safeSurfaceMinX[removeIndex] = safeSurfaceMinX[lastIndex];
    safeSurfaceMaxX[removeIndex] = safeSurfaceMaxX[lastIndex];
    hasSafeSurface[removeIndex] = hasSafeSurface[lastIndex];

    navTargetX.removeLast();
    desiredX.removeLast();
    jumpNow.removeLast();
    hasPlan.removeLast();
    commitMoveDirX.removeLast();
    safeSurfaceMinX.removeLast();
    safeSurfaceMaxX.removeLast();
    hasSafeSurface.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/enemies/surface_nav_state_store.dart =====
import '../../../navigation/types/surface_id.dart';
import '../../entity_id.dart';
import '../../sparse_set.dart';

/// Per-entity pathfinding state.
///
/// Tracks the current surface segment, the target segment, and the calculated path edges.
/// Used by `SurfaceNavigationSystem` to move ground enemies.
class SurfaceNavStateStore extends SparseSet {
  final List<int> graphVersion = <int>[];
  final List<int> repathTicksLeft = <int>[];
  final List<int> currentSurfaceId = <int>[];
  final List<int> targetSurfaceId = <int>[];
  final List<int> activeEdgeIndex = <int>[];
  final List<int> pathCursor = <int>[];
  final List<List<int>> pathEdges = <List<int>>[];

  void add(EntityId entity) {
    addEntity(entity);
  }

  @override
  void onDenseAdded(int denseIndex) {
    graphVersion.add(-1);
    repathTicksLeft.add(0);
    currentSurfaceId.add(surfaceIdUnknown);
    targetSurfaceId.add(surfaceIdUnknown);
    activeEdgeIndex.add(-1);
    pathCursor.add(0);
    pathEdges.add(<int>[]);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    graphVersion[removeIndex] = graphVersion[lastIndex];
    repathTicksLeft[removeIndex] = repathTicksLeft[lastIndex];
    currentSurfaceId[removeIndex] = currentSurfaceId[lastIndex];
    targetSurfaceId[removeIndex] = targetSurfaceId[lastIndex];
    activeEdgeIndex[removeIndex] = activeEdgeIndex[lastIndex];
    pathCursor[removeIndex] = pathCursor[lastIndex];
    pathEdges[removeIndex] = pathEdges[lastIndex];

    graphVersion.removeLast();
    repathTicksLeft.removeLast();
    currentSurfaceId.removeLast();
    targetSurfaceId.removeLast();
    activeEdgeIndex.removeLast();
    pathCursor.removeLast();
    pathEdges.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/faction_store.dart =====
import '../../combat/faction.dart';
import '../entity_id.dart';
import '../sparse_set.dart';

class FactionDef {
  const FactionDef({required this.faction});

  final Faction faction;
}

class FactionStore extends SparseSet {
  final List<Faction> faction = <Faction>[];

  void add(EntityId entity, FactionDef def) {
    final i = addEntity(entity);
    faction[i] = def.faction;
  }

  @override
  void onDenseAdded(int denseIndex) {
    // Default to player if not specified.
    faction.add(Faction.player);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    faction[removeIndex] = faction[lastIndex];
    faction.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/health_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

class HealthDef {
  const HealthDef({
    required this.hp,
    required this.hpMax,
    required this.regenPerSecond100,
  });

  /// Fixed-point: 100 = 1.0
  final int hp;
  final int hpMax;
  final int regenPerSecond100;
}

/// Tracks current and max hit points for damageable entities.
class HealthStore extends SparseSet {
  /// Fixed-point: 100 = 1.0
  final List<int> hp = <int>[];
  final List<int> hpMax = <int>[];
  final List<int> regenPerSecond100 = <int>[];
  final List<int> regenAccumulator = <int>[];

  void add(EntityId entity, HealthDef def) {
    final i = addEntity(entity);
    hp[i] = def.hp;
    hpMax[i] = def.hpMax;
    regenPerSecond100[i] = def.regenPerSecond100;
    regenAccumulator[i] = 0;
  }

  @override
  void onDenseAdded(int denseIndex) {
    hp.add(0);
    hpMax.add(0);
    regenPerSecond100.add(0);
    regenAccumulator.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    hp[removeIndex] = hp[lastIndex];
    hpMax[removeIndex] = hpMax[lastIndex];
    regenPerSecond100[removeIndex] = regenPerSecond100[lastIndex];
    regenAccumulator[removeIndex] = regenAccumulator[lastIndex];

    hp.removeLast();
    hpMax.removeLast();
    regenPerSecond100.removeLast();
    regenAccumulator.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/hit_once_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

/// Tracks unique hit targets for a single strike instance (e.g. one swing).
///
/// **Optimization**: Uses inline fields (`hit0`...`hit3`) instead of a `List`
/// to avoid allocation per entity per frame. Saturation limit is 4 targets.
class HitOnceStore extends SparseSet {
  final List<int> count = <int>[];
  final List<EntityId> hit0 = <EntityId>[];
  final List<EntityId> hit1 = <EntityId>[];
  final List<EntityId> hit2 = <EntityId>[];
  final List<EntityId> hit3 = <EntityId>[];

  void add(EntityId entity) {
    addEntity(entity);
  }

  bool hasHit(EntityId entity, EntityId target) {
    final i = indexOf(entity);
    final c = count[i];
    if (c > 4) return true; // saturated: treat as "already hit everything"
    if (c <= 0) return false;
    if (hit0[i] == target) return true;
    if (c <= 1) return false;
    if (hit1[i] == target) return true;
    if (c <= 2) return false;
    if (hit2[i] == target) return true;
    if (c <= 3) return false;
    return hit3[i] == target;
  }

  void markHit(EntityId entity, EntityId target) {
    final i = indexOf(entity);
    var c = count[i];
    if (c > 4) return; // already saturated
    if (c <= 0) {
      hit0[i] = target;
      count[i] = 1;
      return;
    }
    if (c == 1) {
      hit1[i] = target;
      count[i] = 2;
      return;
    }
    if (c == 2) {
      hit2[i] = target;
      count[i] = 3;
      return;
    }
    if (c == 3) {
      hit3[i] = target;
      count[i] = 4;
      return;
    }
    // We don't expect more than 4 hits per swing.
    //
    // IMPORTANT (determinism + safety): once saturated, treat as "already hit"
    // for any target so a single swing cannot multi-hit due to overflow.
    count[i] = 5;
  }

  @override
  void onDenseAdded(int denseIndex) {
    count.add(0);
    hit0.add(0);
    hit1.add(0);
    hit2.add(0);
    hit3.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    count[removeIndex] = count[lastIndex];
    hit0[removeIndex] = hit0[lastIndex];
    hit1[removeIndex] = hit1[lastIndex];
    hit2[removeIndex] = hit2[lastIndex];
    hit3[removeIndex] = hit3[lastIndex];

    count.removeLast();
    hit0.removeLast();
    hit1.removeLast();
    hit2.removeLast();
    hit3.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/hitbox_store.dart =====
import '../../combat/damage_type.dart';
import '../../combat/faction.dart';
import '../../weapons/weapon_proc.dart';
import '../entity_id.dart';
import '../sparse_set.dart';

class HitboxDef {
  const HitboxDef({
    required this.owner,
    required this.faction,
    required this.damage100,
    required this.damageType,
    this.procs = const <WeaponProc>[],
    required this.halfX,
    required this.halfY,
    required this.offsetX,
    required this.offsetY,
    required this.dirX,
    required this.dirY,
  });

  final EntityId owner;
  final Faction faction;
  /// Fixed-point: 100 = 1.0
  final int damage100;
  final DamageType damageType;
  final List<WeaponProc> procs;
  final double halfX;
  final double halfY;
  final double offsetX;
  final double offsetY;
  final double dirX;
  final double dirY;
}

/// Short-lived damage hitbox used by melee strikes and area effects.
///
/// These entities usually exist for only a few frames (strike windows).
/// They are queried by `HitboxDamageSystem`.
class HitboxStore extends SparseSet {
  final List<EntityId> owner = <EntityId>[];
  final List<Faction> faction = <Faction>[];
  /// Fixed-point: 100 = 1.0
  final List<int> damage100 = <int>[];
  final List<DamageType> damageType = <DamageType>[];
  final List<List<WeaponProc>> procs = <List<WeaponProc>>[];
  final List<double> halfX = <double>[];
  final List<double> halfY = <double>[];
  final List<double> offsetX = <double>[];
  final List<double> offsetY = <double>[];
  final List<double> dirX = <double>[];
  final List<double> dirY = <double>[];

  void add(EntityId entity, HitboxDef def) {
    final i = addEntity(entity);
    owner[i] = def.owner;
    faction[i] = def.faction;
    damage100[i] = def.damage100;
    damageType[i] = def.damageType;
    procs[i] = def.procs;
    halfX[i] = def.halfX;
    halfY[i] = def.halfY;
    offsetX[i] = def.offsetX;
    offsetY[i] = def.offsetY;
    dirX[i] = def.dirX;
    dirY[i] = def.dirY;
  }

  @override
  void onDenseAdded(int denseIndex) {
    owner.add(0);
    faction.add(Faction.player);
    damage100.add(0);
    damageType.add(DamageType.physical);
    procs.add(const <WeaponProc>[]);
    halfX.add(0);
    halfY.add(0);
    offsetX.add(0);
    offsetY.add(0);
    dirX.add(1.0);
    dirY.add(0.0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    owner[removeIndex] = owner[lastIndex];
    faction[removeIndex] = faction[lastIndex];
    damage100[removeIndex] = damage100[lastIndex];
    damageType[removeIndex] = damageType[lastIndex];
    procs[removeIndex] = procs[lastIndex];
    halfX[removeIndex] = halfX[lastIndex];
    halfY[removeIndex] = halfY[lastIndex];
    offsetX[removeIndex] = offsetX[lastIndex];
    offsetY[removeIndex] = offsetY[lastIndex];
    dirX[removeIndex] = dirX[lastIndex];
    dirY[removeIndex] = dirY[lastIndex];

    owner.removeLast();
    faction.removeLast();
    damage100.removeLast();
    damageType.removeLast();
    procs.removeLast();
    halfX.removeLast();
    halfY.removeLast();
    offsetX.removeLast();
    offsetY.removeLast();
    dirX.removeLast();
    dirY.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/lifetime_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

class LifetimeDef {
  const LifetimeDef({required this.ticksLeft});

  final int ticksLeft;
}

/// Tracks entity lifetime in ticks. Entity is despawned when `ticksLeft <= 0`.
class LifetimeStore extends SparseSet {
  final List<int> ticksLeft = <int>[];

  void add(EntityId entity, LifetimeDef def) {
    final i = addEntity(entity);
    ticksLeft[i] = def.ticksLeft;
  }

  @override
  void onDenseAdded(int denseIndex) {
    ticksLeft.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    ticksLeft[removeIndex] = ticksLeft[lastIndex];
    ticksLeft.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/mana_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

class ManaDef {
  const ManaDef({
    required this.mana,
    required this.manaMax,
    required this.regenPerSecond100,
  });

  /// Fixed-point: 100 = 1.0
  final int mana;
  final int manaMax;
  final int regenPerSecond100;
}

/// Tracks current and max mana for spellcasters (Player).
class ManaStore extends SparseSet {
  /// Fixed-point: 100 = 1.0
  final List<int> mana = <int>[];
  final List<int> manaMax = <int>[];
  final List<int> regenPerSecond100 = <int>[];
  final List<int> regenAccumulator = <int>[];

  void add(EntityId entity, ManaDef def) {
    final i = addEntity(entity);
    mana[i] = def.mana;
    manaMax[i] = def.manaMax;
    regenPerSecond100[i] = def.regenPerSecond100;
    regenAccumulator[i] = 0;
  }

  @override
  void onDenseAdded(int denseIndex) {
    mana.add(0);
    manaMax.add(0);
    regenPerSecond100.add(0);
    regenAccumulator.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    mana[removeIndex] = mana[lastIndex];
    manaMax[removeIndex] = manaMax[lastIndex];
    regenPerSecond100[removeIndex] = regenPerSecond100[lastIndex];
    regenAccumulator[removeIndex] = regenAccumulator[lastIndex];

    mana.removeLast();
    manaMax.removeLast();
    regenPerSecond100.removeLast();
    regenAccumulator.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/melee_intent_store.dart =====
import '../../abilities/ability_def.dart';
import '../../combat/damage_type.dart';
import '../../weapons/weapon_proc.dart';
import '../entity_id.dart';
import '../sparse_set.dart';

class MeleeIntentDef {
  const MeleeIntentDef({
    required this.abilityId,
    required this.slot,
    required this.damage100,
    required this.damageType,
    this.procs = const <WeaponProc>[],
    required this.halfX,
    required this.halfY,
    required this.offsetX,
    required this.offsetY,
    required this.dirX,
    required this.dirY,
    required this.commitTick,
    required this.windupTicks,
    required this.activeTicks,
    required this.recoveryTicks,
    required this.cooldownTicks,
    required this.staminaCost100,
    required this.cooldownGroupId,
    required this.tick,
  });

  final AbilityKey abilityId;
  final AbilitySlot slot;

  /// Fixed-point: 100 = 1.0
  final int damage100;
  final DamageType damageType;
  final List<WeaponProc> procs;
  final double halfX;
  final double halfY;
  final double offsetX;
  final double offsetY;
  final double dirX;
  final double dirY;

  /// Tick the ability was committed (costs/cooldown start).
  final int commitTick;

  /// Windup duration (ticks) before hitbox spawns.
  final int windupTicks;
  final int activeTicks;

  /// Recovery duration (ticks) after active window.
  final int recoveryTicks;
  final int cooldownTicks;

  /// Fixed-point: 100 = 1.0
  final int staminaCost100;
  final int cooldownGroupId;

  /// Tick stamp for effect execution.
  ///
  /// Use `-1` for "no intent". The effect spawns only when `tick == currentTick`.
  final int tick;
}

/// Per-entity "perform a melee strike this tick" intent.
///
/// This is written by player/enemy intent writers and consumed by `MeleeStrikeSystem`.
///
/// **Usage**: Persistent component. Intents are set via `set()` with a `tick` stamp.
/// Old intents are ignored if `tick` matches current game tick.
class MeleeIntentStore extends SparseSet {
  final List<AbilityKey> abilityId = <AbilityKey>[];
  final List<AbilitySlot> slot = <AbilitySlot>[];

  /// Fixed-point: 100 = 1.0
  final List<int> damage100 = <int>[];
  final List<DamageType> damageType = <DamageType>[];
  final List<List<WeaponProc>> procs = <List<WeaponProc>>[];
  final List<double> halfX = <double>[];
  final List<double> halfY = <double>[];
  final List<double> offsetX = <double>[];
  final List<double> offsetY = <double>[];
  final List<double> dirX = <double>[];
  final List<double> dirY = <double>[];
  final List<int> commitTick = <int>[];
  final List<int> windupTicks = <int>[];
  final List<int> activeTicks = <int>[];
  final List<int> recoveryTicks = <int>[];
  final List<int> cooldownTicks = <int>[];

  /// Fixed-point: 100 = 1.0
  final List<int> staminaCost100 = <int>[];
  final List<int> cooldownGroupId = <int>[];
  final List<int> tick = <int>[];

  void add(EntityId entity) {
    addEntity(entity);
  }

  void set(EntityId entity, MeleeIntentDef def) {
    assert(
      has(entity),
      'MeleeIntentStore.set called for entity without MeleeIntentStore; add the component at spawn time.',
    );
    final i = indexOf(entity);
    abilityId[i] = def.abilityId;
    slot[i] = def.slot;
    damage100[i] = def.damage100;
    damageType[i] = def.damageType;
    procs[i] = def.procs;
    halfX[i] = def.halfX;
    halfY[i] = def.halfY;
    offsetX[i] = def.offsetX;
    offsetY[i] = def.offsetY;
    dirX[i] = def.dirX;
    dirY[i] = def.dirY;
    commitTick[i] = def.commitTick;
    windupTicks[i] = def.windupTicks;
    activeTicks[i] = def.activeTicks;
    recoveryTicks[i] = def.recoveryTicks;
    cooldownTicks[i] = def.cooldownTicks;
    staminaCost100[i] = def.staminaCost100;
    cooldownGroupId[i] = def.cooldownGroupId;
    tick[i] = def.tick;
  }

  @override
  void onDenseAdded(int denseIndex) {
    abilityId.add('common.unarmed_strike');
    slot.add(AbilitySlot.primary);
    damage100.add(0);
    damageType.add(DamageType.physical);
    procs.add(const <WeaponProc>[]);
    halfX.add(0.0);
    halfY.add(0.0);
    offsetX.add(0.0);
    offsetY.add(0.0);
    dirX.add(1.0);
    dirY.add(0.0);
    commitTick.add(-1);
    windupTicks.add(0);
    activeTicks.add(0);
    recoveryTicks.add(0);
    cooldownTicks.add(0);
    staminaCost100.add(0);
    cooldownGroupId.add(0);
    tick.add(-1);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    abilityId[removeIndex] = abilityId[lastIndex];
    slot[removeIndex] = slot[lastIndex];
    damage100[removeIndex] = damage100[lastIndex];
    damageType[removeIndex] = damageType[lastIndex];
    procs[removeIndex] = procs[lastIndex];
    halfX[removeIndex] = halfX[lastIndex];
    halfY[removeIndex] = halfY[lastIndex];
    offsetX[removeIndex] = offsetX[lastIndex];
    offsetY[removeIndex] = offsetY[lastIndex];
    dirX[removeIndex] = dirX[lastIndex];
    dirY[removeIndex] = dirY[lastIndex];
    commitTick[removeIndex] = commitTick[lastIndex];
    windupTicks[removeIndex] = windupTicks[lastIndex];
    activeTicks[removeIndex] = activeTicks[lastIndex];
    recoveryTicks[removeIndex] = recoveryTicks[lastIndex];
    cooldownTicks[removeIndex] = cooldownTicks[lastIndex];
    staminaCost100[removeIndex] = staminaCost100[lastIndex];
    cooldownGroupId[removeIndex] = cooldownGroupId[lastIndex];
    tick[removeIndex] = tick[lastIndex];

    abilityId.removeLast();
    slot.removeLast();
    damage100.removeLast();
    damageType.removeLast();
    procs.removeLast();
    halfX.removeLast();
    halfY.removeLast();
    offsetX.removeLast();
    offsetY.removeLast();
    dirX.removeLast();
    dirY.removeLast();
    commitTick.removeLast();
    windupTicks.removeLast();
    activeTicks.removeLast();
    recoveryTicks.removeLast();
    cooldownTicks.removeLast();
    staminaCost100.removeLast();
    cooldownGroupId.removeLast();
    tick.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/mobility_intent_store.dart =====
import '../../abilities/ability_def.dart';
import '../entity_id.dart';
import '../sparse_set.dart';

class MobilityIntentDef {
  const MobilityIntentDef({
    required this.abilityId,
    required this.slot,
    required this.dirX,
    required this.commitTick,
    required this.windupTicks,
    required this.activeTicks,
    required this.recoveryTicks,
    required this.cooldownTicks,
    required this.cooldownGroupId,
    required this.staminaCost100,
    required this.tick,
  });

  final AbilityKey abilityId;
  final AbilitySlot slot;

  /// Direction of the mobility action (normalized X).
  final double dirX;

  /// Tick the ability was committed (costs/cooldown start).
  final int commitTick;

  /// Windup duration (ticks) before movement starts.
  final int windupTicks;
  final int activeTicks;

  /// Recovery duration (ticks) after active window.
  final int recoveryTicks;
  final int cooldownTicks;
  final int cooldownGroupId;

  /// Fixed-point: 100 = 1.0
  final int staminaCost100;

  /// Tick stamp for movement execution.
  ///
  /// Use `-1` for "no intent". The effect triggers only when
  /// `tick == currentTick`.
  final int tick;
}

/// Per-entity "perform a mobility action this tick" intent.
///
/// Written by [AbilityActivationSystem], consumed by [MobilitySystem].
class MobilityIntentStore extends SparseSet {
  final List<AbilityKey> abilityId = <AbilityKey>[];
  final List<AbilitySlot> slot = <AbilitySlot>[];
  final List<double> dirX = <double>[];
  final List<int> commitTick = <int>[];
  final List<int> windupTicks = <int>[];
  final List<int> activeTicks = <int>[];
  final List<int> recoveryTicks = <int>[];
  final List<int> cooldownTicks = <int>[];
  final List<int> cooldownGroupId = <int>[];

  /// Fixed-point: 100 = 1.0
  final List<int> staminaCost100 = <int>[];
  final List<int> tick = <int>[];

  void add(EntityId entity) {
    addEntity(entity);
  }

  void set(EntityId entity, MobilityIntentDef def) {
    assert(
      has(entity),
      'MobilityIntentStore.set called for entity without MobilityIntentStore; add the component at spawn time.',
    );
    final i = indexOf(entity);
    abilityId[i] = def.abilityId;
    slot[i] = def.slot;
    dirX[i] = def.dirX;
    commitTick[i] = def.commitTick;
    windupTicks[i] = def.windupTicks;
    activeTicks[i] = def.activeTicks;
    recoveryTicks[i] = def.recoveryTicks;
    cooldownTicks[i] = def.cooldownTicks;
    cooldownGroupId[i] = def.cooldownGroupId;
    staminaCost100[i] = def.staminaCost100;
    tick[i] = def.tick;
  }

  @override
  void onDenseAdded(int denseIndex) {
    abilityId.add('eloise.dash');
    slot.add(AbilitySlot.mobility);
    dirX.add(1.0);
    commitTick.add(-1);
    windupTicks.add(0);
    activeTicks.add(0);
    recoveryTicks.add(0);
    cooldownTicks.add(0);
    cooldownGroupId.add(0);
    staminaCost100.add(0);
    tick.add(-1);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    abilityId[removeIndex] = abilityId[lastIndex];
    slot[removeIndex] = slot[lastIndex];
    dirX[removeIndex] = dirX[lastIndex];
    commitTick[removeIndex] = commitTick[lastIndex];
    windupTicks[removeIndex] = windupTicks[lastIndex];
    activeTicks[removeIndex] = activeTicks[lastIndex];
    recoveryTicks[removeIndex] = recoveryTicks[lastIndex];
    cooldownTicks[removeIndex] = cooldownTicks[lastIndex];
    cooldownGroupId[removeIndex] = cooldownGroupId[lastIndex];
    staminaCost100[removeIndex] = staminaCost100[lastIndex];
    tick[removeIndex] = tick[lastIndex];

    abilityId.removeLast();
    slot.removeLast();
    dirX.removeLast();
    commitTick.removeLast();
    windupTicks.removeLast();
    activeTicks.removeLast();
    recoveryTicks.removeLast();
    cooldownTicks.removeLast();
    cooldownGroupId.removeLast();
    staminaCost100.removeLast();
    tick.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/parry_consume_store.dart =====
import '../entity_id.dart';

/// Tracks per-entity parry consumption for the current activation.
/// We key by the active-ability startTick, so re-activations reset automatically.
class ParryConsumeStore {
  final List<EntityId> denseEntities = <EntityId>[];
  final Map<EntityId, int> _sparse = <EntityId, int>{};

  /// Last parry activation startTick consumed.
  final List<int> consumedStartTick = <int>[];

  bool has(EntityId e) => _sparse.containsKey(e);

  int? tryIndexOf(EntityId e) => _sparse[e];

  int indexOfOrAdd(EntityId e) {
    final existing = _sparse[e];
    if (existing != null) return existing;
    final i = denseEntities.length;
    denseEntities.add(e);
    _sparse[e] = i;
    consumedStartTick.add(-1);
    return i;
  }

  void removeEntity(EntityId e) {
    final i = _sparse.remove(e);
    if (i == null) return;
    final last = denseEntities.length - 1;
    if (i != last) {
      final moved = denseEntities[last];
      denseEntities[i] = moved;
      _sparse[moved] = i;
      consumedStartTick[i] = consumedStartTick[last];
    }
    denseEntities.removeLast();
    consumedStartTick.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/player/gravity_control_store.dart =====
import '../../entity_id.dart';
import '../../sparse_set.dart';

/// Tracks entities that are temporarily ignoring global gravity.
///
/// Used by movement skills (e.g. Dash) to keep the player straight.
/// Entities are removed from this store when `suppressGravityTicksLeft` hits 0.
class GravityControlStore extends SparseSet {
  final List<int> suppressGravityTicksLeft = <int>[];

  void setSuppressForTicks(EntityId entity, int ticks) {
    if (ticks <= 0) {
      removeEntity(entity);
      return;
    }

    final i = addEntity(entity);
    suppressGravityTicksLeft[i] = ticks;
  }

  @override
  void onDenseAdded(int denseIndex) {
    suppressGravityTicksLeft.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    suppressGravityTicksLeft[removeIndex] = suppressGravityTicksLeft[lastIndex];
    suppressGravityTicksLeft.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/player/invulnerability_store.dart =====
import '../../entity_id.dart';
import '../../sparse_set.dart';

class InvulnerabilityDef {
  const InvulnerabilityDef({this.ticksLeft = 0});

  final int ticksLeft;
}

/// Per-entity invulnerability window after taking damage.
///
/// This store is only attached to the player (no enemy i-frames).
class InvulnerabilityStore extends SparseSet {
  final List<int> ticksLeft = <int>[];

  void add(EntityId entity, [InvulnerabilityDef def = const InvulnerabilityDef()]) {
    final i = addEntity(entity);
    ticksLeft[i] = def.ticksLeft;
  }

  @override
  void onDenseAdded(int denseIndex) {
    ticksLeft.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    ticksLeft[removeIndex] = ticksLeft[lastIndex];
    ticksLeft.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/player/last_damage_store.dart =====
import '../../../enemies/enemy_id.dart';
import '../../../events/game_event.dart';
import '../../../projectiles/projectile_id.dart';
import '../../../projectiles/projectile_item_id.dart';
import '../../entity_id.dart';
import '../../sparse_set.dart';

/// Per-entity record of the last applied damage metadata.
///
/// Used to populate the "Game Over" screen with cause of death.
class LastDamageStore extends SparseSet {
  final List<DeathSourceKind> kind = <DeathSourceKind>[];
  final List<EnemyId> enemyId = <EnemyId>[];
  final List<bool> hasEnemyId = <bool>[];
  final List<ProjectileId> projectileId = <ProjectileId>[];
  final List<bool> hasProjectileId = <bool>[];
  final List<ProjectileItemId> projectileItemId = <ProjectileItemId>[];
  final List<bool> hasProjectileItemId = <bool>[];
  /// Fixed-point: 100 = 1.0
  final List<int> amount100 = <int>[];
  final List<int> tick = <int>[];

  void add(EntityId entity) {
    addEntity(entity);
  }

  @override
  void onDenseAdded(int denseIndex) {
    kind.add(DeathSourceKind.unknown);
    enemyId.add(EnemyId.unocoDemon);
    hasEnemyId.add(false);
    projectileId.add(ProjectileId.iceBolt);
    hasProjectileId.add(false);
    projectileItemId.add(ProjectileItemId.iceBolt);
    hasProjectileItemId.add(false);
    amount100.add(0);
    tick.add(-1);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    kind[removeIndex] = kind[lastIndex];
    enemyId[removeIndex] = enemyId[lastIndex];
    hasEnemyId[removeIndex] = hasEnemyId[lastIndex];
    projectileId[removeIndex] = projectileId[lastIndex];
    hasProjectileId[removeIndex] = hasProjectileId[lastIndex];
    projectileItemId[removeIndex] = projectileItemId[lastIndex];
    hasProjectileItemId[removeIndex] = hasProjectileItemId[lastIndex];
    amount100[removeIndex] = amount100[lastIndex];
    tick[removeIndex] = tick[lastIndex];

    kind.removeLast();
    enemyId.removeLast();
    hasEnemyId.removeLast();
    projectileId.removeLast();
    hasProjectileId.removeLast();
    projectileItemId.removeLast();
    hasProjectileItemId.removeLast();
    amount100.removeLast();
    tick.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/player/movement_store.dart =====
import '../../../snapshots/enums.dart';
import '../../entity_id.dart';
import '../../sparse_set.dart';

/// Movement state for platformer-style motion (timers + grounded + facing).
///
/// Contains transient state counters for precise movement tech:
/// - Coyote time (jump after leaving ledge)
/// - Jump buffer (press before landing)
/// - Active dash state (duration, direction)
///
/// **Note**: Dash *cooldown* is now managed by [CooldownStore] using
/// [CooldownGroup.mobility]. This store only tracks active dash execution.
class MovementStore extends SparseSet {
  final List<int> coyoteTicksLeft = <int>[];
  final List<int> jumpBufferTicksLeft = <int>[];

  /// Ticks remaining in active dash. 0 = not dashing.
  final List<int> dashTicksLeft = <int>[];

  /// Direction of current dash (-1.0 or 1.0).
  final List<double> dashDirX = <double>[];

  final List<Facing> facing = <Facing>[];
  final List<int> facingLockTicksLeft = <int>[];

  void add(EntityId entity, {required Facing facing}) {
    final i = addEntity(entity);
    this.facing[i] = facing;
  }

  bool isDashing(EntityId entity) => dashTicksLeft[indexOf(entity)] > 0;

  @override
  void onDenseAdded(int denseIndex) {
    coyoteTicksLeft.add(0);
    jumpBufferTicksLeft.add(0);
    dashTicksLeft.add(0);
    dashDirX.add(1);
    facing.add(Facing.right);
    facingLockTicksLeft.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    coyoteTicksLeft[removeIndex] = coyoteTicksLeft[lastIndex];
    jumpBufferTicksLeft[removeIndex] = jumpBufferTicksLeft[lastIndex];
    dashTicksLeft[removeIndex] = dashTicksLeft[lastIndex];
    dashDirX[removeIndex] = dashDirX[lastIndex];
    facing[removeIndex] = facing[lastIndex];
    facingLockTicksLeft[removeIndex] = facingLockTicksLeft[lastIndex];

    coyoteTicksLeft.removeLast();
    jumpBufferTicksLeft.removeLast();
    dashTicksLeft.removeLast();
    dashDirX.removeLast();
    facing.removeLast();
    facingLockTicksLeft.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/player/player_input_store.dart =====
import '../../../abilities/ability_def.dart';
import '../../entity_id.dart';
import '../../sparse_set.dart';

/// Per-tick player input (authoritative commands decoded by the core).
///
/// This is reset/overwritten each tick by `GameCore.applyCommands`.
/// All actions are boolean or axis values used by `MovementSystem` and decision systems.
class PlayerInputStore extends SparseSet {
  final List<double> moveAxis = <double>[];
  final List<bool> jumpPressed = <bool>[];
  final List<bool> dashPressed = <bool>[];
  final List<bool> strikePressed = <bool>[];
  final List<double> projectileAimDirX = <double>[];
  final List<double> projectileAimDirY = <double>[];
  final List<double> meleeAimDirX = <double>[];
  final List<double> meleeAimDirY = <double>[];
  final List<bool> projectilePressed = <bool>[];
  final List<bool> secondaryPressed = <bool>[];
  final List<bool> bonusPressed = <bool>[];
  final List<bool> hasAbilitySlotPressed = <bool>[];
  final List<AbilitySlot> lastAbilitySlotPressed = <AbilitySlot>[];

  void add(EntityId entity) {
    addEntity(entity);
  }

  void resetTickInputs(EntityId entity) {
    final i = indexOf(entity);
    moveAxis[i] = 0;
    jumpPressed[i] = false;
    dashPressed[i] = false;
    strikePressed[i] = false;
    projectileAimDirX[i] = 0;
    projectileAimDirY[i] = 0;
    meleeAimDirX[i] = 0;
    meleeAimDirY[i] = 0;
    projectilePressed[i] = false;
    secondaryPressed[i] = false;
    bonusPressed[i] = false;
    hasAbilitySlotPressed[i] = false;
  }

  @override
  void onDenseAdded(int denseIndex) {
    moveAxis.add(0);
    jumpPressed.add(false);
    dashPressed.add(false);
    strikePressed.add(false);
    projectileAimDirX.add(0);
    projectileAimDirY.add(0);
    meleeAimDirX.add(0);
    meleeAimDirY.add(0);
    projectilePressed.add(false);
    secondaryPressed.add(false);
    bonusPressed.add(false);
    hasAbilitySlotPressed.add(false);
    lastAbilitySlotPressed.add(AbilitySlot.primary);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    moveAxis[removeIndex] = moveAxis[lastIndex];
    jumpPressed[removeIndex] = jumpPressed[lastIndex];
    dashPressed[removeIndex] = dashPressed[lastIndex];
    strikePressed[removeIndex] = strikePressed[lastIndex];
    projectileAimDirX[removeIndex] = projectileAimDirX[lastIndex];
    projectileAimDirY[removeIndex] = projectileAimDirY[lastIndex];
    meleeAimDirX[removeIndex] = meleeAimDirX[lastIndex];
    meleeAimDirY[removeIndex] = meleeAimDirY[lastIndex];
    projectilePressed[removeIndex] = projectilePressed[lastIndex];
    secondaryPressed[removeIndex] = secondaryPressed[lastIndex];
    bonusPressed[removeIndex] = bonusPressed[lastIndex];
    hasAbilitySlotPressed[removeIndex] = hasAbilitySlotPressed[lastIndex];
    lastAbilitySlotPressed[removeIndex] = lastAbilitySlotPressed[lastIndex];

    moveAxis.removeLast();
    jumpPressed.removeLast();
    dashPressed.removeLast();
    strikePressed.removeLast();
    projectileAimDirX.removeLast();
    projectileAimDirY.removeLast();
    meleeAimDirX.removeLast();
    meleeAimDirY.removeLast();
    projectilePressed.removeLast();
    secondaryPressed.removeLast();
    bonusPressed.removeLast();
    hasAbilitySlotPressed.removeLast();
    lastAbilitySlotPressed.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/projectile_intent_store.dart =====
import '../../abilities/ability_def.dart';
import '../../combat/damage_type.dart';
import '../../projectiles/projectile_id.dart';
import '../../projectiles/projectile_item_id.dart';
import '../../weapons/weapon_proc.dart';
import '../entity_id.dart';
import '../sparse_set.dart';

class ProjectileIntentDef {
  const ProjectileIntentDef({
    required this.projectileItemId,
    required this.abilityId,
    required this.slot,
    required this.damage100,
    required this.staminaCost100,
    required this.manaCost100,
    required this.cooldownTicks,
    required this.cooldownGroupId,
    required this.projectileId,
    required this.damageType,
    this.procs = const <WeaponProc>[],
    required this.ballistic,
    required this.gravityScale,
    required this.dirX,
    required this.dirY,
    required this.fallbackDirX,
    required this.fallbackDirY,
    required this.originOffset,
    required this.commitTick,
    required this.windupTicks,
    required this.activeTicks,
    required this.recoveryTicks,
    required this.tick,
  });

  final ProjectileItemId projectileItemId;
  final AbilityKey abilityId;
  final AbilitySlot slot;
  final int damage100;
  final int staminaCost100;
  final int manaCost100;
  final int cooldownTicks;
  final int cooldownGroupId;
  final ProjectileId projectileId;
  final DamageType damageType;
  final List<WeaponProc> procs;
  final bool ballistic;
  final double gravityScale;

  final double dirX;
  final double dirY;
  final double fallbackDirX;
  final double fallbackDirY;
  final double originOffset;
  final int commitTick;
  final int windupTicks;
  final int activeTicks;
  final int recoveryTicks;
  final int tick;
}

/// Per-entity "fire a projectile item this tick" intent.
class ProjectileIntentStore extends SparseSet {
  final List<ProjectileItemId> projectileItemId = <ProjectileItemId>[];
  final List<AbilityKey> abilityId = <AbilityKey>[];
  final List<AbilitySlot> slot = <AbilitySlot>[];
  final List<int> damage100 = <int>[];
  final List<int> staminaCost100 = <int>[];
  final List<int> manaCost100 = <int>[];
  final List<int> cooldownTicks = <int>[];
  final List<int> cooldownGroupId = <int>[];
  final List<ProjectileId> projectileId = <ProjectileId>[];
  final List<DamageType> damageType = <DamageType>[];
  final List<List<WeaponProc>> procs = <List<WeaponProc>>[];
  final List<bool> ballistic = <bool>[];
  final List<double> gravityScale = <double>[];

  final List<double> dirX = <double>[];
  final List<double> dirY = <double>[];
  final List<double> fallbackDirX = <double>[];
  final List<double> fallbackDirY = <double>[];
  final List<double> originOffset = <double>[];
  final List<int> commitTick = <int>[];
  final List<int> windupTicks = <int>[];
  final List<int> activeTicks = <int>[];
  final List<int> recoveryTicks = <int>[];
  final List<int> tick = <int>[];

  void add(EntityId entity) {
    addEntity(entity);
  }

  void set(EntityId entity, ProjectileIntentDef def) {
    assert(
      has(entity),
      'ProjectileIntentStore.set called for entity without ProjectileIntentStore; add the component at spawn time.',
    );
    final i = indexOf(entity);
    projectileItemId[i] = def.projectileItemId;
    abilityId[i] = def.abilityId;
    slot[i] = def.slot;
    damage100[i] = def.damage100;
    staminaCost100[i] = def.staminaCost100;
    manaCost100[i] = def.manaCost100;
    cooldownTicks[i] = def.cooldownTicks;
    cooldownGroupId[i] = def.cooldownGroupId;
    projectileId[i] = def.projectileId;
    damageType[i] = def.damageType;
    procs[i] = def.procs;
    ballistic[i] = def.ballistic;
    gravityScale[i] = def.gravityScale;
    dirX[i] = def.dirX;
    dirY[i] = def.dirY;
    fallbackDirX[i] = def.fallbackDirX;
    fallbackDirY[i] = def.fallbackDirY;
    originOffset[i] = def.originOffset;
    commitTick[i] = def.commitTick;
    windupTicks[i] = def.windupTicks;
    activeTicks[i] = def.activeTicks;
    recoveryTicks[i] = def.recoveryTicks;
    tick[i] = def.tick;
  }

  @override
  void onDenseAdded(int denseIndex) {
    projectileItemId.add(ProjectileItemId.iceBolt);
    abilityId.add('eloise.ice_bolt');
    slot.add(AbilitySlot.projectile);
    damage100.add(0);
    staminaCost100.add(0);
    manaCost100.add(0);
    cooldownTicks.add(0);
    cooldownGroupId.add(0);
    projectileId.add(ProjectileId.iceBolt);
    damageType.add(DamageType.ice);
    procs.add(const <WeaponProc>[]);
    ballistic.add(false);
    gravityScale.add(1.0);
    dirX.add(0.0);
    dirY.add(0.0);
    fallbackDirX.add(1.0);
    fallbackDirY.add(0.0);
    originOffset.add(0.0);
    commitTick.add(-1);
    windupTicks.add(0);
    activeTicks.add(0);
    recoveryTicks.add(0);
    tick.add(-1);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    projectileItemId[removeIndex] = projectileItemId[lastIndex];
    abilityId[removeIndex] = abilityId[lastIndex];
    slot[removeIndex] = slot[lastIndex];
    damage100[removeIndex] = damage100[lastIndex];
    staminaCost100[removeIndex] = staminaCost100[lastIndex];
    manaCost100[removeIndex] = manaCost100[lastIndex];
    cooldownTicks[removeIndex] = cooldownTicks[lastIndex];
    cooldownGroupId[removeIndex] = cooldownGroupId[lastIndex];
    projectileId[removeIndex] = projectileId[lastIndex];
    damageType[removeIndex] = damageType[lastIndex];
    procs[removeIndex] = procs[lastIndex];
    ballistic[removeIndex] = ballistic[lastIndex];
    gravityScale[removeIndex] = gravityScale[lastIndex];
    dirX[removeIndex] = dirX[lastIndex];
    dirY[removeIndex] = dirY[lastIndex];
    fallbackDirX[removeIndex] = fallbackDirX[lastIndex];
    fallbackDirY[removeIndex] = fallbackDirY[lastIndex];
    originOffset[removeIndex] = originOffset[lastIndex];
    commitTick[removeIndex] = commitTick[lastIndex];
    windupTicks[removeIndex] = windupTicks[lastIndex];
    activeTicks[removeIndex] = activeTicks[lastIndex];
    recoveryTicks[removeIndex] = recoveryTicks[lastIndex];
    tick[removeIndex] = tick[lastIndex];

    projectileItemId.removeLast();
    abilityId.removeLast();
    slot.removeLast();
    damage100.removeLast();
    staminaCost100.removeLast();
    manaCost100.removeLast();
    cooldownTicks.removeLast();
    cooldownGroupId.removeLast();
    projectileId.removeLast();
    damageType.removeLast();
    procs.removeLast();
    ballistic.removeLast();
    gravityScale.removeLast();
    dirX.removeLast();
    dirY.removeLast();
    fallbackDirX.removeLast();
    fallbackDirY.removeLast();
    originOffset.removeLast();
    commitTick.removeLast();
    windupTicks.removeLast();
    activeTicks.removeLast();
    recoveryTicks.removeLast();
    tick.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/projectile_item_origin_store.dart =====
import '../../projectiles/projectile_item_id.dart';
import '../entity_id.dart';
import '../sparse_set.dart';

class ProjectileItemOriginDef {
  const ProjectileItemOriginDef({required this.projectileItemId});

  final ProjectileItemId projectileItemId;
}

/// Metadata for projectile entities (spawned from projectile slot items).
class ProjectileItemOriginStore extends SparseSet {
  final List<ProjectileItemId> projectileItemId = <ProjectileItemId>[];

  void add(EntityId entity, ProjectileItemOriginDef def) {
    final i = addEntity(entity);
    projectileItemId[i] = def.projectileItemId;
  }

  @override
  void onDenseAdded(int denseIndex) {
    projectileItemId.add(ProjectileItemId.iceBolt);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    projectileItemId[removeIndex] = projectileItemId[lastIndex];
    projectileItemId.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/projectile_store.dart =====
import '../../combat/damage_type.dart';
import '../../combat/faction.dart';
import '../../projectiles/projectile_id.dart';
import '../../weapons/weapon_proc.dart';
import '../entity_id.dart';
import '../sparse_set.dart';

class ProjectileDef {
  const ProjectileDef({
    required this.projectileId,
    required this.faction,
    required this.owner,
    required this.dirX,
    required this.dirY,
    required this.speedUnitsPerSecond,
    required this.damage100,
    required this.damageType,
    this.procs = const <WeaponProc>[],
    this.usePhysics = false,
  });

  final ProjectileId projectileId;
  final Faction faction;
  final EntityId owner;
  final double dirX;
  final double dirY;
  final double speedUnitsPerSecond;
  /// Fixed-point: 100 = 1.0
  final int damage100;
  final DamageType damageType;
  final List<WeaponProc> procs;

  /// If true, this projectile is moved by core physics (GravitySystem +
  /// CollisionSystem) rather than [ProjectileSystem].
  final bool usePhysics;
}

/// Immutable metadata for active projectiles.
///
/// Combines with `Transform` (for position) and `ColliderAabb` (for hit detection).
class ProjectileStore extends SparseSet {
  final List<ProjectileId> projectileId = <ProjectileId>[];
  final List<Faction> faction = <Faction>[];
  final List<EntityId> owner = <EntityId>[];
  final List<double> dirX = <double>[];
  final List<double> dirY = <double>[];
  final List<double> speedUnitsPerSecond = <double>[];
  /// Fixed-point: 100 = 1.0
  final List<int> damage100 = <int>[];
  final List<DamageType> damageType = <DamageType>[];
  final List<List<WeaponProc>> procs = <List<WeaponProc>>[];
  final List<bool> usePhysics = <bool>[];

  void add(EntityId entity, ProjectileDef def) {
    final i = addEntity(entity);
    projectileId[i] = def.projectileId;
    faction[i] = def.faction;
    owner[i] = def.owner;
    dirX[i] = def.dirX;
    dirY[i] = def.dirY;
    speedUnitsPerSecond[i] = def.speedUnitsPerSecond;
    damage100[i] = def.damage100;
    damageType[i] = def.damageType;
    procs[i] = def.procs;
    usePhysics[i] = def.usePhysics;
  }

  @override
  void onDenseAdded(int denseIndex) {
    projectileId.add(ProjectileId.iceBolt);
    faction.add(Faction.player);
    owner.add(0);
    dirX.add(1.0);
    dirY.add(0.0);
    speedUnitsPerSecond.add(0.0);
    damage100.add(0);
    damageType.add(DamageType.physical);
    procs.add(const <WeaponProc>[]);
    usePhysics.add(false);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    projectileId[removeIndex] = projectileId[lastIndex];
    faction[removeIndex] = faction[lastIndex];
    owner[removeIndex] = owner[lastIndex];
    dirX[removeIndex] = dirX[lastIndex];
    dirY[removeIndex] = dirY[lastIndex];
    speedUnitsPerSecond[removeIndex] = speedUnitsPerSecond[lastIndex];
    damage100[removeIndex] = damage100[lastIndex];
    damageType[removeIndex] = damageType[lastIndex];
    procs[removeIndex] = procs[lastIndex];
    usePhysics[removeIndex] = usePhysics[lastIndex];

    projectileId.removeLast();
    faction.removeLast();
    owner.removeLast();
    dirX.removeLast();
    dirY.removeLast();
    speedUnitsPerSecond.removeLast();
    damage100.removeLast();
    damageType.removeLast();
    procs.removeLast();
    usePhysics.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/restoration_item_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

enum RestorationStat {
  health,
  mana,
  stamina,
}

class RestorationItemDef {
  const RestorationItemDef({required this.stat});

  final RestorationStat stat;
}

/// SoA store for restoration item metadata (health/mana/stamina).
class RestorationItemStore extends SparseSet {
  final List<RestorationStat> stat = <RestorationStat>[];

  void add(EntityId entity, RestorationItemDef def) {
    final i = addEntity(entity);
    stat[i] = def.stat;
  }

  @override
  void onDenseAdded(int denseIndex) {
    stat.add(RestorationStat.health);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    stat[removeIndex] = stat[lastIndex];
    stat.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/riposte_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

/// One-shot offensive buff granted by a successful parry.
///
/// The buff is consumed only when a melee hit actually lands (so misses do not
/// waste it). It may also expire after a fixed number of ticks.
class RiposteStore extends SparseSet {
  /// Tick at which this buff expires (inclusive).
  final List<int> expiresTick = <int>[];

  /// Damage bonus in basis points (bpScale = 10000).
  /// Example: 10000 = +100% (i.e. x2 total when applied).
  final List<int> bonusBp = <int>[];

  void grant(
    EntityId entity, {
    required int expiresAtTick,
    required int bonusBp,
  }) {
    final i = addEntity(entity);
    expiresTick[i] = expiresAtTick;
    this.bonusBp[i] = bonusBp;
  }

  void consume(EntityId entity) {
    removeEntity(entity);
  }

  @override
  void onDenseAdded(int denseIndex) {
    expiresTick.add(-1);
    bonusBp.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    expiresTick[removeIndex] = expiresTick[lastIndex];
    bonusBp[removeIndex] = bonusBp[lastIndex];
    expiresTick.removeLast();
    bonusBp.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/self_intent_store.dart =====
import '../../abilities/ability_def.dart';
import '../entity_id.dart';
import '../sparse_set.dart';

class SelfIntentDef {
  const SelfIntentDef({
    required this.abilityId,
    required this.slot,
    required this.commitTick,
    required this.windupTicks,
    required this.activeTicks,
    required this.recoveryTicks,
    required this.cooldownTicks,
    required this.cooldownGroupId,
    required this.staminaCost100,
    required this.manaCost100,
    required this.tick,
  });

  final AbilityKey abilityId;
  final AbilitySlot slot;

  /// Tick the ability was committed (costs/cooldown start).
  final int commitTick;

  /// Windup duration (ticks) before effect window.
  final int windupTicks;
  final int activeTicks;

  /// Recovery duration (ticks) after active window.
  final int recoveryTicks;
  final int cooldownTicks;
  final int cooldownGroupId;

  /// Fixed-point: 100 = 1.0
  final int staminaCost100;

  /// Fixed-point: 100 = 1.0
  final int manaCost100;

  /// Tick stamp for execution.
  ///
  /// Use `-1` for "no intent". The effect triggers only when
  /// `tick == currentTick`.
  final int tick;
}

/// Per-entity "perform a self ability this tick" intent.
///
/// Written by [AbilityActivationSystem], consumed by [SelfAbilitySystem].
class SelfIntentStore extends SparseSet {
  final List<AbilityKey> abilityId = <AbilityKey>[];
  final List<AbilitySlot> slot = <AbilitySlot>[];
  final List<int> commitTick = <int>[];
  final List<int> windupTicks = <int>[];
  final List<int> activeTicks = <int>[];
  final List<int> recoveryTicks = <int>[];
  final List<int> cooldownTicks = <int>[];
  final List<int> cooldownGroupId = <int>[];

  /// Fixed-point: 100 = 1.0
  final List<int> staminaCost100 = <int>[];

  /// Fixed-point: 100 = 1.0
  final List<int> manaCost100 = <int>[];
  final List<int> tick = <int>[];

  void add(EntityId entity) {
    addEntity(entity);
  }

  void set(EntityId entity, SelfIntentDef def) {
    assert(
      has(entity),
      'SelfIntentStore.set called for entity without SelfIntentStore; add the component at spawn time.',
    );
    final i = indexOf(entity);
    abilityId[i] = def.abilityId;
    slot[i] = def.slot;
    commitTick[i] = def.commitTick;
    windupTicks[i] = def.windupTicks;
    activeTicks[i] = def.activeTicks;
    recoveryTicks[i] = def.recoveryTicks;
    cooldownTicks[i] = def.cooldownTicks;
    cooldownGroupId[i] = def.cooldownGroupId;
    staminaCost100[i] = def.staminaCost100;
    manaCost100[i] = def.manaCost100;
    tick[i] = def.tick;
  }

  @override
  void onDenseAdded(int denseIndex) {
    abilityId.add('eloise.sword_parry');
    slot.add(AbilitySlot.primary);
    commitTick.add(-1);
    windupTicks.add(0);
    activeTicks.add(0);
    recoveryTicks.add(0);
    cooldownTicks.add(0);
    cooldownGroupId.add(0);
    staminaCost100.add(0);
    manaCost100.add(0);
    tick.add(-1);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    abilityId[removeIndex] = abilityId[lastIndex];
    slot[removeIndex] = slot[lastIndex];
    commitTick[removeIndex] = commitTick[lastIndex];
    windupTicks[removeIndex] = windupTicks[lastIndex];
    activeTicks[removeIndex] = activeTicks[lastIndex];
    recoveryTicks[removeIndex] = recoveryTicks[lastIndex];
    cooldownTicks[removeIndex] = cooldownTicks[lastIndex];
    cooldownGroupId[removeIndex] = cooldownGroupId[lastIndex];
    staminaCost100[removeIndex] = staminaCost100[lastIndex];
    manaCost100[removeIndex] = manaCost100[lastIndex];
    tick[removeIndex] = tick[lastIndex];

    abilityId.removeLast();
    slot.removeLast();
    commitTick.removeLast();
    windupTicks.removeLast();
    activeTicks.removeLast();
    recoveryTicks.removeLast();
    cooldownTicks.removeLast();
    cooldownGroupId.removeLast();
    staminaCost100.removeLast();
    manaCost100.removeLast();
    tick.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/stamina_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

class StaminaDef {
  const StaminaDef({
    required this.stamina,
    required this.staminaMax,
    required this.regenPerSecond100,
  });

  /// Fixed-point: 100 = 1.0
  final int stamina;
  final int staminaMax;
  final int regenPerSecond100;
}

/// Tracks stamina for dashing and melee strikes.
class StaminaStore extends SparseSet {
  /// Fixed-point: 100 = 1.0
  final List<int> stamina = <int>[];
  final List<int> staminaMax = <int>[];
  final List<int> regenPerSecond100 = <int>[];
  final List<int> regenAccumulator = <int>[];

  void add(EntityId entity, StaminaDef def) {
    final i = addEntity(entity);
    stamina[i] = def.stamina;
    staminaMax[i] = def.staminaMax;
    regenPerSecond100[i] = def.regenPerSecond100;
    regenAccumulator[i] = 0;
  }

  @override
  void onDenseAdded(int denseIndex) {
    stamina.add(0);
    staminaMax.add(0);
    regenPerSecond100.add(0);
    regenAccumulator.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    stamina[removeIndex] = stamina[lastIndex];
    staminaMax[removeIndex] = staminaMax[lastIndex];
    regenPerSecond100[removeIndex] = regenPerSecond100[lastIndex];
    regenAccumulator[removeIndex] = regenAccumulator[lastIndex];

    stamina.removeLast();
    staminaMax.removeLast();
    regenPerSecond100.removeLast();
    regenAccumulator.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/status/bleed_store.dart =====
import '../../entity_id.dart';
import '../../sparse_set.dart';

class BleedDef {
  const BleedDef({
    required this.ticksLeft,
    required this.periodTicks,
    required this.dps100,
  }) : periodTicksLeft = periodTicks;

  final int ticksLeft;
  final int periodTicks;
  final int periodTicksLeft;
  /// Fixed-point DPS: 100 = 1.0 per second
  final int dps100;
}

/// Active bleed (damage-over-time) status.
class BleedStore extends SparseSet {
  final List<int> ticksLeft = <int>[];
  final List<int> periodTicks = <int>[];
  final List<int> periodTicksLeft = <int>[];
  /// Fixed-point DPS: 100 = 1.0 per second
  final List<int> dps100 = <int>[];

  void add(EntityId entity, BleedDef def) {
    final i = addEntity(entity);
    ticksLeft[i] = def.ticksLeft;
    periodTicks[i] = def.periodTicks;
    periodTicksLeft[i] = def.periodTicksLeft;
    dps100[i] = def.dps100;
  }

  @override
  void onDenseAdded(int denseIndex) {
    ticksLeft.add(0);
    periodTicks.add(1);
    periodTicksLeft.add(1);
    dps100.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    ticksLeft[removeIndex] = ticksLeft[lastIndex];
    periodTicks[removeIndex] = periodTicks[lastIndex];
    periodTicksLeft[removeIndex] = periodTicksLeft[lastIndex];
    dps100[removeIndex] = dps100[lastIndex];

    ticksLeft.removeLast();
    periodTicks.removeLast();
    periodTicksLeft.removeLast();
    dps100.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/status/burn_store.dart =====
import '../../entity_id.dart';
import '../../sparse_set.dart';

class BurnDef {
  const BurnDef({
    required this.ticksLeft,
    required this.periodTicks,
    required this.dps100,
  }) : periodTicksLeft = periodTicks;

  final int ticksLeft;
  final int periodTicks;
  final int periodTicksLeft;
  /// Fixed-point DPS: 100 = 1.0 per second
  final int dps100;
}

/// Active burn (damage-over-time) status.
class BurnStore extends SparseSet {
  final List<int> ticksLeft = <int>[];
  final List<int> periodTicks = <int>[];
  final List<int> periodTicksLeft = <int>[];
  /// Fixed-point DPS: 100 = 1.0 per second
  final List<int> dps100 = <int>[];

  void add(EntityId entity, BurnDef def) {
    final i = addEntity(entity);
    ticksLeft[i] = def.ticksLeft;
    periodTicks[i] = def.periodTicks;
    periodTicksLeft[i] = def.periodTicksLeft;
    dps100[i] = def.dps100;
  }

  @override
  void onDenseAdded(int denseIndex) {
    ticksLeft.add(0);
    periodTicks.add(1);
    periodTicksLeft.add(1);
    dps100.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    ticksLeft[removeIndex] = ticksLeft[lastIndex];
    periodTicks[removeIndex] = periodTicks[lastIndex];
    periodTicksLeft[removeIndex] = periodTicksLeft[lastIndex];
    dps100[removeIndex] = dps100[lastIndex];

    ticksLeft.removeLast();
    periodTicks.removeLast();
    periodTicksLeft.removeLast();
    dps100.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/status/slow_store.dart =====
import '../../entity_id.dart';
import '../../sparse_set.dart';

class SlowDef {
  const SlowDef({required this.ticksLeft, required this.magnitude});

  final int ticksLeft;
  /// Basis points (100 = 1%).
  final int magnitude;
}

/// Active slow status (movement speed multiplier).
class SlowStore extends SparseSet {
  final List<int> ticksLeft = <int>[];
  /// Basis points (100 = 1%).
  final List<int> magnitude = <int>[];

  void add(EntityId entity, SlowDef def) {
    final i = addEntity(entity);
    ticksLeft[i] = def.ticksLeft;
    magnitude[i] = def.magnitude;
  }

  @override
  void onDenseAdded(int denseIndex) {
    ticksLeft.add(0);
    magnitude.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    ticksLeft[removeIndex] = ticksLeft[lastIndex];
    magnitude[removeIndex] = magnitude[lastIndex];
    ticksLeft.removeLast();
    magnitude.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/transform_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

/// SoA store for `Transform` (position + velocity).
///
/// This is the "hot" store accessed by almost every system.
class TransformStore extends SparseSet {
  final List<double> posX = <double>[];
  final List<double> posY = <double>[];
  final List<double> velX = <double>[];
  final List<double> velY = <double>[];

  void add(
    EntityId entity, {
    required double posX,
    required double posY,
    required double velX,
    required double velY,
  }) {
    final i = addEntity(entity);
    this.posX[i] = posX;
    this.posY[i] = posY;
    this.velX[i] = velX;
    this.velY[i] = velY;
  }

  void setPosXY(EntityId entity, double x, double y) {
    final i = indexOf(entity);
    posX[i] = x;
    posY[i] = y;
  }

  void setVelXY(EntityId entity, double x, double y) {
    final i = indexOf(entity);
    velX[i] = x;
    velY[i] = y;
  }

  @override
  void onDenseAdded(int denseIndex) {
    posX.add(0);
    posY.add(0);
    velX.add(0);
    velY.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    posX[removeIndex] = posX[lastIndex];
    posY[removeIndex] = posY[lastIndex];
    velX[removeIndex] = velX[lastIndex];
    velY[removeIndex] = velY[lastIndex];

    posX.removeLast();
    posY.removeLast();
    velX.removeLast();
    velY.removeLast();
  }
}


===== FILE: lib/core/ecs/systems/ability_activation_system.dart =====
import 'dart:math';

import '../../abilities/ability_gate.dart';
import '../../abilities/ability_catalog.dart';
import '../../abilities/ability_def.dart';
import '../../combat/hit_payload_builder.dart';
import '../../snapshots/enums.dart';
import '../../projectiles/projectile_item_catalog.dart';
import '../../weapons/weapon_catalog.dart';
import '../../util/fixed_math.dart';
import '../../util/tick_math.dart';
import '../entity_id.dart';
import '../stores/combat/equipped_loadout_store.dart';
import '../stores/melee_intent_store.dart';
import '../stores/mobility_intent_store.dart';
import '../stores/projectile_intent_store.dart';
import '../stores/self_intent_store.dart';
import '../world.dart';

/// Routes player input into ability intents based on the equipped loadout.
///
/// **Responsibilities**:
/// - Read player input (strike/projectile/secondary/mobility/jump).
/// - Resolve the equipped ability for each slot.
/// - Emit intent stores (melee/projectile) for execution systems.
///
/// **Determinism**:
/// - No RNG.
/// - No wall-clock time; uses [currentTick].
class AbilityActivationSystem {
  const AbilityActivationSystem({
    required this.tickHz,
    required this.inputBufferTicks,
    required this.abilities,
    required this.weapons,
    required this.projectileItems,
  });

  final int tickHz;
  final int inputBufferTicks;
  final AbilityCatalog abilities;
  final WeaponCatalog weapons;
  final ProjectileItemCatalog projectileItems;

  void step(
    EcsWorld world, {
    required EntityId player,
    required int currentTick,
  }) {
    final inputIndex = world.playerInput.tryIndexOf(player);
    if (inputIndex == null) return;

    final movementIndex = world.movement.tryIndexOf(player);
    if (movementIndex == null) return;

    final loadoutIndex = world.equippedLoadout.tryIndexOf(player);
    if (loadoutIndex == null) return;

    if (world.controlLock.isStunned(player, currentTick)) return;

    final axis = world.playerInput.moveAxis[inputIndex];
    final Facing facing = axis != 0
        ? (axis > 0 ? Facing.right : Facing.left)
        : world.movement.facing[movementIndex];

    final bufferIndex = world.abilityInputBuffer.tryIndexOf(player);
    if (bufferIndex == null) {
      assert(
        false,
        'AbilityActivationSystem requires AbilityInputBufferStore on the player; add it at spawn time.',
      );
      return;
    }

    _expireBuffer(world, player, bufferIndex, currentTick);

    final activePhase = _activePhaseFor(world, player);
    final hasActive = activePhase != AbilityPhase.idle;
    final isRecovery = activePhase == AbilityPhase.recovery;

    final input = world.playerInput;
    if (input.dashPressed[inputIndex]) {
      _cancelCombatOnMobilityPress(world, player);
      _commitSlot(
        world,
        player: player,
        loadoutIndex: loadoutIndex,
        inputIndex: inputIndex,
        movementIndex: movementIndex,
        facing: facing,
        slot: AbilitySlot.mobility,
        commitTick: currentTick,
      );
      return;
    }
    if (input.jumpPressed[inputIndex]) {
      _cancelCombatOnMobilityPress(world, player);
      _commitSlot(
        world,
        player: player,
        loadoutIndex: loadoutIndex,
        inputIndex: inputIndex,
        movementIndex: movementIndex,
        facing: facing,
        slot: AbilitySlot.jump,
        commitTick: currentTick,
      );
      return;
    }

    final slotPressed = _resolvePressedSlot(world, inputIndex);

    if (hasActive) {
      if (slotPressed != null && isRecovery) {
        _bufferInput(
          world,
          player: player,
          bufferIndex: bufferIndex,
          loadoutIndex: loadoutIndex,
          inputIndex: inputIndex,
          facing: facing,
          slot: slotPressed,
          currentTick: currentTick,
        );
      }
      return;
    }

    if (slotPressed != null) {
      _commitSlot(
        world,
        player: player,
        loadoutIndex: loadoutIndex,
        inputIndex: inputIndex,
        movementIndex: movementIndex,
        facing: facing,
        slot: slotPressed,
        commitTick: currentTick,
      );
      return;
    }

    if (world.abilityInputBuffer.hasBuffered[bufferIndex]) {
      _commitBuffered(
        world,
        player: player,
        bufferIndex: bufferIndex,
        loadoutIndex: loadoutIndex,
        movementIndex: movementIndex,
        commitTick: currentTick,
      );
    }
  }

  AbilityPhase _activePhaseFor(EcsWorld world, EntityId entity) {
    if (!world.activeAbility.has(entity)) return AbilityPhase.idle;
    final index = world.activeAbility.indexOf(entity);
    final abilityId = world.activeAbility.abilityId[index];
    if (abilityId == null || abilityId.isEmpty) return AbilityPhase.idle;
    return world.activeAbility.phase[index];
  }

  AbilitySlot? _resolvePressedSlot(EcsWorld world, int inputIndex) {
    final input = world.playerInput;
    if (input.hasAbilitySlotPressed[inputIndex]) {
      return input.lastAbilitySlotPressed[inputIndex];
    }
    if (input.strikePressed[inputIndex]) return AbilitySlot.primary;
    if (input.secondaryPressed[inputIndex]) return AbilitySlot.secondary;
    if (input.projectilePressed[inputIndex]) return AbilitySlot.projectile;
    if (input.bonusPressed[inputIndex]) return AbilitySlot.bonus;
    return null;
  }

  void _expireBuffer(
    EcsWorld world,
    EntityId player,
    int bufferIndex,
    int currentTick,
  ) {
    if (!world.abilityInputBuffer.hasBuffered[bufferIndex]) return;
    final expires = world.abilityInputBuffer.expiresTick[bufferIndex];
    if (expires >= 0 && currentTick > expires) {
      world.abilityInputBuffer.clear(player);
    }
  }

  void _bufferInput(
    EcsWorld world, {
    required EntityId player,
    required int bufferIndex,
    required int loadoutIndex,
    required int inputIndex,
    required Facing facing,
    required AbilitySlot slot,
    required int currentTick,
  }) {
    final abilityId = _abilityIdForSlot(
      world,
      loadoutIndex,
      slot,
      inputIndex: inputIndex,
    );
    if (abilityId == null) return;
    final ability = abilities.resolve(abilityId);
    if (ability == null) return;

    final aim = _aimForAbility(world, inputIndex, slot, ability);

    world.abilityInputBuffer.setBuffer(
      player,
      slot: slot,
      abilityId: abilityId,
      aimDirX: aim.$1,
      aimDirY: aim.$2,
      facing: facing,
      commitTick: currentTick,
      expiresTick: currentTick + inputBufferTicks,
    );
  }

  void _commitBuffered(
    EcsWorld world, {
    required EntityId player,
    required int bufferIndex,
    required int loadoutIndex,
    required int movementIndex,
    required int commitTick,
  }) {
    final slot = world.abilityInputBuffer.slot[bufferIndex];
    final abilityId = world.abilityInputBuffer.abilityId[bufferIndex];
    final aimX = world.abilityInputBuffer.aimDirX[bufferIndex];
    final aimY = world.abilityInputBuffer.aimDirY[bufferIndex];
    final facing = world.abilityInputBuffer.facing[bufferIndex];

    final committed = _commitSlot(
      world,
      player: player,
      loadoutIndex: loadoutIndex,
      inputIndex: null,
      movementIndex: movementIndex,
      facing: facing,
      slot: slot,
      commitTick: commitTick,
      aimOverrideX: aimX,
      aimOverrideY: aimY,
      abilityOverrideId: abilityId,
    );

    if (committed) {
      world.abilityInputBuffer.clear(player);
    }
  }

  AbilityKey? _abilityIdForSlot(
    EcsWorld world,
    int loadoutIndex,
    AbilitySlot slot, {
    int? inputIndex,
  }) {
    final loadout = world.equippedLoadout;
    switch (slot) {
      case AbilitySlot.primary:
        return loadout.abilityPrimaryId[loadoutIndex];
      case AbilitySlot.secondary:
        return loadout.abilitySecondaryId[loadoutIndex];
      case AbilitySlot.projectile:
        return loadout.abilityProjectileId[loadoutIndex];
      case AbilitySlot.mobility:
        return loadout.abilityMobilityId[loadoutIndex];
      case AbilitySlot.jump:
        return loadout.abilityJumpId[loadoutIndex];
      case AbilitySlot.bonus:
        return loadout.abilityBonusId[loadoutIndex];
    }
  }

  (double, double) _aimForAbility(
    EcsWorld world,
    int inputIndex,
    AbilitySlot slot,
    AbilityDef ability,
  ) {
    final input = world.playerInput;
    // Aim source is determined by "mechanics", not by UI slot.
    // This required so Bonus can host melee/proj abilities cleanly.
    final hitDelivery = ability.hitDelivery;
    if (hitDelivery is MeleeHitDelivery) {
      return (input.meleeAimDirX[inputIndex], input.meleeAimDirY[inputIndex]);
    }
    if (hitDelivery is ProjectileHitDelivery) {
      return (
        input.projectileAimDirX[inputIndex],
        input.projectileAimDirY[inputIndex],
      );
    }
    return (0.0, 0.0);
  }

  bool _commitSlot(
    EcsWorld world, {
    required EntityId player,
    required int loadoutIndex,
    required int movementIndex,
    required Facing facing,
    required AbilitySlot slot,
    required int commitTick,
    int? inputIndex,
    double? aimOverrideX,
    double? aimOverrideY,
    AbilityKey? abilityOverrideId,
  }) {
    final abilityId =
        abilityOverrideId ??
        _abilityIdForSlot(world, loadoutIndex, slot, inputIndex: inputIndex);
    if (abilityId == null) return false;

    final ability = abilities.resolve(abilityId);
    if (ability == null) {
      assert(false, 'Ability not found: $abilityId');
      return false;
    }

    if (ability.category == AbilityCategory.mobility) {
      return _commitMobility(
        world,
        player: player,
        movementIndex: movementIndex,
        inputIndex: inputIndex,
        facing: facing,
        ability: ability,
        slot: slot,
        commitTick: commitTick,
      );
    }

    final hitDelivery = ability.hitDelivery;
    if (hitDelivery is MeleeHitDelivery) {
      return _commitMelee(
        world,
        player: player,
        loadoutIndex: loadoutIndex,
        inputIndex: inputIndex,
        facing: facing,
        ability: ability,
        slot: slot,
        commitTick: commitTick,
        aimOverrideX: aimOverrideX,
        aimOverrideY: aimOverrideY,
      );
    }
    if (hitDelivery is ProjectileHitDelivery) {
      return _commitProjectile(
        world,
        player: player,
        loadoutIndex: loadoutIndex,
        inputIndex: inputIndex,
        movementIndex: movementIndex,
        facing: facing,
        ability: ability,
        slot: slot,
        commitTick: commitTick,
        aimOverrideX: aimOverrideX,
        aimOverrideY: aimOverrideY,
      );
    }
    if (hitDelivery is SelfHitDelivery) {
      return _commitSelf(
        world,
        player: player,
        loadoutIndex: loadoutIndex,
        facing: facing,
        ability: ability,
        slot: slot,
        commitTick: commitTick,
      );
    }

    return false;
  }

  bool _commitSelf(
    EcsWorld world, {
    required EntityId player,
    required int loadoutIndex,
    required Facing facing,
    required AbilityDef ability,
    required AbilitySlot slot,
    required int commitTick,
  }) {
    if (!world.selfIntent.has(player)) {
      assert(
        false,
        'AbilityActivationSystem requires SelfIntentStore on the player; add it at spawn time.',
      );
      return false;
    }

    // Gate by payload source (Bonus can host anything, so slot is irrelevant).
    final mask = world.equippedLoadout.mask[loadoutIndex];
    switch (ability.payloadSource) {
      case AbilityPayloadSource.none:
        break;
      case AbilityPayloadSource.primaryWeapon:
        if ((mask & LoadoutSlotMask.mainHand) == 0) return false;
        break;
      case AbilityPayloadSource.secondaryWeapon:
        // Off-hand unless primary is two-handed.
        final mainId = world.equippedLoadout.mainWeaponId[loadoutIndex];
        final main = weapons.tryGet(mainId);
        if (main != null && main.isTwoHanded) {
          if ((mask & LoadoutSlotMask.mainHand) == 0) return false;
        } else {
          if ((mask & LoadoutSlotMask.offHand) == 0) return false;
        }
        break;
      case AbilityPayloadSource.projectileItem:
        if ((mask & LoadoutSlotMask.projectile) == 0) return false;
        break;
    }

    final windupTicks = _scaleAbilityTicks(ability.windupTicks);
    final activeTicks = _scaleAbilityTicks(ability.activeTicks);
    final recoveryTicks = _scaleAbilityTicks(ability.recoveryTicks);
    final executeTick = commitTick + windupTicks;
    final cooldownGroupId = ability.effectiveCooldownGroup(slot);
    final cooldownTicks = _scaleAbilityTicks(ability.cooldownTicks);

    final fail = AbilityGate.canCommitCombat(
      world,
      entity: player,
      currentTick: commitTick,
      cooldownGroupId: cooldownGroupId,
      manaCost100: ability.manaCost,
      staminaCost100: ability.staminaCost,
    );
    if (fail != null) return false;

    _applyCommitSideEffects(
      world,
      player: player,
      abilityId: ability.id,
      slot: slot,
      commitTick: commitTick,
      windupTicks: windupTicks,
      activeTicks: activeTicks,
      recoveryTicks: recoveryTicks,
      facingDir: facing,
      cooldownGroupId: cooldownGroupId,
      cooldownTicks: cooldownTicks,
      manaCost100: ability.manaCost,
      staminaCost100: ability.staminaCost,
    );

    world.selfIntent.set(
      player,
      SelfIntentDef(
        abilityId: ability.id,
        slot: slot,
        commitTick: commitTick,
        windupTicks: windupTicks,
        activeTicks: activeTicks,
        recoveryTicks: recoveryTicks,
        cooldownTicks: cooldownTicks,
        staminaCost100: ability.staminaCost,
        manaCost100: ability.manaCost,
        cooldownGroupId: cooldownGroupId,
        tick: executeTick,
      ),
    );
    return true;
  }

  bool _commitMobility(
    EcsWorld world, {
    required EntityId player,
    required int movementIndex,
    required Facing facing,
    required AbilityDef ability,
    required AbilitySlot slot,
    required int commitTick,
    int? inputIndex,
  }) {
    if (!world.mobilityIntent.has(player)) {
      assert(
        false,
        'AbilityActivationSystem requires MobilityIntentStore on the player; add it at spawn time.',
      );
      return false;
    }

    final axis = inputIndex == null
        ? 0.0
        : world.playerInput.moveAxis[inputIndex];
    final dirX = axis != 0
        ? (axis > 0 ? 1.0 : -1.0)
        : (facing == Facing.right ? 1.0 : -1.0);

    final windupTicks = _scaleAbilityTicks(ability.windupTicks);
    final activeTicks = _scaleAbilityTicks(ability.activeTicks);
    final recoveryTicks = _scaleAbilityTicks(ability.recoveryTicks);
    final executeTick = commitTick + windupTicks;
    final cooldownGroupId = ability.effectiveCooldownGroup(slot);
    final cooldownTicks = _scaleAbilityTicks(ability.cooldownTicks);

    // Preserve old behavior: mobility cancels pending combat + buffered input + active combat ability.
    _cancelCombatOnMobilityPress(world, player);

    final fail = AbilityGate.canCommitMobility(
      world,
      entity: player,
      currentTick: commitTick,
      cooldownGroupId: cooldownGroupId,
      staminaCost100: ability.staminaCost,
    );
    if (fail != null) return false;

    final facingDir = dirX >= 0 ? Facing.right : Facing.left;
    _applyCommitSideEffects(
      world,
      player: player,
      abilityId: ability.id,
      slot: slot,
      commitTick: commitTick,
      windupTicks: windupTicks,
      activeTicks: activeTicks,
      recoveryTicks: recoveryTicks,
      facingDir: facingDir,
      cooldownGroupId: cooldownGroupId,
      cooldownTicks: cooldownTicks,
      manaCost100: 0,
      staminaCost100: ability.staminaCost,
      movementIndex: movementIndex,
    );

    world.mobilityIntent.set(
      player,
      MobilityIntentDef(
        abilityId: ability.id,
        slot: slot,
        dirX: dirX,
        commitTick: commitTick,
        windupTicks: windupTicks,
        activeTicks: activeTicks,
        recoveryTicks: recoveryTicks,
        cooldownTicks: cooldownTicks,
        staminaCost100: ability.staminaCost,
        cooldownGroupId: cooldownGroupId,
        tick: executeTick,
      ),
    );
    return true;
  }

  bool _commitMelee(
    EcsWorld world, {
    required EntityId player,
    required int loadoutIndex,
    required Facing facing,
    required AbilityDef ability,
    required AbilitySlot slot,
    required int commitTick,
    int? inputIndex,
    double? aimOverrideX,
    double? aimOverrideY,
  }) {
    if (!world.meleeIntent.has(player)) {
      assert(
        false,
        'AbilityActivationSystem requires MeleeIntentStore on the player; add it at spawn time.',
      );
      return false;
    }

    final mask = world.equippedLoadout.mask[loadoutIndex];
    // Gate by payload source, not by triggered slot.
    switch (ability.payloadSource) {
      case AbilityPayloadSource.none:
        break;
      case AbilityPayloadSource.primaryWeapon:
        if ((mask & LoadoutSlotMask.mainHand) == 0) return false;
        break;
      case AbilityPayloadSource.secondaryWeapon:
        final mainId = world.equippedLoadout.mainWeaponId[loadoutIndex];
        final main = weapons.tryGet(mainId);
        if (main != null && main.isTwoHanded) {
          if ((mask & LoadoutSlotMask.mainHand) == 0) return false;
        } else {
          if ((mask & LoadoutSlotMask.offHand) == 0) return false;
        }
        break;
      case AbilityPayloadSource.projectileItem:
        // Melee delivery cannot legally pull payload from projectile item.
        return false;
    }

    final hitDelivery = ability.hitDelivery;
    if (hitDelivery is! MeleeHitDelivery) return false;

    final aimX =
        aimOverrideX ??
        (inputIndex == null ? 0.0 : world.playerInput.meleeAimDirX[inputIndex]);
    final aimY =
        aimOverrideY ??
        (inputIndex == null ? 0.0 : world.playerInput.meleeAimDirY[inputIndex]);
    final len2 = aimX * aimX + aimY * aimY;

    final double dirX;
    final double dirY;
    if (len2 > 1e-12) {
      final invLen = 1.0 / sqrt(len2);
      dirX = aimX * invLen;
      dirY = aimY * invLen;
    } else {
      dirX = facing == Facing.right ? 1.0 : -1.0;
      dirY = 0.0;
    }

    // Resolve hitbox dimensions from the ability.
    final halfX = hitDelivery.sizeX * 0.5;
    final halfY = hitDelivery.sizeY * 0.5;

    // Offset: push the hitbox forward from the player collider.
    var maxHalfExtent = 0.0;
    if (world.colliderAabb.has(player)) {
      final aabbi = world.colliderAabb.indexOf(player);
      final colliderHalfX = world.colliderAabb.halfX[aabbi];
      final colliderHalfY = world.colliderAabb.halfY[aabbi];
      maxHalfExtent = colliderHalfX > colliderHalfY
          ? colliderHalfX
          : colliderHalfY;
    }
    final forward =
        maxHalfExtent * 0.5 + max(halfX, halfY) + hitDelivery.offsetX;
    final offsetX = dirX * forward;
    final offsetY = dirY * forward + hitDelivery.offsetY;

    final weaponId = () {
      switch (ability.payloadSource) {
        case AbilityPayloadSource.primaryWeapon:
          return world.equippedLoadout.mainWeaponId[loadoutIndex];
        case AbilityPayloadSource.secondaryWeapon:
          final mainId = world.equippedLoadout.mainWeaponId[loadoutIndex];
          final main = weapons.tryGet(mainId);
          if (main != null && main.isTwoHanded) return mainId;
          return world.equippedLoadout.offhandWeaponId[loadoutIndex];
        case AbilityPayloadSource.none:
          // Fallback: preserve old behavior (slot-based) for any legacy melee.
          return slot == AbilitySlot.secondary
              ? world.equippedLoadout.offhandWeaponId[loadoutIndex]
              : world.equippedLoadout.mainWeaponId[loadoutIndex];
        case AbilityPayloadSource.projectileItem:
          return world.equippedLoadout.mainWeaponId[loadoutIndex];
      }
    }();
    final weapon = weapons.get(weaponId);

    final payload = HitPayloadBuilder.build(
      ability: ability,
      source: player,
      weaponStats: weapon.stats,
      weaponDamageType: weapon.damageType,
      weaponProcs: weapon.procs,
    );

    final cooldownGroupId = ability.effectiveCooldownGroup(slot);
    final cooldownTicks = _scaleAbilityTicks(ability.cooldownTicks);

    final fail = AbilityGate.canCommitCombat(
      world,
      entity: player,
      currentTick: commitTick,
      cooldownGroupId: cooldownGroupId,
      manaCost100: 0,
      staminaCost100: ability.staminaCost,
    );
    if (fail != null) return false;

    final facingDir = dirX >= 0 ? Facing.right : Facing.left;
    _applyCommitSideEffects(
      world,
      player: player,
      abilityId: ability.id,
      slot: slot,
      commitTick: commitTick,
      windupTicks: _scaleAbilityTicks(ability.windupTicks),
      activeTicks: _scaleAbilityTicks(ability.activeTicks),
      recoveryTicks: _scaleAbilityTicks(ability.recoveryTicks),
      facingDir: facingDir,
      cooldownGroupId: cooldownGroupId,
      cooldownTicks: cooldownTicks,
      manaCost100: 0,
      staminaCost100: ability.staminaCost,
    );

    world.meleeIntent.set(
      player,
      MeleeIntentDef(
        abilityId: ability.id,
        slot: slot,
        damage100: payload.damage100,
        damageType: payload.damageType,
        procs: payload.procs,
        halfX: halfX,
        halfY: halfY,
        offsetX: offsetX,
        offsetY: offsetY,
        dirX: dirX,
        dirY: dirY,
        commitTick: commitTick,
        windupTicks: _scaleAbilityTicks(ability.windupTicks),
        activeTicks: _scaleAbilityTicks(ability.activeTicks),
        recoveryTicks: _scaleAbilityTicks(ability.recoveryTicks),
        cooldownTicks: cooldownTicks,
        staminaCost100: ability.staminaCost,
        cooldownGroupId: cooldownGroupId,
        tick: commitTick + _scaleAbilityTicks(ability.windupTicks),
      ),
    );
    return true;
  }

  bool _commitProjectile(
    EcsWorld world, {
    required EntityId player,
    required int loadoutIndex,
    required int movementIndex,
    required Facing facing,
    required AbilityDef ability,
    required AbilitySlot slot,
    required int commitTick,
    int? inputIndex,
    double? aimOverrideX,
    double? aimOverrideY,
  }) {
    if (!world.projectileIntent.has(player)) {
      assert(
        false,
        'AbilityActivationSystem requires ProjectileIntentStore on the player; add it at spawn time.',
      );
      return false;
    }

    // Projectile delivery must pull payload from projectile item.
    if (ability.payloadSource != AbilityPayloadSource.projectileItem) {
      return false;
    }
    final mask = world.equippedLoadout.mask[loadoutIndex];
    if ((mask & LoadoutSlotMask.projectile) == 0) return false;

    if (ability.category != AbilityCategory.magic &&
        ability.category != AbilityCategory.ranged) {
      return false;
    }

    final projectileItemId =
        world.equippedLoadout.projectileItemId[loadoutIndex];
    final projectileItem = projectileItems.tryGet(projectileItemId);
    if (projectileItem == null) {
      assert(false, 'Projectile item not found: $projectileItemId');
      return false;
    }

    final aimX =
        aimOverrideX ??
        (inputIndex == null
            ? 0.0
            : world.playerInput.projectileAimDirX[inputIndex]);
    final aimY =
        aimOverrideY ??
        (inputIndex == null
            ? 0.0
            : world.playerInput.projectileAimDirY[inputIndex]);
    final len2 = aimX * aimX + aimY * aimY;
    final fallbackDirX = facing == Facing.right ? 1.0 : -1.0;

    if (ability.category == AbilityCategory.ranged) {
      final double dirX;
      if (len2 > 1e-12) {
        final invLen = 1.0 / sqrt(len2);
        dirX = aimX * invLen;
      } else {
        dirX = fallbackDirX;
      }

      if (dirX.abs() > 1e-6) {
        world.movement.facing[movementIndex] = dirX >= 0
            ? Facing.right
            : Facing.left;
        world.movement.facingLockTicksLeft[movementIndex] = 1;
      }
    }

    double originOffset;
    if (projectileItem.weaponType == WeaponType.projectileSpell) {
      var maxHalfExtent = 0.0;
      if (world.colliderAabb.has(player)) {
        final aabbi = world.colliderAabb.indexOf(player);
        final halfX = world.colliderAabb.halfX[aabbi];
        final halfY = world.colliderAabb.halfY[aabbi];
        maxHalfExtent = halfX > halfY ? halfX : halfY;
      }
      originOffset = maxHalfExtent * 0.5;
    } else {
      originOffset = projectileItem.originOffset;
    }

    final payload = HitPayloadBuilder.build(
      ability: ability,
      source: player,
      weaponStats: projectileItem.stats,
      weaponDamageType: projectileItem.damageType,
      weaponProcs: projectileItem.procs,
    );

    final cooldownGroupId = ability.effectiveCooldownGroup(slot);
    final cooldownTicks = _scaleAbilityTicks(ability.cooldownTicks);

    final fail = AbilityGate.canCommitCombat(
      world,
      entity: player,
      currentTick: commitTick,
      cooldownGroupId: cooldownGroupId,
      manaCost100: ability.manaCost,
      staminaCost100: ability.staminaCost,
    );
    if (fail != null) return false;

    final primaryX = (aimX.abs() > 1e-6) ? aimX : fallbackDirX;
    final facingDir = primaryX >= 0 ? Facing.right : Facing.left;
    _applyCommitSideEffects(
      world,
      player: player,
      abilityId: ability.id,
      slot: slot,
      commitTick: commitTick,
      windupTicks: _scaleAbilityTicks(ability.windupTicks),
      activeTicks: _scaleAbilityTicks(ability.activeTicks),
      recoveryTicks: _scaleAbilityTicks(ability.recoveryTicks),
      facingDir: facingDir,
      cooldownGroupId: cooldownGroupId,
      cooldownTicks: cooldownTicks,
      manaCost100: ability.manaCost,
      staminaCost100: ability.staminaCost,
    );

    world.projectileIntent.set(
      player,
      ProjectileIntentDef(
        projectileItemId: projectileItemId,
        abilityId: ability.id,
        slot: slot,
        damage100: payload.damage100,
        staminaCost100: ability.staminaCost,
        manaCost100: ability.manaCost,
        cooldownTicks: cooldownTicks,
        cooldownGroupId: cooldownGroupId,
        projectileId: projectileItem.projectileId,
        damageType: payload.damageType,
        procs: payload.procs,
        ballistic: projectileItem.ballistic,
        gravityScale: projectileItem.gravityScale,
        dirX: aimX,
        dirY: aimY,
        fallbackDirX: fallbackDirX,
        fallbackDirY: 0.0,
        originOffset: originOffset,
        commitTick: commitTick,
        windupTicks: _scaleAbilityTicks(ability.windupTicks),
        activeTicks: _scaleAbilityTicks(ability.activeTicks),
        recoveryTicks: _scaleAbilityTicks(ability.recoveryTicks),
        tick: commitTick + _scaleAbilityTicks(ability.windupTicks),
      ),
    );
    return true;
  }

  void _applyCommitSideEffects(
    EcsWorld world, {
    required EntityId player,
    required AbilityKey abilityId,
    required AbilitySlot slot,
    required int commitTick,
    required int windupTicks,
    required int activeTicks,
    required int recoveryTicks,
    required Facing facingDir,
    required int cooldownGroupId,
    required int cooldownTicks,
    required int manaCost100,
    required int staminaCost100,
    int? movementIndex,
  }) {
    // Deduct mana (fixed-point) — deterministic clamp.
    if (manaCost100 > 0) {
      final mi = world.mana.tryIndexOf(player);
      assert(
        mi != null,
        'Missing ManaStore on $player for manaCost=$manaCost100',
      );
      if (mi != null) {
        final cur = world.mana.mana[mi];
        final max = world.mana.manaMax[mi];
        world.mana.mana[mi] = clampInt(cur - manaCost100, 0, max);
      }
    }

    // Deduct stamina (fixed-point) — deterministic clamp.
    if (staminaCost100 > 0) {
      final si = world.stamina.tryIndexOf(player);
      assert(
        si != null,
        'Missing StaminaStore on $player for staminaCost=$staminaCost100',
      );
      if (si != null) {
        final cur = world.stamina.stamina[si];
        final max = world.stamina.staminaMax[si];
        world.stamina.stamina[si] = clampInt(cur - staminaCost100, 0, max);
      }
    }

    // Start cooldown at commit (max-refresh semantics already inside CooldownStore.startCooldown()).
    world.cooldown.startCooldown(player, cooldownGroupId, cooldownTicks);

    // Mark active ability at commit.
    world.activeAbility.set(
      player,
      id: abilityId,
      slot: slot,
      commitTick: commitTick,
      windupTicks: windupTicks,
      activeTicks: activeTicks,
      recoveryTicks: recoveryTicks,
      facingDir: facingDir,
    );

    // Keep movement facing consistent for mobility-like commits (matches old MobilitySystem behavior).
    if (movementIndex != null) {
      world.movement.facing[movementIndex] = facingDir;
    }
  }

  int _scaleAbilityTicks(int ticks) {
    if (ticks <= 0) return 0;
    if (tickHz == _abilityTickHz) return ticks;
    final seconds = ticks / _abilityTickHz;
    return ticksFromSecondsCeil(seconds, tickHz);
  }

  static const int _abilityTickHz = 60;

  void _cancelCombatOnMobilityPress(EcsWorld world, EntityId player) {
    _clearCombatIntents(world, player);
    if (world.abilityInputBuffer.has(player)) {
      world.abilityInputBuffer.clear(player);
    }
    _clearActiveCombatAbility(world, player);
  }

  void _clearCombatIntents(EcsWorld world, EntityId player) {
    if (world.meleeIntent.has(player)) {
      final i = world.meleeIntent.indexOf(player);
      world.meleeIntent.tick[i] = -1;
      world.meleeIntent.commitTick[i] = -1;
    }
    if (world.projectileIntent.has(player)) {
      final i = world.projectileIntent.indexOf(player);
      world.projectileIntent.tick[i] = -1;
      world.projectileIntent.commitTick[i] = -1;
    }
    if (world.selfIntent.has(player)) {
      final i = world.selfIntent.indexOf(player);
      world.selfIntent.tick[i] = -1;
      world.selfIntent.commitTick[i] = -1;
    }
  }

  void _clearActiveCombatAbility(EcsWorld world, EntityId player) {
    if (!world.activeAbility.has(player)) return;
    final i = world.activeAbility.indexOf(player);
    final abilityId = world.activeAbility.abilityId[i];
    if (abilityId == null || abilityId.isEmpty) {
      world.activeAbility.clear(player);
      return;
    }
    final def = abilities.resolve(abilityId);
    if (def == null || def.category != AbilityCategory.mobility) {
      world.activeAbility.clear(player);
    }
  }
}


===== FILE: lib/core/ecs/systems/active_ability_phase_system.dart =====
import '../../abilities/ability_def.dart';
import '../world.dart';

/// Updates ActiveAbilityState phase timing and handles forced interruptions.
class ActiveAbilityPhaseSystem {
  void step(EcsWorld world, {required int currentTick}) {
    final active = world.activeAbility;
    if (active.denseEntities.isEmpty) return;

    for (var i = 0; i < active.denseEntities.length; i += 1) {
      final entity = active.denseEntities[i];
      final abilityId = active.abilityId[i];
      if (abilityId == null || abilityId.isEmpty) {
        active.phase[i] = AbilityPhase.idle;
        active.elapsedTicks[i] = 0;
        continue;
      }

      if (_isForcedInterrupted(world, entity, currentTick)) {
        _clearAbility(world, entity, i);
        _clearBufferedInput(world, entity);
        _clearPendingIntents(world, entity);
        continue;
      }

      final commitTick = active.startTick[i];
      var elapsed = currentTick - commitTick;
      if (elapsed < 0) elapsed = 0;
      active.elapsedTicks[i] = elapsed;

      final total = active.totalTicks[i];
      if (total <= 0 || elapsed >= total) {
        _clearAbility(world, entity, i);
        continue;
      }

      final windup = active.windupTicks[i];
      final activeTicks = active.activeTicks[i];

      if (elapsed < windup) {
        active.phase[i] = AbilityPhase.windup;
      } else if (elapsed < windup + activeTicks) {
        active.phase[i] = AbilityPhase.active;
      } else {
        active.phase[i] = AbilityPhase.recovery;
      }
    }
  }

  bool _isForcedInterrupted(EcsWorld world, int entity, int currentTick) {
    if (world.controlLock.isStunned(entity, currentTick)) return true;
    final hi = world.health.tryIndexOf(entity);
    if (hi != null && world.health.hp[hi] <= 0) return true;
    if (world.deathState.has(entity)) return true;
    return false;
  }

  void _clearAbility(EcsWorld world, int entity, int index) {
    world.activeAbility.clear(entity);
    world.activeAbility.phase[index] = AbilityPhase.idle;
    world.activeAbility.elapsedTicks[index] = 0;
  }

  void _clearBufferedInput(EcsWorld world, int entity) {
    if (world.abilityInputBuffer.has(entity)) {
      world.abilityInputBuffer.clear(entity);
    }
  }

  void _clearPendingIntents(EcsWorld world, int entity) {
    if (world.meleeIntent.has(entity)) {
      final i = world.meleeIntent.indexOf(entity);
      world.meleeIntent.tick[i] = -1;
      world.meleeIntent.commitTick[i] = -1;
    }
    if (world.projectileIntent.has(entity)) {
      final i = world.projectileIntent.indexOf(entity);
      world.projectileIntent.tick[i] = -1;
      world.projectileIntent.commitTick[i] = -1;
    }
    if (world.mobilityIntent.has(entity)) {
      final i = world.mobilityIntent.indexOf(entity);
      world.mobilityIntent.tick[i] = -1;
      world.mobilityIntent.commitTick[i] = -1;
    }
    if (world.selfIntent.has(entity)) {
      final i = world.selfIntent.indexOf(entity);
      world.selfIntent.tick[i] = -1;
      world.selfIntent.commitTick[i] = -1;
    }
  }
}


===== FILE: lib/core/ecs/systems/anim/anim_system.dart =====
import '../../../anim/anim_resolver.dart';
import '../../../abilities/ability_catalog.dart';
import '../../../snapshots/enums.dart';
import '../../../enemies/death_behavior.dart';
import '../../../enemies/enemy_catalog.dart';
import '../../../enemies/enemy_id.dart';
import '../../../players/player_tuning.dart';
import '../../../util/tick_math.dart';
import '../../entity_id.dart';
import '../../world.dart';

/// System that computes per-entity animation state each tick.
///
/// Uses [AnimResolver] with per-entity [AnimProfile]s to pick the animation key
/// and frame offset deterministically.
class AnimSystem {
  AnimSystem({
    required int tickHz,
    required this.enemyCatalog,
    required MovementTuningDerived playerMovement,
    required AnimTuningDerived playerAnimTuning,
  }) : _tickHz = tickHz,
       _playerMovement = playerMovement,
       _playerAnimTuning = playerAnimTuning,
       _playerProfile = AnimProfile(
         minMoveSpeed: playerMovement.base.minMoveSpeed,
         runSpeedThresholdX: playerMovement.base.runSpeedThresholdX,
         supportsWalk: true,
         supportsJumpFall: true,
         supportsDash: true,
         supportsCast: true,
         supportsRanged: true,
         supportsSpawn: true,
         supportsStun: true,
         directionalStrike: true,
       ) {
    _buildHitAnimTicksById(tickHz);
  }

  /// Catalog for per-enemy configuration (hit windows, anim profiles).
  final EnemyCatalog enemyCatalog;

  final int _tickHz;
  final MovementTuningDerived _playerMovement;
  final AnimTuningDerived _playerAnimTuning;
  final AnimProfile _playerProfile;

  /// Pre-computed hit animation durations in ticks per enemy type.
  late final Map<EnemyId, int> _hitAnimTicksById;

  void _buildHitAnimTicksById(int tickHz) {
    _hitAnimTicksById = <EnemyId, int>{};
    for (final id in EnemyId.values) {
      final seconds = enemyCatalog.get(id).hitAnimSeconds;
      _hitAnimTicksById[id] = ticksFromSecondsCeil(seconds, tickHz);
    }
  }

  /// Updates animation state for player and enemies.
  ///
  /// Call this once per tick before [SnapshotBuilder.build].
  void step(EcsWorld world, {required EntityId player, required int currentTick}) {
    _stepPlayer(world, player: player, currentTick: currentTick);
    _stepEnemies(world, currentTick: currentTick);
  }

  void _stepPlayer(
    EcsWorld world, {
    required EntityId player,
    required int currentTick,
  }) {
    if (player < 0) return;
    if (!world.animState.has(player)) return;
    if (!world.transform.has(player) || !world.movement.has(player)) return;

    final ai = world.animState.indexOf(player);
    final ti = world.transform.indexOf(player);
    final mi = world.movement.indexOf(player);

    final hi = world.health.tryIndexOf(player);
    final hp = hi == null ? 1 : world.health.hp[hi];

    final grounded = world.collision.has(player)
        ? world.collision.grounded[world.collision.indexOf(player)]
        : false;

    final facing = world.movement.facing[mi];
    const lastMeleeTick = -1;
    final lastMeleeFacing = facing;
    const lastCastTick = -1;
    const lastRangedTick = -1;

    final lastDamageTick = world.lastDamage.has(player)
        ? world.lastDamage.tick[world.lastDamage.indexOf(player)]
        : -1;
    
    final stunLocked = world.controlLock.isStunned(player, currentTick);
    
    // Phase 6: Active Action Layer
    final activeAction = _resolveActiveAction(
      world,
      entity: player,
      currentTick: currentTick,
      stunned: stunLocked,
      hp: hp,
      deathPhase: DeathPhase.none,
    );

    final signals = AnimSignals.player(
      tick: currentTick,
      hp: hp,
      grounded: grounded,
      velX: world.transform.velX[ti],
      velY: world.transform.velY[ti],
      lastDamageTick: lastDamageTick,
      hitAnimTicks: _playerAnimTuning.hitAnimTicks,
      lastStrikeTick: lastMeleeTick,
      strikeAnimTicks: _playerAnimTuning.strikeAnimTicks,
      backStrikeAnimTicks: _playerAnimTuning.backStrikeAnimTicks,
      lastStrikeFacing: lastMeleeFacing,
      lastCastTick: lastCastTick,
      castAnimTicks: _playerAnimTuning.castAnimTicks,
      lastRangedTick: lastRangedTick,
      rangedAnimTicks: _playerAnimTuning.rangedAnimTicks,
      dashTicksLeft: 0,
      dashDurationTicks: 0,
      spawnAnimTicks: _playerAnimTuning.spawnAnimTicks,
      stunLocked: stunLocked,
      activeActionAnim: activeAction.anim,
      activeActionFrame: activeAction.frame,
    );

    final result = AnimResolver.resolve(_playerProfile, signals);
    world.animState.anim[ai] = result.anim;
    world.animState.animFrame[ai] = result.animFrame;
  }

  void _stepEnemies(EcsWorld world, {required int currentTick}) {
    final enemies = world.enemy;
    final animStore = world.animState;

    for (var ei = 0; ei < enemies.denseEntities.length; ei += 1) {
      final e = enemies.denseEntities[ei];
      if (!animStore.has(e)) continue;
      final ai = animStore.indexOf(e);
      final enemyId = enemies.enemyId[ei];
      final profile = enemyCatalog.get(enemyId).animProfile;

      final hp = world.health.has(e)
          ? world.health.hp[world.health.indexOf(e)]
          : 1;

      final grounded = world.collision.has(e)
          ? world.collision.grounded[world.collision.indexOf(e)]
          : false;

      final di = world.deathState.tryIndexOf(e);
      final deathPhase = di == null ? DeathPhase.none : world.deathState.phase[di];
      final deathStartTick = di == null ? -1 : world.deathState.deathStartTick[di];

      final lastDamageTick = world.lastDamage.has(e)
          ? world.lastDamage.tick[world.lastDamage.indexOf(e)]
          : -1;

      final hitAnimTicks = _hitAnimTicksById[enemyId] ?? 0;
      const lastMeleeTick = -1;
      const lastMeleeAnimTicks = 0;
      const lastMeleeFacing = Facing.right;

      final ti = world.transform.tryIndexOf(e);
      final velX = ti == null ? 0.0 : world.transform.velX[ti];
      final velY = ti == null ? 0.0 : world.transform.velY[ti];

      final stunLocked = world.controlLock.isStunned(e, currentTick);

      // Phase 6: Active Action Layer (Enemies)
      final activeAction = _resolveActiveAction(
        world,
        entity: e,
        currentTick: currentTick,
        stunned: stunLocked,
        hp: hp,
        deathPhase: deathPhase,
      );

      final signals = AnimSignals.enemy(
        tick: currentTick,
        hp: hp,
        deathPhase: deathPhase,
        deathStartTick: deathStartTick,
        grounded: grounded,
        velX: velX,
        velY: velY,
        lastDamageTick: lastDamageTick,
        hitAnimTicks: hitAnimTicks,
        lastStrikeTick: lastMeleeTick,
        strikeAnimTicks: lastMeleeAnimTicks,
        lastStrikeFacing: lastMeleeFacing,
        stunLocked: stunLocked,
        activeActionAnim: activeAction.anim,
        activeActionFrame: activeAction.frame,
      );

      final result = AnimResolver.resolve(profile, signals);
      animStore.anim[ai] = result.anim;
      animStore.animFrame[ai] = result.animFrame;
    }
  }

  ({AnimKey? anim, int frame}) _resolveActiveAction(
    EcsWorld world, {
    required EntityId entity,
    required int currentTick,
    required bool stunned,
    required int hp,
    required DeathPhase deathPhase,
  }) {
    if (!world.activeAbility.has(entity)) {
      return (anim: null, frame: 0);
    }

    if (stunned || hp <= 0 || deathPhase != DeathPhase.none) {
      world.activeAbility.clear(entity);
      return (anim: null, frame: 0);
    }

    final index = world.activeAbility.indexOf(entity);
    final activeId = world.activeAbility.abilityId[index];
    if (activeId == null || activeId.isEmpty) {
      world.activeAbility.clear(entity);
      return (anim: null, frame: 0);
    }

    final def = AbilityCatalog.tryGet(activeId);
    if (def == null) {
      world.activeAbility.clear(entity);
      return (anim: null, frame: 0);
    }

    final elapsed = world.activeAbility.elapsedTicks[index];
    final totalTicks = world.activeAbility.totalTicks[index];
    final maxTicks = totalTicks > 0 ? totalTicks : 1;

    if (elapsed >= maxTicks) {
      world.activeAbility.clear(entity);
      return (anim: null, frame: 0);
    }

    return (anim: def.animKey, frame: elapsed < 0 ? 0 : elapsed);
  }
}


===== FILE: lib/core/ecs/systems/anim/TODO.md =====
# TODO — `lib/core/ecs/systems/anim_system.dart`

> Goal: ensure AnimSystem emits **correct, deterministic** `AnimSignals` for all entities (player + enemies) and updates `AnimStateStore` without hiding gameplay bugs.

---

## P0 — Must fix (current behavior is incorrect / missing)

### [ ] Wire **player spawnStartTick** (spawn cannot be correct without it)

**Symptom**: player signals don’t provide a real spawn start tick, so spawn anim either never plays (if resolver requires `spawnStartTick`) or only plays at global tick 0 (legacy behavior).

**Task**

* Add authoritative source for player spawn timing (choose one):

  * `SpawnStateStore` (recommended) storing `spawnStartTick` per entity
  * Or a one-shot “run start tick” for the player entity if player only spawns once per run
* Pass `spawnStartTick` into `AnimSignals.player(...)`.

**Acceptance**

* Spawn anim plays for exactly `spawnAnimTicks` after spawn, even if the player respawns mid-run.

---

### [ ] Provide **player death lifecycle** (`deathPhase` + `deathStartTick`)

**Symptom**: player signals hardcode `deathPhase: none`, so resolver can’t start death animation deterministically.

**Task**

* Pick a unified death representation for player + enemies:

  * Option A (recommended): use the existing `DeathStateStore` for player entity too
  * Option B: add minimal player-specific death tick fields
* Feed `deathPhase` and `deathStartTick` into `AnimSignals.player(...)`.

**Acceptance**

* On player death, death anim starts at frame 0 on the first death tick.
* No fallback to `lastDamageTick` is needed once systems always provide `deathStartTick`.

---

### [ ] Wire **dash ticks** (`dashTicksLeft`, `dashDurationTicks`)

**Symptom**: dash animation can’t trigger if the system never emits dash timing signals.

**Task**

* Identify dash state source (mobility store / intent / status).
* Emit:

  * `dashTicksLeft`
  * `dashDurationTicks`

**Acceptance**

* Dash anim plays exactly during dash window, and frame progresses deterministically.

---

### [ ] Stop emitting permanently disabled legacy timestamps for player (`lastMeleeTick/lastCastTick/lastRangedTick = -1`)

**Symptom**: legacy strike/cast/ranged anim paths are dead for player.

**Decision** (pick one and commit)

* **A — Remove legacy**: delete/ignore these fields for player entirely and rely on `ActiveAbilityStateStore` exclusively.
* **B — Support legacy**: wire real timestamps from intent stores / combat events.

**Acceptance**

* No “ghost” fields that are always `-1` unless they are explicitly deprecated.

---

## P1 — Determinism + visual consistency

### [ ] Add/emit **stunStartTick** (stun anim should be relative to stun start)

**Symptom**: with only `stunLocked: bool`, resolver tends to drive stun frames from global `tick`, producing phase noise.

**Task**

* Extend `AnimSignals` to include `stunStartTick`.
* Update the lock/control store to track the tick when stun became active.
* Emit `stunStartTick` from AnimSystem.

**Acceptance**

* Stun anim starts at frame 0 on stun application.
* Re-applying stun restarts (or follows your defined rule) deterministically.

---

### [ ] Clarify/guarantee `ActiveAbilityStateStore` semantics

**Risk**: if `activeAbility.frame` is not strictly relative to the ability start tick, animations will drift.

**Task**

* Document invariants:

  * `frame` is 0 on the first tick of the ability phase.
  * `frame` increments by 1 per sim tick while active.
* Ensure AnimSystem never “guesses” frame using global tick.

**Acceptance**

* Ability animations always start at frame 0.

---

## P2 — Maintainability + bug-proofing

### [ ] Make AnimSystem **read-only** with respect to gameplay state

**Rule**: AnimSystem should not cancel abilities, clear intents, or mutate combat state.

**Task**

* Audit for writes to gameplay stores.
* If any exist, move them to the owning gameplay system.

**Acceptance**

* Reordering AnimSystem in the pipeline never changes gameplay outcomes.

---

### [ ] Reduce duplication between `_stepPlayer` and `_stepEnemies`

**Task**

* Extract a small helper that builds `AnimSignals` from common store reads (hp, movement, stun, active ability, hit/death phases).
* Keep player-specific bits (dash/spawn) as overrides.

**Acceptance**

* Adding a new signal field requires changing code in one place.

---

### [ ] Add minimal unit tests (high ROI)

**Tests**

* Player spawn window uses `spawnStartTick`.
* Player death starts at `deathStartTick`.
* Dash emits correct frames.
* Active ability anim uses ability-relative frame.
* Stun uses `stunStartTick`.

---

## P3 — Performance (only after profiling)

### [ ] Avoid per-entity allocations if DevTools shows GC pressure

**Note**: keep resolver returning `AnimResult` until profiling proves it’s hot.

**If needed**

* Switch to `resolveInto(...)` that writes directly into `AnimStateStore` arrays.
* Or store `AnimKey + frameHint` directly without creating objects.

**Acceptance**

* Verified reduction in allocations + improved frame time/jank in profiler.

---

## Suggested implementation order

1. Player spawnStartTick (P0)
2. Player death state (P0)
3. Dash ticks (P0)
4. Decide legacy timestamps vs ActiveAbility-only (P0)
5. Stun start tick plumbing (P1)
6. Read-only audit + refactor helpers + tests (P2)
7. Perf only if profiled (P3)


===== FILE: lib/core/ecs/systems/collectible_system.dart =====
import '../hit/aabb_hit_utils.dart';
import '../entity_id.dart';
import '../world.dart';
import '../../tuning/collectible_tuning.dart';

/// System responsible for updating collectible entities (e.g. coins).
///
/// It handles:
/// 1. Despawning collectibles that have fallen behind the camera.
/// 2. Detecting collisions between the player and collectibles.
/// 3. Triggering collection callbacks and destroying collected entities.
class CollectibleSystem {
  // Recycled list to avoid per-frame allocations for destruction.
  final List<EntityId> _toDespawn = <EntityId>[];

  /// Updates all collectibles.
  ///
  /// [cameraLeft] is the world-space X coordinate of the left edge of the camera,
  /// used for culling entities that are no longer visible.
  void step(
    EcsWorld world, {
    required EntityId player,
    required double cameraLeft,
    required CollectibleTuning tuning,
    required void Function(int value) onCollected,
  }) {
    final collectibles = world.collectible;
    if (collectibles.denseEntities.isEmpty) return;

    // Pre-resolve player components to avoid looking them up for every collectible.
    final playerTi = world.transform.tryIndexOf(player);
    final playerAi = world.colliderAabb.tryIndexOf(player);
    final canCollect = playerTi != null && playerAi != null;

    _toDespawn.clear();

    final despawnLimit = cameraLeft - tuning.despawnBehindCameraMargin;
    for (var ci = 0; ci < collectibles.denseEntities.length; ci += 1) {
      final e = collectibles.denseEntities[ci];
      final ti = world.transform.tryIndexOf(e);
      final ai = world.colliderAabb.tryIndexOf(e);
      // Skip if entity is missing required components (malformed entity).
      if (ti == null || ai == null) continue;

      final centerX = world.transform.posX[ti] + world.colliderAabb.offsetX[ai];
      
      // 1. Culling: Despawn if far behind the camera.
      if (centerX < despawnLimit) {
        _toDespawn.add(e);
        continue;
      }

      // 2. Collection: Check AABB overlap with player.
      if (canCollect) {
        final overlaps = aabbOverlapsWorldColliders(
          world,
          aTransformIndex: ti,
          aAabbIndex: ai,
          bTransformIndex: playerTi,
          bAabbIndex: playerAi,
        );
        if (overlaps) {
          onCollected(collectibles.value[ci]);
          _toDespawn.add(e);
        }
      }
    }

    // Apply deferred destruction.
    for (final e in _toDespawn) {
      world.destroyEntity(e);
    }
  }
}


===== FILE: lib/core/ecs/systems/collision_system.dart =====
import '../../collision/static_world_geometry_index.dart';
import '../../players/player_tuning.dart';
import '../queries.dart';
import '../stores/body_store.dart';
import '../world.dart';

/// Handles physics integration and collision resolution for dynamic entities.
///
/// This system operates in three main steps:
/// 1.  **Integration**: Updates position based on velocity (`pos += vel * dt`).
/// 2.  **Vertical Resolution**:
///     -   Checks floors (ground segments and one-way platforms).
///     -   Checks ceilings (if not ignored).
///     -   Snaps position to the contact surface and zeroes vertical velocity.
/// 3.  **Horizontal Resolution**:
///     -   Checks walls in the direction of movement.
///     -   Stops horizontal movement upon collision.
///
/// Order within a tick:
/// - PlayerMovementSystem computes control velocities (jump/dash/horizontal).
/// - GravitySystem applies vertical gravity acceleration.
/// - CollisionSystem integrates `pos += vel * dt`, resolves collisions, and
///   finalizes grounded/contact state for the tick.
class CollisionSystem {
  // Reusable buffers to avoid allocations during collision queries.
  final List<StaticSolid> _queryBuffer = <StaticSolid>[];
  final List<StaticGroundSegment> _groundSegBuffer = <StaticGroundSegment>[];

  /// Runs the physics update for one tick.
  ///
  /// [tuning] provides the delta time [dtSeconds].
  /// [staticWorld] is the spatial index for static geometry (floors, walls).
  void step(
    EcsWorld world,
    MovementTuningDerived tuning, {
    required StaticWorldGeometryIndex staticWorld,
  }) {
    final dt = tuning.dtSeconds;
    // Epsilon for floating point comparisons and overlap tolerance.
    const eps = 1e-3;

    EcsQueries.forColliders(world, (e, ti, bi, coli, aabbi) {
      if (!world.body.enabled[bi]) return;

      // Reset per-tick collision flags (grounded, hitCeiling, etc.).
      world.collision.resetTick(e);

      // Kinematic bodies are excluded from physics integration/resolution.
      // They are moved manually by other systems.
      if (world.body.isKinematic[bi]) {
        return;
      }


      final prevPosX = world.transform.posX[ti];
      final prevPosY = world.transform.posY[ti];

      // Integrate position from the current velocity.
      world.transform.posX[ti] += world.transform.velX[ti] * dt;
      world.transform.posY[ti] += world.transform.velY[ti] * dt;

      final halfX = world.colliderAabb.halfX[aabbi];
      final halfY = world.colliderAabb.halfY[aabbi];
      final offsetX = world.colliderAabb.offsetX[aabbi];
      final offsetY = world.colliderAabb.offsetY[aabbi];

      final prevCenterX = prevPosX + offsetX;
      final prevCenterY = prevPosY + offsetY;
      final prevBottom = prevCenterY + halfY;

      final centerX = world.transform.posX[ti] + offsetX;
      final centerY = world.transform.posY[ti] + offsetY;
      final minX = centerX - halfX;
      final maxX = centerX + halfX;
      final bottom = centerY + halfY;
      final top = centerY - halfY;

      // Vertical top resolution (one-way platforms): only while moving downward.
      double? bestTopY;
      if (world.transform.velY[ti] > 0) {
        _queryBuffer.clear();
        staticWorld.queryTops(minX + eps, maxX - eps, _queryBuffer);
        for (final solid in _queryBuffer) {
          final topY = solid.minY;
          final crossesTop =
              prevBottom <= topY + eps && bottom >= topY - eps;
          if (!crossesTop) continue;

          if (bestTopY == null || topY < bestTopY) {
            bestTopY = topY;
          }
        }
      }

      // Check ceilings.
      // Only resolve if moving upward and the body collides with ceilings.
      double? bestBottomY;
      if (world.transform.velY[ti] < 0 && !world.body.ignoreCeilings[bi]) {
        final prevTop = prevCenterY - halfY;
        _queryBuffer.clear();
        staticWorld.queryBottoms(minX + eps, maxX - eps, _queryBuffer);
        for (final solid in _queryBuffer) {
          final bottomY = solid.maxY;
          // Check if we crossed the surface from below to above.
          final crossesBottom =
              prevTop >= bottomY - eps && top <= bottomY + eps;
          if (!crossesBottom) continue;

          // Keep the lowest ceiling (maximum Y) encountered.
          if (bestBottomY == null || bottomY > bestBottomY) {
            bestBottomY = bottomY;
          }
        }
      }

      // Check Ground Segments (optimized horizontal strips for ground).
      // Treated same as one-way platforms.
      if (world.transform.velY[ti] > 0) {
        _groundSegBuffer.clear();
        staticWorld.queryGroundSegments(minX + eps, maxX - eps, _groundSegBuffer);
        for (final seg in _groundSegBuffer) {
          final groundTopY = seg.topY;
          final crossesTop =
              prevBottom <= groundTopY + eps && bottom >= groundTopY - eps;
          if (!crossesTop) continue;
          
          if (bestTopY == null || groundTopY < bestTopY) {
            bestTopY = groundTopY;
          }
        }
      }

      // Apply vertical resolution.
      if (bestTopY != null) {
        // Landed on floor.
        world.transform.posY[ti] = bestTopY - offsetY - halfY;
        if (world.transform.velY[ti] > 0) {
          world.transform.velY[ti] = 0;
        }
        world.collision.grounded[coli] = true;
      } else if (bestBottomY != null) {
        // Hit ceiling.
        world.transform.posY[ti] = bestBottomY - offsetY + halfY;
        if (world.transform.velY[ti] < 0) {
          world.transform.velY[ti] = 0;
        }
        world.collision.hitCeiling[coli] = true;
      }

      // Horizontal Resolution
      // Recompute AABB after vertical resolution for stable side overlap tests.
      // This prevents "snagging" on walls due to slight vertical overlap that should have been resolved.
      final resolvedCenterX = world.transform.posX[ti] + offsetX;
      final resolvedCenterY = world.transform.posY[ti] + offsetY;
      final resolvedMinY = resolvedCenterY - halfY;
      final resolvedMaxY = resolvedCenterY + halfY;

      // Resolve against static walls.
      final sideMask = world.body.sideMask[bi];
      final velX = world.transform.velX[ti];

      if (velX > 0 && (sideMask &  BodyDef.sideRight) != 0) {
        // Moving Right.
        final prevRight = prevCenterX + halfX;
        final right = resolvedCenterX + halfX;
        double? bestWallX;

        _queryBuffer.clear();
        staticWorld.queryLeftWalls(prevRight - eps, right + eps, _queryBuffer);

        for (final solid in _queryBuffer) {
          // Filter by vertical overlap (y-axis).
          final overlapY =
              resolvedMaxY > solid.minY + eps && resolvedMinY < solid.maxY - eps;
          if (!overlapY) continue;

          final wallX = solid.minX;
          // Check if we crossed the wall line.
          final crossesWall = prevRight <= wallX + eps && right >= wallX - eps;
          if (!crossesWall) continue;

          if (bestWallX == null || wallX < bestWallX) {
            bestWallX = wallX;
          }
        }

        if (bestWallX != null) {
          // Hit right wall.
          world.transform.posX[ti] = bestWallX - offsetX - halfX;
          world.transform.velX[ti] = 0;
          world.collision.hitRight[coli] = true;
        }
      } else if (velX < 0 && (sideMask & BodyDef.sideLeft) != 0) {
        // Moving Left.
        final prevLeft = prevCenterX - halfX;
        final left = resolvedCenterX - halfX;
        double? bestWallX;

        _queryBuffer.clear();
        staticWorld.queryRightWalls(left - eps, prevLeft + eps, _queryBuffer);

        for (final solid in _queryBuffer) {
          // Filter by vertical overlap (y-axis).
          final overlapY =
              resolvedMaxY > solid.minY + eps && resolvedMinY < solid.maxY - eps;
          if (!overlapY) continue;

          final wallX = solid.maxX;
          // Check if we crossed the wall line from right to left.
          final crossesWall = prevLeft >= wallX - eps && left <= wallX + eps;
          if (!crossesWall) continue;

          // Keep the rightmost wall (maximum X) encountered.
          if (bestWallX == null || wallX > bestWallX) {
            bestWallX = wallX;
          }
        }

        if (bestWallX != null) {
          // Hit left wall.
          world.transform.posX[ti] = bestWallX - offsetX + halfX;
          world.transform.velX[ti] = 0;
          world.collision.hitLeft[coli] = true;
        }
      }
    });
  }
}


===== FILE: lib/core/ecs/systems/control_lock_system.dart =====
import '../world.dart';

/// Refreshes control lock masks and removes expired locks each tick.
///
/// This system should run **early** in the tick pipeline, before any
/// gameplay systems that check locks.
///
/// **Responsibilities**:
/// - Recompute [activeMask] for each entity based on current tick
/// - Remove entities from the store when all locks have expired
class ControlLockSystem {
  /// Steps the lock system, refreshing masks and cleaning up expired entries.
  void step(EcsWorld world, {required int currentTick}) {
    final store = world.controlLock;

    // Iterate backwards to safely remove while iterating
    for (int i = store.denseEntities.length - 1; i >= 0; i--) {
      final entity = store.denseEntities[i];

      // Refresh the active mask
      store.refreshMask(i, currentTick);

      // Remove entity from store if no locks are active
      if (store.activeMask[i] == 0) {
        store.removeEntity(entity);
      }
    }
  }
}


===== FILE: lib/core/ecs/systems/cooldown_system.dart =====
import '../world.dart';

/// Decrements active action cooldowns for all entities each tick.
class CooldownSystem {
  /// Runs the cooldown logic.
  ///
  /// Iterates over all entities with a [CooldownStore] and reduces their
  /// remaining tick counts by 1 for all cooldown groups, clamping at 0.
  void step(EcsWorld world) {
    world.cooldown.tickAll();
  }
}


===== FILE: lib/core/ecs/systems/damage_middleware_system.dart =====
import '../stores/damage_queue_store.dart';
import '../world.dart';

/// Applies combat rules to queued damage before it reaches [DamageSystem].
///
/// Middlewares can cancel, redirect, or modify queued damage requests.
/// This system never writes health directly.
class DamageMiddlewareSystem {
  DamageMiddlewareSystem({
    List<DamageMiddleware> middlewares = const <DamageMiddleware>[],
  }) : _middlewares = List<DamageMiddleware>.unmodifiable(middlewares);

  final List<DamageMiddleware> _middlewares;

  void step(EcsWorld world, {required int currentTick}) {
    if (_middlewares.isEmpty) return;

    final queue = world.damageQueue;
    final initialCount = queue.length;
    if (initialCount == 0) return;

    for (var i = 0; i < initialCount; i += 1) {
      if ((queue.flags[i] & DamageQueueFlags.canceled) != 0) continue;
      for (final middleware in _middlewares) {
        middleware.apply(world, queue, i, currentTick);
        if ((queue.flags[i] & DamageQueueFlags.canceled) != 0) {
          break;
        }
      }
    }
  }
}

/// Middleware hook for editing queued damage requests.
abstract class DamageMiddleware {
  void apply(EcsWorld world, DamageQueueStore queue, int index, int currentTick);
}


===== FILE: lib/core/ecs/systems/damage_system.dart =====
import '../../combat/status/status.dart';
import '../../util/deterministic_rng.dart';
import '../../util/fixed_math.dart';
import '../../weapons/weapon_proc.dart';
import '../stores/damage_queue_store.dart';
import '../world.dart';

/// Central system for validating and applying damage to entities.
///
/// Handles:
/// 1.  Processing queued [DamageRequest]s.
/// 2.  Checking invulnerability frames (i-frames).
/// 3.  Reducing [HealthStore] HP.
/// 4.  Recording [LastDamageStore] details (source, amount) for UI/logic.
/// 5.  Applying post-hit invulnerability.
class DamageSystem {
  DamageSystem({
    required this.invulnerabilityTicksOnHit,
    required int rngSeed,
  }) : _rngState = seedFrom(rngSeed, 0x44a3c2f1);

  /// Number of ticks an entity is invulnerable after taking damage.
  final int invulnerabilityTicksOnHit;

  int _rngState;
  
  /// Processes all pending damage requests.
  void step(
    EcsWorld world, {
    required int currentTick,
    void Function(StatusRequest request)? queueStatus,
  }) {
    final queue = world.damageQueue;
    if (queue.length == 0) return;

    final health = world.health;
    final invuln = world.invulnerability;
    final lastDamage = world.lastDamage;
    final resistance = world.damageResistance;
    
    for (var i = 0; i < queue.length; i += 1) {
      if ((queue.flags[i] & DamageQueueFlags.canceled) != 0) continue;

      final target = queue.target[i];
      final amount100 = queue.amount100[i];
      final damageType = queue.damageType[i];
      final procs = queue.procs[i];
      final sourceKind = queue.sourceKind[i];
      final sourceEnemyId = queue.sourceEnemyId[i];
      final sourceProjectileId = queue.sourceProjectileId[i];
      final sourceProjectileItemId = queue.sourceProjectileItemId[i];

      // 1. Resolve Health component.
      // Use tryIndexOf (returns int?) to combine "has check" and "get index"
      // into a single lookup for performance.
      final hi = health.tryIndexOf(target);
      if (hi == null) continue;

      // 2. Resolve Invulnerability component (optional).
      final ii = invuln.tryIndexOf(target);

      // Invulnerability applies only to entities that have `InvulnerabilityStore`
      // attached.
      if (ii != null && invuln.ticksLeft[ii] > 0) {
        continue; // Damage negated.
      }

      // 3. Apply resistance/vulnerability modifier.
      final ri = resistance.tryIndexOf(target);
      final modBp = ri == null ? 0 : resistance.modBpForIndex(ri, damageType);
      var appliedAmount = applyBp(amount100, modBp);
      if (appliedAmount < 0) appliedAmount = 0;

      final prevHp = health.hp[hi];
      final nextHp = clampInt(
        prevHp - appliedAmount,
        0,
        health.hpMax[hi],
      );
      health.hp[hi] = nextHp;

      // 4. Record Last Damage details (if store exists).
      // Only useful if damage was actually taken.
      if (nextHp < prevHp) {
        final li = lastDamage.tryIndexOf(target);
        if (li != null) {
          lastDamage.kind[li] = sourceKind;
          lastDamage.amount100[li] = appliedAmount;
          lastDamage.tick[li] = currentTick;

          if (sourceEnemyId != null) {
            lastDamage.enemyId[li] = sourceEnemyId;
            lastDamage.hasEnemyId[li] = true;
          } else {
            lastDamage.hasEnemyId[li] = false;
          }

          if (sourceProjectileId != null) {
            lastDamage.projectileId[li] = sourceProjectileId;
            lastDamage.hasProjectileId[li] = true;
          } else {
            lastDamage.hasProjectileId[li] = false;
          }

          if (sourceProjectileItemId != null) {
            lastDamage.projectileItemId[li] = sourceProjectileItemId;
            lastDamage.hasProjectileItemId[li] = true;
          } else {
            lastDamage.hasProjectileItemId[li] = false;
          }
        }
      }

      // 5. Queue status effects for non-zero damage requests.
      if (queueStatus != null && amount100 > 0 && procs.isNotEmpty) {
        for (final proc in procs) {
          if (proc.hook != ProcHook.onHit) continue;
          if (proc.statusProfileId == StatusProfileId.none) continue;
          final chance = proc.chanceBp;
          if (chance >= bpScale) {
            queueStatus(
              StatusRequest(
                target: target,
                profileId: proc.statusProfileId,
                damageType: damageType,
              ),
            );
            continue;
          }
          if (chance <= 0) continue;
          _rngState = nextUint32(_rngState);
          if ((_rngState % bpScale) < chance) {
            queueStatus(
              StatusRequest(
                target: target,
                profileId: proc.statusProfileId,
                damageType: damageType,
              ),
            );
          }
        }
      }

      // 6. Apply new Invulnerability frames.
      if (invulnerabilityTicksOnHit > 0 && ii != null) {
        invuln.ticksLeft[ii] = invulnerabilityTicksOnHit;
      }
    }
    queue.clear();
  }
}


===== FILE: lib/core/ecs/systems/death_despawn_system.dart =====
import '../../enemies/death_behavior.dart';
import '../entity_id.dart';
import '../world.dart';

/// Despawns entities when their death animation has completed.
class DeathDespawnSystem {
  final List<EntityId> _toDespawn = <EntityId>[];

  void step(EcsWorld world, {required int currentTick}) {
    final deathState = world.deathState;
    if (deathState.denseEntities.isEmpty) return;

    _toDespawn.clear();
    for (var i = 0; i < deathState.denseEntities.length; i += 1) {
      final e = deathState.denseEntities[i];
      if (deathState.phase[i] != DeathPhase.deathAnim) continue;

      final despawnTick = deathState.despawnTick[i];
      if (despawnTick >= 0 && currentTick >= despawnTick) {
        _toDespawn.add(e);
      }
    }

    for (final e in _toDespawn) {
      world.destroyEntity(e);
    }
  }
}



===== FILE: lib/core/ecs/systems/enemy_cast_system.dart =====
import 'dart:math';

import '../../abilities/ability_catalog.dart';
import '../../abilities/ability_def.dart';
import '../../combat/hit_payload_builder.dart';
import '../../enemies/enemy_catalog.dart';
import '../../projectiles/projectile_catalog.dart';
import '../../projectiles/projectile_item_catalog.dart';
import '../../projectiles/projectile_item_def.dart';
import '../../projectiles/projectile_item_id.dart';
import '../../snapshots/enums.dart';
import '../../tuning/flying_enemy_tuning.dart';
import '../../util/double_math.dart';
import '../entity_id.dart';
import '../stores/projectile_intent_store.dart';
import '../world.dart';

/// Handles enemy projectile strike decisions and writes projectile intents.
class EnemyCastSystem {
  EnemyCastSystem({
    required this.unocoDemonTuning,
    required this.enemyCatalog,
    required this.projectileItems,
    required this.projectiles,
  });

  final UnocoDemonTuningDerived unocoDemonTuning;
  final EnemyCatalog enemyCatalog;
  final ProjectileItemCatalog projectileItems;
  final ProjectileCatalogDerived projectiles;

  /// Evaluates casts for all enemies and writes projectile intents.
  void step(
    EcsWorld world, {
    required EntityId player,
    required int currentTick,
  }) {
    if (!world.transform.has(player)) return;

    final ability = AbilityCatalog.tryGet(_enemyAbilityId);
    if (ability == null) return;

    final playerTi = world.transform.indexOf(player);
    final playerX = world.transform.posX[playerTi];
    final playerY = world.transform.posY[playerTi];
    final playerVelX = world.transform.velX[playerTi];
    final playerVelY = world.transform.velY[playerTi];
    var playerCenterX = playerX;
    var playerCenterY = playerY;
    if (world.colliderAabb.has(player)) {
      final ai = world.colliderAabb.indexOf(player);
      playerCenterX += world.colliderAabb.offsetX[ai];
      playerCenterY += world.colliderAabb.offsetY[ai];
    }

    final enemies = world.enemy;
    for (var ei = 0; ei < enemies.denseEntities.length; ei += 1) {
      final enemy = enemies.denseEntities[ei];
      if (world.deathState.has(enemy)) continue;
      final ti = world.transform.tryIndexOf(enemy);
      if (ti == null) continue;

      if (!world.cooldown.has(enemy)) continue;
      if (world.controlLock.isStunned(enemy, currentTick)) continue;
      if (world.activeAbility.hasActiveAbility(enemy)) continue;

      if (!world.projectileIntent.has(enemy)) {
        assert(
          false,
          'EnemyCastSystem requires ProjectileIntentStore on enemies; add it at spawn time.',
        );
        continue;
      }

      final enemyId = enemies.enemyId[ei];
      final projectileItemId = enemyCatalog
          .get(enemyId)
          .primaryProjectileItemId;
      if (projectileItemId == null) continue;

      final projectileItem = projectileItems.get(projectileItemId);
      final projectileId = projectileItem.projectileId;
      final projectileSpeed = projectiles.base
          .get(projectileId)
          .speedUnitsPerSecond;

      var enemyCenterX = world.transform.posX[ti];
      var enemyCenterY = world.transform.posY[ti];
      if (world.colliderAabb.has(enemy)) {
        final ai = world.colliderAabb.indexOf(enemy);
        enemyCenterX += world.colliderAabb.offsetX[ai];
        enemyCenterY += world.colliderAabb.offsetY[ai];
      }

      _writeProjectileIntent(
        world,
        ability: ability,
        projectileItemId: projectileItemId,
        projectileItem: projectileItem,
        enemyIndex: ei,
        enemyCenterX: enemyCenterX,
        enemyCenterY: enemyCenterY,
        playerCenterX: playerCenterX,
        playerCenterY: playerCenterY,
        playerVelX: playerVelX,
        playerVelY: playerVelY,
        projectileSpeed: projectileSpeed,
        currentTick: currentTick,
      );
    }
  }

  void _writeProjectileIntent(
    EcsWorld world, {
    required AbilityDef ability,
    required int enemyIndex,
    required double enemyCenterX,
    required double enemyCenterY,
    required double playerCenterX,
    required double playerCenterY,
    required double playerVelX,
    required double playerVelY,
    required double projectileSpeed,
    required int currentTick,
    required ProjectileItemId projectileItemId,
    required ProjectileItemDef projectileItem,
  }) {
    final tuning = unocoDemonTuning;

    var targetX = playerCenterX;
    var targetY = playerCenterY;
    if (projectileSpeed > 0.0) {
      final dx = playerCenterX - enemyCenterX;
      final dy = playerCenterY - enemyCenterY;
      final distance = sqrt(dx * dx + dy * dy);
      final leadSeconds = clampDouble(
        distance / projectileSpeed,
        tuning.base.unocoDemonAimLeadMinSeconds,
        tuning.base.unocoDemonAimLeadMaxSeconds,
      );
      targetX = playerCenterX + playerVelX * leadSeconds;
      targetY = playerCenterY + playerVelY * leadSeconds;
    }

    final castDirX = targetX - enemyCenterX;
    if (castDirX.abs() > 1e-6) {
      world.enemy.facing[enemyIndex] = castDirX >= 0
          ? Facing.right
          : Facing.left;
    }

    final enemy = world.enemy.denseEntities[enemyIndex];
    final payload = HitPayloadBuilder.build(
      ability: ability,
      source: enemy,
      weaponStats: projectileItem.stats,
      weaponDamageType: projectileItem.damageType,
      weaponProcs: projectileItem.procs,
    );

    final windupTicks = _scaleAbilityTicks(ability.windupTicks);
    final activeTicks = _scaleAbilityTicks(ability.activeTicks);
    final recoveryTicks = _scaleAbilityTicks(ability.recoveryTicks);
    final commitTick = currentTick;
    final executeTick = commitTick + windupTicks;

    world.projectileIntent.set(
      enemy,
      ProjectileIntentDef(
        projectileItemId: projectileItemId,
        abilityId: ability.id,
        slot: AbilitySlot.projectile,
        damage100: payload.damage100,
        staminaCost100: ability.staminaCost,
        manaCost100: ability.manaCost,
        cooldownTicks: tuning.unocoDemonCastCooldownTicks,
        projectileId: projectileItem.projectileId,
        damageType: payload.damageType,
        procs: payload.procs,
        ballistic: projectileItem.ballistic,
        gravityScale: projectileItem.gravityScale,
        dirX: targetX - enemyCenterX,
        dirY: targetY - enemyCenterY,
        fallbackDirX: 1.0,
        fallbackDirY: 0.0,
        originOffset: tuning.base.unocoDemonCastOriginOffset,
        commitTick: commitTick,
        windupTicks: windupTicks,
        activeTicks: activeTicks,
        recoveryTicks: recoveryTicks,
        cooldownGroupId: CooldownGroup.projectile,
        tick: executeTick,
      ),
    );
  }

  int _scaleAbilityTicks(int ticks) {
    if (ticks <= 0) return 0;
    if (unocoDemonTuning.tickHz <= 0) return ticks;
    final seconds = ticks / _abilityTickHz;
    return (seconds * unocoDemonTuning.tickHz).ceil();
  }

  static const int _abilityTickHz = 60;
  static const AbilityKey _enemyAbilityId = 'common.enemy_cast';
}


===== FILE: lib/core/ecs/systems/enemy_cull_system.dart =====
import '../../tuning/track_tuning.dart';
import '../entity_id.dart';
import '../world.dart';

/// Despawns enemies that are behind the camera or below the ground.
///
/// Rules:
/// - Behind: enemy maxX < cameraLeft - tuning.cullBehindMargin
/// - Below:  enemy bottomY > groundTopY + tuning.enemyCullBelowGroundOffsetY
class EnemyCullSystem {
  final List<EntityId> _toDespawn = <EntityId>[];

  void step(
    EcsWorld world, {
    required double cameraLeft,
    required double groundTopY,
    required TrackTuning tuning,
  }) {
    final enemies = world.enemy;
    if (enemies.denseEntities.isEmpty) return;

    _toDespawn.clear();

    final despawnX = cameraLeft - tuning.cullBehindMargin;
    final despawnY = groundTopY + tuning.enemyCullBelowGroundOffsetY;

    // 1. identify enemies to despawn
    for (var i = 0; i < enemies.denseEntities.length; i += 1) {
      final e = enemies.denseEntities[i];

      final ti = world.transform.tryIndexOf(e);
      if (ti == null) {
        // Orphan enemy, kill it.
        _toDespawn.add(e);
        continue;
      }

      // Compute bounds using ColliderAabb when present.
      var cx = world.transform.posX[ti];
      var cy = world.transform.posY[ti];
      var maxX = cx;
      var bottomY = cy;

      final ci = world.colliderAabb.tryIndexOf(e);
      if (ci != null) {
        cx += world.colliderAabb.offsetX[ci];
        cy += world.colliderAabb.offsetY[ci];
        maxX = cx + world.colliderAabb.halfX[ci];
        bottomY = cy + world.colliderAabb.halfY[ci];
      }

      if (maxX < despawnX || bottomY > despawnY) {
        _toDespawn.add(e);
      }
    }

    if (_toDespawn.isEmpty) return;

    // 2. destroy
    for (final e in _toDespawn) {
      world.destroyEntity(e);
    }
  }
}


===== FILE: lib/core/ecs/systems/enemy_death_state_system.dart =====
import '../../enemies/death_behavior.dart';
import '../../enemies/enemy_catalog.dart';
import '../../enemies/enemy_id.dart';
import '../../util/tick_math.dart';
import '../stores/death_state_store.dart';
import '../world.dart';

/// Tracks enemy death phases and schedules despawn timing.
class EnemyDeathStateSystem {
  EnemyDeathStateSystem({
    required int tickHz,
    EnemyCatalog enemyCatalog = const EnemyCatalog(),
    double maxFallSeconds = 3.0,
  }) : _enemyCatalog = enemyCatalog,
       _maxFallTicks = ticksFromSecondsCeil(maxFallSeconds, tickHz) {
    _buildDeathAnimTicksById(tickHz);
  }

  final EnemyCatalog _enemyCatalog;
  final int _maxFallTicks;

  late final Map<EnemyId, int> _deathAnimTicksById;

  void _buildDeathAnimTicksById(int tickHz) {
    _deathAnimTicksById = <EnemyId, int>{};
    for (final id in EnemyId.values) {
      final seconds = _enemyCatalog.get(id).deathAnimSeconds;
      _deathAnimTicksById[id] = ticksFromSecondsCeil(seconds, tickHz);
    }
  }

  void step(
    EcsWorld world, {
    required int currentTick,
    List<EnemyId>? outEnemiesKilled,
  }) {
    final enemies = world.enemy;
    if (enemies.denseEntities.isEmpty) return;

    final health = world.health;
    final collision = world.collision;
    final deathState = world.deathState;
    final transform = world.transform;

    for (var ei = 0; ei < enemies.denseEntities.length; ei += 1) {
      final e = enemies.denseEntities[ei];
      final di = deathState.tryIndexOf(e);
      if (di != null) {
        final phase = deathState.phase[di];
        if (phase != DeathPhase.fallingUntilGround) continue;

        final grounded = collision.has(e) &&
            collision.grounded[collision.indexOf(e)];
        final maxFallTick = deathState.maxFallDespawnTick[di];
        final shouldStartDeathAnim =
            grounded || (maxFallTick >= 0 && currentTick >= maxFallTick);

        if (!shouldStartDeathAnim) continue;

        final deathTicks = _deathAnimTicksById[enemies.enemyId[ei]] ?? 0;
        deathState.phase[di] = DeathPhase.deathAnim;
        deathState.deathStartTick[di] = currentTick;
        deathState.despawnTick[di] = currentTick + deathTicks;

        final ti = transform.tryIndexOf(e);
        if (ti != null) {
          transform.velX[ti] = 0.0;
          transform.velY[ti] = 0.0;
        }
        continue;
      }

      final hi = health.tryIndexOf(e);
      if (hi == null) continue;
      if (health.hp[hi] > 0) continue;

      final archetype = _enemyCatalog.get(enemies.enemyId[ei]);
      final deathTicks = _deathAnimTicksById[enemies.enemyId[ei]] ?? 0;

      if (outEnemiesKilled != null) {
        outEnemiesKilled.add(enemies.enemyId[ei]);
      }

      final grounded = collision.has(e) &&
          collision.grounded[collision.indexOf(e)];

      if (archetype.deathBehavior == DeathBehavior.groundImpactThenDeath &&
          !grounded) {
        deathState.add(
          e,
          DeathStateDef(
            phase: DeathPhase.fallingUntilGround,
            deathStartTick: -1,
            despawnTick: -1,
            maxFallDespawnTick: currentTick + _maxFallTicks,
          ),
        );
        continue;
      }

      deathState.add(
        e,
        DeathStateDef(
          phase: DeathPhase.deathAnim,
          deathStartTick: currentTick,
          despawnTick: currentTick + deathTicks,
        ),
      );

      final ti = transform.tryIndexOf(e);
      if (ti != null) {
        transform.velX[ti] = 0.0;
        transform.velY[ti] = 0.0;
      }
    }
  }
}


===== FILE: lib/core/ecs/systems/enemy_engagement_system.dart =====
import 'dart:math';

import '../../abilities/ability_def.dart';

import 'package:rpg_runner/core/ecs/entity_id.dart';

import '../../enemies/enemy_id.dart';
import '../../tuning/ground_enemy_tuning.dart';
import '../../util/deterministic_rng.dart';
import '../../util/double_math.dart';
import '../stores/enemies/melee_engagement_store.dart';
import '../world.dart';

/// Resolves melee engagement state and desired slots for ground enemies.
class EnemyEngagementSystem {
  EnemyEngagementSystem({required this.groundEnemyTuning});

  final GroundEnemyTuningDerived groundEnemyTuning;

  /// Updates engagement intents for ground enemies.
  void step(
    EcsWorld world, {
    required EntityId player,
    required int currentTick,
  }) {
    if (!world.transform.has(player)) return;

    final playerTi = world.transform.indexOf(player);
    final playerX = world.transform.posX[playerTi];

    final enemies = world.enemy;
    for (var ei = 0; ei < enemies.denseEntities.length; ei += 1) {
      if (enemies.enemyId[ei] != EnemyId.grojib) continue;

      final enemy = enemies.denseEntities[ei];
      if (world.deathState.has(enemy)) continue;
      final ti = world.transform.tryIndexOf(enemy);
      if (ti == null) continue;

      if (world.controlLock.isStunned(enemy, currentTick)) continue;

      final meleeIndex = world.meleeEngagement.tryIndexOf(enemy);
      if (meleeIndex == null) {
        assert(
          false,
          'EnemyEngagementSystem requires MeleeEngagementStore on melee enemies; add it at spawn time.',
        );
        continue;
      }

      final chaseIndex = world.groundEnemyChaseOffset.tryIndexOf(enemy);
      if (chaseIndex == null) continue;

      final navIntentIndex = world.navIntent.tryIndexOf(enemy);
      if (navIntentIndex == null) {
        assert(
          false,
          'EnemyEngagementSystem requires NavIntentStore on ground enemies; add it at spawn time.',
        );
        continue;
      }

      final engagementIndex = world.engagementIntent.tryIndexOf(enemy);
      if (engagementIndex == null) {
        assert(
          false,
          'EnemyEngagementSystem requires EngagementIntentStore on melee enemies; add it at spawn time.',
        );
        continue;
      }

      _ensureChaseOffsetInitialized(world, chaseIndex, enemy);

      final chaseOffset = world.groundEnemyChaseOffset;
      final chaseOffsetX = chaseOffset.chaseOffsetX[chaseIndex];
      final chaseSpeedScale = chaseOffset.chaseSpeedScale[chaseIndex];

      final navTargetX = world.navIntent.navTargetX[navIntentIndex];

      var state = world.meleeEngagement.state[meleeIndex];
      var ticksLeft = world.meleeEngagement.ticksLeft[meleeIndex];
      var preferredSide = world.meleeEngagement.preferredSide[meleeIndex];
      var strikeStartTick = world.meleeEngagement.strikeStartTick[meleeIndex];
      var plannedHitTick = world.meleeEngagement.plannedHitTick[meleeIndex];
      if (ticksLeft > 0) {
        ticksLeft -= 1;
      }

      final ex = world.transform.posX[ti];
      final dxToPlayer = playerX - ex;
      final distToPlayerX = dxToPlayer.abs();
      final sideNow = dxToPlayer >= 0 ? -1 : 1;
      final collapseDistX =
          groundEnemyTuning.combat.meleeRangeX +
          groundEnemyTuning.locomotion.stopDistanceX;

      final meleeOffsetMaxX = groundEnemyTuning.navigation.chaseOffsetMeleeX
          .abs();
      final meleeOffsetAbs = min(meleeOffsetMaxX, chaseOffsetX.abs());
      final meleeOffsetX = meleeOffsetAbs == 0.0
          ? 0.0
          : (chaseOffsetX >= 0.0 ? meleeOffsetAbs : -meleeOffsetAbs);

      if (preferredSide == 0 || sideNow != preferredSide) {
        preferredSide = sideNow;
      }

      final engageEnterDist =
          groundEnemyTuning.combat.meleeRangeX +
          groundEnemyTuning.locomotion.stopDistanceX +
          groundEnemyTuning.engagement.meleeEngageBufferX;
      final engageExitDist =
          engageEnterDist + groundEnemyTuning.engagement.meleeEngageHysteresisX;

      switch (state) {
        case MeleeEngagementState.approach:
          if (distToPlayerX <= engageEnterDist) {
            state = MeleeEngagementState.engage;
            ticksLeft = 0;
            strikeStartTick = -1;
            plannedHitTick = -1;
          }
          break;
        case MeleeEngagementState.engage:
          if (distToPlayerX > engageExitDist) {
            state = MeleeEngagementState.approach;
            ticksLeft = 0;
            strikeStartTick = -1;
            plannedHitTick = -1;
          } else {
            // Cooldown-gated transition into strike.
            final ci = world.cooldown.tryIndexOf(enemy);
            if (ci != null) {
              final cooldownReady = !world.cooldown.isOnCooldown(
                enemy,
                CooldownGroup.primary,
              );
              final inMeleeRange =
                  distToPlayerX <= groundEnemyTuning.combat.meleeRangeX;
              if (cooldownReady && inMeleeRange) {
                state = MeleeEngagementState.strike;
                ticksLeft = groundEnemyTuning.combat.meleeAnimTicks;
                strikeStartTick = currentTick;
                plannedHitTick =
                    currentTick + groundEnemyTuning.combat.meleeWindupTicks;
              }
            }
          }
          break;
        case MeleeEngagementState.strike:
          if (ticksLeft <= 0) {
            state = MeleeEngagementState.recover;
            ticksLeft = groundEnemyTuning.combat.meleeAnimTicks;
            strikeStartTick = -1;
            plannedHitTick = -1;
          }
          break;
        case MeleeEngagementState.recover:
          if (ticksLeft <= 0) {
            state = MeleeEngagementState.engage;
            strikeStartTick = -1;
            plannedHitTick = -1;
          }
          break;
      }

      final engageTargetX =
          navTargetX +
          preferredSide * groundEnemyTuning.engagement.meleeStandOffX;

      double desiredTargetX;
      var stateSpeedMul = 1.0;
      var arrivalSlowRadiusX = 0.0;
      var speedScale = 1.0;

      if (state == MeleeEngagementState.approach) {
        desiredTargetX = distToPlayerX <= collapseDistX
            ? navTargetX + meleeOffsetX
            : navTargetX + chaseOffsetX;
        speedScale = chaseSpeedScale;
      } else {
        desiredTargetX = engageTargetX;
        arrivalSlowRadiusX =
            groundEnemyTuning.engagement.meleeArriveSlowRadiusX;
        if (state == MeleeEngagementState.strike) {
          stateSpeedMul = groundEnemyTuning.engagement.meleeStrikeSpeedMul;
        } else if (state == MeleeEngagementState.recover) {
          stateSpeedMul = groundEnemyTuning.engagement.meleeRecoverSpeedMul;
        }
      }

      final engagementIntent = world.engagementIntent;
      engagementIntent.desiredTargetX[engagementIndex] = desiredTargetX;
      engagementIntent.arrivalSlowRadiusX[engagementIndex] = arrivalSlowRadiusX;
      engagementIntent.stateSpeedMul[engagementIndex] = stateSpeedMul;
      engagementIntent.speedScale[engagementIndex] = speedScale;

      world.meleeEngagement.state[meleeIndex] = state;
      world.meleeEngagement.ticksLeft[meleeIndex] = max(0, ticksLeft);
      world.meleeEngagement.preferredSide[meleeIndex] = preferredSide;
      world.meleeEngagement.strikeStartTick[meleeIndex] = strikeStartTick;
      world.meleeEngagement.plannedHitTick[meleeIndex] = plannedHitTick;
    }
  }

  void _ensureChaseOffsetInitialized(
    EcsWorld world,
    int chaseIndex,
    EntityId enemy,
  ) {
    final chaseOffset = world.groundEnemyChaseOffset;
    if (chaseOffset.initialized[chaseIndex]) return;

    final tuning = groundEnemyTuning;
    var rngState = chaseOffset.rngState[chaseIndex];
    if (rngState == 0) {
      rngState = enemy;
    }

    final maxAbs = tuning.navigation.chaseOffsetMaxX.abs();
    var offsetX = 0.0;
    if (maxAbs > 0.0) {
      rngState = nextUint32(rngState);
      offsetX = rangeDouble(rngState, -maxAbs, maxAbs);
      final minAbs = clampDouble(
        tuning.navigation.chaseOffsetMinAbsX,
        0.0,
        maxAbs,
      );
      final absOffset = offsetX.abs();
      if (absOffset < minAbs) {
        offsetX = offsetX >= 0.0 ? minAbs : -minAbs;
        if (absOffset == 0.0) {
          offsetX = minAbs;
        }
      }
    }

    rngState = nextUint32(rngState);
    final speedScale = rangeDouble(
      rngState,
      tuning.navigation.chaseSpeedScaleMin,
      tuning.navigation.chaseSpeedScaleMax,
    );
    chaseOffset.initialized[chaseIndex] = true;
    chaseOffset.chaseOffsetX[chaseIndex] = offsetX;
    chaseOffset.chaseSpeedScale[chaseIndex] = speedScale;
    chaseOffset.rngState[chaseIndex] = rngState;
  }
}


===== FILE: lib/core/ecs/systems/enemy_melee_system.dart =====
import 'package:rpg_runner/core/ecs/entity_id.dart';

import '../../abilities/ability_def.dart';
import '../../combat/damage_type.dart';
import '../../snapshots/enums.dart';
import '../../tuning/ground_enemy_tuning.dart';
import '../../util/fixed_math.dart';
import '../stores/enemies/melee_engagement_store.dart';
import '../stores/melee_intent_store.dart';
import '../world.dart';

/// Handles enemy melee strike decisions and writes melee intents.
class EnemyMeleeSystem {
  EnemyMeleeSystem({required this.groundEnemyTuning});

  final GroundEnemyTuningDerived groundEnemyTuning;

  /// Evaluates melee strikes for all enemies and writes melee intents.
  void step(
    EcsWorld world, {
    required EntityId player,
    required int currentTick,
  }) {
    if (!world.transform.has(player)) return;

    final playerTi = world.transform.indexOf(player);
    final playerX = world.transform.posX[playerTi];

    final meleeEngagement = world.meleeEngagement;
    for (var i = 0; i < meleeEngagement.denseEntities.length; i += 1) {
      final enemy = meleeEngagement.denseEntities[i];
      if (world.deathState.has(enemy)) continue;
      final enemyIndex = world.enemy.tryIndexOf(enemy);
      if (enemyIndex == null) {
        assert(
          false,
          'EnemyMeleeSystem requires EnemyStore on melee enemies; add it at spawn time.',
        );
        continue;
      }

      if (!world.cooldown.has(enemy)) continue;

      final ti = world.transform.tryIndexOf(enemy);
      if (ti == null) continue;

      if (world.controlLock.isStunned(enemy, currentTick)) continue;
      if (world.activeAbility.hasActiveAbility(enemy)) continue;

      // Only write an intent on the first tick we enter the strike state.
      if (meleeEngagement.state[i] != MeleeEngagementState.strike) continue;
      if (meleeEngagement.strikeStartTick[i] != currentTick) continue;
      final plannedHitTick = meleeEngagement.plannedHitTick[i];
      if (plannedHitTick < 0) continue;

      if (!world.meleeIntent.has(enemy)) {
        assert(
          false,
          'EnemyMeleeSystem requires MeleeIntentStore on enemies; add it at spawn time.',
        );
        continue;
      }
      if (!world.colliderAabb.has(enemy)) {
        assert(
          false,
          'Enemy melee requires ColliderAabbStore on the enemy to compute hitbox offset.',
        );
        continue;
      }

      final ex = world.transform.posX[ti];
      final tuning = groundEnemyTuning;

      final facing = playerX >= ex ? Facing.right : Facing.left;
      world.enemy.facing[enemyIndex] = facing;
      final dirX = facing == Facing.right ? 1.0 : -1.0;

      final halfX = tuning.combat.meleeHitboxSizeX * 0.5;
      final halfY = tuning.combat.meleeHitboxSizeY * 0.5;

      final ownerHalfX =
          world.colliderAabb.halfX[world.colliderAabb.indexOf(enemy)];
      final offsetX = dirX * (ownerHalfX * 0.5 + halfX);
      const offsetY = 0.0;

      final commitTick = meleeEngagement.strikeStartTick[i];
      final windupTicks = plannedHitTick > commitTick
          ? plannedHitTick - commitTick
          : tuning.combat.meleeWindupTicks;
      final recoveryTicks =
          tuning.combat.meleeAnimTicks -
          windupTicks -
          tuning.combat.meleeActiveTicks;
      final clampedRecovery = recoveryTicks < 0 ? 0 : recoveryTicks;

      world.meleeIntent.set(
        enemy,
        MeleeIntentDef(
          abilityId: 'common.enemy_strike',
          slot: AbilitySlot.primary,
          damage100: toFixed100(tuning.combat.meleeDamage),
          damageType: DamageType.physical,
          halfX: halfX,
          halfY: halfY,
          offsetX: offsetX,
          offsetY: offsetY,
          dirX: dirX,
          dirY: 0.0,
          commitTick: commitTick,
          windupTicks: windupTicks,
          activeTicks: tuning.combat.meleeActiveTicks,
          recoveryTicks: clampedRecovery,
          cooldownTicks: tuning.combat.meleeCooldownTicks,
          staminaCost100: 0,
          cooldownGroupId: CooldownGroup.primary,
          tick: plannedHitTick,
        ),
      );

      // Commit side effects (Cooldown + ActiveAbility) must be applied manually
      // since enemies don't use AbilityActivationSystem.
      world.cooldown.startCooldown(
        enemy,
        CooldownGroup.primary,
        tuning.combat.meleeCooldownTicks,
      );

      world.activeAbility.set(
        enemy,
        id: 'common.enemy_strike',
        slot: AbilitySlot.primary,
        commitTick: commitTick,
        windupTicks: windupTicks,
        activeTicks: tuning.combat.meleeActiveTicks,
        recoveryTicks: clampedRecovery,
        facingDir: facing,
      );

      world.enemy.lastMeleeTick[enemyIndex] = currentTick;
      world.enemy.lastMeleeFacing[enemyIndex] = facing;
      world.enemy.lastMeleeAnimTicks[enemyIndex] = tuning.combat.meleeAnimTicks;
    }
  }
}


===== FILE: lib/core/ecs/systems/enemy_navigation_system.dart =====
import 'package:rpg_runner/core/ecs/entity_id.dart';

import '../../enemies/enemy_id.dart';
import '../../navigation/surface_navigator.dart';
import '../../navigation/types/surface_graph.dart';
import '../../navigation/types/surface_id.dart';
import '../../navigation/utils/surface_spatial_index.dart';
import '../../navigation/utils/trajectory_predictor.dart';
import '../world.dart';

/// Builds navigation intents for ground enemies using the surface graph.
class EnemyNavigationSystem {
  EnemyNavigationSystem({
    required this.surfaceNavigator,
    this.trajectoryPredictor,
    int chaseTargetDelayTicks = 0,
  }) : _chaseTargetDelayTicks = chaseTargetDelayTicks < 0
           ? 0
           : chaseTargetDelayTicks {
    final len = _chaseTargetDelayTicks <= 0 ? 1 : _chaseTargetDelayTicks + 1;
    _targetHistoryX = List<double>.filled(len, 0.0);
    _targetHistoryBottomY = List<double>.filled(len, 0.0);
    _targetHistoryGrounded = List<bool>.filled(len, true);
  }

  final SurfaceNavigator surfaceNavigator;
  final TrajectoryPredictor? trajectoryPredictor;

  final int _chaseTargetDelayTicks;

  SurfaceGraph? _surfaceGraph;
  SurfaceSpatialIndex? _surfaceIndex;
  int _surfaceGraphVersion = 0;

  late final List<double> _targetHistoryX;
  late final List<double> _targetHistoryBottomY;
  late final List<bool> _targetHistoryGrounded;
  int _targetHistoryCursor = 0;
  bool _targetHistoryPrimed = false;

  /// Updates the navigation graph used by ground enemies.
  void setSurfaceGraph({
    required SurfaceGraph graph,
    required SurfaceSpatialIndex spatialIndex,
    required int graphVersion,
  }) {
    _surfaceGraph = graph;
    _surfaceIndex = spatialIndex;
    _surfaceGraphVersion = graphVersion;
  }

  /// Computes navigation intents for all ground enemies.
  void step(
    EcsWorld world, {
    required EntityId player,
    required int currentTick,
  }) {
    if (!world.transform.has(player)) return;

    final playerTi = world.transform.indexOf(player);
    final playerX = world.transform.posX[playerTi];
    final playerY = world.transform.posY[playerTi];
    final playerVelX = world.transform.velX[playerTi];
    final playerVelY = world.transform.velY[playerTi];

    final playerGrounded = world.collision.has(player)
        ? world.collision.grounded[world.collision.indexOf(player)]
        : false;

    var playerHalfX = 0.0;
    var playerBottomY = playerY;
    if (world.colliderAabb.has(player)) {
      final ai = world.colliderAabb.indexOf(player);
      playerHalfX = world.colliderAabb.halfX[ai];
      final offsetY = world.colliderAabb.offsetY[ai];
      playerBottomY = playerY + offsetY + world.colliderAabb.halfY[ai];
    }

    final graph = _surfaceGraph;
    final spatialIndex = _surfaceIndex;

    var rawTargetX = playerX;
    var rawTargetBottomY = playerBottomY;
    var rawTargetGrounded = playerGrounded;

    if (!playerGrounded &&
        trajectoryPredictor != null &&
        graph != null &&
        spatialIndex != null) {
      final prediction = trajectoryPredictor!.predictLanding(
        startX: playerX,
        startBottomY: playerBottomY,
        velX: playerVelX,
        velY: playerVelY,
        graph: graph,
        spatialIndex: spatialIndex,
        entityHalfWidth: playerHalfX,
      );

      if (prediction != null) {
        rawTargetX = prediction.x;
        rawTargetBottomY = prediction.bottomY;
        rawTargetGrounded = true;
      }
    }

    double navTargetX;
    double navTargetBottomY;
    bool navTargetGrounded;

    if (_chaseTargetDelayTicks <= 0) {
      navTargetX = rawTargetX;
      navTargetBottomY = rawTargetBottomY;
      navTargetGrounded = rawTargetGrounded;
    } else {
      final len = _targetHistoryX.length;
      if (!_targetHistoryPrimed) {
        for (var i = 0; i < len; i += 1) {
          _targetHistoryX[i] = rawTargetX;
          _targetHistoryBottomY[i] = rawTargetBottomY;
          _targetHistoryGrounded[i] = rawTargetGrounded;
        }
        _targetHistoryCursor = 0;
        _targetHistoryPrimed = true;
      } else {
        _targetHistoryCursor += 1;
        if (_targetHistoryCursor >= len) _targetHistoryCursor = 0;
        _targetHistoryX[_targetHistoryCursor] = rawTargetX;
        _targetHistoryBottomY[_targetHistoryCursor] = rawTargetBottomY;
        _targetHistoryGrounded[_targetHistoryCursor] = rawTargetGrounded;
      }

      var delayedIndex = _targetHistoryCursor - _chaseTargetDelayTicks;
      if (delayedIndex < 0) delayedIndex += len;
      navTargetX = _targetHistoryX[delayedIndex];
      navTargetBottomY = _targetHistoryBottomY[delayedIndex];
      navTargetGrounded = _targetHistoryGrounded[delayedIndex];
    }

    final enemies = world.enemy;
    for (var ei = 0; ei < enemies.denseEntities.length; ei += 1) {
      if (enemies.enemyId[ei] != EnemyId.grojib) continue;

      final enemy = enemies.denseEntities[ei];
      if (world.deathState.has(enemy)) continue;
      final ti = world.transform.tryIndexOf(enemy);
      if (ti == null) continue;

      if (world.controlLock.isStunned(enemy, currentTick)) continue;

      if (world.controlLock.isStunned(enemy, 0))
        continue; // Tick is roughly irrelevant for isLocked check here as it's just checking duration, but ideally we pass tick. Wait, isLocked needs tick.
      // I need to start passing tick to EnemyNavigationSystem to be correct.
      // However, for now, let's assume if I don't pass tick, I can't check expiry correctly unless I use the store's knowledge.
      // Actually isLocked REQUIRES currentTick.
      // I will update the step signature to include currentTick.

      final navIndex = world.surfaceNav.tryIndexOf(enemy);
      if (navIndex == null) continue;

      final intentIndex = world.navIntent.tryIndexOf(enemy);
      if (intentIndex == null) {
        assert(
          false,
          'EnemyNavigationSystem requires NavIntentStore on ground enemies; add it at spawn time.',
        );
        continue;
      }

      world.navIntent.navTargetX[intentIndex] = navTargetX;

      SurfaceNavIntent intent;
      var hasSafeSurface = false;
      var safeSurfaceMinX = 0.0;
      var safeSurfaceMaxX = 0.0;

      if (graph == null ||
          spatialIndex == null ||
          !world.colliderAabb.has(enemy)) {
        intent = SurfaceNavIntent(
          desiredX: navTargetX,
          jumpNow: false,
          hasPlan: false,
        );
      } else {
        final ai = world.colliderAabb.indexOf(enemy);
        final enemyHalfX = world.colliderAabb.halfX[ai];
        final enemyHalfY = world.colliderAabb.halfY[ai];
        final offsetY = world.colliderAabb.offsetY[ai];
        final ex = world.transform.posX[ti];
        final enemyBottomY = world.transform.posY[ti] + offsetY + enemyHalfY;
        final grounded =
            world.collision.has(enemy) &&
            world.collision.grounded[world.collision.indexOf(enemy)];

        intent = surfaceNavigator.update(
          navStore: world.surfaceNav,
          navIndex: navIndex,
          graph: graph,
          spatialIndex: spatialIndex,
          graphVersion: _surfaceGraphVersion,
          entityX: ex,
          entityBottomY: enemyBottomY,
          entityHalfWidth: enemyHalfX,
          entityGrounded: grounded,
          targetX: navTargetX,
          targetBottomY: navTargetBottomY,
          targetHalfWidth: playerHalfX,
          targetGrounded: navTargetGrounded,
        );

        if (!intent.hasPlan) {
          final currentSurfaceId = world.surfaceNav.currentSurfaceId[navIndex];
          if (currentSurfaceId != surfaceIdUnknown) {
            final currentIndex = graph.indexOfSurfaceId(currentSurfaceId);
            if (currentIndex != null) {
              final surface = graph.surfaces[currentIndex];
              final minX = surface.xMin + enemyHalfX;
              final maxX = surface.xMax - enemyHalfX;
              if (minX <= maxX) {
                hasSafeSurface = true;
                safeSurfaceMinX = minX;
                safeSurfaceMaxX = maxX;
              }
            }
          }
        }
      }

      final navIntent = world.navIntent;
      navIntent.desiredX[intentIndex] = intent.desiredX;
      navIntent.jumpNow[intentIndex] = intent.jumpNow;
      navIntent.hasPlan[intentIndex] = intent.hasPlan;
      navIntent.commitMoveDirX[intentIndex] = intent.commitMoveDirX;
      navIntent.hasSafeSurface[intentIndex] = hasSafeSurface;
      navIntent.safeSurfaceMinX[intentIndex] = safeSurfaceMinX;
      navIntent.safeSurfaceMaxX[intentIndex] = safeSurfaceMaxX;
    }
  }
}


===== FILE: lib/core/ecs/systems/flying_enemy_locomotion_system.dart =====
import 'package:rpg_runner/core/ecs/entity_id.dart';

import '../../snapshots/enums.dart';
import '../../tuning/flying_enemy_tuning.dart';
import '../../util/deterministic_rng.dart';
import '../../util/double_math.dart';
import '../../util/velocity_math.dart';
import '../world.dart';

/// Applies movement for flying enemies based on steering behaviors.
class FlyingEnemyLocomotionSystem {
  FlyingEnemyLocomotionSystem({required this.unocoDemonTuning});

  final UnocoDemonTuningDerived unocoDemonTuning;

  /// Applies locomotion for all flying enemies.
  void step(
    EcsWorld world, {
    required EntityId player,
    required double groundTopY,
    required double dtSeconds,
    required int currentTick,
  }) {
    if (dtSeconds <= 0.0) return;
    if (!world.transform.has(player)) return;

    final playerTi = world.transform.indexOf(player);
    final playerX = world.transform.posX[playerTi];
    final playerY = world.transform.posY[playerTi];

    final steering = world.flyingEnemySteering;
    for (var i = 0; i < steering.denseEntities.length; i += 1) {
      final enemy = steering.denseEntities[i];
      if (world.deathState.has(enemy)) continue;
      final enemyTi = world.transform.tryIndexOf(enemy);
      if (enemyTi == null) continue;

      if (world.controlLock.isStunned(enemy, currentTick)) {
        // Option B: Freeze in place
        world.transform.velX[enemyTi] = 0.0;
        world.transform.velY[enemyTi] = 0.0;
        continue;
      }

      final enemyIndex = world.enemy.tryIndexOf(enemy);
      if (enemyIndex == null) {
        assert(
          false,
          'FlyingEnemyLocomotionSystem requires EnemyStore on flying enemies; add it at spawn time.',
        );
        continue;
      }

      final ex = world.transform.posX[enemyTi];
      final ey = world.transform.posY[enemyTi];
      _steerFlyingEnemy(
        world,
        enemyIndex: enemyIndex,
        enemy: enemy,
        enemyTi: enemyTi,
        steeringIndex: i,
        playerX: playerX,
        playerY: playerY,
        ex: ex,
        ey: ey,
        groundTopY: groundTopY,
        dtSeconds: dtSeconds,
      );
    }
  }

  void _steerFlyingEnemy(
    EcsWorld world, {
    required int enemyIndex,
    required EntityId enemy,
    required int enemyTi,
    required int steeringIndex,
    required double playerX,
    required double playerY,
    required double ex,
    required double ey,
    required double groundTopY,
    required double dtSeconds,
  }) {
    final tuning = unocoDemonTuning;
    final steering = world.flyingEnemySteering;

    final modIndex = world.statModifier.tryIndexOf(enemy);
    final moveSpeedMul = modIndex == null
        ? 1.0
        : world.statModifier.moveSpeedMul[modIndex];

    var rngState = steering.rngState[steeringIndex];
    double nextRange(double min, double max) {
      rngState = nextUint32(rngState);
      return rangeDouble(rngState, min, max);
    }

    if (!steering.initialized[steeringIndex]) {
      steering.initialized[steeringIndex] = true;
      steering.desiredRangeHoldLeftS[steeringIndex] = nextRange(
        tuning.base.unocoDemonDesiredRangeHoldMinSeconds,
        tuning.base.unocoDemonDesiredRangeHoldMaxSeconds,
      );
      steering.desiredRange[steeringIndex] = nextRange(
        tuning.base.unocoDemonDesiredRangeMin,
        tuning.base.unocoDemonDesiredRangeMax,
      );
      steering.flightTargetHoldLeftS[steeringIndex] = 0.0;
      steering.flightTargetAboveGround[steeringIndex] = nextRange(
        tuning.base.unocoDemonMinHeightAboveGround,
        tuning.base.unocoDemonMaxHeightAboveGround,
      );
    }

    var desiredRangeHoldLeftS = steering.desiredRangeHoldLeftS[steeringIndex];
    var desiredRange = steering.desiredRange[steeringIndex];

    if (desiredRangeHoldLeftS > 0.0) {
      desiredRangeHoldLeftS -= dtSeconds;
    } else {
      desiredRangeHoldLeftS = nextRange(
        tuning.base.unocoDemonDesiredRangeHoldMinSeconds,
        tuning.base.unocoDemonDesiredRangeHoldMaxSeconds,
      );
      desiredRange = nextRange(
        tuning.base.unocoDemonDesiredRangeMin,
        tuning.base.unocoDemonDesiredRangeMax,
      );
    }

    final dx = playerX - ex;
    final distX = dx.abs();
    if (distX > 1e-6) {
      world.enemy.facing[enemyIndex] = dx >= 0 ? Facing.right : Facing.left;
    }

    final slack = tuning.base.unocoDemonHoldSlack;
    double desiredVelX = 0.0;
    if (distX > 1e-6) {
      final dirToPlayerX = dx >= 0 ? 1.0 : -1.0;
      final error = distX - desiredRange;

      if (error.abs() > slack) {
        final slowRadiusX = tuning.base.unocoDemonSlowRadiusX;
        final t = slowRadiusX > 0.0
            ? clampDouble((error.abs() - slack) / slowRadiusX, 0.0, 1.0)
            : 1.0;
        final speed = t * tuning.base.unocoDemonMaxSpeedX;
        desiredVelX = (error > 0.0 ? dirToPlayerX : -dirToPlayerX) * speed;
      }
    }

    var flightTargetHoldLeftS =
        steering.flightTargetHoldLeftS[steeringIndex];
    var flightTargetAboveGround =
        steering.flightTargetAboveGround[steeringIndex];
    if (flightTargetHoldLeftS > 0.0) {
      flightTargetHoldLeftS -= dtSeconds;
    } else {
      flightTargetHoldLeftS = nextRange(
        tuning.base.unocoDemonFlightTargetHoldMinSeconds,
        tuning.base.unocoDemonFlightTargetHoldMaxSeconds,
      );
      flightTargetAboveGround = nextRange(
        tuning.base.unocoDemonMinHeightAboveGround,
        tuning.base.unocoDemonMaxHeightAboveGround,
      );
    }

    final targetY = groundTopY - flightTargetAboveGround;
    final deltaY = targetY - ey;
    double desiredVelY = clampDouble(
      deltaY * tuning.base.unocoDemonVerticalKp,
      -tuning.base.unocoDemonMaxSpeedY,
      tuning.base.unocoDemonMaxSpeedY,
    );
    if (deltaY.abs() <= tuning.base.unocoDemonVerticalDeadzone) {
      desiredVelY = 0.0;
    }

    desiredVelX *= moveSpeedMul;
    desiredVelY *= moveSpeedMul;
    final currentVelX = world.transform.velX[enemyTi];
    world.transform.velX[enemyTi] = applyAccelDecel(
      current: currentVelX,
      desired: desiredVelX,
      dtSeconds: dtSeconds,
      accelPerSecond: tuning.base.unocoDemonAccelX,
      decelPerSecond: tuning.base.unocoDemonDecelX,
    );
    world.transform.velY[enemyTi] = desiredVelY;

    steering.desiredRangeHoldLeftS[steeringIndex] = desiredRangeHoldLeftS;
    steering.desiredRange[steeringIndex] = desiredRange;
    steering.flightTargetHoldLeftS[steeringIndex] = flightTargetHoldLeftS;
    steering.flightTargetAboveGround[steeringIndex] = flightTargetAboveGround;
    steering.rngState[steeringIndex] = rngState;
  }
}


===== FILE: lib/core/ecs/systems/gravity_system.dart =====
import '../../players/player_tuning.dart';
import '../../tuning/physics_tuning.dart';
import '../world.dart';

/// Applies gravity to all enabled, non-kinematic bodies that opt into gravity.
///
/// Gravity is applied before collision integration/resolution each tick.
class GravitySystem {
  void step(
    EcsWorld world,
    MovementTuningDerived movement, {
    required PhysicsTuning physics,
  }) {
    final dt = movement.dtSeconds;
    if (dt <= 0.0) return;

    final gravityY = physics.gravityY;
    final bodies = world.body;

    for (var bi = 0; bi < bodies.denseEntities.length; bi += 1) {
      final e = bodies.denseEntities[bi];

      final ti = world.transform.tryIndexOf(e);
      if (ti == null) continue;

      if (!bodies.enabled[bi]) continue;
      if (bodies.isKinematic[bi]) continue;
      if (!bodies.useGravity[bi]) continue;

      // -- Gravity Suppression Logic --
      // Check if gravity is temporarily suppressed for this entity (e.g. during a dash).
      final gci = world.gravityControl.tryIndexOf(e);
      if (gci != null) {
        final ticksLeft = world.gravityControl.suppressGravityTicksLeft[gci];
        
        if (ticksLeft > 0) {
          // Decrement timer.
          final nextTicks = ticksLeft - 1;
          world.gravityControl.suppressGravityTicksLeft[gci] = nextTicks;
          
          // If timer just expired, remove the component so gravity resumes NEXT tick.
          if (nextTicks <= 0) {
            world.gravityControl.removeEntity(e);
          }
          // Skip gravity application for this frame.
          continue;
        } else {
          // Component exists but is stale (0 or negative ticks), remove it and apply gravity immediately.
          world.gravityControl.removeEntity(e);
        }
      }

      // -- Apply Gravity --
      final scaledGravityY = gravityY * bodies.gravityScale[bi];
      world.transform.velY[ti] += scaledGravityY * dt;

      // -- Terminal Velocity --
      final maxVelY = bodies.maxVelY[bi];
      world.transform.velY[ti] = world.transform.velY[ti]
          .clamp(-maxVelY, maxVelY);
    }
  }
}


===== FILE: lib/core/ecs/systems/ground_enemy_locomotion_system.dart =====
import 'dart:math';

import 'package:rpg_runner/core/ecs/entity_id.dart';

import '../../navigation/types/surface_graph.dart';
import '../../snapshots/enums.dart';
import '../../tuning/ground_enemy_tuning.dart';
import '../../util/double_math.dart';
import '../../util/velocity_math.dart';
import '../stores/enemies/melee_engagement_store.dart';
import '../world.dart';

/// Applies movement for ground enemies based on nav + engagement intents.
class GroundEnemyLocomotionSystem {
  GroundEnemyLocomotionSystem({required this.groundEnemyTuning});

  final GroundEnemyTuningDerived groundEnemyTuning;

  SurfaceGraph? _surfaceGraph;

  void setSurfaceGraph({required SurfaceGraph graph}) {
    _surfaceGraph = graph;
  }

  /// Applies locomotion for all ground enemies.
  void step(
    EcsWorld world, {
    required EntityId player,
    required double dtSeconds,
    required int currentTick,
  }) {
    if (dtSeconds <= 0.0) return;
    if (!world.transform.has(player)) return;

    final playerTi = world.transform.indexOf(player);
    final playerX = world.transform.posX[playerTi];

    final navIntent = world.navIntent;
    for (var i = 0; i < navIntent.denseEntities.length; i += 1) {
      final enemy = navIntent.denseEntities[i];
      if (world.deathState.has(enemy)) continue;
      final enemyTi = world.transform.tryIndexOf(enemy);
      if (enemyTi == null) continue;

      if (world.controlLock.isStunned(enemy, currentTick)) {
        world.transform.velX[enemyTi] = 0.0;
        // Keep velY for falling
        continue;
      }

      final enemyIndex = world.enemy.tryIndexOf(enemy);
      if (enemyIndex == null) {
        assert(
          false,
          'GroundEnemyLocomotionSystem requires EnemyStore on ground enemies; add it at spawn time.',
        );
        continue;
      }

      final navIndex = world.surfaceNav.tryIndexOf(enemy);
      if (navIndex == null) {
        assert(
          false,
          'GroundEnemyLocomotionSystem requires SurfaceNavStateStore on ground enemies; add it at spawn time.',
        );
        continue;
      }

      final engagementIndex = world.engagementIntent.tryIndexOf(enemy);
      if (engagementIndex == null) {
        assert(
          false,
          'GroundEnemyLocomotionSystem requires EngagementIntentStore on ground enemies; add it at spawn time.',
        );
        continue;
      }

      final meleeIndex = world.meleeEngagement.tryIndexOf(enemy);
      if (meleeIndex == null) {
        assert(
          false,
          'GroundEnemyLocomotionSystem requires MeleeEngagementStore on ground enemies; add it at spawn time.',
        );
        continue;
      }
      final meleeState = world.meleeEngagement.state[meleeIndex];
      final lockFacingToPlayer = meleeState == MeleeEngagementState.engage ||
          meleeState == MeleeEngagementState.strike ||
          meleeState == MeleeEngagementState.recover;

      final ex = world.transform.posX[enemyTi];
      _applyGroundEnemyLocomotion(
        world,
        enemyIndex: enemyIndex,
        enemyTi: enemyTi,
        navIndex: navIndex,
        navIntentIndex: i,
        engagementIndex: engagementIndex,
        lockFacingToPlayer: lockFacingToPlayer,
        ex: ex,
        playerX: playerX,
        dtSeconds: dtSeconds,
      );
    }
  }

  void _applyGroundEnemyLocomotion(
    EcsWorld world, {
    required int enemyIndex,
    required int enemyTi,
    required int navIndex,
    required int navIntentIndex,
    required int engagementIndex,
    required bool lockFacingToPlayer,
    required double ex,
    required double playerX,
    required double dtSeconds,
  }) {
    final navIntent = world.navIntent;
    final engagementIntent = world.engagementIntent;

    var desiredX = navIntent.desiredX[navIntentIndex];
    if (!navIntent.hasPlan[navIntentIndex]) {
      desiredX = engagementIntent.desiredTargetX[engagementIndex];
      if (navIntent.hasSafeSurface[navIntentIndex]) {
        final minX = navIntent.safeSurfaceMinX[navIntentIndex];
        final maxX = navIntent.safeSurfaceMaxX[navIntentIndex];
        if (minX <= maxX) {
          desiredX = clampDouble(desiredX, minX, maxX);
        }
      }
    }

    final effectiveSpeedScale = navIntent.hasPlan[navIntentIndex]
        ? 1.0
        : engagementIntent.speedScale[engagementIndex];
    final arrivalSlowRadiusX =
        engagementIntent.arrivalSlowRadiusX[engagementIndex];
    final stateSpeedMul = engagementIntent.stateSpeedMul[engagementIndex];

    _applyGroundEnemyPhysics(
      world,
      enemyIndex: enemyIndex,
      enemyTi: enemyTi,
      navIndex: navIndex,
      ex: ex,
      desiredX: desiredX,
      jumpNow: navIntent.jumpNow[navIntentIndex],
      hasPlan: navIntent.hasPlan[navIntentIndex],
      commitMoveDirX: navIntent.commitMoveDirX[navIntentIndex],
      hasSafeSurface: navIntent.hasSafeSurface[navIntentIndex],
      safeSurfaceMinX: navIntent.safeSurfaceMinX[navIntentIndex],
      safeSurfaceMaxX: navIntent.safeSurfaceMaxX[navIntentIndex],
      effectiveSpeedScale: effectiveSpeedScale,
      arrivalSlowRadiusX: arrivalSlowRadiusX,
      stateSpeedMul: stateSpeedMul,
      lockFacingToPlayer: lockFacingToPlayer,
      dtSeconds: dtSeconds,
      graph: _surfaceGraph,
      playerX: playerX,
    );
  }

  void _applyGroundEnemyPhysics(
    EcsWorld world, {
    required int enemyIndex,
    required int enemyTi,
    required int navIndex,
    required double ex,
    required double desiredX,
    required bool jumpNow,
    required bool hasPlan,
    required int commitMoveDirX,
    required bool hasSafeSurface,
    required double safeSurfaceMinX,
    required double safeSurfaceMaxX,
    required double effectiveSpeedScale,
    required double arrivalSlowRadiusX,
    required double stateSpeedMul,
    required bool lockFacingToPlayer,
    required double dtSeconds,
    required SurfaceGraph? graph,
    required double playerX,
  }) {
    final tuning = groundEnemyTuning;
    final enemy = world.enemy.denseEntities[enemyIndex];
    final modIndex = world.statModifier.tryIndexOf(enemy);
    final moveSpeedMul = modIndex == null
        ? 1.0
        : world.statModifier.moveSpeedMul[modIndex];
    final dx = desiredX - ex;
    double arrivalScale = 1.0;
    if (arrivalSlowRadiusX > 0.0) {
      arrivalScale = clampDouble(dx.abs() / arrivalSlowRadiusX, 0.0, 1.0);
    }
    final baseSpeed = tuning.locomotion.speedX *
        effectiveSpeedScale *
        stateSpeedMul *
        moveSpeedMul;
    double desiredVelX = 0.0;
    int desiredDirX = 0;

    if (commitMoveDirX != 0) {
      desiredDirX = commitMoveDirX;
      desiredVelX = desiredDirX.toDouble() * baseSpeed;
    } else if (dx.abs() > tuning.locomotion.stopDistanceX) {
      desiredDirX = dx >= 0 ? 1 : -1;
      desiredVelX = desiredDirX.toDouble() * baseSpeed * arrivalScale;
    }

    if (jumpNow) {
      world.transform.velY[enemyTi] = -tuning.locomotion.jumpSpeed;
    }

    final currentVelX = world.transform.velX[enemyTi];
    final nextVelX = applyAccelDecel(
      current: currentVelX,
      desired: desiredVelX,
      dtSeconds: dtSeconds,
      accelPerSecond: tuning.locomotion.accelX,
      decelPerSecond: tuning.locomotion.decelX,
    );

    double? jumpSnapVelX;
    if (hasPlan && jumpNow && graph != null) {
      final activeEdgeIndex = world.surfaceNav.activeEdgeIndex[navIndex];
      if (activeEdgeIndex >= 0 && activeEdgeIndex < graph.edges.length) {
        final edge = graph.edges[activeEdgeIndex];
        if (edge.kind == SurfaceEdgeKind.jump && edge.travelTicks > 0) {
          final travelSeconds = edge.travelTicks * dtSeconds;
          if (travelSeconds > 0.0) {
            final dxAbs = (edge.landingX - ex).abs();
            final requiredAbs = dxAbs / travelSeconds;
            final desiredAbs = desiredVelX.abs();
            final currentAbs = currentVelX.abs();
            final snapAbs = min(desiredAbs, max(currentAbs, requiredAbs));
            if (snapAbs > nextVelX.abs()) {
              final sign = desiredVelX >= 0.0 ? 1.0 : -1.0;
              jumpSnapVelX = sign * snapAbs;
            }
          }
        }
      }
    }

    world.transform.velX[enemyTi] = jumpSnapVelX ?? nextVelX;

    if (commitMoveDirX != 0) {
      world.enemy.facing[enemyIndex] =
          commitMoveDirX > 0 ? Facing.right : Facing.left;
    } else {
      final enemyCi = world.collision.tryIndexOf(enemy);
      final grounded = enemyCi != null && world.collision.grounded[enemyCi];
      if (grounded) {
        if (desiredDirX != 0) {
          world.enemy.facing[enemyIndex] =
              desiredDirX > 0 ? Facing.right : Facing.left;
        }
      } else {
        const airFacingVelDeadzone = 1.0;
        final vx = world.transform.velX[enemyTi];
        if (vx.abs() > airFacingVelDeadzone) {
          world.enemy.facing[enemyIndex] = vx > 0 ? Facing.right : Facing.left;
        }
      }
    }

    if (!hasPlan && hasSafeSurface) {
      final stopDist = tuning.locomotion.stopDistanceX;
      final nextVelX = world.transform.velX[enemyTi];
      if (nextVelX > 0.0 && ex >= safeSurfaceMaxX - stopDist) {
        world.transform.velX[enemyTi] = 0.0;
      } else if (nextVelX < 0.0 && ex <= safeSurfaceMinX + stopDist) {
        world.transform.velX[enemyTi] = 0.0;
      }
    }

    if (lockFacingToPlayer) {
      final dxToPlayer = playerX - ex;
      if (dxToPlayer.abs() > 1e-6) {
        world.enemy.facing[enemyIndex] =
            dxToPlayer >= 0 ? Facing.right : Facing.left;
      }
    }
  }
}


===== FILE: lib/core/ecs/systems/health_despawn_system.dart =====
import '../entity_id.dart';
import '../world.dart';

/// Despawns any non-player entity with `HealthStore` and `hp <= 0`.
///
/// **Responsibilities**:
/// *   Scans all entities with health.
/// *   Identifies those with zero or negative health points.
/// *   Removes the dead entities from the ECS world.
///
/// **IMPORTANT**: The player is intentionally exempt because player "death" is a
/// different gameplay flow (game over / respawn / end-run) than despawning an
/// entity in-place.
class HealthDespawnSystem {
  /// Internal buffer to hold entities scheduled for destruction this frame.
  /// Used to avoid modifying the entity collection while iterating over it.
  final List<EntityId> _toDespawn = <EntityId>[];

  /// Runs the system logic.
  ///
  void step(
    EcsWorld world, {
    required EntityId player,
  }) {
    final health = world.health;
    // Optimization: If no entities have health components, there's nothing to check.
    if (health.denseEntities.isEmpty) return;

    // Reset buffer for this frame.
    _toDespawn.clear();

    // -- Pass 1: Identification --
    // Iterate over all entities participating in the health system.
    for (var i = 0; i < health.denseEntities.length; i += 1) {
      final e = health.denseEntities[i];
      
      // Safety check: The player should never be despawned by this system.
      if (e == player) continue;
      
      // Enemies are handled by the enemy death state pipeline.
      if (world.enemy.has(e)) continue;

      // If health is depleted, mark for destruction.
      if (health.hp[i] <= 0) {
        _toDespawn.add(e);
      }
    }

    // -- Pass 2: Reporting & Destruction --
    // Process the list of doomed entities.
    for (final e in _toDespawn) {
      // Permanently remove the entity and all its components from the world.
      world.destroyEntity(e);
    }
  }
}


===== FILE: lib/core/ecs/systems/hitbox_damage_system.dart =====
import '../../combat/damage.dart';
import '../../events/game_event.dart';
import '../../util/fixed_math.dart';
import '../hit/hit_resolver.dart';
import '../spatial/broadphase_grid.dart';
import '../world.dart';

/// Detects collisions between active hitboxes (melee strikes) and vulnerable targets.
///
/// **Responsibilities**:
/// *   Iterate over all active hitboxes (entities with `HitboxStore`).
/// *   Perform broadphase/narrowphase collision checks against potential targets.
/// *   Filter hits based on faction (Friendly fire prevention).
/// *   Enforce "Hit Once" logic to prevent a single frame of strike from dealing damage every tick.
/// *   Queue [DamageRequest]s for resolved hits.
class HitboxDamageSystem {
  /// Helper for spatial queries and overlap sorting.
  final HitResolver _resolver = HitResolver();
  
  /// Reused buffer to store indices of overlapping entities each frame.
  final List<int> _overlaps = <int>[];

  /// Executes the system logic.
  ///
  /// [broadphase] provides the spatial index of all damageable entities this frame.
  void step(
    EcsWorld world,
    BroadphaseGrid broadphase, {
    required int currentTick,
  }) {
    final hitboxes = world.hitbox;
    // Early exit if no active strikes exist.
    if (hitboxes.denseEntities.isEmpty) return;

    // Early exit if there are no targets to hit.
    if (broadphase.targets.isEmpty) return;

    // Process each active hitbox.
    for (var hi = 0; hi < hitboxes.denseEntities.length; hi += 1) {
      final hb = hitboxes.denseEntities[hi];
      
      // Hitboxes must have a position (Transform) to overlap anything.
      if (!world.transform.has(hb)) continue;
      
      // Hitboxes must have a HitOnce state to track who they've already damaged.
      // This prevents "machine gun" damage from a lingering sword swing.
      if (!world.hitOnce.has(hb)) continue;

      final hbTi = world.transform.indexOf(hb);
      final hbCx = world.transform.posX[hbTi];
      final hbCy = world.transform.posY[hbTi];
      final hbHalfX = hitboxes.halfX[hi];
      final hbHalfY = hitboxes.halfY[hi];
      final hbDirX = hitboxes.dirX[hi];
      final hbDirY = hitboxes.dirY[hi];

      // Calculate capsule segment endpoints.
      // We interpret `halfX` as the half-length along the direction vector,
      // and `halfY` as the capsule radius (thickness).
      // This effectively creates a capsule centered at (hbCx, hbCy) oriented along (hbDirX, hbDirY).
      final ax = hbCx - hbDirX * hbHalfX;
      final ay = hbCy - hbDirY * hbHalfX;
      final bx = hbCx + hbDirX * hbHalfX;
      final by = hbCy + hbDirY * hbHalfX;

      final owner = hitboxes.owner[hi];
      final sourceFaction = hitboxes.faction[hi];

      if (world.deathState.has(owner)) continue;
      
      // Resolve enemy ID efficiently if the owner is an enemy.
      // This is used for kill credit/stats.
      final enemyIndex = world.enemy.tryIndexOf(owner);
      final enemyId = enemyIndex != null
          ? world.enemy.enemyId[enemyIndex]
          : null;

      // Ensure buffer is clear before collection (safety measure).
      _overlaps.clear();
      
      // Query the spatial grid for potential overlaps.
      // This handles the geometric check (Capsule vs Target Bounds) and Faction check.
      _resolver.collectOrderedOverlapsCapsule(
        broadphase: broadphase,
        ax: ax,
        ay: ay,
        bx: bx,
        by: by,
        radius: hbHalfY,
        owner: owner,
        sourceFaction: sourceFaction,
        outTargetIndices: _overlaps,
      );
      if (_overlaps.isEmpty) continue;

      // Register hits for verified overlaps.
      for (var i = 0; i < _overlaps.length; i += 1) {
        final ti = _overlaps[i];
        final target = broadphase.targets.entities[ti];
        
        // "Hit Once" Check: Has this specific hitbox entity already struck this specific target entity?
        if (world.hitOnce.hasHit(hb, target)) continue;
        
        // Mark as hit so we don't damage them again this swing.
        world.hitOnce.markHit(hb, target);

        // Send the damage request.
        var amount100 = hitboxes.damage100[hi];

        // Consume parry riposte only when a melee hit actually lands.
        final ri = world.riposte.tryIndexOf(owner);
        if (ri != null) {
          if (currentTick <= world.riposte.expiresTick[ri]) {
            amount100 =
                (amount100 * (bpScale + world.riposte.bonusBp[ri])) ~/ bpScale;
          }
          world.riposte.consume(owner);
        }

        world.damageQueue.add(
          DamageRequest(
            target: target,
            amount100: amount100,
            damageType: hitboxes.damageType[hi],
            procs: hitboxes.procs[hi],
            source: owner,
            sourceKind: DeathSourceKind.meleeHitbox,
            sourceEnemyId: enemyId,
          ),
        );
      }
    }
  }
}


===== FILE: lib/core/ecs/systems/hitbox_follow_owner_system.dart =====
import '../entity_id.dart';
import '../world.dart';

/// Synchronizes the position of hitbox entities with their owners.
///
/// **Responsibilities**:
/// *   Iterate over all active hitboxes (entities with `HitboxStore`).
/// *   Retrieve the owner's current position.
/// *   Apply the hitbox's local offset (defined at spawn).
/// *   Update the hitbox's `Transform` component to match the calculated world position.
///
/// **Usage Note**:
/// This system ensures that a sword swing or projectile hitbox moves *with* the
/// character/projectile effectively. It runs every tick to prevent "hitbox drift".
class HitboxFollowOwnerSystem {
  final List<EntityId> _toDespawn = <EntityId>[];

  /// Executes the synchronization logic.
  void step(EcsWorld world) {
    final hitboxes = world.hitbox;
    // Early exit if no hitboxes exist.
    if (hitboxes.denseEntities.isEmpty) return;

    _toDespawn.clear();

    for (var hi = 0; hi < hitboxes.denseEntities.length; hi += 1) {
      final hitbox = hitboxes.denseEntities[hi];
      
      // Safety: The hitbox entity itself must have a Transform component to be positioned.
      if (!world.transform.has(hitbox)) {
        _toDespawn.add(hitbox);
        continue;
      }

      final owner = hitboxes.owner[hi];
      
      // If the owner has been destroyed or lacks a transform,
      // we cannot position the hitbox relative to it.
      final ownerTi = world.transform.tryIndexOf(owner);
      if (ownerTi == null) {
        _toDespawn.add(hitbox);
        continue;
      }

      // Calculate world position: Owner Position + Local Offset.
      final x = world.transform.posX[ownerTi] + hitboxes.offsetX[hi];
      final y = world.transform.posY[ownerTi] + hitboxes.offsetY[hi];

      // specific Snap behavior: We overwrite the position completely.
      // Physics forces are not applied here; it's a hard attachment.
      world.transform.setPosXY(hitbox, x, y);
    }

    for (final e in _toDespawn) {
      world.destroyEntity(e);
    }
  }
}


===== FILE: lib/core/ecs/systems/invulnerability_system.dart =====
import '../world.dart';

/// Manages temporary invulnerability frames (i-frames).
///
/// **Responsibilities**:
/// *   Decrements invulnerability timers each tick.
/// *   Removes the `InvulnerabilityStore` component when the timer expires.
class InvulnerabilitySystem {
  void step(EcsWorld world) {
    final store = world.invulnerability;
    // Iterate backwards to allow safe removal of entities (Swap-Remove safe).
    for (var i = store.denseEntities.length - 1; i >= 0; i--) {
      // Decrement.
      if (store.ticksLeft[i] > 0) {
        store.ticksLeft[i] -= 1;
      }

      // Cleanup logic: If expired, remove the component so other systems
      // (collision/damage) know the entity is vulnerable again.
      if (store.ticksLeft[i] <= 0) {
        final e = store.denseEntities[i];
        store.removeEntity(e);
      }
    }
  }
}



===== FILE: lib/core/ecs/systems/lifetime_system.dart =====
import '../entity_id.dart';
import '../world.dart';

/// Determines when temporary entities should expire.
///
/// **Responsibilities**:
/// *   Decrements the life timer (`LifetimeStore.ticksLeft`) for all participating entities every tick.
/// *   Despawns entities when their timer reaches zero.
///
/// **Usage**:
/// Generic system used for particles, projectiles, transient UI markers, or timed buffs
/// that need to clean themselves up automatically.
class LifetimeSystem {
  /// Buffer for entities to destroy.
  /// Used to avoid `ConcurrentModificationException` when modifying the ECS state during iteration.
  final List<EntityId> _toDespawn = <EntityId>[];

  /// Executes the system logic.
  void step(EcsWorld world) {
    final lifetimes = world.lifetime;
    // Optimization: Skip processing if no timed entities exist.
    if (lifetimes.denseEntities.isEmpty) return;

    // Reset the buffer for this frame.
    _toDespawn.clear();

    // Iterate over all entities with a lifetime component.
    for (var li = 0; li < lifetimes.denseEntities.length; li += 1) {
      final e = lifetimes.denseEntities[li];
      
      // Decrement the timer (Tick down).
      lifetimes.ticksLeft[li]--;
      
      // If time has run out (or was force-set to <= 0), mark for destruction.
      if (lifetimes.ticksLeft[li] <= 0) {
        _toDespawn.add(e);
      }
    }

    // Process the destruction queue.
    for (final e in _toDespawn) {
      world.destroyEntity(e);
    }
  }
}



===== FILE: lib/core/ecs/systems/melee_strike_system.dart =====
import '../stores/hitbox_store.dart';
import '../stores/lifetime_store.dart';
import '../world.dart';

/// Processes requests to perform melee strikes.
///
/// **Responsibilities**:
/// *   Consumes committed melee intents created by input or enemy AI.
/// *   **Execution only**: converts `tick == currentTick` intents into ephemeral hitbox entities.
/// *   Spawns the actual "Hitbox" entity that performs collision checks (+ HitOnce + Lifetime).
/// *   Invalidates the intent immediately to prevent double execution in the same tick.
///
/// **Not responsible for**:
/// - Resource deduction (mana/stamina), cooldown start, or commit gating.
///   Those are handled at commit-time (e.g. AbilityActivationSystem / enemy commit logic).
///
/// **Workflow**:
/// 1. Filter intents that match the [currentTick] (synchronization via stamped execute tick).
/// 2. Invalidate the intent (so multi-pass in the same tick can’t double-spawn).
/// 3. Validate attacker existence + basic state (e.g. stunned checks).
/// 4. Spawn hitbox entity:
///    - Transform at attacker position
///    - HitboxDef from intent fields
///    - HitOnce marker
///    - LifetimeDef based on active window ticks
class MeleeStrikeSystem {
  /// Runs the system logic.
  ///
  /// [currentTick] is required to ensure we only process intents generated for THIS frame,
  /// preserving determinism.
  void step(EcsWorld world, {required int currentTick}) {
    final intents = world.meleeIntent;
    if (intents.denseEntities.isEmpty) return;

    // Iterate through all intents.
    for (var ii = 0; ii < intents.denseEntities.length; ii += 1) {
      final strikeer = intents.denseEntities[ii];

      final executeTick = intents.tick[ii];

      if (executeTick != currentTick) continue;

      // Invalidate now so accidental multi-pass execution in the same tick cannot
      // double-strike. (Intent is still ignored next tick due to stamp mismatch.)
      intents.tick[ii] = -1;
      intents.commitTick[ii] = -1;

      // -- Validation & Resource Checks --

      // Attacker must exist physically.
      final strikeerTi = world.transform.tryIndexOf(strikeer);
      if (strikeerTi == null) continue;

      // Cannot strike while stunned.
      if (world.controlLock.isStunned(strikeer, currentTick)) continue;

      // Attacker must have a faction to determine who they hit.
      final fi = world.faction.tryIndexOf(strikeer);
      if (fi == null) continue;
      final faction = world.faction.faction[fi];

      // -- Execution --

      // Spawn the hitbox.
      final hitbox = world.createEntity();
      world.transform.add(
        hitbox,
        // HitboxFollowOwnerSystem will position from `owner + offset`.
        // Initialize at owner's position to prevent 1-frame visual glitch.
        posX: world.transform.posX[strikeerTi],
        posY: world.transform.posY[strikeerTi],
        velX: 0.0,
        velY: 0.0,
      );
      world.hitbox.add(
        hitbox,
        HitboxDef(
          owner: strikeer,
          faction: faction,
          damage100: intents.damage100[ii],
          damageType: intents.damageType[ii],
          procs: intents.procs[ii],
          halfX: intents.halfX[ii],
          halfY: intents.halfY[ii],
          offsetX: intents.offsetX[ii],
          offsetY: intents.offsetY[ii],
          dirX: intents.dirX[ii],
          dirY: intents.dirY[ii],
        ),
      );
      // Ensure hitbox only hits things once.
      world.hitOnce.add(hitbox);
      // Hitbox is ephemeral.
      world.lifetime.add(
        hitbox,
        LifetimeDef(ticksLeft: intents.activeTicks[ii]),
      );
    }
  }
}


===== FILE: lib/core/ecs/systems/mobility_system.dart =====
import '../../abilities/ability_def.dart';
import '../../snapshots/enums.dart';
import '../../players/player_tuning.dart';
import '../stores/mobility_intent_store.dart';
import '../world.dart';

/// Executes mobility intents (dash/roll) and applies movement state.
///
/// Responsibilities:
/// - Validate cooldown/stamina/locks at commit.
/// - Start cooldown + ActiveAbility state on commit.
/// - Apply dash movement and gravity suppression on execute tick.
class MobilitySystem {
  void step(
    EcsWorld world,
    MovementTuningDerived tuning, {
    required int currentTick,
  }) {
    final intents = world.mobilityIntent;
    if (intents.denseEntities.isEmpty) return;

    final movements = world.movement;
    final transforms = world.transform;
    final bodies = world.body;

    final count = intents.denseEntities.length;
    for (var ii = 0; ii < count; ii += 1) {
      final entity = intents.denseEntities[ii];
      if (intents.slot[ii] == AbilitySlot.jump) {
        continue;
      }
      final executeTick = intents.tick[ii];

      if (executeTick != currentTick) continue;

      _invalidateIntent(intents, ii);

      final mi = movements.tryIndexOf(entity);
      final ti = transforms.tryIndexOf(entity);
      final bi = bodies.tryIndexOf(entity);
      if (mi == null || ti == null || bi == null) continue;
      if (!bodies.enabled[bi] || bodies.isKinematic[bi]) continue;

      final activeTicks = intents.activeTicks[ii];
      if (activeTicks <= 0) continue;

      final modifierIndex = world.statModifier.tryIndexOf(entity);
      final moveSpeedMul = modifierIndex == null
          ? 1.0
          : world.statModifier.moveSpeedMul[modifierIndex];

      final dirX = intents.dirX[ii];
      movements.dashDirX[mi] = dirX;
      movements.dashTicksLeft[mi] = activeTicks;
      movements.facing[mi] = dirX >= 0 ? Facing.right : Facing.left;

      // Cancel vertical motion and suppress gravity to keep dash horizontal.
      transforms.velY[ti] = 0;
      transforms.velX[ti] = dirX * tuning.base.dashSpeedX * moveSpeedMul;
      world.gravityControl.setSuppressForTicks(entity, activeTicks);
    }
  }

  void _invalidateIntent(MobilityIntentStore intents, int index) {
    intents.tick[index] = -1;
    intents.commitTick[index] = -1;
  }
}


===== FILE: lib/core/ecs/systems/player_movement_system.dart =====
import '../../abilities/ability_def.dart';
import '../../snapshots/enums.dart';
import '../../players/player_tuning.dart';
import '../../util/velocity_math.dart';
import '../queries.dart';
import '../world.dart';

/// Applies platformer-style movement for entities with:
/// - Transform
/// - PlayerInput
/// - Movement
/// - Body
///
/// PlayerMovementSystem writes velocities only (input/jump/dash state/gravity/clamps).
/// Dash initiation is handled by [MobilitySystem].
/// Position integration and collision resolution are handled by CollisionSystem.
///
/// **Responsibilities**:
/// *   Update movement state timers (Dash cooldown, Coyote time, Jump buffer).
/// *   Process Input (Jump request, Horizontal move).
/// *   Apply velocities based on state.
class PlayerMovementSystem {
  void step(
    EcsWorld world,
    MovementTuningDerived tuning, {
    required ResourceTuningDerived resources,
    required int currentTick,
  }) {
    final dt = tuning.dtSeconds;
    final t = tuning.base;

    // Iterate over all controllable entities (Join: Movement + Input + Body +...).
    // Uses EcsQueries to efficiently fetch entities with all required components.
    EcsQueries.forMovementBodies(world, (e, mi, ti, ii, bi, ci, si) {
      if (!world.body.enabled[bi]) return;

      // Kinematic bodies are moved by scripts/physics directly, not by player input.
      if (world.body.isKinematic[bi]) {
        return;
      }

      // -- Stun Check --
      // If stunned, Zero horizontal velocity and skip input input processing.
      // Vertical velocity (gravity) continues to apply normally (falling).
      if (world.controlLock.isStunned(e, currentTick)) {
        // Cancel dash if active (so we don't float)
        if (world.movement.dashTicksLeft[mi] > 0) {
          world.movement.dashTicksLeft[mi] = 0;
          // Restore gravity if it was suppressed by dash
          if (world.gravityControl.suppressGravityTicksLeft[world.gravityControl
                  .indexOf(e)] >
              0) {
            world.gravityControl.suppressGravityTicksLeft[world.gravityControl
                    .indexOf(e)] =
                0;
          }
        }
        world.transform.velX[ti] = 0;
        return;
      }

      // -- Timers --
      // Decrement state timers. These track cooldowns and temporary states (dash, buffers).

      if (world.movement.dashTicksLeft[mi] > 0) {
        world.movement.dashTicksLeft[mi] -= 1;
      }
      if (world.movement.jumpBufferTicksLeft[mi] > 0) {
        world.movement.jumpBufferTicksLeft[mi] -= 1;
      }

      // -- Coyote Time --
      // "Coyote Time" allows the player to jump for a few frames after walking off a ledge.
      // - If currently grounded (from CollisionSystem last frame), reset the timer to full.
      // - If in air, decrement the timer.
      final wasGrounded = world.collision.grounded[ci];
      if (wasGrounded) {
        world.movement.coyoteTicksLeft[mi] = tuning.coyoteTicks;
      } else if (world.movement.coyoteTicksLeft[mi] > 0) {
        world.movement.coyoteTicksLeft[mi] -= 1;
      }

      // -- Input Buffering --
      // Buffer a jump request coming from the ability pipeline.
      final jumpIntentIndex = world.mobilityIntent.tryIndexOf(e);
      final hasJumpIntent =
          jumpIntentIndex != null &&
          world.mobilityIntent.slot[jumpIntentIndex] == AbilitySlot.jump;
      if (hasJumpIntent &&
          world.mobilityIntent.commitTick[jumpIntentIndex] == currentTick) {
        // Jump pressed this tick: prime the buffer.
        world.movement.jumpBufferTicksLeft[mi] = tuning.jumpBufferTicks;
      }

      final dashing = world.movement.dashTicksLeft[mi] > 0;
      final modifierIndex = world.statModifier.tryIndexOf(e);
      final moveSpeedMul = modifierIndex == null
          ? 1.0
          : world.statModifier.moveSpeedMul[modifierIndex];

      if (world.movement.facingLockTicksLeft[mi] > 0) {
        world.movement.facingLockTicksLeft[mi] -= 1;
      }

      // -- Horizontal Movement --
      if (dashing) {
        // [State: Dashing]
        // Lock velocity to the dash direction and speed.
        // Zero out Y velocity to prevent gravity from affecting the dash arc (linear dash).
        world.transform.velX[ti] =
            world.movement.dashDirX[mi] * t.dashSpeedX * moveSpeedMul;
        world.transform.velY[ti] = 0;
      } else {
        // [State: Normal Control]
        final axis = world.playerInput.moveAxis[ii];

        // Visuals: Update facing direction based on input.
        // This is decoupled from velocity to allow "turning" animations before velocity flips.
        if (world.movement.facingLockTicksLeft[mi] == 0 && axis != 0) {
          world.movement.facing[mi] = axis > 0 ? Facing.right : Facing.left;
        }

        // Apply horizontal acceleration/deceleration.
        world.transform.velX[ti] = _applyHorizontalMove(
          world.transform.velX[ti],
          axis,
          dt,
          tuning,
          moveSpeedMul,
        );

        // -- Jumping --
        // Execute Jump if:
        // 1. Jump is buffered (Pressed recently).
        // 2. Player can jump (Grounded OR Coyote Time active).
        // 3. Sufficient Stamina.
        if (world.movement.jumpBufferTicksLeft[mi] > 0 &&
            (wasGrounded || world.movement.coyoteTicksLeft[mi] > 0)) {
          final jumpCost = hasJumpIntent
              ? world.mobilityIntent.staminaCost100[jumpIntentIndex]
              : resources.jumpStaminaCost100;
          if (world.stamina.stamina[si] >= jumpCost) {
            // Stamina cost is handled by AbilityActivationSystem at commit time.
            // world.stamina.stamina[si] -= jumpCost;

            // Apply instantaneous upward velocity.
            world.transform.velY[ti] = -t.jumpSpeed;

            // Consume the buffer and coyote time immediately to prevent double-jumping
            // in the same window.
            world.movement.jumpBufferTicksLeft[mi] = 0;
            world.movement.coyoteTicksLeft[mi] = 0;

            if (hasJumpIntent) {
              // Mark the jump intent as consumed and stamp the active ability.
              final intent = world.mobilityIntent;
              intent.tick[jumpIntentIndex] = -1;
              intent.commitTick[jumpIntentIndex] = -1;

              if (world.activeAbility.has(e)) {
                world.activeAbility.set(
                  e,
                  id: intent.abilityId[jumpIntentIndex],
                  slot: intent.slot[jumpIntentIndex],
                  commitTick: currentTick,
                  windupTicks: intent.windupTicks[jumpIntentIndex],
                  activeTicks: intent.activeTicks[jumpIntentIndex],
                  recoveryTicks: intent.recoveryTicks[jumpIntentIndex],
                  facingDir: world.movement.facing[mi],
                );
              }
            }
          }
        }
      }

      // If a jump intent is buffered but expired, clear it.
      if (hasJumpIntent && world.movement.jumpBufferTicksLeft[mi] <= 0) {
        world.mobilityIntent.tick[jumpIntentIndex] = -1;
        world.mobilityIntent.commitTick[jumpIntentIndex] = -1;
      }

      // -- Limits --
      // Soft cap on horizontal velocity to prevent runaway speeds from external forces.
      world.transform.velX[ti] = world.transform.velX[ti].clamp(
        -world.body.maxVelX[bi],
        world.body.maxVelX[bi],
      );
    });
  }

  /// Calculates the new horizontal velocity using linear acceleration/deceleration.
  ///
  /// Note:
  /// - Uses [t.decelerationX] when `axis == 0` (Stopping).
  /// - Uses [t.accelerationX] for both Speeding Up and Turning (changing direction).
  /// - Snaps to 0 if speed is below [t.minMoveSpeed] and input is 0.
  double _applyHorizontalMove(
    double velocityX,
    double axis,
    double dt,
    MovementTuningDerived tuning,
    double moveSpeedMul,
  ) {
    final t = tuning.base;
    final desiredX = axis == 0.0 ? 0.0 : axis * t.maxSpeedX * moveSpeedMul;
    return applyAccelDecel(
      current: velocityX,
      desired: desiredX,
      dtSeconds: dt,
      accelPerSecond: t.accelerationX * moveSpeedMul,
      decelPerSecond: t.decelerationX * moveSpeedMul,
      minStopSpeed: t.minMoveSpeed,
    );
  }

  // Dash initiation moved to MobilitySystem (ability-driven).
}


===== FILE: lib/core/ecs/systems/projectile_hit_system.dart =====
import 'dart:math';

import '../../combat/damage.dart';
import '../../events/game_event.dart';
import '../../snapshots/enums.dart';
import '../../util/vec2.dart';
import '../entity_id.dart';
import '../hit/hit_resolver.dart';
import '../spatial/broadphase_grid.dart';
import '../world.dart';

/// Handles collision detection for projectiles against potentially damageable targets.
///
/// **Responsibilities**:
/// - Iterates all active projectiles.
/// - Calculates a swept capsule shape for the projectile based on its velocity/direction.
/// - Queries the [BroadphaseGrid] for collisions.
/// - Queues [DamageRequest] and despawns the projectile on impact.
class ProjectileHitSystem {
  final List<EntityId> _toDespawn = <EntityId>[];
  final HitResolver _resolver = HitResolver();

  /// Runs the system logic for a single tick.
  ///
  /// [broadphase] provides spatial acceleration for finding targets efficiently.
  void step(
    EcsWorld world,
    BroadphaseGrid broadphase, {
    required int currentTick,
    void Function(ProjectileHitEvent event)? queueHitEvent,
  }) {
    // Optimization: If there are no targets to hit, projectiles just fly.
    if (broadphase.targets.isEmpty) return;
    
    final projectiles = world.projectile;
    if (projectiles.denseEntities.isEmpty) return;

    _toDespawn.clear();

    // Cache store references for efficient lookup (Hoisting).
    final transforms = world.transform;
    final colliders = world.colliderAabb;
    final enemies = world.enemy;
    final projectileOrigins = world.projectileItemOrigin;

    final count = projectiles.denseEntities.length;
    for (var pi = 0; pi < count; pi += 1) {
      final p = projectiles.denseEntities[pi];
      
      // Validation: Projectiles must have physical presence.
      final ti = transforms.tryIndexOf(p);
      if (ti == null) continue;

      final ci = colliders.tryIndexOf(p);
      if (ci == null) continue;

      // -- Geometry Construction --
      // Projectiles are modeled as capsules (swept circles) oriented along their velocity vector.
      // - [offsetX/Y]: Center offset relative to transform.
      // - [halfX]: Interpreted as half-length of the capsule shaft.
      // - [halfY]: Interpreted as the radius (thickness) of the projectile.
      final pcx = transforms.posX[ti] + colliders.offsetX[ci];
      final pcy = transforms.posY[ti] + colliders.offsetY[ci];
      
      final halfLength = colliders.halfX[ci];
      final radius = colliders.halfY[ci];
      
      final dirX = projectiles.dirX[pi];
      final dirY = projectiles.dirY[pi];
      final facing = dirX >= 0 ? Facing.right : Facing.left;
      final rotationRad = atan2(dirY, dirX);

      // Calculate the start (A) and end (B) points of the capsule segment.
      // The segment is centered at (pcx, pcy) and extends halfLength in both directions along (dirX, dirY).
      final ax = pcx - dirX * halfLength;
      final ay = pcy - dirY * halfLength;
      final bx = pcx + dirX * halfLength;
      final by = pcy + dirY * halfLength;

      // -- Hit Resolution --
      final owner = projectiles.owner[pi];
      final sourceFaction = projectiles.faction[pi];
      if (world.deathState.has(owner)) {
        _toDespawn.add(p);
        continue;
      }

      // Query the broadphase for the first valid intersection.
      // This respects "Friendly Fire" rules via [sourceFaction].
      final targetIndex = _resolver.firstOrderedOverlapCapsule(
        broadphase: broadphase,
        ax: ax,
        ay: ay,
        bx: bx,
        by: by,
        radius: radius,
        owner: owner,
        sourceFaction: sourceFaction,
      );

      // -- Impact Handling --
      if (targetIndex != null) {
        // Optimization: Resolve heavy metadata (EnemyId, ProjectileItemId) ONLY when a hit actually occurs.
        // Doing this before the hit check would waste cycles for the 99% of frames a projectile is just flying.
        final ei = enemies.tryIndexOf(owner);
        final enemyId = ei != null ? enemies.enemyId[ei] : null;
        
        final si = projectileOrigins.tryIndexOf(p);
        final projectileItemId =
            si != null ? projectileOrigins.projectileItemId[si] : null;

        // Dispatch damage event.
        world.damageQueue.add(
          DamageRequest(
            target: broadphase.targets.entities[targetIndex],
            amount100: projectiles.damage100[pi],
            damageType: projectiles.damageType[pi],
            procs: projectiles.procs[pi],
            source: owner,
            sourceKind: DeathSourceKind.projectile,
            sourceEnemyId: enemyId,
            sourceProjectileId: projectiles.projectileId[pi],
            sourceProjectileItemId: projectileItemId,
          ),
        );

        if (queueHitEvent != null) {
          queueHitEvent(
            ProjectileHitEvent(
              tick: currentTick,
              projectileId: projectiles.projectileId[pi],
              projectileItemId: projectileItemId,
              pos: Vec2(pcx, pcy),
              facing: facing,
              rotationRad: rotationRad,
            ),
          );
        }
        
        // Mark projectile for removal.
        // We defer removal until after the loop or use a list to avoid modifying the collection while iterating
        // (though we are iterating by index here, deferred removal is safer/cleaner pattern).
        _toDespawn.add(p);
      }
    }

    // Process despawns.
    for (final e in _toDespawn) {
      world.destroyEntity(e);
    }
  }
}


===== FILE: lib/core/ecs/systems/projectile_launch_system.dart =====
import '../../projectiles/projectile_catalog.dart';
import '../../projectiles/spawn_projectile_item.dart';
import '../stores/projectile_intent_store.dart';
import '../stores/transform_store.dart';
import '../world.dart';

/// Executes [ProjectileIntentStore] intents by spawning projectiles.
///
/// **Execution Only**:
/// - Reads committed intents (`tick == currentTick`).
/// - Spawns projectile entities.
/// - Does **not** deduct resources or start cooldowns (handled by Activation).
class ProjectileLaunchSystem {
  ProjectileLaunchSystem({required this.projectiles});

  final ProjectileCatalogDerived projectiles;

  void step(EcsWorld world, {required int currentTick}) {
    final intents = world.projectileIntent;
    if (intents.denseEntities.isEmpty) return;

    final transforms = world.transform;
    final factions = world.faction;

    final count = intents.denseEntities.length;
    for (var ii = 0; ii < count; ii += 1) {
      final caster = intents.denseEntities[ii];
      final executeTick = intents.tick[ii];

      final ti = transforms.tryIndexOf(caster);
      if (ti == null) {
        _invalidateIntent(intents, ii);
        continue;
      }

      if (executeTick != currentTick) continue;

      _invalidateIntent(intents, ii);

      final fi = factions.tryIndexOf(caster);
      if (fi == null) continue;

      spawnProjectileItemFromCaster(
        world,
        projectiles: projectiles,
        projectileItemId: intents.projectileItemId[ii],
        projectileId: intents.projectileId[ii],
        faction: factions.faction[fi],
        owner: caster,
        casterX: transforms.posX[ti],
        casterY: transforms.posY[ti],
        originOffset: intents.originOffset[ii],
        dirX: intents.dirX[ii],
        dirY: intents.dirY[ii],
        fallbackDirX: intents.fallbackDirX[ii],
        fallbackDirY: intents.fallbackDirY[ii],
        damage100: intents.damage100[ii],
        damageType: intents.damageType[ii],
        procs: intents.procs[ii],
        ballistic: intents.ballistic[ii],
        gravityScale: intents.gravityScale[ii],
      );
    }
  }

  void _invalidateIntent(ProjectileIntentStore intents, int index) {
    intents.tick[index] = -1;
    intents.commitTick[index] = -1;
  }
}


===== FILE: lib/core/ecs/systems/projectile_system.dart =====
import 'dart:math';

import '../../players/player_tuning.dart';
import '../world.dart';

/// Moves active projectiles based on their linear velocity.
///
/// **Responsibilities**:
/// - Updates `velX` and `velY` (for use by renderers/interpolation).
/// - Explicitly integrates position: `pos += vel * dt`.
///
/// Note: Projectiles are typically simple kinematic objects that do not participate
/// in the full physics/collision resolution loop (no `Body` component), hence the
/// manual position integration here.
class ProjectileSystem {
  void step(EcsWorld world, MovementTuningDerived movement) {
    final dt = movement.dtSeconds;
    final projectiles = world.projectile;
    final transforms = world.transform;

    // Iterate efficiently over dense projectile arrays.
    final count = projectiles.denseEntities.length;
    for (var pi = 0; pi < count; pi += 1) {
      final e = projectiles.denseEntities[pi];
      
      final ti = transforms.tryIndexOf(e);
      if (ti == null) continue;

      // Physics-driven projectiles (ballistic) are moved by the main physics
      // pipeline (GravitySystem + CollisionSystem). We only keep direction
      // in sync with velocity for hitbox orientation / rendering.
      if (projectiles.usePhysics[pi]) {
        final vx = transforms.velX[ti];
        final vy = transforms.velY[ti];
        final len2 = vx * vx + vy * vy;
        if (len2 > 1e-12) {
          final invLen = 1.0 / sqrt(len2);
          projectiles.dirX[pi] = vx * invLen;
          projectiles.dirY[pi] = vy * invLen;
        }
        continue;
      }

      // Calculate velocity from direction and speed.
      final vx = projectiles.dirX[pi] * projectiles.speedUnitsPerSecond[pi];
      final vy = projectiles.dirY[pi] * projectiles.speedUnitsPerSecond[pi];

      // Update Transform velocity (useful for other systems/debug).
      transforms.velX[ti] = vx;
      transforms.velY[ti] = vy;

      // Explicit Euler integration: pos += vel * dt
      // We do this here because projectiles lack a 'Body' component for simplicity
      // and thus aren't moved by the main physics solver.
      transforms.posX[ti] += vx * dt;
      transforms.posY[ti] += vy * dt;
    }
  }
}


===== FILE: lib/core/ecs/systems/projectile_world_collision_system.dart =====
import '../entity_id.dart';
import '../world.dart';

/// Despawns physics-driven projectiles that collided with the static world.
///
/// This is intended for ballistic projectiles (arrows, thrown axes) that use
/// [BodyStore] + [CollisionSystem] for ground/wall collision. When a collision
/// occurs, the projectile is removed immediately (same tick).
class ProjectileWorldCollisionSystem {
  final List<EntityId> _toDespawn = <EntityId>[];

  void step(EcsWorld world) {
    final projectiles = world.projectile;
    if (projectiles.denseEntities.isEmpty) return;

    final collisions = world.collision;
    if (collisions.denseEntities.isEmpty) return;

    _toDespawn.clear();
    for (var pi = 0; pi < projectiles.denseEntities.length; pi += 1) {
      if (!projectiles.usePhysics[pi]) continue;

      final p = projectiles.denseEntities[pi];
      final ci = collisions.tryIndexOf(p);
      if (ci == null) continue;

      if (collisions.grounded[ci] ||
          collisions.hitCeiling[ci] ||
          collisions.hitLeft[ci] ||
          collisions.hitRight[ci]) {
        _toDespawn.add(p);
      }
    }

    for (final p in _toDespawn) {
      world.destroyEntity(p);
    }
  }
}



===== FILE: lib/core/ecs/systems/resource_regen_system.dart =====
import '../world.dart';

/// Periodically regenerates Health, Mana, and Stamina for all entities.
///
/// **Responsibilities**:
/// - Iterates over all entities with [Health], [Mana], or [Stamina].
/// - Applies regeneration rates (`regenPerSecond`) scaled by `dtSeconds`.
/// - Clamps values to `[0, Max]`.
///
/// **Performance**:
/// - Uses direct dense array iteration (Structure of Arrays) for cache efficiency.
/// - Skips full resources and zero-regen entities early.
class ResourceRegenSystem {
  ResourceRegenSystem({required int tickHz}) : _tickHz = tickHz;

  final int _tickHz;

  void step(EcsWorld world) {
    _regenHealth(world);
    _regenMana(world);
    _regenStamina(world);
  }

  void _regenHealth(EcsWorld world) {
    final store = world.health;
    final deathState = world.deathState;
    final count = store.denseEntities.length;
    // Iterate contiguous arrays directly (SoA pattern).
    for (var i = 0; i < count; i += 1) {
      if (deathState.has(store.denseEntities[i])) continue;
      final max = store.hpMax[i];
      if (max <= 0) continue;
      
      final current = store.hp[i];
      if (current >= max) continue;
      
      final regen = store.regenPerSecond100[i];
      if (regen <= 0) continue;

      final accum = store.regenAccumulator[i] + regen;
      final delta = accum ~/ _tickHz;
      if (delta > 0) {
        final next = current + delta;
        store.hp[i] = next > max ? max : next;
      }
      store.regenAccumulator[i] = accum - (delta * _tickHz);
    }
  }

  void _regenMana(EcsWorld world) {
    final store = world.mana;
    final deathState = world.deathState;
    final count = store.denseEntities.length;
    for (var i = 0; i < count; i += 1) {
      if (deathState.has(store.denseEntities[i])) continue;
      final max = store.manaMax[i];
      if (max <= 0) continue;
      
      final current = store.mana[i];
      if (current >= max) continue;
      
      final regen = store.regenPerSecond100[i];
      if (regen <= 0) continue;

      final accum = store.regenAccumulator[i] + regen;
      final delta = accum ~/ _tickHz;
      if (delta > 0) {
        final next = current + delta;
        store.mana[i] = next > max ? max : next;
      }
      store.regenAccumulator[i] = accum - (delta * _tickHz);
    }
  }

  void _regenStamina(EcsWorld world) {
    final store = world.stamina;
    final deathState = world.deathState;
    final count = store.denseEntities.length;
    for (var i = 0; i < count; i += 1) {
      if (deathState.has(store.denseEntities[i])) continue;
      final max = store.staminaMax[i];
      if (max <= 0) continue;
      
      final current = store.stamina[i];
      if (current >= max) continue;
      
      final regen = store.regenPerSecond100[i];
      if (regen <= 0) continue;

      final accum = store.regenAccumulator[i] + regen;
      final delta = accum ~/ _tickHz;
      if (delta > 0) {
        final next = current + delta;
        store.stamina[i] = next > max ? max : next;
      }
      store.regenAccumulator[i] = accum - (delta * _tickHz);
    }
  }
}


===== FILE: lib/core/ecs/systems/restoration_item_system.dart =====
import '../entity_id.dart';
import '../world.dart';
import '../stores/restoration_item_store.dart';
import '../../tuning/restoration_item_tuning.dart';
import '../../util/fixed_math.dart';

/// Handles the lifecycle and collision of restoration pickups (Health/Mana/Stamina potions).
///
/// **Responsibilities**:
/// - Despawns items that fall too far behind the camera.
/// - Checks for collision with the Player.
/// - Applies restoration effects and despawns on pickup.
class RestorationItemSystem {
  final List<EntityId> _toDespawn = <EntityId>[];

  /// Executes the system logic for a single frame.
  ///
  /// - [player]: The valid [EntityId] of the local player character.
  /// - [cameraLeft]: The X coordinate of the camera's left edge (used for culling).
  /// - [tuning]: Configuration values for pickup ranges and restore amounts.
  void step(
    EcsWorld world, {
    required EntityId player,
    required double cameraLeft,
    required RestorationItemTuning tuning,
  }) {
    final items = world.restorationItem;
    // Early exit if no items exist to process.
    if (items.denseEntities.isEmpty) return;
    
    _toDespawn.clear();
    final despawnLimit = cameraLeft - tuning.despawnBehindCameraMargin;

    // -- Resolve Player AABB (Optimization) --
    // We cache the player's world-space bounds once per frame.
    final transforms = world.transform;
    final colliders = world.colliderAabb;

    final pTi = transforms.tryIndexOf(player);
    final pCi = colliders.tryIndexOf(player);
    
    // Bounds: Min/Max X/Y
    double pMinX = 0, pMaxX = 0, pMinY = 0, pMaxY = 0;
    bool playerActive = false;

    if (pTi != null && pCi != null) {
      playerActive = true;
      final cx = transforms.posX[pTi] + colliders.offsetX[pCi];
      final cy = transforms.posY[pTi] + colliders.offsetY[pCi];
      final hx = colliders.halfX[pCi];
      final hy = colliders.halfY[pCi];
      pMinX = cx - hx;
      pMaxX = cx + hx;
      pMinY = cy - hy;
      pMaxY = cy + hy;
    }

    // -- Iterate Items --
    final count = items.denseEntities.length;
    for (var ii = 0; ii < count; ii += 1) {
      final e = items.denseEntities[ii];
      
      final ti = transforms.tryIndexOf(e);
      // Skip items that are missing spatial components (malformed entities).
      if (ti == null) continue;
      
      final ci = colliders.tryIndexOf(e);
      if (ci == null) continue;

      final cx = transforms.posX[ti] + colliders.offsetX[ci];
      
      // 1. Despawn Logic (Garbage Collection)
      if (cx < despawnLimit) {
        _toDespawn.add(e);
        continue;
      }

      // 2. Collision Check (Pickup)
      if (playerActive) {
        final cy = transforms.posY[ti] + colliders.offsetY[ci];
        final hx = colliders.halfX[ci];
        final hy = colliders.halfY[ci];

        // AABB Overlap Logic:
        final overlaps = (cx - hx) < pMaxX && 
                         (cx + hx) > pMinX && 
                         (cy - hy) < pMaxY && 
                         (cy + hy) > pMinY;

        if (overlaps) {
          _applyRestore(
            world,
            player: player,
            stat: items.stat[ii],
            percentBp: tuning.restorePercentBp,
          );
          _toDespawn.add(e);
        }
      }
    }

    // Process all despawns in batch at the end of the frame.
    for (final e in _toDespawn) {
      world.destroyEntity(e);
    }
  }

  /// RESTORES a specific stat on the target [player].
  ///
  /// - [percent]: Percentage of MAX value to restore (0.0 to 1.0).
  /// - Scales based on the player's Max HP/Mana/Stamina.
  /// - Clamps to Max value (prevents overhealing).
  void _applyRestore(
    EcsWorld world, {
    required EntityId player,
    required RestorationStat stat,
    required int percentBp,
  }) {
    // Note: We use min/max checks to ensure we don't overheal or divide by zero.
    switch (stat) {
      case RestorationStat.health:
        final index = world.health.tryIndexOf(player);
        if (index != null) {
          final max = world.health.hpMax[index];
          if (max > 0) {
            final restore = (max * percentBp) ~/ bpScale;
            final next = world.health.hp[index] + restore;
            world.health.hp[index] = next > max ? max : next;
          }
        }
      case RestorationStat.mana:
        final index = world.mana.tryIndexOf(player);
        if (index != null) {
          final max = world.mana.manaMax[index];
          if (max > 0) {
            final restore = (max * percentBp) ~/ bpScale;
            final next = world.mana.mana[index] + restore;
            world.mana.mana[index] = next > max ? max : next;
          }
        }
      case RestorationStat.stamina:
        final index = world.stamina.tryIndexOf(player);
        if (index != null) {
          final max = world.stamina.staminaMax[index];
          if (max > 0) {
            final restore = (max * percentBp) ~/ bpScale;
            final next = world.stamina.stamina[index] + restore;
            world.stamina.stamina[index] =
                next > max ? max : next;
          }
        }
    }
  }
}


===== FILE: lib/core/ecs/systems/self_ability_system.dart =====
import '../stores/self_intent_store.dart';
import '../world.dart';

/// Executes self abilities (parry, block, buffs) based on committed intents.
///
/// **Execution Only**:
/// - Reads committed intents (`tick == currentTick`).
/// - Applies effects (e.g., healing, buffs).
/// - Does **not** deduct resources or start cooldowns.
class SelfAbilitySystem {
  void step(EcsWorld world, {required int currentTick}) {
    final intents = world.selfIntent;
    if (intents.denseEntities.isEmpty) return;

    final count = intents.denseEntities.length;
    for (var ii = 0; ii < count; ii += 1) {
      final executeTick = intents.tick[ii];

      if (executeTick != currentTick) continue;

      // Invalidate now to ensure no double-execution in same tick
      _invalidateIntent(intents, ii);
    }
  }

  void _invalidateIntent(SelfIntentStore intents, int index) {
    intents.tick[index] = -1;
    intents.commitTick[index] = -1;
  }
}


===== FILE: lib/core/ecs/systems/status_system.dart =====
import '../../combat/damage.dart';
import '../../combat/damage_type.dart';
import '../../combat/status/status.dart';
import '../../events/game_event.dart';
import '../../util/tick_math.dart';
import '../../util/fixed_math.dart';
import '../entity_id.dart';
import '../stores/status/bleed_store.dart';
import '../stores/status/burn_store.dart';
import '../stores/status/slow_store.dart';
import '../../combat/control_lock.dart';
import '../world.dart';

/// Applies status effects and ticks active statuses.
class StatusSystem {
  StatusSystem({
    required int tickHz,
    StatusProfileCatalog profiles = const StatusProfileCatalog(),
  }) : _tickHz = tickHz,
       _profiles = profiles;

  final int _tickHz;
  final StatusProfileCatalog _profiles;

  final List<StatusRequest> _pending = <StatusRequest>[];
  final List<EntityId> _removeScratch = <EntityId>[];

  /// Current tick, set at the start of applyQueued.
  int _currentTick = 0;

  /// Queues a status profile to apply.
  void queue(StatusRequest request) {
    if (request.profileId == StatusProfileId.none) return;
    _pending.add(request);
  }

  /// Ticks existing statuses and queues DoT damage.
  void tickExisting(
    EcsWorld world,
  ) {
    _tickBurn(world);
    _tickBleed(world);
    _tickSlow(world);
  }

  /// Applies queued statuses and refreshes derived modifiers.
  void applyQueued(EcsWorld world, {required int currentTick}) {
    _currentTick = currentTick;
    if (_pending.isNotEmpty) {
      _applyPending(world);
      _pending.clear();
    }
    _refreshMoveSpeed(world);
  }

  void _tickBurn(
    EcsWorld world,
  ) {
    final burn = world.burn;
    if (burn.denseEntities.isEmpty) return;

    _removeScratch.clear();
    for (var i = 0; i < burn.denseEntities.length; i += 1) {
      final target = burn.denseEntities[i];
      if (world.deathState.has(target)) {
        _removeScratch.add(target);
        continue;
      }
      burn.ticksLeft[i] -= 1;
      if (burn.ticksLeft[i] <= 0) {
        _removeScratch.add(target);
        continue;
      }

      burn.periodTicksLeft[i] -= 1;
      if (burn.periodTicksLeft[i] <= 0) {
        burn.periodTicksLeft[i] = burn.periodTicks[i];
        final amount100 = (burn.dps100[i] * burn.periodTicks[i]) ~/ _tickHz;
        world.damageQueue.add(
          DamageRequest(
            target: target,
            amount100: amount100,
            damageType: DamageType.fire,
            sourceKind: DeathSourceKind.statusEffect,
          ),
        );
      }
    }
    for (final target in _removeScratch) {
      burn.removeEntity(target);
    }
  }

  void _tickBleed(
    EcsWorld world,
  ) {
    final bleed = world.bleed;
    if (bleed.denseEntities.isEmpty) return;

    _removeScratch.clear();
    for (var i = 0; i < bleed.denseEntities.length; i += 1) {
      final target = bleed.denseEntities[i];
      if (world.deathState.has(target)) {
        _removeScratch.add(target);
        continue;
      }
      bleed.ticksLeft[i] -= 1;
      if (bleed.ticksLeft[i] <= 0) {
        _removeScratch.add(target);
        continue;
      }

      bleed.periodTicksLeft[i] -= 1;
      if (bleed.periodTicksLeft[i] <= 0) {
        bleed.periodTicksLeft[i] = bleed.periodTicks[i];
        final amount100 = (bleed.dps100[i] * bleed.periodTicks[i]) ~/ _tickHz;
        world.damageQueue.add(
          DamageRequest(
            target: target,
            amount100: amount100,
            damageType: DamageType.bleed,
            sourceKind: DeathSourceKind.statusEffect,
          ),
        );
      }
    }
    for (final target in _removeScratch) {
      bleed.removeEntity(target);
    }
  }

  void _tickSlow(EcsWorld world) {
    final slow = world.slow;
    if (slow.denseEntities.isEmpty) return;

    _removeScratch.clear();
    for (var i = 0; i < slow.denseEntities.length; i += 1) {
      final target = slow.denseEntities[i];
      if (world.deathState.has(target)) {
        _removeScratch.add(target);
        continue;
      }
      slow.ticksLeft[i] -= 1;
      if (slow.ticksLeft[i] <= 0) {
        _removeScratch.add(target);
      }
    }
    for (final target in _removeScratch) {
      slow.removeEntity(target);
    }
  }

  void _applyPending(EcsWorld world) {
    final resistance = world.damageResistance;
    final immunity = world.statusImmunity;
    final invuln = world.invulnerability;

    for (final req in _pending) {
      if (world.deathState.has(req.target)) continue;
      if (!world.health.has(req.target)) continue;

      final ii = invuln.tryIndexOf(req.target);
      if (ii != null && invuln.ticksLeft[ii] > 0) continue;

      final profile = _profiles.get(req.profileId);
      if (profile.applications.isEmpty) continue;

      for (final app in profile.applications) {
        if (immunity.isImmune(req.target, app.type)) continue;

        var magnitude = app.magnitude;
        if (app.scaleByDamageType) {
          final modBp = resistance.modBpForEntity(req.target, req.damageType);
          if (modBp > 0) {
            magnitude = applyBp(magnitude, modBp);
          }
        }
        if (magnitude <= 0) continue;

        switch (app.type) {
          case StatusEffectType.slow:
            _applySlow(world, req.target, magnitude, app.durationSeconds);
          case StatusEffectType.burn:
            _applyDot(
              world,
              target: req.target,
              magnitude: magnitude,
              durationSeconds: app.durationSeconds,
              periodSeconds: app.periodSeconds,
              useBurn: true,
            );
          case StatusEffectType.bleed:
            _applyDot(
              world,
              target: req.target,
              magnitude: magnitude,
              durationSeconds: app.durationSeconds,
              periodSeconds: app.periodSeconds,
              useBurn: false,
            );
          case StatusEffectType.stun:
            _applyStun(world, req.target, magnitude, app.durationSeconds);
        }
      }
    }
  }

  void _applyStun(
    EcsWorld world,
    EntityId target,
    int magnitude,
    double durationSeconds,
  ) {
    // Stun requires statModifier for moveSpeedMul (and arguably any status effect target)
    if (!world.statModifier.has(target)) return;
    final durationTicks = ticksFromSecondsCeil(durationSeconds, _tickHz);
    if (durationTicks <= 0) return;

    // Add stun lock via ControlLockStore
    world.controlLock.addLock(target, LockFlag.stun, durationTicks, _currentTick);

    // Hard cancel active intents to prevent ghost execution
    if (world.meleeIntent.has(target)) {
      world.meleeIntent.tick[world.meleeIntent.indexOf(target)] = -1;
    }
    if (world.projectileIntent.has(target)) {
      world.projectileIntent.tick[world.projectileIntent.indexOf(target)] = -1;
    }
    if (world.selfIntent.has(target)) {
      world.selfIntent.tick[world.selfIntent.indexOf(target)] = -1;
    }
    // Cancel dash if active
    final mi = world.movement.tryIndexOf(target);
    if (mi != null && world.movement.dashTicksLeft[mi] > 0) {
      world.movement.dashTicksLeft[mi] = 0;
    }
  }

  void _applySlow(
    EcsWorld world,
    EntityId target,
    int magnitude,
    double durationSeconds,
  ) {
    if (!world.statModifier.has(target)) return;
    final ticksLeft = ticksFromSecondsCeil(durationSeconds, _tickHz);
    if (ticksLeft <= 0) return;

    final slow = world.slow;
    final clamped = clampInt(magnitude, 0, 9000);
    final index = slow.tryIndexOf(target);
    if (index == null) {
      slow.add(
        target,
        SlowDef(ticksLeft: ticksLeft, magnitude: clamped),
      );
    } else {
      final currentMagnitude = slow.magnitude[index];
      if (clamped > currentMagnitude) {
        slow.magnitude[index] = clamped;
        slow.ticksLeft[index] = ticksLeft;
      } else if (clamped == currentMagnitude) {
        if (ticksLeft > slow.ticksLeft[index]) {
          slow.ticksLeft[index] = ticksLeft;
        }
      }
    }
  }

  void _applyDot(
    EcsWorld world, {
    required EntityId target,
    required int magnitude,
    required double durationSeconds,
    required double periodSeconds,
    required bool useBurn,
  }) {
    final ticksLeft = ticksFromSecondsCeil(durationSeconds, _tickHz);
    if (ticksLeft <= 0) return;

    final periodTicks = periodSeconds <= 0.0
        ? 1
        : ticksFromSecondsCeil(periodSeconds, _tickHz);
    final dps100 = magnitude;

    if (useBurn) {
      final burn = world.burn;
      final index = burn.tryIndexOf(target);
      if (index == null) {
        burn.add(
          target,
          BurnDef(
            ticksLeft: ticksLeft,
            periodTicks: periodTicks,
            dps100: dps100,
          ),
        );
      } else {
        final currentDps = burn.dps100[index];
        if (dps100 > currentDps) {
          burn.dps100[index] = dps100;
          burn.periodTicks[index] = periodTicks;
          burn.periodTicksLeft[index] = periodTicks;
          burn.ticksLeft[index] = ticksLeft;
        } else if (dps100 == currentDps) {
          if (ticksLeft > burn.ticksLeft[index]) {
            burn.ticksLeft[index] = ticksLeft;
          }
        }
      }
      return;
    }

    final bleed = world.bleed;
    final index = bleed.tryIndexOf(target);
    if (index == null) {
      bleed.add(
        target,
        BleedDef(
          ticksLeft: ticksLeft,
          periodTicks: periodTicks,
          dps100: dps100,
        ),
      );
    } else {
      final currentDps = bleed.dps100[index];
      if (dps100 > currentDps) {
        bleed.dps100[index] = dps100;
        bleed.periodTicks[index] = periodTicks;
        bleed.periodTicksLeft[index] = periodTicks;
        bleed.ticksLeft[index] = ticksLeft;
      } else if (dps100 == currentDps) {
        if (ticksLeft > bleed.ticksLeft[index]) {
          bleed.ticksLeft[index] = ticksLeft;
        }
      }
    }
  }

  void _refreshMoveSpeed(EcsWorld world) {
    final mods = world.statModifier;
    if (mods.denseEntities.isEmpty) return;

    for (var i = 0; i < mods.denseEntities.length; i += 1) {
      mods.moveSpeedMul[i] = 1.0;
    }

    final slow = world.slow;
    if (slow.denseEntities.isEmpty) return;

    for (var i = 0; i < slow.denseEntities.length; i += 1) {
      final target = slow.denseEntities[i];
      final mi = mods.tryIndexOf(target);
      if (mi == null) continue;
      final slowBp = slow.magnitude[i];
      final multiplierBp = clampInt(bpScale - slowBp, 1000, bpScale);
      mods.moveSpeedMul[mi] = multiplierBp / bpScale;
    }
  }
}


===== FILE: lib/core/ecs/world.dart =====
import 'entity_id.dart';
import 'sparse_set.dart';
import 'stores/body_store.dart';
import 'stores/collider_aabb_store.dart';
import 'stores/collision_state_store.dart';
import 'stores/cooldown_store.dart';
import 'stores/projectile_intent_store.dart';
import 'stores/self_intent_store.dart';
import 'stores/combat/creature_tag_store.dart';
import 'stores/combat/damage_resistance_store.dart';
import 'stores/combat/equipped_loadout_store.dart';
import 'stores/combat/stat_modifier_store.dart';
import 'stores/combat/status_immunity_store.dart';
import 'stores/collectible_store.dart';
import 'stores/player/gravity_control_store.dart';
import 'stores/enemies/flying_enemy_steering_store.dart';
import 'stores/faction_store.dart';
import 'stores/anim/anim_state_store.dart';
import 'stores/active_ability_state_store.dart';
import 'stores/ability_input_buffer_store.dart';
import 'stores/enemies/enemy_store.dart';
import 'stores/enemies/ground_enemy_chase_offset_store.dart';
import 'stores/enemies/engagement_intent_store.dart';
import 'stores/enemies/melee_engagement_store.dart';
import 'stores/enemies/nav_intent_store.dart';
import 'stores/health_store.dart';
import 'stores/hit_once_store.dart';
import 'stores/hitbox_store.dart';
import 'stores/death_state_store.dart';
import 'stores/player/invulnerability_store.dart';
import 'stores/player/last_damage_store.dart';
import 'stores/lifetime_store.dart';
import 'stores/mana_store.dart';
import 'stores/melee_intent_store.dart';
import 'stores/mobility_intent_store.dart';
import 'stores/player/movement_store.dart';
import 'stores/player/player_input_store.dart';
import 'stores/projectile_store.dart';
import 'stores/restoration_item_store.dart';
import 'stores/status/bleed_store.dart';
import 'stores/status/burn_store.dart';
import 'stores/status/slow_store.dart';
import 'stores/control_lock_store.dart';
import 'stores/damage_queue_store.dart';
import 'stores/parry_consume_store.dart';
import 'stores/riposte_store.dart';
import 'stores/projectile_item_origin_store.dart';
import 'stores/stamina_store.dart';
import 'stores/enemies/surface_nav_state_store.dart';
import 'stores/transform_store.dart';

/// Minimal Entity Component System (ECS) world container.
///
/// The [EcsWorld] is the central hub of the ECS architecture. It manages the
/// creation and destruction of entities ([EntityId]) and acts as a registry
/// for all Component Stores.
///
/// Design philosophy:
/// - **Structure-of-Arrays (SoA):** Data is stored in parallel arrays within each
///   [SparseSet] component store, rather than as objects on the entity.
/// - **Composition over Inheritance:** Game objects are defined by the collection
///   of components they possess.
/// - **Pooling:** Entity IDs are recycled to keep memory usage compact and predictable.
///
/// To add functionality to the game, Systems (logic) query this World for Entities
/// with specific components and operate on them.
class EcsWorld {
  /// Creates a new ECS World with an optional [seed] for deterministic behavior.
  EcsWorld({int seed = 0}) : seed = seed;

  /// Seed used for deterministic RNG in the core, passed to components that need it.
  final int seed;

  /// Counter for generating new unique Entity IDs.
  EntityId _nextEntityId = 1;

  /// Pool of recycled Entity IDs available for reuse.
  final List<EntityId> _freeIds = <EntityId>[];

  /// Fast lookup set for recycled IDs to prevent double-freeing.
  final Set<EntityId> _freeIdsSet = <EntityId>{};

  /// Registry of all registered component stores.
  final List<SparseSet> _stores = <SparseSet>[];

  /// Helper to register a store with the world so it receives lifecycle events (like entity destruction).
  T _register<T extends SparseSet>(T store) {
    _stores.add(store);
    return store;
  }

  /// World-level damage request queue (shared across systems).
  final DamageQueueStore damageQueue = DamageQueueStore();

  /// Parry consumption tracker (per activation).
  final ParryConsumeStore parryConsume = ParryConsumeStore();

  // --- Component Stores ---
  // Each store manages a specific type of data for entities.

  /// Stores position (x, y) and velocity (vx, vy).
  late final TransformStore transform = _register(TransformStore());

  /// Helper components for handling user input events.
  late final PlayerInputStore playerInput = _register(PlayerInputStore());

  /// Buffered ability input for recovery-window handling.
  late final AbilityInputBufferStore abilityInputBuffer = _register(
    AbilityInputBufferStore(),
  );

  /// Logic and state for movement, including facing direction.
  late final MovementStore movement = _register(MovementStore());

  /// Physics properties like mass, friction, and restitution.
  late final BodyStore body = _register(BodyStore());

  /// Axis-Aligned Bounding Box (AABB) for collision detection.
  late final ColliderAabbStore colliderAabb = _register(ColliderAabbStore());

  /// Runtime state of collisions (e.g., is grounded, wall contact).
  late final CollisionStateStore collision = _register(CollisionStateStore());

  /// Generic cooldown timer for abilities or actions.
  late final CooldownStore cooldown = _register(CooldownStore());

  /// Tracks the player's intent to fire a projectile item (spell or throw).
  late final ProjectileIntentStore projectileIntent = _register(
    ProjectileIntentStore(),
  );

  /// Tracks the intent to use a self ability (parry, block, buff).
  late final SelfIntentStore selfIntent = _register(SelfIntentStore());

  /// Creature classification tags (humanoid, demon, etc.).
  late final CreatureTagStore creatureTag = _register(CreatureTagStore());

  /// Marks an entity as a collectible item (e.g., coin, power-up).
  late final CollectibleStore collectible = _register(CollectibleStore());

  /// Defines an item that restores stats (health/mana) when collected.
  late final RestorationItemStore restorationItem = _register(
    RestorationItemStore(),
  );

  /// Allows an entity to control or defy gravity.
  late final GravityControlStore gravityControl = _register(
    GravityControlStore(),
  );

  /// Defines which faction (Player, Enemy, Neutral) an entity belongs to.
  late final FactionStore faction = _register(FactionStore());

  /// Manages Health Points (HP) and max HP.
  late final HealthStore health = _register(HealthStore());

  /// Damage resistance/vulnerability modifiers.
  late final DamageResistanceStore damageResistance = _register(
    DamageResistanceStore(),
  );

  /// Grants temporary invulnerability (i-frames).
  late final InvulnerabilityStore invulnerability = _register(
    InvulnerabilityStore(),
  );

  /// Records the last entity/source that dealt damage to this entity.
  late final LastDamageStore lastDamage = _register(LastDamageStore());

  /// Tracks per-entity death lifecycle state.
  late final DeathStateStore deathState = _register(DeathStateStore());

  /// Status immunities (burn, slow, bleed).
  late final StatusImmunityStore statusImmunity = _register(
    StatusImmunityStore(),
  );

  /// Manages Mana Points (MP) and max MP.
  late final ManaStore mana = _register(ManaStore());

  /// Tracks the player's intent to perform a melee strike.
  late final MeleeIntentStore meleeIntent = _register(MeleeIntentStore());

  /// Tracks the player's intent to perform a mobility action (dash/roll).
  late final MobilityIntentStore mobilityIntent = _register(
    MobilityIntentStore(),
  );


  /// Unified loadout store (single source of truth for all equipment).
  late final EquippedLoadoutStore equippedLoadout = _register(
    EquippedLoadoutStore(),
  );

  /// Derived runtime stat modifiers (e.g., slows).
  late final StatModifierStore statModifier = _register(StatModifierStore());

  /// Manages Stamina Points (SP) and max SP.
  late final StaminaStore stamina = _register(StaminaStore());

  /// One-shot bonus granted by parry, consumed on the next landed melee hit.
  late final RiposteStore riposte = _register(RiposteStore());

  /// Marks an entity as a projectile and defines its properties.
  late final ProjectileStore projectile = _register(ProjectileStore());

  /// Defines an area that deals damage or effects on contact.
  late final HitboxStore hitbox = _register(HitboxStore());

  /// Ensures a hitbox only affects a target once per interaction.
  late final HitOnceStore hitOnce = _register(HitOnceStore());

  /// Despawns entities after a set duration.
  late final LifetimeStore lifetime = _register(LifetimeStore());

  /// Active burn DoT effects.
  late final BurnStore burn = _register(BurnStore());

  /// Active bleed DoT effects.
  late final BleedStore bleed = _register(BleedStore());

  /// Active slow effects.
  late final SlowStore slow = _register(SlowStore());

  /// Control locks for ability/action gating (stun, movement locks, etc.).
  late final ControlLockStore controlLock = _register(ControlLockStore());

  /// Links a projectile back to its originating projectile item.
  late final ProjectileItemOriginStore projectileItemOrigin = _register(
    ProjectileItemOriginStore(),
  );

  /// State for ground enemies navigating terrain (jumping gaps/walls).
  late final SurfaceNavStateStore surfaceNav = _register(
    SurfaceNavStateStore(),
  );

  /// Identifies an entity as a specific type of enemy.
  late final EnemyStore enemy = _register(EnemyStore());

  /// Per-entity animation state computed by [AnimSystem].
  late final AnimStateStore animState = _register(AnimStateStore());

  /// Tracks the currently active ability for animation purposes.
  late final ActiveAbilityStateStore activeAbility = _register(
    ActiveAbilityStateStore(),
  );

  /// Steering behaviors for flying enemies.
  late final FlyingEnemySteeringStore flyingEnemySteering = _register(
    FlyingEnemySteeringStore(),
  );

  /// AI state for ground enemies to create offset chasing behaviors.
  late final GroundEnemyChaseOffsetStore groundEnemyChaseOffset = _register(
    GroundEnemyChaseOffsetStore(),
  );

  /// Navigation intent output for ground enemies.
  late final NavIntentStore navIntent = _register(NavIntentStore());

  /// Engagement intent output for melee enemies.
  late final EngagementIntentStore engagementIntent = _register(
    EngagementIntentStore(),
  );

  /// Engagement state for melee enemies (approach/engage/strike/recover).
  late final MeleeEngagementStore meleeEngagement = _register(
    MeleeEngagementStore(),
  );

  /// Allocates a new [EntityId].
  ///
  /// Prefers reusing ID from the free pool if available; otherwise increments the counter.
  EntityId createEntity() {
    if (_freeIds.isNotEmpty) {
      final id = _freeIds.removeLast();
      _freeIdsSet.remove(id);
      return id;
    }
    final id = _nextEntityId;
    _nextEntityId += 1;
    return id;
  }

  /// Destroys [entity], removing it from all component stores.
  ///
  /// The ID is returned to the free pool for future reuse.
  /// Does nothing if the entity is already destroyed/free.
  void destroyEntity(EntityId entity) {
    if (_freeIdsSet.contains(entity)) {
      return;
    }
    for (final store in _stores) {
      store.removeEntity(entity);
    }
    parryConsume.removeEntity(entity);
    _freeIds.add(entity);
    _freeIdsSet.add(entity);
  }
}


===== FILE: lib/core/enemies/death_behavior.dart =====
/// Enemy death behavior configuration (data-driven).
library;

/// Determines how an enemy transitions from "killed" to final despawn.
enum DeathBehavior {
  /// Start the death animation immediately on kill.
  instant,

  /// If killed mid-air, fall until grounded before starting the death animation.
  groundImpactThenDeath,
}

/// Runtime death phase for enemies that are waiting to despawn.
enum DeathPhase {
  none,
  fallingUntilGround,
  deathAnim,
}



===== FILE: lib/core/enemies/enemy_catalog.dart =====
import '../ecs/stores/body_store.dart';
import '../ecs/stores/collider_aabb_store.dart';
import '../ecs/stores/combat/creature_tag_store.dart';
import '../ecs/stores/combat/damage_resistance_store.dart';
import '../ecs/stores/combat/status_immunity_store.dart';
import '../ecs/stores/health_store.dart';
import '../ecs/stores/mana_store.dart';
import '../ecs/stores/stamina_store.dart';
import '../combat/creature_tag.dart';
import '../anim/anim_resolver.dart';
import '../contracts/render_anim_set_definition.dart';
import 'death_behavior.dart';
import '../projectiles/projectile_item_id.dart';
import '../snapshots/enums.dart';
import '../util/vec2.dart';
import 'enemy_id.dart';

// -----------------------------------------------------------------------------
// Unoco Demon render animation strip definitions (authoring-time)
// -----------------------------------------------------------------------------

const int _unocoAnimFrameWidth = 81;
const int _unocoAnimFrameHeight = 71;

const int _unocoAnimIdleFrames = 4;
const double _unocoAnimIdleStepSeconds = 0.12;

const int _unocoAnimStunFrames = 4;
const double _unocoAnimStunStepSeconds = 0.12;

const int _unocoAnimMoveFrames = 4;
const double _unocoAnimMoveStepSeconds = 0.12;

const int _unocoAnimHitFrames = 4;
const double _unocoAnimHitStepSeconds = 0.10;

const int _unocoAnimDeathFrames = 7;
const double _unocoAnimDeathStepSeconds = 0.12;

const double _unocoHitAnimSeconds =
    _unocoAnimHitFrames * _unocoAnimHitStepSeconds;
const double _unocoDeathAnimSeconds =
    _unocoAnimDeathFrames * _unocoAnimDeathStepSeconds;

const Map<AnimKey, int> _unocoAnimFrameCountsByKey = <AnimKey, int>{
  AnimKey.idle: _unocoAnimIdleFrames,
  AnimKey.stun: _unocoAnimStunFrames,
  AnimKey.run: _unocoAnimMoveFrames,
  AnimKey.hit: _unocoAnimHitFrames,
  AnimKey.death: _unocoAnimDeathFrames,
};

const Map<AnimKey, double> _unocoAnimStepTimeSecondsByKey = <AnimKey, double>{
  AnimKey.idle: _unocoAnimIdleStepSeconds,
  AnimKey.stun: _unocoAnimStunStepSeconds,
  AnimKey.run: _unocoAnimMoveStepSeconds,
  AnimKey.hit: _unocoAnimHitStepSeconds,
  AnimKey.death: _unocoAnimDeathStepSeconds,
};

const Map<AnimKey, String> _unocoAnimSourcesByKey = <AnimKey, String>{
  AnimKey.idle: 'entities/enemies/unoco/flying.png',
  AnimKey.stun: 'entities/enemies/unoco/stun.png',
  AnimKey.run: 'entities/enemies/unoco/flying.png',
  AnimKey.hit: 'entities/enemies/unoco/hit.png',
  AnimKey.death: 'entities/enemies/unoco/death.png',
};

const RenderAnimSetDefinition _unocoRenderAnim = RenderAnimSetDefinition(
  frameWidth: _unocoAnimFrameWidth,
  frameHeight: _unocoAnimFrameHeight,
  sourcesByKey: _unocoAnimSourcesByKey,
  frameCountsByKey: _unocoAnimFrameCountsByKey,
  stepTimeSecondsByKey: _unocoAnimStepTimeSecondsByKey,
);

const AnimProfile _unocoAnimProfile = AnimProfile(
  minMoveSpeed: 1.0,
  runSpeedThresholdX: 0.0,
  supportsWalk: false,
  supportsJumpFall: false,
  supportsStun: true,
  strikeAnimKey: AnimKey.idle,
);

// -----------------------------------------------------------------------------
// grojib (ground enemy) render animation sheet definitions (authoring-time)
// -----------------------------------------------------------------------------

const int _grojibAnimFrameWidth = 108;
const int _grojibAnimFrameHeight = 59;

const int _grojibAnimIdleFrames = 8;
const double _grojibAnimIdleStepSeconds = 0.14;

const int _grojibAnimStunFrames = 8;
const double _grojibAnimStunStepSeconds = 0.14;

const int _grojibAnimMoveFrames = 8;
const double _grojibAnimMoveStepSeconds = 0.08;

const int _grojibAnimWalkFrames = _grojibAnimMoveFrames;
const double _grojibAnimWalkStepSeconds = _grojibAnimMoveStepSeconds;

const int _grojibAnimHitFrames = 3;
const double _grojibAnimHitStepSeconds = 0.10;

const int _grojibAnimDeathFrames = 12;
const double _grojibAnimDeathStepSeconds = 0.12;

// The authored sheet has 20 columns on the strike row:
// - frames 1..8  = Strike
// - frames 9..20 = Strike2
// Core only exposes AnimKey.strike, so we treat the full row as one animation.
const int _grojibAnimStrikeFrames = 8;
const double _grojibAnimStrikeStepSeconds = 0.06;

const int _grojibAnimJumpFrames = 3;
const double _grojibAnimJumpStepSeconds = 0.10;

const int _grojibAnimFallFrames = 3;
const double _grojibAnimFallStepSeconds = 0.10;
const double _grojibHitAnimSeconds =
    _grojibAnimHitFrames * _grojibAnimHitStepSeconds;
const double _grojibDeathAnimSeconds =
    _grojibAnimDeathFrames * _grojibAnimDeathStepSeconds;

const Map<AnimKey, int> _grojibAnimFrameCountsByKey = <AnimKey, int>{
  AnimKey.idle: _grojibAnimIdleFrames,
  AnimKey.stun: _grojibAnimStunFrames,
  AnimKey.run: _grojibAnimMoveFrames,
  AnimKey.walk: _grojibAnimWalkFrames,
  AnimKey.strike: _grojibAnimStrikeFrames,
  AnimKey.hit: _grojibAnimHitFrames,
  AnimKey.death: _grojibAnimDeathFrames,
  AnimKey.jump: _grojibAnimJumpFrames,
  AnimKey.fall: _grojibAnimFallFrames,
};

const Map<AnimKey, double> _grojibAnimStepTimeSecondsByKey = <AnimKey, double>{
  AnimKey.idle: _grojibAnimIdleStepSeconds,
  AnimKey.stun: _grojibAnimStunStepSeconds,
  AnimKey.run: _grojibAnimMoveStepSeconds,
  AnimKey.walk: _grojibAnimWalkStepSeconds,
  AnimKey.strike: _grojibAnimStrikeStepSeconds,
  AnimKey.hit: _grojibAnimHitStepSeconds,
  AnimKey.death: _grojibAnimDeathStepSeconds,
  AnimKey.jump: _grojibAnimJumpStepSeconds,
  AnimKey.fall: _grojibAnimFallStepSeconds,
};

const String _grojibAnimSpriteSheetPath = 'entities/enemies/grojib/grojib.png';

const Map<AnimKey, String> _grojibAnimSourcesByKey = <AnimKey, String>{
  AnimKey.idle: _grojibAnimSpriteSheetPath,
  AnimKey.stun: _grojibAnimSpriteSheetPath,
  AnimKey.run: _grojibAnimSpriteSheetPath,
  AnimKey.walk: _grojibAnimSpriteSheetPath,
  AnimKey.strike: _grojibAnimSpriteSheetPath,
  AnimKey.hit: _grojibAnimSpriteSheetPath,
  AnimKey.death: _grojibAnimSpriteSheetPath,
  AnimKey.jump: _grojibAnimSpriteSheetPath,
  AnimKey.fall: _grojibAnimSpriteSheetPath,
};

const Map<AnimKey, int> _grojibAnimRowByKey = <AnimKey, int>{
  AnimKey.idle: 0,
  AnimKey.stun: 0,
  AnimKey.run: 1,
  AnimKey.walk: 1,
  AnimKey.strike: 2,
  AnimKey.hit: 3,
  AnimKey.death: 4,
  AnimKey.jump: 5,
  AnimKey.fall: 7,
};

const RenderAnimSetDefinition _grojibRenderAnim = RenderAnimSetDefinition(
  frameWidth: _grojibAnimFrameWidth,
  frameHeight: _grojibAnimFrameHeight,
  sourcesByKey: _grojibAnimSourcesByKey,
  rowByKey: _grojibAnimRowByKey,
  anchorInFramePx: Vec2(77, _grojibAnimFrameHeight * 0.5),
  frameCountsByKey: _grojibAnimFrameCountsByKey,
  stepTimeSecondsByKey: _grojibAnimStepTimeSecondsByKey,
);

const AnimProfile _grojibAnimProfile = AnimProfile(
  minMoveSpeed: 1.0,
  runSpeedThresholdX: 120.0,
  supportsStun: true,
);

/// Defines the base stats and physics properties for an enemy type.
///
/// This data is "static" (read-only) configuration used to initialize
/// the ECS components effectively when an enemy spawns.
class EnemyArchetype {
  const EnemyArchetype({
    required this.body,
    required this.collider,
    required this.health,
    required this.mana,
    required this.stamina,
    required this.renderAnim,
    required this.animProfile,
    required this.hitAnimSeconds,
    required this.deathAnimSeconds,
    this.deathBehavior = DeathBehavior.instant,
    this.primaryProjectileItemId,
    this.artFacingDir = Facing.left,
    this.tags = const CreatureTagDef(),
    this.resistance = const DamageResistanceDef(),
    this.statusImmunity = const StatusImmunityDef(),
  });

  /// Physics configuration (Gravity, Constraints, Kinematics).
  final BodyDef body;

  /// Hitbox size (Collision).
  final ColliderAabbDef collider;

  /// Vitals (HP, Mana, Stamina) configuration.
  final HealthDef health;
  final ManaDef mana;
  final StaminaDef stamina;

  /// Render-only animation metadata (strip paths, frame size, timing).
  final RenderAnimSetDefinition renderAnim;

  /// Core animation profile (movement thresholds and supported keys).
  final AnimProfile animProfile;

  /// Duration the hit animation should be visible (seconds).
  final double hitAnimSeconds;

  /// Duration the death animation should be visible (seconds).
  final double deathAnimSeconds;

  /// Behavior for death transition timing (instant vs ground impact).
  final DeathBehavior deathBehavior;

  /// Optional primary projectile item for this enemy.
  ///
  /// When present, the [EnemyCastSystem] will use this to write projectile intents.
  final ProjectileItemId? primaryProjectileItemId;

  /// Direction the authored art faces when not mirrored.
  ///
  /// Most sprites face right by default, but some packs are authored facing
  /// left. The renderer uses this to mirror correctly based on logical [Facing].
  final Facing artFacingDir;

  /// Broad tags used by combat rules and content filters.
  final CreatureTagDef tags;

  /// Resistance/vulnerability modifiers by damage type.
  final DamageResistanceDef resistance;

  /// Status effect immunities for this enemy.
  final StatusImmunityDef statusImmunity;
}

/// Central registry for Enemy Definitions.
///
/// **Usage**:
/// - Accessed by `EnemySpawnSystem` (or similar) to hydration entities.
/// - Decouples "What an enemy is" from "How to spawn it".
class EnemyCatalog {
  const EnemyCatalog();

  /// Returns the static archetype definition for a given [EnemyId].
  ///
  /// Note: The returned objects are `const` and allocation-light.
  EnemyArchetype get(EnemyId id) {
    switch (id) {
      case EnemyId.unocoDemon:
        return const EnemyArchetype(
          body: BodyDef(
            isKinematic: false,
            useGravity: false,
            gravityScale: 0.0,
            sideMask: BodyDef.sideNone,
            maxVelX: 800.0,
            maxVelY: 800.0,
          ),
          collider: ColliderAabbDef(halfX: 12.0, halfY: 12.0),
          health: HealthDef(hp: 2000, hpMax: 2000, regenPerSecond100: 50),
          mana: ManaDef(mana: 8000, manaMax: 8000, regenPerSecond100: 500),
          stamina: StaminaDef(stamina: 0, staminaMax: 0, regenPerSecond100: 0),
          renderAnim: _unocoRenderAnim,
          animProfile: _unocoAnimProfile,
          hitAnimSeconds: _unocoHitAnimSeconds,
          deathAnimSeconds: _unocoDeathAnimSeconds,
          deathBehavior: DeathBehavior.instant,
          primaryProjectileItemId: ProjectileItemId.thunderBolt,
          artFacingDir: Facing.left,
          tags: CreatureTagDef(
            mask: CreatureTagMask.flying | CreatureTagMask.demon,
          ),
          resistance: DamageResistanceDef(fireBp: -5000, iceBp: 5000),
        );

      case EnemyId.grojib:
        return const EnemyArchetype(
          body: BodyDef(
            isKinematic: false,
            useGravity: true,
            ignoreCeilings: true,
            gravityScale: 1.0,
            sideMask: BodyDef.sideLeft | BodyDef.sideRight,
          ),
          collider: ColliderAabbDef(
            halfX: 25.0,
            halfY: 25.0,
            offsetX: 0.0,
            offsetY: 20.0,
          ),
          health: HealthDef(hp: 2000, hpMax: 2000, regenPerSecond100: 50),
          mana: ManaDef(mana: 0, manaMax: 0, regenPerSecond100: 0),
          stamina: StaminaDef(stamina: 0, staminaMax: 0, regenPerSecond100: 0),
          renderAnim: _grojibRenderAnim,
          animProfile: _grojibAnimProfile,
          hitAnimSeconds: _grojibHitAnimSeconds,
          deathAnimSeconds: _grojibDeathAnimSeconds,
          deathBehavior: DeathBehavior.groundImpactThenDeath,
          tags: CreatureTagDef(mask: CreatureTagMask.humanoid),
        );
    }
  }
}


===== FILE: lib/core/enemies/enemy_id.dart =====
/// Unique identifiers for enemy types.
///
/// **Usage**:
/// - Used for spawning via `SpawnSystem`.
/// - keys for `EnemyCatalog` lookup.
/// - Stable identifiers for networking/snapshots (protocol-stable).
enum EnemyId {
  /// A flying demon enemy that ignores gravity and casts spells.
  unocoDemon,

  /// A basic ground chasing enemy that is affected by gravity.
  grojib,
}



===== FILE: lib/core/enemies/enemy_killed_info.dart =====
library;

import '../snapshots/enums.dart';
import '../util/vec2.dart';
import 'enemy_id.dart';

/// Minimal data captured at the moment an enemy is killed.
///
/// Used to emit render/UI events (e.g. play a death animation) even though the
/// enemy entity is despawned immediately by Core.
class EnemyKilledInfo {
  const EnemyKilledInfo({
    required this.enemyId,
    required this.pos,
    required this.facing,
    required this.artFacingDir,
  });

  final EnemyId enemyId;
  final Vec2 pos;
  final Facing facing;
  final Facing artFacingDir;
}


===== FILE: lib/core/events/enemy_events.dart =====
part of 'game_event.dart';

/// Emitted when an enemy is killed (HP reaches 0 and the entity despawns).
///
/// This exists because Core typically despawns dead enemies immediately, so the
/// renderer would otherwise have no chance to play a death animation.
class EnemyKilledEvent extends GameEvent {
  const EnemyKilledEvent({
    required this.tick,
    required this.enemyId,
    required this.pos,
    required this.facing,
    required this.artFacingDir,
  });

  /// Simulation tick when the kill occurred.
  final int tick;

  final EnemyId enemyId;
  final Vec2 pos;
  final Facing facing;
  final Facing artFacingDir;
}


===== FILE: lib/core/events/game_event.dart =====
/// Core -> Render/UI event model.
///
/// **Architecture**:
/// - "Events" in this context are **transient side effects** emitted by the simulation.
/// - Examples: SFX triggers, Particle spawns, Run completion, Screen shake.
/// - They are distinct from "State" (Snapshots). State is continuous; Events are discrete.
///
/// **Usage**:
/// - Systems emit events into a queue.
/// - The GameController or UI layer consumes them (e.g., to play a sound or show a dialog).
/// - Events are fire-and-forget.
library;
import '../enemies/enemy_id.dart';
import '../projectiles/projectile_id.dart';
import '../snapshots/enums.dart';
import '../projectiles/projectile_item_id.dart';
import '../util/vec2.dart';

part 'run_events.dart';
part 'enemy_events.dart';
part 'projectile_events.dart';

/// Base sealed class for all simulation events.
sealed class GameEvent {
  const GameEvent();
}


===== FILE: lib/core/events/projectile_events.dart =====
part of 'game_event.dart';

/// Emitted when a projectile hits a damageable target.
///
/// Used by the renderer to spawn impact VFX even though the projectile entity
/// is despawned immediately in Core.
class ProjectileHitEvent extends GameEvent {
  const ProjectileHitEvent({
    required this.tick,
    required this.projectileId,
    required this.pos,
    required this.facing,
    required this.rotationRad,
    this.projectileItemId,
  });

  /// Simulation tick when the hit occurred.
  final int tick;

  final ProjectileId projectileId;
  final ProjectileItemId? projectileItemId;
  final Vec2 pos;
  final Facing facing;
  final double rotationRad;
}


===== FILE: lib/core/events/run_events.dart =====
part of 'game_event.dart';

/// The specific cause for a run ending.
enum RunEndReason {
  /// Player was too slow and scrolled off the screen.
  fellBehindCamera,
  
  /// Player fell into a death pit.
  fellIntoGap,
  
  /// HP reached 0 (combat death).
  playerDied,
  
  /// User manually exited the run.
  gaveUp,
}

/// Identifies the category of damage source that caused death.
enum DeathSourceKind {
  projectile,
  meleeHitbox,
  statusEffect,
  unknown,
}

/// Detailed context about what killed the player.
class DeathInfo {
  const DeathInfo({
    required this.kind,
    this.enemyId,
    this.projectileId,
    this.projectileItemId,
  });

  /// Category of the damage source.
  final DeathSourceKind kind;
  
  /// The [EnemyId] responsible (if applicable).
  final EnemyId? enemyId;
  
  /// The [ProjectileId] responsible (if applicable).
  final ProjectileId? projectileId;
  
  /// The [ProjectileItemId] responsible (if applicable).
  final ProjectileItemId? projectileItemId;
}

/// Aggregate statistics collected during a run.
class RunEndStats {
  const RunEndStats({
    required this.collectibles,
    required this.collectibleScore,
    required this.enemyKillCounts,
  });

  /// Total count of collectibles picked up.
  final int collectibles;
  
  /// Total score value of collectibles.
  final int collectibleScore;

  /// Kill counts per enemy type.
  ///
  /// **Ordering**: Indices strictly align with [EnemyId.values].
  /// `enemyKillCounts[i]` corresponds to the kills for the enemy at `EnemyId.values[i]`.
  final List<int> enemyKillCounts;
}

/// Event emitted when the game session terminates.
///
/// Contains all necessary data to display the "Game Over" screen.
class RunEndedEvent extends GameEvent {
  const RunEndedEvent({
    required this.tick,
    required this.distance,
    required this.reason,
    required this.stats,
    this.deathInfo,
  });

  /// The tick on which the run ended.
  final int tick;
  
  /// Total distance traveled (meters/pixels).
  final double distance;
  
  /// Why the run ended (Death vs GiveUp).
  final RunEndReason reason;
  
  /// Performance stats.
  final RunEndStats stats;
  
  /// Details on the lethal hit (if applicable).
  final DeathInfo? deathInfo;
}


===== FILE: lib/core/game_core.dart =====
/// Authoritative, deterministic simulation layer (pure Dart).
///
/// This is the heart of the game—a pure Dart simulation that processes
/// tick-stamped commands, advances physics and AI, and produces immutable
/// snapshots for the renderer/UI. By keeping this layer Flutter/Flame-free,
/// we gain:
/// - **Testability**: Unit tests can run headless at any tick rate.
/// - **Determinism**: Same seed + commands = identical simulation.
/// - **Portability**: Core logic could run on a server for validation.
///
/// ## Architecture Overview
///
/// ```
/// Commands (from input layer)
///         ↓
///    GameCore.applyCommands()
///         ↓
///    GameCore.stepOneTick()
///         ↓
///    [Track streaming → Physics → AI → Combat → Cleanup]
///         ↓
///    GameStateSnapshot (to render layer)
/// ```
///
/// ## Module Dependencies
///
/// [GameCore] orchestrates three extracted modules:
/// - [TrackManager]: Procedural chunk generation, geometry lifecycle.
/// - [SpawnService]: Deterministic entity spawning (enemies, items).
/// - [SnapshotBuilder]: ECS → render snapshot conversion.
///
/// ## ECS System Execution Order
///
/// Systems run in a carefully ordered pipeline each tick:
/// 1. **Track streaming**: Spawn/cull chunks based on camera.
/// 2. **Cooldowns & invulnerability**: Decrement timers.
/// 3. **Enemy AI steering**: Path planning and movement intent.
/// 4. **Player input**: Resolve ability intents (including mobility).
/// 5. **Player movement**: Apply input to velocity.
/// 6. **Mobility execution**: Apply dash/roll state.
/// 7. **Gravity**: Apply gravity to non-kinematic bodies.
/// 8. **Collision**: Resolve static world collisions.
/// 9. **Pickups**: Collect items overlapping player.
/// 10. **Broadphase rebuild**: Update spatial grid for hit detection.
/// 11. **Projectile movement**: Advance existing projectiles.
/// 12. **Strike intents**: Enemies and player queue strikes.
/// 13. **Strike execution**: Spawn hitboxes/projectiles/self abilities.
/// 14. **Hitbox positioning**: Follow owner entities.
/// 15. **Hit resolution**: Detect overlaps, queue damage.
/// 16. **Status ticking**: Apply DoT ticks and queue damage.
/// 17. **Damage middleware**: Apply combat rule edits/cancellations.
/// 18. **Damage application**: Apply queued damage, set invulnerability.
/// 19. **Status application**: Apply on-hit status profiles.
/// 20. **Death handling**: Despawn dead entities, record kills.
/// 21. **Resource regen**: Regenerate mana/stamina.
/// 22. **Lifetime cleanup**: Remove expired entities.
///
/// ## Determinism Contract
///
/// Given identical inputs:
/// - Same [seed] parameter
/// - Same sequence of [Command]s with same tick stamps
/// - Same [tickHz]
///
/// The simulation will produce identical results across runs and platforms.
/// This is achieved by:
/// - Using [DeterministicRng] instead of `dart:math Random`
/// - Fixed-point-style tick math (no frame-rate-dependent dt accumulation)
/// - Deterministic iteration order (entity IDs, not hash-based)
library;

import 'dart:math';

import 'camera/autoscroll_camera.dart';
import 'abilities/ability_catalog.dart';
import 'abilities/ability_def.dart';
import 'combat/middleware/parry_middleware.dart';
import 'collision/static_world_geometry_index.dart';
import 'commands/command.dart';
import 'contracts/render_contract.dart';
import 'ecs/entity_factory.dart';
import 'ecs/entity_id.dart';
import 'ecs/spatial/broadphase_grid.dart';
import 'ecs/spatial/grid_index_2d.dart';
import 'ecs/stores/restoration_item_store.dart';
import 'ecs/systems/collectible_system.dart';
import 'ecs/systems/collision_system.dart';
import 'ecs/systems/cooldown_system.dart';
import 'ecs/systems/damage_middleware_system.dart';
import 'ecs/systems/damage_system.dart';
import 'ecs/systems/active_ability_phase_system.dart';
import 'ecs/systems/death_despawn_system.dart';
import 'ecs/systems/enemy_cast_system.dart';
import 'ecs/systems/enemy_death_state_system.dart';
import 'ecs/systems/enemy_engagement_system.dart';
import 'ecs/systems/flying_enemy_locomotion_system.dart';
import 'ecs/systems/ground_enemy_locomotion_system.dart';
import 'ecs/systems/enemy_navigation_system.dart';
import 'ecs/systems/gravity_system.dart';
import 'ecs/systems/health_despawn_system.dart';
import 'ecs/systems/hitbox_damage_system.dart';
import 'ecs/systems/hitbox_follow_owner_system.dart';
import 'ecs/systems/invulnerability_system.dart';
import 'ecs/systems/lifetime_system.dart';
import 'ecs/systems/melee_strike_system.dart';
import 'ecs/systems/ability_activation_system.dart';
import 'ecs/systems/mobility_system.dart';
import 'ecs/systems/player_movement_system.dart';
import 'ecs/systems/projectile_hit_system.dart';
import 'ecs/systems/projectile_system.dart';
import 'ecs/systems/projectile_world_collision_system.dart';
import 'ecs/systems/projectile_launch_system.dart';
import 'ecs/systems/resource_regen_system.dart';
import 'ecs/systems/restoration_item_system.dart';
import 'ecs/systems/self_ability_system.dart';
import 'ecs/systems/status_system.dart';
import 'ecs/systems/control_lock_system.dart';
import 'ecs/systems/anim/anim_system.dart';
import 'ecs/systems/enemy_cull_system.dart';
import 'ecs/systems/enemy_melee_system.dart';
import 'ecs/world.dart';
import 'enemies/enemy_catalog.dart';
import 'enemies/enemy_id.dart';
import 'events/game_event.dart';
import 'levels/level_definition.dart';
import 'levels/level_id.dart';
import 'levels/level_registry.dart';
import 'navigation/surface_graph_builder.dart';
import 'navigation/surface_navigator.dart';
import 'navigation/surface_pathfinder.dart';
import 'navigation/utils/jump_template.dart';
import 'navigation/utils/trajectory_predictor.dart';
import 'players/player_catalog.dart';
import 'players/player_character_definition.dart';
import 'players/player_character_registry.dart';
import 'projectiles/projectile_catalog.dart';
import 'snapshots/enums.dart';
import 'snapshots/game_state_snapshot.dart';
import 'snapshot_builder.dart';
import 'spawn_service.dart';
import 'projectiles/projectile_item_catalog.dart';
import 'projectiles/projectile_item_id.dart';
import 'track_manager.dart';
import 'weapons/weapon_catalog.dart';
import 'ecs/stores/combat/equipped_loadout_store.dart';
import 'tuning/camera_tuning.dart';
import 'tuning/collectible_tuning.dart';
import 'tuning/core_tuning.dart';
import 'tuning/flying_enemy_tuning.dart';
import 'tuning/ground_enemy_tuning.dart';
import 'tuning/navigation_tuning.dart';
import 'tuning/physics_tuning.dart';
import 'players/player_tuning.dart';
import 'tuning/restoration_item_tuning.dart';
import 'tuning/score_tuning.dart';
import 'tuning/spatial_grid_tuning.dart';
import 'tuning/track_tuning.dart';
import 'util/tick_math.dart';

// ─────────────────────────────────────────────────────────────────────────────
// GameCore - Main simulation coordinator
// ─────────────────────────────────────────────────────────────────────────────

/// Deterministic game simulation core.
///
/// This class is the central coordinator for the game simulation. It:
/// - Owns the [EcsWorld] and all ECS systems.
/// - Processes player [Command]s each tick.
/// - Steps physics, AI, and combat systems in order.
/// - Produces [GameStateSnapshot]s for the render layer.
/// - Emits [GameEvent]s for UI feedback (run ended, etc.).
///
/// ## Usage
///
/// ```dart
/// final core = GameCore(seed: 42);
/// core.applyCommands([JumpPressedCommand()]);
/// core.stepOneTick();
/// final snapshot = core.buildSnapshot();
/// final events = core.drainEvents();
/// ```
///
/// ## Custom Configuration
///
/// Use [CoreTuning] to customize world/level parameters:
/// ```dart
/// final core = GameCore(
///   seed: 123,
///   tuning: CoreTuning(track: TrackTuning(enabled: false)),
/// );
/// ```
///
/// Use [PlayerCharacterDefinition] to select player-specific tuning + collider:
/// ```dart
/// final core = GameCore(
///   seed: 123,
///   playerCharacter: PlayerCharacterRegistry.eloise,
/// );
/// ```
///
/// Use [LevelDefinition] to select a level configuration:
/// ```dart
/// final core = GameCore(
///   seed: 123,
///   levelDefinition: LevelRegistry.byId(LevelId.defaultLevel),
/// );
/// ```
class GameCore {
  static LevelDefinition _resolveLevelDefinition({
    required CoreTuning tuning,
    required StaticWorldGeometry staticWorldGeometry,
    LevelDefinition? levelDefinition,
  }) {
    if (levelDefinition != null) return levelDefinition;
    final base = LevelRegistry.defaultLevel;
    return LevelDefinition(
      id: base.id,
      patternPool: base.patternPool,
      earlyPatternChunks: base.earlyPatternChunks,
      noEnemyChunks: base.noEnemyChunks,
      themeId: base.themeId,
      tuning: tuning,
      staticWorldGeometry: staticWorldGeometry,
    );
  }

  /// Creates a new game simulation with the given configuration.
  ///
  /// Parameters:
  /// - [seed]: Master RNG seed for deterministic generation.
  /// - [tickHz]: Fixed tick rate (default 60). Higher = smoother but more CPU.
  /// - [tuning]: Aggregate tuning configuration (see [CoreTuning]).
  /// - Catalogs: Entity archetype definitions (spells, enemies, etc.).
  /// - [staticWorldGeometry]: Base level geometry (ground, initial platforms).
  /// - [levelDefinition]: Optional level config. When provided, its tuning,
  ///   static geometry, and pattern pools are used (and [tuning] /
  ///   [staticWorldGeometry] are ignored).
  GameCore({
    required int seed,
    int tickHz = defaultTickHz,
    CoreTuning tuning = const CoreTuning(),
    PlayerCharacterDefinition playerCharacter =
        PlayerCharacterRegistry.defaultCharacter,
    ProjectileItemCatalog projectileItemCatalog = const ProjectileItemCatalog(),
    ProjectileCatalog projectileCatalog = const ProjectileCatalog(),
    EnemyCatalog enemyCatalog = const EnemyCatalog(),
    WeaponCatalog weaponCatalog = const WeaponCatalog(),
    StaticWorldGeometry staticWorldGeometry = const StaticWorldGeometry(
      groundPlane: StaticGroundPlane(topY: groundTopY * 1.0),
    ),
    LevelDefinition? levelDefinition,
  }) : this._fromLevel(
         seed: seed,
         tickHz: tickHz,
         levelDefinition: _resolveLevelDefinition(
           levelDefinition: levelDefinition,
           tuning: tuning,
           staticWorldGeometry: staticWorldGeometry,
         ),
         projectileItemCatalog: projectileItemCatalog,
         projectileCatalog: projectileCatalog,
         enemyCatalog: enemyCatalog,
         playerCharacter: playerCharacter,
         weaponCatalog: weaponCatalog,
       );

  GameCore._fromLevel({
    required this.seed,
    required this.tickHz,
    required LevelDefinition levelDefinition,
    required ProjectileItemCatalog projectileItemCatalog,
    required ProjectileCatalog projectileCatalog,
    required EnemyCatalog enemyCatalog,
    required PlayerCharacterDefinition playerCharacter,
    required WeaponCatalog weaponCatalog,
  }) : _levelDefinition = levelDefinition,
       _movement = MovementTuningDerived.from(
         playerCharacter.tuning.movement,
         tickHz: tickHz,
       ),
       _physicsTuning = levelDefinition.tuning.physics,
       _resourceTuning = ResourceTuningDerived.from(
         playerCharacter.tuning.resource,
       ),
       _abilities = AbilityTuningDerived.from(
         playerCharacter.tuning.ability,
         tickHz: tickHz,
       ),
       _animTuning = AnimTuningDerived.from(
         playerCharacter.tuning.anim,
         tickHz: tickHz,
       ),
       _combat = CombatTuningDerived.from(
         playerCharacter.tuning.combat,
         tickHz: tickHz,
       ),
       _unocoDemonTuning = UnocoDemonTuningDerived.from(
         levelDefinition.tuning.unocoDemon,
         tickHz: tickHz,
       ),
       _groundEnemyTuning = GroundEnemyTuningDerived.from(
         levelDefinition.tuning.groundEnemy,
         tickHz: tickHz,
       ),
       _navigationTuning = levelDefinition.tuning.navigation,
       _spatialGridTuning = levelDefinition.tuning.spatialGrid,
       _projectileItems = projectileItemCatalog,
       _projectiles = ProjectileCatalogDerived.from(
         projectileCatalog,
         tickHz: tickHz,
       ),
       _enemyCatalog = enemyCatalog,
       _playerCharacter = playerCharacter,
       _weapons = weaponCatalog,
       _scoreTuning = levelDefinition.tuning.score,
       _trackTuning = levelDefinition.tuning.track,
       _collectibleTuning = levelDefinition.tuning.collectible,
       _restorationItemTuning = levelDefinition.tuning.restorationItem {
    _initializeWorld(levelDefinition);
  }

  /// Common initialization shared by all constructors.
  void _initializeWorld(LevelDefinition levelDefinition) {
    final staticWorldGeometry = levelDefinition.staticWorldGeometry;
    final cameraTuning = levelDefinition.tuning.camera;
    // ─── Initialize ECS world and entity factory ───
    _world = EcsWorld(seed: seed);
    _entityFactory = EntityFactory(_world);

    // ─── Initialize all ECS systems ───
    _initializeSystems();

    // ─── Initialize autoscrolling camera ───
    _cameraTuning = CameraTuningDerived.from(cameraTuning, movement: _movement);
    _camera = AutoscrollCamera(
      viewWidth: virtualWidth.toDouble(),
      tuning: _cameraTuning,
      initial: CameraState(
        centerX: virtualWidth * 0.5,
        targetX: virtualWidth * 0.5,
        speedX: 0.0,
      ),
    );

    // ─── Initialize spawn service (needs ECS + catalogs) ───
    _spawnService = SpawnService(
      world: _world,
      entityFactory: _entityFactory,
      enemyCatalog: _enemyCatalog,
      unocoDemonTuning: _unocoDemonTuning,
      movement: _movement,
      collectibleTuning: _collectibleTuning,
      restorationItemTuning: _restorationItemTuning,
      trackTuning: _trackTuning,
      seed: seed,
    );

    // ─── Spawn player entity (must happen before TrackManager) ───
    final effectiveGroundTopY =
        staticWorldGeometry.groundPlane?.topY ?? groundTopY.toDouble();
    _spawnPlayer(effectiveGroundTopY);

    // ─── Initialize track manager (needs player for callbacks) ───
    _trackManager = TrackManager(
      seed: seed,
      trackTuning: _trackTuning,
      collectibleTuning: _collectibleTuning,
      restorationItemTuning: _restorationItemTuning,
      baseGeometry: staticWorldGeometry,
      surfaceGraphBuilder: _surfaceGraphBuilder,
      jumpTemplate: _groundEnemyJumpTemplate,
      enemyNavigationSystem: _enemyNavigationSystem,
      groundEnemyLocomotionSystem: _groundEnemyLocomotionSystem,
      spawnService: _spawnService,
      groundTopY: effectiveGroundTopY,
      patternPool: levelDefinition.patternPool,
      earlyPatternChunks: levelDefinition.earlyPatternChunks,
      noEnemyChunks: levelDefinition.noEnemyChunks,
    );

    // ─── Initialize snapshot builder (needs player entity ID) ───
    _snapshotBuilder = SnapshotBuilder(
      tickHz: tickHz,
      world: _world,
      player: _player,
      movement: _movement,
      abilities: _abilities,
      resources: _resourceTuning,
      projectiles: _projectiles,
      enemyCatalog: _enemyCatalog,
    );
  }

  /// Initializes all ECS systems.
  ///
  /// Systems are stateless processors that operate on component stores.
  /// They're created once at construction and reused every tick.
  void _initializeSystems() {
    // Core movement and physics.
    _movementSystem = PlayerMovementSystem();
    _mobilitySystem = MobilitySystem();
    _collisionSystem = CollisionSystem();
    _cooldownSystem = CooldownSystem();
    _gravitySystem = GravitySystem();

    // Projectile lifecycle.
    _projectileSystem = ProjectileSystem();
    _projectileHitSystem = ProjectileHitSystem();
    _projectileWorldCollisionSystem = ProjectileWorldCollisionSystem();

    // Spatial partitioning for hit detection.
    _broadphaseGrid = BroadphaseGrid(
      index: GridIndex2D(cellSize: _spatialGridTuning.broadphaseCellSize),
    );

    // Hitbox management.
    _hitboxFollowOwnerSystem = HitboxFollowOwnerSystem();
    _lifetimeSystem = LifetimeSystem();

    // Damage pipeline.
    _invulnerabilitySystem = InvulnerabilitySystem();
    _damageMiddlewareSystem = DamageMiddlewareSystem(
      middlewares: [
        ParryMiddleware(
          abilityIds: const <AbilityKey>{
            'eloise.sword_parry',
            'eloise.shield_block',
          },
        ),
      ],
    );
    _damageSystem = DamageSystem(
      invulnerabilityTicksOnHit: _combat.invulnerabilityTicks,
      rngSeed: seed,
    );
    _statusSystem = StatusSystem(tickHz: tickHz);
    _controlLockSystem = ControlLockSystem();
    _activeAbilityPhaseSystem = ActiveAbilityPhaseSystem();
    _healthDespawnSystem = HealthDespawnSystem();
    _enemyDeathStateSystem = EnemyDeathStateSystem(
      tickHz: tickHz,
      enemyCatalog: _enemyCatalog,
    );
    _deathDespawnSystem = DeathDespawnSystem();
    _enemyCullSystem = EnemyCullSystem();
    _animSystem = AnimSystem(
      tickHz: tickHz,
      enemyCatalog: _enemyCatalog,
      playerMovement: _movement,
      playerAnimTuning: _animTuning,
    );

    // Player combat (input → intents).
    _abilityActivationSystem = AbilityActivationSystem(
      tickHz: tickHz,
      inputBufferTicks: _abilities.inputBufferTicks,
      abilities: const AbilityCatalog(),
      weapons: _weapons,
      projectileItems: _projectileItems,
    );
    _hitboxDamageSystem = HitboxDamageSystem();

    // Pickup systems.
    _collectibleSystem = CollectibleSystem();
    _restorationItemSystem = RestorationItemSystem();
    _resourceRegenSystem = ResourceRegenSystem(tickHz: tickHz);

    // Projectile execution.
    _projectileLaunchSystem = ProjectileLaunchSystem(projectiles: _projectiles);
    _selfAbilitySystem = SelfAbilitySystem();
    _meleeStrikeSystem = MeleeStrikeSystem();

    // Navigation infrastructure.
    _surfaceGraphBuilder = SurfaceGraphBuilder(
      surfaceGrid: GridIndex2D(cellSize: _spatialGridTuning.broadphaseCellSize),
      takeoffSampleMaxStep: _navigationTuning.takeoffSampleMaxStep,
    );
    _groundEnemyJumpTemplate = JumpReachabilityTemplate.build(
      JumpProfile(
        jumpSpeed: _groundEnemyTuning.locomotion.jumpSpeed,
        gravityY: _physicsTuning.gravityY,
        maxAirTicks: _groundEnemyMaxAirTicks(),
        airSpeedX: _groundEnemyTuning.locomotion.speedX,
        dtSeconds: _movement.dtSeconds,
        agentHalfWidth: _enemyCatalog.get(EnemyId.grojib).collider.halfX,
      ),
    );
    _surfacePathfinder = SurfacePathfinder(
      maxExpandedNodes: _navigationTuning.maxExpandedNodes,
      runSpeedX: _groundEnemyTuning.locomotion.speedX,
      edgePenaltySeconds: _navigationTuning.edgePenaltySeconds,
    );
    _surfaceNavigator = SurfaceNavigator(
      pathfinder: _surfacePathfinder,
      repathCooldownTicks: _navigationTuning.repathCooldownTicks,
      surfaceEps: _navigationTuning.surfaceEps,
      takeoffEps: max(
        _navigationTuning.takeoffEpsMin,
        _groundEnemyTuning.locomotion.stopDistanceX,
      ),
    );

    _enemyNavigationSystem = EnemyNavigationSystem(
      surfaceNavigator: _surfaceNavigator,
      trajectoryPredictor: TrajectoryPredictor(
        gravityY: _physicsTuning.gravityY,
        dtSeconds: _movement.dtSeconds,
        maxTicks: 120,
      ),
      chaseTargetDelayTicks:
          _groundEnemyTuning.navigation.chaseTargetDelayTicks,
    );
    _enemyEngagementSystem = EnemyEngagementSystem(
      groundEnemyTuning: _groundEnemyTuning,
    );
    _groundEnemyLocomotionSystem = GroundEnemyLocomotionSystem(
      groundEnemyTuning: _groundEnemyTuning,
    );
    _flyingEnemyLocomotionSystem = FlyingEnemyLocomotionSystem(
      unocoDemonTuning: _unocoDemonTuning,
    );
    _enemyCastSystem = EnemyCastSystem(
      unocoDemonTuning: _unocoDemonTuning,
      enemyCatalog: _enemyCatalog,
      projectileItems: _projectileItems,
      projectiles: _projectiles,
    );
    _enemyMeleeSystem = EnemyMeleeSystem(groundEnemyTuning: _groundEnemyTuning);
  }

  /// Spawns the player entity at the start of a run.
  ///
  /// The player is positioned at [TrackTuning.playerStartX], standing on the
  /// ground. This must be called before [TrackManager] is created because
  /// track manager callbacks reference the player entity.
  void _spawnPlayer(double groundTopY) {
    final spawnX = _trackTuning.playerStartX;
    final playerArchetype = PlayerCatalogDerived.from(
      _playerCharacter.catalog,
      movement: _movement,
      resources: _resourceTuning,
    ).archetype;
    final playerCollider = playerArchetype.collider;

    // Position so collider bottom touches ground.
    final spawnY = groundTopY - (playerCollider.offsetY + playerCollider.halfY);
    _player = _entityFactory.createPlayer(
      posX: spawnX,
      posY: spawnY,
      velX: 0.0,
      velY: 0.0,
      facing: playerArchetype.facing,
      grounded: true,
      body: playerArchetype.body,
      collider: playerCollider,
      health: playerArchetype.health,
      mana: playerArchetype.mana,
      stamina: playerArchetype.stamina,
      tags: playerArchetype.tags,
      resistance: playerArchetype.resistance,
      statusImmunity: playerArchetype.statusImmunity,
      equippedLoadout: EquippedLoadoutDef(
        mask: playerArchetype.loadoutSlotMask,
        mainWeaponId: playerArchetype.weaponId,
        offhandWeaponId: playerArchetype.offhandWeaponId,
        projectileItemId: playerArchetype.projectileItemId,
        abilityProjectileId: _abilityIdForProjectileItem(
          playerArchetype.projectileItemId,
        ),
      ),
    );
  }

  AbilityKey _abilityIdForProjectileItem(ProjectileItemId id) {
    switch (id) {
      case ProjectileItemId.iceBolt:
        return 'eloise.ice_bolt';
      case ProjectileItemId.fireBolt:
        return 'eloise.fire_bolt';
      case ProjectileItemId.thunderBolt:
        return 'eloise.thunder_bolt';
      case ProjectileItemId.throwingKnife:
        return 'eloise.throwing_knife';
      case ProjectileItemId.throwingAxe:
        return 'eloise.throwing_knife';
    }
  }

  // ─────────────────────────────────────────────────────────────────────────
  // Fields
  // ─────────────────────────────────────────────────────────────────────────

  /// Master RNG seed for deterministic generation.
  ///
  /// The same seed produces identical track layouts, enemy spawns, and

  /// item placements across runs.
  final int seed;

  /// Fixed simulation tick frequency (ticks per second).
  ///
  /// Higher values = smoother physics but more CPU. Default is 60.
  final int tickHz;

  /// Core level configuration for this run.
  final LevelDefinition _levelDefinition;

  // ─── Derived Tunings ───
  // These are pre-computed from base tunings using tickHz.

  final MovementTuningDerived _movement;
  final PhysicsTuning _physicsTuning;
  final ResourceTuningDerived _resourceTuning;
  final AbilityTuningDerived _abilities;
  final AnimTuningDerived _animTuning;
  final CombatTuningDerived _combat;
  final UnocoDemonTuningDerived _unocoDemonTuning;
  final GroundEnemyTuningDerived _groundEnemyTuning;
  final NavigationTuning _navigationTuning;
  final SpatialGridTuning _spatialGridTuning;
  late final CameraTuningDerived _cameraTuning;
  final ScoreTuning _scoreTuning;
  final TrackTuning _trackTuning;
  final CollectibleTuning _collectibleTuning;
  final RestorationItemTuning _restorationItemTuning;

  // ─── Catalogs ───
  // Archetype definitions for entities.

  final ProjectileItemCatalog _projectileItems;
  final ProjectileCatalogDerived _projectiles;
  final EnemyCatalog _enemyCatalog;
  final PlayerCharacterDefinition _playerCharacter;
  final WeaponCatalog _weapons;

  // ─── ECS Core ───

  /// The ECS world containing all component stores.
  late final EcsWorld _world;

  /// Factory for creating complex entities (player, enemies).
  late final EntityFactory _entityFactory;

  /// The player entity ID.
  late EntityId _player;

  // Pending game over delay for death animation.
  int _deathAnimTicksLeft = 0;
  RunEndReason? _pendingRunEndReason;
  DeathInfo? _pendingDeathInfo;

  // ─── ECS Systems ───
  // Stateless processors that operate on component stores.

  late final PlayerMovementSystem _movementSystem;
  late final MobilitySystem _mobilitySystem;
  late final CollisionSystem _collisionSystem;
  late final CooldownSystem _cooldownSystem;
  late final GravitySystem _gravitySystem;
  late final ProjectileSystem _projectileSystem;
  late final ProjectileHitSystem _projectileHitSystem;
  late final ProjectileWorldCollisionSystem _projectileWorldCollisionSystem;
  late final BroadphaseGrid _broadphaseGrid;
  late final HitboxFollowOwnerSystem _hitboxFollowOwnerSystem;
  late final CollectibleSystem _collectibleSystem;
  late final RestorationItemSystem _restorationItemSystem;
  late final LifetimeSystem _lifetimeSystem;
  late final InvulnerabilitySystem _invulnerabilitySystem;
  late final DamageMiddlewareSystem _damageMiddlewareSystem;
  late final DamageSystem _damageSystem;
  late final StatusSystem _statusSystem;
  late final ControlLockSystem _controlLockSystem;
  late final ActiveAbilityPhaseSystem _activeAbilityPhaseSystem;
  late final HealthDespawnSystem _healthDespawnSystem;
  late final EnemyDeathStateSystem _enemyDeathStateSystem;
  late final DeathDespawnSystem _deathDespawnSystem;
  late EnemyNavigationSystem _enemyNavigationSystem;
  late EnemyEngagementSystem _enemyEngagementSystem;
  late GroundEnemyLocomotionSystem _groundEnemyLocomotionSystem;
  late FlyingEnemyLocomotionSystem _flyingEnemyLocomotionSystem;
  late EnemyCastSystem _enemyCastSystem;
  late EnemyMeleeSystem _enemyMeleeSystem;
  late final SurfaceGraphBuilder _surfaceGraphBuilder;
  late final JumpReachabilityTemplate _groundEnemyJumpTemplate;
  late final SurfacePathfinder _surfacePathfinder;
  late final SurfaceNavigator _surfaceNavigator;
  late final AbilityActivationSystem _abilityActivationSystem;
  late final SelfAbilitySystem _selfAbilitySystem;
  late final MeleeStrikeSystem _meleeStrikeSystem;
  late final ProjectileLaunchSystem _projectileLaunchSystem;
  late final HitboxDamageSystem _hitboxDamageSystem;
  late final ResourceRegenSystem _resourceRegenSystem;
  late final AnimSystem _animSystem;
  late final EnemyCullSystem _enemyCullSystem;

  // ─── Modular Services ───
  // Extracted modules for specific responsibilities.

  /// Entity spawning with deterministic placement.
  late final SpawnService _spawnService;

  /// Track streaming, geometry lifecycle, navigation updates.
  late final TrackManager _trackManager;

  /// ECS → render snapshot conversion.
  late SnapshotBuilder _snapshotBuilder;

  // ─── Camera ───

  /// Autoscrolling camera that follows and pushes the player.
  late final AutoscrollCamera _camera;

  // ─── Event Queue ───

  /// Pending events to be consumed by UI (drained each frame).
  final List<GameEvent> _events = <GameEvent>[];

  // ─── Scratch/Tracking State ───

  /// Scratch list for killed enemies (reused to avoid allocation).
  final List<EnemyId> _killedEnemiesScratch = <EnemyId>[];

  /// Kill counts per enemy type (indexed by [EnemyId.index]).
  final List<int> _enemyKillCounts = List<int>.filled(EnemyId.values.length, 0);

  // ─── Simulation State ───

  /// Current simulation tick (increments each [stepOneTick]).
  int tick = 0;

  /// Whether simulation is paused (commands still apply, time doesn't advance).
  bool paused = false;

  /// Whether the run has ended (simulation is frozen permanently).
  bool gameOver = false;

  /// Total distance traveled (world units, not meters).
  double distance = 0;

  /// Number of collectibles picked up this run.
  int collectibles = 0;

  /// Total score from collectibles.
  int collectibleScore = 0;

  // ─────────────────────────────────────────────────────────────────────────
  // Public Accessors
  // ─────────────────────────────────────────────────────────────────────────

  /// Level identifier for this run (stable across sessions).
  LevelId get levelId => _levelDefinition.id;

  /// Optional render theme identifier for this run.
  String? get themeId => _levelDefinition.themeId;

  /// Score tuning for UI display and leaderboard calculation.
  ScoreTuning get scoreTuning => _scoreTuning;

  /// Enemy catalog for render-side animation loading.
  EnemyCatalog get enemyCatalog => _enemyCatalog;

  /// Current static world geometry (base + streamed chunks).
  StaticWorldGeometry get staticWorldGeometry => _trackManager.staticGeometry;

  /// Player X position in world coordinates.
  double get playerPosX =>
      _world.transform.posX[_world.transform.indexOf(_player)];

  /// Player Y position in world coordinates.
  double get playerPosY =>
      _world.transform.posY[_world.transform.indexOf(_player)];

  /// Sets player position (for tests or teleportation).
  void setPlayerPosXY(double x, double y) =>
      _world.transform.setPosXY(_player, x, y);

  /// Player X velocity (positive = moving right).
  double get playerVelX =>
      _world.transform.velX[_world.transform.indexOf(_player)];

  /// Player Y velocity (positive = moving down).
  double get playerVelY =>
      _world.transform.velY[_world.transform.indexOf(_player)];

  /// Sets player velocity (for tests or knockback effects).
  void setPlayerVelXY(double x, double y) =>
      _world.transform.setVelXY(_player, x, y);

  /// Whether the player is currently on the ground.
  bool get playerGrounded =>
      _world.collision.grounded[_world.collision.indexOf(_player)];

  /// Player facing direction (left or right).
  Facing get playerFacing =>
      _world.movement.facing[_world.movement.indexOf(_player)];

  /// Sets player facing direction.
  set playerFacing(Facing value) {
    _world.movement.facing[_world.movement.indexOf(_player)] = value;
  }

  /// Remaining projectile cooldown ticks.
  /// Remaining projectile cooldown ticks.
  int get playerProjectileCooldownTicksLeft =>
      _world.cooldown.getTicksLeft(_player, CooldownGroup.projectile);

  /// Remaining melee strike cooldown ticks.
  int get playerMeleeCooldownTicksLeft =>
      _world.cooldown.getTicksLeft(_player, CooldownGroup.primary);

  // ─────────────────────────────────────────────────────────────────────────
  // Command Processing
  // ─────────────────────────────────────────────────────────────────────────

  /// Applies all commands scheduled for the current tick.
  ///
  /// Commands are the only way external code can influence the simulation.
  /// Each command type maps to a specific player input flag or value:
  ///
  /// - [MoveAxisCommand]: Sets horizontal movement axis (-1 to 1).
  /// - [JumpPressedCommand]: Triggers a jump attempt.
  /// - [DashPressedCommand]: Triggers a dash attempt.
  /// - [StrikePressedCommand]: Triggers an strike attempt.
  /// - [SecondaryPressedCommand]: Triggers an off-hand ability attempt.
  /// - [ProjectileAimDirCommand]: Sets projectile aim direction.
  /// - [MeleeAimDirCommand]: Sets melee strike direction.
  /// - [ProjectilePressedCommand]: Triggers the projectile slot attempt.
  /// - [BonusPressedCommand]: Triggers a bonus-slot ability attempt.
  ///
  /// Commands are processed before [stepOneTick] to ensure inputs are
  /// available when systems read them.
  void applyCommands(List<Command> commands) {
    // Reset all input flags to their default state.
    _world.playerInput.resetTickInputs(_player);
    final inputIndex = _world.playerInput.indexOf(_player);
    final movementIndex = _world.movement.indexOf(_player);

    for (final command in commands) {
      switch (command) {
        // Movement axis: -1 (left) to +1 (right).
        case MoveAxisCommand(:final axis):
          final clamped = axis.clamp(-1.0, 1.0);
          _world.playerInput.moveAxis[inputIndex] = clamped;
          // Update facing direction unless dashing (locked during dash).
          if (_world.movement.dashTicksLeft[movementIndex] == 0) {
            if (clamped < 0) {
              playerFacing = Facing.left;
            } else if (clamped > 0) {
              playerFacing = Facing.right;
            }
          }

        // Jump: Consumed by AbilityActivationSystem (mobility), executed by PlayerMovementSystem.
        case JumpPressedCommand():
          _world.playerInput.jumpPressed[inputIndex] = true;

        // Dash: Consumed by AbilityActivationSystem (mobility).
        case DashPressedCommand():
          _world.playerInput.dashPressed[inputIndex] = true;

        // Strike: Consumed by AbilityActivationSystem.
        case StrikePressedCommand():
          _world.playerInput.strikePressed[inputIndex] = true;
          _world.playerInput.hasAbilitySlotPressed[inputIndex] = true;
          _world.playerInput.lastAbilitySlotPressed[inputIndex] =
              AbilitySlot.primary;

        // Secondary: Consumed by AbilityActivationSystem.
        case SecondaryPressedCommand():
          _world.playerInput.secondaryPressed[inputIndex] = true;
          _world.playerInput.hasAbilitySlotPressed[inputIndex] = true;
          _world.playerInput.lastAbilitySlotPressed[inputIndex] =
              AbilitySlot.secondary;

        // Projectile aim: Direction vector for projectile abilities.
        case ProjectileAimDirCommand(:final x, :final y):
          _world.playerInput.projectileAimDirX[inputIndex] = x;
          _world.playerInput.projectileAimDirY[inputIndex] = y;

        // Melee aim: Direction vector for melee strikes.
        case MeleeAimDirCommand(:final x, :final y):
          _world.playerInput.meleeAimDirX[inputIndex] = x;
          _world.playerInput.meleeAimDirY[inputIndex] = y;

        // Clear projectile aim: Resets to no-aim state.
        case ClearProjectileAimDirCommand():
          _world.playerInput.projectileAimDirX[inputIndex] = 0;
          _world.playerInput.projectileAimDirY[inputIndex] = 0;

        // Clear melee aim: Resets to no-aim state.
        case ClearMeleeAimDirCommand():
          _world.playerInput.meleeAimDirX[inputIndex] = 0;
          _world.playerInput.meleeAimDirY[inputIndex] = 0;

        // Projectile slot: unified input for spells or throws.
        case ProjectilePressedCommand():
          _world.playerInput.projectilePressed[inputIndex] = true;
          _world.playerInput.hasAbilitySlotPressed[inputIndex] = true;
          _world.playerInput.lastAbilitySlotPressed[inputIndex] =
              AbilitySlot.projectile;

        // Bonus slot input.
        case BonusPressedCommand():
          _world.playerInput.bonusPressed[inputIndex] = true;
          _world.playerInput.hasAbilitySlotPressed[inputIndex] = true;
          _world.playerInput.lastAbilitySlotPressed[inputIndex] =
              AbilitySlot.bonus;
      }
    }
  }

  // ─────────────────────────────────────────────────────────────────────────
  // Simulation Tick
  // ─────────────────────────────────────────────────────────────────────────

  /// Advances the simulation by exactly one fixed tick.
  ///
  /// This is the main simulation loop. It executes all ECS systems in a
  /// carefully ordered pipeline to ensure correct behavior:
  ///
  /// 1. **Track streaming**: Generate/cull chunks, spawn enemies.
  /// 2. **Cooldowns**: Decrement ability and invulnerability timers.
  /// 3. **Enemy AI**: Compute paths and movement intentions.
  /// 4. **Player input**: Resolve ability intents (including mobility).
  /// 5. **Player movement**: Apply input to velocity.
  /// 6. **Mobility execution**: Apply dash/roll state.
  /// 7. **Gravity**: Apply gravitational acceleration.
  /// 8. **Collision**: Resolve against static world geometry.
  /// 9. **Death checks**: Detect fall-into-gap and fell-behind-camera.
  /// 10. **Camera update**: Advance autoscroll position.
  /// 11. **Pickups**: Process collectible and restoration item collection.
  /// 12. **Broadphase**: Rebuild spatial grid for hit detection.
  /// 13. **Projectiles**: Move existing projectiles.
  /// 14. **Strike intents**: Queue enemy and player strikes.
  /// 15. **Strike execution**: Spawn hitboxes/projectiles/self abilities from intents.
  /// 16. **Hitbox positioning**: Update hitbox positions from owners.
  /// 17. **Hit detection**: Check projectile and hitbox overlaps.
  /// 18. **Status ticking**: Apply DoT ticks and queue damage.
  /// 19. **Damage middleware**: Apply combat rule edits/cancellations.
  /// 20. **Damage application**: Apply queued damage events.
  /// 21. **Status application**: Apply on-hit status profiles.
  /// 22. **Death handling**: Despawn dead entities, record kills.
  /// 23. **Resource regen**: Regenerate mana and stamina.
  /// 24. **Animation**: Compute per-entity anim key + frame.
  /// 25. **Cleanup**: Remove entities past their lifetime.
  ///
  /// If the run ends during this tick (player death, fell into gap, etc.),
  /// a [RunEndedEvent] is emitted and the simulation freezes.
  void stepOneTick() {
    // Don't advance if paused or game already over.
    if (paused || gameOver) return;

    if (_deathAnimTicksLeft > 0) {
      tick += 1;
      // Update animations during death anim freeze.
      _animSystem.step(_world, player: _player, currentTick: tick);
      _deathAnimTicksLeft -= 1;
      if (_deathAnimTicksLeft <= 0) {
        _endRun(
          _pendingRunEndReason ?? RunEndReason.playerDied,
          deathInfo: _pendingDeathInfo,
        );
      }
      return;
    }

    tick += 1;

    // Cache ground Y once per tick (ground plane doesn't change mid-tick).
    final effectiveGroundTopY =
        staticWorldGeometry.groundPlane?.topY ?? groundTopY.toDouble();

    // ─── Phase 1: World generation ───
    _stepTrackManager(effectiveGroundTopY);

    // ─── Phase 2: Timer decrements ───
    _cooldownSystem.step(_world);
    _invulnerabilitySystem.step(_world);

    // ─── Phase 2.5: Control lock refresh ───
    // Must run before any gameplay systems that check locks.
    _controlLockSystem.step(_world, currentTick: tick);

    // ─── Phase 2.75: Active ability phase update ───
    _activeAbilityPhaseSystem.step(_world, currentTick: tick);

    // ─── Phase 3: AI, input, and movement ───
    _enemyNavigationSystem.step(_world, player: _player, currentTick: tick);
    _enemyEngagementSystem.step(_world, player: _player, currentTick: tick);
    _groundEnemyLocomotionSystem.step(
      _world,
      player: _player,
      dtSeconds: _movement.dtSeconds,
      currentTick: tick,
    );
    _flyingEnemyLocomotionSystem.step(
      _world,
      player: _player,
      groundTopY: effectiveGroundTopY,
      dtSeconds: _movement.dtSeconds,
      currentTick: tick,
    );

    _abilityActivationSystem.step(_world, player: _player, currentTick: tick);
    _movementSystem.step(
      _world,
      _movement,
      resources: _resourceTuning,
      currentTick: tick,
    );
    _mobilitySystem.step(_world, _movement, currentTick: tick);
    _gravitySystem.step(_world, _movement, physics: _physicsTuning);
    _collisionSystem.step(
      _world,
      _movement,
      staticWorld: _trackManager.staticIndex,
    );

    // ─── Phase 4: Distance tracking ───
    // Only count forward movement (positive X velocity).
    distance += max(0.0, playerVelX) * _movement.dtSeconds;

    // ─── Phase 5: Death condition checks ───
    if (_checkFellIntoGap(effectiveGroundTopY)) {
      _endRun(RunEndReason.fellIntoGap);
      return;
    }

    _camera.updateTick(dtSeconds: _movement.dtSeconds, playerX: playerPosX);
    if (_checkFellBehindCamera()) {
      _endRun(RunEndReason.fellBehindCamera);
      return;
    }

    // ─── Phase 6: Pickup collection ───
    _collectibleSystem.step(
      _world,
      player: _player,
      cameraLeft: _camera.left(),
      tuning: _collectibleTuning,
      onCollected: (value) {
        collectibles += 1;
        collectibleScore += value;
      },
    );
    _restorationItemSystem.step(
      _world,
      player: _player,
      cameraLeft: _camera.left(),
      tuning: _restorationItemTuning,
    );

    // ─── Phase 7: Spatial grid rebuild ───
    // Must happen before hit detection to ensure accurate overlaps.
    _broadphaseGrid.rebuild(_world);

    // ─── Phase 8: Projectile movement ───
    // Move existing projectiles before spawning new ones.
    _projectileSystem.step(_world, _movement);

    // ─── Phase 9: Strike intent writing ───
    // Enemy intent writing only.
    // Player intents are written at commit-time in Phase 3 (AbilityActivationSystem),
    // then executed later via stamped executeTick. Keep ordering explicit for tie-breaks.
    _enemyCastSystem.step(_world, player: _player, currentTick: tick);
    _enemyMeleeSystem.step(_world, player: _player, currentTick: tick);

    // ─── Phase 10: Strike execution ───
    _selfAbilitySystem.step(_world, currentTick: tick);
    // Convert intents into actual hitboxes/projectiles.
    // Self abilities first so buffs/blocks/i-frames can affect spawns & downstream combat deterministically.
    _meleeStrikeSystem.step(_world, currentTick: tick);
    _projectileLaunchSystem.step(_world, currentTick: tick);

    // ─── Phase 11: Hitbox positioning ───
    // Update hitbox transforms to follow their owner entities.
    _hitboxFollowOwnerSystem.step(_world);

    // ─── Phase 12: Hit resolution ───
    // Detect overlaps and queue damage events.
    _projectileHitSystem.step(
      _world,
      _broadphaseGrid,
      currentTick: tick,
      queueHitEvent: (event) => _events.add(event),
    );
    _hitboxDamageSystem.step(_world, _broadphaseGrid, currentTick: tick);
    _projectileWorldCollisionSystem.step(_world);
    // ─── Phase 13: Status + damage ───
    _statusSystem.tickExisting(_world);
    _damageMiddlewareSystem.step(_world, currentTick: tick);
    _damageSystem.step(
      _world,
      currentTick: tick,
      queueStatus: _statusSystem.queue,
    );
    _statusSystem.applyQueued(_world, currentTick: tick);

    // ─── Phase 14: Death handling ───
    _killedEnemiesScratch.clear();
    _enemyCullSystem.step(
      _world,
      cameraLeft: _camera.left(),
      groundTopY: effectiveGroundTopY,
      tuning: _trackTuning,
    );
    _enemyDeathStateSystem.step(
      _world,
      currentTick: tick,
      outEnemiesKilled: _killedEnemiesScratch,
    );
    _deathDespawnSystem.step(_world, currentTick: tick);
    _healthDespawnSystem.step(_world, player: _player);
    if (_killedEnemiesScratch.isNotEmpty) {
      _recordEnemyKills(_killedEnemiesScratch);
    }
    if (_isPlayerDead()) {
      if (_deathAnimTicksLeft <= 0) {
        _pendingRunEndReason = RunEndReason.playerDied;
        _pendingDeathInfo = _buildDeathInfo();
        if (_animTuning.deathAnimTicks <= 0) {
          _endRun(_pendingRunEndReason!, deathInfo: _pendingDeathInfo);
        } else {
          _deathAnimTicksLeft = _animTuning.deathAnimTicks;
        }
      }
      return;
    }

    // ─── Phase 15: Resource regeneration ───
    _resourceRegenSystem.step(_world);

    // ─── Phase 16: Animation ───
    _animSystem.step(_world, player: _player, currentTick: tick);

    // ─── Phase 17: Cleanup ───
    _lifetimeSystem.step(_world);
  }

  /// Steps the track manager and handles enemy spawning callbacks.
  ///
  /// This is extracted from [stepOneTick] to keep the main loop readable.
  void _stepTrackManager(double effectiveGroundTopY) {
    _trackManager.step(
      cameraLeft: _camera.left(),
      cameraRight: _camera.right(),
      spawnEnemy: (enemyId, x) {
        // Route spawn requests to the appropriate SpawnService method.
        switch (enemyId) {
          case EnemyId.unocoDemon:
            _spawnService.spawnUnocoDemon(
              spawnX: x,
              groundTopY: effectiveGroundTopY,
            );
          case EnemyId.grojib:
            _spawnService.spawnGroundEnemy(
              spawnX: x,
              groundTopY: effectiveGroundTopY,
            );
        }
      },
      lowestResourceStat: _lowestResourceStat,
    );
  }

  // ─────────────────────────────────────────────────────────────────────────
  // Run End Handling
  // ─────────────────────────────────────────────────────────────────────────

  /// Ends the current run and emits a [RunEndedEvent].
  ///
  /// After this call, [gameOver] is true and [stepOneTick] will no-op.
  void _endRun(RunEndReason reason, {DeathInfo? deathInfo}) {
    gameOver = true;
    paused = true;
    _events.add(
      RunEndedEvent(
        tick: tick,
        distance: distance,
        reason: reason,
        stats: _buildRunEndStats(),
        deathInfo: deathInfo,
      ),
    );
  }

  /// Manually ends the run (e.g., from pause menu).
  ///
  /// Does nothing if the game is already over.
  void giveUp() {
    if (gameOver) return;
    _endRun(RunEndReason.gaveUp);
  }

  /// Records enemy kills for score calculation.
  void _recordEnemyKills(List<EnemyId> killedEnemies) {
    for (final enemyId in killedEnemies) {
      final index = enemyId.index;
      if (index >= 0 && index < _enemyKillCounts.length) {
        _enemyKillCounts[index] += 1;
      }
    }
  }

  /// Builds run statistics for the end-of-run event.
  RunEndStats _buildRunEndStats() => RunEndStats(
    collectibles: collectibles,
    collectibleScore: collectibleScore,
    enemyKillCounts: List<int>.unmodifiable(_enemyKillCounts),
  );

  /// Checks if the player's HP has reached zero.
  bool _isPlayerDead() {
    final hi = _world.health.tryIndexOf(_player);
    if (hi == null) return false;
    return _world.health.hp[hi] <= 0;
  }

  /// Builds death info for the run-ended event.
  ///
  /// This provides details about what killed the player (enemy type,
  /// projectile type, etc.) for death screen messaging.
  DeathInfo? _buildDeathInfo() {
    final li = _world.lastDamage.tryIndexOf(_player);
    if (li == null) return null;

    final kind = _world.lastDamage.kind[li];
    if (kind == DeathSourceKind.unknown) return null;

    return DeathInfo(
      kind: kind,
      enemyId: _world.lastDamage.hasEnemyId[li]
          ? _world.lastDamage.enemyId[li]
          : null,
      projectileId: _world.lastDamage.hasProjectileId[li]
          ? _world.lastDamage.projectileId[li]
          : null,
      projectileItemId: _world.lastDamage.hasProjectileItemId[li]
          ? _world.lastDamage.projectileItemId[li]
          : null,
    );
  }

  // ─────────────────────────────────────────────────────────────────────────
  // Death Condition Checks
  // ─────────────────────────────────────────────────────────────────────────

  /// Checks if the player has fallen behind the camera's left edge.
  ///
  /// This is a "soft" death—the player can still be on solid ground but
  /// has failed to keep up with the autoscrolling camera.
  bool _checkFellBehindCamera() {
    if (!(_world.transform.has(_player) && _world.colliderAabb.has(_player))) {
      return false;
    }

    final ti = _world.transform.indexOf(_player);
    final ai = _world.colliderAabb.indexOf(_player);
    final centerX = _world.transform.posX[ti] + _world.colliderAabb.offsetX[ai];
    final right = centerX + _world.colliderAabb.halfX[ai];

    // Player's right edge must stay ahead of camera's left edge.
    return right < _camera.left();
  }

  /// Checks if the player has fallen into a ground gap (pit).
  ///
  /// The kill threshold is set well below ground level to give visual
  /// feedback of falling before the death triggers. Configured via
  /// [TrackTuning.gapKillOffsetY].
  bool _checkFellIntoGap(double groundTopY) {
    if (!(_world.transform.has(_player) && _world.colliderAabb.has(_player))) {
      return false;
    }

    final ti = _world.transform.indexOf(_player);
    final ai = _world.colliderAabb.indexOf(_player);
    final bottomY =
        _world.transform.posY[ti] +
        _world.colliderAabb.offsetY[ai] +
        _world.colliderAabb.halfY[ai];

    return bottomY > groundTopY + _trackTuning.gapKillOffsetY;
  }

  // ─────────────────────────────────────────────────────────────────────────
  // Resource Helpers
  // ─────────────────────────────────────────────────────────────────────────

  /// Returns the player's most depleted resource stat.
  ///
  /// Used by restoration item spawning to bias item type toward what
  /// the player needs most. Compares ratios (current/max) to handle
  /// resources with different maximum values fairly.
  ///
  /// **Tie-breaking priority**: When ratios are equal, the first resource
  /// checked wins: health > mana > stamina. This is intentional—health
  /// is prioritized as the most critical survival resource.
  RestorationStat _lowestResourceStat() {
    final hi = _world.health.tryIndexOf(_player);
    final mi = _world.mana.tryIndexOf(_player);
    final si = _world.stamina.tryIndexOf(_player);
    if (hi == null || mi == null || si == null) {
      return RestorationStat.health;
    }

    // Start with health as baseline.
    var best = RestorationStat.health;
    var bestValue = _world.health.hp[hi];
    var bestMax = _world.health.hpMax[hi];

    // Compare mana ratio.
    final mana = _world.mana.mana[mi];
    final manaMax = _world.mana.manaMax[mi];
    if (_ratioLess(mana, manaMax, bestValue, bestMax)) {
      best = RestorationStat.mana;
      bestValue = mana;
      bestMax = manaMax;
    }

    // Compare stamina ratio.
    final stamina = _world.stamina.stamina[si];
    final staminaMax = _world.stamina.staminaMax[si];
    if (_ratioLess(stamina, staminaMax, bestValue, bestMax)) {
      best = RestorationStat.stamina;
    }

    return best;
  }

  /// Compares two ratios without division: (valueA / maxA) < (valueB / maxB).
  ///
  /// Cross-multiplies to avoid division: valueA * maxB < valueB * maxA.
  bool _ratioLess(int valueA, int maxA, int valueB, int maxB) {
    if (maxA <= 0) return false; // Invalid ratio A, can't be less.
    if (maxB <= 0) return true; // Invalid ratio B, A wins by default.
    return valueA * maxB < valueB * maxA;
  }

  /// Computes the maximum air time (in ticks) for ground enemy jumps.
  ///
  /// Based on projectile motion: time = 2 * jumpSpeed / gravity.
  /// Multiplied by 1.5 for safety margin (accounts for landing tolerance).
  int _groundEnemyMaxAirTicks() {
    final gravity = _physicsTuning.gravityY;
    if (gravity <= 0) {
      // No gravity means infinite air time; cap at 1 second.
      return ticksFromSecondsCeil(1.0, tickHz);
    }
    final jumpSpeed = _groundEnemyTuning.locomotion.jumpSpeed.abs();
    final baseAirSeconds = (2.0 * jumpSpeed) / gravity;
    return ticksFromSecondsCeil(baseAirSeconds * 1.5, tickHz);
  }

  // ─────────────────────────────────────────────────────────────────────────
  // Events & Snapshots
  // ─────────────────────────────────────────────────────────────────────────

  /// Drains and returns all pending game events.
  ///
  /// Events are produced during [stepOneTick] (e.g., [RunEndedEvent]).
  /// The UI layer should call this after each tick to process events.
  ///
  /// Returns an empty list if no events are pending (avoids allocation).
  List<GameEvent> drainEvents() {
    if (_events.isEmpty) return const <GameEvent>[];
    final drained = List<GameEvent>.unmodifiable(_events);
    _events.clear();
    return drained;
  }

  /// Builds an immutable snapshot for render/UI consumption.
  ///
  /// The snapshot contains everything needed to render a single frame:
  /// - Entity positions, velocities, and animations
  /// - Player HUD data (HP, mana, stamina, cooldowns)
  /// - Static geometry (platforms, ground gaps)
  /// - Camera position
  ///
  /// Snapshots are immutable and safe to pass to async render code.
  GameStateSnapshot buildSnapshot() {
    return _snapshotBuilder.build(
      tick: tick,
      seed: seed,
      levelId: levelId,
      themeId: themeId,
      distance: distance,
      paused: paused,
      gameOver: gameOver,
      cameraCenterX: _camera.state.centerX,
      cameraCenterY: cameraFixedY,
      collectibles: collectibles,
      collectibleScore: collectibleScore,
      staticSolids: _trackManager.staticSolidsSnapshot,
      groundGaps: _trackManager.staticGroundGapsSnapshot,
    );
  }
}


===== FILE: lib/core/levels/level_definition.dart =====
/// Data-first definition of a level configuration (Core-only).
library;

import '../collision/static_world_geometry.dart';
import '../contracts/render_contract.dart';
import '../track/chunk_pattern_pool.dart';
import '../tuning/core_tuning.dart';
import 'level_id.dart';

/// Core configuration for a single level.
///
/// This is pure data: no Flutter/Flame imports and no runtime side effects.
class LevelDefinition {
  const LevelDefinition({
    required this.id,
    required this.patternPool,
    this.tuning = const CoreTuning(),
    this.staticWorldGeometry = const StaticWorldGeometry(
      groundPlane: StaticGroundPlane(topY: groundTopY * 1.0),
    ),
    this.earlyPatternChunks = defaultEarlyPatternChunks,
    this.noEnemyChunks = defaultNoEnemyChunks,
    this.themeId,
  }) : assert(earlyPatternChunks >= 0),
       assert(noEnemyChunks >= 0);

  /// Stable identifier for this level.
  final LevelId id;

  /// Core tuning overrides for this level.
  final CoreTuning tuning;

  /// Base collision geometry for the level (ground + fixed platforms).
  final StaticWorldGeometry staticWorldGeometry;

  /// Pattern pool used for procedural chunk generation.
  final ChunkPatternPool patternPool;

  /// Number of early chunks that use [patternPool.easyPatterns].
  final int earlyPatternChunks;

  /// Number of early chunks that suppress enemy spawns.
  final int noEnemyChunks;

  /// Optional render theme identifier (e.g., lookup key for assets).
  final String? themeId;
}


===== FILE: lib/core/levels/level_id.dart =====
/// Stable identifiers for level definitions.
///
/// Avoid renaming or reordering values; treat as protocol-stable.
enum LevelId {
  /// The default runner level.
  defaultLevel,
  forest,
  field,
}


===== FILE: lib/core/levels/level_registry.dart =====
/// Registry for core level definitions.
library;

import '../track/chunk_pattern_pool.dart';
import '../track/chunk_patterns_library.dart';
import 'level_definition.dart';
import 'level_id.dart';

/// Default pattern pool (matches current behavior).
const ChunkPatternPool defaultPatternPool = ChunkPatternPool(
  easyPatterns: easyPatterns,
  allPatterns: allPatterns,
);

/// Default level definition.
const LevelDefinition defaultLevelDefinition = LevelDefinition(
  id: LevelId.defaultLevel,
  patternPool: defaultPatternPool,
  themeId: 'forest',
);

/// Resolves level definitions by stable [LevelId].
class LevelRegistry {
  const LevelRegistry._();

  /// Default level used when no level is specified.
  static const LevelDefinition defaultLevel = defaultLevelDefinition;

  /// Returns the level definition for a given [LevelId].
  static LevelDefinition byId(LevelId id) {
    switch (id) {
      case LevelId.forest:
        return LevelDefinition(
          id: LevelId.forest,
          patternPool: defaultPatternPool,
          themeId: 'forest',
        );
      case LevelId.field:
        return LevelDefinition(
          id: LevelId.field,
          patternPool: defaultPatternPool,
          themeId: 'field',
        );
      case LevelId.defaultLevel:
        return defaultLevelDefinition;
    }
  }
}


===== FILE: lib/core/loadout/loadout_issue.dart =====
import '../abilities/ability_def.dart';

/// The kind of issue found during loadout validation.
enum IssueKind {
  /// Ability is not allowed in this slot (checked against `allowedSlots`).
  slotNotAllowed,

  /// Equipped weapon definition does not match the slot's expected category.
  weaponCategoryMismatch,

  /// Equipped weapon (or effective weapon) lacks tags required by the ability.
  missingRequiredTags,

  /// Equipped weapon (or effective weapon) lacks required weapon types.
  missingRequiredWeaponTypes,

  /// Ability requires an equipped weapon, but none is present.
  requiresEquippedWeapon,

  /// Two-handed primary weapon conflicts with a separately equipped off-hand item.
  twoHandedConflict,

  /// References a definition that does not exist in the catalog.
  catalogMissing,
}

/// A single validation error or warning for a loadout.
class LoadoutIssue {
  const LoadoutIssue({
    required this.slot,
    required this.kind,
    this.abilityId,
    this.weaponId,
    this.missingTags = const {},
    this.missingWeaponTypes = const {},
    this.message = '',
  });

  /// The slot where the issue occurred.
  final AbilitySlot slot;

  /// The specific kind of validation failure.
  final IssueKind kind;

  /// The ID of the ability involved, if known.
  final String? abilityId;

  /// The ID of the weapon involved, if known.
  final String? weaponId;

  /// If [kind] is [missingRequiredTags], this set contains the missing tags.
  final Set<AbilityTag> missingTags;

  /// If [kind] is [missingRequiredWeaponTypes], this set contains the missing types.
  final Set<WeaponType> missingWeaponTypes;

  /// A human-readable message describing the issue.
  final String message;

  @override
  String toString() {
    return 'LoadoutIssue($slot, $kind, ability:$abilityId, weapon:$weaponId, missingTags:$missingTags, missingWeaponTypes:$missingWeaponTypes)';
  }
}


===== FILE: lib/core/loadout/loadout_validation_result.dart =====
import 'loadout_issue.dart';

/// Result of a full loadout validation pass.
class LoadoutValidationResult {
  const LoadoutValidationResult({
    required this.isValid,
    this.issues = const [],
  });

  /// A completely valid result with no issues.
  static const LoadoutValidationResult valid = LoadoutValidationResult(isValid: true);

  /// Creates an invalid result with a list of issues.
  factory LoadoutValidationResult.invalid(List<LoadoutIssue> issues) =>
      LoadoutValidationResult(isValid: false, issues: issues);

  /// Whether the loadout is considered valid and runnable.
  final bool isValid;

  /// List of issues found during validation.
  final List<LoadoutIssue> issues;
}


===== FILE: lib/core/loadout/loadout_validator.dart =====
import '../abilities/ability_catalog.dart';
import '../abilities/ability_def.dart';
import '../ecs/stores/combat/equipped_loadout_store.dart';
import '../projectiles/projectile_item_catalog.dart';
import '../projectiles/projectile_item_def.dart';
import '../projectiles/projectile_item_id.dart';
import '../weapons/weapon_catalog.dart';
import '../weapons/weapon_category.dart';
import '../weapons/weapon_def.dart';
import '../weapons/weapon_id.dart';
import 'loadout_issue.dart';
import 'loadout_validation_result.dart';

/// Stateless validator for checking loadout legality.
class LoadoutValidator {
  const LoadoutValidator({
    required this.abilityCatalog,
    required this.weaponCatalog,
    required this.projectileItemCatalog,
  });

  final AbilityCatalog abilityCatalog;
  final WeaponCatalog weaponCatalog;
  final ProjectileItemCatalog projectileItemCatalog;

  /// Validates an entire loadout definition.
  LoadoutValidationResult validate(EquippedLoadoutDef loadout) {
    final issues = <LoadoutIssue>[];

    // 1. Resolve Weapons
    final mainWeapon = _resolveWeapon(
      loadout.mainWeaponId,
      WeaponCategory.primary,
      AbilitySlot.primary,
      issues,
    );

    final offhandWeapon = _resolveWeapon(
      loadout.offhandWeaponId,
      WeaponCategory.offHand,
      AbilitySlot.secondary,
      issues,
    );

    final projectileItem = _resolveProjectileItem(
      loadout.projectileItemId,
      AbilitySlot.projectile,
      issues,
    );

    // 2. Derive Effective Weapons (Two-Handed Logic)
    final isTwoHanded = mainWeapon?.isTwoHanded ?? false;

    // Rule: Two-Handed weapon blocks separate secondary weapon
    if (isTwoHanded && offhandWeapon != null) {
      issues.add(LoadoutIssue(
        slot: AbilitySlot.secondary,
        kind: IssueKind.twoHandedConflict,
        weaponId: loadout.offhandWeaponId.toString(),
        message: 'Cannot equip off-hand weapon with two-handed primary.',
      ));
    }

    // Effective weapons for gating
    final effectiveSecondaryWeapon = isTwoHanded ? mainWeapon : offhandWeapon;

    // 3. Validate Slots

    // Primary
    _validateSlot(
      issues: issues,
      abilityId: loadout.abilityPrimaryId,
      slot: AbilitySlot.primary,
      mainWeapon: mainWeapon,
      effectiveSecondaryWeapon: effectiveSecondaryWeapon,
      projectileItem: projectileItem,
    );

    // Secondary
    _validateSlot(
      issues: issues,
      abilityId: loadout.abilitySecondaryId,
      slot: AbilitySlot.secondary,
      mainWeapon: mainWeapon,
      effectiveSecondaryWeapon: effectiveSecondaryWeapon,
      projectileItem: projectileItem,
    );

    // Projectile
    _validateSlot(
      issues: issues,
      abilityId: loadout.abilityProjectileId,
      slot: AbilitySlot.projectile,
      mainWeapon: mainWeapon,
      effectiveSecondaryWeapon: effectiveSecondaryWeapon,
      projectileItem: projectileItem,
    );

    // Mobility (No weapon)
    _validateSlot(
      issues: issues,
      abilityId: loadout.abilityMobilityId,
      slot: AbilitySlot.mobility,
      mainWeapon: mainWeapon,
      effectiveSecondaryWeapon: effectiveSecondaryWeapon,
      projectileItem: projectileItem,
    );

    // Bonus: payload gating is now driven by AbilityDef.payloadSource.
    _validateSlot(
      issues: issues,
      abilityId: loadout.abilityBonusId,
      slot: AbilitySlot.bonus,
      mainWeapon: mainWeapon,
      effectiveSecondaryWeapon: effectiveSecondaryWeapon,
      projectileItem: projectileItem,
    );

    // Jump (Fixed slot, no weapon)
    _validateSlot(
      issues: issues,
      abilityId: loadout.abilityJumpId,
      slot: AbilitySlot.jump,
      mainWeapon: mainWeapon,
      effectiveSecondaryWeapon: effectiveSecondaryWeapon,
      projectileItem: projectileItem,
    );

    return LoadoutValidationResult(
      isValid: issues.isEmpty,
      issues: issues,
    );
  }

  WeaponDef? _resolveWeapon(
    WeaponId id,
    WeaponCategory expectedCategory,
    AbilitySlot slot,
    List<LoadoutIssue> issues,
  ) {
    final weapon = weaponCatalog.tryGet(id);
    if (weapon == null) {
      // If we assume LoadoutStore always has valid defaults, this is a corruption/catalogMissing.
      // If we want to support "none", we'd need a specific ID for it or nullable field.
      // LoadoutDefs are non-nullable IDs.
      // So if tryGet fails, it's catalogMissing.
      issues.add(LoadoutIssue(
        slot: slot,
        kind: IssueKind.catalogMissing,
        weaponId: id.toString(),
        message: 'Weapon ID not found in catalog.',
      ));
      return null;
    }

    if (weapon.category != expectedCategory) {
      issues.add(LoadoutIssue(
        slot: slot,
        kind: IssueKind.weaponCategoryMismatch,
        weaponId: id.toString(),
        message: 'Expected $expectedCategory, found ${weapon.category}.',
      ));
      // Return null so we don't cascade category errors into type errors?
      // Or return weapon so we can still check types?
      // Returning weapon allows more checks, but might be noisy. 
      // Let's return null to fail-fast on this slot's weapon.
      return null;
    }

    return weapon;
  }

  ProjectileItemDef? _resolveProjectileItem(
    ProjectileItemId id,
    AbilitySlot slot,
    List<LoadoutIssue> issues,
  ) {
    final item = projectileItemCatalog.tryGet(id);
    if (item == null) {
      issues.add(LoadoutIssue(
        slot: slot,
        kind: IssueKind.catalogMissing,
        weaponId: id.toString(),
        message: 'Projectile item ID not found in catalog.',
      ));
      return null;
    }
    return item;
  }

  void _validateSlot({
    required List<LoadoutIssue> issues,
    required AbilityKey abilityId,
    required AbilitySlot slot,
    required WeaponDef? mainWeapon,
    required WeaponDef? effectiveSecondaryWeapon,
    required ProjectileItemDef? projectileItem,
  }) {
    final ability = abilityCatalog.resolve(abilityId);
    if (ability == null) {
      issues.add(LoadoutIssue(
        slot: slot,
        kind: IssueKind.catalogMissing,
        abilityId: abilityId,
        message: 'Ability ID not found in catalog.',
      ));
      return;
    }

    final (hasWeapon, weaponType) = _payloadContextFor(
      ability,
      mainWeapon: mainWeapon,
      effectiveSecondaryWeapon: effectiveSecondaryWeapon,
      projectileItem: projectileItem,
    );

    // 1. Slot Compatibility
    if (!ability.allowedSlots.contains(slot)) {
      issues.add(LoadoutIssue(
        slot: slot,
        kind: IssueKind.slotNotAllowed,
        abilityId: abilityId,
        message: 'Ability not allowed in $slot slot.',
      ));
    }

    // 2. Weapon Presence
    if (ability.requiresEquippedWeapon && !hasWeapon) {
      issues.add(LoadoutIssue(
        slot: slot,
        kind: IssueKind.requiresEquippedWeapon,
        abilityId: abilityId,
        message: 'Ability requires an equipped weapon.',
      ));
    }

    // 3. Weapon Type Gating
    if (ability.requiredWeaponTypes.isNotEmpty) {
      if (weaponType == null ||
          !ability.requiredWeaponTypes.contains(weaponType)) {
        issues.add(LoadoutIssue(
          slot: slot,
          kind: IssueKind.missingRequiredWeaponTypes,
          abilityId: abilityId,
          missingWeaponTypes: ability.requiredWeaponTypes,
          message: 'Missing required weapon types: ${ability.requiredWeaponTypes.join(", ")}.',
        ));
      }
    }
  }

  (bool hasWeapon, WeaponType? weaponType) _payloadContextFor(
    AbilityDef ability, {
    required WeaponDef? mainWeapon,
    required WeaponDef? effectiveSecondaryWeapon,
    required ProjectileItemDef? projectileItem,
  }) {
    switch (ability.payloadSource) {
      case AbilityPayloadSource.none:
        return (false, null);
      case AbilityPayloadSource.primaryWeapon:
        return (mainWeapon != null, mainWeapon?.weaponType);
      case AbilityPayloadSource.secondaryWeapon:
        // effectiveSecondaryWeapon already applies two-handed mapping
        return (effectiveSecondaryWeapon != null, effectiveSecondaryWeapon?.weaponType);
      case AbilityPayloadSource.projectileItem:
        return (projectileItem != null, projectileItem?.weaponType);
    }
  }
}


===== FILE: lib/core/navigation/surface_extractor.dart =====
import '../collision/static_world_geometry.dart';
import 'types/nav_tolerances.dart';
import 'types/surface_id.dart';
import 'types/walk_surface.dart';

/// Extracts [WalkSurface]s from tile-based world geometry.
///
/// **Pipeline**:
/// 1. Collect top faces of solid tiles as raw segments.
/// 2. Process ground layer (explicit segments or infinite plane).
/// 3. Subtract blockers (solids/gaps) from ground.
/// 4. Sort and merge adjacent coplanar segments.
///
/// **ID Assignment**:
/// Each surface gets a unique ID via [packSurfaceId], encoding chunk and local
/// indices. This enables stable references across graph rebuilds.
class SurfaceExtractor {
  SurfaceExtractor({
    // Use a pixel-ish tolerance by default to avoid fragmenting surfaces due to
    // tiny seams (chunk boundaries, floating error, inclusive/exclusive edges).
    this.mergeEps = navSpatialEps,
    this.groundPadding = 1024.0,
  });

  /// Tolerance for merging adjacent segments (pixels).
  final double mergeEps;

  /// Horizontal padding beyond world bounds for ground plane fallback.
  final double groundPadding;

  /// Extracts walkable surfaces from [geometry].
  ///
  /// **Returns**: Unmodifiable list of [WalkSurface]s, sorted and merged.
  List<WalkSurface> extract(StaticWorldGeometry geometry) {
    final segments = <_SurfaceSegment>[];

    // Stride for ground segment IDs to avoid collisions with tile IDs.
    const groundPieceStride = 1000;

    // -------------------------------------------------------------------------
    // Step 1: Collect solid top faces.
    // -------------------------------------------------------------------------
    var minX = double.infinity;
    var maxX = double.negativeInfinity;
    for (var i = 0; i < geometry.solids.length; i += 1) {
      final solid = geometry.solids[i];

      // Track world bounds for ground plane fallback.
      if (solid.minX < minX) minX = solid.minX;
      if (solid.maxX > maxX) maxX = solid.maxX;

      // Only include solids with a walkable top face.
      if ((solid.sides & StaticSolid.sideTop) == 0) continue;

      var localSolidIndex = solid.localSolidIndex;
      if (localSolidIndex < 0) {
        if (solid.chunkIndex != StaticSolid.noChunk) {
          throw StateError(
            'Chunk solid is missing a localSolidIndex; check track streamer.',
          );
        }
        // Non-chunk solid: use array index as fallback.
        localSolidIndex = i;
      }

      final id = packSurfaceId(
        chunkIndex: solid.chunkIndex,
        localSolidIndex: localSolidIndex,
      );
      segments.add(
        _SurfaceSegment(
          id: id,
          xMin: solid.minX,
          xMax: solid.maxX,
          yTop: solid.minY,
        ),
      );
    }

    // -------------------------------------------------------------------------
    // Step 2: Process ground layer.
    // -------------------------------------------------------------------------
    if (geometry.groundSegments.isNotEmpty) {
      // Explicit ground segments (from level data).
      for (var gi = 0; gi < geometry.groundSegments.length; gi += 1) {
        final ground = geometry.groundSegments[gi];
        var localSegmentIndex = ground.localSegmentIndex;
        if (localSegmentIndex < 0) {
          if (ground.chunkIndex != StaticSolid.noChunk) {
            throw StateError(
              'Ground segment is missing a localSegmentIndex; check track streamer.',
            );
          }
          localSegmentIndex = gi;
        }

        // Subtract solids that block the ground at this Y.
        final blockers = _collectGroundBlockers(
          geometry.solids,
          const <StaticGroundGap>[],
          ground.topY,
          mergeEps,
        );
        final groundSegments = _subtractRanges(
          ground.minX,
          ground.maxX,
          blockers,
          mergeEps,
        );

        // Create surface for each unblocked portion.
        for (var i = 0; i < groundSegments.length; i += 1) {
          final seg = groundSegments[i];
          final id = packSurfaceId(
            chunkIndex: ground.chunkIndex,
            localSolidIndex: localSegmentIndex * groundPieceStride + i,
          );
          segments.add(
            _SurfaceSegment(
              id: id,
              xMin: seg.min,
              xMax: seg.max,
              yTop: ground.topY,
            ),
          );
        }
      }
    } else {
      // Infinite ground plane fallback.
      final groundPlane = geometry.groundPlane;
      if (groundPlane != null) {
        final baseMinX = minX.isFinite ? minX : 0.0;
        final baseMaxX = maxX.isFinite ? maxX : 0.0;
        final groundMinX = baseMinX - groundPadding;
        final groundMaxX = baseMaxX + groundPadding;

        final blockers = _collectGroundBlockers(
          geometry.solids,
          geometry.groundGaps,
          groundPlane.topY,
          mergeEps,
        );
        final groundSegments = _subtractRanges(
          groundMinX,
          groundMaxX,
          blockers,
          mergeEps,
        );

        for (var i = 0; i < groundSegments.length; i += 1) {
          final seg = groundSegments[i];
          segments.add(
            _SurfaceSegment(
              id: packSurfaceId(
                chunkIndex: StaticSolid.groundChunk,
                localSolidIndex: i,
              ),
              xMin: seg.min,
              xMax: seg.max,
              yTop: groundPlane.topY,
            ),
          );
        }
      }
    }

    if (segments.isEmpty) {
      return const <WalkSurface>[];
    }

    // -------------------------------------------------------------------------
    // Step 3: Sort and merge adjacent coplanar segments.
    // -------------------------------------------------------------------------
    segments.sort(_compareSegments);

    final merged = <WalkSurface>[];
    var current = segments.first;
    for (var i = 1; i < segments.length; i += 1) {
      final next = segments[i];
      final sameY = (next.yTop - current.yTop).abs() <= mergeEps;
      final touches = next.xMin <= current.xMax + mergeEps;

      if (sameY && touches) {
        // Extend current segment to include next.
        if (next.xMax > current.xMax) {
          current = current.copyWith(xMax: next.xMax);
        }
      } else {
        // Flush current, start new segment.
        merged.add(
          WalkSurface(
            id: current.id,
            xMin: current.xMin,
            xMax: current.xMax,
            yTop: current.yTop,
          ),
        );
        current = next;
      }
    }

    // Flush final segment.
    merged.add(
      WalkSurface(
        id: current.id,
        xMin: current.xMin,
        xMax: current.xMax,
        yTop: current.yTop,
      ),
    );

    return List<WalkSurface>.unmodifiable(merged);
  }
}

// =============================================================================
// Internal types
// =============================================================================

/// Intermediate segment representation before merging.
class _SurfaceSegment {
  const _SurfaceSegment({
    required this.id,
    required this.xMin,
    required this.xMax,
    required this.yTop,
  });

  /// Packed surface ID (see [packSurfaceId]).
  final int id;

  /// Left edge X coordinate.
  final double xMin;

  /// Right edge X coordinate.
  final double xMax;

  /// Top Y coordinate (walking height).
  final double yTop;

  /// Creates a copy with modified [xMax] (used during merge).
  _SurfaceSegment copyWith({double? xMax}) {
    return _SurfaceSegment(
      id: id,
      xMin: xMin,
      xMax: xMax ?? this.xMax,
      yTop: yTop,
    );
  }
}

/// Mutable horizontal range (used for blocker collection).
class _Range {
  _Range(this.min, this.max);

  double min;
  double max;
}

// =============================================================================
// Helper functions
// =============================================================================

/// Collects horizontal ranges that block the ground at [groundTopY].
///
/// Includes:
/// - Solids with left/right walls touching ground Y.
/// - Explicit ground gaps.
///
/// Returns merged, sorted list of blocking ranges.
List<_Range> _collectGroundBlockers(
  List<StaticSolid> solids,
  List<StaticGroundGap> gaps,
  double groundTopY,
  double eps,
) {
  final blockers = <_Range>[];

  // Collect solids that intersect ground level and have vertical walls.
  for (final solid in solids) {
    final hasWalls =
        (solid.sides & (StaticSolid.sideLeft | StaticSolid.sideRight)) != 0;
    if (!hasWalls) continue;

    final touchesGround =
        solid.minY <= groundTopY + eps && solid.maxY >= groundTopY - eps;
    if (!touchesGround) continue;

    blockers.add(_Range(solid.minX, solid.maxX));
  }

  // Add explicit gaps.
  for (final gap in gaps) {
    blockers.add(_Range(gap.minX, gap.maxX));
  }

  if (blockers.isEmpty) return blockers;

  // Sort and merge overlapping blockers.
  blockers.sort((a, b) => a.min.compareTo(b.min));
  final merged = <_Range>[blockers.first];
  for (var i = 1; i < blockers.length; i += 1) {
    final current = blockers[i];
    final last = merged.last;
    if (current.min <= last.max + eps) {
      // Overlapping or adjacent—extend.
      if (current.max > last.max) {
        last.max = current.max;
      }
    } else {
      merged.add(_Range(current.min, current.max));
    }
  }

  return merged;
}

/// Subtracts [blockers] from range [min, max], returning unblocked segments.
///
/// **Algorithm**:
/// Walk left-to-right, emitting segments between blocker gaps.
List<_Range> _subtractRanges(
  double min,
  double max,
  List<_Range> blockers,
  double eps,
) {
  if (blockers.isEmpty) {
    return <_Range>[_Range(min, max)];
  }

  final segments = <_Range>[];
  var cursor = min;

  for (final blocker in blockers) {
    // Skip blockers entirely before our range.
    if (blocker.max <= min + eps) continue;
    // Stop if blocker starts after our range.
    if (blocker.min >= max - eps) break;

    // Clamp blocker to our range.
    final blockMin = blocker.min < min ? min : blocker.min;
    final blockMax = blocker.max > max ? max : blocker.max;

    // Emit segment before blocker (if any).
    if (blockMin > cursor + eps) {
      segments.add(_Range(cursor, blockMin));
    }

    // Advance cursor past blocker.
    if (blockMax > cursor) {
      cursor = blockMax;
    }
  }

  // Emit trailing segment (if any).
  if (cursor < max - eps) {
    segments.add(_Range(cursor, max));
  }

  return segments;
}

/// Comparison function for sorting segments (Y, then X, then ID).
int _compareSegments(_SurfaceSegment a, _SurfaceSegment b) {
  // Primary: Y ascending (lower platforms first in screen coords).
  if (a.yTop < b.yTop) return -1;
  if (a.yTop > b.yTop) return 1;
  // Secondary: X ascending.
  if (a.xMin < b.xMin) return -1;
  if (a.xMin > b.xMin) return 1;
  // Tertiary: Width ascending.
  if (a.xMax < b.xMax) return -1;
  if (a.xMax > b.xMax) return 1;
  // Final: ID for determinism.
  if (a.id < b.id) return -1;
  if (a.id > b.id) return 1;
  return 0;
}


===== FILE: lib/core/navigation/surface_graph_builder.dart =====
import '../collision/static_world_geometry.dart';
import '../ecs/spatial/grid_index_2d.dart';
import 'utils/jump_template.dart';
import 'types/nav_tolerances.dart';
import 'surface_extractor.dart';
import 'types/surface_graph.dart';
import 'utils/surface_spatial_index.dart';
import 'types/walk_surface.dart';

/// Result of [SurfaceGraphBuilder.build].
class SurfaceGraphBuildResult {
  const SurfaceGraphBuildResult({
    required this.graph,
    required this.spatialIndex,
  });

  /// The navigation graph (surfaces + edges in CSR format).
  final SurfaceGraph graph;

  /// Spatial index for fast surface lookups during runtime navigation.
  final SurfaceSpatialIndex spatialIndex;
}

/// Builds a [SurfaceGraph] from world geometry and jump physics.
///
/// **Pipeline**:
/// 1. Extract [WalkSurface]s from tiles via [SurfaceExtractor].
/// 2. Build spatial index for candidate queries.
/// 3. For each surface, generate edges:
///    - **Drop edges**: Walk off ledge, fall to surface below.
///    - **Jump edges**: Sample takeoff points, find reachable surfaces.
/// 4. Pack into CSR (Compressed Sparse Row) format.
///
/// **Configuration**:
/// - [standableEps]: Tolerance for standable range calculations.
/// - [dropSampleOffset]: Nudge takeoff past ledge for drop edges.
/// - [takeoffSampleMaxStep]: Maximum spacing between takeoff samples.
class SurfaceGraphBuilder {
  SurfaceGraphBuilder({
    required GridIndex2D surfaceGrid,
    SurfaceExtractor? extractor,
    this.standableEps = navGeomEps,
    this.dropSampleOffset = navSpatialEps,
    this.takeoffSampleMaxStep = 64.0,
  })  : _surfaceGrid = surfaceGrid,
        _extractor = extractor ?? SurfaceExtractor();

  /// Grid for spatial index bucket allocation.
  final GridIndex2D _surfaceGrid;

  /// Surface extractor (default: standard tile-based extraction).
  final SurfaceExtractor _extractor;

  /// Tolerance for standable range width check.
  final double standableEps;

  /// Offset past ledge for drop takeoff (ensures entity actually falls).
  final double dropSampleOffset;

  /// Maximum step between takeoff sample points.
  final double takeoffSampleMaxStep;

  /// Builds a navigation graph from world geometry.
  ///
  /// **Parameters**:
  /// - [geometry]: Static collision geometry (tile-based).
  /// - [jumpTemplate]: Precomputed jump arc for reachability queries.
  ///
  /// **Returns**: [SurfaceGraphBuildResult] with graph and spatial index.
  SurfaceGraphBuildResult build({
    required StaticWorldGeometry geometry,
    required JumpReachabilityTemplate jumpTemplate,
  }) {
    // -------------------------------------------------------------------------
    // Step 1: Extract surfaces and build spatial index.
    // -------------------------------------------------------------------------
    final surfaces = _extractor.extract(geometry);
    final spatialIndex = SurfaceSpatialIndex(index: _surfaceGrid);
    spatialIndex.rebuild(surfaces);

    // Build surface ID → index lookup.
    final indexById = <int, int>{};
    for (var i = 0; i < surfaces.length; i += 1) {
      indexById[surfaces[i].id] = i;
    }

    // -------------------------------------------------------------------------
    // Step 2: Generate edges for each surface.
    // -------------------------------------------------------------------------
    final edges = <SurfaceEdge>[];
    final edgeOffsets = List<int>.filled(surfaces.length + 1, 0);
    final tempCandidates = <int>[];

    for (var i = 0; i < surfaces.length; i += 1) {
      edgeOffsets[i] = edges.length;
      final from = surfaces[i];

      // Compute standable range (agent center positions that fit on surface).
      final standable = _standableRange(
        from,
        jumpTemplate.profile.agentHalfWidth,
        standableEps,
      );
      if (standable == null) {
        // Surface too narrow for agent.
        edgeOffsets[i + 1] = edges.length;
        continue;
      }

      // -----------------------------------------------------------------------
      // Step 2a: Generate drop edges (walk off ledge).
      // -----------------------------------------------------------------------
      final dropSamples = _dropSamples(standable.min, standable.max);
      final dropMid = (standable.min + standable.max) * 0.5;
      for (final dropX in dropSamples) {
        final landingIndex = _findFirstSurfaceBelow(
          surfaces,
          dropX,
          from.yTop,
          jumpTemplate.profile.agentHalfWidth,
        );
        if (landingIndex == null) continue;

        final landingSurface = surfaces[landingIndex];
        final dy = landingSurface.yTop - from.yTop;
        final fallTicks = estimateFallTicks(
          dy: dy,
          gravityY: jumpTemplate.profile.gravityY,
          dtSeconds: jumpTemplate.profile.dtSeconds,
          maxTicks: jumpTemplate.profile.maxAirTicks,
        );

        // Nudge takeoff past ledge so agent actually walks off.
        final commitDirX = dropX <= dropMid ? -1 : 1;
        final takeoffX = dropX + (commitDirX * dropSampleOffset);

        final edge = SurfaceEdge(
          to: landingIndex,
          kind: SurfaceEdgeKind.drop,
          takeoffX: takeoffX,
          landingX: _clamp(
            dropX,
            landingSurface.xMin + jumpTemplate.profile.agentHalfWidth,
            landingSurface.xMax - jumpTemplate.profile.agentHalfWidth,
          ),
          commitDirX: commitDirX,
          travelTicks: fallTicks,
          cost: fallTicks * jumpTemplate.profile.dtSeconds,
        );
        edges.add(edge);
      }

      // -----------------------------------------------------------------------
      // Step 2b: Generate jump edges (sample takeoff points).
      // -----------------------------------------------------------------------
      final takeoffXs = _takeoffSamples(
        standable.min,
        standable.max,
        jumpTemplate.maxDx,
        takeoffSampleMaxStep,
      );

      for (final takeoffX in takeoffXs) {
        // Query reachable surfaces within jump arc bounding box.
        final minX = takeoffX - jumpTemplate.maxDx;
        final maxX = takeoffX + jumpTemplate.maxDx;
        final minY = from.yTop + jumpTemplate.minDy;
        final maxY = from.yTop + jumpTemplate.maxDy;

        spatialIndex.queryAabb(
          minX: minX,
          minY: minY,
          maxX: maxX,
          maxY: maxY,
          outSurfaceIndices: tempCandidates,
        );

        // Sort for deterministic edge ordering.
        tempCandidates.sort(
          (a, b) => surfaces[a].id.compareTo(surfaces[b].id),
        );

        for (final targetIndex in tempCandidates) {
          if (targetIndex == i) continue; // Skip self.
          final target = surfaces[targetIndex];

          // Safety net: avoid generating "micro-hop" jump edges between surfaces
          // that are effectively coplanar and contiguous. These should have
          // been merged by the extractor; emitting a jump here can cause AI to
          // do a weird hop on top of the same obstacle.
          final dy = target.yTop - from.yTop;
          final coplanar = dy.abs() <= navSpatialEps;
          if (coplanar) {
            final touchesOrOverlaps =
                target.xMin <= from.xMax + navSpatialEps &&
                target.xMax >= from.xMin - navSpatialEps;
            if (touchesOrOverlaps) {
              continue;
            }
          }

          final landing = _standableRange(
            target,
            jumpTemplate.profile.agentHalfWidth,
            standableEps,
          );
          if (landing == null) continue; // Target too narrow.

          // Check if jump arc can reach target surface.
          final dxMin = landing.min - takeoffX;
          final dxMax = landing.max - takeoffX;
          final landingTick = jumpTemplate.findFirstLanding(
            dy: dy,
            dxMin: dxMin,
            dxMax: dxMax,
          );
          if (landingTick == null) continue; // Not reachable.

          // Compute actual landing range (intersection of reach and surface).
          final reachMin = takeoffX - landingTick.maxDx;
          final reachMax = takeoffX + landingTick.maxDx;
          final low = reachMin > landing.min ? reachMin : landing.min;
          final high = reachMax < landing.max ? reachMax : landing.max;
          if (low > high + standableEps) continue; // No overlap.

          final landingX = (low + high) * 0.5; // Center of landing range.
          final commitDirX = landingX > takeoffX + navGeomEps
              ? 1
              : (landingX < takeoffX - navGeomEps ? -1 : 0);

          final edge = SurfaceEdge(
            to: targetIndex,
            kind: SurfaceEdgeKind.jump,
            takeoffX: takeoffX,
            landingX: landingX,
            commitDirX: commitDirX,
            travelTicks: landingTick.tick,
            cost: landingTick.tick * jumpTemplate.profile.dtSeconds,
          );
          edges.add(edge);
        }
      }

      edgeOffsets[i + 1] = edges.length;
    }

    // -------------------------------------------------------------------------
    // Step 3: Pack into graph and return.
    // -------------------------------------------------------------------------
    return SurfaceGraphBuildResult(
      graph: SurfaceGraph(
        surfaces: surfaces,
        edgeOffsets: edgeOffsets,
        edges: edges,
        indexById: indexById,
      ),
      spatialIndex: spatialIndex,
    );
  }
}

// =============================================================================
// Helper types and functions
// =============================================================================

/// A horizontal range [min, max].
class _Range {
  const _Range(this.min, this.max);

  final double min;
  final double max;
}

/// Computes the standable X range for an agent on a surface.
///
/// The agent's center must be at least [halfWidth] from each edge.
/// Returns `null` if the surface is too narrow.
_Range? _standableRange(WalkSurface surface, double halfWidth, double eps) {
  final min = surface.xMin + halfWidth;
  final max = surface.xMax - halfWidth;
  if (min > max + eps) return null;
  return _Range(min, max);
}

/// Generates takeoff sample points across a standable range.
///
/// - Returns [min, mid, max] for narrow surfaces.
/// - Returns evenly-spaced samples (at most [maxStep] apart) for wide surfaces.
/// - Deduplicates samples within [navGeomEps].
List<double> _takeoffSamples(
  double min,
  double max,
  double maxDx,
  double maxStep,
) {
  if (max <= min) {
    return <double>[min];
  }

  var step = maxDx;
  if (maxStep > 0 && step > maxStep) {
    step = maxStep;
  }

  // Narrow surface: just sample endpoints and midpoint.
  if (step <= navGeomEps || (max - min) <= step) {
    final mid = (min + max) * 0.5;
    return _dedupeSamples(<double>[min, mid, max]);
  }

  // Wide surface: evenly-spaced samples.
  final samples = <double>[];
  for (var x = min; x <= max; x += step) {
    samples.add(x);
  }
  // Ensure max is included.
  if ((max - samples.last).abs() > navGeomEps) {
    samples.add(max);
  }
  return _dedupeSamples(samples);
}

/// Generates drop sample points (only at ledge endpoints).
List<double> _dropSamples(double min, double max) {
  final samples = <double>[min, max];
  return _dedupeSamples(samples);
}

/// Removes duplicate samples within [eps] tolerance.
List<double> _dedupeSamples(
  List<double> samples, {
  double eps = navGeomEps,
}) {
  samples.sort();
  final deduped = <double>[];
  for (final s in samples) {
    if (deduped.isEmpty || (s - deduped.last).abs() > eps) {
      deduped.add(s);
    }
  }
  return deduped;
}

/// Finds the first (highest) surface directly below a point.
///
/// **Parameters**:
/// - [x]: Horizontal position to check.
/// - [fromY]: Starting Y (surfaces must be below this).
/// - [halfWidth]: Agent half-width for standability check.
///
/// **Returns**: Surface index, or `null` if no surface below.
int? _findFirstSurfaceBelow(
  List<WalkSurface> surfaces,
  double x,
  double fromY,
  double halfWidth,
) {
  int? bestIndex;
  double? bestY;

  for (var i = 0; i < surfaces.length; i += 1) {
    final s = surfaces[i];
    // Must be below starting point.
    if (s.yTop <= fromY) continue;
    // Must be standable at this X.
    final minX = s.xMin + halfWidth;
    final maxX = s.xMax - halfWidth;
    if (minX > maxX) continue;
    if (x < minX || x > maxX) continue;

    // Prefer highest surface (lowest yTop).
    if (bestY == null || s.yTop < bestY) {
      bestY = s.yTop;
      bestIndex = i;
    } else if ((s.yTop - bestY).abs() < navTieEps) {
      // Tie-break by ID for determinism.
      if (s.id < surfaces[bestIndex!].id) {
        bestIndex = i;
      }
    }
  }

  return bestIndex;
}

/// Clamps [v] to the range [min, max].
double _clamp(double v, double min, double max) {
  if (v < min) return min;
  if (v > max) return max;
  return v;
}


===== FILE: lib/core/navigation/surface_navigator.dart =====
import '../ecs/stores/enemies/surface_nav_state_store.dart';
import 'types/nav_tolerances.dart';
import 'types/surface_graph.dart';
import 'types/surface_id.dart';
import 'surface_pathfinder.dart';
import 'utils/surface_spatial_index.dart';

/// Output of [SurfaceNavigator.update] indicating desired movement.
class SurfaceNavIntent {
  const SurfaceNavIntent({
    required this.desiredX,
    required this.jumpNow,
    required this.hasPlan,
    this.commitMoveDirX = 0,
  });

  /// Target X position the locomotion controller should move toward.
  final double desiredX;

  /// If `true`, the entity should jump this frame.
  final bool jumpNow;

  /// If `true`, a valid path exists (even if currently executing an edge).
  final bool hasPlan;

  /// Movement commit direction while approaching/executing an edge.
  ///
  /// When non-zero (-1 or +1), the locomotion controller should keep moving in
  /// this direction even if it would normally stop near `desiredX`, and it
  /// should not reverse direction due to tiny `desiredX` overshoots.
  ///
  /// This is primarily used to ensure drop edges actually leave the takeoff
  /// surface (walk past the ledge) instead of stopping "close enough".
  final int commitMoveDirX;
}

/// Runtime navigation controller for surface-graph-based AI movement.
///
/// **Responsibilities**:
/// 1. Track which surface the entity and target are standing on.
/// 2. Request paths via [SurfacePathfinder] when surfaces change.
/// 3. Execute path edges (walk to takeoff, jump/drop, land on destination).
/// 4. Return [SurfaceNavIntent] each tick for the locomotion controller.
///
/// **State Storage**:
/// Uses [SurfaceNavStateStore] (external SOA store) so multiple entities can
/// share a single [SurfaceNavigator] instance.
///
/// **Usage**:
/// ```dart
/// final intent = navigator.update(
///   navStore: store, navIndex: idx,
///   graph: graph, spatialIndex: index,
///   graphVersion: version,
///   entityX: e.x, entityBottomY: e.bottom, entityHalfWidth: e.hw,
///   entityGrounded: e.grounded,
///   targetX: t.x, targetBottomY: t.bottom, targetHalfWidth: t.hw,
///   targetGrounded: t.grounded,
/// );
/// // Use intent.desiredX, intent.jumpNow, intent.commitMoveDirX
/// ```
class SurfaceNavigator {
  SurfaceNavigator({
    required this.pathfinder,
    this.repathCooldownTicks = 30,
    this.surfaceEps = navSpatialEps,
    this.takeoffEps = 2.0,
  });

  /// Pathfinder used for A* queries.
  final SurfacePathfinder pathfinder;

  /// Minimum ticks between path recalculations (prevents thrashing).
  final int repathCooldownTicks;

  /// Vertical tolerance for surface detection (pixels).
  final double surfaceEps;

  /// Horizontal tolerance for reaching takeoff point (pixels).
  final double takeoffEps;

  /// Reusable buffer for spatial index queries.
  final List<int> _candidateBuffer = <int>[];

  /// Updates navigation state and returns movement intent for one entity.
  ///
  /// **Flow**:
  /// 1. Locate current and target surfaces via spatial index.
  /// 2. Invalidate path if graph version changed.
  /// 3. Repath if cooldown expired and surfaces are known.
  /// 4. If same surface, return direct movement to target.
  /// 5. Otherwise, execute next edge in path (approach → jump/drop → land).
  SurfaceNavIntent update({
    required SurfaceNavStateStore navStore,
    required int navIndex,
    required SurfaceGraph graph,
    required SurfaceSpatialIndex spatialIndex,
    required int graphVersion,
    required double entityX,
    required double entityBottomY,
    required double entityHalfWidth,
    required bool entityGrounded,
    required double targetX,
    required double targetBottomY,
    required double targetHalfWidth,
    required bool targetGrounded,
  }) {
    final prevCurrentId = navStore.currentSurfaceId[navIndex];
    final prevTargetId = navStore.targetSurfaceId[navIndex];

    // -------------------------------------------------------------------------
    // Step 1: Locate surfaces.
    // -------------------------------------------------------------------------
    var currentSurfaceId = prevCurrentId;
    if (entityGrounded) {
      final currentIndex = _locateSurfaceIndex(
        graph,
        spatialIndex,
        _candidateBuffer,
        entityX,
        entityBottomY,
        entityHalfWidth,
        surfaceEps,
      );
      currentSurfaceId = currentIndex == null
          ? surfaceIdUnknown
          : graph.surfaces[currentIndex].id;
    }

    var targetSurfaceId = prevTargetId;
    if (targetGrounded) {
      final targetIndex = _locateSurfaceIndex(
        graph,
        spatialIndex,
        _candidateBuffer,
        targetX,
        targetBottomY,
        targetHalfWidth,
        surfaceEps,
      );
      targetSurfaceId = targetIndex == null
          ? surfaceIdUnknown
          : graph.surfaces[targetIndex].id;
    }

    // -------------------------------------------------------------------------
    // Step 2: Invalidate path on graph rebuild.
    // -------------------------------------------------------------------------
    if (navStore.graphVersion[navIndex] != graphVersion) {
      navStore.graphVersion[navIndex] = graphVersion;
      navStore.pathEdges[navIndex].clear();
      navStore.pathCursor[navIndex] = 0;
      navStore.activeEdgeIndex[navIndex] = -1;
      navStore.repathTicksLeft[navIndex] = 0;
    }

    navStore.currentSurfaceId[navIndex] = currentSurfaceId;
    navStore.targetSurfaceId[navIndex] = targetSurfaceId;

    // Decrement repath cooldown.
    if (navStore.repathTicksLeft[navIndex] > 0) {
      navStore.repathTicksLeft[navIndex] -= 1;
    }

    final plan = navStore.pathEdges[navIndex];
    final surfaceChanged =
        currentSurfaceId != prevCurrentId || targetSurfaceId != prevTargetId;

    // Reset cooldown if either surface changed (allows immediate repath).
    if (surfaceChanged) {
      navStore.repathTicksLeft[navIndex] = 0;
    }

    // -------------------------------------------------------------------------
    // Step 3: Repath if needed.
    // -------------------------------------------------------------------------
    if (entityGrounded &&
        navStore.repathTicksLeft[navIndex] == 0 &&
        currentSurfaceId != surfaceIdUnknown &&
        targetSurfaceId != surfaceIdUnknown) {
      final startIndex = graph.indexOfSurfaceId(currentSurfaceId);
      final goalIndex = graph.indexOfSurfaceId(targetSurfaceId);
      if (startIndex != null && goalIndex != null) {
        final found = pathfinder.findPath(
          graph,
          startIndex: startIndex,
          goalIndex: goalIndex,
          outEdges: plan,
          startX: entityX,
          goalX: targetX,
        );
        navStore.pathCursor[navIndex] = 0;
        navStore.activeEdgeIndex[navIndex] = -1;
        if (!found) {
          plan.clear();
        }
      }
      navStore.repathTicksLeft[navIndex] = repathCooldownTicks;
    }

    // -------------------------------------------------------------------------
    // Step 4: Same-surface shortcut.
    // -------------------------------------------------------------------------
    if (currentSurfaceId != surfaceIdUnknown &&
        currentSurfaceId == targetSurfaceId) {
      plan.clear();
      navStore.pathCursor[navIndex] = 0;
      navStore.activeEdgeIndex[navIndex] = -1;
      return SurfaceNavIntent(
        desiredX: targetX,
        jumpNow: false,
        hasPlan: false,
      );
    }

    // -------------------------------------------------------------------------
    // Step 5: Execute path edges.
    // -------------------------------------------------------------------------
    final cursor = navStore.pathCursor[navIndex];
    if (plan.isEmpty || cursor >= plan.length) {
      navStore.activeEdgeIndex[navIndex] = -1;
      return SurfaceNavIntent(
        desiredX: targetX,
        jumpNow: false,
        hasPlan: false,
      );
    }

    final edgeIndex = plan[cursor];
    final edge = graph.edges[edgeIndex];

    // --- Executing an edge (mid-flight or post-takeoff) ---
    if (navStore.activeEdgeIndex[navIndex] >= 0) {
      // Check if we've landed on the destination surface.
      if (entityGrounded &&
          currentSurfaceId != surfaceIdUnknown &&
          currentSurfaceId == graph.surfaces[edge.to].id) {
        // Edge complete—advance cursor.
        navStore.activeEdgeIndex[navIndex] = -1;
        navStore.pathCursor[navIndex] = cursor + 1;
        return SurfaceNavIntent(
          desiredX: targetX,
          jumpNow: false,
          hasPlan: true,
        );
      }

      // Drop edge: keep walking toward ledge until we fall off.
      if (edge.kind == SurfaceEdgeKind.drop && entityGrounded) {
        return SurfaceNavIntent(
          desiredX: edge.takeoffX,
          jumpNow: false,
          hasPlan: true,
          commitMoveDirX: edge.commitDirX,
        );
      }

      // Drop edge in-flight: keep commit direction stable. (landingX can be
      // slightly behind the entity due to clamping, which would otherwise
      // cause a brief direction reversal.)
      if (edge.kind == SurfaceEdgeKind.drop) {
        return SurfaceNavIntent(
          desiredX: edge.landingX,
          jumpNow: false,
          hasPlan: true,
          commitMoveDirX: edge.commitDirX,
        );
      }

      // Jump edge in-flight: aim for landing point.
      return SurfaceNavIntent(
        desiredX: edge.landingX,
        jumpNow: false,
        hasPlan: true,
      );
    }

    // --- Approaching takeoff point ---
    // For jump edges with commitMoveDirX, the entity may overshoot the exact
    // takeoff point at high speeds. Check if the entity is at OR past the
    // takeoff point in the direction of travel.
    final dir = edge.commitDirX;
    final closeEnough = edge.kind == SurfaceEdgeKind.jump && dir != 0
        ? (dir > 0 ? entityX >= edge.takeoffX - takeoffEps : entityX <= edge.takeoffX + takeoffEps)
        : (entityX - edge.takeoffX).abs() <= takeoffEps;
    if (entityGrounded && closeEnough) {
      // Initiate edge execution.
      navStore.activeEdgeIndex[navIndex] = edgeIndex;

      final jumpNow = edge.kind == SurfaceEdgeKind.jump;
      return SurfaceNavIntent(
        desiredX:
            edge.kind == SurfaceEdgeKind.drop ? edge.takeoffX : edge.landingX,
        jumpNow: jumpNow,
        hasPlan: true,
        commitMoveDirX: edge.commitDirX,
      );
    }

    // Walk toward takeoff point.
    // For jump edges, commit direction keeps the entity moving at full speed
    // through the takeoff instead of decelerating as it approaches.
    return SurfaceNavIntent(
      desiredX: edge.takeoffX,
      jumpNow: false,
      hasPlan: true,
      commitMoveDirX:
          edge.kind == SurfaceEdgeKind.jump ? edge.commitDirX : 0,
    );
  }
}

/// Finds the best surface index for a given entity footprint.
///
/// **Algorithm**:
/// 1. Query spatial index for candidate surfaces in AABB.
/// 2. Filter by horizontal overlap and vertical proximity.
/// 3. Prefer lowest yTop (highest platform). Tie-break by surface ID.
///
/// **Returns**: Surface index, or `null` if not standing on any surface.
int? _locateSurfaceIndex(
  SurfaceGraph graph,
  SurfaceSpatialIndex spatialIndex,
  List<int> candidates,
  double x,
  double bottomY,
  double halfWidth,
  double eps,
) {
  final minX = x - halfWidth;
  final maxX = x + halfWidth;
  final minY = bottomY - eps;
  final maxY = bottomY + eps;

  spatialIndex.queryAabb(
    minX: minX,
    minY: minY,
    maxX: maxX,
    maxY: maxY,
    outSurfaceIndices: candidates,
  );

  int? bestIndex;
  double? bestY;
  for (final i in candidates) {
    final s = graph.surfaces[i];
    // Skip if no horizontal overlap.
    if (s.xMin > maxX || s.xMax < minX) continue;
    // Skip if too far vertically.
    if ((s.yTop - bottomY).abs() > eps) continue;

    // Prefer higher platform (lower yTop in screen coords).
    if (bestY == null || s.yTop < bestY) {
      bestY = s.yTop;
      bestIndex = i;
    } else if ((s.yTop - bestY).abs() <= eps) {
      // Tie-break by ID for determinism.
      if (s.id < graph.surfaces[bestIndex!].id) {
        bestIndex = i;
      }
    }
  }

  return bestIndex;
}


===== FILE: lib/core/navigation/surface_pathfinder.dart =====
import 'types/surface_graph.dart';
import 'types/nav_tolerances.dart';

/// A* pathfinder for surface-based navigation graphs.
///
/// **Algorithm**: Standard A* with:
/// - Admissible heuristic: straight-line horizontal distance / run speed.
/// - Edge costs: transition cost + run distance to takeoff + landing adjustment.
/// - Tie-breaking: lower g-score, then surface ID for determinism.
///
/// **Optimizations**:
/// - Generation-stamp pattern avoids clearing arrays between searches.
/// - Reusable working lists grow once, persist across queries.
/// - Linear open-list scan (adequate for small graphs; swap to binary heap
///   if graph size grows significantly).
///
/// **Usage**:
/// ```dart
/// final pathfinder = SurfacePathfinder(maxExpandedNodes: 500, runSpeedX: 200);
/// final edges = <int>[];
/// if (pathfinder.findPath(graph, startIndex: s, goalIndex: g, outEdges: edges)) {
///   // edges contains edge indices from start to goal.
/// }
/// ```
class SurfacePathfinder {
  SurfacePathfinder({
    required this.maxExpandedNodes,
    required this.runSpeedX,
    this.edgePenaltySeconds = 0.0,
  })  : assert(maxExpandedNodes > 0),
        assert(runSpeedX > 0),
        assert(edgePenaltySeconds >= 0.0);

  /// Maximum nodes to expand before giving up (prevents runaway searches).
  final int maxExpandedNodes;

  /// Horizontal run speed (pixels/second) for cost calculations.
  final double runSpeedX;

  /// Flat penalty added to every edge (discourages excessive transitions).
  final double edgePenaltySeconds;

  // ---------------------------------------------------------------------------
  // Working arrays (reused across searches via generation stamps).
  // ---------------------------------------------------------------------------

  /// Cost from start to each node (g-score).
  final List<double> _gScore = <double>[];

  /// Estimated total cost through each node (f = g + h).
  final List<double> _fScore = <double>[];

  /// Edge index used to reach each node (-1 = start or unvisited).
  final List<int> _cameFromEdge = <int>[];

  /// Predecessor node index (-1 = start or unvisited).
  final List<int> _cameFromNode = <int>[];

  /// Open set (nodes pending expansion).
  final List<int> _open = <int>[];

  /// 1 if node is in open set this search, 0 otherwise.
  final List<int> _openStamp = <int>[];

  /// Scratch space for path reconstruction.
  final List<int> _reconstruct = <int>[];

  /// Generation stamp per node (matches [_searchGeneration] if valid).
  final List<int> _nodeGenerations = <int>[];

  /// Incremented each search to invalidate stale node data.
  int _searchGeneration = 0;

  /// Finds a path from [startIndex] to [goalIndex] in [graph].
  ///
  /// **Parameters**:
  /// - [startIndex], [goalIndex]: Surface indices in [graph.surfaces].
  /// - [outEdges]: Receives ordered edge indices from start to goal.
  /// - [startX], [goalX]: Optional precise X positions for cost accuracy.
  ///
  /// **Returns**: `true` if a path was found, `false` otherwise.
  bool findPath(
    SurfaceGraph graph, {
    required int startIndex,
    required int goalIndex,
    required List<int> outEdges,
    double? startX,
    double? goalX,
  }) {
    outEdges.clear();
    if (startIndex == goalIndex) return true;

    _ensureSize(graph.surfaces.length);
    _searchGeneration += 1;

    // Initialize start node.
    _touch(startIndex);
    _open.clear();
    _open.add(startIndex);
    _openStamp[startIndex] = 1;
    _gScore[startIndex] = 0.0;
    _fScore[startIndex] = _heuristic(graph, startIndex, goalIndex);

    var expanded = 0;
    while (_open.isNotEmpty && expanded < maxExpandedNodes) {
      final current = _popBest(graph);
      if (current == goalIndex) {
        _reconstructPath(goalIndex, outEdges);
        return true;
      }

      expanded += 1;

      // Iterate outgoing edges (CSR format).
      final start = graph.edgeOffsets[current];
      final end = graph.edgeOffsets[current + 1];
      for (var ei = start; ei < end; ei += 1) {
        final edge = graph.edges[ei];
        final neighbor = edge.to;
        _touch(neighbor);

        // Total edge cost: base + run-to-takeoff + landing adjustment + penalty.
        final edgeCost = edge.cost +
            _runCost(
              graph,
              current,
              edge,
              startIndex: startIndex,
              startX: startX,
            ) +
            _goalLandingCost(
              edge,
              neighbor: neighbor,
              goalIndex: goalIndex,
              goalX: goalX,
            ) +
            edgePenaltySeconds;

        final tentative = _gScore[current] + edgeCost;
        if (tentative >= _gScore[neighbor]) continue;

        // Better path found—update neighbor.
        _cameFromEdge[neighbor] = ei;
        _cameFromNode[neighbor] = current;
        _gScore[neighbor] = tentative;
        _fScore[neighbor] = tentative + _heuristic(graph, neighbor, goalIndex);

        // Add to open set if not already present.
        if (_openStamp[neighbor] != 1) {
          _open.add(neighbor);
          _openStamp[neighbor] = 1;
        }
      }
    }

    return false; // No path found within expansion limit.
  }

  /// Admissible heuristic: horizontal distance / run speed.
  ///
  /// Ignores vertical distance (platforms can be reached by jumps/falls
  /// with minimal time penalty relative to horizontal travel).
  double _heuristic(SurfaceGraph graph, int from, int goal) {
    final dx =
        (graph.surfaces[goal].centerX - graph.surfaces[from].centerX).abs();
    return dx / runSpeedX;
  }

  /// Cost to run from current position to edge takeoff point.
  double _runCost(
    SurfaceGraph graph,
    int fromIndex,
    SurfaceEdge edge, {
    required int startIndex,
    required double? startX,
  }) {
    final fromSurface = graph.surfaces[fromIndex];
    // Use exact position for start node, otherwise surface center.
    final originX =
        (fromIndex == startIndex && startX != null) ? startX : fromSurface.centerX;
    final dx = (edge.takeoffX - originX).abs();
    return dx / runSpeedX;
  }

  /// Additional cost for landing distance to goal (only on final edge).
  double _goalLandingCost(
    SurfaceEdge edge, {
    required int neighbor,
    required int goalIndex,
    required double? goalX,
  }) {
    if (goalX == null) return 0.0;
    if (neighbor != goalIndex) return 0.0;
    final dx = (edge.landingX - goalX).abs();
    return dx / runSpeedX;
  }

  /// Extracts and removes the node with lowest f-score from [_open].
  ///
  /// Uses linear scan (O(n)) which is fine for small open sets.
  /// For larger graphs, consider a binary heap.
  int _popBest(SurfaceGraph graph) {
    var bestIndex = 0;
    var bestNode = _open[0];
    for (var i = 1; i < _open.length; i += 1) {
      final node = _open[i];
      if (_isBetter(graph, node, bestNode)) {
        bestIndex = i;
        bestNode = node;
      }
    }

    // Swap-remove: replace extracted element with last, then pop.
    final last = _open.removeLast();
    if (bestIndex < _open.length) {
      _open[bestIndex] = last;
    }
    _openStamp[bestNode] = 0;
    return bestNode;
  }

  /// Compares two nodes for priority (lower f-score wins).
  ///
  /// Tie-breaking order:
  /// 1. Lower f-score.
  /// 2. Lower g-score (prefer nodes closer to start).
  /// 3. Lower surface ID (determinism).
  bool _isBetter(SurfaceGraph graph, int a, int b) {
    final fa = _fScore[a];
    final fb = _fScore[b];
    if (fa < fb - navTieEps) return true;
    if (fa > fb + navTieEps) return false;
    final ga = _gScore[a];
    final gb = _gScore[b];
    if (ga < gb - navTieEps) return true;
    if (ga > gb + navTieEps) return false;
    return graph.surfaces[a].id < graph.surfaces[b].id;
  }

  /// Reconstructs path by walking [_cameFromEdge] back to start.
  ///
  /// Edges are collected in reverse order, then reversed into [outEdges].
  void _reconstructPath(int goalIndex, List<int> outEdges) {
    _reconstruct.clear();
    var current = goalIndex;
    while (_cameFromEdge[current] != -1) {
      _reconstruct.add(_cameFromEdge[current]);
      current = _cameFromNode[current];
    }
    // Reverse into output.
    for (var i = _reconstruct.length - 1; i >= 0; i -= 1) {
      outEdges.add(_reconstruct[i]);
    }
  }

  /// Grows working arrays to accommodate [count] nodes.
  void _ensureSize(int count) {
    while (_gScore.length < count) {
      _gScore.add(double.infinity);
      _fScore.add(double.infinity);
      _cameFromEdge.add(-1);
      _cameFromNode.add(-1);
      _openStamp.add(0);
      _nodeGenerations.add(0);
    }
  }

  /// Lazily initializes node data for the current search generation.
  ///
  /// Avoids O(n) clearing of all arrays between searches.
  void _touch(int index) {
    if (_nodeGenerations[index] != _searchGeneration) {
      _gScore[index] = double.infinity;
      _fScore[index] = double.infinity;
      _cameFromEdge[index] = -1;
      _cameFromNode[index] = -1;
      _openStamp[index] = 0;
      _nodeGenerations[index] = _searchGeneration;
    }
  }
}


===== FILE: lib/core/navigation/types/nav_tolerances.dart =====
/// Navigation-wide numeric tolerances.
///
/// **Design**:
/// - [navEps] is kept very small for geometric comparisons and deterministic
///   tie-breaking.
/// - [navSpatialEps] is intentionally larger to make runtime surface detection
///   robust against tiny simulation drift (world units are pixels).
///
/// **Warning**: Changing these values affects pathfinding determinism.
library;

/// Default epsilon for equality checks and tie-breaks (1e-6 world units).
const double navEps = 1e-6;

/// Epsilon for geometric equality checks (e.g., "are these two points the same?").
const double navGeomEps = navEps;

/// Epsilon for spatial queries (surface containment, overlap thickness).
const double navSpatialEps = 1.0;

/// Epsilon for deterministic tie-breaking in A* (f-cost and g-cost comparisons).
const double navTieEps = navEps;


===== FILE: lib/core/navigation/types/surface_graph.dart =====
import 'walk_surface.dart';

/// The type of transition between two surfaces.
enum SurfaceEdgeKind {
  /// An active jump (requires jump input).
  jump,
  
  /// A passive drop (walking off an edge).
  drop,
}

/// A directed edge in the navigation graph.
///
/// Represents a traversable connection from one [WalkSurface] to another.
class SurfaceEdge {
  const SurfaceEdge({
    required this.to,
    required this.kind,
    required this.takeoffX,
    required this.landingX,
    required this.commitDirX,
    required this.travelTicks,
    required this.cost,
  }) : assert(commitDirX >= -1 && commitDirX <= 1);

  /// Index of the destination surface in [SurfaceGraph.surfaces].
  final int to;
  
  /// Type of traversal (Jump or Drop).
  final SurfaceEdgeKind kind;
  
  /// World X coordinate where the entity leaves the source surface.
  final double takeoffX;
  
  /// World X coordinate where the entity lands on the destination surface.
  final double landingX;

  /// Movement commit direction while approaching/executing this edge.
  ///
  /// When non-zero (-1 or +1), the locomotion controller should keep moving in
  /// this direction when approaching the takeoff point and (for drops) while
  /// walking past the ledge to ensure the entity actually falls.
  ///
  /// **Design**:
  /// - For [SurfaceEdgeKind.drop], this is derived from which ledge is used.
  /// - For [SurfaceEdgeKind.jump], this is derived from `landingX - takeoffX`.
  final int commitDirX;
  
  /// Estimated travel time in simulation ticks.
  final int travelTicks;
  
  /// Pathfinding cost (typically based on time or distance).
  final double cost;
}

/// An immutable navigation graph built from [WalkSurface]s.
///
/// **Structure**:
/// - **Nodes**: [surfaces] (indexed 0..N-1).
/// - **Edges**: Stored in [edges], with [edgeOffsets] providing CSR-style indexing.
///
/// **CSR (Compressed Sparse Row) Format**:
/// - `edgeOffsets[i]` is the start index in [edges] for surface `i`.
/// - `edgeOffsets[i+1]` is the end index (exclusive).
/// - This allows O(1) lookup of outgoing edges for any surface.
class SurfaceGraph {
  SurfaceGraph({
    required List<WalkSurface> surfaces,
    required List<int> edgeOffsets,
    required List<SurfaceEdge> edges,
    required Map<int, int> indexById,
  })  : surfaces = List<WalkSurface>.unmodifiable(surfaces),
        edgeOffsets = List<int>.unmodifiable(edgeOffsets),
        edges = List<SurfaceEdge>.unmodifiable(edges),
        _indexById = Map<int, int>.unmodifiable(indexById);

  /// All walkable surfaces (graph nodes).
  final List<WalkSurface> surfaces;
  
  /// CSR row pointers into [edges]. Length = surfaces.length + 1.
  final List<int> edgeOffsets;
  
  /// All edges (graph arcs), grouped by source surface.
  final List<SurfaceEdge> edges;
  
  /// Lookup: Surface ID -> index in [surfaces].
  final Map<int, int> _indexById;

  /// Returns the index of a surface by its packed [id], or null if not found.
  int? indexOfSurfaceId(int id) => _indexById[id];

  /// Yields all outgoing edges from [surfaceIndex].
  Iterable<SurfaceEdge> edgesFor(int surfaceIndex) sync* {
    final start = edgeOffsets[surfaceIndex];
    final end = edgeOffsets[surfaceIndex + 1];
    for (var i = start; i < end; i += 1) {
      yield edges[i];
    }
  }
}


===== FILE: lib/core/navigation/types/surface_id.dart =====
/// Surface ID Packing Utilities.
///
/// Surfaces are identified by a 64-bit integer that encodes:
/// - **Chunk Index** (32 bits, high): Which level chunk the surface belongs to.
/// - **Local Solid Index** (30 bits): Index of the solid tile within the chunk.
/// - **Surface Kind** (2 bits, low): Top/Side/etc. (Currently only Top is used).
///
/// This encoding allows:
/// - Stable, deterministic IDs across save/load.
/// - Efficient Map/Set lookups.
/// - Lexicographic ordering by chunk then local index.
library;

/// The "Top" surface kind (entities stand on top of the solid).
const int surfaceKindTop = 0;

/// Sentinel value for "no surface" / invalid.
const int surfaceIdUnknown = -1;

/// Packs a surface identity into a stable, comparable 64-bit key.
///
/// **Bit Layout**:
/// ```
/// [63..32] chunkIndex (XOR'd with 0x80000000 to handle signed comparison)
/// [31..2]  localSolidIndex
/// [1..0]   surfaceKind
/// ```
int packSurfaceId({
  required int chunkIndex,
  required int localSolidIndex,
  int surfaceKind = surfaceKindTop,
}) {
  if (localSolidIndex < 0) {
    throw ArgumentError.value(
      localSolidIndex,
      'localSolidIndex',
      'must be >= 0',
    );
  }
  // XOR with sign bit to make signed chunkIndex sort correctly as unsigned.
  final chunk = (chunkIndex ^ 0x80000000) & 0xFFFFFFFF;
  // Pack localSolidIndex and surfaceKind into lower 32 bits.
  final local = ((localSolidIndex << 2) | (surfaceKind & 0x3)) & 0xFFFFFFFF;
  return (chunk << 32) | local;
}

/// Extracts the chunk index from a packed [surfaceId].
int unpackChunkIndex(int surfaceId) {
  final chunk = (surfaceId >> 32) & 0xFFFFFFFF;
  return (chunk ^ 0x80000000);
}

/// Extracts the local solid index from a packed [surfaceId].
int unpackLocalSolidIndex(int surfaceId) {
  final local = surfaceId & 0xFFFFFFFF;
  return local >> 2;
}

/// Extracts the surface kind (Top/Side) from a packed [surfaceId].
int unpackSurfaceKind(int surfaceId) {
  return surfaceId & 0x3;
}


===== FILE: lib/core/navigation/types/walk_surface.dart =====
/// Represents a horizontal walkable platform segment in world space.
///
/// **Geometry**:
/// - A 1D segment along the X-axis at a fixed Y height ([yTop]).
/// - Defined by [[xMin], [xMax]] (inclusive bounds).
///
/// **Usage**:
/// - Used by the navigation system to represent ground/platforms.
/// - Entities can stand on this surface if their X is within [xMin, xMax].
class WalkSurface {
  const WalkSurface({
    required this.id,
    required this.xMin,
    required this.xMax,
    required this.yTop,
  }) : assert(xMax >= xMin);

  /// Unique identifier (packed via [packSurfaceId]).
  final int id;

  /// Left edge of the walkable segment (inclusive).
  final double xMin;
  
  /// Right edge of the walkable segment (inclusive).
  final double xMax;

  /// World-space Y coordinate of the top surface (where entities stand).
  final double yTop;

  /// Horizontal center of the surface.
  double get centerX => (xMin + xMax) * 0.5;
  
  /// Width of the walkable segment.
  double get width => xMax - xMin;
}



===== FILE: lib/core/navigation/utils/jump_template.dart =====
import '../types/nav_tolerances.dart';

/// Physics parameters for simulating a jump arc.
///
/// Used to precompute reachability templates for AI pathfinding.
class JumpProfile {
  const JumpProfile({
    required this.jumpSpeed,
    required this.gravityY,
    required this.maxAirTicks,
    required this.airSpeedX,
    required this.dtSeconds,
    required this.agentHalfWidth,
  })  : assert(maxAirTicks > 0),
        assert(dtSeconds > 0);

  /// Instantaneous vertical speed at jump start (negative = upward).
  final double jumpSpeed;

  /// Gravity acceleration (positive = downward, e.g., 980 for ~10m/s²).
  final double gravityY;

  /// Fixed timestep in seconds (e.g., 1/60 for 60Hz).
  final double dtSeconds;

  /// Maximum ticks to simulate (limits arc length for performance).
  final int maxAirTicks;

  /// Assumed constant horizontal speed while airborne.
  final double airSpeedX;

  /// Agent's collider half-width (for landing overlap calculations).
  final double agentHalfWidth;
}

/// A single sample point along a precomputed jump arc.
class JumpSample {
  const JumpSample({
    required this.tick,
    required this.prevY,
    required this.y,
    required this.velY,
    required this.maxDx,
  });

  /// Tick number (1-based, 0 = takeoff).
  final int tick;

  /// Y position at the end of the previous tick.
  final double prevY;

  /// Y position at the end of this tick.
  final double y;

  /// Vertical velocity at the end of this tick.
  final double velY;

  /// Maximum horizontal displacement reachable by this tick.
  final double maxDx;
}

/// Result of a successful landing query.
class JumpLanding {
  const JumpLanding({required this.tick, required this.maxDx});

  /// Tick at which landing occurs.
  final int tick;

  /// Maximum horizontal reach at landing time.
  final double maxDx;
}

/// Precomputed jump arc template for reachability queries.
///
/// **Usage**:
/// - Built once from a [JumpProfile] (at startup or when physics change).
/// - Queried during graph construction to find valid jump edges.
///
/// **Physics**:
/// - Uses semi-implicit Euler integration: `vel += g*dt`, then `pos += vel*dt`.
/// - Matches the runtime physics in [GravitySystem].
class JumpReachabilityTemplate {
  JumpReachabilityTemplate._({
    required this.profile,
    required this.samples,
    required this.minDy,
    required this.maxDy,
    required this.maxDx,
  });

  /// The physics profile used to build this template.
  final JumpProfile profile;

  /// Sampled arc positions (tick 1 to maxAirTicks).
  final List<JumpSample> samples;

  /// Lowest Y offset reached (negative = above origin).
  final double minDy;

  /// Highest Y offset reached (positive = below origin, after fall).
  final double maxDy;

  /// Maximum horizontal distance reachable.
  final double maxDx;

  /// Builds a reachability template by simulating [profile.maxAirTicks] of flight.
  factory JumpReachabilityTemplate.build(JumpProfile profile) {
    final samples = <JumpSample>[];

    var y = 0.0;
    var velY = -profile.jumpSpeed; // Negative = upward
    final dt = profile.dtSeconds;
    var minDy = 0.0;
    var maxDy = 0.0;
    var maxDxOverall = 0.0;

    for (var tick = 1; tick <= profile.maxAirTicks; tick += 1) {
      final prevY = y;
      
      // Semi-implicit Euler: update velocity first, then position.
      velY += profile.gravityY * dt;
      y += velY * dt;
      
      // Horizontal reach increases linearly with time.
      final maxDx = profile.airSpeedX * dt * tick;
      
      // Track bounding box.
      if (y < minDy) minDy = y;
      if (y > maxDy) maxDy = y;
      if (maxDx > maxDxOverall) maxDxOverall = maxDx;
      
      samples.add(
        JumpSample(
          tick: tick,
          prevY: prevY,
          y: y,
          velY: velY,
          maxDx: maxDx,
        ),
      );
    }

    return JumpReachabilityTemplate._(
      profile: profile,
      samples: List<JumpSample>.unmodifiable(samples),
      minDy: minDy,
      maxDy: maxDy,
      maxDx: maxDxOverall,
    );
  }

  /// Finds the earliest tick at which a jump can land at vertical offset [dy].
  ///
  /// **Parameters**:
  /// - [dy]: Target vertical offset (positive = below takeoff, negative = above).
  /// - [dxMin], [dxMax]: Required horizontal range for a valid landing.
  ///
  /// **Returns**: [JumpLanding] if reachable, null otherwise.
  ///
  /// **Logic**:
  /// 1. Skip ascending samples (velY < 0).
  /// 2. Check if [dy] is crossed between prevY and y.
  /// 3. Check if horizontal range overlaps [dxMin, dxMax].
  JumpLanding? findFirstLanding({
    required double dy,
    required double dxMin,
    required double dxMax,
    double eps = navGeomEps,
  }) {
    if (dxMin > dxMax) return null;

    for (final sample in samples) {
      // Only consider descending phase.
      if (sample.velY < 0) continue;
      
      // Check vertical crossing: prevY <= dy <= y (with tolerance).
      final crosses = (sample.prevY <= dy + eps) && (sample.y >= dy - eps);
      if (!crosses) continue;

      // Check horizontal reachability.
      final maxDx = sample.maxDx;
      if (dxMin > maxDx + eps) continue;  // Target too far right.
      if (dxMax < -maxDx - eps) continue; // Target too far left.
      
      return JumpLanding(tick: sample.tick, maxDx: maxDx);
    }

    return null;
  }
}

/// Estimates the number of ticks to fall a given vertical distance.
///
/// Used for "drop" edges (walking off a ledge without jumping).
///
/// **Parameters**:
/// - [dy]: Distance to fall (positive = downward).
/// - [gravityY]: Gravity acceleration.
/// - [dtSeconds]: Timestep.
/// - [maxTicks]: Upper bound to prevent infinite loops.
int estimateFallTicks({
  required double dy,
  required double gravityY,
  required double dtSeconds,
  required int maxTicks,
}) {
  if (dy <= 0) return 0;
  
  var y = 0.0;
  var velY = 0.0;
  
  for (var tick = 1; tick <= maxTicks; tick += 1) {
    velY += gravityY * dtSeconds;
    y += velY * dtSeconds;
    if (y >= dy) return tick;
  }
  
  return maxTicks;
}


===== FILE: lib/core/navigation/utils/surface_spatial_index.dart =====
import '../../ecs/spatial/grid_index_2d.dart';
import '../types/nav_tolerances.dart';
import '../types/walk_surface.dart';

/// Spatial hash grid for fast AABB queries against [WalkSurface]s.
///
/// **Purpose**:
/// - Given an AABB (e.g., entity bounds), quickly find all surfaces that might overlap.
/// - Avoids O(N) linear scans over all surfaces.
///
/// **Design**:
/// - Uses a uniform grid (via [GridIndex2D]) to bucket surfaces by cell.
/// - Surfaces spanning multiple cells are inserted into each overlapping cell.
/// - A stamp-based deduplication prevents returning the same surface twice per query.
///
/// **Lifecycle**:
/// - Call [rebuild] when static geometry changes (e.g., new chunk loaded).
/// - Call [queryAabb] during gameplay (e.g., to find surfaces under an entity).
class SurfaceSpatialIndex {
  SurfaceSpatialIndex({
    required GridIndex2D index,
    this.surfaceThickness = navSpatialEps,
  }) : _index = index;

  /// The underlying grid coordinate system.
  final GridIndex2D _index;
  
  /// Vertical thickness added above/below each surface for overlap tests.
  final double surfaceThickness;

  /// Cell key -> list of surface indices in that cell.
  final Map<int, List<int>> _buckets = <int, List<int>>{};
  
  /// Keys of all currently populated buckets (for fast clearing).
  final List<int> _activeKeys = <int>[];
  
  /// Pool of reusable bucket lists (reduces GC pressure).
  final List<List<int>> _bucketPool = <List<int>>[];

  /// Stamp-based deduplication: `_seenStampBySurface[i] == _stamp` means already seen.
  final List<int> _seenStampBySurface = <int>[];
  int _stamp = 0;
  int _surfaceCount = 0;

  /// Rebuilds the spatial index from a new set of surfaces.
  ///
  /// **Performance**: O(S * C) where S = surfaces, C = avg cells per surface.
  void rebuild(List<WalkSurface> surfaces) {
    // Return all active buckets to the pool.
    for (var i = 0; i < _activeKeys.length; i += 1) {
      final key = _activeKeys[i];
      final bucket = _buckets.remove(key);
      if (bucket == null) continue;
      bucket.clear();
      _bucketPool.add(bucket);
    }
    _activeKeys.clear();

    _surfaceCount = surfaces.length;
    if (surfaces.isEmpty) return;

    // Insert each surface into all cells it overlaps.
    for (var si = 0; si < surfaces.length; si += 1) {
      final surface = surfaces[si];
      
      // Surface AABB: horizontal span + thin vertical slab.
      final minX = surface.xMin;
      final maxX = surface.xMax;
      final minY = surface.yTop - surfaceThickness;
      final maxY = surface.yTop + surfaceThickness;

      // Convert to cell coordinates.
      final minCx = _index.worldToCellX(minX);
      final maxCx = _index.worldToCellX(maxX);
      final minCy = _index.worldToCellY(minY);
      final maxCy = _index.worldToCellY(maxY);

      // Insert surface index into each overlapping cell.
      for (var cellY = minCy; cellY <= maxCy; cellY += 1) {
        for (var cellX = minCx; cellX <= maxCx; cellX += 1) {
          final key = _index.cellKey(cellX, cellY);
          var bucket = _buckets[key];
          if (bucket == null) {
            // Reuse pooled bucket or allocate new.
            bucket = _bucketPool.isNotEmpty ? _bucketPool.removeLast() : <int>[];
            _buckets[key] = bucket;
            _activeKeys.add(key);
          }
          bucket.add(si);
        }
      }
    }
  }

  /// Finds all surfaces overlapping the given AABB.
  ///
  /// Results are written to [outSurfaceIndices] (cleared first).
  /// Each surface index appears at most once (deduplicated via stamp).
  ///
  /// **Performance**: O(C * B) where C = cells in query, B = avg bucket size.
  void queryAabb({
    required double minX,
    required double minY,
    required double maxX,
    required double maxY,
    required List<int> outSurfaceIndices,
  }) {
    outSurfaceIndices.clear();
    if (_activeKeys.isEmpty) return;

    // Advance the deduplication stamp.
    _stamp += 1;
    if (_stamp == 0x7FFFFFFF) {
      // Overflow protection: reset all stamps.
      for (var i = 0; i < _seenStampBySurface.length; i += 1) {
        _seenStampBySurface[i] = 0;
      }
      _stamp = 1;
    }

    // Determine cell range for query AABB.
    final minCx = _index.worldToCellX(minX);
    final maxCx = _index.worldToCellX(maxX);
    final minCy = _index.worldToCellY(minY);
    final maxCy = _index.worldToCellY(maxY);

    // Ensure stamp array is large enough.
    if (_seenStampBySurface.length < _surfaceCount) {
      final missing = _surfaceCount - _seenStampBySurface.length;
      for (var i = 0; i < missing; i += 1) {
        _seenStampBySurface.add(0);
      }
    }

    // Iterate all cells in query range.
    for (var cellY = minCy; cellY <= maxCy; cellY += 1) {
      for (var cellX = minCx; cellX <= maxCx; cellX += 1) {
        final key = _index.cellKey(cellX, cellY);
        final bucket = _buckets[key];
        if (bucket == null || bucket.isEmpty) continue;

        // Add each unseen surface to results.
        for (var bi = 0; bi < bucket.length; bi += 1) {
          final surfaceIndex = bucket[bi];
          if (_seenStampBySurface[surfaceIndex] == _stamp) continue;
          _seenStampBySurface[surfaceIndex] = _stamp;
          outSurfaceIndices.add(surfaceIndex);
        }
      }
    }
  }
}


===== FILE: lib/core/navigation/utils/trajectory_predictor.dart =====
import '../types/surface_graph.dart';
import 'surface_spatial_index.dart';

/// Prediction result for where an airborne entity will land.
class LandingPrediction {
  const LandingPrediction({
    required this.x,
    required this.bottomY,
    required this.surfaceIndex,
    required this.ticksToLand,
  });

  /// Predicted X position at landing.
  final double x;

  /// Predicted bottom Y position at landing (on surface).
  final double bottomY;

  /// Index of the surface in [SurfaceGraph.surfaces] where landing occurs.
  final int surfaceIndex;

  /// Number of ticks until landing.
  final int ticksToLand;
}

/// Predicts where an airborne entity will land.
///
/// **Purpose**:
/// Used by ground enemy AI to anticipate where an airborne player will land,
/// enabling pathfinding toward the predicted landing spot instead of the
/// player's current (airborne) position.
///
/// **Algorithm**:
/// Simulates the entity's trajectory tick-by-tick using semi-implicit Euler
/// integration (matching [GravitySystem]), checking for surface intersections
/// at each step.
///
/// **Usage**:
/// ```dart
/// final predictor = TrajectoryPredictor(
///   gravityY: physics.gravityY,
///   dtSeconds: movement.dtSeconds,
///   maxTicks: 120,
/// );
///
/// final prediction = predictor.predictLanding(
///   startX: playerX,
///   startBottomY: playerBottomY,
///   velX: playerVelX,
///   velY: playerVelY,
///   graph: surfaceGraph,
///   spatialIndex: surfaceSpatialIndex,
///   entityHalfWidth: playerHalfX,
/// );
/// ```
class TrajectoryPredictor {
  const TrajectoryPredictor({
    required this.gravityY,
    required this.dtSeconds,
    required this.maxTicks,
  });

  /// Gravity acceleration (positive = downward).
  final double gravityY;

  /// Fixed timestep in seconds.
  final double dtSeconds;

  /// Maximum ticks to simulate before giving up.
  final int maxTicks;

  /// Predicts landing position for an airborne entity.
  ///
  /// **Parameters**:
  /// - [startX], [startBottomY]: Current position (bottom of collider).
  /// - [velX], [velY]: Current velocity.
  /// - [graph]: Surface graph for landing candidates.
  /// - [spatialIndex]: Spatial index for fast surface queries.
  /// - [entityHalfWidth]: Half-width of the entity collider.
  ///
  /// **Returns**: [LandingPrediction] if a valid landing is found, null otherwise.
  ///
  /// **Edge Cases**:
  /// - Returns null if entity is moving upward and never descends (shouldn't happen with gravity).
  /// - Returns null if no surface intersects the trajectory within [maxTicks].
  /// - Returns the FIRST valid landing (earliest tick) if multiple surfaces are crossed.
  LandingPrediction? predictLanding({
    required double startX,
    required double startBottomY,
    required double velX,
    required double velY,
    required SurfaceGraph graph,
    required SurfaceSpatialIndex spatialIndex,
    required double entityHalfWidth,
  }) {
    if (graph.surfaces.isEmpty) return null;

    var x = startX;
    var y = startBottomY;
    var vy = velY;
    final dt = dtSeconds;

    // Reusable buffer for spatial queries.
    final candidates = <int>[];

    for (var tick = 1; tick <= maxTicks; tick += 1) {
      final prevY = y;

      // Semi-implicit Euler (matches GravitySystem).
      vy += gravityY * dt;
      y += vy * dt;
      x += velX * dt;

      // Only check for landing when descending (vy > 0 means moving downward).
      if (vy <= 0) continue;

      // Check if we crossed any surface between prevY and y.
      final landing = _findLandingSurface(
        graph: graph,
        spatialIndex: spatialIndex,
        candidates: candidates,
        x: x,
        prevY: prevY,
        y: y,
        entityHalfWidth: entityHalfWidth,
        tick: tick,
      );

      if (landing != null) {
        return landing;
      }
    }

    return null;
  }

  /// Checks if the trajectory crossed a valid landing surface this tick.
  LandingPrediction? _findLandingSurface({
    required SurfaceGraph graph,
    required SurfaceSpatialIndex spatialIndex,
    required List<int> candidates,
    required double x,
    required double prevY,
    required double y,
    required double entityHalfWidth,
    required int tick,
  }) {
    // Query surfaces in the vertical band we just traversed.
    final minY = prevY < y ? prevY : y;
    final maxY = prevY > y ? prevY : y;

    spatialIndex.queryAabb(
      minX: x - entityHalfWidth,
      minY: minY,
      maxX: x + entityHalfWidth,
      maxY: maxY,
      outSurfaceIndices: candidates,
    );

    if (candidates.isEmpty) return null;

    // Find the highest surface (lowest yTop) that we crossed.
    // This handles cases where trajectory passes through multiple surfaces.
    int? bestIndex;
    double? bestYTop;

    for (final surfaceIndex in candidates) {
      final surface = graph.surfaces[surfaceIndex];

      // Check horizontal overlap: entity must fit on surface.
      final entityMinX = x - entityHalfWidth;
      final entityMaxX = x + entityHalfWidth;
      if (entityMinX > surface.xMax || entityMaxX < surface.xMin) continue;

      // Check vertical crossing: prevY was above (or at) surface, y is at or below.
      // We want surfaces where prevY <= yTop <= y (crossed from above).
      final yTop = surface.yTop;
      if (prevY > yTop) continue; // Started below surface, can't land on it.
      if (y < yTop) continue; // Ended above surface, haven't reached it yet.

      // Valid landing candidate. Prefer highest surface (lowest yTop).
      if (bestYTop == null || yTop < bestYTop) {
        bestYTop = yTop;
        bestIndex = surfaceIndex;
      }
    }

    if (bestIndex == null) return null;

    return LandingPrediction(
      x: x,
      bottomY: bestYTop!,
      surfaceIndex: bestIndex,
      ticksToLand: tick,
    );
  }
}


===== FILE: lib/core/pickups/pickup_render_catalog.dart =====
import '../contracts/render_anim_set_definition.dart';
import '../snapshots/entity_render_snapshot.dart';
import '../snapshots/enums.dart';

const int _frameW = 16;
const int _frameH = 16;
const int _frames = 12;
const double _stepSeconds = 0.08;

const Map<AnimKey, int> _frameCountsByKey = <AnimKey, int>{
  AnimKey.idle: _frames,
};

const Map<AnimKey, double> _stepTimeSecondsByKey = <AnimKey, double>{
  AnimKey.idle: _stepSeconds,
};

RenderAnimSetDefinition _rowFromSheet({
  required String assetPath,
  required int row,
}) {
  return RenderAnimSetDefinition(
    frameWidth: _frameW,
    frameHeight: _frameH,
    sourcesByKey: <AnimKey, String>{AnimKey.idle: assetPath},
    frameCountsByKey: _frameCountsByKey,
    stepTimeSecondsByKey: _stepTimeSecondsByKey,
    rowByKey: <AnimKey, int>{AnimKey.idle: row},
  );
}

class PickupRenderCatalog {
  const PickupRenderCatalog();

  RenderAnimSetDefinition get(int pickupVariant) {
    switch (pickupVariant) {
      case PickupVariant.collectible:
        return _rowFromSheet(
          assetPath: 'entities/collectibles/coins.png',
          row: 0,
        );
      case PickupVariant.restorationHealth:
        return _rowFromSheet(
          assetPath: 'entities/regenerationItems/gems.png',
          row: 0,
        );
      case PickupVariant.restorationMana:
        return _rowFromSheet(
          assetPath: 'entities/regenerationItems/gems.png',
          row: 1,
        );
      case PickupVariant.restorationStamina:
        return _rowFromSheet(
          assetPath: 'entities/regenerationItems/gems.png',
          row: 2,
        );
      default:
        throw StateError(
          'No render animation defined for pickupVariant=$pickupVariant.',
        );
    }
  }
}


===== FILE: lib/core/players/characters/eloise.dart =====
library;

import '../../ecs/stores/body_store.dart';
import '../../ecs/stores/combat/creature_tag_store.dart';
import '../../ecs/stores/combat/damage_resistance_store.dart';
import '../../ecs/stores/combat/equipped_loadout_store.dart';
import '../../ecs/stores/combat/status_immunity_store.dart';
import '../../combat/creature_tag.dart';
import '../../snapshots/enums.dart';
import '../../projectiles/projectile_item_id.dart';
import '../../weapons/weapon_id.dart';
import '../player_character_definition.dart';
import '../player_catalog.dart';
import '../player_tuning.dart';
import '../../contracts/render_anim_set_definition.dart';

/// Baseline character definition: Éloïse.
///
/// All current "default player" values in v0 are treated as belonging to Éloïse.

// -----------------------------------------------------------------------------
// Éloïse render animation strip definitions (authoring-time)
// -----------------------------------------------------------------------------

const int eloiseAnimFrameWidth = 100;
const int eloiseAnimFrameHeight = 64;

const int eloiseAnimIdleFrames = 4;
const double eloiseAnimIdleStepSeconds = 0.14;

const int eloiseAnimStunFrames = 4;
const double eloiseAnimStunStepSeconds = 0.14;

const int eloiseAnimRunFrames = 7;
const double eloiseAnimRunStepSeconds = 0.08;

const int eloiseAnimWalkFrames = 7;
const double eloiseAnimWalkStepSeconds = 0.16;

const int eloiseAnimJumpFrames = 6;
const double eloiseAnimJumpStepSeconds = 0.10;

const int eloiseAnimFallFrames = 3;
const double eloiseAnimFallStepSeconds = 0.10;

const int eloiseAnimStrikeFrames = 6;
const double eloiseAnimStrikeStepSeconds = 0.06;

const int eloiseAnimBackStrikeFrames = 5;
const double eloiseAnimBackStrikeStepSeconds = 0.08;

const int eloiseAnimParryFrames = 6;
const double eloiseAnimParryStepSeconds = 0.06;

const int eloiseAnimCastFrames = 5;
const double eloiseAnimCastStepSeconds = 0.08;

const int eloiseAnimRangedFrames = eloiseAnimCastFrames;
const double eloiseAnimRangedStepSeconds = eloiseAnimCastStepSeconds;

// Shield bash should match sword strike tempo (6 frames x 0.06s).
const int eloiseAnimShieldBashFrames = eloiseAnimStrikeFrames;
const double eloiseAnimShieldBashStepSeconds = eloiseAnimStrikeStepSeconds;

// Shield block is authored as its own strip: 7 frames x ~0.052s ~= 0.364s.
// Keep it close to parry/strike total duration (~0.36s) for consistent gameplay timing.
const int eloiseAnimShieldBlockFrames = 7;
const double eloiseAnimShieldBlockStepSeconds = 0.052;

const int eloiseAnimDashFrames = 4;
const double eloiseAnimDashStepSeconds = 0.05;

const int eloiseAnimRollFrames = 10;
const double eloiseAnimRollStepSeconds = 0.05;

const int eloiseAnimHitFrames = 4;
const double eloiseAnimHitStepSeconds = 0.10;

const int eloiseAnimDeathFrames = 6;
const double eloiseAnimDeathStepSeconds = 0.12;

// Spawn reuses idle timing/frames until a dedicated strip exists.
const int eloiseAnimSpawnFrames = eloiseAnimIdleFrames;
const double eloiseAnimSpawnStepSeconds = eloiseAnimIdleStepSeconds;

const Map<AnimKey, int> eloiseAnimFrameCountsByKey = <AnimKey, int>{
  AnimKey.idle: eloiseAnimIdleFrames,
  AnimKey.stun: eloiseAnimStunFrames,
  AnimKey.run: eloiseAnimRunFrames,
  AnimKey.jump: eloiseAnimJumpFrames,
  AnimKey.fall: eloiseAnimFallFrames,
  AnimKey.strike: eloiseAnimStrikeFrames,
  AnimKey.backStrike: eloiseAnimBackStrikeFrames,
  AnimKey.parry: eloiseAnimParryFrames,
  AnimKey.cast: eloiseAnimCastFrames,
  AnimKey.ranged: eloiseAnimRangedFrames,
  AnimKey.shieldBash: eloiseAnimShieldBashFrames,
  AnimKey.shieldBlock: eloiseAnimShieldBlockFrames,
  AnimKey.dash: eloiseAnimDashFrames,
  AnimKey.roll: eloiseAnimRollFrames,
  AnimKey.hit: eloiseAnimHitFrames,
  AnimKey.death: eloiseAnimDeathFrames,
  AnimKey.spawn: eloiseAnimSpawnFrames,
  AnimKey.walk: eloiseAnimWalkFrames,
};

const Map<AnimKey, double> eloiseAnimStepTimeSecondsByKey = <AnimKey, double>{
  AnimKey.idle: eloiseAnimIdleStepSeconds,
  AnimKey.stun: eloiseAnimStunStepSeconds,
  AnimKey.run: eloiseAnimRunStepSeconds,
  AnimKey.jump: eloiseAnimJumpStepSeconds,
  AnimKey.fall: eloiseAnimFallStepSeconds,
  AnimKey.strike: eloiseAnimStrikeStepSeconds,
  AnimKey.backStrike: eloiseAnimBackStrikeStepSeconds,
  AnimKey.parry: eloiseAnimParryStepSeconds,
  AnimKey.cast: eloiseAnimCastStepSeconds,
  AnimKey.ranged: eloiseAnimRangedStepSeconds,
  AnimKey.shieldBash: eloiseAnimShieldBashStepSeconds,
  AnimKey.shieldBlock: eloiseAnimShieldBlockStepSeconds,
  AnimKey.dash: eloiseAnimDashStepSeconds,
  AnimKey.roll: eloiseAnimRollStepSeconds,
  AnimKey.hit: eloiseAnimHitStepSeconds,
  AnimKey.death: eloiseAnimDeathStepSeconds,
  AnimKey.spawn: eloiseAnimSpawnStepSeconds,
  AnimKey.walk: eloiseAnimWalkStepSeconds,
};

const Map<AnimKey, String> eloiseAnimSourcesByKey = <AnimKey, String>{
  AnimKey.idle: 'entities/player/idle.png',
  AnimKey.stun: 'entities/player/stun.png',
  AnimKey.run: 'entities/player/move.png',
  AnimKey.jump: 'entities/player/jump.png',
  AnimKey.fall: 'entities/player/fall.png',
  AnimKey.strike: 'entities/player/strike.png',
  AnimKey.backStrike: 'entities/player/back_strike.png',
  AnimKey.parry: 'entities/player/parry.png',
  AnimKey.cast: 'entities/player/cast.png',
  AnimKey.ranged: 'entities/player/cast.png',
  AnimKey.shieldBash: 'entities/player/shield_bash.png',
  AnimKey.shieldBlock: 'entities/player/shield_block.png',
  AnimKey.dash: 'entities/player/dash.png',
  AnimKey.roll: 'entities/player/roll.png',
  AnimKey.hit: 'entities/player/hit.png',
  AnimKey.death: 'entities/player/death.png',
  AnimKey.spawn: 'entities/player/idle.png',
  AnimKey.walk: 'entities/player/walk.png',
};

const RenderAnimSetDefinition eloiseRenderAnim = RenderAnimSetDefinition(
  frameWidth: eloiseAnimFrameWidth,
  frameHeight: eloiseAnimFrameHeight,
  sourcesByKey: eloiseAnimSourcesByKey,
  frameCountsByKey: eloiseAnimFrameCountsByKey,
  stepTimeSecondsByKey: eloiseAnimStepTimeSecondsByKey,
);

// -----------------------------------------------------------------------------
// Éloïse authored Core values (single-file source of truth)
// -----------------------------------------------------------------------------

const PlayerCatalog eloiseCatalog = PlayerCatalog(
  bodyTemplate: BodyDef(
    isKinematic: false,
    useGravity: true,
    ignoreCeilings: false,
    topOnlyGround: true,
    gravityScale: 1.0,
    sideMask: BodyDef.sideLeft | BodyDef.sideRight,
  ),
  colliderWidth: 22.0,
  colliderHeight: 46.0,
  colliderOffsetX: 0.0,
  colliderOffsetY: 0.0,
  tags: CreatureTagDef(mask: CreatureTagMask.humanoid),
  resistance: DamageResistanceDef(),
  statusImmunity: StatusImmunityDef(),
  loadoutSlotMask: LoadoutSlotMask.all,
  weaponId: WeaponId.basicSword,
  offhandWeaponId: WeaponId.basicShield,
  projectileItemId: ProjectileItemId.fireBolt,
  facing: Facing.right,
);

const PlayerTuning eloiseTuning = PlayerTuning(
  movement: MovementTuning(
    maxSpeedX: 200,
    accelerationX: 600,
    decelerationX: 400,
    minMoveSpeed: 5,
    runSpeedThresholdX: 120,
    maxVelX: 1500,
    maxVelY: 1500,
    jumpSpeed: 500,
    coyoteTimeSeconds: 0.10,
    jumpBufferSeconds: 0.12,
    dashSpeedX: 550,
    dashDurationSeconds: 0.20,
    dashCooldownSeconds: 2.0,
  ),
  resource: ResourceTuning(
    playerHpMax: 100,
    playerHpRegenPerSecond: 0.5,
    playerManaMax: 100,
    playerManaRegenPerSecond: 2.0,
    playerStaminaMax: 100,
    playerStaminaRegenPerSecond: 1.0,
    jumpStaminaCost: 2,
    dashStaminaCost: 2,
  ),
  ability: AbilityTuning(
    castCooldownSeconds: 0.25,
    meleeCooldownSeconds: 0.30,
    meleeActiveSeconds: 0.10,
    meleeStaminaCost: 5.0,
    meleeDamage: 15.0,
    meleeHitboxSizeX: 32.0,
    meleeHitboxSizeY: 32.0,
  ),
  // Keep these windows in sync with Éloïse's render strips above.
  anim: AnimTuning(
    hitAnimSeconds: eloiseAnimHitFrames * eloiseAnimHitStepSeconds,
    castAnimSeconds: eloiseAnimCastFrames * eloiseAnimCastStepSeconds,
    strikeAnimSeconds: eloiseAnimStrikeFrames * eloiseAnimStrikeStepSeconds,
    backStrikeAnimSeconds:
        eloiseAnimBackStrikeFrames * eloiseAnimBackStrikeStepSeconds,
    parryAnimSeconds: eloiseAnimParryFrames * eloiseAnimParryStepSeconds,
    rangedAnimSeconds: eloiseAnimRangedFrames * eloiseAnimRangedStepSeconds,
    dashAnimSeconds: eloiseAnimDashFrames * eloiseAnimDashStepSeconds,
    rollAnimSeconds: eloiseAnimRollFrames * eloiseAnimRollStepSeconds,
    deathAnimSeconds: eloiseAnimDeathFrames * eloiseAnimDeathStepSeconds,
    spawnAnimSeconds: eloiseAnimSpawnFrames * eloiseAnimSpawnStepSeconds,
  ),
  combat: CombatTuning(invulnerabilitySeconds: 0.25),
);

const PlayerCharacterDefinition eloiseCharacter = PlayerCharacterDefinition(
  id: PlayerCharacterId.eloise,
  displayName: 'Éloïse',
  renderAnim: eloiseRenderAnim,
  catalog: eloiseCatalog,
  tuning: eloiseTuning,
);


===== FILE: lib/core/players/player_archetype.dart =====
import '../ecs/stores/body_store.dart';
import '../ecs/stores/collider_aabb_store.dart';
import '../ecs/stores/combat/creature_tag_store.dart';
import '../ecs/stores/combat/damage_resistance_store.dart';
import '../ecs/stores/combat/equipped_loadout_store.dart';
import '../ecs/stores/combat/status_immunity_store.dart';
import '../ecs/stores/health_store.dart';
import '../ecs/stores/mana_store.dart';
import '../ecs/stores/stamina_store.dart';
import '../snapshots/enums.dart';
import '../projectiles/projectile_item_id.dart';
import '../weapons/weapon_id.dart';

/// Fully-resolved player configuration used to spawn the player entity.
///
/// **Purpose**:
/// Contains all the component definitions needed to instantiate a player
/// entity in the ECS world. Unlike [PlayerCatalog], which holds authoring-time
/// templates, this class holds final, tick-rate-independent values ready for
/// entity creation.
///
/// **Lifecycle**:
/// 1. [PlayerCatalog] defines base templates (physics flags, default facing).
/// 2. [PlayerCatalogDerived.from] merges templates with tuning data to produce
///    a [PlayerArchetype].
/// 3. [EntityFactory.createPlayer] uses the archetype to add components..
class PlayerArchetype {
  const PlayerArchetype({
    required this.collider,
    required this.body,
    required this.health,
    required this.mana,
    required this.stamina,
    this.tags = const CreatureTagDef(),
    this.resistance = const DamageResistanceDef(),
    this.statusImmunity = const StatusImmunityDef(),
    this.loadoutSlotMask = LoadoutSlotMask.defaultMask,
    this.weaponId = WeaponId.basicSword,
    this.offhandWeaponId = WeaponId.basicShield,
    this.projectileItemId = ProjectileItemId.iceBolt,
    this.facing = Facing.right,
  });

  /// AABB collider definition (half-extents and offset).
  ///
  /// Determines the player's collision bounds for physics and hit detection.
  /// Typically derived from [PlayerCatalog.colliderWidth] and
  /// [PlayerCatalog.colliderHeight].
  final ColliderAabbDef collider;

  /// Physics body configuration (gravity, kinematic flags, velocity clamps).
  ///
  /// Controls how the player interacts with the physics simulation:
  /// - `useGravity`: Whether gravity affects the player.
  /// - `maxVelX/maxVelY`: Velocity clamps from movement tuning.
  /// - `sideMask`: Which collision sides are active.
  final BodyDef body;

  /// Health pool definition (current HP, max HP, regeneration rate).
  ///
  /// Values derived from [ResourceTuning.playerHpMax] and related fields.
  final HealthDef health;

  /// Mana pool definition (current mana, max mana, regeneration rate).
  ///
  /// Used for projectile abilities. Values from [ResourceTuning.playerManaMax].
  final ManaDef mana;

  /// Stamina pool definition (current stamina, max stamina, regeneration rate).
  ///
  /// Used for abilities like dash. Values from [ResourceTuning.playerStaminaMax].
  final StaminaDef stamina;

  /// Broad tags used by combat rules and content filters.
  final CreatureTagDef tags;

  /// Resistance/vulnerability modifiers by damage type.
  final DamageResistanceDef resistance;

  /// Status effect immunities for the player.
  final StatusImmunityDef statusImmunity;

  /// Bitmask of enabled loadout slots (see [LoadoutSlotMask]).
  final int loadoutSlotMask;

  /// Equipped weapon used for melee strikes.
  final WeaponId weaponId;

  /// Equipped off-hand weapon or shield.
  final WeaponId offhandWeaponId;

  /// Equipped projectile item used for thrown/ballistic projectiles.
  final ProjectileItemId projectileItemId;

  /// Initial facing direction when the player spawns.
  ///
  /// Affects sprite rendering and directional abilities.
  final Facing facing;
}


===== FILE: lib/core/players/player_catalog.dart =====
import '../combat/creature_tag.dart';
import '../ecs/stores/body_store.dart';
import '../ecs/stores/collider_aabb_store.dart';
import '../ecs/stores/combat/creature_tag_store.dart';
import '../ecs/stores/combat/damage_resistance_store.dart';
import '../ecs/stores/combat/equipped_loadout_store.dart';
import '../ecs/stores/combat/status_immunity_store.dart';
import '../ecs/stores/health_store.dart';
import '../ecs/stores/mana_store.dart';
import '../ecs/stores/stamina_store.dart';
import '../snapshots/enums.dart';
import 'player_tuning.dart';
import '../projectiles/projectile_item_id.dart';
import '../weapons/weapon_id.dart';
import 'player_archetype.dart';

/// Authoring-time configuration for the player entity.
///
/// **Purpose**:
/// Defines the base template for player physics and spawn behavior. This class
/// holds values that are independent of tick rate or specific tuning numbers,
/// focusing on structural configuration (what physics flags to use, etc.).
///
/// **Relationship to Tuning**:
/// - [PlayerCatalog]: Structural config (physics flags, collision sides).
/// - [MovementTuning]: Numeric movement values (speed, collider size, velocity clamps).
/// - [ResourceTuning]: Numeric resource values (HP, mana, stamina).
///
/// The [PlayerCatalogDerived.from] factory merges all three to produce a
/// complete [PlayerArchetype] ready for entity creation.
class PlayerCatalog {
  const PlayerCatalog({
    this.bodyTemplate = const BodyDef(
      isKinematic: false,
      useGravity: true,
      ignoreCeilings: false,
      topOnlyGround: true,
      gravityScale: 1.0,
      sideMask: BodyDef.sideLeft | BodyDef.sideRight,
    ),
    this.colliderWidth = 22.0,
    this.colliderHeight = 46.0,
    this.colliderOffsetX = 0.0,
    this.colliderOffsetY = -6.0,
    this.tags = const CreatureTagDef(mask: CreatureTagMask.humanoid),
    this.resistance = const DamageResistanceDef(),
    this.statusImmunity = const StatusImmunityDef(),
    this.loadoutSlotMask = LoadoutSlotMask.defaultMask,
    this.weaponId = WeaponId.basicSword,
    this.offhandWeaponId = WeaponId.basicShield,
    this.projectileItemId = ProjectileItemId.iceBolt,
    this.facing = Facing.right,
  });

  /// Template for how the player participates in physics.
  ///
  /// **Fields used from template**:
  /// - `isKinematic`: False for player (affected by forces).
  /// - `useGravity`: True (player falls).
  /// - `ignoreCeilings`: False (player collides with ceilings).
  /// - `topOnlyGround`: True (only collide with top of ground, not sides).
  /// - `gravityScale`: 1.0 (normal gravity).
  /// - `sideMask`: Left + Right (collide with walls on both sides).
  ///
  /// **Fields filled from [MovementTuning] during derivation**:
  /// - `maxVelX`: Horizontal velocity clamp.
  /// - `maxVelY`: Vertical velocity clamp.
  ///
  /// This split ensures movement tuning remains the single source of truth
  /// for velocity limits.
  final BodyDef bodyTemplate;

  /// Player collision AABB size (full extents) in world units.
  ///
  /// Core uses center-based AABBs, so `halfX = width * 0.5` and
  /// `halfY = height * 0.5`.
  final double colliderWidth;
  final double colliderHeight;

  /// Optional collider center offset from entity `Transform.pos`.
  final double colliderOffsetX;
  final double colliderOffsetY;

  double get colliderHalfX => colliderWidth * 0.5;
  double get colliderHalfY => colliderHeight * 0.5;
  double get colliderMaxHalfExtent =>
      colliderHalfX > colliderHalfY ? colliderHalfX : colliderHalfY;

  /// Broad tags used by combat rules and content filters.
  final CreatureTagDef tags;

  /// Resistance/vulnerability modifiers by damage type.
  final DamageResistanceDef resistance;

  /// Status effect immunities for the player.
  final StatusImmunityDef statusImmunity;

  /// Bitmask of enabled loadout slots (see [LoadoutSlotMask]).
  final int loadoutSlotMask;

  /// Default equipped weapon at spawn time.
  final WeaponId weaponId;

  /// Default equipped off-hand weapon or shield at spawn time.
  final WeaponId offhandWeaponId;

  /// Default equipped projectile item at spawn time.
  final ProjectileItemId projectileItemId;

  /// Default facing direction at spawn time.
  ///
  /// Determines initial sprite orientation and directional ability targeting.
  final Facing facing;
}

/// Derived player configuration with tick-rate-resolved values.
///
/// **Purpose**:
/// Combines [PlayerCatalog] templates with [MovementTuning] and [ResourceTuning]
/// to produce a complete [PlayerArchetype]. This is the "compiled" form of
/// player configuration, ready for entity creation.
///
/// **Why a Separate Class?**:
/// - Tuning values may be tick-rate dependent (e.g., regen per second → per tick).
/// - Collider size comes from movement tuning, not catalog.
/// - Resource pools (HP, mana, stamina) come from resource tuning.
/// - Keeping derivation explicit makes dependencies clear and testable.
///
/// **Lifecycle**:
/// Created once at game initialization, stored in [GameCore], used whenever
/// the player needs to be spawned or respawned.
class PlayerCatalogDerived {
  const PlayerCatalogDerived._({required this.archetype});

  /// Creates a derived catalog by merging base config with tuning data.
  ///
  /// **Parameters**:
  /// - [base]: The authoring-time catalog with physics flags.
  /// - [movement]: Movement tuning for collider size and velocity clamps.
  /// - [resources]: Resource tuning for HP, mana, and stamina pools.
  ///
  /// **Derivation Logic**:
  /// 1. Copy physics flags from [base.bodyTemplate].
  /// 2. Fill `maxVelX`/`maxVelY` from [movement].
  /// 3. Create AABB collider from [base].
  /// 4. Create resource pools from [resources].
  /// 5. Bundle everything into a [PlayerArchetype].
  factory PlayerCatalogDerived.from(
    PlayerCatalog base, {
    required MovementTuningDerived movement,
    required ResourceTuningDerived resources,
  }) {
    // Merge body template with velocity clamps from movement tuning.
    final body = BodyDef(
      enabled: base.bodyTemplate.enabled,
      isKinematic: base.bodyTemplate.isKinematic,
      useGravity: base.bodyTemplate.useGravity,
      ignoreCeilings: base.bodyTemplate.ignoreCeilings,
      topOnlyGround: base.bodyTemplate.topOnlyGround,
      gravityScale: base.bodyTemplate.gravityScale,
      maxVelX: movement.base.maxVelX,
      maxVelY: movement.base.maxVelY,
      sideMask: base.bodyTemplate.sideMask,
    );

    // AABB collider from catalog.
    final collider = ColliderAabbDef(
      halfX: base.colliderHalfX,
      halfY: base.colliderHalfY,
      offsetX: base.colliderOffsetX,
      offsetY: base.colliderOffsetY,
    );

    // Resource pools from resource tuning.
    final health = HealthDef(
      hp: resources.playerHpMax100,
      hpMax: resources.playerHpMax100,
      regenPerSecond100: resources.playerHpRegenPerSecond100,
    );
    final mana = ManaDef(
      mana: resources.playerManaMax100,
      manaMax: resources.playerManaMax100,
      regenPerSecond100: resources.playerManaRegenPerSecond100,
    );
    final stamina = StaminaDef(
      stamina: resources.playerStaminaMax100,
      staminaMax: resources.playerStaminaMax100,
      regenPerSecond100: resources.playerStaminaRegenPerSecond100,
    );

    return PlayerCatalogDerived._(
      archetype: PlayerArchetype(
        collider: collider,
        body: body,
        health: health,
        mana: mana,
        stamina: stamina,
        tags: base.tags,
        resistance: base.resistance,
        statusImmunity: base.statusImmunity,
        loadoutSlotMask: base.loadoutSlotMask,
        weaponId: base.weaponId,
        offhandWeaponId: base.offhandWeaponId,
        projectileItemId: base.projectileItemId,
        facing: base.facing,
      ),
    );
  }

  /// The fully-resolved player archetype ready for entity creation.
  ///
  /// Use this with [EntityFactory.createPlayer] to spawn the player entity.
  final PlayerArchetype archetype;
}


===== FILE: lib/core/players/player_character_definition.dart =====
library;

import '../contracts/render_anim_set_definition.dart';
import '../snapshots/enums.dart';
import 'player_tuning.dart';
import 'player_catalog.dart';

enum PlayerCharacterId { eloise }

class PlayerCharacterDefinition {
  const PlayerCharacterDefinition({
    required this.id,
    required this.displayName,
    required this.renderAnim,
    this.catalog = const PlayerCatalog(),
    this.tuning = const PlayerTuning(),
  });

  final PlayerCharacterId id;
  final String displayName;

  /// Render-only animation metadata (strip paths, frame size, timing).
  ///
  /// Core owns the timing numbers so render strips and deterministic animation
  /// windows can stay in sync, but the renderer remains the only layer that
  /// loads assets.
  final RenderAnimSetDefinition renderAnim;

  /// Structural player configuration (collider size/offset, physics flags, etc.).
  final PlayerCatalog catalog;

  /// Per-character numeric tuning bundle.
  final PlayerTuning tuning;

  PlayerCharacterDefinition copyWith({
    String? displayName,
    RenderAnimSetDefinition? renderAnim,
    PlayerCatalog? catalog,
    PlayerTuning? tuning,
  }) {
    return PlayerCharacterDefinition(
      id: id,
      displayName: displayName ?? this.displayName,
      renderAnim: renderAnim ?? this.renderAnim,
      catalog: catalog ?? this.catalog,
      tuning: tuning ?? this.tuning,
    );
  }

  /// Debug-only validation for authoring-time character definitions.
  ///
  /// This is intended to fail fast during development when a new character is
  /// added with incomplete render strip metadata or invalid collider sizes.
  ///
  /// In release builds, asserts are stripped and this becomes a no-op.
  void assertValid() {
    assert(() {
      if (displayName.trim().isEmpty) {
        throw StateError(
          'PlayerCharacterDefinition($id) has empty displayName',
        );
      }

      // Catalog invariants.
      if (!catalog.colliderWidth.isFinite ||
          !catalog.colliderHeight.isFinite ||
          catalog.colliderWidth <= 0 ||
          catalog.colliderHeight <= 0) {
        throw StateError(
          'PlayerCharacterDefinition($id) has invalid collider size '
          '(width=${catalog.colliderWidth}, height=${catalog.colliderHeight})',
        );
      }
      if (!catalog.colliderOffsetX.isFinite ||
          !catalog.colliderOffsetY.isFinite) {
        throw StateError(
          'PlayerCharacterDefinition($id) has non-finite collider offsets '
          '(x=${catalog.colliderOffsetX}, y=${catalog.colliderOffsetY})',
        );
      }

      // Render anim invariants.
      if (renderAnim.frameWidth <= 0 || renderAnim.frameHeight <= 0) {
        throw StateError(
          'PlayerCharacterDefinition($id) has invalid render frame size '
          '(${renderAnim.frameWidth}x${renderAnim.frameHeight})',
        );
      }
      if (!renderAnim.sourcesByKey.containsKey(AnimKey.idle)) {
        throw StateError(
          'PlayerCharacterDefinition($id) renderAnim.sourcesByKey must include AnimKey.idle',
        );
      }
      if (!renderAnim.frameCountsByKey.containsKey(AnimKey.idle)) {
        throw StateError(
          'PlayerCharacterDefinition($id) renderAnim.frameCountsByKey must include AnimKey.idle',
        );
      }
      if (!renderAnim.stepTimeSecondsByKey.containsKey(AnimKey.idle)) {
        throw StateError(
          'PlayerCharacterDefinition($id) renderAnim.stepTimeSecondsByKey must include AnimKey.idle',
        );
      }

      for (final entry in renderAnim.sourcesByKey.entries) {
        final key = entry.key;
        final path = entry.value;
        if (path.trim().isEmpty) {
          throw StateError(
            'PlayerCharacterDefinition($id) renderAnim.sourcesByKey[$key] is empty',
          );
        }

        // Frame counts / step times are allowed to be omitted per-key; render
        // falls back to the `idle` values in that case. If a value is provided
        // for the key, validate it.
        final count = renderAnim.frameCountsByKey[key];
        if (count != null && count <= 0) {
          throw StateError(
            'PlayerCharacterDefinition($id) renderAnim.frameCountsByKey[$key] must be > 0 (got $count)',
          );
        }
        final seconds = renderAnim.stepTimeSecondsByKey[key];
        if (seconds != null && (!seconds.isFinite || seconds <= 0)) {
          throw StateError(
            'PlayerCharacterDefinition($id) renderAnim.stepTimeSecondsByKey[$key] must be > 0 (got $seconds)',
          );
        }
      }

      for (final entry in renderAnim.frameCountsByKey.entries) {
        final key = entry.key;
        final count = entry.value;
        if (count <= 0) {
          throw StateError(
            'PlayerCharacterDefinition($id) renderAnim.frameCountsByKey[$key] must be > 0 (got $count)',
          );
        }
        if (key != AnimKey.idle && !renderAnim.sourcesByKey.containsKey(key)) {
          throw StateError(
            'PlayerCharacterDefinition($id) renderAnim.frameCountsByKey[$key] has no matching sourcesByKey entry',
          );
        }
      }

      for (final entry in renderAnim.stepTimeSecondsByKey.entries) {
        final key = entry.key;
        final seconds = entry.value;
        if (!seconds.isFinite || seconds <= 0) {
          throw StateError(
            'PlayerCharacterDefinition($id) renderAnim.stepTimeSecondsByKey[$key] must be > 0 (got $seconds)',
          );
        }
        if (key != AnimKey.idle && !renderAnim.sourcesByKey.containsKey(key)) {
          throw StateError(
            'PlayerCharacterDefinition($id) renderAnim.stepTimeSecondsByKey[$key] has no matching sourcesByKey entry',
          );
        }
      }

      for (final entry in renderAnim.rowByKey.entries) {
        final key = entry.key;
        final row = entry.value;
        if (row < 0) {
          throw StateError(
            'PlayerCharacterDefinition($id) renderAnim.rowByKey[$key] must be >= 0 (got $row)',
          );
        }
        if (!renderAnim.sourcesByKey.containsKey(key)) {
          throw StateError(
            'PlayerCharacterDefinition($id) renderAnim.rowByKey[$key] has no matching sourcesByKey entry',
          );
        }
        if (!renderAnim.frameCountsByKey.containsKey(key)) {
          throw StateError(
            'PlayerCharacterDefinition($id) renderAnim.rowByKey[$key] has no matching frameCountsByKey entry',
          );
        }
      }

      for (final entry in renderAnim.frameStartByKey.entries) {
        final key = entry.key;
        final start = entry.value;
        if (start < 0) {
          throw StateError(
            'PlayerCharacterDefinition($id) renderAnim.frameStartByKey[$key] must be >= 0 (got $start)',
          );
        }
        if (!renderAnim.sourcesByKey.containsKey(key)) {
          throw StateError(
            'PlayerCharacterDefinition($id) renderAnim.frameStartByKey[$key] has no matching sourcesByKey entry',
          );
        }
        if (!renderAnim.frameCountsByKey.containsKey(key)) {
          throw StateError(
            'PlayerCharacterDefinition($id) renderAnim.frameStartByKey[$key] has no matching frameCountsByKey entry',
          );
        }
      }

      final anchor = renderAnim.anchorInFramePx;
      if (anchor != null) {
        if (!anchor.x.isFinite || !anchor.y.isFinite) {
          throw StateError(
            'PlayerCharacterDefinition($id) renderAnim.anchorInFramePx must be finite (got $anchor)',
          );
        }
        if (anchor.x < 0 ||
            anchor.x > renderAnim.frameWidth ||
            anchor.y < 0 ||
            anchor.y > renderAnim.frameHeight) {
          throw StateError(
            'PlayerCharacterDefinition($id) renderAnim.anchorInFramePx must be within the frame '
            '(0..${renderAnim.frameWidth}, 0..${renderAnim.frameHeight}). Got $anchor',
          );
        }
      }

      // Tuning invariants (only basic sanity checks here).
      if (!tuning.anim.hitAnimSeconds.isFinite ||
          !tuning.anim.castAnimSeconds.isFinite ||
          !tuning.anim.strikeAnimSeconds.isFinite ||
          !tuning.anim.deathAnimSeconds.isFinite ||
          !tuning.anim.spawnAnimSeconds.isFinite ||
          !tuning.anim.rangedAnimSeconds.isFinite) {
        throw StateError(
          'PlayerCharacterDefinition($id) has non-finite AnimTuning seconds',
        );
      }

      return true;
    }());
  }
}


===== FILE: lib/core/players/player_character_registry.dart =====
library;

import 'characters/eloise.dart';
import 'player_character_definition.dart';

class PlayerCharacterRegistry {
  const PlayerCharacterRegistry._();

  static const PlayerCharacterDefinition eloise = eloiseCharacter;

  static const PlayerCharacterDefinition defaultCharacter = eloise;

  static const List<PlayerCharacterDefinition> all = [eloise];

  static final Map<PlayerCharacterId, PlayerCharacterDefinition> byId =
      _buildById(all);

  static Map<PlayerCharacterId, PlayerCharacterDefinition> _buildById(
    List<PlayerCharacterDefinition> defs,
  ) {
    assert(() {
      for (final d in defs) {
        d.assertValid();
      }
      return true;
    }());

    final map = <PlayerCharacterId, PlayerCharacterDefinition>{};
    for (final d in defs) {
      final existing = map[d.id];
      if (existing != null) {
        throw StateError('Duplicate PlayerCharacterId ${d.id} in registry');
      }
      map[d.id] = d;
    }
    return map;
  }
}


===== FILE: lib/core/players/player_tuning.dart =====
/// Player tuning (single-file source of truth).
///
/// This module intentionally centralizes all player-specific tuning:
/// movement + resources + abilities + combat + animation (and derived/cache
/// variants). This keeps per-character definitions DRY: they can reference a
/// single import and override only what differs.
library;

import '../snapshots/enums.dart';
import '../util/tick_math.dart';
import '../util/fixed_math.dart';
import '../tuning/utils/anim_tuning.dart' as anim_utils;

// ─────────────────────────────────────────────────────────────────────────────
// Player animation strip definitions (frame counts / step times) live in
// character files (e.g. `lib/core/players/characters/eloise.dart`).
// ─────────────────────────────────────────────────────────────────────────────

// Keep [AnimTuning] windows in sync with the selected character's strips.

// ─────────────────────────────────────────────────────────────────────────────
// Player movement tuning (author in seconds, applied per fixed tick)
// ─────────────────────────────────────────────────────────────────────────────

const int defaultTickHz = 60;

class MovementTuning {
  const MovementTuning({
    this.maxSpeedX = 200,
    this.accelerationX = 600,
    this.decelerationX = 400,
    this.minMoveSpeed = 5,
    this.runSpeedThresholdX = 60,
    this.maxVelX = 1500,
    this.maxVelY = 1500,
    this.jumpSpeed = 500,
    this.coyoteTimeSeconds = 0.10,
    this.jumpBufferSeconds = 0.12,
    this.dashSpeedX = 550,
    this.dashDurationSeconds = 0.20,
    this.dashCooldownSeconds = 2.0,
  });

  final double maxSpeedX;
  final double accelerationX;
  final double decelerationX;
  final double minMoveSpeed;
  final double runSpeedThresholdX;

  final double maxVelX;
  final double maxVelY;

  final double jumpSpeed;

  final double coyoteTimeSeconds;
  final double jumpBufferSeconds;

  final double dashSpeedX;
  final double dashDurationSeconds;
  final double dashCooldownSeconds;
}

class MovementTuningDerived {
  const MovementTuningDerived._({
    required this.tickHz,
    required this.dtSeconds,
    required this.base,
    required this.coyoteTicks,
    required this.jumpBufferTicks,
    required this.dashDurationTicks,
    required this.dashCooldownTicks,
  });

  factory MovementTuningDerived.from(MovementTuning base, {required int tickHz}) {
    if (tickHz <= 0) {
      throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
    }
    return MovementTuningDerived._(
      tickHz: tickHz,
      dtSeconds: 1.0 / tickHz,
      base: base,
      coyoteTicks: ticksFromSecondsCeil(base.coyoteTimeSeconds, tickHz),
      jumpBufferTicks: ticksFromSecondsCeil(base.jumpBufferSeconds, tickHz),
      dashDurationTicks: ticksFromSecondsCeil(base.dashDurationSeconds, tickHz),
      dashCooldownTicks: ticksFromSecondsCeil(base.dashCooldownSeconds, tickHz),
    );
  }

  final int tickHz;
  final double dtSeconds;
  final MovementTuning base;

  final int coyoteTicks;
  final int jumpBufferTicks;
  final int dashDurationTicks;
  final int dashCooldownTicks;
}

// ─────────────────────────────────────────────────────────────────────────────
// Player resources tuning (hp/mana/stamina + regen + costs)
// ─────────────────────────────────────────────────────────────────────────────

class ResourceTuning {
  const ResourceTuning({
    this.playerHpMax = 100,
    this.playerHpRegenPerSecond = 0.5,
    this.playerManaMax = 100,
    this.playerManaRegenPerSecond = 2.0,
    this.playerStaminaMax = 100,
    this.playerStaminaRegenPerSecond = 1.0,
    this.jumpStaminaCost = 2,
    this.dashStaminaCost = 2,
  });

  final double playerHpMax;
  final double playerHpRegenPerSecond;

  final double playerManaMax;
  final double playerManaRegenPerSecond;

  final double playerStaminaMax;
  final double playerStaminaRegenPerSecond;

  final double jumpStaminaCost;
  final double dashStaminaCost;
}

class ResourceTuningDerived {
  const ResourceTuningDerived({
    required this.playerHpMax100,
    required this.playerHpRegenPerSecond100,
    required this.playerManaMax100,
    required this.playerManaRegenPerSecond100,
    required this.playerStaminaMax100,
    required this.playerStaminaRegenPerSecond100,
    required this.jumpStaminaCost100,
    required this.dashStaminaCost100,
  });

  factory ResourceTuningDerived.from(ResourceTuning base) {
    return ResourceTuningDerived(
      playerHpMax100: toFixed100(base.playerHpMax),
      playerHpRegenPerSecond100: toFixed100(base.playerHpRegenPerSecond),
      playerManaMax100: toFixed100(base.playerManaMax),
      playerManaRegenPerSecond100: toFixed100(base.playerManaRegenPerSecond),
      playerStaminaMax100: toFixed100(base.playerStaminaMax),
      playerStaminaRegenPerSecond100: toFixed100(base.playerStaminaRegenPerSecond),
      jumpStaminaCost100: toFixed100(base.jumpStaminaCost),
      dashStaminaCost100: toFixed100(base.dashStaminaCost),
    );
  }

  /// Fixed-point: 100 = 1.0
  final int playerHpMax100;
  final int playerHpRegenPerSecond100;
  final int playerManaMax100;
  final int playerManaRegenPerSecond100;
  final int playerStaminaMax100;
  final int playerStaminaRegenPerSecond100;
  final int jumpStaminaCost100;
  final int dashStaminaCost100;
}

// ─────────────────────────────────────────────────────────────────────────────
// Player ability tuning (cast, melee)
// ─────────────────────────────────────────────────────────────────────────────

class AbilityTuning {
  const AbilityTuning({
    this.castCooldownSeconds = 0.25,
    this.meleeCooldownSeconds = 0.30,
    this.meleeActiveSeconds = 0.10,
    this.meleeStaminaCost = 5.0,
    this.meleeDamage = 15.0,
    this.meleeHitboxSizeX = 32.0,
    this.meleeHitboxSizeY = 16.0,
    this.inputBufferSeconds = 0.15,
  });

  final double castCooldownSeconds;
  final double meleeCooldownSeconds;
  final double meleeActiveSeconds;

  final double meleeStaminaCost;
  final double meleeDamage;

  final double meleeHitboxSizeX;
  final double meleeHitboxSizeY;
  final double inputBufferSeconds;
}

class AbilityTuningDerived {
  const AbilityTuningDerived._({
    required this.tickHz,
    required this.base,
    required this.castCooldownTicks,
    required this.meleeCooldownTicks,
    required this.meleeActiveTicks,
    required this.inputBufferTicks,
  });

  factory AbilityTuningDerived.from(AbilityTuning base, {required int tickHz}) {
    if (tickHz <= 0) {
      throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
    }

    return AbilityTuningDerived._(
      tickHz: tickHz,
      base: base,
      castCooldownTicks: ticksFromSecondsCeil(base.castCooldownSeconds, tickHz),
      meleeCooldownTicks: ticksFromSecondsCeil(base.meleeCooldownSeconds, tickHz),
      meleeActiveTicks: ticksFromSecondsCeil(base.meleeActiveSeconds, tickHz),
      inputBufferTicks: ticksFromSecondsCeil(base.inputBufferSeconds, tickHz),
    );
  }

  final int tickHz;
  final AbilityTuning base;

  final int castCooldownTicks;
  final int meleeCooldownTicks;
  final int meleeActiveTicks;
  final int inputBufferTicks;
}

// ─────────────────────────────────────────────────────────────────────────────
// Player combat tuning (invulnerability)
// ─────────────────────────────────────────────────────────────────────────────

class CombatTuning {
  const CombatTuning({this.invulnerabilitySeconds = 0.25});

  final double invulnerabilitySeconds;
}

class CombatTuningDerived {
  const CombatTuningDerived._({
    required this.tickHz,
    required this.base,
    required this.invulnerabilityTicks,
  });

  factory CombatTuningDerived.from(CombatTuning base, {required int tickHz}) {
    if (tickHz <= 0) {
      throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
    }

    return CombatTuningDerived._(
      tickHz: tickHz,
      base: base,
      invulnerabilityTicks: ticksFromSecondsCeil(
        base.invulnerabilitySeconds,
        tickHz,
      ),
    );
  }

  final int tickHz;
  final CombatTuning base;

  final int invulnerabilityTicks;
}

// ─────────────────────────────────────────────────────────────────────────────
// Player animation tuning (timing windows)
// ─────────────────────────────────────────────────────────────────────────────

class AnimTuning {
  const AnimTuning({
    this.hitAnimSeconds = 0.40,
    this.castAnimSeconds = 0.40,
    this.strikeAnimSeconds = 0.36,
    this.backStrikeAnimSeconds = 0.36,
    this.parryAnimSeconds = 0.36,
    this.rangedAnimSeconds = 0.40,
    this.dashAnimSeconds = 0.20,
    this.rollAnimSeconds = 0.50,
    this.deathAnimSeconds = 0.72,
    this.spawnAnimSeconds = 0.56,
  });

  static AnimTuning fromStripFrames({
    required Map<AnimKey, int> frameCounts,
    required Map<AnimKey, double> stepTimeSecondsByKey,
  }) {
    final castSeconds = anim_utils.secondsForKey(
      key: AnimKey.cast,
      frameCounts: frameCounts,
      stepTimeSecondsByKey: stepTimeSecondsByKey,
    );
    final strikeSeconds = anim_utils.secondsForKey(
      key: AnimKey.strike,
      frameCounts: frameCounts,
      stepTimeSecondsByKey: stepTimeSecondsByKey,
    );
    return AnimTuning(
      hitAnimSeconds: anim_utils.secondsForKey(
        key: AnimKey.hit,
        frameCounts: frameCounts,
        stepTimeSecondsByKey: stepTimeSecondsByKey,
      ),
      castAnimSeconds: castSeconds,
      strikeAnimSeconds: strikeSeconds,
      backStrikeAnimSeconds:
          (frameCounts.containsKey(AnimKey.backStrike) ||
                  stepTimeSecondsByKey.containsKey(AnimKey.backStrike))
              ? anim_utils.secondsForKey(
                  key: AnimKey.backStrike,
                  frameCounts: frameCounts,
                  stepTimeSecondsByKey: stepTimeSecondsByKey,
                )
              : strikeSeconds,
      parryAnimSeconds:
          (frameCounts.containsKey(AnimKey.parry) ||
                  stepTimeSecondsByKey.containsKey(AnimKey.parry))
              ? anim_utils.secondsForKey(
                  key: AnimKey.parry,
                  frameCounts: frameCounts,
                  stepTimeSecondsByKey: stepTimeSecondsByKey,
                )
              : strikeSeconds,
      rangedAnimSeconds:
          (frameCounts.containsKey(AnimKey.ranged) ||
                  stepTimeSecondsByKey.containsKey(AnimKey.ranged))
              ? anim_utils.secondsForKey(
                  key: AnimKey.ranged,
                  frameCounts: frameCounts,
                  stepTimeSecondsByKey: stepTimeSecondsByKey,
                )
              : castSeconds,
      dashAnimSeconds:
          (frameCounts.containsKey(AnimKey.dash) ||
                  stepTimeSecondsByKey.containsKey(AnimKey.dash))
              ? anim_utils.secondsForKey(
                  key: AnimKey.dash,
                  frameCounts: frameCounts,
                  stepTimeSecondsByKey: stepTimeSecondsByKey,
                )
              : 0.20,
      rollAnimSeconds:
          (frameCounts.containsKey(AnimKey.roll) ||
                  stepTimeSecondsByKey.containsKey(AnimKey.roll))
              ? anim_utils.secondsForKey(
                  key: AnimKey.roll,
                  frameCounts: frameCounts,
                  stepTimeSecondsByKey: stepTimeSecondsByKey,
                )
              : 0.50,
      deathAnimSeconds: anim_utils.secondsForKey(
        key: AnimKey.death,
        frameCounts: frameCounts,
        stepTimeSecondsByKey: stepTimeSecondsByKey,
      ),
      spawnAnimSeconds: anim_utils.secondsForKey(
        key: AnimKey.spawn,
        frameCounts: frameCounts,
        stepTimeSecondsByKey: stepTimeSecondsByKey,
      ),
    );
  }

  final double hitAnimSeconds;
  final double castAnimSeconds;
  final double strikeAnimSeconds;
  final double backStrikeAnimSeconds;
  final double parryAnimSeconds;
  final double rangedAnimSeconds;
  final double dashAnimSeconds;
  final double rollAnimSeconds;
  final double deathAnimSeconds;
  final double spawnAnimSeconds;
}

class AnimTuningDerived {
  const AnimTuningDerived._({
    required this.tickHz,
    required this.base,
    required this.hitAnimTicks,
    required this.castAnimTicks,
    required this.strikeAnimTicks,
    required this.backStrikeAnimTicks,
    required this.parryAnimTicks,
    required this.rangedAnimTicks,
    required this.dashAnimTicks,
    required this.rollAnimTicks,
    required this.deathAnimTicks,
    required this.spawnAnimTicks,
  });

  factory AnimTuningDerived.from(AnimTuning base, {required int tickHz}) {
    if (tickHz <= 0) {
      throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
    }

    return AnimTuningDerived._(
      tickHz: tickHz,
      base: base,
      hitAnimTicks: ticksFromSecondsCeil(base.hitAnimSeconds, tickHz),
      castAnimTicks: ticksFromSecondsCeil(base.castAnimSeconds, tickHz),
      strikeAnimTicks: ticksFromSecondsCeil(base.strikeAnimSeconds, tickHz),
      backStrikeAnimTicks: ticksFromSecondsCeil(base.backStrikeAnimSeconds, tickHz),
      parryAnimTicks: ticksFromSecondsCeil(base.parryAnimSeconds, tickHz),
      rangedAnimTicks: ticksFromSecondsCeil(base.rangedAnimSeconds, tickHz),
      dashAnimTicks: ticksFromSecondsCeil(base.dashAnimSeconds, tickHz),
      rollAnimTicks: ticksFromSecondsCeil(base.rollAnimSeconds, tickHz),
      deathAnimTicks: ticksFromSecondsCeil(base.deathAnimSeconds, tickHz),
      spawnAnimTicks: ticksFromSecondsCeil(base.spawnAnimSeconds, tickHz),
    );
  }

  final int tickHz;
  final AnimTuning base;

  final int hitAnimTicks;
  final int castAnimTicks;
  final int strikeAnimTicks;
  final int backStrikeAnimTicks;
  final int parryAnimTicks;
  final int rangedAnimTicks;
  final int dashAnimTicks;
  final int rollAnimTicks;
  final int deathAnimTicks;
  final int spawnAnimTicks;
}

// ─────────────────────────────────────────────────────────────────────────────
// Player tuning bundle + derived compiler (composition)
// ─────────────────────────────────────────────────────────────────────────────

class PlayerTuning {
  const PlayerTuning({
    this.movement = const MovementTuning(),
    this.resource = const ResourceTuning(),
    this.ability = const AbilityTuning(),
    this.anim = const AnimTuning(),
    this.combat = const CombatTuning(),
  });

  final MovementTuning movement;
  final ResourceTuning resource;
  final AbilityTuning ability;
  final AnimTuning anim;
  final CombatTuning combat;

  PlayerTuning copyWith({
    MovementTuning? movement,
    ResourceTuning? resource,
    AbilityTuning? ability,
    AnimTuning? anim,
    CombatTuning? combat,
  }) {
    return PlayerTuning(
      movement: movement ?? this.movement,
      resource: resource ?? this.resource,
      ability: ability ?? this.ability,
      anim: anim ?? this.anim,
      combat: combat ?? this.combat,
    );
  }
}

class PlayerTuningDerived {
  const PlayerTuningDerived({
    required this.movement,
    required this.ability,
    required this.anim,
    required this.combat,
    required this.resource,
  });

  final MovementTuningDerived movement;
  final AbilityTuningDerived ability;
  final AnimTuningDerived anim;
  final CombatTuningDerived combat;
  final ResourceTuningDerived resource;
}

class PlayerTuningCompiler {
  const PlayerTuningCompiler({required this.tickHz});

  final int tickHz;

  PlayerTuningDerived compile(PlayerTuning base) {
    return PlayerTuningDerived(
      movement: MovementTuningDerived.from(base.movement, tickHz: tickHz),
      ability: AbilityTuningDerived.from(base.ability, tickHz: tickHz),
      anim: AnimTuningDerived.from(base.anim, tickHz: tickHz),
      combat: CombatTuningDerived.from(base.combat, tickHz: tickHz),
      resource: ResourceTuningDerived.from(base.resource),
    );
  }
}


===== FILE: lib/core/projectiles/projectile_catalog.dart =====
import '../util/tick_math.dart';

import 'projectile_id.dart';

/// Static properties for a projectile type.
///
/// Defines speed, lifetime, and collision bounds. Damage is determined by
/// the spell that spawns the projectile, not the projectile itself.
class ProjectileArchetype {
  const ProjectileArchetype({
    required this.speedUnitsPerSecond,
    required this.lifetimeSeconds,
    required this.colliderSizeX,
    required this.colliderSizeY,
  });

  /// Travel speed in world units per second.
  final double speedUnitsPerSecond;

  /// How long before auto-despawn (seconds).
  final double lifetimeSeconds;

  /// Full width of the collision box (world units).
  final double colliderSizeX;

  /// Full height of the collision box (world units).
  final double colliderSizeY;
}

/// Lookup table for projectile archetypes by [ProjectileId].
///
/// All values are authoring-time constants. For tick-rate-dependent values,
/// use [ProjectileCatalogDerived].
class ProjectileCatalog {
  const ProjectileCatalog();

  /// Returns the archetype for the given projectile type.
  ProjectileArchetype get(ProjectileId id) {
    switch (id) {
      case ProjectileId.iceBolt:
        return const ProjectileArchetype(
          speedUnitsPerSecond: 1000.0,
          lifetimeSeconds: 1.0,
          colliderSizeX: 18.0,
          colliderSizeY: 8.0,
        );
      case ProjectileId.thunderBolt:
        return const ProjectileArchetype(
          speedUnitsPerSecond: 1000.0,
          lifetimeSeconds: 1.2,
          colliderSizeX: 16.0,
          colliderSizeY: 8.0,
        );
      case ProjectileId.fireBolt:
        return const ProjectileArchetype(
          speedUnitsPerSecond: 900.0,
          lifetimeSeconds: 1.3,
          colliderSizeX: 20.0,
          colliderSizeY: 10.0,
        );
      case ProjectileId.throwingAxe:
        return const ProjectileArchetype(
          speedUnitsPerSecond: 800.0,
          lifetimeSeconds: 1.6,
          colliderSizeX: 16.0,
          colliderSizeY: 10.0,
        );
      case ProjectileId.throwingKnife:
        return const ProjectileArchetype(
          speedUnitsPerSecond: 900.0,
          lifetimeSeconds: 1.2,
          colliderSizeX: 14.0,
          colliderSizeY: 6.0,
        );
    }
  }
}

/// Tick-rate-aware wrapper for [ProjectileCatalog].
///
/// Converts time-based values (seconds) to tick counts for use in systems.
class ProjectileCatalogDerived {
  const ProjectileCatalogDerived._({required this.tickHz, required this.base});

  factory ProjectileCatalogDerived.from(
    ProjectileCatalog base, {
    required int tickHz,
  }) {
    if (tickHz <= 0) {
      throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
    }
    return ProjectileCatalogDerived._(tickHz: tickHz, base: base);
  }

  final int tickHz;
  final ProjectileCatalog base;

  /// Converts [lifetimeSeconds] to ticks (rounded up).
  int lifetimeTicks(ProjectileId id) {
    return ticksFromSecondsCeil(base.get(id).lifetimeSeconds, tickHz);
  }
}


===== FILE: lib/core/projectiles/projectile_id.dart =====
/// Identifies a projectile type for catalog lookup and rendering.
///
/// Each ID maps to a [ProjectileArchetype] in [ProjectileCatalog] and
/// determines visual appearance in the renderer.
enum ProjectileId {
  /// Player's primary ranged strike. Fast, short-lived.
  iceBolt,

  /// Enemy ranged strike. Slower but longer range.
  thunderBolt,

  /// Player's fire spell projectile. Medium speed and lifetime.
  fireBolt,

  /// Physical throwing axe projectile (ballistic).
  throwingAxe,

  /// Physical throwing knife projectile (ballistic).
  throwingKnife,
}


===== FILE: lib/core/projectiles/projectile_item_catalog.dart =====
import '../abilities/ability_def.dart' show WeaponType;
import '../combat/damage_type.dart';
import '../combat/status/status.dart';
import '../projectiles/projectile_id.dart';
import '../weapons/weapon_proc.dart';
import 'projectile_item_def.dart';
import 'projectile_item_id.dart';

/// Lookup table for projectile slot items (spells + throwing weapons).
class ProjectileItemCatalog {
  const ProjectileItemCatalog();

  ProjectileItemDef get(ProjectileItemId id) {
    switch (id) {
      // Spells
      case ProjectileItemId.iceBolt:
        return const ProjectileItemDef(
          id: ProjectileItemId.iceBolt,
          weaponType: WeaponType.projectileSpell,
          projectileId: ProjectileId.iceBolt,
          ballistic: false,
          gravityScale: 1.0,
          damageType: DamageType.ice,
          procs: <WeaponProc>[
            WeaponProc(
              hook: ProcHook.onHit,
              statusProfileId: StatusProfileId.iceBolt,
              chanceBp: 10000,
            ),
          ],
        );
      case ProjectileItemId.fireBolt:
        return const ProjectileItemDef(
          id: ProjectileItemId.fireBolt,
          weaponType: WeaponType.projectileSpell,
          projectileId: ProjectileId.fireBolt,
          ballistic: false,
          gravityScale: 1.0,
          damageType: DamageType.fire,
          procs: <WeaponProc>[
            WeaponProc(
              hook: ProcHook.onHit,
              statusProfileId: StatusProfileId.fireBolt,
              chanceBp: 10000,
            ),
          ],
        );
      case ProjectileItemId.thunderBolt:
        return const ProjectileItemDef(
          id: ProjectileItemId.thunderBolt,
          weaponType: WeaponType.projectileSpell,
          projectileId: ProjectileId.thunderBolt,
          ballistic: false,
          gravityScale: 1.0,
          damageType: DamageType.thunder,
        );

      // Throwing weapons
      case ProjectileItemId.throwingKnife:
        return const ProjectileItemDef(
          id: ProjectileItemId.throwingKnife,
          weaponType: WeaponType.throwingWeapon,
          projectileId: ProjectileId.throwingKnife,
          originOffset: 6.0,
          ballistic: true,
          gravityScale: 0.9,
          damageType: DamageType.physical,
        );
      case ProjectileItemId.throwingAxe:
        return const ProjectileItemDef(
          id: ProjectileItemId.throwingAxe,
          weaponType: WeaponType.throwingWeapon,
          projectileId: ProjectileId.throwingAxe,
          originOffset: 8.0,
          ballistic: true,
          gravityScale: 1.0,
          damageType: DamageType.physical,
        );
    }
  }

  ProjectileItemDef? tryGet(ProjectileItemId id) {
    try {
      return get(id);
    } catch (_) {
      return null;
    }
  }
}


===== FILE: lib/core/projectiles/projectile_item_def.dart =====
import '../abilities/ability_def.dart' show WeaponType;
import '../combat/damage_type.dart';
import '../projectiles/projectile_id.dart';
import '../weapons/weapon_proc.dart';
import '../weapons/weapon_stats.dart';
import 'projectile_item_id.dart';

/// Unified data definition for projectile slot items (spells + throwing weapons).
class ProjectileItemDef {
  const ProjectileItemDef({
    required this.id,
    required this.weaponType,
    required this.projectileId,
    this.originOffset = 0.0,
    this.ballistic = false,
    this.gravityScale = 1.0,
    this.damageType = DamageType.physical,
    this.procs = const <WeaponProc>[],
    this.stats = const WeaponStats(),
  });

  final ProjectileItemId id;
  final WeaponType weaponType;

  final ProjectileId projectileId;
  final double originOffset;
  final bool ballistic;
  final double gravityScale;

  final DamageType damageType;
  final List<WeaponProc> procs;
  final WeaponStats stats;
}


===== FILE: lib/core/projectiles/projectile_item_id.dart =====
enum ProjectileItemId {
  iceBolt,
  fireBolt,
  thunderBolt,
  throwingKnife,
  throwingAxe,
}


===== FILE: lib/core/projectiles/projectile_render_catalog.dart =====
import '../contracts/render_anim_set_definition.dart';
import '../snapshots/enums.dart';
import 'projectile_id.dart';

// -----------------------------------------------------------------------------
// Ice Bolt render animation strip definitions (authoring-time)
// -----------------------------------------------------------------------------

const int _iceBoltFrameWidth = 48;
const int _iceBoltFrameHeight = 32;

const int _iceBoltStartFrames = 3;
const int _iceBoltRepeatFrames = 10;
const int _iceBoltHitFrames = 8;

const double _iceBoltStartStepSeconds = 0.05;
const double _iceBoltRepeatStepSeconds = 0.06;
const double _iceBoltHitStepSeconds = 0.05;

const Map<AnimKey, int> _iceBoltFrameCountsByKey = <AnimKey, int>{
  AnimKey.spawn: _iceBoltStartFrames,
  AnimKey.idle: _iceBoltRepeatFrames,
  AnimKey.hit: _iceBoltHitFrames,
};

const Map<AnimKey, double> _iceBoltStepTimeSecondsByKey = <AnimKey, double>{
  AnimKey.spawn: _iceBoltStartStepSeconds,
  AnimKey.idle: _iceBoltRepeatStepSeconds,
  AnimKey.hit: _iceBoltHitStepSeconds,
};

const Map<AnimKey, String> _iceBoltSourcesByKey = <AnimKey, String>{
  AnimKey.spawn: 'entities/spells/iceBolt/start.png',
  AnimKey.idle: 'entities/spells/iceBolt/repeatable.png',
  AnimKey.hit: 'entities/spells/iceBolt/hit.png',
};

const RenderAnimSetDefinition _iceBoltRenderAnim = RenderAnimSetDefinition(
  frameWidth: _iceBoltFrameWidth,
  frameHeight: _iceBoltFrameHeight,
  sourcesByKey: _iceBoltSourcesByKey,
  frameCountsByKey: _iceBoltFrameCountsByKey,
  stepTimeSecondsByKey: _iceBoltStepTimeSecondsByKey,
);

// -----------------------------------------------------------------------------
// Thunder Bolt render animation strip definitions (authoring-time)
// -----------------------------------------------------------------------------

const int _thunderBoltFrameWidth = 32;
const int _thunderBoltFrameHeight = 32;

const int _thunderBoltStartFrames = 5;
const int _thunderBoltRepeatFrames = 5;
const int _thunderBoltHitFrames = 6;

const double _thunderBoltStartStepSeconds = 0.05;
const double _thunderBoltRepeatStepSeconds = 0.06;
const double _thunderBoltHitStepSeconds = 0.05;

const Map<AnimKey, int> _thunderBoltFrameCountsByKey = <AnimKey, int>{
  AnimKey.spawn: _thunderBoltStartFrames,
  AnimKey.idle: _thunderBoltRepeatFrames,
  AnimKey.hit: _thunderBoltHitFrames,
};

const Map<AnimKey, double> _thunderBoltStepTimeSecondsByKey =
    <AnimKey, double>{
  AnimKey.spawn: _thunderBoltStartStepSeconds,
  AnimKey.idle: _thunderBoltRepeatStepSeconds,
  AnimKey.hit: _thunderBoltHitStepSeconds,
};

const Map<AnimKey, String> _thunderBoltSourcesByKey = <AnimKey, String>{
  AnimKey.spawn: 'entities/spells/thunderBolt/start.png',
  AnimKey.idle: 'entities/spells/thunderBolt/repeatable.png',
  AnimKey.hit: 'entities/spells/thunderBolt/hit.png',
};

const RenderAnimSetDefinition _thunderBoltRenderAnim = RenderAnimSetDefinition(
  frameWidth: _thunderBoltFrameWidth,
  frameHeight: _thunderBoltFrameHeight,
  sourcesByKey: _thunderBoltSourcesByKey,
  frameCountsByKey: _thunderBoltFrameCountsByKey,
  stepTimeSecondsByKey: _thunderBoltStepTimeSecondsByKey,
);

// -----------------------------------------------------------------------------
// Fire Bolt render animation strip definitions (authoring-time)
// -----------------------------------------------------------------------------

const int _fireBoltFrameWidth = 48;
const int _fireBoltFrameHeight = 48;

const int _fireBoltStartFrames = 4;
const int _fireBoltHitFrames = 6;

const double _fireBoltStartStepSeconds = 0.05;
const double _fireBoltIdleStepSeconds = 0.06;
const double _fireBoltHitStepSeconds = 0.05;

const Map<AnimKey, int> _fireBoltFrameCountsByKey = <AnimKey, int>{
  AnimKey.spawn: _fireBoltStartFrames,
  AnimKey.idle: _fireBoltStartFrames,
  AnimKey.hit: _fireBoltHitFrames,
};

const Map<AnimKey, int> _fireBoltFrameStartByKey = <AnimKey, int>{
  AnimKey.spawn: 0,
  AnimKey.idle: 0,
  AnimKey.hit: 5,
};

const Map<AnimKey, double> _fireBoltStepTimeSecondsByKey =
    <AnimKey, double>{
  AnimKey.spawn: _fireBoltStartStepSeconds,
  AnimKey.idle: _fireBoltIdleStepSeconds,
  AnimKey.hit: _fireBoltHitStepSeconds,
};

const Map<AnimKey, String> _fireBoltSourcesByKey = <AnimKey, String>{
  AnimKey.spawn: 'entities/spells/fireBolt/fireBolt_spriteSheet.png',
  AnimKey.idle: 'entities/spells/fireBolt/fireBolt_spriteSheet.png',
  AnimKey.hit: 'entities/spells/fireBolt/fireBolt_spriteSheet.png',
};

const RenderAnimSetDefinition _fireBoltRenderAnim = RenderAnimSetDefinition(
  frameWidth: _fireBoltFrameWidth,
  frameHeight: _fireBoltFrameHeight,
  sourcesByKey: _fireBoltSourcesByKey,
  frameStartByKey: _fireBoltFrameStartByKey,
  frameCountsByKey: _fireBoltFrameCountsByKey,
  stepTimeSecondsByKey: _fireBoltStepTimeSecondsByKey,
);

// -----------------------------------------------------------------------------
// Throwing Axe render animation strip definitions (authoring-time)
// -----------------------------------------------------------------------------

const int _throwingAxeFrameWidth = 32;
const int _throwingAxeFrameHeight = 32;

const int _throwingAxeFrames = 1;
const double _throwingAxeStepSeconds = 0.10;

const Map<AnimKey, int> _throwingAxeFrameCountsByKey = <AnimKey, int>{
  AnimKey.idle: _throwingAxeFrames,
};

const Map<AnimKey, double> _throwingAxeStepTimeSecondsByKey =
    <AnimKey, double>{
  AnimKey.idle: _throwingAxeStepSeconds,
};

const Map<AnimKey, String> _throwingAxeSourcesByKey = <AnimKey, String>{
  AnimKey.idle: 'weapons/throwingWeapons/throwingAxe.png',
};

const RenderAnimSetDefinition _throwingAxeRenderAnim = RenderAnimSetDefinition(
  frameWidth: _throwingAxeFrameWidth,
  frameHeight: _throwingAxeFrameHeight,
  sourcesByKey: _throwingAxeSourcesByKey,
  frameCountsByKey: _throwingAxeFrameCountsByKey,
  stepTimeSecondsByKey: _throwingAxeStepTimeSecondsByKey,
);

// -----------------------------------------------------------------------------
// Throwing Axe render animation strip definitions (authoring-time)
// -----------------------------------------------------------------------------

const int _throwingKnifeFrameWidth = 32;
const int _throwingKnifeFrameHeight = 32;

const int _throwingKnifeFrames = 1;
const double _throwingKnifeStepSeconds = 0.10;

const Map<AnimKey, int> _throwingKnifeFrameCountsByKey = <AnimKey, int>{
  AnimKey.idle: _throwingKnifeFrames,
};

const Map<AnimKey, double> _throwingKnifeStepTimeSecondsByKey =
    <AnimKey, double>{
  AnimKey.idle: _throwingKnifeStepSeconds,
};

const Map<AnimKey, String> _throwingKnifeSourcesByKey = <AnimKey, String>{
  AnimKey.idle: 'weapons/throwingWeapons/throwingKnife.png',
};

const RenderAnimSetDefinition _throwingKnifeRenderAnim = RenderAnimSetDefinition(
  frameWidth: _throwingKnifeFrameWidth,
  frameHeight: _throwingKnifeFrameHeight,
  sourcesByKey: _throwingKnifeSourcesByKey,
  frameCountsByKey: _throwingKnifeFrameCountsByKey,
  stepTimeSecondsByKey: _throwingKnifeStepTimeSecondsByKey,
);

/// Lookup table for projectile render animation definitions.
///
/// Core owns the animation timing and frame metadata. The renderer uses this
/// catalog to load assets and drive deterministic animation frames.
class ProjectileRenderCatalog {
  const ProjectileRenderCatalog();

  RenderAnimSetDefinition get(ProjectileId id) {
    switch (id) {
      case ProjectileId.iceBolt:
        return _iceBoltRenderAnim;
      case ProjectileId.thunderBolt:
        return _thunderBoltRenderAnim;
      case ProjectileId.fireBolt:
        return _fireBoltRenderAnim;
      case ProjectileId.throwingAxe:
        return _throwingAxeRenderAnim;
      case ProjectileId.throwingKnife:
        return _throwingKnifeRenderAnim;
    }
  }
}


===== FILE: lib/core/projectiles/spawn_projectile_item.dart =====
/// Projectile spawning utilities for projectile slot items.
library;

import 'dart:math';

import '../combat/damage_type.dart';
import '../combat/faction.dart';
import '../ecs/entity_id.dart';
import '../ecs/stores/body_store.dart';
import '../ecs/stores/collider_aabb_store.dart';
import '../ecs/stores/lifetime_store.dart';
import '../ecs/stores/projectile_item_origin_store.dart';
import '../ecs/stores/projectile_store.dart';
import '../ecs/world.dart';
import '../projectiles/projectile_catalog.dart';
import '../projectiles/projectile_id.dart';
import '../projectiles/projectile_item_id.dart';
import '../weapons/weapon_proc.dart';

const _dirEps2 = 1e-12;

({double x, double y}) _normalizeDirOrFallback(
  double x,
  double y, {
  required double fallbackX,
  required double fallbackY,
}) {
  final len2 = x * x + y * y;
  if (len2 <= _dirEps2) {
    final fbLen2 = fallbackX * fallbackX + fallbackY * fallbackY;
    if (fbLen2 <= _dirEps2) {
      return (x: 1.0, y: 0.0);
    }
    final invLen = 1.0 / sqrt(fbLen2);
    return (x: fallbackX * invLen, y: fallbackY * invLen);
  }

  final invLen = 1.0 / sqrt(len2);
  return (x: x * invLen, y: y * invLen);
}

EntityId spawnProjectileItemFromCaster(
  EcsWorld world, {
  required ProjectileCatalogDerived projectiles,
  required ProjectileItemId projectileItemId,
  required ProjectileId projectileId,
  required Faction faction,
  required EntityId owner,
  required double casterX,
  required double casterY,
  required double originOffset,
  required double dirX,
  required double dirY,
  required double fallbackDirX,
  required double fallbackDirY,
  required int damage100,
  required DamageType damageType,
  List<WeaponProc> procs = const <WeaponProc>[],
  required bool ballistic,
  required double gravityScale,
}) {
  final proj = projectiles.base.get(projectileId);
  final speedUnitsPerSecond = proj.speedUnitsPerSecond;

  final dir = _normalizeDirOrFallback(
    dirX,
    dirY,
    fallbackX: fallbackDirX,
    fallbackY: fallbackDirY,
  );

  final originX = casterX + dir.x * originOffset;
  final originY = casterY + dir.y * originOffset;

  final entity = world.createEntity();

  final initialVelX = ballistic ? dir.x * speedUnitsPerSecond : 0.0;
  final initialVelY = ballistic ? dir.y * speedUnitsPerSecond : 0.0;

  world.transform.add(
    entity,
    posX: originX,
    posY: originY,
    velX: initialVelX,
    velY: initialVelY,
  );

  world.projectile.add(
    entity,
    ProjectileDef(
      projectileId: projectileId,
      faction: faction,
      owner: owner,
      dirX: dir.x,
      dirY: dir.y,
      speedUnitsPerSecond: speedUnitsPerSecond,
      damage100: damage100,
      damageType: damageType,
      procs: procs,
      usePhysics: ballistic,
    ),
  );

  world.projectileItemOrigin.add(
    entity,
    ProjectileItemOriginDef(projectileItemId: projectileItemId),
  );

  world.lifetime.add(
    entity,
    LifetimeDef(ticksLeft: projectiles.lifetimeTicks(projectileId)),
  );

  world.colliderAabb.add(
    entity,
    ColliderAabbDef(
      halfX: proj.colliderSizeX * 0.5,
      halfY: proj.colliderSizeY * 0.5,
    ),
  );

  if (ballistic) {
    world.body.add(
      entity,
      BodyDef(
        isKinematic: false,
        useGravity: true,
        gravityScale: gravityScale,
        sideMask: BodyDef.sideLeft | BodyDef.sideRight,
      ),
    );
    world.collision.add(entity);
  }

  return entity;
}


===== FILE: lib/core/scoring/run_score_breakdown.dart =====
import '../enemies/enemy_id.dart';
import '../tuning/score_tuning.dart';

/// Categories of score contributions shown in the end-of-run breakdown.
enum RunScoreRowKind {
  /// Points earned from distance traveled.
  distance,

  /// Points earned from survival time.
  time,

  /// Points earned from collected items.
  collectibles,

  /// Points earned from killing enemies (one row per enemy type).
  enemyKill,
}

/// A single line item in the score breakdown UI.
///
/// Each row shows a category, a count (e.g., meters, seconds, kills),
/// and the points contributed by that category.
class RunScoreRow {
  const RunScoreRow({
    required this.kind,
    required this.count,
    required this.points,
    this.enemyId,
  });

  /// Row category (distance/time/collectibles/enemy kills).
  final RunScoreRowKind kind;

  /// Quantity displayed (meters, seconds, collectible count, or kill count).
  final int count;

  /// Total points contributed by this row.
  final int points;

  /// For [RunScoreRowKind.enemyKill] rows, identifies the enemy type.
  final EnemyId? enemyId;
}

/// Complete score breakdown for a finished run.
///
/// Contains itemized rows and the computed total. Used by the game-over UI
/// to display how the player earned their score.
class RunScoreBreakdown {
  const RunScoreBreakdown({required this.rows, required this.totalPoints});

  /// Itemized score contributions (distance, time, collectibles, enemy kills).
  final List<RunScoreRow> rows;

  /// Sum of all row points.
  final int totalPoints;
}

/// Computes the score breakdown for a completed run.
///
/// Converts raw game stats (ticks, distance units, kill counts) into
/// player-facing values (meters, seconds) and calculates points using
/// [ScoreTuning] multipliers.
RunScoreBreakdown buildRunScoreBreakdown({
  required int tick,
  required double distanceUnits,
  required int collectibles,
  required int collectibleScore,
  required List<int> enemyKillCounts,
  required ScoreTuning tuning,
  required int tickHz,
  int unitsPerMeter = kWorldUnitsPerMeter,
}) {
  // Convert internal units to player-facing values.
  final meters = unitsPerMeter <= 0
      ? 0
      : (distanceUnits / unitsPerMeter).floor();
  final timeSeconds = tickHz <= 0 ? 0 : tick ~/ tickHz;

  final rows = <RunScoreRow>[
    RunScoreRow(
      kind: RunScoreRowKind.distance,
      count: meters,
      points: meters * tuning.distanceScorePerMeter,
    ),
    RunScoreRow(
      kind: RunScoreRowKind.time,
      count: timeSeconds,
      points: timeSeconds * tuning.timeScorePerSecond,
    ),
    RunScoreRow(
      kind: RunScoreRowKind.collectibles,
      count: collectibles,
      points: collectibleScore,
    ),
  ];

  // Add a row for each enemy type with at least one kill.
  for (final enemyId in EnemyId.values) {
    final index = enemyId.index;
    final kills = index < enemyKillCounts.length ? enemyKillCounts[index] : 0;
    if (kills <= 0) continue;
    rows.add(
      RunScoreRow(
        kind: RunScoreRowKind.enemyKill,
        count: kills,
        points: kills * _enemyKillScore(tuning, enemyId),
        enemyId: enemyId,
      ),
    );
  }

  // Sum all rows for total.
  var totalPoints = 0;
  for (final row in rows) {
    totalPoints += row.points;
  }

  return RunScoreBreakdown(
    rows: List<RunScoreRow>.unmodifiable(rows),
    totalPoints: totalPoints,
  );
}

/// Returns the point value for killing one enemy of [enemyId] type.
int _enemyKillScore(ScoreTuning tuning, EnemyId enemyId) {
  switch (enemyId) {
    case EnemyId.grojib:
      return tuning.groundEnemyKillScore;
    case EnemyId.unocoDemon:
      return tuning.unocoDemonKillScore;
  }
}


===== FILE: lib/core/snapshot_builder.dart =====
/// Builds immutable render snapshots from ECS world state.
///
/// This module decouples snapshot construction from simulation logic,
/// providing a clean separation between the game's internal state (ECS)
/// and the data consumed by the rendering layer.
///
/// All methods are pure readers—no side effects on [EcsWorld].
///
/// ## Architecture
///
/// The render layer never reads ECS directly. Instead, [GameCore] calls
/// [SnapshotBuilder.build] once per tick to produce a [GameStateSnapshot],
/// which is an immutable, self-contained description of everything needed
/// to draw a single frame.
///
/// ## Key Types
///
/// - [SnapshotBuilder] — Stateful builder holding ECS and tuning references.
/// - [GameStateSnapshot] — Complete frame data (entities, HUD, geometry).
/// - [EntityRenderSnapshot] — Per-entity render info (position, animation, etc.).
/// - [PlayerHudSnapshot] — Player resource bars, cooldowns, affordability flags.
library;

import 'dart:math';

import 'ecs/entity_id.dart';
import 'ecs/world.dart';
import 'ecs/stores/combat/equipped_loadout_store.dart';
import 'ecs/stores/restoration_item_store.dart';
import 'levels/level_id.dart';
import 'projectiles/projectile_catalog.dart';
import 'enemies/enemy_catalog.dart';
import 'snapshots/enums.dart';
import 'snapshots/entity_render_snapshot.dart';
import 'snapshots/game_state_snapshot.dart';
import 'snapshots/player_hud_snapshot.dart';
import 'snapshots/static_ground_gap_snapshot.dart';
import 'snapshots/static_solid_snapshot.dart';
import 'players/player_tuning.dart';
import 'util/vec2.dart';
import 'abilities/ability_catalog.dart';
import 'abilities/ability_def.dart';
import 'util/fixed_math.dart';
import 'util/tick_math.dart';

// ─────────────────────────────────────────────────────────────────────────────
// SnapshotBuilder
// ─────────────────────────────────────────────────────────────────────────────

/// Constructs [GameStateSnapshot] instances from ECS world state.
///
/// Holds references to the ECS world and all tuning data needed to compute
/// derived values (e.g., cooldown progress, affordability flags).
///
/// Usage:
/// ```dart
/// final builder = SnapshotBuilder(world: ..., player: ..., ...);
/// final snapshot = builder.build(tick: 42, ...);
/// ```
class SnapshotBuilder {
  /// Creates a snapshot builder with the given dependencies.
  ///
  /// - [tickHz]: Fixed tick rate for converting seconds to ticks.
  /// - [world]: The ECS world containing all entity component data.
  /// - [player]: Entity ID of the player (used to query player-specific stores).
  /// - [movement]: Derived movement tuning (dash cooldown ticks, etc.).
  /// - [abilities]: Derived ability tuning (melee/cast cooldown ticks).
  /// - [resources]: Resource costs (jump/dash stamina, etc.).
  /// - [projectiles]: Projectile catalog for collider sizes.
  /// - [enemyCatalog]: Enemy catalog for render metadata (hit windows, art facing).
  SnapshotBuilder({
    required this.tickHz,
    required this.world,
    required this.player,
    required this.movement,
    required this.abilities,
    required this.resources,
    required this.projectiles,
    required this.enemyCatalog,
  });

  /// Tick rate (ticks per second) for converting seconds to ticks.
  final int tickHz;

  /// The ECS world containing all game entity data.
  final EcsWorld world;

  /// Entity ID of the player character.
  final EntityId player;

  /// Derived movement tuning (pre-computed tick-based values).
  final MovementTuningDerived movement;

  /// Derived ability tuning (cooldown durations in ticks).
  final AbilityTuningDerived abilities;

  /// Resource tuning (stamina/mana costs for actions).
  final ResourceTuningDerived resources;

  /// Projectile catalog for collider dimensions.
  final ProjectileCatalogDerived projectiles;

  /// Enemy catalog for render metadata (art facing direction).
  final EnemyCatalog enemyCatalog;

  // ───────────────────────────────────────────────────────────────────────────
  // Public API
  // ───────────────────────────────────────────────────────────────────────────

  /// Builds a complete [GameStateSnapshot] for the current tick.
  ///
  /// This method reads from multiple ECS component stores to assemble:
  /// - Player state (position, velocity, animation, facing direction)
  /// - HUD data (HP, mana, stamina, cooldowns, affordability)
  /// - All entity render snapshots (player, enemies, projectiles, pickups)
  /// - Static geometry (platforms, ground gaps)
  ///
  /// Parameters:
  /// - [tick]: Current simulation tick number.
  /// - [seed]: RNG seed for this run (stored for replay/debug).
  /// - [levelId]: Level identifier for this run (stored for replay/debug).
  /// - [themeId]: Optional render theme identifier (stored for debug/UI).
  /// - [distance]: Total distance traveled (world units).
  /// - [paused]: Whether the game is currently paused.
  /// - [gameOver]: Whether the run has ended.
  /// - [cameraCenterX], [cameraCenterY]: Camera focus point (world coords).
  /// - [collectibles]: Number of collectibles picked up this run.
  /// - [collectibleScore]: Total score from collectibles.
  /// - [staticSolids]: Pre-built list of platform snapshots.
  /// - [groundGaps]: Pre-built list of ground gap snapshots.
  GameStateSnapshot build({
    required int tick,
    required int seed,
    required LevelId levelId,
    required String? themeId,
    required double distance,
    required bool paused,
    required bool gameOver,
    required double cameraCenterX,
    required double cameraCenterY,
    required int collectibles,
    required int collectibleScore,
    required List<StaticSolidSnapshot> staticSolids,
    required List<StaticGroundGapSnapshot> groundGaps,
  }) {
    // ─── Query player component indices ───
    final mi = world.movement.indexOf(player);
    final onGround = world.collision.grounded[world.collision.indexOf(player)];
    final hi = world.health.indexOf(player);
    final mai = world.mana.indexOf(player);
    final si = world.stamina.indexOf(player);

    final li = world.equippedLoadout.indexOf(player);

    // ─── Read current resource values ───
    final stamina = world.stamina.stamina[si];
    final mana = world.mana.mana[mai];
    final loadout = world.equippedLoadout;
    final loadoutMask = loadout.mask[li];

    final projectileAbilityId = loadout.abilityProjectileId[li];
    final projectileAbility = AbilityCatalog.tryGet(projectileAbilityId);
    final projectileManaCost = projectileAbility?.manaCost ?? 0;
    final projectileStaminaCost = projectileAbility?.staminaCost ?? 0;
    final hasProjectileSlot = (loadoutMask & LoadoutSlotMask.projectile) != 0;

    final mobilityAbilityId = loadout.abilityMobilityId[li];
    final mobilityAbility = AbilityCatalog.tryGet(mobilityAbilityId);
    final dashStaminaCost =
        mobilityAbility?.staminaCost ?? resources.dashStaminaCost100;

    final jumpAbilityId = loadout.abilityJumpId[li];
    final jumpAbility = AbilityCatalog.tryGet(jumpAbilityId);
    final jumpStaminaCost =
        jumpAbility?.staminaCost ?? resources.jumpStaminaCost100;

    final meleeAbilityId = loadout.abilityPrimaryId[li];
    final meleeAbility = AbilityCatalog.tryGet(meleeAbilityId);
    final meleeStaminaCost =
        meleeAbility?.staminaCost ??
        toFixed100(abilities.base.meleeStaminaCost);

    final secondaryAbilityId = loadout.abilitySecondaryId[li];
    final secondaryAbility = AbilityCatalog.tryGet(secondaryAbilityId);
    final secondaryStaminaCost =
        secondaryAbility?.staminaCost ??
        toFixed100(abilities.base.meleeStaminaCost);

    final bonusAbilityId = loadout.abilityBonusId[li];
    final bonusAbility = AbilityCatalog.tryGet(bonusAbilityId);
    final bonusManaCost = bonusAbility?.manaCost ?? 0;
    final bonusStaminaCost = bonusAbility?.staminaCost ?? 0;

    final meleeInputMode = _inputModeFor(meleeAbility);
    final projectileInputMode = _inputModeFor(projectileAbility);


    final bonusInputMode = _inputModeFor(bonusAbility);
    final bonusUsesMeleeAim = bonusAbility?.hitDelivery is MeleeHitDelivery;
    // ─── Compute affordability flags ───
    // These tell the UI whether action buttons should appear enabled.
    final canAffordJump = stamina >= jumpStaminaCost;
    final canAffordDash = stamina >= dashStaminaCost;
    final canAffordMelee = stamina >= meleeStaminaCost;

    final hasSecondarySlot = (loadoutMask & LoadoutSlotMask.offHand) != 0;
    final canAffordSecondary = hasSecondarySlot && stamina >= secondaryStaminaCost;

    final canAffordProjectile =
        hasProjectileSlot &&
        stamina >= projectileStaminaCost &&
        mana >= projectileManaCost;

    final canAffordBonus =
        bonusAbility != null && stamina >= bonusStaminaCost && mana >= bonusManaCost;

    // ─── Read cooldown timers ───
    final cooldownTicksLeft = List<int>.filled(kMaxCooldownGroups, 0);
    final cooldownTicksTotal = List<int>.filled(kMaxCooldownGroups, 0);

    // Populate current ticks from store.
    for (var g = 0; g < kMaxCooldownGroups; g++) {
      cooldownTicksLeft[g] = world.cooldown.getTicksLeft(player, g);
    }

    // Populate totals for active ability slots.
    // Primary (Melee)
    cooldownTicksTotal[CooldownGroup.primary] = meleeAbility == null
        ? abilities.meleeCooldownTicks
        : _scaleAbilityTicks(meleeAbility.cooldownTicks);

    // Secondary (Off-hand)
    cooldownTicksTotal[CooldownGroup.secondary] = secondaryAbility == null
        ? abilities.meleeCooldownTicks
        : _scaleAbilityTicks(secondaryAbility.cooldownTicks);

    // Projectile
    cooldownTicksTotal[CooldownGroup.projectile] = projectileAbility == null
        ? abilities.castCooldownTicks
        : _scaleAbilityTicks(projectileAbility.cooldownTicks);

    // Mobility (Dash)
    cooldownTicksTotal[CooldownGroup.mobility] = mobilityAbility == null
        ? movement.dashCooldownTicks
        : _scaleAbilityTicks(mobilityAbility.cooldownTicks);

    // Bonus (Utility)
    cooldownTicksTotal[CooldownGroup.bonus0] =
        bonusAbility == null ? 0 : _scaleAbilityTicks(bonusAbility.cooldownTicks);

    // Jump currently has no cooldown (buffer/coyote are handled by MovementSystem).
    cooldownTicksTotal[CooldownGroup.jump] = 0;

    // ─── Read player transform ───
    final ti = world.transform.indexOf(player);
    final playerPosX = world.transform.posX[ti];
    final playerPosY = world.transform.posY[ti];
    final playerVelX = world.transform.velX[ti];
    final playerVelY = world.transform.velY[ti];
    final playerFacing = world.movement.facing[mi];
    final animState = world.animState;
    final AnimKey anim;
    final int playerAnimFrame;
    if (animState.has(player)) {
      final ai = animState.indexOf(player);
      anim = animState.anim[ai];
      playerAnimFrame = animState.animFrame[ai];
    } else {
      anim = AnimKey.idle;
      playerAnimFrame = tick;
    }

    final playerPos = Vec2(playerPosX, playerPosY);
    final playerVel = Vec2(playerVelX, playerVelY);

    Vec2? playerSize;
    if (world.colliderAabb.has(player)) {
      final aabbi = world.colliderAabb.indexOf(player);
      playerSize = Vec2(
        world.colliderAabb.halfX[aabbi] * 2,
        world.colliderAabb.halfY[aabbi] * 2,
      );
    }

    // ─── Build entity list (player first) ───
    final entities = <EntityRenderSnapshot>[
      EntityRenderSnapshot(
        id: player,
        kind: EntityKind.player,
        pos: playerPos,
        vel: playerVel,
        size: playerSize,
        facing: playerFacing,
        anim: anim,
        grounded: onGround,
        animFrame: playerAnimFrame,
      ),
    ];

    // Append all other renderable entities.
    _addProjectiles(entities, tick: tick);
    _addHitboxes(entities, tick: tick);
    _addCollectibles(entities, tick: tick);
    _addRestorationItems(entities, tick: tick);
    _addEnemies(entities, tick: tick);

    // ─── Assemble final snapshot ───
    return GameStateSnapshot(
      tick: tick,
      seed: seed,
      levelId: levelId,
      themeId: themeId,
      distance: distance,
      paused: paused,
      gameOver: gameOver,
      cameraCenterX: cameraCenterX,
      cameraCenterY: cameraCenterY,
      hud: PlayerHudSnapshot(
        hp: fromFixed100(world.health.hp[hi]),
        hpMax: fromFixed100(world.health.hpMax[hi]),
        mana: fromFixed100(mana),
        manaMax: fromFixed100(world.mana.manaMax[mai]),
        stamina: fromFixed100(stamina),
        staminaMax: fromFixed100(world.stamina.staminaMax[si]),
        canAffordJump: canAffordJump,
        canAffordDash: canAffordDash,
        canAffordMelee: canAffordMelee,
        canAffordSecondary: canAffordSecondary,
        canAffordProjectile: canAffordProjectile,
        canAffordBonus: canAffordBonus,
        cooldownTicksLeft: cooldownTicksLeft,
        cooldownTicksTotal: cooldownTicksTotal,
        meleeInputMode: meleeInputMode,
        projectileInputMode: projectileInputMode,
        bonusInputMode: bonusInputMode,
        bonusUsesMeleeAim: bonusUsesMeleeAim,
        collectibles: collectibles,
        collectibleScore: collectibleScore,
      ),
      entities: entities,
      staticSolids: staticSolids,
      groundGaps: groundGaps,
    );
  }

  int _scaleAbilityTicks(int ticks) {
    if (ticks <= 0) return 0;
    if (tickHz == _abilityTickHz) return ticks;
    final seconds = ticks / _abilityTickHz;
    return ticksFromSecondsCeil(seconds, tickHz);
  }

  AbilityInputMode _inputModeFor(AbilityDef? ability) {
    if (ability == null) return AbilityInputMode.tap;
    final targeting = ability.targetingModel;
    return targeting == TargetingModel.none
        ? AbilityInputMode.tap
        : AbilityInputMode.holdAimRelease;
  }

  static const int _abilityTickHz = 60;

  // ───────────────────────────────────────────────────────────────────────────
  // Private Entity Collectors
  // ───────────────────────────────────────────────────────────────────────────

  /// Appends projectile entity snapshots to [entities].
  ///
  /// Iterates the projectile component store and creates render snapshots
  /// with position, velocity, facing direction, and rotation angle.
  void _addProjectiles(
    List<EntityRenderSnapshot> entities, {
    required int tick,
  }) {
    final projectileStore = world.projectile;
    for (var pi = 0; pi < projectileStore.denseEntities.length; pi += 1) {
      final e = projectileStore.denseEntities[pi];
      if (!world.transform.has(e)) continue;
      final ti = world.transform.indexOf(e);

      // Look up projectile definition for collider size.
      final projectileId = projectileStore.projectileId[pi];
      final proj = projectiles.base.get(projectileId);
      final colliderSize = Vec2(proj.colliderSizeX, proj.colliderSizeY);

      // Compute facing and rotation from direction vector.
      final dirX = projectileStore.dirX[pi];
      final dirY = projectileStore.dirY[pi];
      final facing = dirX >= 0 ? Facing.right : Facing.left;
      final rotationRad = atan2(dirY, dirX);

      entities.add(
        EntityRenderSnapshot(
          id: e,
          kind: EntityKind.projectile,
          pos: Vec2(world.transform.posX[ti], world.transform.posY[ti]),
          vel: Vec2(world.transform.velX[ti], world.transform.velY[ti]),
          size: colliderSize,
          projectileId: projectileId,
          facing: facing,
          rotationRad: rotationRad,
          anim: AnimKey.idle,
          grounded: false,
          animFrame: tick,
        ),
      );
    }
  }

  /// Appends active hitbox (melee strike) snapshots to [entities].
  ///
  /// Hitboxes are short-lived trigger volumes spawned by melee strikes.
  /// They render as debug overlays or strike effects.
  void _addHitboxes(List<EntityRenderSnapshot> entities, {required int tick}) {
    final hitboxes = world.hitbox;
    for (var hi = 0; hi < hitboxes.denseEntities.length; hi += 1) {
      final e = hitboxes.denseEntities[hi];
      if (!world.transform.has(e)) continue;
      final ti = world.transform.indexOf(e);

      // Hitbox size is stored as half-extents; double for full size.
      final size = Vec2(hitboxes.halfX[hi] * 2, hitboxes.halfY[hi] * 2);
      final dirX = hitboxes.dirX[hi];
      final dirY = hitboxes.dirY[hi];
      final facing = dirX >= 0 ? Facing.right : Facing.left;
      final rotationRad = atan2(dirY, dirX);

      entities.add(
        EntityRenderSnapshot(
          id: e,
          kind: EntityKind.trigger,
          pos: Vec2(world.transform.posX[ti], world.transform.posY[ti]),
          size: size,
          facing: facing,
          rotationRad: rotationRad,
          anim: AnimKey.hit,
          grounded: false,
          animFrame: tick,
        ),
      );
    }
  }

  /// Appends collectible (score pickup) snapshots to [entities].
  ///
  /// Collectibles are small pickups that grant score when collected.
  void _addCollectibles(
    List<EntityRenderSnapshot> entities, {
    required int tick,
  }) {
    final collectiblesStore = world.collectible;
    for (var ci = 0; ci < collectiblesStore.denseEntities.length; ci += 1) {
      final e = collectiblesStore.denseEntities[ci];
      if (!world.transform.has(e)) continue;
      final ti = world.transform.indexOf(e);

      // Size comes from AABB collider if present.
      Vec2? size;
      if (world.colliderAabb.has(e)) {
        final aabbi = world.colliderAabb.indexOf(e);
        size = Vec2(
          world.colliderAabb.halfX[aabbi] * 2,
          world.colliderAabb.halfY[aabbi] * 2,
        );
      }

      entities.add(
        EntityRenderSnapshot(
          id: e,
          kind: EntityKind.pickup,
          pos: Vec2(world.transform.posX[ti], world.transform.posY[ti]),
          size: size,
          facing: Facing.right,
          pickupVariant: PickupVariant.collectible,
          rotationRad: pi * 0.25, // 45° tilt for visual interest
          anim: AnimKey.idle,
          grounded: false,
          animFrame: tick,
        ),
      );
    }
  }

  /// Appends restoration item (health/mana/stamina orb) snapshots to [entities].
  ///
  /// Restoration items restore a specific resource when picked up.
  /// The [pickupVariant] field tells the renderer which sprite to use.
  void _addRestorationItems(
    List<EntityRenderSnapshot> entities, {
    required int tick,
  }) {
    final restorationStore = world.restorationItem;
    for (var ri = 0; ri < restorationStore.denseEntities.length; ri += 1) {
      final e = restorationStore.denseEntities[ri];
      if (!world.transform.has(e)) continue;
      final ti = world.transform.indexOf(e);

      Vec2? size;
      if (world.colliderAabb.has(e)) {
        final aabbi = world.colliderAabb.indexOf(e);
        size = Vec2(
          world.colliderAabb.halfX[aabbi] * 2,
          world.colliderAabb.halfY[aabbi] * 2,
        );
      }

      // Map restoration stat enum to pickup variant for rendering.
      final stat = restorationStore.stat[ri];
      int variant;
      switch (stat) {
        case RestorationStat.health:
          variant = PickupVariant.restorationHealth;
        case RestorationStat.mana:
          variant = PickupVariant.restorationMana;
        case RestorationStat.stamina:
          variant = PickupVariant.restorationStamina;
      }

      entities.add(
        EntityRenderSnapshot(
          id: e,
          kind: EntityKind.pickup,
          pos: Vec2(world.transform.posX[ti], world.transform.posY[ti]),
          size: size,
          facing: Facing.right,
          pickupVariant: variant,
          rotationRad: pi * 0.25,
          anim: AnimKey.idle,
          grounded: false,
          animFrame: tick,
        ),
      );
    }
  }

  /// Appends enemy entity snapshots to [entities].
  ///
  /// Enemies have position, velocity, facing direction, and grounded state.
  /// Animation is read from [AnimStateStore], pre-computed by [AnimSystem].
  void _addEnemies(List<EntityRenderSnapshot> entities, {required int tick}) {
    final enemies = world.enemy;
    final animStore = world.animState;

    for (var ei = 0; ei < enemies.denseEntities.length; ei += 1) {
      final e = enemies.denseEntities[ei];
      if (!world.transform.has(e)) continue;
      final ti = world.transform.indexOf(e);
      final enemyId = enemies.enemyId[ei];
      final enemyArchetype = enemyCatalog.get(enemyId);

      Vec2? size;
      if (world.colliderAabb.has(e)) {
        final aabbi = world.colliderAabb.indexOf(e);
        size = Vec2(
          world.colliderAabb.halfX[aabbi] * 2,
          world.colliderAabb.halfY[aabbi] * 2,
        );
      }

      final grounded = world.collision.has(e)
          ? world.collision.grounded[world.collision.indexOf(e)]
          : false;

      // Read pre-computed animation from AnimStateStore.
      final AnimKey anim;
      final int animFrame;
      if (animStore.has(e)) {
        final ai = animStore.indexOf(e);
        anim = animStore.anim[ai];
        animFrame = animStore.animFrame[ai];
      } else {
        // Fallback if no anim component (shouldn't happen).
        anim = AnimKey.idle;
        animFrame = tick;
      }

      entities.add(
        EntityRenderSnapshot(
          id: e,
          kind: EntityKind.enemy,
          pos: Vec2(world.transform.posX[ti], world.transform.posY[ti]),
          vel: Vec2(world.transform.velX[ti], world.transform.velY[ti]),
          size: size,
          enemyId: enemyId,
          facing: enemies.facing[ei],
          artFacingDir: enemyArchetype.artFacingDir,
          anim: anim,
          grounded: grounded,
          animFrame: animFrame,
        ),
      );
    }
  }
}


===== FILE: lib/core/snapshots/entity_render_snapshot.dart =====
/// Renderer-facing entity data extracted from Core at the end of each tick.
///
/// This is a read-only, serializable view of entity state. It intentionally
/// hides internal ECS storage details and provides only what the renderer needs.
library;

import '../enemies/enemy_id.dart';
import '../util/vec2.dart';
import '../projectiles/projectile_id.dart';
import 'enums.dart';

/// Render-only snapshot of a single entity.
///
/// Created by [GameCore] after each simulation tick. Contains position,
/// animation state, and optional metadata for specialized rendering.
class EntityRenderSnapshot {
  const EntityRenderSnapshot({
    required this.id,
    required this.kind,
    required this.pos,
    required this.facing,
    required this.anim,
    required this.grounded,
    this.artFacingDir,
    this.vel,
    this.size,
    this.enemyId,
    this.projectileId,
    this.pickupVariant,
    this.z,
    this.rotationRad = 0.0,
    this.animFrame,
  });

  /// Stable entity identifier (protocol-stable).
  final int id;

  /// Broad entity classification for choosing visuals/behavior.
  final EntityKind kind;

  /// World position in virtual pixels.
  final Vec2 pos;

  /// Optional world velocity (useful for facing/animation).
  final Vec2? vel;

  /// Optional full extents in world units (virtual pixels).
  ///
  /// Render-only hint for placeholder shapes (e.g. projectile rectangles).
  final Vec2? size;

  /// Optional enemy archetype id (set when [kind] is [EntityKind.enemy]).
  final EnemyId? enemyId;

  /// Optional projectile archetype id (set when [kind] is [EntityKind.projectile]).
  final ProjectileId? projectileId;

  /// Optional pickup variant for render-only pickup styling.
  final int? pickupVariant;

  /// Optional sort key for render ordering.
  final double? z;

  /// Optional rotation (radians) for rendering orientation.
  final double rotationRad;

  /// Facing direction for choosing sprites/poses.
  final Facing facing;

  /// Direction the authored art faces when not mirrored.
  ///
  /// When null, render should assume `Facing.right`.
  final Facing? artFacingDir;

  /// Whether the entity is grounded at the end of the tick.
  ///
  /// This is authoritative collision state from Core (do not infer from anim).
  final bool grounded;

  /// Logical animation selection (renderer maps to assets).
  final AnimKey anim;

  /// Optional frame hint for deterministic animation in replays/networking.
  final int? animFrame;
}

/// Variant codes for pickup rendering.
///
/// Maps to visual styles (colors, icons) in the renderer.
abstract class PickupVariant {
  static const int collectible = 0;
  static const int restorationHealth = 1;
  static const int restorationMana = 2;
  static const int restorationStamina = 3;
}


===== FILE: lib/core/snapshots/enums.dart =====
/// Protocol-stable enums used by snapshots and the Core→Renderer contract.
///
/// **Stability**: These enums may become part of the network protocol for
/// replays or multiplayer. Avoid renaming or reordering values.
///
/// **Scope**: These are "logical" game concepts, not tied to specific
/// textures or asset names. The renderer maps them to visuals.
library;

/// Logical animation state for entity rendering.
///
/// The renderer maps these to sprite sheets or animation clips.
enum AnimKey {
  idle,
  stun,
  run,
  jump,
  fall,
  hit,
  cast,
  death,
  spawn,
  strike,
  dash,
  walk,
  backStrike,
  parry,
  ranged,
  roll,
  punch,
  shieldBash,
  shieldBlock,
  throwItem,
}

/// Broad entity classification for rendering and (future) networking.
///
/// Used to select visual style, collision layer, and render order.
enum EntityKind {
  player,
  enemy,
  projectile,
  obstacle,
  pickup,
  hazard,
  trigger,
}

/// Horizontal facing direction for sprites and directional abilities.
enum Facing {
  left,
  right,
}

/// Input interaction mode for an ability slot.
enum AbilityInputMode {
  /// Instant commit on press.
  tap,
  /// Hold to aim, commit on release.
  holdAimRelease,
}


===== FILE: lib/core/snapshots/game_state_snapshot.dart =====
/// Immutable snapshot of game state for rendering and UI.
///
/// Built by [GameCore] after each fixed simulation tick. This is the primary
/// contract between Core and the Flame/Flutter layer—treat as read-only.
library;

import '../levels/level_id.dart';
import 'entity_render_snapshot.dart';
import 'enums.dart';
import 'player_hud_snapshot.dart';
import 'static_ground_gap_snapshot.dart';
import 'static_solid_snapshot.dart';

/// Complete game state snapshot at a specific simulation tick.
///
/// Contains everything the renderer and UI need: camera position, HUD data,
/// entity list, and static geometry.
class GameStateSnapshot {
  const GameStateSnapshot({
    required this.tick,
    required this.seed,
    required this.levelId,
    required this.themeId,
    required this.distance,
    required this.paused,
    required this.gameOver,
    required this.cameraCenterX,
    required this.cameraCenterY,
    required this.hud,
    required this.entities,
    required this.staticSolids,
    required this.groundGaps,
  });

  /// Current simulation tick.
  final int tick;

  /// Seed used for deterministic generation/RNG.
  final int seed;

  /// Level identifier for this run (stable across sessions).
  final LevelId levelId;

  /// Optional render theme identifier for this run.
  ///
  /// This is Core-owned metadata (pure data) that the renderer can map to
  /// asset paths and visuals without importing any Core gameplay logic.
  final String? themeId;

  /// Distance progressed in the run.
  final double distance;

  /// Whether the simulation is currently paused.
  final bool paused;

  /// Whether the run has ended (simulation is frozen).
  final bool gameOver;

  /// Camera center used for rendering this snapshot.
  final double cameraCenterX;
  final double cameraCenterY;

  /// HUD-only player stats.
  final PlayerHudSnapshot hud;

  /// Render-only entity list for the current tick.
  final List<EntityRenderSnapshot> entities;

  /// Render-only static collision geometry (platforms/obstacles) for this run.
  final List<StaticSolidSnapshot> staticSolids;

  /// Render-only ground gaps (holes in the ground band).
  final List<StaticGroundGapSnapshot> groundGaps;

  /// Returns the player entity snapshot, or `null` if not found.
  ///
  /// Convenience getter to avoid duplicating player-lookup logic across
  /// rendering components.
  EntityRenderSnapshot? get playerEntity {
    for (final e in entities) {
      if (e.kind == EntityKind.player) return e;
    }
    return null;
  }
}


===== FILE: lib/core/snapshots/player_hud_snapshot.dart =====
/// HUD-only player data extracted from Core.
///
/// Separated from entity snapshots so the UI can render player stats
/// (HP bars, cooldowns, etc.) without scanning all entities.
import 'enums.dart';

class PlayerHudSnapshot {
  const PlayerHudSnapshot({
    required this.hp,
    required this.hpMax,
    required this.mana,
    required this.manaMax,
    required this.stamina,
    required this.staminaMax,
    required this.canAffordJump,
    required this.canAffordDash,
    required this.canAffordMelee,
    required this.canAffordSecondary,
    required this.canAffordProjectile,
    required this.canAffordBonus,
    required this.cooldownTicksLeft,
    required this.cooldownTicksTotal,
    required this.meleeInputMode,
    required this.projectileInputMode,
    required this.bonusInputMode,
    required this.bonusUsesMeleeAim,
    required this.collectibles,
    required this.collectibleScore,
  });

  /// Current health.
  final double hp;

  /// Maximum health.
  final double hpMax;

  /// Current mana (resource for spells).
  final double mana;

  /// Maximum mana.
  final double manaMax;

  /// Current stamina (resource for physical actions like jump/dash).
  final double stamina;

  /// Maximum stamina.
  final double staminaMax;

  /// Whether stamina is sufficient for jumping.
  final bool canAffordJump;

  /// Whether stamina is sufficient for dashing.
  final bool canAffordDash;

  /// Whether stamina is sufficient for melee.
  final bool canAffordMelee;

  /// Whether resources are sufficient for the equipped secondary/off-hand ability.
  final bool canAffordSecondary;

  /// Whether resources are sufficient for the equipped projectile ability.
  final bool canAffordProjectile;

  /// Whether resources are sufficient for the equipped bonus ability.
  final bool canAffordBonus;

  /// Remaining cooldown ticks for each CooldownGroup.
  final List<int> cooldownTicksLeft;

  /// Total cooldown ticks for each CooldownGroup.
  final List<int> cooldownTicksTotal;

  /// Input interaction mode for melee slot.
  final AbilityInputMode meleeInputMode;

  /// Input interaction mode for projectile slot.
  final AbilityInputMode projectileInputMode;


  /// Input interaction mode for bonus slot.
  final AbilityInputMode bonusInputMode;

  /// Which aim channel the bonus ability consumes when in hold-aim mode.
  ///
  /// - true  => uses melee aim direction
  /// - false => uses projectile aim direction
  final bool bonusUsesMeleeAim;

  /// Collected collectibles.
  final int collectibles;

  /// Score value earned from collectibles.
  final int collectibleScore;
}


===== FILE: lib/core/snapshots/static_ground_gap_snapshot.dart =====
/// Renderer-facing snapshot for a gap in the ground band.
///
/// This is a read-only view for rendering/debug overlays. Authoritative
/// collision still lives in Core using `StaticWorldGeometry`.
class StaticGroundGapSnapshot {
  const StaticGroundGapSnapshot({
    required this.minX,
    required this.maxX,
  });

  final double minX;
  final double maxX;
}


===== FILE: lib/core/snapshots/static_solid_snapshot.dart =====
/// Renderer-facing snapshot for one piece of static collision geometry.
///
/// This is a read-only view for rendering/debug overlays. Authoritative
/// collision still lives in Core using `StaticWorldGeometry`.
class StaticSolidSnapshot {
  const StaticSolidSnapshot({
    required this.minX,
    required this.minY,
    required this.maxX,
    required this.maxY,
    required this.sides,
    required this.oneWayTop,
  });

  final double minX;
  final double minY;
  final double maxX;
  final double maxY;

  /// Bitmask of enabled faces.
  final int sides;

  /// Whether the top face behaves as one-way (platform).
  final bool oneWayTop;
}



===== FILE: lib/core/spawn_service.dart =====
/// Entity spawning service for GameCore.
///
/// Centralizes all entity creation logic (enemies, collectibles, restoration
/// items) with deterministic placement algorithms. Determinism is critical
/// for replay consistency—given the same seed and chunk index, the same
/// entities spawn at the same positions.
///
/// ## Architecture
///
/// [SpawnService] is owned by [GameCore] and called during:
/// - **Enemy spawning**: When the spawn horizon advances, enemies are placed
///   at fixed X offsets ahead of the camera.
/// - **Chunk generation**: When [TrackManager] streams new chunks,
///   collectibles and restoration items are procedurally scattered.
///
/// ## Determinism Strategy
///
/// All RNG operations use [seedFrom] and [nextUint32] from the deterministic
/// RNG module. Each spawn type uses a unique salt (e.g., `0xC011EC7` for
/// collectibles) XOR'd with the chunk index to ensure:
/// - Same seed + chunk → same spawn pattern
/// - Different chunks → independent sequences
/// - Different spawn types → no correlation
///
/// ## Placement Algorithm
///
/// For collectibles and restoration items:
/// 1. Compute valid X range (chunk bounds minus edge margins).
/// 2. Generate random X, snap to grid.
/// 3. Query the [SurfaceGraph] for the highest platform at that X.
/// 4. Place item above the surface with clearance.
/// 5. Reject if overlapping solids or existing entities.
/// 6. Retry up to `maxAttempts` times.
library;

import 'abilities/ability_def.dart';
import 'ecs/entity_id.dart';
import 'ecs/entity_factory.dart';
import 'ecs/hit/aabb_hit_utils.dart';
import 'ecs/stores/body_store.dart';
import 'ecs/stores/collider_aabb_store.dart';
import 'ecs/stores/collectible_store.dart';
import 'ecs/stores/restoration_item_store.dart';
import 'ecs/world.dart';
import 'enemies/enemy_catalog.dart';
import 'enemies/enemy_id.dart';
import 'navigation/types/nav_tolerances.dart';
import 'navigation/types/surface_graph.dart';
import 'navigation/utils/surface_spatial_index.dart';
import 'snapshots/enums.dart';
import 'tuning/collectible_tuning.dart';
import 'tuning/flying_enemy_tuning.dart';
import 'players/player_tuning.dart';
import 'tuning/restoration_item_tuning.dart';
import 'tuning/track_tuning.dart';
import 'util/deterministic_rng.dart';

// ─────────────────────────────────────────────────────────────────────────────
// RNG Salt Constants
// ─────────────────────────────────────────────────────────────────────────────

/// RNG salt for collectible spawn positions ("COLLECT" in hex-speak).
const int _collectibleSalt = 0xC011EC7;

/// RNG salt for restoration item spawn phase offset ("ALTESAT" - alternate stat).
const int _restorationPhaseSalt = 0xA17E5A7;

/// RNG salt for restoration item spawn positions ("ASTALL" - a stall/restore).
const int _restorationSpawnSalt = 0xA57A11;

// ─────────────────────────────────────────────────────────────────────────────
// SpawnService
// ─────────────────────────────────────────────────────────────────────────────

/// Service for spawning game entities with deterministic, seeded placement.
///
/// Handles creation of:
/// - **Flying enemies**: Hover above ground, cast projectiles.
/// - **Ground enemies**: Walk on platforms, chase player.
/// - **Collectibles**: Score pickups scattered across chunks.
/// - **Restoration items**: Health/mana/stamina orbs on periodic chunks.
///
/// Usage:
/// ```dart
/// final spawner = SpawnService(world: ..., seed: 42, ...);
/// spawner.setSurfaceGraph(graph: navGraph, spatialIndex: index);
/// spawner.spawnUnocoDemon(spawnX: 500, groundTopY: 0);
/// spawner.spawnCollectiblesForChunk(chunkIndex: 3, ...);
/// ```
class SpawnService {
  /// Creates a spawn service with the given dependencies.
  ///
  /// - [world]: ECS world for entity creation and component access.
  /// - [entityFactory]: Factory for creating complex entities (enemies).
  /// - [enemyCatalog]: Archetype definitions for enemy types.
  /// - [unocoDemonTuning]: Flying enemy hover offset and cooldowns.
  /// - [movement]: Movement tuning for ground enemy velocity limits.
  /// - [collectibleTuning]: Spawn density, spacing, and margins.
  /// - [restorationItemTuning]: Spawn frequency and item sizing.
  /// - [trackTuning]: Chunk dimensions and grid snap settings.
  /// - [seed]: Master RNG seed for deterministic spawning.
  SpawnService({
    required EcsWorld world,
    required EntityFactory entityFactory,
    required EnemyCatalog enemyCatalog,
    required UnocoDemonTuningDerived unocoDemonTuning,
    required MovementTuningDerived movement,
    required CollectibleTuning collectibleTuning,
    required RestorationItemTuning restorationItemTuning,
    required TrackTuning trackTuning,
    required int seed,
  }) : _world = world,
       _entityFactory = entityFactory,
       _enemyCatalog = enemyCatalog,
       _unocoDemonTuning = unocoDemonTuning,
       _movement = movement,
       _collectibleTuning = collectibleTuning,
       _restorationItemTuning = restorationItemTuning,
       _trackTuning = trackTuning,
       _seed = seed;

  // ─── Dependencies ───
  final EcsWorld _world;
  final EntityFactory _entityFactory;
  final EnemyCatalog _enemyCatalog;
  final UnocoDemonTuningDerived _unocoDemonTuning;
  final MovementTuningDerived _movement;
  final CollectibleTuning _collectibleTuning;
  final RestorationItemTuning _restorationItemTuning;
  final TrackTuning _trackTuning;
  final int _seed;

  // ─── Scratch buffers (reused to avoid allocation) ───

  /// X positions of collectibles spawned in the current chunk (for spacing).
  final List<double> _collectibleSpawnXs = <double>[];

  /// Surface indices returned by spatial queries.
  final List<int> _surfaceQueryCandidates = <int>[];

  // ─── Surface graph state (updated by TrackManager) ───
  SurfaceGraph? _surfaceGraph;
  SurfaceSpatialIndex? _surfaceSpatialIndex;
  double _surfaceMinY = 0.0;
  double _surfaceMaxY = 0.0;

  // ───────────────────────────────────────────────────────────────────────────
  // Surface Graph Management
  // ───────────────────────────────────────────────────────────────────────────

  /// Updates the navigation surface graph for item placement queries.
  ///
  /// Called by [TrackManager] whenever the track geometry changes.
  /// The surface graph provides platform positions for placing items
  /// "on top of" surfaces rather than floating in mid-air.
  ///
  /// Also caches the Y-axis bounds for efficient spatial queries.
  void setSurfaceGraph({
    required SurfaceGraph? graph,
    required SurfaceSpatialIndex? spatialIndex,
  }) {
    _surfaceGraph = graph;
    _surfaceSpatialIndex = spatialIndex;
    _surfaceMinY = 0.0;
    _surfaceMaxY = 0.0;

    // Pre-compute Y bounds to avoid repeated iteration during queries.
    if (graph != null && graph.surfaces.isNotEmpty) {
      var minY = graph.surfaces.first.yTop;
      var maxY = minY;
      for (var i = 1; i < graph.surfaces.length; i += 1) {
        final y = graph.surfaces[i].yTop;
        if (y < minY) minY = y;
        if (y > maxY) maxY = y;
      }
      _surfaceMinY = minY;
      _surfaceMaxY = maxY;
    }
  }

  // ───────────────────────────────────────────────────────────────────────────
  // Enemy Spawning
  // ───────────────────────────────────────────────────────────────────────────

  /// Spawns the Unoco Demon at [spawnX], hovering above [groundTopY].
  ///
  /// Flying enemies are placed at a fixed vertical offset above the ground
  /// (defined by [UnocoDemonTuning.unocoDemonHoverOffsetY]). They don't
  /// use gravity and will begin AI behavior on the next tick.
  ///
  /// The enemy's cast cooldown is pre-set to avoid immediate projectile
  /// spam on the spawn tick—this keeps early-game pacing predictable.
  ///
  /// Returns the [EntityId] of the newly created enemy.
  EntityId spawnUnocoDemon({
    required double spawnX,
    required double groundTopY,
  }) {
    final archetype = _enemyCatalog.get(EnemyId.unocoDemon);
    final unocoDemon = _entityFactory.createEnemy(
      enemyId: EnemyId.unocoDemon,
      posX: spawnX,
      posY: groundTopY - _unocoDemonTuning.base.unocoDemonHoverOffsetY,
      velX: 0.0,
      velY: 0.0,
      facing: Facing.left,
      body: archetype.body,
      collider: archetype.collider,
      health: archetype.health,
      mana: archetype.mana,
      stamina: archetype.stamina,
      tags: archetype.tags,
      resistance: archetype.resistance,
      statusImmunity: archetype.statusImmunity,
    );

    // Pre-set cooldown to prevent immediate casting on spawn tick.
    // This ensures consistent early-game difficulty across runs.
    _world.cooldown.setTicksLeft(
      unocoDemon,
      CooldownGroup.projectile,
      _unocoDemonTuning.unocoDemonCastCooldownTicks,
    );

    return unocoDemon;
  }

  /// Spawns a ground enemy at [spawnX], standing on [groundTopY].
  ///
  /// Ground enemies use gravity and collision. Their Y position is
  /// computed so their collider's bottom edge rests on the ground surface.
  ///
  /// The enemy inherits movement velocity limits from [MovementTuning]
  /// to ensure consistent chase behavior relative to player speed.
  ///
  /// Returns the [EntityId] of the newly created enemy.
  EntityId spawnGroundEnemy({
    required double spawnX,
    required double groundTopY,
  }) {
    final archetype = _enemyCatalog.get(EnemyId.grojib);

    // Position so collider bottom touches ground.
    return _entityFactory.createEnemy(
      enemyId: EnemyId.grojib,
      posX: spawnX,
      posY:
          groundTopY - (archetype.collider.offsetY + archetype.collider.halfY),
      velX: 0.0,
      velY: 0.0,
      facing: Facing.left,
      body: BodyDef(
        enabled: archetype.body.enabled,
        isKinematic: archetype.body.isKinematic,
        useGravity: archetype.body.useGravity,
        ignoreCeilings: archetype.body.ignoreCeilings,
        topOnlyGround: archetype.body.topOnlyGround,
        gravityScale: archetype.body.gravityScale,
        maxVelX: _movement.base.maxVelX,
        maxVelY: _movement.base.maxVelY,
        sideMask: archetype.body.sideMask,
      ),
      collider: archetype.collider,
      health: archetype.health,
      mana: archetype.mana,
      stamina: archetype.stamina,
      tags: archetype.tags,
      resistance: archetype.resistance,
      statusImmunity: archetype.statusImmunity,
    );
  }

  // ───────────────────────────────────────────────────────────────────────────
  // Collectible & Restoration Item Spawning
  // ───────────────────────────────────────────────────────────────────────────

  /// Spawns a single collectible at the given world position.
  ///
  /// Collectibles are stationary pickups that grant score when touched.
  /// They have an AABB collider for overlap detection but no physics body.
  ///
  /// Prefer [spawnCollectiblesForChunk] for procedural placement.
  EntityId spawnCollectibleAt(double x, double y) {
    final half = _collectibleTuning.collectibleSize * 0.5;
    final entity = _world.createEntity();
    _world.transform.add(entity, posX: x, posY: y, velX: 0.0, velY: 0.0);
    _world.colliderAabb.add(entity, ColliderAabbDef(halfX: half, halfY: half));
    _world.collectible.add(
      entity,
      CollectibleDef(value: _collectibleTuning.valuePerCollectible),
    );
    return entity;
  }

  /// Spawns a restoration item at the given world position.
  ///
  /// Restoration items restore the specified [stat] (health, mana, or
  /// stamina) when collected. Like collectibles, they're stationary with
  /// an AABB collider.
  ///
  /// Prefer [spawnRestorationItemForChunk] for procedural placement.
  EntityId spawnRestorationItemAt(double x, double y, RestorationStat stat) {
    final half = _restorationItemTuning.itemSize * 0.5;
    final entity = _world.createEntity();
    _world.transform.add(entity, posX: x, posY: y, velX: 0.0, velY: 0.0);
    _world.colliderAabb.add(entity, ColliderAabbDef(halfX: half, halfY: half));
    _world.restorationItem.add(entity, RestorationItemDef(stat: stat));
    return entity;
  }

  /// Spawns collectibles for a track chunk using deterministic placement.
  ///
  /// This method:
  /// 1. Skips if collectibles are disabled or chunk is too early.
  /// 2. Determines spawn count from RNG (between min and max per chunk).
  /// 3. For each collectible, picks a random X within chunk bounds.
  /// 4. Snaps X to grid and enforces minimum spacing between items.
  /// 5. Queries the highest surface at that X for vertical placement.
  /// 6. Rejects positions overlapping platforms or existing items.
  ///
  /// The RNG is seeded with `seed XOR chunkIndex XOR 0xC011EC7` to ensure
  /// deterministic but unique sequences per chunk.
  void spawnCollectiblesForChunk({
    required int chunkIndex,
    required double chunkStartX,
    required List<StaticSolid> solids,
  }) {
    final tuning = _collectibleTuning;

    // ─── Early-out checks ───
    if (!tuning.enabled) return;
    if (chunkIndex < tuning.spawnStartChunkIndex) return;
    if (tuning.maxPerChunk <= 0) return;

    final graph = _surfaceGraph;
    final spatialIndex = _surfaceSpatialIndex;
    if (graph == null || spatialIndex == null || graph.surfaces.isEmpty) {
      return;
    }

    // ─── Compute valid X range ───
    final minX = chunkStartX + tuning.chunkEdgeMarginX;
    final maxX =
        chunkStartX + _trackTuning.chunkWidth - tuning.chunkEdgeMarginX;
    if (maxX <= minX) return;

    // ─── Initialize RNG and determine target count ───
    var rngState = seedFrom(_seed, chunkIndex ^ _collectibleSalt);
    rngState = nextUint32(rngState);
    final countRange = tuning.maxPerChunk - tuning.minPerChunk + 1;
    final targetCount = tuning.minPerChunk + (rngState % countRange);
    if (targetCount <= 0) return;

    // ─── Spawn loop with rejection sampling ───
    _collectibleSpawnXs.clear();
    final halfSize = tuning.collectibleSize * 0.5;
    final maxAttempts = tuning.maxAttemptsPerChunk;

    for (
      var attempt = 0;
      attempt < maxAttempts && _collectibleSpawnXs.length < targetCount;
      attempt += 1
    ) {
      // Generate candidate X position.
      rngState = nextUint32(rngState);
      var x = rangeDouble(rngState, minX, maxX);
      x = _snapToGrid(x, _trackTuning.gridSnap);
      if (x < minX || x > maxX) continue;

      // Enforce minimum spacing from already-spawned collectibles.
      if (tuning.minSpacingX > 0.0) {
        var spaced = true;
        for (final prevX in _collectibleSpawnXs) {
          if ((prevX - x).abs() < tuning.minSpacingX) {
            spaced = false;
            break;
          }
        }
        if (!spaced) continue;
      }

      // Find surface Y and compute item center position.
      final surfaceY = _highestSurfaceYAtX(x);
      if (surfaceY == null) continue;
      final centerY = surfaceY - tuning.surfaceClearanceY - halfSize;

      // Reject if overlapping static geometry.
      if (_overlapsAnySolid(
        centerX: x,
        centerY: centerY,
        halfSize: halfSize,
        margin: tuning.noSpawnMargin,
        solids: solids,
      )) {
        continue;
      }

      // Success—spawn and record position.
      spawnCollectibleAt(x, centerY);
      _collectibleSpawnXs.add(x);
    }
  }

  /// Spawns a restoration item for a chunk if eligible.
  ///
  /// Restoration items spawn on a periodic schedule (e.g., every N chunks)
  /// with a phase offset derived from the seed to avoid predictable timing.
  ///
  /// The item type is determined by [lowestResourceStat], which should
  /// return the player's most depleted resource (health, mana, or stamina).
  ///
  /// Placement follows the same rejection-sampling algorithm as collectibles,
  /// with an additional check to avoid overlapping existing collectibles.
  void spawnRestorationItemForChunk({
    required int chunkIndex,
    required double chunkStartX,
    required List<StaticSolid> solids,
    required RestorationStat Function() lowestResourceStat,
  }) {
    final tuning = _restorationItemTuning;

    // ─── Early-out checks ───
    if (!tuning.enabled) return;
    if (chunkIndex < tuning.spawnStartChunkIndex) return;
    if (tuning.spawnEveryChunks <= 0) return;

    // ─── Periodic spawn check (with seeded phase offset) ───
    final phase =
        seedFrom(_seed, _restorationPhaseSalt) % tuning.spawnEveryChunks;
    if ((chunkIndex - phase) % tuning.spawnEveryChunks != 0) return;

    final graph = _surfaceGraph;
    final spatialIndex = _surfaceSpatialIndex;
    if (graph == null || spatialIndex == null || graph.surfaces.isEmpty) {
      return;
    }

    // ─── Compute valid X range ───
    final minX = chunkStartX + tuning.chunkEdgeMarginX;
    final maxX =
        chunkStartX + _trackTuning.chunkWidth - tuning.chunkEdgeMarginX;
    if (maxX <= minX) return;

    // ─── Determine which stat to restore ───
    final stat = lowestResourceStat();

    // ─── Spawn with rejection sampling ───
    var rngState = seedFrom(_seed, chunkIndex ^ _restorationSpawnSalt);
    final halfSize = tuning.itemSize * 0.5;

    for (var attempt = 0; attempt < tuning.maxAttemptsPerSpawn; attempt += 1) {
      rngState = nextUint32(rngState);
      var x = rangeDouble(rngState, minX, maxX);
      x = _snapToGrid(x, _trackTuning.gridSnap);
      if (x < minX || x > maxX) continue;

      final surfaceY = _highestSurfaceYAtX(x);
      if (surfaceY == null) continue;
      final centerY = surfaceY - tuning.surfaceClearanceY - halfSize;

      // Reject if overlapping static geometry.
      if (_overlapsAnySolid(
        centerX: x,
        centerY: centerY,
        halfSize: halfSize,
        margin: tuning.noSpawnMargin,
        solids: solids,
      )) {
        continue;
      }

      // Reject if overlapping existing collectibles.
      if (_overlapsAnyCollectible(
        centerX: x,
        centerY: centerY,
        halfSize: halfSize,
        margin: tuning.noSpawnMargin,
      )) {
        continue;
      }

      // Success—spawn and exit.
      spawnRestorationItemAt(x, centerY, stat);
      return;
    }
  }

  // ───────────────────────────────────────────────────────────────────────────
  // Private Helpers
  // ───────────────────────────────────────────────────────────────────────────

  /// Snaps [x] to the nearest multiple of [grid].
  ///
  /// Grid snapping ensures items align visually with the track's tile grid,
  /// avoiding sub-pixel positioning artifacts.
  double _snapToGrid(double x, double grid) {
    if (grid <= 0) return x;
    return (x / grid).roundToDouble() * grid;
  }

  /// Returns the Y coordinate of the highest surface at [x], or null if none.
  ///
  /// Uses the [SurfaceSpatialIndex] for efficient lookup, then filters
  /// candidates to find the topmost platform. Ties are broken by surface ID
  /// for determinism.
  double? _highestSurfaceYAtX(double x) {
    final graph = _surfaceGraph;
    final spatialIndex = _surfaceSpatialIndex;
    if (graph == null || spatialIndex == null || graph.surfaces.isEmpty) {
      return null;
    }

    // Query all surfaces that might contain X.
    final minY = _surfaceMinY - navSpatialEps;
    final maxY = _surfaceMaxY + navSpatialEps;
    _surfaceQueryCandidates.clear();
    spatialIndex.queryAabb(
      minX: x - navSpatialEps,
      minY: minY,
      maxX: x + navSpatialEps,
      maxY: maxY,
      outSurfaceIndices: _surfaceQueryCandidates,
    );

    // Find highest (smallest Y in screen coords) surface containing X.
    double? bestY;
    int? bestId;
    for (final i in _surfaceQueryCandidates) {
      final s = graph.surfaces[i];
      if (x < s.xMin - navGeomEps || x > s.xMax + navGeomEps) continue;

      // Prefer lower Y (higher on screen). Break ties by ID for determinism.
      if (bestY == null || s.yTop < bestY - navTieEps) {
        bestY = s.yTop;
        bestId = s.id;
      } else if ((s.yTop - bestY).abs() <= navTieEps && s.id < bestId!) {
        bestY = s.yTop;
        bestId = s.id;
      }
    }

    return bestY;
  }

  /// Checks if an AABB centered at ([centerX], [centerY]) overlaps any solid.
  ///
  /// The AABB is expanded by [margin] to prevent items from spawning too
  /// close to platform edges.
  bool _overlapsAnySolid({
    required double centerX,
    required double centerY,
    required double halfSize,
    required double margin,
    required List<StaticSolid> solids,
  }) {
    if (solids.isEmpty) return false;

    // Expand bounds by half-size and margin.
    final minX = centerX - halfSize - margin;
    final maxX = centerX + halfSize + margin;
    final minY = centerY - halfSize - margin;
    final maxY = centerY + halfSize + margin;

    for (final solid in solids) {
      final overlaps = aabbOverlapsMinMax(
        aMinX: minX,
        aMaxX: maxX,
        aMinY: minY,
        aMaxY: maxY,
        bMinX: solid.minX,
        bMaxX: solid.maxX,
        bMinY: solid.minY,
        bMaxY: solid.maxY,
      );
      if (overlaps) return true;
    }
    return false;
  }

  /// Checks if an AABB overlaps any existing collectible entity.
  ///
  /// Used by restoration item spawning to avoid stacking pickups.
  bool _overlapsAnyCollectible({
    required double centerX,
    required double centerY,
    required double halfSize,
    required double margin,
  }) {
    final collectibles = _world.collectible;
    if (collectibles.denseEntities.isEmpty) return false;

    final minX = centerX - halfSize - margin;
    final maxX = centerX + halfSize + margin;
    final minY = centerY - halfSize - margin;
    final maxY = centerY + halfSize + margin;

    for (var ci = 0; ci < collectibles.denseEntities.length; ci += 1) {
      final e = collectibles.denseEntities[ci];
      if (!(_world.transform.has(e) && _world.colliderAabb.has(e))) continue;

      // Read collectible's world-space AABB.
      final ti = _world.transform.indexOf(e);
      final ai = _world.colliderAabb.indexOf(e);
      final cx = _world.transform.posX[ti] + _world.colliderAabb.offsetX[ai];
      final cy = _world.transform.posY[ti] + _world.colliderAabb.offsetY[ai];

      final overlaps = aabbOverlapsMinMax(
        aMinX: minX,
        aMaxX: maxX,
        aMinY: minY,
        aMaxY: maxY,
        bMinX: cx - _world.colliderAabb.halfX[ai],
        bMaxX: cx + _world.colliderAabb.halfX[ai],
        bMinY: cy - _world.colliderAabb.halfY[ai],
        bMaxY: cy + _world.colliderAabb.halfY[ai],
      );
      if (overlaps) return true;
    }

    return false;
  }
}

// ─────────────────────────────────────────────────────────────────────────────
// Supporting Types
// ─────────────────────────────────────────────────────────────────────────────

/// Axis-aligned bounding box for static world geometry.
///
/// Used by [SpawnService] for overlap rejection during item placement.
/// Re-exported here to avoid circular imports with collision module.
typedef StaticSolid = ({double minX, double maxX, double minY, double maxY});


===== FILE: lib/core/track/chunk_builder.dart =====
/// Chunk geometry builder functions for track streaming.
///
/// Converts chunk-relative pattern definitions into world-space collision
/// geometry ([StaticSolid], [StaticGroundSegment], [StaticGroundGap]).
library;

import '../collision/static_world_geometry.dart';
import 'chunk_pattern.dart';

/// Result of building ground geometry from a chunk pattern.
class GroundBuildResult {
  const GroundBuildResult({
    required this.segments,
    required this.gaps,
  });

  /// Walkable ground spans (between gaps).
  final List<StaticGroundSegment> segments;

  /// Pit/gap spans.
  final List<StaticGroundGap> gaps;
}

/// Converts pattern platforms/obstacles into world-space [StaticSolid]s.
///
/// [pattern] - The chunk pattern containing platforms and obstacles.
/// [chunkStartX] - World X where this chunk begins.
/// [chunkIndex] - Sequential chunk number for tagging solids.
/// [groundTopY] - World Y of the ground surface.
/// [chunkWidth] - Width of a chunk (for bounds checking).
/// [gridSnap] - Grid snap value (for alignment checking).
List<StaticSolid> buildSolids(
  ChunkPattern pattern, {
  required double chunkStartX,
  required int chunkIndex,
  required double groundTopY,
  required double chunkWidth,
  required double gridSnap,
}) {
  // Preserve author ordering for determinism.
  final solids = <StaticSolid>[];
  var localSolidIndex = 0;

  // ── Platforms (one-way top) ──
  for (final p in pattern.platforms) {
    assert(
      _withinChunk(p.x, p.width, chunkWidth),
      'Platform out of chunk bounds: ${pattern.name}',
    );
    assert(
      _snapped(p.x, gridSnap) &&
          _snapped(p.width, gridSnap) &&
          _snapped(p.aboveGroundTop, gridSnap),
      'Platform not snapped to grid: ${pattern.name}',
    );
    final topY = groundTopY - p.aboveGroundTop;
    solids.add(
      StaticSolid(
        minX: chunkStartX + p.x,
        minY: topY,
        maxX: chunkStartX + p.x + p.width,
        maxY: topY + p.thickness,
        sides: StaticSolid.sideTop,
        oneWayTop: true,
        chunkIndex: chunkIndex,
        localSolidIndex: localSolidIndex,
      ),
    );
    localSolidIndex += 1;
  }

  // ── Obstacles (solid on all sides) ──
  for (final o in pattern.obstacles) {
    assert(
      _withinChunk(o.x, o.width, chunkWidth),
      'Obstacle out of chunk bounds: ${pattern.name}',
    );
    assert(
      _snapped(o.x, gridSnap) &&
          _snapped(o.width, gridSnap) &&
          _snapped(o.height, gridSnap),
      'Obstacle not snapped to grid: ${pattern.name}',
    );
    solids.add(
      StaticSolid(
        minX: chunkStartX + o.x,
        minY: groundTopY - o.height,
        maxX: chunkStartX + o.x + o.width,
        maxY: groundTopY,
        sides: StaticSolid.sideAll,
        oneWayTop: false,
        chunkIndex: chunkIndex,
        localSolidIndex: localSolidIndex,
      ),
    );
    localSolidIndex += 1;
  }

  return solids;
}

/// Builds ground segments by splitting at gap positions.
///
/// Gaps are sorted by X, then segments fill the remaining spans.
///
/// [pattern] - The chunk pattern containing ground gaps.
/// [chunkStartX] - World X where this chunk begins.
/// [chunkIndex] - Sequential chunk number for tagging segments.
/// [groundTopY] - World Y of the ground surface.
/// [chunkWidth] - Width of a chunk.
/// [gridSnap] - Grid snap value (for alignment checking).
GroundBuildResult buildGroundSegments(
  ChunkPattern pattern, {
  required double chunkStartX,
  required int chunkIndex,
  required double groundTopY,
  required double chunkWidth,
  required double gridSnap,
}) {
  // Sort gaps left-to-right for sequential processing.
  final orderedGaps = List<GapRel>.from(pattern.groundGaps);
  if (orderedGaps.isNotEmpty) {
    orderedGaps.sort((a, b) => a.x.compareTo(b.x));
  }

  final segments = <StaticGroundSegment>[];
  final gaps = <StaticGroundGap>[];
  var cursor = 0.0; // Tracks end of last segment/gap.
  var localSegmentIndex = 0;
  var lastGapEnd = -1.0; // For overlap assertion.

  for (final gap in orderedGaps) {
    assert(
      _withinChunk(gap.x, gap.width, chunkWidth),
      'Ground gap out of chunk bounds: ${pattern.name}',
    );
    assert(
      _snapped(gap.x, gridSnap) && _snapped(gap.width, gridSnap),
      'Ground gap not snapped to grid: ${pattern.name}',
    );
    assert(
      gap.x >= lastGapEnd - 1e-6,
      'Ground gap overlaps previous: ${pattern.name}',
    );

    final gapStart = gap.x;
    final gapEnd = gap.x + gap.width;

    // Emit segment from cursor to gap start (if non-empty).
    if (gapStart > cursor + 1e-6) {
      segments.add(
        StaticGroundSegment(
          minX: chunkStartX + cursor,
          maxX: chunkStartX + gapStart,
          topY: groundTopY,
          chunkIndex: chunkIndex,
          localSegmentIndex: localSegmentIndex,
        ),
      );
      localSegmentIndex += 1;
    }

    // Record gap for collision/rendering.
    gaps.add(
      StaticGroundGap(
        minX: chunkStartX + gapStart,
        maxX: chunkStartX + gapEnd,
      ),
    );

    // Advance cursor past gap.
    cursor = gapEnd > cursor ? gapEnd : cursor;
    lastGapEnd = gapEnd;
  }

  // Emit trailing segment from last gap to chunk end.
  if (cursor < chunkWidth - 1e-6) {
    segments.add(
      StaticGroundSegment(
        minX: chunkStartX + cursor,
        maxX: chunkStartX + chunkWidth,
        topY: groundTopY,
        chunkIndex: chunkIndex,
        localSegmentIndex: localSegmentIndex,
      ),
    );
  }

  return GroundBuildResult(segments: segments, gaps: gaps);
}

/// Checks if a span [x, x+width] fits within [0, chunkWidth].
bool _withinChunk(double x, double width, double chunkWidth) {
  return x >= 0.0 && (x + width) <= chunkWidth;
}

/// Checks if a value is snapped to the grid.
bool _snapped(double v, double gridSnap) {
  final snapped = (v / gridSnap).roundToDouble() * gridSnap;
  return (v - snapped).abs() < 1e-9;
}


===== FILE: lib/core/track/chunk_pattern.dart =====
/// Chunk pattern data structures for track streaming.
///
/// Defines the authored building blocks (platforms, obstacles, gaps, spawns)
/// used to compose procedural track chunks.
library;

import '../enemies/enemy_id.dart';

/// Authored chunk template defining platforms, obstacles, gaps, and spawns.
///
/// All coordinates are chunk-relative (x in `[0, chunkWidth)`).
/// Heights are expressed as "above ground top" so patterns are ground-agnostic.
class ChunkPattern {
  const ChunkPattern({
    required this.name,
    this.platforms = const <PlatformRel>[],
    this.obstacles = const <ObstacleRel>[],
    this.groundGaps = const <GapRel>[],
    this.spawnMarkers = const <SpawnMarker>[],
  });

  /// Human-readable identifier for debugging/logging.
  final String name;

  /// One-way platforms the player can jump through.
  final List<PlatformRel> platforms;

  /// Solid obstacles the player must jump over.
  final List<ObstacleRel> obstacles;

  /// Holes in the ground (pit hazards or visual breaks).
  final List<GapRel> groundGaps;

  /// Probabilistic enemy spawn points.
  final List<SpawnMarker> spawnMarkers;
}

/// Chunk-relative platform definition (one-way top surface).
class PlatformRel {
  const PlatformRel({
    required this.x,
    required this.width,
    required this.aboveGroundTop,
    required this.thickness,
  }) : assert(width > 0),
       assert(thickness > 0),
       assert(aboveGroundTop > 0);

  /// Left edge offset from chunk start.
  final double x;

  /// Horizontal extent.
  final double width;

  /// Vertical offset above ground (positive = higher).
  final double aboveGroundTop;

  /// Platform thickness (visual/collision depth).
  final double thickness;
}

/// Chunk-relative obstacle definition (solid on all sides).
class ObstacleRel {
  const ObstacleRel({
    required this.x,
    required this.width,
    required this.height,
  }) : assert(width > 0),
       assert(height > 0);

  /// Left edge offset from chunk start.
  final double x;

  /// Horizontal extent.
  final double width;

  /// Vertical extent (sits on ground, extends upward).
  final double height;
}

/// Chunk-relative ground gap (pit hazard).
class GapRel {
  const GapRel({
    required this.x,
    required this.width,
  }) : assert(width > 0);

  /// Left edge offset from chunk start.
  final double x;

  /// Horizontal extent of the gap.
  final double width;
}

/// Chunk-relative enemy spawn marker with probabilistic activation.
class SpawnMarker {
  const SpawnMarker({
    required this.enemyId,
    required this.x,
    required this.chancePercent,
    required this.salt,
  }) : assert(chancePercent >= 0),
       assert(chancePercent <= 100);

  /// Enemy type to spawn.
  final EnemyId enemyId;

  /// Spawn X offset from chunk start.
  final double x;

  /// Probability [0–100] that this marker activates.
  final int chancePercent;

  /// Extra entropy to differentiate markers with same position.
  final int salt;
}


===== FILE: lib/core/track/chunk_pattern_pool.dart =====
/// Groups pattern pools used for procedural track generation.
library;

import 'chunk_pattern.dart';

/// Default count of early chunks that draw from the "easy" pool.
const int defaultEarlyPatternChunks = 3;

/// Default count of early chunks that suppress enemy spawns.
const int defaultNoEnemyChunks = 3;

/// Pattern pools for early vs full difficulty.
class ChunkPatternPool {
  const ChunkPatternPool({
    required this.easyPatterns,
    required this.allPatterns,
  });

  /// Simpler patterns for early chunks.
  final List<ChunkPattern> easyPatterns;

  /// Full pattern pool used after early chunks.
  final List<ChunkPattern> allPatterns;
}


===== FILE: lib/core/track/chunk_patterns_library.dart =====
/// Pre-authored chunk pattern library for track streaming.
///
/// Notes:
/// - All coordinates are relative to the chunk start (x in [0, chunkWidth)).
/// - Y is expressed as "above ground top" (so 48 means 48 units above ground).
/// - Values are authored on a 16-unit grid for stability.
library;

import '../enemies/enemy_id.dart';
import 'chunk_pattern.dart';

/// Standard platform thickness (visual/collision depth).
const double kPlatformThickness = 16.0;

/// Shorthand for [kPlatformThickness] in pattern definitions.
const double _t = kPlatformThickness;

/// Simpler patterns for early-game chunks (default early window).
///
/// These give the player breathing room before harder patterns appear.
const List<ChunkPattern> easyPatterns = <ChunkPattern>[
  ChunkPattern(
    name: 'recovery-flat',
    platforms: <PlatformRel>[],
    obstacles: <ObstacleRel>[],
    groundGaps: <GapRel>[],
    spawnMarkers: <SpawnMarker>[],
  ),
  ChunkPattern(
    name: 'single-low-platform',
    platforms: <PlatformRel>[
      PlatformRel(x: 160, width: 160, aboveGroundTop: 48, thickness: _t),
    ],
    obstacles: <ObstacleRel>[],
    groundGaps: <GapRel>[GapRel(x: 64, width: 96)],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
        enemyId: EnemyId.unocoDemon,
        x: 240,
        chancePercent: 10,
        salt: 0x11,
      ),
    ],
  ),
  ChunkPattern(
    name: 'two-low-platforms',
    platforms: <PlatformRel>[
      PlatformRel(x: 64, width: 144, aboveGroundTop: 48, thickness: _t),
      PlatformRel(x: 272, width: 144, aboveGroundTop: 64, thickness: _t),
    ],
    obstacles: <ObstacleRel>[],
    groundGaps: <GapRel>[],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
        enemyId: EnemyId.grojib,
        x: 448,
        chancePercent: 10,
        salt: 0x12,
      ),
    ],
  ),
];

/// Full pattern pool for later chunks (index >= 3).
///
/// Includes [easyPatterns] plus more challenging layouts.
const List<ChunkPattern> allPatterns = <ChunkPattern>[
  // ── Recovery / breathers ──
  ...easyPatterns,

  // ── Platforming ──
  ChunkPattern(
    name: 'staggered-mid-platforms',
    platforms: <PlatformRel>[
      PlatformRel(x: 48, width: 160, aboveGroundTop: 64, thickness: _t),
      PlatformRel(x: 256, width: 160, aboveGroundTop: 96, thickness: _t),
    ],
    groundGaps: <GapRel>[GapRel(x: 240, width: 128)],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
        enemyId: EnemyId.unocoDemon,
        x: 352,
        chancePercent: 17,
        salt: 0x01,
      ),
    ],
  ),
  ChunkPattern(
    name: 'triple-runner-platforms',
    platforms: <PlatformRel>[
      PlatformRel(x: 32, width: 128, aboveGroundTop: 48, thickness: _t),
      PlatformRel(x: 192, width: 128, aboveGroundTop: 80, thickness: _t),
      PlatformRel(x: 352, width: 96, aboveGroundTop: 64, thickness: _t),
    ],
    groundGaps: <GapRel>[],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
        enemyId: EnemyId.unocoDemon,
        x: 288,
        chancePercent: 15,
        salt: 0x02,
      ),
    ],
  ),
  ChunkPattern(
    name: 'high-platform-over-obstacle',
    platforms: <PlatformRel>[
      PlatformRel(x: 224, width: 192, aboveGroundTop: 112, thickness: _t),
    ],
    obstacles: <ObstacleRel>[ObstacleRel(x: 128, width: 48, height: 64)],
    groundGaps: <GapRel>[GapRel(x: 176, width: 96)],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
        enemyId: EnemyId.grojib,
        x: 320,
        chancePercent: 22,
        salt: 0x03,
      ),
    ],
  ),

  // ── Obstacles (ground blocks that force a jump/dash) ──
  ChunkPattern(
    name: 'single-block',
    obstacles: <ObstacleRel>[ObstacleRel(x: 224, width: 48, height: 64)],
    groundGaps: <GapRel>[GapRel(x: 128, width: 96)],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
        enemyId: EnemyId.grojib,
        x: 320,
        chancePercent: 17,
        salt: 0x04,
      ),
    ],
  ),
  ChunkPattern(
    name: 'double-blocks',
    obstacles: <ObstacleRel>[
      ObstacleRel(x: 160, width: 32, height: 48),
      ObstacleRel(x: 288, width: 48, height: 64),
    ],
    groundGaps: <GapRel>[],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
        enemyId: EnemyId.unocoDemon,
        x: 96,
        chancePercent: 12,
        salt: 0x05,
      ),
      SpawnMarker(
        enemyId: EnemyId.grojib,
        x: 352,
        chancePercent: 15,
        salt: 0x06,
      ),
    ],
  ),
  ChunkPattern(
    name: 'low-staircase-platforms',
    platforms: <PlatformRel>[
      PlatformRel(x: 48, width: 128, aboveGroundTop: 48, thickness: _t),
      PlatformRel(x: 208, width: 128, aboveGroundTop: 64, thickness: _t),
      PlatformRel(x: 368, width: 128, aboveGroundTop: 80, thickness: _t),
    ],
    groundGaps: <GapRel>[GapRel(x: 304, width: 96)],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
        enemyId: EnemyId.grojib,
        x: 112,
        chancePercent: 15,
        salt: 0x07,
      ),
      SpawnMarker(
        enemyId: EnemyId.unocoDemon,
        x: 320,
        chancePercent: 15,
        salt: 0x08,
      ),
    ],
  ),
  ChunkPattern(
    name: 'wide-platform-gap',
    platforms: <PlatformRel>[
      PlatformRel(x: 32, width: 192, aboveGroundTop: 64, thickness: _t),
      PlatformRel(x: 288, width: 192, aboveGroundTop: 64, thickness: _t),
    ],
    groundGaps: <GapRel>[],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
        enemyId: EnemyId.unocoDemon,
        x: 192,
        chancePercent: 17,
        salt: 0x09,
      ),
      SpawnMarker(
        enemyId: EnemyId.grojib,
        x: 448,
        chancePercent: 15,
        salt: 0x0A,
      ),
    ],
  ),
  ChunkPattern(
    name: 'double-obstacle-lane',
    obstacles: <ObstacleRel>[
      ObstacleRel(x: 144, width: 48, height: 64),
      ObstacleRel(x: 336, width: 48, height: 64),
    ],
    groundGaps: <GapRel>[],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
        enemyId: EnemyId.grojib,
        x: 256,
        chancePercent: 17,
        salt: 0x0B,
      ),
      SpawnMarker(
        enemyId: EnemyId.unocoDemon,
        x: 80,
        chancePercent: 12,
        salt: 0x0C,
      ),
    ],
  ),
  ChunkPattern(
    name: 'mid-platform-overhang',
    platforms: <PlatformRel>[
      PlatformRel(x: 96, width: 160, aboveGroundTop: 96, thickness: _t),
      PlatformRel(x: 384, width: 128, aboveGroundTop: 64, thickness: _t),
    ],
    obstacles: <ObstacleRel>[ObstacleRel(x: 320, width: 64, height: 80)],
    groundGaps: <GapRel>[],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
        enemyId: EnemyId.unocoDemon,
        x: 176,
        chancePercent: 15,
        salt: 0x0D,
      ),
      SpawnMarker(
        enemyId: EnemyId.grojib,
        x: 448,
        chancePercent: 15,
        salt: 0x0E,
      ),
    ],
  ),
  ChunkPattern(
    name: 'tight-platforms',
    platforms: <PlatformRel>[
      PlatformRel(x: 32, width: 96, aboveGroundTop: 80, thickness: _t),
      PlatformRel(x: 160, width: 96, aboveGroundTop: 96, thickness: _t),
      PlatformRel(x: 288, width: 96, aboveGroundTop: 80, thickness: _t),
    ],
    obstacles: <ObstacleRel>[ObstacleRel(x: 448, width: 48, height: 64)],
    groundGaps: <GapRel>[GapRel(x: 112, width: 128)],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
        enemyId: EnemyId.unocoDemon,
        x: 240,
        chancePercent: 15,
        salt: 0x0F,
      ),
      SpawnMarker(
        enemyId: EnemyId.grojib,
        x: 480,
        chancePercent: 12,
        salt: 0x10,
      ),
    ],
  ),

  // ── Ground gaps ──
  ChunkPattern(
    name: 'ground-gap-small',
    groundGaps: <GapRel>[GapRel(x: 256, width: 64)],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
        enemyId: EnemyId.grojib,
        x: 160,
        chancePercent: 12,
        salt: 0x21,
      ),
      SpawnMarker(
        enemyId: EnemyId.unocoDemon,
        x: 416,
        chancePercent: 12,
        salt: 0x22,
      ),
    ],
  ),
  ChunkPattern(
    name: 'ground-gap-wide',
    groundGaps: <GapRel>[GapRel(x: 224, width: 128)],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
        enemyId: EnemyId.unocoDemon,
        x: 96,
        chancePercent: 12,
        salt: 0x23,
      ),
      SpawnMarker(
        enemyId: EnemyId.grojib,
        x: 480,
        chancePercent: 12,
        salt: 0x24,
      ),
    ],
  ),
];


===== FILE: lib/core/track/track_streamer.dart =====
/// Infinite-runner track streaming system.
///
/// Procedurally generates level geometry (platforms, obstacles, ground gaps)
/// and enemy spawn points by selecting from a pool of pre-authored chunk
/// patterns. Uses deterministic RNG so runs are reproducible given the same
/// seed.
library;

import '../collision/static_world_geometry.dart';
import '../enemies/enemy_id.dart';
import '../tuning/track_tuning.dart';
import '../util/deterministic_rng.dart' show mix32;
import 'chunk_builder.dart';
import 'chunk_pattern.dart';
import 'chunk_pattern_pool.dart';

/// Callback to spawn an enemy at a world X position.
typedef SpawnEnemy = void Function(EnemyId enemyId, double x);

/// Metadata for a newly spawned chunk, returned by [TrackStreamer.step].
class TrackSpawnedChunk {
  const TrackSpawnedChunk({
    required this.index,
    required this.startX,
  });

  /// Sequential chunk number (0 = first chunk).
  final int index;

  /// World X coordinate where this chunk begins.
  final double startX;
}

/// Result of a single [TrackStreamer.step] call.
class TrackStreamStepResult {
  const TrackStreamStepResult({
    required this.changed,
    required this.spawnedChunks,
  });

  /// True if geometry lists were rebuilt (chunk spawned or culled).
  final bool changed;

  /// Chunks created this step (empty on steady-state frames).
  final List<TrackSpawnedChunk> spawnedChunks;
}

/// Streams procedural track chunks based on camera position.
///
/// Call [step] each frame with the current camera bounds. The streamer:
/// 1. Spawns new chunks ahead of the camera (within [TrackTuning.spawnAheadMargin]).
/// 2. Culls old chunks behind the camera (beyond [TrackTuning.cullBehindMargin]).
/// 3. Rebuilds [dynamicSolids], [dynamicGroundSegments], [dynamicGroundGaps].
///
/// Pattern selection is deterministic given [seed] and chunk index.
class TrackStreamer {
  /// Creates a streamer seeded for deterministic generation.
  TrackStreamer({
    required this.seed,
    required this.tuning,
    required this.groundTopY,
    required this.patterns,
    required this.earlyPatternChunks,
    required this.noEnemyChunks,
  }) : _nextChunkIndex = 0,
       _nextChunkStartX = 0.0;

  /// RNG seed for pattern selection and spawn rolls.
  final int seed;

  /// Tuning parameters (chunk width, margins, grid snap).
  final TrackTuning tuning;

  /// World Y of the ground surface (platforms offset from this).
  final double groundTopY;

  /// Pattern pools for early vs full difficulty.
  final ChunkPatternPool patterns;

  /// Number of early chunks that use [patterns.easyPatterns].
  final int earlyPatternChunks;

  /// Number of early chunks that suppress enemy spawns.
  final int noEnemyChunks;

  int _nextChunkIndex;
  double _nextChunkStartX;

  final List<_ActiveChunk> _active = <_ActiveChunk>[];
  List<StaticSolid> _dynamicSolids = const <StaticSolid>[];
  List<StaticGroundSegment> _dynamicGroundSegments =
      const <StaticGroundSegment>[];
  List<StaticGroundGap> _dynamicGroundGaps = const <StaticGroundGap>[];

  /// Current streamed solids (excluding any caller-provided base solids).
  List<StaticSolid> get dynamicSolids => _dynamicSolids;

  /// Current streamed ground segments (excluding any base segments).
  List<StaticGroundSegment> get dynamicGroundSegments => _dynamicGroundSegments;

  /// Current streamed ground gaps (excluding any base gaps).
  List<StaticGroundGap> get dynamicGroundGaps => _dynamicGroundGaps;

  /// Advances chunk streaming based on the current camera bounds.
  ///
  /// Returns a step result (spawned chunks + whether geometry changed).
  TrackStreamStepResult step({
    required double cameraLeft,
    required double cameraRight,
    required SpawnEnemy spawnEnemy,
  }) {
    // Streaming disabled – return no-op.
    if (!tuning.enabled) {
      return const TrackStreamStepResult(
        changed: false,
        spawnedChunks: <TrackSpawnedChunk>[],
      );
    }

    var changed = false;
    final spawnedChunks = <TrackSpawnedChunk>[];

    // ── Spawn new chunks ahead of the camera ──
    final spawnLimitX = cameraRight + tuning.spawnAheadMargin;
    while (_nextChunkStartX <= spawnLimitX) {
      final chunkIndex = _nextChunkIndex;
      final startX = _nextChunkStartX;
      final endX = startX + tuning.chunkWidth;

      // Select pattern deterministically from seed + index.
      final pattern = _patternFor(seed, chunkIndex);

      // Build geometry from pattern.
      final solids = buildSolids(
        pattern,
        chunkStartX: startX,
        chunkIndex: chunkIndex,
        groundTopY: groundTopY,
        chunkWidth: tuning.chunkWidth,
        gridSnap: tuning.gridSnap,
      );
      final ground = buildGroundSegments(
        pattern,
        chunkStartX: startX,
        chunkIndex: chunkIndex,
        groundTopY: groundTopY,
        chunkWidth: tuning.chunkWidth,
        gridSnap: tuning.gridSnap,
      );

      // Track active chunk.
      _active.add(
        _ActiveChunk(
          index: chunkIndex,
          startX: startX,
          endX: endX,
          solids: solids,
          groundSegments: ground.segments,
          groundGaps: ground.gaps,
        ),
      );
      spawnedChunks.add(
        TrackSpawnedChunk(index: chunkIndex, startX: startX),
      );

      // Roll for enemy spawns.
      _spawnEnemiesForChunk(
        pattern,
        chunkIndex,
        chunkStartX: startX,
        spawnEnemy: spawnEnemy,
      );

      _nextChunkIndex += 1;
      _nextChunkStartX += tuning.chunkWidth;
      changed = true;
    }

    // ── Cull old chunks behind the camera ──
    final cullLimitX = cameraLeft - tuning.cullBehindMargin;
    while (_active.isNotEmpty && _active.first.endX < cullLimitX) {
      _active.removeAt(0); // O(n) but chunk count is small (~3-5).
      changed = true;
    }

    // ── Rebuild flattened geometry lists if anything changed ──
    if (changed) {
      final rebuilt = <StaticSolid>[];
      final rebuiltGroundSegments = <StaticGroundSegment>[];
      final rebuiltGroundGaps = <StaticGroundGap>[];
      for (final c in _active) {
        rebuilt.addAll(c.solids);
        rebuiltGroundSegments.addAll(c.groundSegments);
        rebuiltGroundGaps.addAll(c.groundGaps);
      }
      _dynamicSolids = List<StaticSolid>.unmodifiable(rebuilt);
      _dynamicGroundSegments =
          List<StaticGroundSegment>.unmodifiable(rebuiltGroundSegments);
      _dynamicGroundGaps =
          List<StaticGroundGap>.unmodifiable(rebuiltGroundGaps);
    }

    return TrackStreamStepResult(
      changed: changed,
      spawnedChunks: List<TrackSpawnedChunk>.unmodifiable(spawnedChunks),
    );
  }

  /// Rolls for enemy spawns defined in [pattern].
  ///
  /// Uses deterministic RNG keyed by seed, chunk index, and marker salt.
  void _spawnEnemiesForChunk(
    ChunkPattern pattern,
    int chunkIndex, {
    required double chunkStartX,
    required SpawnEnemy spawnEnemy,
  }) {
    // Early-game safety: keep first few chunks enemy-free.
    if (chunkIndex < noEnemyChunks) return;

    for (var i = 0; i < pattern.spawnMarkers.length; i += 1) {
      final m = pattern.spawnMarkers[i];

      // Deterministic roll: hash(seed, chunkIndex, markerIndex, salt).
      final roll = mix32(
        seed ^ (chunkIndex * 0x9e3779b9) ^ (i * 0x85ebca6b) ^ m.salt,
      );
      if ((roll % 100) >= m.chancePercent) continue;

      final x = chunkStartX + m.x;
      spawnEnemy(m.enemyId, x);
    }
  }

  /// Selects a chunk pattern deterministically from [seed] and [chunkIndex].
  ///
  /// Early chunks draw from [patterns.easyPatterns]; later chunks use full pool.
  ChunkPattern _patternFor(int seed, int chunkIndex) {
    final isEarly = chunkIndex < earlyPatternChunks;
    final pool = isEarly ? patterns.easyPatterns : patterns.allPatterns;
    // MurmurHash-style mix for uniform distribution.
    final h = mix32(seed ^ (chunkIndex * 0x9e3779b9) ^ 0x27d4eb2d);
    final idx = h % pool.length;
    return pool[idx];
  }
}

/// Tracks a spawned chunk's geometry while it's within camera culling bounds.
class _ActiveChunk {
  const _ActiveChunk({
    required this.index,
    required this.startX,
    required this.endX,
    required this.solids,
    required this.groundSegments,
    required this.groundGaps,
  });

  /// Sequential chunk number.
  final int index;

  /// World X where chunk begins.
  final double startX;

  /// World X where chunk ends (startX + chunkWidth).
  final double endX;

  /// Platforms and obstacles in this chunk.
  final List<StaticSolid> solids;

  /// Walkable ground spans.
  final List<StaticGroundSegment> groundSegments;

  /// Holes in the ground.
  final List<StaticGroundGap> groundGaps;
}


===== FILE: lib/core/track_manager.dart =====
/// Track streaming and geometry lifecycle management.
///
/// This module handles the procedural generation of track chunks as the
/// player progresses, maintaining both collision geometry and navigation
/// data for enemy AI.
///
/// ## Architecture
///
/// [TrackManager] is owned by [GameCore] and orchestrates:
/// - **Track streaming**: [TrackStreamer] spawns/culls chunks based on camera.
/// - **Collision geometry**: Merges base geometry with streamed chunks.
/// - **Surface graph**: Rebuilds navigation data when geometry changes.
/// - **Item spawning**: Delegates to [SpawnService] for new chunks.
///
/// ## Geometry Lifecycle
///
/// ```
/// Camera moves right
///        ↓
/// TrackStreamer.step() detects chunk spawn/cull needed
///        ↓
/// TrackManager merges base + dynamic geometry
///        ↓
/// StaticWorldGeometryIndex rebuilt (collision)
///        ↓
/// SurfaceGraphBuilder.build() (navigation)
///        ↓
/// SpawnService + enemy navigation systems receive new graphs
/// ```
///
/// ## Chunk Spawning Flow
///
/// When a new chunk enters the horizon:
/// 1. [TrackStreamer] generates platforms and enemy spawn points.
/// 2. [TrackManager] merges the new solids into collision geometry.
/// 3. Collectibles and restoration items are placed via [SpawnService].
/// 4. Surface graph is rebuilt so enemies can navigate new platforms.
library;

import 'collision/static_world_geometry_index.dart';
import 'ecs/stores/restoration_item_store.dart' show RestorationStat;
import 'ecs/systems/ground_enemy_locomotion_system.dart';
import 'ecs/systems/enemy_navigation_system.dart';
import 'enemies/enemy_id.dart';
import 'navigation/surface_graph_builder.dart';
import 'navigation/utils/jump_template.dart';
import 'snapshots/static_ground_gap_snapshot.dart';
import 'snapshots/static_solid_snapshot.dart';
import 'spawn_service.dart' hide StaticSolid;
import 'track/chunk_pattern_pool.dart';
import 'track/track_streamer.dart';
import 'tuning/collectible_tuning.dart';
import 'tuning/restoration_item_tuning.dart';
import 'tuning/track_tuning.dart';

// ─────────────────────────────────────────────────────────────────────────────
// Types
// ─────────────────────────────────────────────────────────────────────────────

/// Callback invoked when a chunk's enemy spawn point enters the horizon.
///
/// - [enemyId]: The type of enemy to spawn (ground or flying).
/// - [x]: The world X coordinate for the spawn.
typedef SpawnEnemyCallback = void Function(EnemyId enemyId, double x);

/// Result of a single [TrackManager.step] call.
///
/// Used by [GameCore] to decide whether to update render snapshots.
class TrackStepResult {
  const TrackStepResult({required this.geometryChanged});

  /// Whether static geometry was updated this step.
  ///
  /// When true, collision indices, surface graphs, and render snapshots
  /// have all been regenerated.
  final bool geometryChanged;
}

// ─────────────────────────────────────────────────────────────────────────────
// TrackManager
// ─────────────────────────────────────────────────────────────────────────────

/// Manages track streaming, collision geometry, and navigation graph updates.
///
/// Responsibilities:
/// - Steps [TrackStreamer] each tick to spawn/cull chunks.
/// - Merges base level geometry with dynamically streamed platforms.
/// - Rebuilds [StaticWorldGeometryIndex] for collision detection.
/// - Rebuilds [SurfaceGraph] for enemy pathfinding.
/// - Triggers collectible/item spawning for new chunks.
///
/// Usage:
/// ```dart
/// final manager = TrackManager(seed: 42, ...);
/// final result = manager.step(
///   cameraLeft: cam.left,
///   cameraRight: cam.right,
///   spawnEnemy: (id, x) => spawner.spawn(id, x),
///   lowestResourceStat: () => player.lowestStat,
/// );
/// if (result.geometryChanged) {
///   // Update render snapshots
/// }
/// ```
class TrackManager {
  /// Creates a track manager with the given dependencies.
  ///
  /// - [seed]: Master RNG seed for deterministic chunk generation.
  /// - [trackTuning]: Chunk dimensions, spawn horizons, platform density.
  /// - [collectibleTuning]: Collectible spawn parameters.
  /// - [restorationItemTuning]: Restoration item spawn parameters.
  /// - [baseGeometry]: Static level geometry (ground plane, initial platforms).
  /// - [surfaceGraphBuilder]: Builder for navigation surface graphs.
  /// - [jumpTemplate]: Precomputed jump reachability for pathfinding.
  /// - [enemyNavigationSystem]: Ground enemy navigation (receives graph updates).
  /// - [groundEnemyLocomotionSystem]: Ground locomotion (receives graph updates).
  /// - [spawnService]: Entity spawner (receives surface graph updates).
  /// - [groundTopY]: Y coordinate of the ground surface (for spawning).
  /// - [patternPool]: Chunk pattern pools for procedural generation.
  /// - [earlyPatternChunks]: Number of early chunks using easy patterns.
  /// - [noEnemyChunks]: Number of early chunks that suppress enemy spawns.
  TrackManager({
    required int seed,
    required TrackTuning trackTuning,
    required CollectibleTuning collectibleTuning,
    required RestorationItemTuning restorationItemTuning,
    required StaticWorldGeometry baseGeometry,
    required SurfaceGraphBuilder surfaceGraphBuilder,
    required JumpReachabilityTemplate jumpTemplate,
    required EnemyNavigationSystem enemyNavigationSystem,
    required GroundEnemyLocomotionSystem groundEnemyLocomotionSystem,
    required SpawnService spawnService,
    required double groundTopY,
    required ChunkPatternPool patternPool,
    int earlyPatternChunks = defaultEarlyPatternChunks,
    int noEnemyChunks = defaultNoEnemyChunks,
  }) : _trackTuning = trackTuning,
        _collectibleTuning = collectibleTuning,
        _restorationItemTuning = restorationItemTuning,
        _baseGeometry = baseGeometry,
        _surfaceGraphBuilder = surfaceGraphBuilder,
        _jumpTemplate = jumpTemplate,
        _enemyNavigationSystem = enemyNavigationSystem,
        _groundEnemyLocomotionSystem = groundEnemyLocomotionSystem,
        _spawnService = spawnService,
        _patternPool = patternPool,
        _earlyPatternChunks = earlyPatternChunks,
        _noEnemyChunks = noEnemyChunks {
    // Initialize geometry state from base level.
    _staticGeometry = baseGeometry;
    _staticIndex = StaticWorldGeometryIndex.from(baseGeometry);
    _staticSolidsSnapshot = _buildStaticSolidsSnapshot(baseGeometry);
    _staticGroundGapsSnapshot = _buildGroundGapsSnapshot(baseGeometry);

    // Create track streamer if procedural generation is enabled.
    if (_trackTuning.enabled) {
      _trackStreamer = TrackStreamer(
        seed: seed,
        tuning: _trackTuning,
        groundTopY: groundTopY,
        patterns: _patternPool,
        earlyPatternChunks: _earlyPatternChunks,
        noEnemyChunks: _noEnemyChunks,
      );
    }

    // Build initial surface graph for enemy navigation.
    _rebuildSurfaceGraph();
  }

  // ─── Dependencies ───
  final TrackTuning _trackTuning;
  final CollectibleTuning _collectibleTuning;
  final RestorationItemTuning _restorationItemTuning;
  final StaticWorldGeometry _baseGeometry;
  final SurfaceGraphBuilder _surfaceGraphBuilder;
  final JumpReachabilityTemplate _jumpTemplate;
  final EnemyNavigationSystem _enemyNavigationSystem;
  final GroundEnemyLocomotionSystem _groundEnemyLocomotionSystem;
  final SpawnService _spawnService;
  final ChunkPatternPool _patternPool;
  final int _earlyPatternChunks;
  final int _noEnemyChunks;

  // ─── Runtime State ───

  /// The track streamer (null if procedural generation is disabled).
  TrackStreamer? _trackStreamer;

  /// Version counter for surface graph rebuilds (for cache invalidation).
  int _surfaceGraphVersion = 0;

  /// Current merged geometry (base + streamed chunks).
  late StaticWorldGeometry _staticGeometry;

  /// Spatial index for broadphase collision queries.
  late StaticWorldGeometryIndex _staticIndex;

  /// Immutable snapshot of solids for the render layer.
  late List<StaticSolidSnapshot> _staticSolidsSnapshot;

  /// Immutable snapshot of ground gaps for the render layer.
  late List<StaticGroundGapSnapshot> _staticGroundGapsSnapshot;

  // ───────────────────────────────────────────────────────────────────────────
  // Public API
  // ───────────────────────────────────────────────────────────────────────────

  /// Current static world geometry (base + streamed chunks).
  ///
  /// Used by physics systems for collision resolution.
  StaticWorldGeometry get staticGeometry => _staticGeometry;

  /// Spatial index for efficient collision queries.
  ///
  /// Rebuilt whenever geometry changes.
  StaticWorldGeometryIndex get staticIndex => _staticIndex;

  /// Immutable snapshot of static solids for rendering.
  ///
  /// Contains platform AABBs, side masks, and one-way flags.
  List<StaticSolidSnapshot> get staticSolidsSnapshot => _staticSolidsSnapshot;

  /// Immutable snapshot of ground gaps for rendering.
  ///
  /// Used to draw pit hazard indicators.
  List<StaticGroundGapSnapshot> get staticGroundGapsSnapshot =>
      _staticGroundGapsSnapshot;

  /// Advances the track streamer and updates geometry if needed.
  ///
  /// This method should be called once per tick with the current camera
  /// bounds. It handles:
  /// 1. Chunk spawning/culling based on camera position.
  /// 2. Geometry merging and index rebuilding.
  /// 3. Surface graph updates for enemy AI.
  /// 4. Collectible and restoration item spawning.
  ///
  /// Parameters:
  /// - [cameraLeft], [cameraRight]: Camera X bounds for horizon calculation.
  /// - [spawnEnemy]: Callback invoked for each enemy spawn point in new chunks.
  /// - [lowestResourceStat]: Returns player's lowest resource for item type selection.
  ///
  /// Returns a [TrackStepResult] indicating whether geometry changed.
  TrackStepResult step({
    required double cameraLeft,
    required double cameraRight,
    required SpawnEnemyCallback spawnEnemy,
    required RestorationStat Function() lowestResourceStat,
  }) {
    final streamer = _trackStreamer;
    if (streamer == null) {
      // Procedural generation disabled—geometry never changes.
      return const TrackStepResult(geometryChanged: false);
    }

    // Step the streamer to spawn/cull chunks based on camera position.
    final result = streamer.step(
      cameraLeft: cameraLeft,
      cameraRight: cameraRight,
      spawnEnemy: spawnEnemy,
    );

    if (!result.changed) {
      // No chunks spawned or culled—nothing to update.
      return const TrackStepResult(geometryChanged: false);
    }

    // ─── Merge base geometry with streamed chunks ───
    final combinedSolids = <StaticSolid>[
      ..._baseGeometry.solids,
      ...streamer.dynamicSolids,
    ];
    final combinedSegments = <StaticGroundSegment>[
      ..._baseGeometry.groundSegments,
      ...streamer.dynamicGroundSegments,
    ];
    final combinedGaps = <StaticGroundGap>[
      ..._baseGeometry.groundGaps,
      ...streamer.dynamicGroundGaps,
    ];

    // Apply the new combined geometry (rebuilds index, snapshots, nav graph).
    _setStaticGeometry(
      StaticWorldGeometry(
        groundPlane: _baseGeometry.groundPlane,
        groundSegments: List<StaticGroundSegment>.unmodifiable(
          combinedSegments,
        ),
        solids: List<StaticSolid>.unmodifiable(combinedSolids),
        groundGaps: List<StaticGroundGap>.unmodifiable(combinedGaps),
      ),
    );

    // ─── Spawn items for newly created chunks ───
    if (result.spawnedChunks.isNotEmpty) {
      // Convert geometry to spawn-friendly format (avoids import cycles).
      final solidsForSpawn = _staticGeometry.solids
          .map((s) => (minX: s.minX, maxX: s.maxX, minY: s.minY, maxY: s.maxY))
          .toList();

      for (final chunk in result.spawnedChunks) {
        // Spawn collectibles if enabled.
        if (_collectibleTuning.enabled) {
          _spawnService.spawnCollectiblesForChunk(
            chunkIndex: chunk.index,
            chunkStartX: chunk.startX,
            solids: solidsForSpawn,
          );
        }

        // Spawn restoration items if enabled.
        if (_restorationItemTuning.enabled) {
          _spawnService.spawnRestorationItemForChunk(
            chunkIndex: chunk.index,
            chunkStartX: chunk.startX,
            solids: solidsForSpawn,
            lowestResourceStat: lowestResourceStat,
          );
        }
      }
    }

    return const TrackStepResult(geometryChanged: true);
  }

  // ───────────────────────────────────────────────────────────────────────────
  // Private Helpers
  // ───────────────────────────────────────────────────────────────────────────

  /// Applies new static geometry, rebuilding all derived data structures.
  ///
  /// This is the single point of geometry mutation. It ensures that the
  /// collision index, render snapshots, and navigation graph stay in sync.
  void _setStaticGeometry(StaticWorldGeometry geometry) {
    _staticGeometry = geometry;
    _staticIndex = StaticWorldGeometryIndex.from(geometry);
    _staticSolidsSnapshot = _buildStaticSolidsSnapshot(geometry);
    _staticGroundGapsSnapshot = _buildGroundGapsSnapshot(geometry);
    _rebuildSurfaceGraph();
  }

  /// Rebuilds the navigation surface graph and distributes it to consumers.
  ///
  /// The surface graph is used by:
  /// - [SpawnService]: To place items "on top of" platforms.
  /// - [EnemyNavigationSystem]: To compute jump/walk paths to the player.
  /// - [GroundEnemyLocomotionSystem]: To snap jump velocity on active edges.
  ///
  /// A version counter is incremented each rebuild so consumers can
  /// invalidate cached paths.
  void _rebuildSurfaceGraph() {
    _surfaceGraphVersion += 1;
    final result = _surfaceGraphBuilder.build(
      geometry: _staticGeometry,
      jumpTemplate: _jumpTemplate,
    );

    // Distribute new graph to spawn service.
    _spawnService.setSurfaceGraph(
      graph: result.graph,
      spatialIndex: result.spatialIndex,
    );

    // Distribute new graph to enemy AI system.
    _enemyNavigationSystem.setSurfaceGraph(
      graph: result.graph,
      spatialIndex: result.spatialIndex,
      graphVersion: _surfaceGraphVersion,
    );
    _groundEnemyLocomotionSystem.setSurfaceGraph(graph: result.graph);
  }

  /// Builds an immutable list of [StaticSolidSnapshot] from geometry.
  ///
  /// Converts internal collision representation to render-friendly format.
  static List<StaticSolidSnapshot> _buildStaticSolidsSnapshot(
    StaticWorldGeometry geometry,
  ) {
    return List<StaticSolidSnapshot>.unmodifiable(
      geometry.solids.map(
        (s) => StaticSolidSnapshot(
          minX: s.minX,
          minY: s.minY,
          maxX: s.maxX,
          maxY: s.maxY,
          sides: s.sides,
          oneWayTop: s.oneWayTop,
        ),
      ),
    );
  }

  /// Builds an immutable list of [StaticGroundGapSnapshot] from geometry.
  ///
  /// Returns an empty const list if no gaps exist (avoids allocation).
  static List<StaticGroundGapSnapshot> _buildGroundGapsSnapshot(
    StaticWorldGeometry geometry,
  ) {
    if (geometry.groundGaps.isEmpty) {
      return const <StaticGroundGapSnapshot>[];
    }
    return List<StaticGroundGapSnapshot>.unmodifiable(
      geometry.groundGaps.map(
        (g) => StaticGroundGapSnapshot(minX: g.minX, maxX: g.maxX),
      ),
    );
  }
}


===== FILE: lib/core/tuning/camera_tuning.dart =====
/// Camera auto-scroll and follow tuning.
library;

import 'dart:math';

import '../players/player_tuning.dart';

class CameraTuning {
  const CameraTuning({
    this.speedLagMulX = 0.0,
    this.accelX = 1200.0,
    this.followThresholdRatio = 0.5,
    this.catchupLerp = 8.0,
    this.targetCatchupLerp = 2.5,
  });

  /// Baseline auto-scroll lags behind `MovementTuning.maxSpeedX` by this multiplier.
  final double speedLagMulX;

  /// Acceleration used to ease camera speed toward its target speed.
  final double accelX;

  /// Threshold ratio (from left edge) after which the player can pull the camera forward.
  final double followThresholdRatio;

  /// Smoothing for camera center toward its target (per-second).
  final double catchupLerp;

  /// Smoothing for camera target toward player (per-second).
  final double targetCatchupLerp;
}

class CameraTuningDerived {
  const CameraTuningDerived({
    required this.targetSpeedX,
    required this.accelX,
    required this.followThresholdRatio,
    required this.catchupLerp,
    required this.targetCatchupLerp,
  });

  factory CameraTuningDerived.from(
    CameraTuning tuning, {
    required MovementTuningDerived movement,
  }) {
    final targetSpeedX = max(0.0, movement.base.maxSpeedX * tuning.speedLagMulX);
    return CameraTuningDerived(
      targetSpeedX: targetSpeedX,
      accelX: tuning.accelX,
      followThresholdRatio: tuning.followThresholdRatio,
      catchupLerp: tuning.catchupLerp,
      targetCatchupLerp: tuning.targetCatchupLerp,
    );
  }

  final double targetSpeedX;
  final double accelX;
  final double followThresholdRatio;
  final double catchupLerp;
  final double targetCatchupLerp;
}


===== FILE: lib/core/tuning/collectible_tuning.dart =====
/// Collectible spawning and value configuration.
class CollectibleTuning {
  const CollectibleTuning({
    this.enabled = true,
    this.minPerChunk = 1,
    this.maxPerChunk = 2,
    this.spawnStartChunkIndex = 2,
    this.collectibleSize = 16.0,
    this.surfaceClearanceY = 10.0,
    this.noSpawnMargin = 2.0,
    this.minSpacingX = 80.0,
    this.chunkEdgeMarginX = 32.0,
    this.maxAttemptsPerChunk = 40,
    this.despawnBehindCameraMargin = 900.0,
    this.valuePerCollectible = 50,
  }) : assert(maxPerChunk >= minPerChunk);

  /// Master toggle for collectible spawning.
  final bool enabled;

  /// Min collectibles spawned per chunk.
  final int minPerChunk;

  /// Max collectibles spawned per chunk.
  final int maxPerChunk;

  /// First chunk index where collectibles can spawn.
  final int spawnStartChunkIndex;

  /// Collision/render size (world units).
  final double collectibleSize;

  /// Vertical clearance above surface (world units).
  final double surfaceClearanceY;

  /// Margin from surface edges to avoid clipping (world units).
  final double noSpawnMargin;

  /// Minimum horizontal spacing between collectibles (world units).
  final double minSpacingX;

  /// Margin from chunk edges (world units).
  final double chunkEdgeMarginX;

  /// Max placement attempts before giving up.
  final int maxAttemptsPerChunk;

  /// Distance behind camera before despawn (world units).
  final double despawnBehindCameraMargin;

  /// Score value per collectible.
  final int valuePerCollectible;
}


===== FILE: lib/core/tuning/core_tuning.dart =====
/// Aggregate tuning configuration for the game simulation core.
///
/// This class bundles all tuning parameters into a single object, simplifying
/// the [GameCore] constructor API. All fields have sensible defaults, so you
/// only need to override what you want to customize.
///
/// ## Usage
///
/// ```dart
/// // Default configuration:
/// final core = GameCore(seed: 42);
///
/// // Custom configuration:
/// final core = GameCore(
///   seed: 42,
///   tuning: CoreTuning(
///     track: TrackTuning(enabled: false),
///   ),
/// );
/// ```
///
/// ## Testing
///
/// For unit tests, create a custom [CoreTuning] with specific overrides:
/// ```dart
/// final testTuning = CoreTuning(
///   track: TrackTuning(enabled: false),  // Disable procedural gen
///   physics: PhysicsTuning(gravityY: 0), // Zero gravity
/// );
/// final core = GameCore(seed: 123, tuning: testTuning);
/// ```
library;

import 'camera_tuning.dart';
import 'collectible_tuning.dart';
import 'flying_enemy_tuning.dart';
import 'ground_enemy_tuning.dart';
import 'navigation_tuning.dart';
import 'physics_tuning.dart';
import 'restoration_item_tuning.dart';
import 'score_tuning.dart';
import 'spatial_grid_tuning.dart';
import 'track_tuning.dart';

/// Aggregate container for all game simulation tuning parameters.
///
/// Provides a cleaner API than passing 15+ individual tuning objects to
/// [GameCore]. All fields default to their respective tuning class defaults.
class CoreTuning {
  /// Creates a core tuning configuration with optional overrides.
  ///
  /// Any parameter not specified uses its default value.
  const CoreTuning({
    this.physics = const PhysicsTuning(),
    this.unocoDemon = const UnocoDemonTuning(),
    this.groundEnemy = const GroundEnemyTuning(),
    this.navigation = const NavigationTuning(),
    this.spatialGrid = const SpatialGridTuning(),
    this.camera = const CameraTuning(),
    this.track = const TrackTuning(),
    this.collectible = const CollectibleTuning(),
    this.restorationItem = const RestorationItemTuning(),
    this.score = const ScoreTuning(),
  });

  /// Physics constants (gravity, etc.).
  final PhysicsTuning physics;

  /// Flying enemy AI and spawn parameters.
  final UnocoDemonTuning unocoDemon;

  /// Ground enemy AI and movement parameters.
  final GroundEnemyTuning groundEnemy;

  /// Pathfinding and navigation parameters.
  final NavigationTuning navigation;

  /// Spatial partitioning grid settings.
  final SpatialGridTuning spatialGrid;

  /// Camera behavior (autoscroll, smoothing).
  final CameraTuning camera;

  /// Track streaming and chunk generation.
  final TrackTuning track;

  /// Collectible spawn density and placement.
  final CollectibleTuning collectible;

  /// Restoration item spawn frequency and sizing.
  final RestorationItemTuning restorationItem;

  /// Score calculation parameters.
  final ScoreTuning score;
}


===== FILE: lib/core/tuning/flying_enemy_tuning.dart =====
/// Flying enemy AI tuning (steering, strikes).
library;

import '../util/tick_math.dart';

class UnocoDemonTuning {
  const UnocoDemonTuning({
    this.unocoDemonHoverOffsetY = 150.0,
    this.unocoDemonDesiredRangeMin = 50.0,
    this.unocoDemonDesiredRangeMax = 90.0,
    this.unocoDemonDesiredRangeHoldMinSeconds = 0.60,
    this.unocoDemonDesiredRangeHoldMaxSeconds = 1.40,
    this.unocoDemonHoldSlack = 20.0,
    this.unocoDemonMaxSpeedX = 300.0,
    this.unocoDemonSlowRadiusX = 80.0,
    this.unocoDemonAccelX = 600.0,
    this.unocoDemonDecelX = 400.0,
    this.unocoDemonMinHeightAboveGround = 100.0,
    this.unocoDemonMaxHeightAboveGround = 240.0,
    this.unocoDemonFlightTargetHoldMinSeconds = 1.5,
    this.unocoDemonFlightTargetHoldMaxSeconds = 3.0,
    this.unocoDemonMaxSpeedY = 300.0,
    this.unocoDemonVerticalKp = 4.0,
    this.unocoDemonVerticalDeadzone = 20.0,
    this.unocoDemonAimLeadMinSeconds = 0.08,
    this.unocoDemonAimLeadMaxSeconds = 0.40,
    this.unocoDemonCastCooldownSeconds = 2.0,
    this.unocoDemonCastOriginOffset = 20.0,
  });

  // ── Steering ──

  /// Vertical offset above player when hovering (world units).
  final double unocoDemonHoverOffsetY;

  /// Min horizontal range to maintain from player (world units).
  final double unocoDemonDesiredRangeMin;

  /// Max horizontal range to maintain from player (world units).
  final double unocoDemonDesiredRangeMax;

  /// Min time to hold a desired range before picking new (seconds).
  final double unocoDemonDesiredRangeHoldMinSeconds;

  /// Max time to hold a desired range (seconds).
  final double unocoDemonDesiredRangeHoldMaxSeconds;

  /// Slack distance before recalculating position (world units).
  final double unocoDemonHoldSlack;

  /// Max horizontal speed (world units/sec).
  final double unocoDemonMaxSpeedX;

  /// Distance from target where decel starts (world units).
  final double unocoDemonSlowRadiusX;

  /// Horizontal acceleration (world units/sec²).
  final double unocoDemonAccelX;

  /// Horizontal deceleration (world units/sec²).
  final double unocoDemonDecelX;

  /// Min height above ground (world units).
  final double unocoDemonMinHeightAboveGround;

  /// Max height above ground (world units).
  final double unocoDemonMaxHeightAboveGround;

  /// Min time to hold a flight target (seconds).
  final double unocoDemonFlightTargetHoldMinSeconds;

  /// Max time to hold a flight target (seconds).
  final double unocoDemonFlightTargetHoldMaxSeconds;

  /// Max vertical speed (world units/sec).
  final double unocoDemonMaxSpeedY;

  /// Proportional gain for vertical steering.
  final double unocoDemonVerticalKp;

  /// Deadzone for vertical error (world units).
  final double unocoDemonVerticalDeadzone;

  // ── Strikes ──

  /// Min lead time when aiming at player (seconds).
  final double unocoDemonAimLeadMinSeconds;

  /// Max lead time when aiming at player (seconds).
  final double unocoDemonAimLeadMaxSeconds;

  /// Cooldown between casts (seconds).
  final double unocoDemonCastCooldownSeconds;

  /// Projectile spawn offset from center (world units).
  final double unocoDemonCastOriginOffset;
}

class UnocoDemonTuningDerived {
  const UnocoDemonTuningDerived._({
    required this.tickHz,
    required this.base,
    required this.unocoDemonCastCooldownTicks,
  });

  factory UnocoDemonTuningDerived.from(
    UnocoDemonTuning base, {
    required int tickHz,
  }) {
    if (tickHz <= 0) {
      throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
    }

    return UnocoDemonTuningDerived._(
      tickHz: tickHz,
      base: base,
      unocoDemonCastCooldownTicks: ticksFromSecondsCeil(
        base.unocoDemonCastCooldownSeconds,
        tickHz,
      ),
    );
  }

  final int tickHz;
  final UnocoDemonTuning base;

  final int unocoDemonCastCooldownTicks;
}


===== FILE: lib/core/tuning/ground_enemy_tuning.dart =====
/// Ground enemy AI tuning grouped by navigation/engagement/locomotion/combat.
library;

import '../util/tick_math.dart';

class GroundEnemyTuning {
  const GroundEnemyTuning({
    this.navigation = const GroundEnemyNavigationTuning(),
    this.engagement = const GroundEnemyEngagementTuning(),
    this.locomotion = const GroundEnemyLocomotionTuning(),
    this.combat = const GroundEnemyCombatTuning(),
  });

  final GroundEnemyNavigationTuning navigation;
  final GroundEnemyEngagementTuning engagement;
  final GroundEnemyLocomotionTuning locomotion;
  final GroundEnemyCombatTuning combat;
}

/// Navigation tuning (chase offset + speed variance).
class GroundEnemyNavigationTuning {
  const GroundEnemyNavigationTuning({
    this.chaseOffsetMaxX = 18.0,
    this.chaseOffsetMinAbsX = 6.0,
    this.chaseOffsetMeleeX = 3.0,
    this.chaseSpeedScaleMin = 0.92,
    this.chaseSpeedScaleMax = 1.08,
    this.chaseTargetDelayTicks = 6,
  });

  /// Max random chase offset from player (world units).
  final double chaseOffsetMaxX;

  /// Min absolute chase offset (prevents clumping).
  final double chaseOffsetMinAbsX;

  /// Chase offset when in melee range (world units).
  final double chaseOffsetMeleeX;

  /// Min speed scale for chase variance.
  final double chaseSpeedScaleMin;

  /// Max speed scale for chase variance.
  final double chaseSpeedScaleMax;

  /// Fixed reaction delay (in simulation ticks) applied to chase targeting.
  ///
  /// The navigation system will chase the player's (or predicted) target X from
  /// `delayTicks` ago, producing a deterministic "reaction time" feel.
  ///
  /// Example: At 60 Hz, `6` ticks ≈ 100ms.
  final int chaseTargetDelayTicks;
}

/// Engagement tuning (slot selection + melee state movement).
class GroundEnemyEngagementTuning {
  const GroundEnemyEngagementTuning({
    this.meleeEngageBufferX = 4.0,
    this.meleeEngageHysteresisX = 2.0,
    this.meleeArriveSlowRadiusX = 12.0,
    this.meleeStrikeSpeedMul = 0.25,
    this.meleeRecoverSpeedMul = 0.5,
  });

  /// Extra buffer beyond melee range to enter engage state.
  final double meleeEngageBufferX;

  /// Hysteresis added to engage buffer for disengage threshold.
  final double meleeEngageHysteresisX;

  /// Radius within which arrival steering slows to zero.
  final double meleeArriveSlowRadiusX;

  /// Speed multiplier during strike state.
  final double meleeStrikeSpeedMul;

  /// Speed multiplier during recover state.
  final double meleeRecoverSpeedMul;
}

/// Locomotion tuning (movement + jump).
class GroundEnemyLocomotionTuning {
  const GroundEnemyLocomotionTuning({
    this.speedX = 300.0,
    this.stopDistanceX = 6.0,
    this.accelX = 600.0,
    this.decelX = 400.0,
    this.jumpSpeed = 500.0,
  });

  /// Target horizontal speed (world units/sec).
  final double speedX;

  /// Distance at which enemy stops chasing (world units).
  final double stopDistanceX;

  /// Horizontal acceleration (world units/sec^2).
  final double accelX;

  /// Horizontal deceleration (world units/sec^2).
  final double decelX;

  /// Jump velocity (world units/sec, positive = upward).
  final double jumpSpeed;
}

/// Combat tuning (melee timing + damage).
class GroundEnemyCombatTuning {
  const GroundEnemyCombatTuning({
    this.meleeRangeX = 52.0,
    this.meleeCooldownSeconds = 1.0,
    this.meleeActiveSeconds = 0.10,
    this.meleeAnimSeconds = 0.60,
    this.meleeWindupSeconds = 0.18,
    this.meleeDamage = 5.0,
    this.meleeHitboxSizeX = 56.0,
    this.meleeHitboxSizeY = 32.0,
  });

  /// Horizontal range to trigger melee strike (world units).
  final double meleeRangeX;

  /// Cooldown between melee strikes (seconds).
  final double meleeCooldownSeconds;

  /// Duration melee hitbox is active (seconds).
  final double meleeActiveSeconds;

  /// Duration the melee strike animation should be visible (seconds).
  ///
  /// This can be longer than [meleeActiveSeconds] since the hitbox
  /// window is often only a subset of the full animation.
  final double meleeAnimSeconds;

  /// Telegraph window before the melee hitbox becomes active (seconds).
  ///
  /// This delays hitbox spawn relative to the start of the strike animation.
  final double meleeWindupSeconds;

  /// Damage dealt by melee strike.
  final double meleeDamage;

  /// Melee hitbox width (world units).
  final double meleeHitboxSizeX;

  /// Melee hitbox height (world units).
  final double meleeHitboxSizeY;
}

class GroundEnemyTuningDerived {
  const GroundEnemyTuningDerived._({
    required this.tickHz,
    required this.base,
    required this.navigation,
    required this.engagement,
    required this.locomotion,
    required this.combat,
  });

  factory GroundEnemyTuningDerived.from(
    GroundEnemyTuning base, {
    required int tickHz,
  }) {
    if (tickHz <= 0) {
      throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
    }

    final combat = base.combat;
    final engagement = base.engagement;

    final meleeStandOffX = () {
      final desired = combat.meleeHitboxSizeX * (2.0 / 3.0);
      if (desired.isNaN || desired.isInfinite) return 0.0;
      final clampedToRange = desired > combat.meleeRangeX
          ? combat.meleeRangeX
          : desired;
      return clampedToRange < 0.0 ? 0.0 : clampedToRange;
    }();

    return GroundEnemyTuningDerived._(
      tickHz: tickHz,
      base: base,
      navigation: base.navigation,
      engagement: GroundEnemyEngagementTuningDerived(
        meleeEngageBufferX: engagement.meleeEngageBufferX,
        meleeEngageHysteresisX: engagement.meleeEngageHysteresisX,
        meleeArriveSlowRadiusX: engagement.meleeArriveSlowRadiusX,
        meleeStrikeSpeedMul: engagement.meleeStrikeSpeedMul,
        meleeRecoverSpeedMul: engagement.meleeRecoverSpeedMul,
        meleeStandOffX: meleeStandOffX,
      ),
      locomotion: base.locomotion,
      combat: () {
        final meleeCooldownTicks = ticksFromSecondsCeil(
          combat.meleeCooldownSeconds,
          tickHz,
        );
        final meleeActiveTicks = ticksFromSecondsCeil(
          combat.meleeActiveSeconds,
          tickHz,
        );
        final meleeAnimTicks = ticksFromSecondsCeil(
          combat.meleeAnimSeconds,
          tickHz,
        );
        final rawWindupTicks = ticksFromSecondsCeil(
          combat.meleeWindupSeconds,
          tickHz,
        );
        // Ensure the hit tick occurs while the strike animation is still visible.
        final maxWindupTicks = meleeAnimTicks > 0 ? meleeAnimTicks - 1 : 0;
        final meleeWindupTicks =
            rawWindupTicks > maxWindupTicks ? maxWindupTicks : rawWindupTicks;
        return GroundEnemyCombatTuningDerived(
        meleeRangeX: combat.meleeRangeX,
        meleeCooldownSeconds: combat.meleeCooldownSeconds,
        meleeActiveSeconds: combat.meleeActiveSeconds,
        meleeAnimSeconds: combat.meleeAnimSeconds,
        meleeWindupSeconds: combat.meleeWindupSeconds,
        meleeDamage: combat.meleeDamage,
        meleeHitboxSizeX: combat.meleeHitboxSizeX,
        meleeHitboxSizeY: combat.meleeHitboxSizeY,
        meleeCooldownTicks: meleeCooldownTicks,
        meleeActiveTicks: meleeActiveTicks,
        meleeAnimTicks: meleeAnimTicks,
        meleeWindupTicks: meleeWindupTicks,
      );
      }(),
    );
  }

  final int tickHz;
  final GroundEnemyTuning base;
  final GroundEnemyNavigationTuning navigation;
  final GroundEnemyEngagementTuningDerived engagement;
  final GroundEnemyLocomotionTuning locomotion;
  final GroundEnemyCombatTuningDerived combat;
}

class GroundEnemyEngagementTuningDerived extends GroundEnemyEngagementTuning {
  const GroundEnemyEngagementTuningDerived({
    required super.meleeEngageBufferX,
    required super.meleeEngageHysteresisX,
    required super.meleeArriveSlowRadiusX,
    required super.meleeStrikeSpeedMul,
    required super.meleeRecoverSpeedMul,
    required this.meleeStandOffX,
  });

  /// Stand-off target used in engage/strike/recover phases.
  ///
  /// Derived from [GroundEnemyCombatTuning.meleeHitboxSizeX] so the player
  /// sits well within the hitbox when the enemy is at its preferred slot.
  final double meleeStandOffX;
}

class GroundEnemyCombatTuningDerived extends GroundEnemyCombatTuning {
  const GroundEnemyCombatTuningDerived({
    required super.meleeRangeX,
    required super.meleeCooldownSeconds,
    required super.meleeActiveSeconds,
    required super.meleeAnimSeconds,
    required super.meleeWindupSeconds,
    required super.meleeDamage,
    required super.meleeHitboxSizeX,
    required super.meleeHitboxSizeY,
    required this.meleeCooldownTicks,
    required this.meleeActiveTicks,
    required this.meleeAnimTicks,
    required this.meleeWindupTicks,
  });

  final int meleeCooldownTicks;
  final int meleeActiveTicks;
  final int meleeAnimTicks;
  final int meleeWindupTicks;
}


===== FILE: lib/core/tuning/navigation_tuning.dart =====
/// Navigation tuning for surface-graph based AI.
///
/// This is intentionally separate from movement/combat tunings:
/// - movement tuning controls the player's physical feel
/// - enemy tuning controls per-enemy locomotion abilities
/// - navigation tuning controls pathfinding + graph build tradeoffs
library;
import '../navigation/types/nav_tolerances.dart';

class NavigationTuning {
  const NavigationTuning({
    this.repathCooldownTicks = 30,
    this.maxExpandedNodes = 128,
    this.edgePenaltySeconds = 0.05,
    this.surfaceEps = navSpatialEps,
    this.takeoffEpsMin = 2.0,
    this.takeoffSampleMaxStep = 64.0,
  }) : assert(repathCooldownTicks >= 0),
       assert(maxExpandedNodes > 0),
       assert(edgePenaltySeconds >= 0.0),
       assert(surfaceEps > 0.0),
       assert(takeoffEpsMin >= 0.0),
       assert(takeoffSampleMaxStep > 0.0);

  /// Throttle replans per entity to avoid per-tick A* on mobile.
  final int repathCooldownTicks;

  /// Hard cap on A* node expansions (fail fast deterministically).
  final int maxExpandedNodes;

  /// Small per-edge penalty that biases toward fewer hops when costs tie.
  final double edgePenaltySeconds;

  /// Vertical tolerance when locating the current/target surface (world units).
  final double surfaceEps;

  /// Minimum horizontal tolerance for "close enough to takeoff" (world units).
  ///
  /// The actual takeoff epsilon can be increased by the locomotion controller
  /// (e.g. tied to an enemy's stop distance) to avoid "stops too early to jump".
  final double takeoffEpsMin;

  /// Maximum step between takeoff samples on long surfaces (world units).
  final double takeoffSampleMaxStep;
}


===== FILE: lib/core/tuning/physics_tuning.dart =====
/// Global physics tuning for the Core simulation.
///
/// This is intentionally separate from movement/ability/combat tunings so it can
/// evolve into per-level/biome physics profiles later (e.g. low-gravity zones).
class PhysicsTuning {
  const PhysicsTuning({
    this.gravityY = 1200,
  });

  /// Gravity acceleration (positive is downward), in world units / second^2.
  final double gravityY;
}



===== FILE: lib/core/tuning/restoration_item_tuning.dart =====
/// Restoration item spawning and restore configuration.
class RestorationItemTuning {
  const RestorationItemTuning({
    this.enabled = true,
    this.spawnEveryChunks = 16,
    this.spawnStartChunkIndex = 2,
    this.restorePercentBp = 3000,
    this.itemSize = 16.0,
    this.surfaceClearanceY = 10.0,
    this.noSpawnMargin = 2.0,
    this.chunkEdgeMarginX = 32.0,
    this.maxAttemptsPerSpawn = 40,
    this.despawnBehindCameraMargin = 900.0,
  });

  /// Master toggle for restoration item spawning.
  final bool enabled;

  /// Spawn one item every N chunks.
  final int spawnEveryChunks;

  /// First chunk index where items can spawn.
  final int spawnStartChunkIndex;

  /// Fraction of max HP/mana/stamina restored in basis points (100 = 1%).
  final int restorePercentBp;

  /// Collision/render size (world units).
  final double itemSize;

  /// Vertical clearance above surface (world units).
  final double surfaceClearanceY;

  /// Margin from surface edges (world units).
  final double noSpawnMargin;

  /// Margin from chunk edges (world units).
  final double chunkEdgeMarginX;

  /// Max placement attempts before giving up.
  final int maxAttemptsPerSpawn;

  /// Distance behind camera before despawn (world units).
  final double despawnBehindCameraMargin;
}


===== FILE: lib/core/tuning/score_tuning.dart =====
/// Scoring tuning (points per time, distance, kills).
library;

/// World units per meter (used for distance→score conversion).
const int kWorldUnitsPerMeter = 50;

class ScoreTuning {
  const ScoreTuning({
    this.timeScorePerSecond = 5,
    this.distanceScorePerMeter = 5,
    this.groundEnemyKillScore = 100,
    this.unocoDemonKillScore = 150,
  }) : assert(timeScorePerSecond >= 0),
       assert(distanceScorePerMeter >= 0),
       assert(groundEnemyKillScore >= 0),
       assert(unocoDemonKillScore >= 0);

  /// Points per real-time second survived (implemented deterministically via tickHz).
  final int timeScorePerSecond;

  /// Points per whole meter traveled (50 world units = 1 meter).
  final int distanceScorePerMeter;

  /// Points for killing an enemy (by type).
  final int groundEnemyKillScore;
  final int unocoDemonKillScore;
}


===== FILE: lib/core/tuning/spatial_grid_tuning.dart =====
/// Simulation tuning/config for grid-based spatial indexing (broadphase now,
/// navigation later).
///
/// Keep this separate from combat tuning: broadphase is a physics/simulation
/// concern, not a combat rule.
class SpatialGridTuning {
  const SpatialGridTuning({
    this.broadphaseCellSize = 32.0,
  });

  /// Default broadphase cell size for dynamic AABB queries.
  ///
  /// With current collider sizes (player ~16x16, enemies ~24x24), `32.0`
  /// keeps candidate sets small while keeping grid math cheap.
  final double broadphaseCellSize;
}



===== FILE: lib/core/tuning/track_tuning.dart =====
/// Track streaming / deterministic chunk spawning configuration.
///
/// This is simulation config (Core), not combat/ability tuning.
class TrackTuning {
  const TrackTuning({
    this.enabled = true,
    this.chunkWidth = 600.0,
    this.spawnAheadMargin = 600.0,
    this.cullBehindMargin = 600.0,
    this.enemyCullBelowGroundOffsetY = 300.0,
    this.gridSnap = 16.0,
    this.playerStartX = 300.0,
    this.gapKillOffsetY = 400.0,
  }) : assert(chunkWidth > 0),
       assert(spawnAheadMargin >= 0),
       assert(cullBehindMargin >= 0),
       assert(enemyCullBelowGroundOffsetY >= 0),
       assert(gridSnap > 0),
       assert(playerStartX >= 0),
       assert(gapKillOffsetY >= 0);

  /// If false, no chunk streaming is performed (static world only).
  final bool enabled;

  /// Width of a chunk in world units.
  final double chunkWidth;

  /// Spawn chunks while `cameraRight + spawnAheadMargin >= nextChunkStartX`.
  final double spawnAheadMargin;

  /// Cull chunks while `chunkEndX < cameraLeft - cullBehindMargin`.
  final double cullBehindMargin;

  /// Enemies are despawned if their bottom falls this far below groundTopY.
  final double enemyCullBelowGroundOffsetY;

  /// Authoring grid snap for chunk patterns (world units).
  final double gridSnap;

  /// Player spawn X position at run start (world units).
  final double playerStartX;

  /// How far below ground the player must fall before death triggers.
  ///
  /// Set high enough to give visual feedback of falling into the gap
  /// before the death screen appears.
  final double gapKillOffsetY;
}


===== FILE: lib/core/tuning/utils/anim_tuning.dart =====
/// Animation tuning helper utilities (Core-owned, deterministic).
///
/// This module is intentionally generic so it can be reused by player/enemy
/// tuning without taking a dependency on any specific character system.
library;

/// Computes a recommended duration for a strip based on frame count and step time.
double secondsForStrip({
  required int frameCount,
  required double stepTimeSeconds,
}) {
  if (frameCount <= 0 || stepTimeSeconds <= 0) return 0.0;
  return frameCount * stepTimeSeconds;
}

/// Computes strip duration for a specific [key] from tuning maps.
///
/// Works with any key type (enums, ints, strings) to keep it reusable.
double secondsForKey<K>({
  required K key,
  required Map<K, int> frameCounts,
  required Map<K, double> stepTimeSecondsByKey,
  int defaultFrameCount = 1,
  double defaultStepTimeSeconds = 0.10,
}) {
  final frames = frameCounts[key] ?? defaultFrameCount;
  final step = stepTimeSecondsByKey[key] ?? defaultStepTimeSeconds;
  return secondsForStrip(frameCount: frames, stepTimeSeconds: step);
}



===== FILE: lib/core/util/deterministic_rng.dart =====
/// Deterministic random number generation utilities.
///
/// Provides seedable, reproducible pseudo-random numbers for procedural
/// generation. Uses Xorshift32 (fast, small state) with MurmurHash3 mixing
/// for seed avalanche. All functions are pure and tick-deterministic.
library;

/// Bitmask for 32-bit unsigned integer operations.
const int _mask32 = 0xffffffff;

/// Fallback seed when mixing produces zero (Xorshift32 degenerates on zero).
const int _nonZeroSeed = 0x6d2b79f5;

/// MurmurHash3 finalizer-style bit mixer.
///
/// Produces a well-distributed 32-bit hash from any integer input.
/// Used to "avalanche" seed bits before RNG initialization.
int mix32(int x) {
  var v = x & _mask32;
  v ^= (v >> 16);
  v = (v * 0x7feb352d) & _mask32;
  v ^= (v >> 15);
  v = (v * 0x846ca68b) & _mask32;
  v ^= (v >> 16);
  return v & _mask32;
}

/// Derives a non-zero 32-bit RNG state from [seed] and [salt].
///
/// XORs seed with salt, then mixes. Guarantees non-zero output to
/// prevent Xorshift32 from degenerating into a constant sequence.
int seedFrom(int seed, int salt) {
  final mixed = mix32(seed ^ salt);
  return mixed == 0 ? _nonZeroSeed : mixed;
}

/// Advances [state] by one Xorshift32 step, returning the new state.
///
/// The returned value serves as both the next state and the random output.
/// Period: 2³²−1. Passes most statistical tests for game use.
int nextUint32(int state) {
  var x = state & _mask32;
  if (x == 0) x = _nonZeroSeed; // Guard against degenerate zero state.
  x ^= (x << 13) & _mask32;
  x ^= (x >> 17);
  x ^= (x << 5) & _mask32;
  return x & _mask32;
}

/// Converts a 32-bit unsigned [value] to a double in \[0, 1\].
///
/// Uses simple division for uniform distribution. Inclusive on both ends.
double uint32ToUnitDouble(int value) {
  return (value & _mask32) / _mask32;
}

/// Maps a 32-bit unsigned [value] to a double in \[[min], [max]\].
///
/// Automatically swaps [min]/[max] if inverted. Distribution is uniform.
double rangeDouble(int value, double min, double max) {
  final lo = min <= max ? min : max;
  final hi = min <= max ? max : min;
  return lo + (hi - lo) * uint32ToUnitDouble(value);
}


===== FILE: lib/core/util/double_math.dart =====
/// Floating-point math helpers.
///
/// Supplements `dart:math` with common operations not in the standard library.
library;

import 'dart:math';

/// Clamps [v] to the range \[[lo], [hi]\].
///
/// Returns [lo] if `v < lo`, [hi] if `v > hi`, otherwise [v].
double clampDouble(double v, double lo, double hi) => max(lo, min(hi, v));



===== FILE: lib/core/util/fixed_math.dart =====
/// Fixed-point math helpers for deterministic simulation.
///
/// Units:
/// - Fixed100: 100 = 1.00
/// - Basis Points (bp): 100 = 1%, 10000 = 100%
library;

import 'dart:math';

const int fixedScale = 100;
const int bpScale = 10000;

/// Converts a double to fixed-point (100 = 1.0).
int toFixed100(double value) => (value * fixedScale).round();

/// Converts a double to basis points (100 = 1%).
int toBp(double value) => (value * bpScale).round();

/// Converts fixed-point (100 = 1.0) to double.
double fromFixed100(int value) => value / fixedScale;

/// Clamps [v] to the range [lo, hi].
int clampInt(int v, int lo, int hi) => max(lo, min(hi, v));

/// Scales [value] by a basis-point modifier.
///
/// Example: value=1000, bonusBp=2000 (+20%) -> 1200.
int applyBp(int value, int bonusBp) =>
    (value * (bpScale + bonusBp)) ~/ bpScale;



===== FILE: lib/core/util/smoothing.dart =====
/// Smoothing utilities for frame-rate-independent interpolation.
///
/// Provides exponential smoothing factors that behave consistently
/// regardless of tick rate, useful for camera follow, UI animations, etc.
library;

import 'dart:math';

/// Returns an exponential smoothing factor α in \[0, 1\].
///
/// Given responsiveness [k] (1/seconds) and tick duration [dtSeconds],
/// computes `α = 1 − e^(−k·dt)`. Use as: `value += α * (target − value)`.
///
/// Matches the common pattern: `alpha = 1 - exp(-k * dt)`.
double expSmoothingFactor(double k, double dtSeconds) {
  if (k <= 0) return 0.0;
  if (dtSeconds <= 0) return 0.0;
  return 1.0 - exp(-k * dtSeconds);
}



===== FILE: lib/core/util/tick_math.dart =====
/// Tick/time conversion utilities.
///
/// Bridges between author-friendly seconds and simulation tick counts.
library;

import 'dart:math';

/// Converts [seconds] to tick count at [tickHz], rounding up.
///
/// Rules:
/// - `seconds <= 0` => `0` ticks
/// - otherwise `max(1, ceil(seconds * tickHz))`
int ticksFromSecondsCeil(double seconds, int tickHz) {
  if (tickHz <= 0) {
    throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
  }
  if (seconds <= 0) return 0;
  return max(1, (seconds * tickHz).ceil());
}



===== FILE: lib/core/util/vec2.dart =====
/// Minimal 2D vector type for Core ↔ UI data transfer.
///
/// Immutable, allocation-light, pure Dart. Used in snapshots and events.
/// Internal systems prefer raw `double` fields for hot loops.
library;

/// Immutable 2D vector with [x] and [y] coordinates.
class Vec2 {
  /// Creates a new immutable vector at ([x], [y]).
  const Vec2(this.x, this.y);

  /// Zero vector (0, 0).
  static const Vec2 zero = Vec2(0, 0);

  /// X coordinate (Horizontal), usually in world units/pixels.
  final double x;

  /// Y coordinate (Vertical), usually in world units/pixels.
  final double y;

  /// Returns a new [Vec2] with [x] replaced by [value].
  Vec2 withX(double value) => Vec2(value, y);

  /// Returns a new [Vec2] with [y] replaced by [value].
  Vec2 withY(double value) => Vec2(x, value);

  /// Component-wise Addition.
  Vec2 operator +(Vec2 other) => Vec2(x + other.x, y + other.y);

  /// Component-wise Subtraction.
  Vec2 operator -(Vec2 other) => Vec2(x - other.x, y - other.y);

  /// Scalar Multiplication.
  Vec2 scale(double factor) => Vec2(x * factor, y * factor);

  @override
  String toString() => 'Vec2(${x.toStringAsFixed(2)}, ${y.toStringAsFixed(2)})';
  
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Vec2 &&
          runtimeType == other.runtimeType &&
          x == other.x &&
          y == other.y;

  @override
  int get hashCode => x.hashCode ^ y.hashCode;
}


===== FILE: lib/core/util/velocity_math.dart =====
/// Velocity ramping utilities.
///
/// Helpers for smoothly accelerating/decelerating toward a target speed,
/// used by player and enemy movement systems.
library;

/// Ramps [current] velocity toward [desired] using asymmetric accel/decel.
///
/// - Accelerates at [accelPerSecond] when moving toward non-zero [desired].
/// - Decelerates at [decelPerSecond] when [desired] is zero.
/// - Snaps to zero if `|current| <= minStopSpeed` and `desired == 0`.
///
/// Returns the updated velocity after [dtSeconds].
double applyAccelDecel({
  required double current,
  required double desired,
  required double dtSeconds,
  required double accelPerSecond,
  required double decelPerSecond,
  double minStopSpeed = 0.0,
}) {
  if (dtSeconds <= 0.0) return current;
  if (desired == 0.0 && current.abs() <= minStopSpeed) return 0.0;

  final accel = desired == 0.0 ? decelPerSecond : accelPerSecond;
  final maxDelta = accel * dtSeconds;
  final delta = desired - current;
  if (delta.abs() > maxDelta) {
    return current + (delta > 0.0 ? maxDelta : -maxDelta);
  }
  return desired;
}


===== FILE: lib/core/weapons/weapon_catalog.dart =====
import '../abilities/ability_def.dart' show AbilityTag, WeaponType;
import 'weapon_category.dart';
import 'weapon_def.dart';
import 'weapon_id.dart';
import 'weapon_stats.dart';

/// Lookup table for weapon definitions.
///
/// Similar to [ProjectileItemCatalog], but for melee weapons.
class WeaponCatalog {
  const WeaponCatalog();

  WeaponDef get(WeaponId id) {
    switch (id) {
      case WeaponId.basicSword:
        return const WeaponDef(
          id: WeaponId.basicSword,
          category: WeaponCategory.primary,
          weaponType: WeaponType.oneHandedSword,
          grantedAbilityTags: {AbilityTag.melee, AbilityTag.physical},
        );
      case WeaponId.goldenSword:
        return const WeaponDef(
          id: WeaponId.goldenSword,
          category: WeaponCategory.primary,
          weaponType: WeaponType.oneHandedSword,
          grantedAbilityTags: {AbilityTag.melee, AbilityTag.physical},
          stats: WeaponStats(powerBonusBp: 2000), // +20% Damage
        );
      case WeaponId.basicShield:
        return const WeaponDef(
          id: WeaponId.basicShield,
          category: WeaponCategory.offHand,
          weaponType: WeaponType.shield,
          grantedAbilityTags: {AbilityTag.buff, AbilityTag.physical},
          stats: WeaponStats(powerBonusBp: 500),
        );
      case WeaponId.goldenShield:
        return const WeaponDef(
          id: WeaponId.goldenShield,
          category: WeaponCategory.offHand,
          weaponType: WeaponType.shield,
          grantedAbilityTags: {AbilityTag.buff, AbilityTag.physical},
          stats: WeaponStats(powerBonusBp: 1000),
        );
    }
  }

  WeaponDef? tryGet(WeaponId id) {
    try {
      return get(id);
    } catch (_) {
      return null;
    }
  }
}


===== FILE: lib/core/weapons/weapon_category.dart =====
/// Equipment slot category for weapons.
///
/// This determines which equipment slot(s) a weapon occupies,
/// not which ability slots it can power.
enum WeaponCategory {
  /// Main hand weapons (swords, axes, spears).
  primary,

  /// Off-hand equipment (shields, daggers, torches).
  offHand,

  /// Throwing weapons (knives, axes).
  projectile,
}


===== FILE: lib/core/weapons/weapon_def.dart =====
import '../abilities/ability_def.dart' show AbilityTag, WeaponType;
import '../combat/damage_type.dart';
import 'weapon_category.dart';
import 'weapon_id.dart';
import 'weapon_proc.dart';
import 'weapon_stats.dart';

/// Static, data-first definition for a melee weapon.
///
/// Weapon definitions are queried by [WeaponId] and used by intent writers
/// (e.g. [AbilityActivationSystem]) to fill combat metadata like damage type and
/// on-hit status profiles.
class WeaponDef {
  const WeaponDef({
    required this.id,
    required this.category,
    required this.weaponType,
    this.grantedAbilityTags = const {},
    this.damageType = DamageType.physical,
    this.procs = const [],
    this.stats = const WeaponStats(),
    this.isTwoHanded = false,
  });

  final WeaponId id;

  /// Equipment slot category (primary/offHand/projectile).
  final WeaponCategory category;

  /// Visual/functional family (used for ability gating).
  final WeaponType weaponType;

  /// Capabilities provided by this weapon.
  /// Abilities check: requiredTags ⊆ grantedAbilityTags.
  /// Safe default: empty grants nothing.
  final Set<AbilityTag> grantedAbilityTags;

  /// Default damage type applied to hits.
  final DamageType damageType;

  /// New, extensible proc list (Phase 2+).
  final List<WeaponProc> procs;

  /// Passive stats provided by this weapon (future use).
  final WeaponStats stats;

  /// If true, occupies both Primary + Secondary equipment slots.
  /// Enforcement is equip-time validation (Phase 3/4).
  final bool isTwoHanded;
}


===== FILE: lib/core/weapons/weapon_id.dart =====
/// Stable identifiers for melee weapons.
///
/// These IDs are intended to be deterministic and allocation-light, similar to
/// projectile item IDs used for the projectile slot.
enum WeaponId {
  /// Default starter weapon.
  basicSword,
  basicShield,
  goldenSword,
  goldenShield,
}


===== FILE: lib/core/weapons/weapon_proc.dart =====
import '../combat/status/status.dart';

/// Hook points where weapon procs can trigger.
enum ProcHook {
  onHit,
  onBlock,
  onKill,
  onCrit,
}

/// A single proc effect that can be attached to a weapon.
///
/// When the specified [hook] triggers, there's a [chance] to apply
/// the status effect defined by [statusProfileId].
class WeaponProc {
  const WeaponProc({
    required this.hook,
    required this.statusProfileId,
    this.chanceBp = 10000,
  }) : assert(chanceBp >= 0 && chanceBp <= 10000, 'chanceBp must be in [0..10000]');

  /// When this proc can trigger.
  final ProcHook hook;

  /// The status effect profile to apply.
  final StatusProfileId statusProfileId;

  /// Probability of triggering in Basis Points (100 = 1%, 10000 = 100%).
  final int chanceBp;
}



===== FILE: lib/core/weapons/weapon_stats.dart =====
/// Passive stat modifiers provided by a weapon.
///
/// These are not consumed by runtime systems in Phase 2 but provide
/// the data foundation for future damage/crit scaling.
class WeaponStats {
  const WeaponStats({
    this.powerBonusBp = 0,
    this.critChanceBonusBp = 0,
    this.critDamageBonusBp = 0,
    this.rangeScalarPercent = 100,
  }) : assert(rangeScalarPercent > 0, 'rangeScalarPercent must be > 0');

  /// Additive power bonus in Basis Points (100 = 1%).
  final int powerBonusBp;

  /// Additive crit chance bonus in Basis Points (100 = 1%).
  final int critChanceBonusBp;

  /// Additive crit damage bonus in Basis Points (100 = 1%).
  final int critDamageBonusBp;

  /// Multiplicative range modifier relative to 100 (100 = unchanged).
  final int rangeScalarPercent;
}


===== FILE: lib/firebase_options.dart =====
// File generated by FlutterFire CLI.
// ignore_for_file: type=lint
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'firebase_options.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        return ios;
      case TargetPlatform.macOS:
        return macos;
      case TargetPlatform.windows:
        return windows;
      case TargetPlatform.linux:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static const FirebaseOptions web = FirebaseOptions(
    apiKey: 'AIzaSyBVf_cQ5Xj15s_ZngbkeDXAokYCSCR8P7Y',
    appId: '1:964001571974:web:97acd9d8974e215dd81d07',
    messagingSenderId: '964001571974',
    projectId: 'rpg-runner-d7add',
    authDomain: 'rpg-runner-d7add.firebaseapp.com',
    storageBucket: 'rpg-runner-d7add.firebasestorage.app',
    measurementId: 'G-86SWFBNW26',
  );

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyB_RE8QyjyVnoBQ-H59DCIbGbc39faaixA',
    appId: '1:964001571974:android:d48582bc9cde8cf2d81d07',
    messagingSenderId: '964001571974',
    projectId: 'rpg-runner-d7add',
    storageBucket: 'rpg-runner-d7add.firebasestorage.app',
  );

  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: 'AIzaSyCFNb8YfiG8TULypJb6t5c_obcSKxOTpk4',
    appId: '1:964001571974:ios:84c6faf57baaa0f4d81d07',
    messagingSenderId: '964001571974',
    projectId: 'rpg-runner-d7add',
    storageBucket: 'rpg-runner-d7add.firebasestorage.app',
    iosBundleId: 'com.example.rpgRunner',
  );

  static const FirebaseOptions macos = FirebaseOptions(
    apiKey: 'AIzaSyCFNb8YfiG8TULypJb6t5c_obcSKxOTpk4',
    appId: '1:964001571974:ios:84c6faf57baaa0f4d81d07',
    messagingSenderId: '964001571974',
    projectId: 'rpg-runner-d7add',
    storageBucket: 'rpg-runner-d7add.firebasestorage.app',
    iosBundleId: 'com.example.rpgRunner',
  );

  static const FirebaseOptions windows = FirebaseOptions(
    apiKey: 'AIzaSyBVf_cQ5Xj15s_ZngbkeDXAokYCSCR8P7Y',
    appId: '1:964001571974:web:2f0915a1e04e6c16d81d07',
    messagingSenderId: '964001571974',
    projectId: 'rpg-runner-d7add',
    authDomain: 'rpg-runner-d7add.firebaseapp.com',
    storageBucket: 'rpg-runner-d7add.firebasestorage.app',
    measurementId: 'G-XPENVW9P9L',
  );

}

===== FILE: lib/game/AGENTS.md =====
# AGENTS.md - Game Layer

Instructions for AI coding agents working in the **Game** rendering layer (`lib/game/`).

## Game Layer Responsibility

The Game layer is responsible for **visuals only**. It uses the Flame game engine to render the game state produced by Core.

**Critical rule:** Game layer is **never authoritative** for gameplay logic, collision, or state management. All gameplay truth lives in Core.

## Core Snapshot Consumption

### Read-Only Contract

- The Game layer receives `GameStateSnapshot` objects from Core
- **Treat snapshots as read-only** - never mutate snapshot data
- Never simulate or extrapolate gameplay logic in the Game layer

### Interpolation Pattern

For smooth visuals, interpolate between snapshots:

```dart
void render(GameStateSnapshot prevSnapshot, 
            GameStateSnapshot currSnapshot, 
            double alpha) {
  // alpha ranges from 0.0 (prevSnapshot) to 1.0 (currSnapshot)
  
  final prevPos = prevSnapshot.entities[id].position;
  final currPos = currSnapshot.entities[id].position;
  
  final renderPos = prevPos.lerp(currPos, alpha);
  
  // Update sprite position
  sprite.position = renderPos;
}
```

**Rules:**
- Use `prevSnapshot` and `currSnapshot` for interpolation
- `alpha` is the interpolation factor (0.0 to 1.0)
- **Never simulate** - only interpolate between known states
- Never predict future positions or run physics in Game layer

## Flame Component Patterns

### Entity View Components

Entity view components are Flame components that visualize Core entities:

```dart
class PlayerView extends PositionComponent {
  final int entityId;
  
  void update(GameStateSnapshot snapshot, double alpha) {
    // Read entity data from snapshot
    final entity = snapshot.entities[entityId];
    
    // Update visual representation
    position = entity.position;
    animationState = entity.animationState;
  }
}
```

### Component Organization

- **Entity views** (`lib/game/components/`) - Visual representations of Core entities
- **Camera management** - Viewport, camera follow, shake effects
- **Parallax backgrounds** - Multi-layer scrolling backgrounds
- **VFX** - Visual effects (particles, explosions, trails)
- **Debug visualization** (`lib/game/debug/`) - Collision boxes, debug overlays

## World & Camera Rules

### Virtual Resolution

- Pick one **virtual resolution** (world units == virtual pixels)
- Example: 320×180, 640×360, or 1920×1080 depending on art style
- All Core coordinates use this virtual resolution

### Integer Scaling + Letterboxing

- Use **integer scaling** to avoid fractional pixels (prevents shimmering)
- Add **letterboxing** (black bars) when aspect ratio doesn't match
- No fractional scaling - sprite pixels must be crisp

### Pixel Snapping

- Snap camera position to integer pixels inside the scaled viewport
- Snap entity render positions to integer pixels
- This prevents sub-pixel jitter in pixel-art games

```dart
// Example pixel snapping
final snappedX = (position.x).floor().toDouble();
final snappedY = (position.y).floor().toDouble();
sprite.position = Vector2(snappedX, snappedY);
```

## Asset Management

### Per-Scene Loading

- Assets are loaded **per scene**, not at boot
- Load assets when entering a game route/level
- Unload assets when leaving the route/level

**Example:**
```dart
class LevelScene {
  Future<void> load() async {
    await images.load('level1/background.png');
    await images.load('level1/tileset.png');
    // ... load level-specific assets
  }
  
  void unload() {
    images.clear();
  }
}
```

### No Loading During Gameplay

- **Never load assets during active gameplay**
- Load all required assets during a loading screen
- Preload critical assets before gameplay starts
- Use asset pools for frequently spawned entities

## Input Handling

### Convert Input to Commands

The Game layer can receive input (e.g., from Flame's input system), but it must **convert input to Commands** and send them to the controller.

```dart
@override
void onTapDown(TapDownEvent event) {
  // Convert Flame input to Core command
  final command = JumpCommand(
    tickNumber: controller.currentTick,
    playerId: 0,
  );
  
  // Send to controller
  controller.enqueueCommand(command);
}
```

**Rules:**
- Never modify Core state directly from input handlers
- Always use the Command pattern
- Let Core process commands during its tick execution

## Game Events

Game layer consumes `GameEvent` objects from Core to trigger visual/audio effects:

```dart
void handleEvents(List<GameEvent> events) {
  for (final event in events) {
    switch (event) {
      case HitEvent(:final position, :final damage):
        spawnHitVFX(position, damage);
        playSFX('hit.wav');
        break;
        
      case ScreenShakeEvent(:final intensity, :final duration):
        cameraShake(intensity, duration);
        break;
        
      // ... handle other event types
    }
  }
}
```

**Event types:**
- Spawn/despawn events → Create/remove entity views
- Hit/damage events → Spawn VFX, play sounds
- Screen shake events → Apply camera effects
- Reward events → Display score popups, notifications

## Flame API Preferences

### Use Flame for Render Concerns

Flame provides excellent tools for rendering. Use them:

- **Camera components** - `CameraComponent`, `Viewport`, camera follow
- **Parallax rendering** - `ParallaxComponent` for scrolling backgrounds
- **Effects** - `MoveEffect`, `ScaleEffect`, `OpacityEffect`, etc.
- **Sprite animations** - `SpriteAnimationComponent`
- **Particles** - `ParticleSystemComponent` for VFX

### Don't Use Flame for Gameplay

Flame also provides gameplay-adjacent features that we **do not use**:

- ❌ **Flame collision system** - Core handles all collision authoritatively
- ❌ **Flame physics** - Core handles all physics
- ❌ **Flame game loop timing** - Core uses fixed ticks, not Flame's variable dt

## Common Game Subsystems

- **GameController** (`lib/game/game_controller.dart`) - Bridges UI, Game, and Core
- **RunnerFlameGame** (`lib/game/runner_flame_game.dart`) - Main Flame game instance
- **Components** (`lib/game/components/`) - Entity views and visual components
- **Input** (`lib/game/input/`) - Input handling and command conversion
- **Themes** (`lib/game/themes/`) - Visual themes and color schemes
- **Debug** (`lib/game/debug/`) - Debug visualization and tools

## What NOT to Do in Game Layer

- ❌ **Do not simulate gameplay** - that's Core's job
- ❌ **Do not use Flame collision as gameplay truth** - Core is authoritative
- ❌ **Do not mutate Core state** - send Commands instead
- ❌ **Do not mutate snapshots** - they are read-only
- ❌ **Do not load assets during gameplay** - preload everything
- ❌ **Do not use variable dt for gameplay** - Core uses fixed ticks

## Best Practices

✅ **Interpolate for smooth visuals** using prev/curr snapshots
✅ **Use Flame components** for camera, parallax, effects
✅ **Convert input to Commands** before sending to Core
✅ **Consume events** to trigger VFX and SFX
✅ **Load assets per-scene** and unload when done
✅ **Snap positions** for pixel-perfect rendering

---

**For cross-layer architecture and general rules**, see [lib/AGENTS.md](file:///c:/dev/rpg_runner/lib/AGENTS.md).


===== FILE: lib/game/components/aim_ray_component.dart =====
import 'package:flame/components.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/widgets.dart';

import '../../core/snapshots/entity_render_snapshot.dart';
import '../../core/snapshots/enums.dart';
import '../game_controller.dart';
import '../input/aim_preview.dart';

/// Renders a visual "aim ray" or laser sight extending from the player.
///
/// Reacts to [AimPreviewState] to show the player where their projectile
/// or ability will land.
class AimRayComponent extends Component {
  AimRayComponent({
    required this.controller,
    required this.preview,
    required this.length,
    this.playerRenderPos,
    Paint? paint,
    this.drawWhenNoAim = true,
  }) : _paint =
           paint ??
           (Paint()
             ..color = const Color.fromARGB(255, 120, 165, 236)
             ..strokeWidth = 2
             ..strokeCap = StrokeCap.round);

  /// Provides access to the game state (player position).
  final GameController controller;

  /// Reactive state for the current aim direction/status.
  final ValueListenable<AimPreviewState> preview;

  /// Length of the ray in world units (pixels).
  final double length;

  /// Optional rendered player position (already snapped for pixel-perfect render).
  ///
  /// When provided, the ray origin uses this position instead of the raw
  /// snapshot value to avoid 1px drift when render interpolation/snapping is
  /// enabled.
  final ValueGetter<Vector2>? playerRenderPos;

  /// Whether to draw a "straight ahead" ray even when the player hasn't
  /// explicitly dragged to aim (fallback to player facing).
  final bool drawWhenNoAim;

  final Paint _paint;

  @override
  void render(Canvas canvas) {
    final state = preview.value;
    if (!state.active) return;
    if (!state.hasAim && !drawWhenNoAim) return;

    final player = controller.snapshot.playerEntity;
    if (player == null) return;

    final (dirX, dirY) = _resolveDir(state, player);
    final rendered = playerRenderPos?.call();
    final startX = rendered?.x ?? player.pos.x;
    final startY = rendered?.y ?? player.pos.y;
    final endX = startX + dirX * length;
    final endY = startY + dirY * length;

    canvas.drawLine(Offset(startX, startY), Offset(endX, endY), _paint);
  }

  /// Determines the ray direction.
  ///
  /// Uses the explicit aim if available; otherwise falls back to the player's
  /// current facing direction.
  (double, double) _resolveDir(
    AimPreviewState state,
    EntityRenderSnapshot player,
  ) {
    if (state.hasAim) {
      return (state.dirX, state.dirY);
    }
    final facing = player.facing;
    return (facing == Facing.right ? 1.0 : -1.0, 0.0);
  }
}


===== FILE: lib/game/components/enemies/enemy_render_registry.dart =====
/// Enemy render registry and loaders (render layer only).
library;

import 'package:flame/cache.dart';
import 'package:flame/components.dart';

import '../../../core/contracts/render_anim_set_definition.dart';
import '../../../core/enemies/enemy_catalog.dart';
import '../../../core/enemies/enemy_id.dart';
import '../../../core/snapshots/enums.dart';
import '../sprite_anim/deterministic_anim_view_component.dart';
import '../sprite_anim/sprite_anim_set.dart';
import '../sprite_anim/strip_animation_loader.dart';

typedef EnemyAnimLoader =
    Future<SpriteAnimSet> Function(
      Images images, {
      required RenderAnimSetDefinition renderAnim,
      required Set<AnimKey> oneShotKeys,
    });

typedef EnemyViewFactory =
    DeterministicAnimViewComponent Function(
      SpriteAnimSet animSet,
      Vector2 renderScale,
    );

enum EnemyDeathAnimPolicy { spawn, none }

const Set<AnimKey> _defaultEnemyOneShotKeys = <AnimKey>{
  AnimKey.strike,
  AnimKey.hit,
  AnimKey.death,
};

DeterministicAnimViewComponent _defaultEnemyViewFactory(
  SpriteAnimSet animSet,
  Vector2 renderScale,
) {
  return DeterministicAnimViewComponent(
    animSet: animSet,
    renderSize: Vector2(animSet.frameSize.x, animSet.frameSize.y),
    renderScale: renderScale,
  );
}

class EnemyRenderEntry {
  EnemyRenderEntry({
    required this.id,
    required this.renderScale,
    this.deathAnimPolicy = EnemyDeathAnimPolicy.spawn,
    this.oneShotKeys = _defaultEnemyOneShotKeys,
    this.loader = loadAnimSetFromDefinition,
    this.viewFactory = _defaultEnemyViewFactory,
  });

  final EnemyId id;
  final Vector2 renderScale;
  final EnemyDeathAnimPolicy deathAnimPolicy;
  final Set<AnimKey> oneShotKeys;
  final EnemyAnimLoader loader;
  final EnemyViewFactory viewFactory;

  SpriteAnimSet? _animSet;
  bool _hasAssets = true;

  bool get hasAssets => _hasAssets;

  bool get isLoaded => _animSet != null;

  bool get isRenderable => _hasAssets && _animSet != null;

  SpriteAnimSet get animSet {
    final value = _animSet;
    if (value == null) {
      throw StateError('EnemyRenderEntry($id) has not been loaded yet.');
    }
    return value;
  }

  Future<void> load(
    Images images, {
    required RenderAnimSetDefinition renderAnim,
  }) async {
    final idlePath = renderAnim.sourcesByKey[AnimKey.idle];
    if (idlePath == null || idlePath.trim().isEmpty) {
      _hasAssets = false;
      _animSet = null;
      return;
    }
    _animSet = await loader(
      images,
      renderAnim: renderAnim,
      oneShotKeys: oneShotKeys,
    );
  }
}

/// Render registry for enemies (EnemyId -> render wiring).
class EnemyRenderRegistry {
  EnemyRenderRegistry({EnemyCatalog enemyCatalog = const EnemyCatalog()})
    : _enemyCatalog = enemyCatalog;

  final EnemyCatalog _enemyCatalog;

  final Map<EnemyId, EnemyRenderEntry> _entries = <EnemyId, EnemyRenderEntry>{
    EnemyId.unocoDemon: EnemyRenderEntry(
      id: EnemyId.unocoDemon,
      renderScale: Vector2.all(0.5),
    ),
    EnemyId.grojib: EnemyRenderEntry(
      id: EnemyId.grojib,
      renderScale: Vector2.all(1.5),
    ),
  };

  EnemyRenderEntry? entryFor(EnemyId id) {
    final entry = _entries[id];
    if (entry == null || !entry.isRenderable) return null;
    return entry;
  }

  Future<void> load(Images images) async {
    for (final entry in _entries.values) {
      final renderAnim = _enemyCatalog.get(entry.id).renderAnim;
      await entry.load(images, renderAnim: renderAnim);
    }
  }
}


===== FILE: lib/game/components/pickups/pickup_render_registry.dart =====
/// Pickup render registry and loaders (render layer only).
library;

import 'package:flame/cache.dart';
import 'package:flame/components.dart';

import '../../../core/contracts/render_anim_set_definition.dart';
import '../../../core/pickups/pickup_render_catalog.dart';
import '../../../core/snapshots/entity_render_snapshot.dart';
import '../../../core/snapshots/enums.dart';
import '../sprite_anim/deterministic_anim_view_component.dart';
import '../sprite_anim/sprite_anim_set.dart';
import '../sprite_anim/strip_animation_loader.dart';

typedef PickupAnimLoader =
    Future<SpriteAnimSet> Function(
      Images images, {
      required RenderAnimSetDefinition renderAnim,
      required Set<AnimKey> oneShotKeys,
    });

typedef PickupViewFactory =
    DeterministicAnimViewComponent Function(
      SpriteAnimSet animSet,
      Vector2 renderScale,
    );

DeterministicAnimViewComponent _defaultPickupViewFactory(
  SpriteAnimSet animSet,
  Vector2 renderScale,
) {
  return DeterministicAnimViewComponent(
    animSet: animSet,
    renderSize: Vector2(animSet.frameSize.x, animSet.frameSize.y),
    renderScale: renderScale,
    respectFacing: false,
  );
}

class PickupRenderEntry {
  PickupRenderEntry({
    required this.variant,
    required this.renderScale,
    this.oneShotKeys = const <AnimKey>{},
    this.loader = loadAnimSetFromDefinition,
    this.viewFactory = _defaultPickupViewFactory,
  });

  final int variant;
  final Vector2 renderScale;
  final Set<AnimKey> oneShotKeys;
  final PickupAnimLoader loader;
  final PickupViewFactory viewFactory;

  SpriteAnimSet? _animSet;

  bool get isLoaded => _animSet != null;

  SpriteAnimSet get animSet {
    final value = _animSet;
    if (value == null) {
      throw StateError('PickupRenderEntry($variant) has not been loaded yet.');
    }
    return value;
  }

  Future<void> load(
    Images images, {
    required RenderAnimSetDefinition renderAnim,
  }) async {
    _animSet = await loader(
      images,
      renderAnim: renderAnim,
      oneShotKeys: oneShotKeys,
    );
  }
}

/// Render registry for pickups (PickupVariant -> render wiring).
class PickupRenderRegistry {
  PickupRenderRegistry({
    PickupRenderCatalog catalog = const PickupRenderCatalog(),
  }) : _catalog = catalog;

  final PickupRenderCatalog _catalog;

  // 16px art scaled to match Core collider sizes.
  static final Vector2 _collectibleScale = Vector2.all(1.0);
  static final Vector2 _restorationScale = Vector2.all(1.0);

  final Map<int, PickupRenderEntry> _entries = <int, PickupRenderEntry>{
    // Collectible coin.
    PickupVariant.collectible: PickupRenderEntry(
      variant: PickupVariant.collectible,
      renderScale: _collectibleScale,
    ),
    // Restoration gems.
    PickupVariant.restorationHealth: PickupRenderEntry(
      variant: PickupVariant.restorationHealth,
      renderScale: _restorationScale,
    ),
    PickupVariant.restorationMana: PickupRenderEntry(
      variant: PickupVariant.restorationMana,
      renderScale: _restorationScale,
    ),
    PickupVariant.restorationStamina: PickupRenderEntry(
      variant: PickupVariant.restorationStamina,
      renderScale: _restorationScale,
    ),
  };

  PickupRenderEntry entryForVariant(int variant) {
    final entry = _entries[variant];
    if (entry == null) {
      throw StateError(
        'No pickup render entry registered for variant=$variant.',
      );
    }
    return entry;
  }

  Future<void> load(Images images) async {
    for (final entry in _entries.values) {
      final renderAnim = _catalog.get(entry.variant);
      await entry.load(images, renderAnim: renderAnim);
    }
  }
}


===== FILE: lib/game/components/pixel_parallax_backdrop_component.dart =====
// Renders a multi-layer parallax background for pixel-art games.
//
// Each layer scrolls at a fraction of the camera movement (controlled by
// `parallaxFactor`), creating depth. Layers are rendered in order, so
// earlier layers appear behind later ones.
//
// The component uses a fixed "virtual" viewport size to maintain pixel-perfect
// rendering regardless of actual screen resolution. Images are tiled horizontally
// and bottom-aligned within the viewport.
import 'dart:ui' as ui;
import 'package:flame/components.dart';
import 'package:flame/game.dart';
import 'package:flutter/painting.dart';
import '../util/math_util.dart';

/// Renders a pixel-perfect, multi-layer parallax background.
///
/// Layers are defined via [PixelParallaxLayerSpec] and rendered back-to-front.
/// Each layer's scroll position is determined by its [PixelParallaxLayerSpec.parallaxFactor]:
/// - `0.0` = static (doesn't move with camera)
/// - `1.0` = moves 1:1 with camera (no parallax effect)
/// - Values between create the classic parallax depth illusion
class PixelParallaxBackdropComponent extends Component
    with HasGameReference<FlameGame> {
  PixelParallaxBackdropComponent({
    required this.virtualWidth,
    required this.virtualHeight,
    required this.layers,
    this.snapScrollToPixels = true,
  });

  /// Width of the virtual viewport in pixels.
  final int virtualWidth;

  /// Height of the virtual viewport in pixels.
  final int virtualHeight;

  /// Layer specifications, rendered in order (index 0 = backmost).
  final List<PixelParallaxLayerSpec> layers;

  /// If true, scroll offsets are rounded to whole pixels for crisp rendering.
  final bool snapScrollToPixels;

  /// Loaded images for each layer (parallel to [layers]).
  late final List<ui.Image> _images;

  /// Previous frame's camera X position (for delta calculation).
  double? _prevCameraLeftX;

  /// Accumulated scroll offset for each layer (in pixels).
  late final List<double> _scroll;

  /// Paint configured for nearest-neighbor (pixel-perfect) filtering.
  final Paint _paint = Paint()..filterQuality = FilterQuality.none;

  @override
  Future<void> onLoad() async {
    await super.onLoad();
    _images = await Future.wait(
      layers.map((layer) => game.images.load(layer.assetPath)),
    );
    _scroll = List<double>.filled(layers.length, 0);
  }

  /// Updates scroll offsets based on camera movement.
  ///
  /// Each layer's scroll is incremented by `cameraDelta * parallaxFactor`,
  /// then wrapped to avoid floating-point overflow on long play sessions.
  @override
  void update(double dt) {
    super.update(dt);

    final viewWidth = virtualWidth.toDouble();
    final camX = -game.camera.viewfinder.transform.offset.x;
    final cameraLeftX = camX - viewWidth * 0.5;

    final prev = _prevCameraLeftX;
    _prevCameraLeftX = cameraLeftX;
    if (prev == null) return; // First frame: just record position, skip scroll.

    final delta = cameraLeftX - prev;
    if (delta == 0) return; // No camera movement, nothing to update.

    for (var i = 0; i < layers.length; i++) {
      _scroll[i] += delta * layers[i].parallaxFactor;
      // Wrap scroll to [0, imageWidth) to prevent overflow.
      _scroll[i] = positiveModDouble(_scroll[i], _images[i].width.toDouble());
    }
  }

  /// Renders all parallax layers, back-to-front.
  ///
  /// Each layer is horizontally tiled and bottom-aligned within the virtual
  /// viewport. The viewport is clipped to prevent overdraw outside bounds.
  @override
  void render(ui.Canvas canvas) {
    super.render(canvas);

    final viewWidth = virtualWidth;
    final viewHeight = virtualHeight;

    canvas.save();
    canvas.clipRect(
      ui.Rect.fromLTWH(0, 0, viewWidth.toDouble(), viewHeight.toDouble()),
    );

    for (var i = 0; i < layers.length; i++) {
      final image = _images[i];

      final imageW = image.width;
      final imageH = image.height;
      final y = (viewHeight - imageH).toDouble(); // Bottom-aligned.

      // Optionally snap to whole pixels for crisp pixel-art rendering.
      final scroll = snapScrollToPixels
          ? roundToPixels(_scroll[i])
          : _scroll[i];
      final offsetPx = -scroll;
      final startX = positiveModDouble(offsetPx, imageW.toDouble());

      // Tile the image across the viewport width.
      for (var x = startX - imageW; x < viewWidth; x += imageW) {
        canvas.drawImage(image, ui.Offset(x, y), _paint);
      }
    }

    canvas.restore();
  }
}

/// Configuration for a single parallax layer.
class PixelParallaxLayerSpec {
  const PixelParallaxLayerSpec({
    required this.assetPath,
    required this.parallaxFactor,
  });

  /// Path to the layer image (relative to assets/images/).
  final String assetPath;

  /// How much this layer scrolls relative to camera movement.
  ///
  /// - `0.0`: Layer is static (sky, distant mountains).
  /// - `0.5`: Layer moves at half camera speed (mid-ground).
  /// - `1.0`: Layer moves 1:1 with camera (no parallax, foreground).
  final double parallaxFactor;
}


===== FILE: lib/game/components/player/player_animations.dart =====
/// Player animation loading utilities (render layer only).
///
/// Loads horizontal sprite-strip animations from `assets/images/entities/player/`.
library;

import 'package:flame/cache.dart';

import '../../../core/contracts/render_anim_set_definition.dart';
import '../../../core/snapshots/enums.dart';
import '../sprite_anim/sprite_anim_set.dart';
import '../sprite_anim/strip_animation_loader.dart';

Future<SpriteAnimSet> loadPlayerAnimations(
  Images images, {
  required RenderAnimSetDefinition renderAnim,
}) async {
  final oneShotKeys = <AnimKey>{
    AnimKey.strike,
    AnimKey.backStrike,
    AnimKey.cast,
    AnimKey.ranged,
    AnimKey.dash,
    AnimKey.hit,
    AnimKey.death,
  };
  return loadAnimSetFromDefinition(
    images,
    renderAnim: renderAnim,
    oneShotKeys: oneShotKeys,
  );
}


===== FILE: lib/game/components/player/player_view_component.dart =====
/// Player render component driven purely by Core snapshots.
library;

import 'package:flame/components.dart';

import '../../../core/snapshots/enums.dart';
import '../sprite_anim/deterministic_anim_view_component.dart';
import '../sprite_anim/sprite_anim_set.dart';

class PlayerViewComponent extends DeterministicAnimViewComponent {
  PlayerViewComponent({
    required SpriteAnimSet animationSet,
    Vector2? renderSize,
    Vector2? renderScale,
  }) : super(
         animSet: animationSet,
         initial: AnimKey.idle,
         renderSize: renderSize ??
             Vector2(animationSet.frameSize.x, animationSet.frameSize.y),
         renderScale: renderScale,
         fallbackResolver: (desired) {
           // Allow directional variants to fall back to their base animation key.
           if (desired == AnimKey.backStrike &&
               !animationSet.animations.containsKey(AnimKey.backStrike) &&
               animationSet.animations.containsKey(AnimKey.strike)) {
             return AnimKey.strike;
           }
           if (desired == AnimKey.ranged &&
               !animationSet.animations.containsKey(AnimKey.ranged) &&
               animationSet.animations.containsKey(AnimKey.cast)) {
             return AnimKey.cast;
           }
           return desired;
         },
       );
}


===== FILE: lib/game/components/projectiles/projectile_render_registry.dart =====
/// Projectile render registry and loaders (render layer only).
library;

import 'dart:math';

import 'package:flame/cache.dart';
import 'package:flame/components.dart';

import '../../../core/contracts/render_anim_set_definition.dart';
import '../../../core/projectiles/projectile_id.dart';
import '../../../core/projectiles/projectile_render_catalog.dart';
import '../../../core/snapshots/enums.dart';
import '../sprite_anim/deterministic_anim_view_component.dart';
import '../sprite_anim/sprite_anim_set.dart';
import '../sprite_anim/strip_animation_loader.dart';

typedef ProjectileAnimLoader =
    Future<SpriteAnimSet> Function(
      Images images, {
      required RenderAnimSetDefinition renderAnim,
      required Set<AnimKey> oneShotKeys,
    });

typedef ProjectileViewFactory =
    DeterministicAnimViewComponent Function(
      SpriteAnimSet animSet,
      Vector2 renderScale,
    );

const Set<AnimKey> _defaultProjectileOneShotKeys = <AnimKey>{
  AnimKey.spawn,
  AnimKey.hit,
};

DeterministicAnimViewComponent _defaultProjectileViewFactory(
  SpriteAnimSet animSet,
  Vector2 renderScale,
) {
  return DeterministicAnimViewComponent(
    animSet: animSet,
    renderSize: Vector2(animSet.frameSize.x, animSet.frameSize.y),
    renderScale: renderScale,
    respectFacing: false,
  );
}

class ProjectileRenderEntry {
  ProjectileRenderEntry({
    required this.id,
    required this.renderScale,
    this.oneShotKeys = _defaultProjectileOneShotKeys,
    this.loader = loadAnimSetFromDefinition,
    this.viewFactory = _defaultProjectileViewFactory,
    this.spinSpeedRadPerSecond = 0.0,
  });

  final ProjectileId id;
  final Vector2 renderScale;
  final Set<AnimKey> oneShotKeys;
  final ProjectileAnimLoader loader;
  final ProjectileViewFactory viewFactory;
  final double spinSpeedRadPerSecond;

  SpriteAnimSet? _animSet;
  bool _hasAssets = true;
  final Map<int, int> _spawnAnimTicksCache = <int, int>{};

  bool get hasAssets => _hasAssets;

  bool get isLoaded => _animSet != null;

  bool get isRenderable => _hasAssets && _animSet != null;

  SpriteAnimSet get animSet {
    final value = _animSet;
    if (value == null) {
      throw StateError('ProjectileRenderEntry($id) has not been loaded yet.');
    }
    return value;
  }

  int spawnAnimTicks(int tickHz) {
    final cached = _spawnAnimTicksCache[tickHz];
    if (cached != null) return cached;

    final set = _animSet;
    if (set == null) return 0;
    final anim = set.animations[AnimKey.spawn];
    if (anim == null) return 0;
    final frameCount = anim.frames.length;
    if (frameCount <= 1) return 0;

    final ticksPerFrame = set.ticksPerFrameFor(AnimKey.spawn, tickHz);
    final totalTicks = ticksPerFrame * frameCount;
    _spawnAnimTicksCache[tickHz] = totalTicks;
    return totalTicks;
  }

  Future<void> load(
    Images images, {
    required RenderAnimSetDefinition renderAnim,
  }) async {
    final idlePath = renderAnim.sourcesByKey[AnimKey.idle];
    if (idlePath == null || idlePath.trim().isEmpty) {
      _hasAssets = false;
      _animSet = null;
      return;
    }
    _animSet = await loader(
      images,
      renderAnim: renderAnim,
      oneShotKeys: oneShotKeys,
    );
  }
}

/// Render registry for projectiles (ProjectileId -> render wiring).
class ProjectileRenderRegistry {
  ProjectileRenderRegistry({
    ProjectileRenderCatalog projectileCatalog = const ProjectileRenderCatalog(),
  }) : _projectileCatalog = projectileCatalog;

  final ProjectileRenderCatalog _projectileCatalog;

  static const double _throwingAxeSpinRps = 6.0;
  static const double _throwingKnifeSpinRps = 7.0;

  final Map<ProjectileId, ProjectileRenderEntry> _entries =
      <ProjectileId, ProjectileRenderEntry>{
        ProjectileId.iceBolt: ProjectileRenderEntry(
          id: ProjectileId.iceBolt,
          renderScale: Vector2.all(1.0),
        ),
        ProjectileId.thunderBolt: ProjectileRenderEntry(
          id: ProjectileId.thunderBolt,
          renderScale: Vector2.all(1.0),
        ),
        ProjectileId.fireBolt: ProjectileRenderEntry(
          id: ProjectileId.fireBolt,
          renderScale: Vector2.all(1.0),
        ),
        ProjectileId.throwingAxe: ProjectileRenderEntry(
          id: ProjectileId.throwingAxe,
          renderScale: Vector2.all(1.0),
          spinSpeedRadPerSecond: _throwingAxeSpinRps * 2.0 * pi,
        ),
        ProjectileId.throwingKnife: ProjectileRenderEntry(
          id: ProjectileId.throwingKnife,
          renderScale: Vector2.all(1.0),
          spinSpeedRadPerSecond: _throwingKnifeSpinRps * 2.0 * pi,
        ),
      };

  ProjectileRenderEntry? entryFor(ProjectileId id) {
    final entry = _entries[id];
    if (entry == null || !entry.isRenderable) return null;
    return entry;
  }

  Future<void> load(Images images) async {
    for (final entry in _entries.values) {
      final renderAnim = _projectileCatalog.get(entry.id);
      await entry.load(images, renderAnim: renderAnim);
    }
  }
}


===== FILE: lib/game/components/sprite_anim/deterministic_anim_view_component.dart =====
/// Generic deterministic sprite animation component driven by Core snapshots.
library;

import 'package:flame/components.dart';
import 'package:flutter/widgets.dart';

import '../../../core/snapshots/entity_render_snapshot.dart';
import '../../../core/snapshots/enums.dart';
import 'sprite_anim_set.dart';
import '../../util/math_util.dart' as math;

typedef AnimKeyFallbackResolver = AnimKey Function(AnimKey desired);

class DeterministicAnimViewComponent
    extends SpriteAnimationGroupComponent<AnimKey> {
  DeterministicAnimViewComponent({
    required SpriteAnimSet animSet,
    AnimKey initial = AnimKey.idle,
    AnimKeyFallbackResolver? fallbackResolver,
    Vector2? renderSize,
    Vector2? renderScale,
    bool respectFacing = true,
  }) : _animSet = animSet,
       _availableAnimations = animSet.animations,
       _oneShotKeys = animSet.oneShotKeys,
       _fallbackResolver = fallbackResolver,
       _baseScale = renderScale?.clone() ?? Vector2.all(1.0),
       _respectFacing = respectFacing,
       super(
         animations: animSet.animations,
         current: initial,
         size: renderSize ?? Vector2(animSet.frameSize.x, animSet.frameSize.y),
         scale: renderScale?.clone() ?? Vector2.all(1.0),
         anchor: animSet.anchor,
         paint: Paint()..filterQuality = FilterQuality.none,
       ) {
    // We drive animation frames deterministically from `EntityRenderSnapshot.animFrame`.
    playing = false;
  }

  final SpriteAnimSet _animSet;
  final Map<AnimKey, SpriteAnimation> _availableAnimations;
  final Set<AnimKey> _oneShotKeys;
  final AnimKeyFallbackResolver? _fallbackResolver;
  final Vector2 _baseScale;
  final bool _respectFacing;

  void applySnapshot(
    EntityRenderSnapshot e, {
    required int tickHz,
    Vector2? pos,
    AnimKey? overrideAnim,
    int? overrideAnimFrame,
  }) {
    if (pos != null) {
      position.setFrom(pos);
    } else {
      position.setValues(
        math.roundToPixels(e.pos.x),
        math.roundToPixels(e.pos.y),
      );
    }

    var next = overrideAnim ?? e.anim;
    if (_fallbackResolver != null) {
      next = _fallbackResolver(next);
    }
    if (!_availableAnimations.containsKey(next)) {
      next = AnimKey.idle;
    }
    if (current != next) {
      current = next;
    }

    if (_respectFacing) {
      final artFacing = e.artFacingDir ?? Facing.right;
      final sign = e.facing == artFacing ? 1.0 : -1.0;
      final desiredScaleX = _baseScale.x * sign;
      if (scale.x != desiredScaleX || scale.y != _baseScale.y) {
        scale.setValues(desiredScaleX, _baseScale.y);
      }
    } else if (scale.x != _baseScale.x || scale.y != _baseScale.y) {
      scale.setValues(_baseScale.x, _baseScale.y);
    }

    final frameHint = overrideAnimFrame ?? e.animFrame;
    if (frameHint == null) return;

    final ticker = animationTicker;
    final anim = animation;
    if (ticker == null || anim == null) return;

    final framesLen = anim.frames.length;
    if (framesLen <= 1) return;

    final currentKey = current ?? AnimKey.idle;
    final ticksPerFrame = _animSet.ticksPerFrameFor(currentKey, tickHz);
    final rawIndex = frameHint ~/ ticksPerFrame;
    final index = _oneShotKeys.contains(currentKey)
        ? rawIndex.clamp(0, framesLen - 1).toInt()
        : rawIndex % framesLen;
    ticker.currentIndex = index;
  }
}


===== FILE: lib/game/components/sprite_anim/sprite_anim_set.dart =====
/// Shared render-side sprite animation bundle.
library;

import 'dart:math';

import 'package:flame/components.dart';

import '../../../core/snapshots/enums.dart';

class SpriteAnimSet {
  SpriteAnimSet({
    required this.animations,
    required this.stepTimeSecondsByKey,
    required this.oneShotKeys,
    required this.frameSize,
    this.anchor = Anchor.center,
  });

  final Map<AnimKey, SpriteAnimation> animations;
  final Map<AnimKey, double> stepTimeSecondsByKey;
  final Set<AnimKey> oneShotKeys;

  /// Source frame size inside each horizontal strip image.
  final Vector2 frameSize;

  /// Anchor used by view components when rendering this animation set.
  ///
  /// Defaults to `Anchor.center`.
  final Anchor anchor;

  final Map<int, Map<AnimKey, int>> _ticksPerFrameCache =
      <int, Map<AnimKey, int>>{};

  int ticksPerFrameFor(AnimKey key, int tickHz) {
    final cache = _ticksPerFrameCache.putIfAbsent(
      tickHz,
      () => <AnimKey, int>{},
    );
    final existing = cache[key];
    if (existing != null) return existing;

    final stepSeconds =
        stepTimeSecondsByKey[key] ?? stepTimeSecondsByKey[AnimKey.idle] ?? 0.10;
    final ticks = max(1, (stepSeconds * tickHz).round());
    cache[key] = ticks;
    return ticks;
  }
}


===== FILE: lib/game/components/sprite_anim/strip_animation_loader.dart =====
/// Shared sprite-strip animation loader utilities (render layer only).
library;

import 'dart:ui';

import 'package:flame/cache.dart';
import 'package:flame/components.dart';

import '../../../core/contracts/render_anim_set_definition.dart';
import '../../../core/snapshots/enums.dart';
import '../../../core/util/vec2.dart';
import 'sprite_anim_set.dart';

Future<SpriteAnimSet> loadStripAnimations(
  Images images, {
  required int frameWidth,
  required int frameHeight,
  required Map<AnimKey, String> sourcesByKey,
  Map<AnimKey, int> rowByKey = const <AnimKey, int>{},
  Vec2? anchorInFramePx,
  Map<AnimKey, int> frameStartByKey = const <AnimKey, int>{},
  required Map<AnimKey, int> frameCountsByKey,
  required Map<AnimKey, double> stepTimeSecondsByKey,
  required Set<AnimKey> oneShotKeys,
}) async {
  final frameSize = Vector2(frameWidth.toDouble(), frameHeight.toDouble());

  final anchor = switch (anchorInFramePx) {
    null => Anchor.center,
    final a => () {
      assert(
        a.x >= 0 && a.x <= frameWidth,
        'anchorInFramePx.x must be in [0, $frameWidth] (got ${a.x}).',
      );
      assert(
        a.y >= 0 && a.y <= frameHeight,
        'anchorInFramePx.y must be in [0, $frameHeight] (got ${a.y}).',
      );
      return Anchor(a.x / frameWidth, a.y / frameHeight);
    }(),
  };

  final keysByPath = <String, List<AnimKey>>{};
  for (final entry in sourcesByKey.entries) {
    keysByPath.putIfAbsent(entry.value, () => <AnimKey>[]).add(entry.key);
  }

  // Load each unique path once (Images also caches globally, but this keeps the
  // loader itself allocation-light and predictable).
  final imagesByPath = <String, Image>{};
  for (final path in keysByPath.keys) {
    imagesByPath[path] = await images.load(path);
  }

  final animations = <AnimKey, SpriteAnimation>{};
  for (final entry in sourcesByKey.entries) {
    final key = entry.key;
    final path = entry.value;
    final img = imagesByPath[path]!;

    final stepTime =
        stepTimeSecondsByKey[key] ?? stepTimeSecondsByKey[AnimKey.idle] ?? 0.1;
    final frameCount =
        frameCountsByKey[key] ?? frameCountsByKey[AnimKey.idle] ?? 1;
    final row = rowByKey[key] ?? 0;
    final startFrame = frameStartByKey[key] ?? 0;

    assert(
      startFrame >= 0,
      'frameStartByKey[$key] must be >= 0 (got $startFrame).',
    );

    final sprites = List<Sprite>.generate(frameCount, (i) {
      return Sprite(
        img,
        srcPosition: Vector2(
          frameWidth.toDouble() * (startFrame + i),
          frameHeight.toDouble() * row,
        ),
        srcSize: frameSize,
      );
    });

    animations[key] = SpriteAnimation.spriteList(
      sprites,
      stepTime: stepTime,
      loop: !oneShotKeys.contains(key),
    );
  }

  return SpriteAnimSet(
    animations: animations,
    stepTimeSecondsByKey: stepTimeSecondsByKey,
    oneShotKeys: oneShotKeys,
    frameSize: frameSize,
    anchor: anchor,
  );
}

Future<SpriteAnimSet> loadAnimSetFromDefinition(
  Images images, {
  required RenderAnimSetDefinition renderAnim,
  required Set<AnimKey> oneShotKeys,
}) async {
  final animSet = await loadStripAnimations(
    images,
    frameWidth: renderAnim.frameWidth,
    frameHeight: renderAnim.frameHeight,
    sourcesByKey: renderAnim.sourcesByKey,
    rowByKey: renderAnim.rowByKey,
    anchorInFramePx: renderAnim.anchorInFramePx,
    frameStartByKey: renderAnim.frameStartByKey,
    frameCountsByKey: renderAnim.frameCountsByKey,
    stepTimeSecondsByKey: renderAnim.stepTimeSecondsByKey,
    oneShotKeys: oneShotKeys,
  );

  // Default spawn to idle when no dedicated strip exists.
  animSet.animations[AnimKey.spawn] ??= animSet.animations[AnimKey.idle]!;

  return animSet;
}


===== FILE: lib/game/components/tiled_ground_band_component.dart =====
// Renders a horizontally-tiled ground band (e.g., grass, dirt, platforms).
//
// Supports two rendering modes:
// - **Backdrop mode** (`renderInBackdrop = true`): Renders in screen-space with
//   a fixed virtual viewport. Used for decorative ground in the parallax stack.
// - **World-space mode** (`renderInBackdrop = false`): Renders tiles in world
//   coordinates, following the camera. Used for gameplay-relevant ground.
//
// **Ground Gaps**: Both modes support "gaps" (holes in the ground) by using
// `BlendMode.clear` to punch transparent regions into the tile strip.
//
// **Performance Note**: When gaps are present, `canvas.saveLayer` is used to
// enable the clear blend mode. This incurs GPU overhead due to offscreen
// rasterization. Scenes with many gaps may see performance impact.
import 'dart:ui' as ui;

import 'package:flame/components.dart';
import 'package:flame/game.dart';
import 'package:flutter/painting.dart';

import '../../core/snapshots/static_ground_gap_snapshot.dart';
import '../game_controller.dart';
import '../util/math_util.dart';

/// Renders a horizontally-tiled ground band with optional gap support.
///
/// See file header for rendering mode details and performance considerations.
class TiledGroundBandComponent extends Component
    with HasGameReference<FlameGame> {
  TiledGroundBandComponent({
    required this.assetPath,
    required this.controller,
    this.virtualWidth,
    required this.virtualHeight,
    this.renderInBackdrop = false,
  }) {
    if (renderInBackdrop && virtualWidth == null) {
      throw ArgumentError(
        'virtualWidth is required when renderInBackdrop is true',
      );
    }
  }

  /// Path to the tile image asset (loaded via Flame's image cache).
  final String assetPath;

  /// Game controller providing snapshot data (including ground gaps).
  final GameController controller;

  /// Fixed viewport width for backdrop mode. Required when [renderInBackdrop] is true.
  final int? virtualWidth;

  /// Virtual viewport height; tiles are bottom-aligned to this value.
  final int virtualHeight;

  /// If true, render in screen-space (backdrop); otherwise, render in world-space.
  final bool renderInBackdrop;

  late final ui.Image _image;

  /// Paint with nearest-neighbor filtering for pixel-perfect rendering.
  final Paint _paint = Paint()..filterQuality = FilterQuality.none;

  /// Paint used to "punch holes" for ground gaps.
  final Paint _clearPaint = Paint()..blendMode = ui.BlendMode.clear;

  @override
  Future<void> onLoad() async {
    await super.onLoad();
    _image = await game.images.load(assetPath);
  }

  @override
  void render(ui.Canvas canvas) {
    super.render(canvas);

    final gaps = controller.snapshot.groundGaps;
    final tileW = _image.width;
    final tileH = _image.height;
    final y = (virtualHeight - tileH).toDouble(); // bottom-aligned

    if (renderInBackdrop) {
      _renderBackdropMode(canvas, gaps, tileW, tileH, y);
    } else {
      _renderWorldMode(canvas, gaps, tileW, tileH, y);
    }
  }

  /// Renders tiles in screen-space (fixed virtual viewport).
  void _renderBackdropMode(
    ui.Canvas canvas,
    List<StaticGroundGapSnapshot> gaps,
    int tileW,
    int tileH,
    double y,
  ) {
    final viewWidth = virtualWidth!;
    final halfWidth = viewWidth * 0.5;
    final camX = -game.camera.viewfinder.transform.offset.x;
    final leftWorld = camX - halfWidth;
    final rightWorld = camX + halfWidth;

    double worldToScreenX(double worldX) =>
        roundToPixels(worldX - camX) + halfWidth;

    final startTile = floorDivInt(leftWorld.floor(), tileW) - 1;
    final endTile = floorDivInt(rightWorld.ceil(), tileW) + 1;
    final clipRect = ui.Rect.fromLTWH(
      0,
      0,
      viewWidth.toDouble(),
      virtualHeight.toDouble(),
    );

    _withGapSupport(canvas, clipRect, gaps.isNotEmpty, () {
      for (var tile = startTile; tile <= endTile; tile++) {
        final worldX = (tile * tileW).toDouble();
        final x = worldToScreenX(worldX);
        canvas.drawImage(_image, ui.Offset(x, y), _paint);
      }

      if (gaps.isNotEmpty) {
        final maxX = viewWidth.toDouble();
        for (final gap in gaps) {
          final x0 = worldToScreenX(gap.minX);
          final x1 = worldToScreenX(gap.maxX);
          if (x1 < 0.0 || x0 > maxX) continue;
          if (x1 <= x0) continue;
          canvas.drawRect(ui.Rect.fromLTRB(x0, y, x1, y + tileH), _clearPaint);
        }
      }
    });
  }

  /// Renders tiles in world-space (following camera).
  void _renderWorldMode(
    ui.Canvas canvas,
    List<StaticGroundGapSnapshot> gaps,
    int tileW,
    int tileH,
    double y,
  ) {
    final visible = game.camera.visibleWorldRect;
    final camX = -game.camera.viewfinder.transform.offset.x;
    final left = visible.left.floor();
    final right = visible.right.ceil();

    final startTile = floorDivInt(left, tileW) - 1;
    final endTile = floorDivInt(right, tileW) + 1;

    final clipRect = ui.Rect.fromLTRB(
      visible.left,
      0,
      visible.right,
      virtualHeight.toDouble(),
    );

    _withGapSupport(canvas, clipRect, gaps.isNotEmpty, () {
      for (var tile = startTile; tile <= endTile; tile++) {
        final x = (tile * tileW).toDouble();
        final snappedX = snapWorldToPixelsInCameraSpace1d(x, camX);
        canvas.drawImage(_image, ui.Offset(snappedX, y), _paint);
      }

      if (gaps.isNotEmpty) {
        _clearGapRects(
          canvas,
          gaps: gaps,
          offsetX: 0.0,
          visibleMinX: visible.left,
          visibleMaxX: visible.right,
          y: y,
          height: tileH.toDouble(),
          snapRelativeToCameraX: camX,
        );
      }
    });
  }

  /// Wraps rendering in saveLayer (if gaps exist) or save, then restores.
  ///
  /// When [hasGaps] is true, uses `saveLayer` to enable `BlendMode.clear`.
  /// This has GPU overhead but is necessary for punching transparent holes.
  void _withGapSupport(
    ui.Canvas canvas,
    ui.Rect clipRect,
    bool hasGaps,
    void Function() drawCallback,
  ) {
    if (hasGaps) {
      canvas.saveLayer(clipRect, Paint());
    } else {
      canvas.save();
    }
    canvas.clipRect(clipRect);

    drawCallback();

    canvas.restore();
  }

  /// Punches transparent holes in the tile strip for each gap.
  ///
  /// Uses [_clearPaint] with `BlendMode.clear` to erase pixels. Only draws
  /// gaps that intersect the visible range `[visibleMinX, visibleMaxX]`.
  void _clearGapRects(
    ui.Canvas canvas, {
    required List<StaticGroundGapSnapshot> gaps,
    required double offsetX,
    required double visibleMinX,
    required double visibleMaxX,
    required double y,
    required double height,
    double? snapRelativeToCameraX,
  }) {
    for (final gap in gaps) {
      var x0 = gap.minX + offsetX;
      var x1 = gap.maxX + offsetX;
      if (snapRelativeToCameraX != null) {
        x0 = snapWorldToPixelsInCameraSpace1d(x0, snapRelativeToCameraX);
        x1 = snapWorldToPixelsInCameraSpace1d(x1, snapRelativeToCameraX);
      }
      if (x1 < visibleMinX || x0 > visibleMaxX) continue;
      canvas.drawRect(ui.Rect.fromLTRB(x0, y, x1, y + height), _clearPaint);
    }
  }
}


===== FILE: lib/game/debug/debug_aabb_overlay.dart =====
/// Reusable helper for syncing AABB debug overlays from Core snapshots.
library;

import 'package:flame/components.dart';
import 'package:flutter/widgets.dart';

import '../../core/snapshots/entity_render_snapshot.dart';
import '../util/math_util.dart' as math;

void syncDebugAabbOverlays({
  required Iterable<EntityRenderSnapshot> entities,
  required bool enabled,
  required Component parent,
  required Map<int, RectangleComponent> pool,
  required int priority,
  required Paint paint,
  bool Function(EntityRenderSnapshot e)? include,
  Map<int, EntityRenderSnapshot>? prevById,
  double Function(EntityRenderSnapshot e)? offsetXFor,
  double Function(EntityRenderSnapshot e)? offsetYFor,
  double alpha = 1.0,
  Vector2? cameraCenter,
}) {
  if (!enabled) {
    if (pool.isEmpty) return;
    for (final view in pool.values) {
      view.removeFromParent();
    }
    pool.clear();
    return;
  }

  final seen = <int>{};

  for (final e in entities) {
    if (include != null && !include(e)) continue;
    final size = e.size;
    if (size == null) continue;

    seen.add(e.id);

    var view = pool[e.id];
    if (view == null) {
      view = RectangleComponent(
        size: Vector2(size.x, size.y),
        anchor: Anchor.center,
        paint: paint,
      )..priority = priority;
      pool[e.id] = view;
      parent.add(view);
    } else {
      view.size.setValues(size.x, size.y);
    }

    final prev = prevById == null ? null : prevById[e.id];
    final prevPos = prev?.pos ?? e.pos;
    final prevOffsetX = offsetXFor?.call(prev ?? e) ?? 0.0;
    final prevOffsetY = offsetYFor?.call(prev ?? e) ?? 0.0;
    final offsetX = offsetXFor?.call(e) ?? 0.0;
    final offsetY = offsetYFor?.call(e) ?? 0.0;
    final worldX = math.lerpDouble(
      prevPos.x + prevOffsetX,
      e.pos.x + offsetX,
      alpha,
    );
    final worldY = math.lerpDouble(
      prevPos.y + prevOffsetY,
      e.pos.y + offsetY,
      alpha,
    );
    if (cameraCenter == null) {
      view.position.setValues(
        math.roundToPixels(worldX),
        math.roundToPixels(worldY),
      );
    } else {
      view.position.setValues(
        math.snapWorldToPixelsInCameraSpace1d(worldX, cameraCenter.x),
        math.snapWorldToPixelsInCameraSpace1d(worldY, cameraCenter.y),
      );
    }
  }

  if (pool.isEmpty) return;
  final toRemove = <int>[];
  for (final id in pool.keys) {
    if (!seen.contains(id)) toRemove.add(id);
  }
  for (final id in toRemove) {
    pool.remove(id)?.removeFromParent();
  }
}


===== FILE: lib/game/debug/render_debug_flags.dart =====
/// Render-layer debug flags.
///
/// Kept in `lib/game/**` so Core remains pure/deterministic and unaware of
/// any debug drawing concerns.
library;

import 'package:flutter/foundation.dart';

abstract class RenderDebugFlags {
  /// Draws collision AABB overlays for "actor" entities (player + enemies).
  ///
  /// Default is `false` even in debug builds; toggle locally when needed.
  static bool drawActorHitboxes = false;

  /// Convenience for enabling all render debug overlays in debug/profile
  /// builds while keeping release builds clean.
  static bool get canUseRenderDebug => !kReleaseMode;
}



===== FILE: lib/game/game_controller.dart =====
// Bridge between Core simulation and the Flutter/Flame runtime.
//
// Responsibilities:
// - Owns the `GameCore` instance
// - Queues tick-stamped input commands
// - Runs a fixed-tick simulation loop using an accumulator
// - Exposes (`prevSnapshot`, `snapshot`, `alpha`) for render interpolation
// - Buffers transient `GameEvent`s for Render/UI to consume
import 'dart:math';

import 'package:flutter/foundation.dart';

import '../core/commands/command.dart';
import '../core/enemies/enemy_catalog.dart';
import '../core/events/game_event.dart';
import '../core/game_core.dart';
import '../core/snapshots/game_state_snapshot.dart';
import '../core/tuning/score_tuning.dart';
import 'tick_input_frame.dart';

typedef GameEventListener = void Function(GameEvent event);

/// Owns the simulation clock and provides a stable interface to UI/renderer.
class GameController extends ChangeNotifier {
  GameController({required GameCore core, this.tickHz = 60, this.inputLead = 1})
    : _core = core {
    if (tickHz <= 0) {
      throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
    }
    if (inputLead < 1) {
      throw ArgumentError.value(inputLead, 'inputLead', 'must be >= 1');
    }
    if (tickHz != _core.tickHz) {
      throw ArgumentError(
        'GameController.tickHz ($tickHz) must match GameCore.tickHz (${_core.tickHz}).',
      );
    }
    _curr = _core.buildSnapshot();
    _prev = _curr;
  }

  final GameCore _core;

  /// Fixed simulation tick frequency.
  final int tickHz;

  /// How many ticks ahead local input is scheduled by default.
  ///
  /// `1` means "next tick".
  final int inputLead;

  /// Buffered commands keyed by their target tick.
  final Map<int, TickInputFrame> _inputsByTick = <int, TickInputFrame>{};

  /// Scratch buffer for building command lists without allocation.
  final List<Command> _commandScratch = <Command>[];

  /// Fallback input frame for ticks with no buffered commands.
  final TickInputFrame _frameScratch = TickInputFrame();

  /// Buffered transient events produced by the core.
  final List<GameEvent> _events = <GameEvent>[];

  /// Optional event listeners (render/UI side-effects).
  ///
  /// Listeners are invoked for every event emitted by Core, before events are
  /// buffered into [_events].
  final List<GameEventListener> _eventListeners = <GameEventListener>[];

  /// The most recent [RunEndedEvent], if any.
  ///
  /// Stored separately so UI can access it after events are drained.
  RunEndedEvent? lastRunEndedEvent;

  late GameStateSnapshot _prev;
  late GameStateSnapshot _curr;

  /// Accumulated time for fixed-tick simulation.
  double _accumulatorSeconds = 0;

  /// Current simulation tick (authoritative).
  int get tick => _core.tick;

  ScoreTuning get scoreTuning => _core.scoreTuning;

  EnemyCatalog get enemyCatalog => _core.enemyCatalog;

  /// Latest snapshot produced by the core.
  GameStateSnapshot get snapshot => _curr;

  /// Previous snapshot (used for render interpolation).
  GameStateSnapshot get prevSnapshot => _prev;

  /// Interpolation factor between `prevSnapshot` and `snapshot` for rendering.
  double get alpha {
    final dtTick = 1.0 / tickHz;
    return (_accumulatorSeconds / dtTick).clamp(0, 1);
  }

  /// Enqueues a command to be applied at its declared tick.
  void enqueue(Command command) {
    final frame = _inputsByTick.putIfAbsent(
      command.tick,
      () => TickInputFrame(),
    );
    frame.apply(command);
  }

  /// Helper to schedule a command for the next tick (plus `inputLead`).
  void enqueueForNextTick(Command Function(int tick) factory) {
    enqueue(factory(tick + inputLead));
  }

  /// Drains and clears all buffered transient events.
  List<GameEvent> drainEvents() {
    if (_events.isEmpty) return const <GameEvent>[];
    final drained = List<GameEvent>.unmodifiable(_events);
    _events.clear();
    return drained;
  }

  /// Registers a callback to observe transient [GameEvent]s.
  ///
  /// This is useful for render-only effects (e.g. death animations) that should
  /// not require draining the shared event buffer.
  void addEventListener(GameEventListener listener) {
    if (_eventListeners.contains(listener)) return;
    _eventListeners.add(listener);
  }

  void removeEventListener(GameEventListener listener) {
    _eventListeners.remove(listener);
  }

  /// Pauses/unpauses the simulation.
  void setPaused(bool value) {
    if (_core.paused == value) return;
    _core.paused = value;
    _accumulatorSeconds = 0;
    _prev = _core.buildSnapshot();
    _curr = _prev;
    notifyListeners();
  }

  /// Permanently stops this controller for the current session.
  ///
  /// Use this when leaving the mini-game route (dispose), NOT for backgrounding
  /// (that's what [setPaused] is for).
  ///
  /// What it does:
  /// - pauses the core
  /// - clears queued commands (prevents "stuck input" on next mount)
  /// - clears buffered transient events
  /// - resets interpolation state (accumulator + snapshots)
  void shutdown() {
    // Pause regardless of current state (do NOT early-return like setPaused()).
    _core.paused = true;

    // Drop any in-flight fixed-tick accumulation.
    _accumulatorSeconds = 0;

    // Kill transient buffers so nothing leaks across sessions.
    _inputsByTick.clear();
    _events.clear();

    // Make snapshots consistent with the paused state.
    _curr = _core.buildSnapshot();
    _prev = _curr;
    lastRunEndedEvent = null;
    notifyListeners();
  }

  /// Ends the current run early (player quit).
  ///
  /// Triggers a [RunEndedEvent] with the current score and resets interpolation.
  void giveUp() {
    if (_core.gameOver) return;
    _core.giveUp();
    _accumulatorSeconds = 0;

    _collectCoreEvents();

    _prev = _core.buildSnapshot();
    _curr = _prev;
    notifyListeners();
  }

  /// Advances the simulation clock based on a variable frame delta.
  ///
  /// This uses an accumulator to execute a fixed number of simulation ticks.
  /// [dtSeconds] is clamped to [dtFrameMaxSeconds] (default 100ms) to avoid
  /// "spiral of death" when the app resumes from background or after a lag spike.
  void advanceFrame(double dtSeconds, {double dtFrameMaxSeconds = 0.1}) {
    if (dtSeconds.isNaN || dtSeconds.isInfinite) return;
    if (_core.paused) {
      _accumulatorSeconds = 0;
      return;
    }

    final clamped = max(0.0, min(dtSeconds, dtFrameMaxSeconds));
    _accumulatorSeconds += clamped;

    final dtTick = 1.0 / tickHz;
    var didStep = false;

    while (_accumulatorSeconds >= dtTick) {
      if (_core.paused) {
        _accumulatorSeconds = 0;
        break;
      }
      final nextTick = _core.tick + 1;
      final input = _inputsByTick.remove(nextTick) ?? _frameScratch;
      _applyTickInput(nextTick, input);
      _core.stepOneTick();

      _collectCoreEvents();

      _prev = _curr;
      _curr = _core.buildSnapshot();
      _accumulatorSeconds -= dtTick;
      didStep = true;

      // If the core became paused during the tick (e.g. game over), stop consuming
      // accumulator to avoid an infinite loop.
      if (_core.paused) {
        _accumulatorSeconds = 0;
        break;
      }
    }
    if (didStep) {
      notifyListeners();
    }
  }

  /// Drains events from the core and buffers them for UI consumption.
  ///
  /// Also captures [RunEndedEvent] into [lastRunEndedEvent] for easy access.
  void _collectCoreEvents() {
    final newEvents = _core.drainEvents();
    for (final event in newEvents) {
      if (event is RunEndedEvent) {
        lastRunEndedEvent = event;
      }
      if (_eventListeners.isNotEmpty) {
        for (final listener in _eventListeners) {
          listener(event);
        }
      }
    }
    if (newEvents.isNotEmpty) {
      _events.addAll(newEvents);
    }
  }

  /// Converts a [TickInputFrame] into [Command]s and applies them to the core.
  ///
  /// Uses [_commandScratch] to avoid allocating a new list each tick.
  /// Only non-default values are sent (e.g., zero axis is skipped since the
  /// core treats absence of input as no movement).
  void _applyTickInput(int tick, TickInputFrame input) {
    _commandScratch.clear();

    final axis = input.moveAxis;
    if (axis != 0) {
      _commandScratch.add(MoveAxisCommand(tick: tick, axis: axis));
    }

    if (input.projectileAimDirSet) {
      _commandScratch.add(
        ProjectileAimDirCommand(
          tick: tick,
          x: input.projectileAimDirX,
          y: input.projectileAimDirY,
        ),
      );
    }
    if (input.meleeAimDirSet) {
      _commandScratch.add(
        MeleeAimDirCommand(
          tick: tick,
          x: input.meleeAimDirX,
          y: input.meleeAimDirY,
        ),
      );
    }
    if (input.jumpPressed) {
      _commandScratch.add(JumpPressedCommand(tick: tick));
    }
    if (input.dashPressed) {
      _commandScratch.add(DashPressedCommand(tick: tick));
    }
    if (input.strikePressed) {
      _commandScratch.add(StrikePressedCommand(tick: tick));
    }
    if (input.projectilePressed) {
      _commandScratch.add(ProjectilePressedCommand(tick: tick));
    }
    if (input.secondaryPressed) {
      _commandScratch.add(SecondaryPressedCommand(tick: tick));
    }
    if (input.bonusPressed) {
      _commandScratch.add(BonusPressedCommand(tick: tick));
    }

    _core.applyCommands(_commandScratch);

    // If this is a scratch fallback, it will be reset by the next use anyway.
    // For frames stored in the map we drop the instance after remove().
    input.reset();
  }
}


===== FILE: lib/game/input/aim_preview.dart =====
// Observable aim preview state for the UI layer.
//
// Provides reactive state so that UI widgets (e.g., aim indicators, arrows)
// can listen and update when the player begins aiming, moves the aim direction,
// or releases aim input. This decouples the input router from the rendering layer.
import 'package:flutter/foundation.dart';

/// Immutable snapshot of the current aim preview state.
///
/// - [active]: Whether the player is currently in aiming mode (e.g., touch held).
/// - [hasAim]: Whether a valid aim direction has been determined.
/// - [dirX], [dirY]: The normalized aim direction vector (only meaningful when [hasAim] is true).
class AimPreviewState {
  const AimPreviewState({
    required this.active,
    required this.hasAim,
    required this.dirX,
    required this.dirY,
  });

  /// True when the player is actively aiming (e.g., dragging on the cast button).
  final bool active;

  /// True when a valid direction has been established (drag exceeds dead zone).
  final bool hasAim;

  /// Horizontal component of the normalized aim direction.
  final double dirX;

  /// Vertical component of the normalized aim direction.
  final double dirY;

  /// Default state when the player is not aiming.
  static const AimPreviewState inactive = AimPreviewState(
    active: false,
    hasAim: false,
    dirX: 0,
    dirY: 0,
  );
}

/// Reactive model for aim preview state.
///
/// Extends [ValueNotifier] so UI widgets can listen for changes via
/// [ValueListenableBuilder] or similar patterns. The input layer updates this
/// model as the player interacts with aim controls, and the UI layer consumes
/// it to render visual feedback (e.g., directional arrow, aim reticle).
class AimPreviewModel extends ValueNotifier<AimPreviewState> {
  /// Creates an [AimPreviewModel] initialized to the inactive state.
  AimPreviewModel() : super(AimPreviewState.inactive);

  /// Called when the player starts an aiming gesture (e.g., touch down on cast button).
  ///
  /// Sets [active] to true but [hasAim] remains false until a direction is established.
  void begin() {
    value = const AimPreviewState(
      active: true,
      hasAim: false,
      dirX: 0,
      dirY: 0,
    );
  }

  /// Updates the aim direction during an active aiming gesture.
  ///
  /// [x] and [y] should be the normalized direction vector.
  /// Sets both [active] and [hasAim] to true.
  void updateAim(double x, double y) {
    value = AimPreviewState(active: true, hasAim: true, dirX: x, dirY: y);
  }

  /// Clears the aim direction while keeping the aiming gesture active.
  ///
  /// Used when the drag returns inside the dead zone—player is still touching
  /// but hasn't committed to a direction yet.
  void clearAim() {
    value = const AimPreviewState(
      active: true,
      hasAim: false,
      dirX: 0,
      dirY: 0,
    );
  }

  /// Called when the player ends the aiming gesture (e.g., touch up).
  ///
  /// Resets the model to the fully inactive state.
  void end() {
    value = AimPreviewState.inactive;
  }
}


===== FILE: lib/game/input/aim_quantizer.dart =====
// Utility for quantizing aim direction values.
//
// Quantization reduces floating-point precision to avoid scheduling redundant
// aim commands when the direction changes by negligible amounts. This improves
// determinism and reduces command spam in the input queue.

/// Quantizes aim direction components to a fixed precision.
///
/// By rounding to 1/256 increments, tiny floating-point variations (e.g., from
/// touch jitter) are collapsed into stable values. This ensures:
/// - Fewer redundant [ProjectileAimDirCommand] / [MeleeAimDirCommand] commands.
/// - Consistent behavior across frames when the aim direction is nearly unchanged.
class AimQuantizer {
  /// Private constructor to prevent instantiation; all methods are static.
  const AimQuantizer._();

  /// Quantization scale factor (256 levels per unit).
  ///
  /// Chosen to provide ~0.4% precision, which is imperceptible to players
  /// but sufficient to filter out floating-point noise.
  static const double _aimQuantizeScale = 256.0;

  /// Returns [value] rounded to the nearest 1/256 increment.
  ///
  /// Returns 0 unchanged to preserve exact zero (no aim bias).
  static double quantize(double value) {
    if (value == 0) return 0;
    return (value * _aimQuantizeScale).roundToDouble() / _aimQuantizeScale;
  }
}


===== FILE: lib/game/input/runner_input_router.dart =====
import 'dart:math';

import '../../core/commands/command.dart';
import '../game_controller.dart';
import 'aim_quantizer.dart';

/// Shared input scheduler for multiple input sources (touch + keyboard + mouse).
///
/// - Holds the current continuous inputs (move axis, projectile aim direction).
/// - Schedules them into the GameController for upcoming ticks so Core receives
///   tick-stamped Commands.
/// - Schedules edge-triggered presses (jump/dash/strike/projectile) for the next tick.
///
/// The router distinguishes between:
/// - **Continuous inputs** (movement axis, aim directions): held state is pumped
///   each frame via [pumpHeldInputs], scheduling commands for upcoming ticks.
/// - **Edge-triggered inputs** (jump, dash, strike, projectile): one-shot events
///   scheduled immediately for the next tick via [pressJump], [pressDash], etc.
class RunnerInputRouter {
  /// Creates a router bound to the given [controller].
  RunnerInputRouter({required this.controller});

  /// The game controller that receives scheduled commands.
  final GameController controller;

  /// Input buffering window in seconds.
  ///
  /// This determines how far ahead continuous inputs (move, aim) are scheduled
  /// to smooth over frame rate hitches.
  static const double _inputBufferSeconds = 0.1;

  // ─────────────────────────────────────────────────────────────────────────
  // Movement axis state
  // ─────────────────────────────────────────────────────────────────────────

  /// Current horizontal movement axis in [-1, 1]. Set by touch/keyboard input.
  double _moveAxis = 0;

  /// Last axis value that was scheduled, used to detect changes.
  double _lastScheduledAxis = 0;

  /// Highest tick for which axis commands have been enqueued.
  int _axisScheduledThroughTick = 0;

  // ─────────────────────────────────────────────────────────────────────────
  // Aim state channels
  // ─────────────────────────────────────────────────────────────────────────

  final _AimInputChannel _projectileAim = _AimInputChannel();

  final _AimInputChannel _meleeAim = _AimInputChannel();

  // ─────────────────────────────────────────────────────────────────────────
  // Public setters for continuous inputs
  // ─────────────────────────────────────────────────────────────────────────

  /// Sets the horizontal movement axis (clamped to [-1, 1]).
  ///
  /// Called by joystick or keyboard handlers. The value is held until changed
  /// and pumped to the controller each frame via [pumpHeldInputs].
  void setMoveAxis(double axis) {
    _moveAxis = axis.clamp(-1.0, 1.0);
  }

  /// Sets the projectile aim direction (should be normalized or near-normalized).
  ///
  /// The direction is quantized to reduce floating-point noise. If the quantized
  /// value matches the current aim, the call is a no-op to avoid redundant updates.
  void setProjectileAimDir(double x, double y) => _projectileAim.set(x, y);

  /// Clears the projectile aim direction.
  ///
  /// Called when the player releases the aim input. Subsequent [pumpHeldInputs]
  /// calls will schedule [ClearProjectileAimDirCommand] for upcoming ticks.
  void clearProjectileAimDir() => _projectileAim.clear();

  /// Sets the melee aim direction (should be normalized or near-normalized).
  ///
  /// Quantized similarly to [setProjectileAimDir] to reduce jitter.
  void setMeleeAimDir(double x, double y) => _meleeAim.set(x, y);

  /// Clears the melee aim direction.
  ///
  /// Called when the player releases the melee aim input.
  void clearMeleeAimDir() => _meleeAim.clear();

  // ─────────────────────────────────────────────────────────────────────────
  // Edge-triggered (one-shot) input methods
  // ─────────────────────────────────────────────────────────────────────────

  /// Schedules a jump press for the next tick.
  void pressJump() =>
      controller.enqueueForNextTick((tick) => JumpPressedCommand(tick: tick));

  /// Schedules a dash press for the next tick.
  void pressDash() =>
      controller.enqueueForNextTick((tick) => DashPressedCommand(tick: tick));

  /// Schedules a melee strike press for the next tick.
  void pressStrike() =>
      controller.enqueueForNextTick((tick) => StrikePressedCommand(tick: tick));

  /// Schedules a projectile slot press for the next tick.
  void pressProjectile() => controller.enqueueForNextTick(
        (tick) => ProjectilePressedCommand(tick: tick),
      );

  /// Schedules a secondary-slot press for the next tick.
  void pressSecondary() =>
      controller.enqueueForNextTick((tick) => SecondaryPressedCommand(tick: tick));

  /// Schedules a bonus-slot press for the next tick.
  void pressBonus() =>
      controller.enqueueForNextTick((tick) => BonusPressedCommand(tick: tick));

  // ─────────────────────────────────────────────────────────────────────────
  // Combined action methods (aim + action in a single tick)
  // ─────────────────────────────────────────────────────────────────────────

  /// Presses projectile on the next tick and ensures the projectile aim direction
  /// is set for the same tick.
  void pressProjectileWithAim() {
    commitProjectileWithAim(clearAim: false);
  }

  /// Commits projectile on the next tick using the current projectile aim dir (if set).
  ///
  /// When [clearAim] is true, clear commands are delayed until after the commit
  /// tick to avoid overwriting the aimed shot.
  void commitProjectileWithAim({required bool clearAim}) {
    final tick = controller.tick + controller.inputLead;
    final hadAim = _projectileAim.isSet;
    if (hadAim) {
      controller.enqueue(
        ProjectileAimDirCommand(
          tick: tick,
          x: _projectileAim.x,
          y: _projectileAim.y,
        ),
      );
    }

    controller.enqueue(ProjectilePressedCommand(tick: tick));

    if (clearAim) {
      _projectileAim.clear();
      if (hadAim) {
        // Prevent immediate clear command from overwriting the aim we just committed
        _projectileAim.blockClearThrough(tick);
      }
    }
  }

  /// Commits the bonus ability while preserving the current aim direction.
  ///
  /// Bonus can host projectile or melee abilities; [usesMeleeAim] selects which
  /// aim channel is consumed by the equipped bonus ability.
  void commitBonusWithAim({
    required bool clearAim,
    required bool usesMeleeAim,
  }) {
    final tick = controller.tick + controller.inputLead;
    final channel = usesMeleeAim ? _meleeAim : _projectileAim;
    final hadAim = channel.isSet;

    if (hadAim) {
      controller.enqueue(
        usesMeleeAim
            ? MeleeAimDirCommand(tick: tick, x: channel.x, y: channel.y)
            : ProjectileAimDirCommand(tick: tick, x: channel.x, y: channel.y),
      );
    }

    controller.enqueue(BonusPressedCommand(tick: tick));

    if (clearAim) {
      channel.clear();
      if (hadAim) {
        // Prevent immediate clear command from overwriting the aim we just committed.
        channel.blockClearThrough(tick);
      }
    }
  }


  /// Commits a melee strike on the next tick using the current melee aim dir.
  void commitMeleeStrike() {
    final tick = controller.tick + controller.inputLead;
    final hadAim = _meleeAim.isSet;
    if (hadAim) {
      controller.enqueue(
        MeleeAimDirCommand(tick: tick, x: _meleeAim.x, y: _meleeAim.y),
      );
    } else {
      controller.enqueue(ClearMeleeAimDirCommand(tick: tick));
    }
    controller.enqueue(StrikePressedCommand(tick: tick));

    // Clear aim after commit (release behavior).
    _meleeAim.clear();
    if (hadAim) {
      _meleeAim.blockClearThrough(tick);
    }
  }

  // ─────────────────────────────────────────────────────────────────────────
  // Frame pump: schedule continuous inputs for upcoming ticks
  // ─────────────────────────────────────────────────────────────────────────

  /// Schedules the current held inputs across upcoming ticks.
  ///
  /// This method should be called once per frame, before `controller.advanceFrame(dt)`,
  /// to ensure that continuous inputs (movement, aim) are scheduled far enough
  /// ahead that the simulation always has input data available.
  ///
  /// The scheduling window extends `inputLead + maxTicksPerFrame` ticks into the
  /// future to handle variable frame rates without input starvation.
  void pumpHeldInputs() {
    // 1. Movement: enqueue MoveAxisCommand for upcoming ticks (or overwrite if axis changed).
    _scheduleHeldMoveAxis();

    // 2. Projectile aim: enqueue aim direction or clear commands for upcoming ticks.
    _projectileAim.schedule(
      controller,
      _inputBufferSeconds,
      (t, x, y) => ProjectileAimDirCommand(tick: t, x: x, y: y),
      (t) => ClearProjectileAimDirCommand(tick: t),
    );

    // 3. Melee aim: same pattern as projectile, but for melee strike direction.
    _meleeAim.schedule(
      controller,
      _inputBufferSeconds,
      (t, x, y) => MeleeAimDirCommand(tick: t, x: x, y: y),
      (t) => ClearMeleeAimDirCommand(tick: t),
    );

  }

  /// Schedules [MoveAxisCommand]s for upcoming ticks based on the current axis value.
  ///
  /// Detects axis changes and re-schedules to overwrite any already-buffered ticks.
  void _scheduleHeldMoveAxis() {
    final axis = _moveAxis;

    if (axis == 0 && _lastScheduledAxis == 0) {
      // No held axis and nothing to override.
      _axisScheduledThroughTick = controller.tick;
      return;
    }

    if (axis != _lastScheduledAxis) {
      // Axis changed (including to 0); reschedule to overwrite any already
      // buffered ticks.
      _axisScheduledThroughTick = controller.tick;
      _lastScheduledAxis = axis;
    }

    final maxTicksPerFrame = (controller.tickHz * _inputBufferSeconds).ceil();
    final targetMaxTick =
        controller.tick + controller.inputLead + maxTicksPerFrame;

    final startTick = max(controller.tick + 1, _axisScheduledThroughTick + 1);
    for (var t = startTick; t <= targetMaxTick; t += 1) {
      controller.enqueue(MoveAxisCommand(tick: t, axis: axis));
    }
    _axisScheduledThroughTick = targetMaxTick;
  }
}

/// Helper class to encapsulate the state and scheduling logic for a single aim input (e.g., Projectile or Melee).
class _AimInputChannel {
  /// Whether an aim direction is currently set.
  bool isSet = false;

  /// The X component of the current aim direction (quantized).
  double x = 0;

  /// The Y component of the current aim direction (quantized).
  double y = 0;

  // -- Scheduling State --

  /// Whether the aim was set during the last schedule pass.
  bool _lastScheduledSet = false;

  /// The X component scheduled during the last pass.
  double _lastScheduledX = 0;

  /// The Y component scheduled during the last pass.
  double _lastScheduledY = 0;

  /// The highest tick for which we have already scheduled aim commands.
  int _scheduledThroughTick = 0;

  /// Tick through which clear commands are blocked.
  ///
  /// This is used when a "commit" action (like firing a projectile) uses the aim, and we want
  /// to ensure the subsequent clear command doesn't overwrite it in the same tick.
  int _clearBlockedThroughTick = 0;

  /// Updates the aim direction.
  void set(double rawX, double rawY) {
    final qx = AimQuantizer.quantize(rawX);
    final qy = AimQuantizer.quantize(rawY);

    if (isSet && qx == x && qy == y) {
      return;
    }

    isSet = true;
    x = qx;
    y = qy;
  }

  /// Clears the aim direction.
  void clear() {
    isSet = false;
    x = 0;
    y = 0;
  }

  /// Prevents `Clear...Command` from being scheduled up to and including [tick].
  void blockClearThrough(int tick) {
    _clearBlockedThroughTick = max(_clearBlockedThroughTick, tick);
  }

  /// Schedules aim or clear commands for upcoming ticks.
  ///
  /// [bufferSeconds] determines how far ahead to schedule.
  /// [createAimCmd] factory for the specific aim command (Projectile vs Melee).
  /// [createClearCmd] factory for the specific clear command.
  void schedule(
    GameController controller,
    double bufferSeconds,
    Command Function(int tick, double x, double y) createAimCmd,
    Command Function(int tick) createClearCmd,
  ) {
    if (!isSet && !_lastScheduledSet) {
      // No held aim and nothing to override.
      _scheduledThroughTick = controller.tick;
      return;
    }

    if (isSet != _lastScheduledSet) {
      // Aim active state changed; force reschedule from current tick to overwrite buffers.
      _scheduledThroughTick = controller.tick;
      _lastScheduledSet = isSet;
      _lastScheduledX = x;
      _lastScheduledY = y;
    }

    if (isSet && (x != _lastScheduledX || y != _lastScheduledY)) {
      // Vector changed; force reschedule from current tick.
      _scheduledThroughTick = controller.tick;
      _lastScheduledX = x;
      _lastScheduledY = y;
    }

    final maxTicksPerFrame = (controller.tickHz * bufferSeconds).ceil();
    final targetMaxTick =
        controller.tick + controller.inputLead + maxTicksPerFrame;

    var startTick = max(controller.tick + 1, _scheduledThroughTick + 1);

    // If we are clearing aim, ensure we don't overwrite a committed action tick.
    if (!isSet) {
      startTick = max(startTick, _clearBlockedThroughTick + 1);
    }

    for (var t = startTick; t <= targetMaxTick; t += 1) {
      if (isSet) {
        controller.enqueue(createAimCmd(t, x, y));
      } else {
        controller.enqueue(createClearCmd(t));
      }
    }
    _scheduledThroughTick = targetMaxTick;
  }
}


===== FILE: lib/game/runner_flame_game.dart =====
// Flame rendering layer for the runner (Milestone 0 placeholder).
//
// Reads the latest `GameStateSnapshot` from `GameController` each frame and
// renders a minimal representation (a player dot + debug text). This file is
// intentionally tiny and non-authoritative: gameplay truth lives in Core.
import 'package:flame/components.dart';
import 'package:flame/game.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/widgets.dart';

import '../core/contracts/render_contract.dart';
import '../core/events/game_event.dart';
import '../core/players/player_character_definition.dart';
import '../core/snapshots/entity_render_snapshot.dart';
import '../core/snapshots/enums.dart';
import '../core/snapshots/static_solid_snapshot.dart';
import 'debug/debug_aabb_overlay.dart';
import 'debug/render_debug_flags.dart';
import 'components/player/player_animations.dart';
import 'components/player/player_view_component.dart';
import 'components/enemies/enemy_render_registry.dart';
import 'components/pickups/pickup_render_registry.dart';
import 'components/projectiles/projectile_render_registry.dart';
import 'components/sprite_anim/deterministic_anim_view_component.dart';
import 'tuning/player_render_tuning.dart';
import 'input/runner_input_router.dart';
import 'input/aim_preview.dart';
import 'components/pixel_parallax_backdrop_component.dart';
import 'components/tiled_ground_band_component.dart';
import 'components/aim_ray_component.dart';
import 'game_controller.dart';
import 'themes/parallax_theme_registry.dart';
import 'util/math_util.dart' as math;

// ─────────────────────────────────────────────────────────────────────────────
// Render priorities
// ─────────────────────────────────────────────────────────────────────────────

const _priorityBackgroundParallax = -30;
const _priorityGroundTiles = -20;
const _priorityForegroundParallax = -10;
const _priorityStaticSolids = -5;
const _priorityPlayer = -3;
const _priorityEnemies = -2;
const _priorityProjectiles = -1;
const _priorityCollectibles = -1;
const _priorityHitboxes = 1;
const _priorityActorHitboxes = 2;
const _priorityProjectileAimRay = 5;
const _priorityMeleeAimRay = 6;
const PlayerRenderTuning _playerRenderTuning = PlayerRenderTuning();

/// Minimal Flame `Game` that renders from snapshots.
class RunnerFlameGame extends FlameGame {
  RunnerFlameGame({
    required this.controller,
    required this.input,
    required this.projectileAimPreview,
    required this.meleeAimPreview,
    required this.playerCharacter,
  }) : _enemyRenderRegistry = EnemyRenderRegistry(
         enemyCatalog: controller.enemyCatalog,
       ),
       _projectileRenderRegistry = ProjectileRenderRegistry(),
       _pickupRenderRegistry = PickupRenderRegistry(),
       super(
         camera: CameraComponent.withFixedResolution(
           width: virtualWidth.toDouble(),
           height: virtualHeight.toDouble(),
         ),
       );

  /// Bridge/controller that owns the simulation and produces snapshots.
  final GameController controller;

  /// Input scheduler/aggregator (touch + keyboard + mouse).
  final RunnerInputRouter input;

  /// UI-driven aim preview (render-only).
  final ValueListenable<AimPreviewState> projectileAimPreview;
  final ValueListenable<AimPreviewState> meleeAimPreview;

  /// The selected player character definition for this run (render-only usage).
  final PlayerCharacterDefinition playerCharacter;

  late final PlayerViewComponent _player;
  final EnemyRenderRegistry _enemyRenderRegistry;
  final ProjectileRenderRegistry _projectileRenderRegistry;
  final PickupRenderRegistry _pickupRenderRegistry;
  final List<RectangleComponent> _staticSolids = <RectangleComponent>[];
  List<StaticSolidSnapshot>? _lastStaticSolidsSnapshot;

  /// Entity view pools, keyed by entity ID.
  final Map<int, DeterministicAnimViewComponent> _projectileAnimViews =
      <int, DeterministicAnimViewComponent>{};
  final Map<int, DeterministicAnimViewComponent> _pickupAnimViews =
      <int, DeterministicAnimViewComponent>{};
  final Map<int, DeterministicAnimViewComponent> _enemies =
      <int, DeterministicAnimViewComponent>{};
  final Map<int, RectangleComponent> _hitboxes = <int, RectangleComponent>{};
  final Map<int, RectangleComponent> _actorHitboxes =
      <int, RectangleComponent>{};

  final Paint _hitboxPaint = Paint()..color = const Color(0x66EF4444);
  final Paint _actorHitboxPaint = Paint()
    ..color = const Color(0xFF22C55E)
    ..style = PaintingStyle.stroke
    ..strokeWidth = 1.0;

  final Map<int, EntityRenderSnapshot> _prevEntitiesById =
      <int, EntityRenderSnapshot>{};
  final Map<int, int> _projectileSpawnTicks = <int, int>{};
  final Set<int> _seenIdsScratch = <int>{};
  final List<int> _toRemoveScratch = <int>[];
  final Vector2 _cameraCenterScratch = Vector2.zero();
  final Vector2 _snapScratch = Vector2.zero();
  final List<ProjectileHitEvent> _pendingProjectileHitEvents =
      <ProjectileHitEvent>[];

  @override
  Future<void> onLoad() async {
    await super.onLoad();
    assert(() {
      playerCharacter.assertValid();
      return true;
    }());
    controller.addEventListener(_handleGameEvent);
    final theme = ParallaxThemeRegistry.forThemeId(controller.snapshot.themeId);

    // Background parallax layers (sky, distant mountains, etc.)
    camera.backdrop.add(
      PixelParallaxBackdropComponent(
        virtualWidth: virtualWidth,
        virtualHeight: virtualHeight,
        snapScrollToPixels: false,
        layers: theme.backgroundLayers,
      )..priority = _priorityBackgroundParallax,
    );

    // Ground tiles (with gap support)
    camera.backdrop.add(
      TiledGroundBandComponent(
        assetPath: theme.groundLayerAsset,
        controller: controller,
        virtualWidth: virtualWidth,
        virtualHeight: virtualHeight,
        renderInBackdrop: true,
      )..priority = _priorityGroundTiles,
    );

    // Foreground parallax layers (grass, bushes, etc.)
    camera.backdrop.add(
      PixelParallaxBackdropComponent(
        virtualWidth: virtualWidth,
        virtualHeight: virtualHeight,
        snapScrollToPixels: false,
        layers: theme.foregroundLayers,
      )..priority = _priorityForegroundParallax,
    );

    final playerAnimations = await loadPlayerAnimations(
      images,
      renderAnim: playerCharacter.renderAnim,
    );
    await _enemyRenderRegistry.load(images);
    await _projectileRenderRegistry.load(images);
    await _pickupRenderRegistry.load(images);
    _player = PlayerViewComponent(
      animationSet: playerAnimations,
      renderScale: Vector2.all(_playerRenderTuning.scale),
    )..priority = _priorityPlayer;
    world.add(_player);

    world.add(
      AimRayComponent(
        controller: controller,
        preview: projectileAimPreview,
        length: projectileAimRayLength,
        playerRenderPos: () => _player.position,
        drawWhenNoAim: false,
      )..priority = _priorityProjectileAimRay,
    );

    world.add(
      AimRayComponent(
        controller: controller,
        preview: meleeAimPreview,
        length: meleeAimRayLength,
        playerRenderPos: () => _player.position,
        drawWhenNoAim: false,
        paint: Paint()
          ..color = const Color(0xFFDC4440)
          ..strokeWidth = 2
          ..strokeCap = StrokeCap.round,
      )..priority = _priorityMeleeAimRay,
    );

    _mountStaticSolids(controller.snapshot.staticSolids);
    _lastStaticSolidsSnapshot = controller.snapshot.staticSolids;
  }

  @override
  void update(double dt) {
    final snapshot = controller.snapshot;
    if (!snapshot.paused && !snapshot.gameOver) {
      input.pumpHeldInputs();
    }

    // Step the deterministic core using the frame delta, then render the newest
    // snapshot. This order is critical: Flame components (parallax, etc.) read
    // the camera during their own update(), so Core + camera + view sync must
    // run BEFORE super.update(dt).
    controller.advanceFrame(dt);

    final prevSnapshot = controller.prevSnapshot;
    final currSnapshot = controller.snapshot;
    final alpha = controller.alpha;

    _prevEntitiesById.clear();
    for (final e in prevSnapshot.entities) {
      _prevEntitiesById[e.id] = e;
    }

    final camX = math.lerpDouble(
      prevSnapshot.cameraCenterX,
      currSnapshot.cameraCenterX,
      alpha,
    );
    final camY = math.lerpDouble(
      prevSnapshot.cameraCenterY,
      currSnapshot.cameraCenterY,
      alpha,
    );
    _cameraCenterScratch.setValues(camX, camY);
    camera.viewfinder.position = _cameraCenterScratch;

    _syncStaticSolids(currSnapshot.staticSolids);
    _snapStaticSolids(
      currSnapshot.staticSolids,
      cameraCenter: _cameraCenterScratch,
    );

    final player = currSnapshot.playerEntity;
    if (player != null) {
      final prev = _prevEntitiesById[player.id] ?? player;
      final worldX = math.lerpDouble(prev.pos.x, player.pos.x, alpha);
      final worldY = math.lerpDouble(prev.pos.y, player.pos.y, alpha);
      _snapScratch.setValues(
        math.snapWorldToPixelsInCameraSpace1d(worldX, _cameraCenterScratch.x),
        math.snapWorldToPixelsInCameraSpace1d(worldY, _cameraCenterScratch.y),
      );
      _player.applySnapshot(
        player,
        tickHz: controller.tickHz,
        pos: _snapScratch,
      );
    }

    _syncEnemies(
      currSnapshot.entities,
      prevById: _prevEntitiesById,
      alpha: alpha,
      cameraCenter: _cameraCenterScratch,
    );
    _syncProjectiles(
      currSnapshot.entities,
      prevById: _prevEntitiesById,
      alpha: alpha,
      cameraCenter: _cameraCenterScratch,
      tick: currSnapshot.tick,
    );
    _syncCollectibles(
      currSnapshot.entities,
      prevById: _prevEntitiesById,
      alpha: alpha,
      cameraCenter: _cameraCenterScratch,
    );
    final drawHitboxes =
        RenderDebugFlags.canUseRenderDebug &&
        RenderDebugFlags.drawActorHitboxes;
    if (drawHitboxes) {
      _syncHitboxes(
        currSnapshot.entities,
        prevById: _prevEntitiesById,
        alpha: alpha,
        cameraCenter: _cameraCenterScratch,
      );
    } else if (_hitboxes.isNotEmpty) {
      for (final view in _hitboxes.values) {
        view.removeFromParent();
      }
      _hitboxes.clear();
    }
    syncDebugAabbOverlays(
      entities: currSnapshot.entities,
      enabled:
          RenderDebugFlags.canUseRenderDebug &&
          RenderDebugFlags.drawActorHitboxes,
      parent: world,
      pool: _actorHitboxes,
      priority: _priorityActorHitboxes,
      paint: _actorHitboxPaint,
      include: (e) => e.kind == EntityKind.player || e.kind == EntityKind.enemy,
      prevById: _prevEntitiesById,
      offsetXFor: (e) {
        switch (e.kind) {
          case EntityKind.player:
            return playerCharacter.catalog.colliderOffsetX;
          case EntityKind.enemy:
            final enemyId = e.enemyId;
            if (enemyId == null) return 0.0;
            return controller.enemyCatalog.get(enemyId).collider.offsetX;
          default:
            return 0.0;
        }
      },
      offsetYFor: (e) {
        switch (e.kind) {
          case EntityKind.player:
            return playerCharacter.catalog.colliderOffsetY;
          case EntityKind.enemy:
            final enemyId = e.enemyId;
            if (enemyId == null) return 0.0;
            return controller.enemyCatalog.get(enemyId).collider.offsetY;
          default:
            return 0.0;
        }
      },
      alpha: alpha,
      cameraCenter: _cameraCenterScratch,
    );

    _flushPendingProjectileHitEvents(cameraCenter: _cameraCenterScratch);

    super.update(dt);
  }

  /// Mounts static solid rectangles into the world.
  ///
  /// Called once on load and whenever the static solids list changes.
  /// One-way platforms are rendered with a green tint, solid platforms with
  /// purple.
  void _mountStaticSolids(List<StaticSolidSnapshot> solids) {
    if (solids.isEmpty) return;

    for (final solid in solids) {
      final color = solid.oneWayTop
          ? const Color(0x6648BB78) // green-ish translucent
          : const Color(0x668B5CF6); // purple translucent

      final rect = RectangleComponent(
        position: Vector2(solid.minX, solid.minY),
        size: Vector2(solid.maxX - solid.minX, solid.maxY - solid.minY),
        paint: Paint()..color = color,
      );
      rect.priority = _priorityStaticSolids;
      _staticSolids.add(rect);
      world.add(rect);
    }
  }

  /// Synchronizes enemy view components with the snapshot.
  ///
  /// Creates view components for new enemies, updates existing ones, and
  /// removes components for despawned enemies.
  void _syncEnemies(
    List<EntityRenderSnapshot> entities, {
    required Map<int, EntityRenderSnapshot> prevById,
    required double alpha,
    required Vector2 cameraCenter,
  }) {
    final seen = _seenIdsScratch..clear();

    for (final e in entities) {
      if (e.kind != EntityKind.enemy) continue;

      final entry = e.enemyId == null
          ? null
          : _enemyRenderRegistry.entryFor(e.enemyId!);
      if (entry == null) {
        _enemies.remove(e.id)?.removeFromParent();
        continue;
      }

      seen.add(e.id);

      var view = _enemies[e.id];
      if (view == null) {
        view = entry.viewFactory(entry.animSet, entry.renderScale)
          ..priority = _priorityEnemies;
        _enemies[e.id] = view;
        world.add(view);
      }

      final prev = prevById[e.id] ?? e;
      final worldX = math.lerpDouble(prev.pos.x, e.pos.x, alpha);
      final worldY = math.lerpDouble(prev.pos.y, e.pos.y, alpha);
      final snappedX = math.snapWorldToPixelsInCameraSpace1d(
        worldX,
        cameraCenter.x,
      );
      final snappedY = math.snapWorldToPixelsInCameraSpace1d(
        worldY,
        cameraCenter.y,
      );

      _snapScratch.setValues(snappedX, snappedY);
      view.applySnapshot(e, tickHz: controller.tickHz, pos: _snapScratch);
    }

    if (_enemies.isEmpty) return;
    final toRemove = _toRemoveScratch..clear();
    for (final id in _enemies.keys) {
      if (!seen.contains(id)) toRemove.add(id);
    }
    for (final id in toRemove) {
      _enemies.remove(id)?.removeFromParent();
    }
  }

  void _handleGameEvent(GameEvent event) {
    if (event is ProjectileHitEvent) {
      _pendingProjectileHitEvents.add(event);
    }
  }

  void _flushPendingProjectileHitEvents({required Vector2 cameraCenter}) {
    if (_pendingProjectileHitEvents.isEmpty) return;

    for (final event in _pendingProjectileHitEvents) {
      final entry = _projectileRenderRegistry.entryFor(event.projectileId);
      if (entry == null) continue;

      final hitAnim = entry.animSet.animations[AnimKey.hit];
      if (hitAnim == null) continue;

      final component = _CameraSpaceSnappedSpriteAnimationComponent(
        animation: hitAnim,
        size: entry.animSet.frameSize.clone(),
        worldPosX: event.pos.x,
        worldPosY: event.pos.y,
        anchor: entry.animSet.anchor,
        paint: Paint()..filterQuality = FilterQuality.none,
        removeOnFinish: true,
      )..priority = _priorityProjectiles;

      component.scale.setValues(entry.renderScale.x, entry.renderScale.y);
      component.angle = event.rotationRad;
      component.snapToCamera(cameraCenter);
      world.add(component);
    }

    _pendingProjectileHitEvents.clear();
  }

  /// Synchronizes projectile view components with the snapshot.
  ///
  /// Creates rectangle components for new projectiles, updates position/size
  /// for existing ones, and removes components for despawned projectiles.
  void _syncProjectiles(
    List<EntityRenderSnapshot> entities, {
    required Map<int, EntityRenderSnapshot> prevById,
    required double alpha,
    required Vector2 cameraCenter,
    required int tick,
  }) {
    final seen = _seenIdsScratch..clear();

    for (final e in entities) {
      if (e.kind != EntityKind.projectile) continue;
      seen.add(e.id);

      final projectileId = e.projectileId;
      final entry = projectileId == null
          ? null
          : _projectileRenderRegistry.entryFor(projectileId);

      if (entry != null) {
        var view = _projectileAnimViews[e.id];
        if (view == null) {
          view = entry.viewFactory(entry.animSet, entry.renderScale);
          view.priority = _priorityProjectiles;
          _projectileAnimViews[e.id] = view;
          _projectileSpawnTicks[e.id] = tick;
          world.add(view);
        }

        final prev = prevById[e.id] ?? e;
        final worldX = math.lerpDouble(prev.pos.x, e.pos.x, alpha);
        final worldY = math.lerpDouble(prev.pos.y, e.pos.y, alpha);
        _snapScratch.setValues(
          math.snapWorldToPixelsInCameraSpace1d(worldX, cameraCenter.x),
          math.snapWorldToPixelsInCameraSpace1d(worldY, cameraCenter.y),
        );

        final spawnTick = _projectileSpawnTicks[e.id] ?? tick;
        final startTicks = entry.spawnAnimTicks(controller.tickHz);
        final ageTicks = tick - spawnTick;
        final animOverride =
            startTicks > 0 && ageTicks >= 0 && ageTicks < startTicks
            ? AnimKey.spawn
            : AnimKey.idle;
        final overrideAnimFrame = animOverride == AnimKey.spawn
            ? ageTicks
            : null;

        view.applySnapshot(
          e,
          tickHz: controller.tickHz,
          pos: _snapScratch,
          overrideAnim: animOverride,
          overrideAnimFrame: overrideAnimFrame,
        );
        final spinSpeed = entry.spinSpeedRadPerSecond;
        if (spinSpeed == 0.0) {
          view.angle = e.rotationRad;
        } else {
          final spinSeconds = (ageTicks.toDouble() + alpha) / controller.tickHz;
          view.angle = e.rotationRad + spinSpeed * spinSeconds;
        }
      } else {
        // No fallback rendering for unknown/unregistered projectiles.
        //
        // If the projectile exists in Core but has no render wiring (or assets),
        // we simply avoid rendering it rather than using placeholder rectangles.
        _projectileAnimViews.remove(e.id)?.removeFromParent();
        _projectileSpawnTicks.remove(e.id);
      }
    }

    if (_projectileAnimViews.isNotEmpty) {
      final toRemove = _toRemoveScratch..clear();
      for (final id in _projectileAnimViews.keys) {
        if (!seen.contains(id)) toRemove.add(id);
      }
      for (final id in toRemove) {
        _projectileAnimViews.remove(id)?.removeFromParent();
        _projectileSpawnTicks.remove(id);
      }
    }
  }

  /// Synchronizes collectible/pickup view components with the snapshot.
  ///
  /// Creates deterministic animation components for pickups and removes
  /// components for collected pickups.
  void _syncCollectibles(
    List<EntityRenderSnapshot> entities, {
    required Map<int, EntityRenderSnapshot> prevById,
    required double alpha,
    required Vector2 cameraCenter,
  }) {
    final seen = _seenIdsScratch..clear();

    for (final e in entities) {
      if (e.kind != EntityKind.pickup) continue;
      seen.add(e.id);

      final variant = e.pickupVariant ?? PickupVariant.collectible;
      final entry = _pickupRenderRegistry.entryForVariant(variant);

      var view = _pickupAnimViews[e.id];
      if (view == null) {
        view = entry.viewFactory(entry.animSet, entry.renderScale);
        view.priority = _priorityCollectibles;
        _pickupAnimViews[e.id] = view;
        world.add(view);
      }

      final prev = prevById[e.id] ?? e;
      final worldX = math.lerpDouble(prev.pos.x, e.pos.x, alpha);
      final worldY = math.lerpDouble(prev.pos.y, e.pos.y, alpha);
      _snapScratch.setValues(
        math.snapWorldToPixelsInCameraSpace1d(worldX, cameraCenter.x),
        math.snapWorldToPixelsInCameraSpace1d(worldY, cameraCenter.y),
      );
      view.applySnapshot(e, tickHz: controller.tickHz, pos: _snapScratch);
      view.angle = e.rotationRad;
    }

    if (_pickupAnimViews.isEmpty) return;
    final toRemove = _toRemoveScratch..clear();
    for (final id in _pickupAnimViews.keys) {
      if (!seen.contains(id)) toRemove.add(id);
    }
    for (final id in toRemove) {
      _pickupAnimViews.remove(id)?.removeFromParent();
    }
  }

  /// Synchronizes trigger/hitbox view components with the snapshot.
  ///
  /// Creates translucent red rectangle components for new triggers, updates
  /// position/size for existing ones, and removes components for despawned
  /// triggers.
  void _syncHitboxes(
    List<EntityRenderSnapshot> entities, {
    required Map<int, EntityRenderSnapshot> prevById,
    required double alpha,
    required Vector2 cameraCenter,
  }) {
    final seen = _seenIdsScratch..clear();

    for (final e in entities) {
      if (e.kind != EntityKind.trigger) continue;
      seen.add(e.id);

      var view = _hitboxes[e.id];
      if (view == null) {
        final size = e.size;
        view = RectangleComponent(
          size: Vector2(size?.x ?? 8.0, size?.y ?? 8.0),
          anchor: Anchor.center,
          paint: _hitboxPaint,
        );
        view.priority = _priorityHitboxes;
        _hitboxes[e.id] = view;
        world.add(view);
      } else {
        final size = e.size;
        if (size != null) {
          view.size.setValues(size.x, size.y);
        }
      }

      final prev = prevById[e.id] ?? e;
      final worldX = math.lerpDouble(prev.pos.x, e.pos.x, alpha);
      final worldY = math.lerpDouble(prev.pos.y, e.pos.y, alpha);
      view.position.setValues(
        math.snapWorldToPixelsInCameraSpace1d(worldX, cameraCenter.x),
        math.snapWorldToPixelsInCameraSpace1d(worldY, cameraCenter.y),
      );
    }

    if (_hitboxes.isEmpty) return;
    final toRemove = _toRemoveScratch..clear();
    for (final id in _hitboxes.keys) {
      if (!seen.contains(id)) toRemove.add(id);
    }
    for (final id in toRemove) {
      _hitboxes.remove(id)?.removeFromParent();
    }
  }

  /// Synchronizes static solid views with the snapshot.
  ///
  /// Uses identity comparison as a cheap version check since Core rebuilds
  /// the list only when geometry actually changes (spawn/cull).
  void _syncStaticSolids(List<StaticSolidSnapshot> solids) {
    // Core rebuilds the list only when geometry changes (spawn/cull),
    // so identity check is a cheap "version" check.
    if (identical(solids, _lastStaticSolidsSnapshot)) return;
    _lastStaticSolidsSnapshot = solids;

    for (final c in _staticSolids) {
      c.removeFromParent();
    }
    _staticSolids.clear();

    _mountStaticSolids(solids);
  }

  void _snapStaticSolids(
    List<StaticSolidSnapshot> solids, {
    required Vector2 cameraCenter,
  }) {
    if (solids.isEmpty) return;
    if (_staticSolids.length != solids.length) return;

    for (var i = 0; i < solids.length; i++) {
      final solid = solids[i];
      final view = _staticSolids[i];
      view.position.setValues(
        math.snapWorldToPixelsInCameraSpace1d(solid.minX, cameraCenter.x),
        math.snapWorldToPixelsInCameraSpace1d(solid.minY, cameraCenter.y),
      );
    }
  }

  @override
  void onRemove() {
    controller.removeEventListener(_handleGameEvent);
    images.clearCache();
    super.onRemove();
  }
}

class _CameraSpaceSnappedSpriteAnimationComponent
    extends SpriteAnimationComponent
    with HasGameReference<FlameGame> {
  _CameraSpaceSnappedSpriteAnimationComponent({
    required SpriteAnimation super.animation,
    required Vector2 super.size,
    required this.worldPosX,
    required this.worldPosY,
    this.anchor = Anchor.center,
    super.paint,
    super.removeOnFinish,
  }) : super(anchor: anchor);

  final double worldPosX;
  final double worldPosY;
  final Anchor anchor;

  void snapToCamera(Vector2 cameraCenter) {
    position.setValues(
      math.snapWorldToPixelsInCameraSpace1d(worldPosX, cameraCenter.x),
      math.snapWorldToPixelsInCameraSpace1d(worldPosY, cameraCenter.y),
    );
  }

  @override
  void update(double dt) {
    snapToCamera(game.camera.viewfinder.position);
    super.update(dt);
  }
}


===== FILE: lib/game/themes/parallax_theme.dart =====
/// Render-layer parallax theme configuration.
library;

import '../components/pixel_parallax_backdrop_component.dart';

class ParallaxTheme {
  const ParallaxTheme({
    required this.backgroundLayers,
    required this.groundLayerAsset,
    required this.foregroundLayers,
  });

  final List<PixelParallaxLayerSpec> backgroundLayers;
  final String groundLayerAsset;
  final List<PixelParallaxLayerSpec> foregroundLayers;
}



===== FILE: lib/game/themes/parallax_theme_registry.dart =====
/// Render-layer mapping of Core theme IDs to concrete parallax assets.
library;

import 'parallax_theme.dart';
import '../components/pixel_parallax_backdrop_component.dart';

/// Returns the [ParallaxTheme] for a given Core `themeId`.
///
/// Unknown or null theme IDs fall back to the default theme.
class ParallaxThemeRegistry {
  const ParallaxThemeRegistry._();

  static ParallaxTheme forThemeId(String? themeId) {
    switch (themeId) {
      case 'field':
        return _field;
      case 'forest':
        return _forest;
      default:
        return _field;
    }
  }
}

const ParallaxTheme _field = ParallaxTheme(
  backgroundLayers: <PixelParallaxLayerSpec>[
    PixelParallaxLayerSpec(
      assetPath: 'parallax/field/Field Layer 01.png',
      parallaxFactor: 0.10,
    ),
    PixelParallaxLayerSpec(
      assetPath: 'parallax/field/Field Layer 02.png',
      parallaxFactor: 0.15,
    ),
    PixelParallaxLayerSpec(
      assetPath: 'parallax/field/Field Layer 03.png',
      parallaxFactor: 0.20,
    ),
    PixelParallaxLayerSpec(
      assetPath: 'parallax/field/Field Layer 04.png',
      parallaxFactor: 0.30,
    ),
    PixelParallaxLayerSpec(
      assetPath: 'parallax/field/Field Layer 05.png',
      parallaxFactor: 0.40,
    ),
    PixelParallaxLayerSpec(
      assetPath: 'parallax/field/Field Layer 06.png',
      parallaxFactor: 0.50,
    ),
    PixelParallaxLayerSpec(
      assetPath: 'parallax/field/Field Layer 07.png',
      parallaxFactor: 0.60,
    ),
    PixelParallaxLayerSpec(
      assetPath: 'parallax/field/Field Layer 08.png',
      parallaxFactor: 0.70,
    ),
  ],
  groundLayerAsset: 'parallax/field/Field Layer 09.png',
  foregroundLayers: <PixelParallaxLayerSpec>[
    PixelParallaxLayerSpec(
      assetPath: 'parallax/field/Field Layer 10.png',
      parallaxFactor: 1.0,
    ),
  ],
);

const ParallaxTheme _forest = ParallaxTheme(
  backgroundLayers: <PixelParallaxLayerSpec>[
    PixelParallaxLayerSpec(
      assetPath: 'parallax/forest/Forest Layer 01.png',
      parallaxFactor: 0.10,
    ),
    PixelParallaxLayerSpec(
      assetPath: 'parallax/forest/Forest Layer 02.png',
      parallaxFactor: 0.20,
    ),
    PixelParallaxLayerSpec(
      assetPath: 'parallax/forest/Forest Layer 03.png',
      parallaxFactor: 0.30,
    ),
  ],
  groundLayerAsset: 'parallax/forest/Forest Layer 04.png',
  foregroundLayers: <PixelParallaxLayerSpec>[
    PixelParallaxLayerSpec(
      assetPath: 'parallax/forest/Forest Layer 05.png',
      parallaxFactor: 1.0,
    ),
  ],
);

===== FILE: lib/game/tick_input_frame.dart =====
// Aggregated input state for a single simulation tick.
//
// The game schedules input commands ahead of time (via RunnerInputRouter).
// Multiple commands may target the same tick, so this class merges them into
// a single coherent state that the simulation consumes.
import '../core/commands/command.dart';

/// Aggregated per-tick input for the simulation.
///
/// This replaces `List<Command>` buffering for a given tick to avoid duplicate
/// commands (e.g., multiple [MoveAxisCommand]s for the same tick). Instead of
/// storing a list, we collapse commands into their final values.
///
/// **Usage pattern:**
/// 1. [GameController] creates one [TickInputFrame] per buffered tick.
/// 2. As commands arrive, [apply] merges them into the frame.
/// 3. When the tick executes, the simulation reads the aggregated state.
/// 4. After use, [reset] clears the frame for potential reuse.
class TickInputFrame {
  // ─────────────────────────────────────────────────────────────────────────
  // Movement
  // ─────────────────────────────────────────────────────────────────────────

  /// Horizontal movement axis in [-1, 1]. Last [MoveAxisCommand] wins.
  double moveAxis = 0;

  // ─────────────────────────────────────────────────────────────────────────
  // Edge-triggered actions (one-shot per tick)
  // ─────────────────────────────────────────────────────────────────────────

  /// True if jump was pressed this tick.
  bool jumpPressed = false;

  /// True if dash was pressed this tick.
  bool dashPressed = false;

  /// True if melee strike was pressed this tick.
  bool strikePressed = false;

  /// True if projectile slot was pressed this tick.
  bool projectilePressed = false;

  /// True if secondary slot was pressed this tick.
  bool secondaryPressed = false;

  /// True if bonus slot was pressed this tick.
  bool bonusPressed = false;

  // ─────────────────────────────────────────────────────────────────────────
  // Projectile aim direction
  // ─────────────────────────────────────────────────────────────────────────

  /// Whether a projectile aim direction is set for this tick.
  bool projectileAimDirSet = false;

  /// Projectile aim X component (only valid if [projectileAimDirSet] is true).
  double projectileAimDirX = 0;

  /// Projectile aim Y component (only valid if [projectileAimDirSet] is true).
  double projectileAimDirY = 0;

  // ─────────────────────────────────────────────────────────────────────────
  // Melee aim direction
  // ─────────────────────────────────────────────────────────────────────────

  /// Whether a melee aim direction is set for this tick.
  bool meleeAimDirSet = false;

  /// Melee aim X component (only valid if [meleeAimDirSet] is true).
  double meleeAimDirX = 0;

  /// Melee aim Y component (only valid if [meleeAimDirSet] is true).
  double meleeAimDirY = 0;

  // ─────────────────────────────────────────────────────────────────────────
  /// Applies a [Command] to this frame, merging it with existing state.
  ///
  /// For continuous inputs (move axis, aim), later commands overwrite earlier ones.
  /// For edge-triggered inputs (jump, dash, strike, projectile), any press sets the flag.
  void apply(Command command) {
    switch (command) {
      case MoveAxisCommand(:final axis):
        moveAxis = axis.clamp(-1.0, 1.0);
      case JumpPressedCommand():
        jumpPressed = true;
      case DashPressedCommand():
        dashPressed = true;
      case StrikePressedCommand():
        strikePressed = true;
      case ProjectileAimDirCommand(:final x, :final y):
        projectileAimDirSet = true;
        projectileAimDirX = x;
        projectileAimDirY = y;
      case MeleeAimDirCommand(:final x, :final y):
        meleeAimDirSet = true;
        meleeAimDirX = x;
        meleeAimDirY = y;
      case ClearProjectileAimDirCommand():
        projectileAimDirSet = false;
        projectileAimDirX = 0;
        projectileAimDirY = 0;
      case ClearMeleeAimDirCommand():
        meleeAimDirSet = false;
        meleeAimDirX = 0;
        meleeAimDirY = 0;
      case ProjectilePressedCommand():
        projectilePressed = true;
      case SecondaryPressedCommand():
        secondaryPressed = true;
      case BonusPressedCommand():
        bonusPressed = true;
    }
  }

  /// Resets all fields to their default (idle) state.
  ///
  /// Call this to reuse the frame for a new tick without allocating a new object.
  void reset() {
    moveAxis = 0;
    jumpPressed = false;
    dashPressed = false;
    strikePressed = false;
    projectileAimDirSet = false;
    projectileAimDirX = 0;
    projectileAimDirY = 0;
    meleeAimDirSet = false;
    meleeAimDirX = 0;
    meleeAimDirY = 0;
    projectilePressed = false;
    secondaryPressed = false;
    bonusPressed = false;
  }
}


===== FILE: lib/game/tuning/player_render_tuning.dart =====
/// Render-layer tuning for player sprite presentation.
library;

import 'package:flutter/foundation.dart';

@immutable
class PlayerRenderTuning {
  const PlayerRenderTuning({
    this.scale = 0.75,
  });

  /// Uniform scale applied to the 100x64 sprite frames.
  final double scale;
}


===== FILE: lib/game/util/math_util.dart =====
// Math utilities for the game layer.
//
// Provides helper functions for common math operations that Dart's standard
// library doesn't handle correctly for game use cases (e.g., negative modulo,
// floor division with negative numbers).

import 'package:flame/components.dart';

import '../../core/util/vec2.dart';

/// Returns `value % mod`, always in the range `[0, mod)`.
///
/// Dart's `%` operator can return negative results for negative [value];
/// this function corrects that.
double positiveModDouble(double value, double mod) {
  if (mod <= 0) throw ArgumentError.value(mod, 'mod', 'must be > 0');
  final r = value % mod;
  return r < 0 ? r + mod : r;
}

/// Integer floor division that correctly handles negative dividends.
///
/// Dart's `~/` operator truncates toward zero, which gives incorrect results
/// for negative numbers when you want true floor division (toward -∞).
///
/// Example: `-1 ~/ 16` returns `0`, but `floorDivInt(-1, 16)` returns `-1`.
int floorDivInt(int a, int b) {
  if (b <= 0) throw ArgumentError.value(b, 'b', 'must be > 0');
  if (a >= 0) return a ~/ b;
  return -(((-a) + b - 1) ~/ b);
}

double lerpDouble(double a, double b, double t) => a + (b - a) * t;

Vec2 lerpVec2(Vec2 a, Vec2 b, double t) =>
    Vec2(lerpDouble(a.x, b.x, t), lerpDouble(a.y, b.y, t));

double roundToPixels(double value) => value.roundToDouble();

/// Snaps a world coordinate to integer pixels in camera space.
///
/// Keeps [camera] fractional and rounds only the screen-space delta
/// (`world - camera`) to the nearest pixel.
double snapWorldToPixelsInCameraSpace1d(double world, double camera) =>
    camera + roundToPixels(world - camera);

/// Convenience 2D version of [snapWorldToPixelsInCameraSpace1d].
Vector2 snapWorldToPixelsInCameraSpace(Vec2 world, Vector2 camera) => Vector2(
  snapWorldToPixelsInCameraSpace1d(world.x, camera.x),
  snapWorldToPixelsInCameraSpace1d(world.y, camera.y),
);


===== FILE: lib/main.dart =====
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:firebase_core/firebase_core.dart';

import 'firebase_options.dart';
import 'ui/menus/main_menu_page.dart';

/// Production app entry point for the rpg-runner game.
///
/// The runner can also be embedded in other Flutter apps via
/// `RunnerGameWidget` / `createRunnerGameRoute` (see `lib/runner.dart`).
/// Embedding apps should initialize Firebase (and any other services) themselves.
Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // Lock to landscape orientation
  await SystemChrome.setPreferredOrientations([
    DeviceOrientation.landscapeLeft,
    DeviceOrientation.landscapeRight,
  ]);

  // Hide status bar and navigation bar (immersive fullscreen)
  // Note: Also re-applied in MenuScaffold to handle navigation edge cases
  await SystemChrome.setEnabledSystemUIMode(SystemUiMode.immersiveSticky);

  await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);
  runApp(const RpgRunnerApp());
}

class RpgRunnerApp extends StatelessWidget {
  const RpgRunnerApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'rpg-runner',
      debugShowCheckedModeBanner: false,
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(
          seedColor: Colors.white,
          brightness: Brightness.dark,
        ),
        useMaterial3: true,
      ),
      home: const MainMenuPage(),
    );
  }
}


===== FILE: lib/runner.dart =====
// Public entrypoint ("barrel file") for embedding the runner in a host app.
//
// Host apps should import only this file:
// `import 'package:rpg_runner/runner.dart';`
//
// This keeps the public API stable while allowing internal folders/files to
// evolve without breaking downstream imports.
export 'core/levels/level_id.dart';
export 'core/players/player_character_definition.dart';
export 'core/players/player_character_registry.dart';
export 'ui/runner_game_route.dart';
export 'ui/runner_game_widget.dart';


===== FILE: lib/ui/AGENTS.md =====
# AGENTS.md - UI Layer

Instructions for AI coding agents working in the **UI** layer (`lib/ui/`).

## UI Layer Responsibility

The UI layer is responsible for **Flutter widgets**: menus, overlays, navigation, settings, and HUD elements.

**Critical rule:** UI **never modifies gameplay state directly**. It sends **Commands** to the game controller.

## Command Pattern

### Sending Commands to Core

UI interacts with Core gameplay through the Command pattern:

```dart
class PauseButton extends StatelessWidget {
  final GameController controller;
  
  @override
  Widget build(BuildContext context) {
    return IconButton(
      icon: Icon(Icons.pause),
      onPressed: () {
        // Send command to Core
        controller.enqueueCommand(
          PauseCommand(tickNumber: controller.currentTick)
        );
      },
    );
  }
}
```

**Rules:**
- Never access Core state directly
- Never mutate gameplay state from UI code
- Always use Commands for gameplay interactions
- Examples: pause, resume, level selection, ability activation

### Command Examples

Common UI → Core command patterns:

- **Level selection** → `LoadLevelCommand(levelId: 'level_2')`
- **Pause/Resume** → `PauseCommand()` / `ResumeCommand()`
- **Settings changes** → `UpdateSettingsCommand(volume: 0.8)`
- **Player actions** → Typically from Game input, but UI can also send them (e.g., virtual buttons)

## Widget Organization

### HUD Components

HUD (Heads-Up Display) elements are overlays that show game state:

- **Health bars** (`lib/ui/hud/`) - Display player health from snapshots
- **Score display** - Show current score, combo, multiplier
- **Progress indicators** - Level progress, distance traveled
- **Ability cooldowns** - Visual timers for abilities
- **Mini-map** (if applicable) - Simplified world view

**Pattern:**
```dart
class HealthBar extends StatelessWidget {
  final GameStateSnapshot snapshot;
  
  @override
  Widget build(BuildContext context) {
    final health = snapshot.player.health;
    final maxHealth = snapshot.player.maxHealth;
    
    return LinearProgressIndicator(
      value: health / maxHealth,
      backgroundColor: Colors.red[900],
      valueColor: AlwaysStoppedAnimation(Colors.red),
    );
  }
}
```

### Menu Screens

Menu screens for navigation and settings:

- **Main menu** (`lib/ui/menus/`) - Start game, settings, quit
- **Pause menu** - Resume, restart, quit to menu
- **Game over screen** - Score, retry, quit
- **Level selection** - Choose which level to play
- **Settings** - Audio, graphics, controls

### Controls

Input widgets that send commands:

- **Virtual joystick** (`lib/ui/controls/`) - Directional input
- **Action buttons** - Jump, strike, ability buttons
- **Touch zones** - Swipe gestures, tap-to-jump areas

## State Management

### UI State vs Gameplay State

**Separation of concerns:**

- **Gameplay state** - Lives in Core, authoritative, deterministic
- **UI state** - Lives in UI layer, ephemeral, non-deterministic
  - Examples: menu visibility, animation states, selected options

### RunnerGameUIState

UI-specific state management:

```dart
class RunnerGameUIState {
  bool isPaused = false;
  bool isMenuOpen = false;
  String? selectedLevel;
  
  // UI state only - not part of Core
}
```

**Rules:**
- Keep UI state separate from gameplay state
- UI state can be mutable and non-deterministic
- Gameplay state must go through Core and Commands

### Scoped State

Use scoped state management (`lib/ui/scoped/`) for widgets that need shared UI state without affecting Core:

- Provider/InheritedWidget patterns for UI state
- Never use for gameplay state
- Keep scope narrow (menu-level, screen-level)

## Embedding Contract

### Public API

The game is embeddable via a stable public API:

- **`lib/runner.dart`** - Public entry point, exports main widgets/routes
- **`RunnerGameWidget`** - Main game widget component
- **`RunnerGameRoute`** - Flutter route for navigation

**Usage:**
```dart
// In another app
import 'package:rpg_runner/runner.dart';

Navigator.push(
  context,
  MaterialPageRoute(builder: (context) => RunnerGameWidget()),
);
```

### Dev Host

- **`lib/main.dart`** - Development host/demo app only
- Treat as a development harness, not part of the public API
- Safe to modify for development/testing without affecting embedding

## Viewport Integration

### Letterboxing & Safe Areas

UI overlays must respect the game viewport:

```dart
class GameOverlay extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return SafeArea(
      child: Stack(
        children: [
          // Game viewport (rendered by Flame)
          GameWidget(),
          
          // UI overlay (respects safe areas)
          Positioned(
            top: 16,
            left: 16,
            child: HealthBar(),
          ),
        ],
      ),
    );
  }
}
```

**Rules:**
- Use `SafeArea` to avoid notches/system UI
- Position HUD elements outside the game viewport if needed
- Respect letterboxing (black bars) in layout
- Don't cover critical gameplay areas with UI

## Snapshot Consumption

UI can read snapshots for display purposes:

```dart
class ScoreDisplay extends StatelessWidget {
  final GameStateSnapshot snapshot;
  
  @override
  Widget build(BuildContext context) {
    return Text(
      'Score: ${snapshot.score}',
      style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
    );
  }
}
```

**Rules:**
- Read snapshot data for display only
- Never mutate snapshots
- Never simulate or extrapolate gameplay from snapshots in UI

## Level Selection

Level selection is a UI concern that sends commands to Core:

```dart
class LevelSelectScreen extends StatelessWidget {
  final GameController controller;
  
  @override
  Widget build(BuildContext context) {
    return ListView(
      children: [
        LevelButton(
          levelId: 'level_1',
          onTap: () {
            controller.enqueueCommand(
              LoadLevelCommand(levelId: 'level_1')
            );
            Navigator.push(context, GameRoute());
          },
        ),
        // ... more levels
      ],
    );
  }
}
```

**Pattern:**
- Display level metadata (name, preview, locked state)
- Send `LoadLevelCommand` when level is selected
- Navigate to game route after command is sent
- Core handles actual level loading deterministically

## Common UI Subsystems

- **Controls** (`lib/ui/controls/`) - Input widgets (joystick, buttons)
- **HUD** (`lib/ui/hud/`) - In-game overlays (health, score, progress)
- **Menus** (`lib/ui/menus/`) - Menu screens (main, pause, game over)
- **Levels** (`lib/ui/levels/`) - Level selection UI
- **Leaderboard** (`lib/ui/leaderboard/`) - Score display and rankings
- **Scoped** (`lib/ui/scoped/`) - Scoped state management
- **Viewport** (`lib/ui/viewport/`) - Viewport and safe area management

## What NOT to Do in UI Layer

- ❌ **Do not modify gameplay state directly** - use Commands
- ❌ **Do not simulate gameplay** - that's Core's job
- ❌ **Do not access Core internals** - use snapshots and commands
- ❌ **Do not mix UI state with gameplay state** - keep them separate
- ❌ **Do not mutate snapshots** - they are read-only

## Best Practices

✅ **Send Commands** for all gameplay interactions
✅ **Read snapshots** for display purposes only
✅ **Separate concerns** - UI state vs gameplay state
✅ **Respect viewport** - use SafeArea and letterboxing
✅ **Keep embedding API stable** - `lib/runner.dart` is public
✅ **Use Flutter best practices** - StatelessWidget, composition, etc.

---

**For cross-layer architecture and general rules**, see [lib/AGENTS.md](file:///c:/dev/rpg_runner/lib/AGENTS.md).


===== FILE: lib/ui/components/level_card.dart =====
import 'package:flutter/material.dart';

import '../../core/levels/level_id.dart';
import '../levels/level_id_ui.dart';
import 'level_parallax_preview.dart';

/// A card widget displaying a level with its full parallax background.
///
/// Shows all parallax layers composited as background with the title centered.
/// Use in a row for level selection screens.
class LevelCard extends StatelessWidget {
  const LevelCard({
    super.key,
    required this.levelId,
    required this.onTap,
    this.width,
    this.height = 120,
    this.borderRadius = 12,
  });

  /// The level this card represents.
  final LevelId levelId;

  /// Callback when the card is tapped.
  final VoidCallback onTap;

  /// Card width. If null, uses available space (e.g., in Expanded).
  final double? width;

  /// Card height. Defaults to 120.
  final double height;

  /// Corner radius. Defaults to 12.
  final double borderRadius;

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: onTap,
      child: Container(
        width: width,
        height: height,
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(borderRadius),
          border: Border.all(color: Colors.white, width: 2),
          boxShadow: const [
            BoxShadow(
              color: Colors.black54,
              blurRadius: 8,
              offset: Offset(0, 4),
            ),
          ],
        ),
        child: ClipRRect(
          borderRadius: BorderRadius.circular(borderRadius - 2),
          child: Stack(
            fit: StackFit.expand,
            children: [
              // Full theme preview (no gradient overlay).
              LevelParallaxPreview(themeId: levelId.themeId),

              // Title: readable via shadow, not via a dark scrim.
              Center(
                child: Text(
                  levelId.displayName.toUpperCase(),
                  style: const TextStyle(
                    fontSize: 20,
                    fontWeight: FontWeight.bold,
                    color: Colors.white,
                    letterSpacing: 2,
                    shadows: [
                      Shadow(
                        color: Colors.black,
                        blurRadius: 4,
                        offset: Offset(1, 1),
                      ),
                    ],
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}


===== FILE: lib/ui/components/level_parallax_preview.dart =====
import 'dart:collection';

import 'package:flutter/material.dart';

import '../../game/themes/parallax_theme_registry.dart';

/// Static (non-scrolling) parallax preview for menu cards.
///
/// - Uses ParallaxThemeRegistry as the source of truth.
/// - LRU caches resolved layer AssetImages by themeId.
/// - Precaches per widget lifetime to avoid first-frame hitch.
/// - Never crashes the UI if a layer asset is missing.
class LevelParallaxPreview extends StatefulWidget {
  const LevelParallaxPreview({
    super.key,
    required this.themeId,
    this.baseColor = const Color(0xFF0B1020),
    this.filterQuality = FilterQuality.none,
  });

  final String? themeId;

  /// Fill behind transparent pixels in layers.
  /// Important because MenuScaffold background is black.
  final Color baseColor;

  final FilterQuality filterQuality;

  @override
  State<LevelParallaxPreview> createState() => _LevelParallaxPreviewState();
}

class _LevelParallaxPreviewState extends State<LevelParallaxPreview> {
  // Small LRU (more than enough for current scope: field/forest).
  static const int _maxCacheEntries = 8;
  static final LinkedHashMap<String, List<AssetImage>> _lru = LinkedHashMap();

  String? _cacheKey;
  late List<AssetImage> _layers;
  bool _precached = false;

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();

    final key = widget.themeId ?? '__null__';
    if (_cacheKey == key) return;

    _cacheKey = key;
    _layers = _getOrBuildLayers(widget.themeId);
    _precached = false;

    WidgetsBinding.instance.addPostFrameCallback((_) async {
      if (!mounted || _precached) return;
      _precached = true;

      // Best-effort precache: never throw.
      for (final img in _layers) {
        try {
          await precacheImage(img, context);
        } catch (_) {
          // Ignore missing/bad assets; Image.errorBuilder handles it.
        }
      }
    });
  }

  static List<AssetImage> _getOrBuildLayers(String? themeId) {
    final key = themeId ?? '__null__';

    // LRU hit
    final hit = _lru.remove(key);
    if (hit != null) {
      _lru[key] = hit; // re-insert as most-recent
      return hit;
    }

    final theme = ParallaxThemeRegistry.forThemeId(themeId);

    AssetImage img(String relToImagesFolder) =>
        AssetImage('assets/images/$relToImagesFolder');

    final built = <AssetImage>[
      for (final layer in theme.backgroundLayers) img(layer.assetPath),
      img(theme.groundLayerAsset),
      for (final layer in theme.foregroundLayers) img(layer.assetPath),
    ];

    // LRU insert + evict
    _lru[key] = built;
    while (_lru.length > _maxCacheEntries) {
      _lru.remove(_lru.keys.first);
    }

    return built;
  }

  @override
  Widget build(BuildContext context) {
    return RepaintBoundary(
      child: Stack(
        fit: StackFit.expand,
        children: [
          ColoredBox(color: widget.baseColor),

          for (final provider in _layers)
            Positioned.fill(
              child: Align(
                alignment: Alignment.bottomCenter,
                child: Image(
                  image: provider,
                  fit: BoxFit.cover,
                  alignment: Alignment.bottomCenter,
                  filterQuality: widget.filterQuality,
                  errorBuilder: (context, error, stackTrace) {
                    // If one layer is missing, just skip it visually.
                    return const SizedBox.shrink();
                  },
                ),
              ),
            ),
        ],
      ),
    );
  }
}


===== FILE: lib/ui/components/menu_button.dart =====
import 'package:flutter/material.dart';

/// A simple, reusable button for menu screens.
///
/// Styled for a minimal black/white aesthetic. Use this for main menu,
/// pause menu, and other navigation screens.
class MenuButton extends StatelessWidget {
  const MenuButton({
    super.key,
    required this.label,
    required this.onPressed,
    this.width = 160,
    this.height = 48,
    this.backgroundColor = Colors.white,
    this.foregroundColor = Colors.black,
    this.borderColor,
    this.borderWidth = 2,
    this.fontSize = 16,
  });

  /// The text label displayed on the button.
  final String label;

  /// Callback when the button is pressed.
  final VoidCallback onPressed;

  /// Button width. Defaults to 200.
  final double width;

  /// Button height. Defaults to 56.
  final double height;

  /// Background color. Defaults to white.
  final Color backgroundColor;

  /// Text color. Defaults to black.
  final Color foregroundColor;

  /// Border color. Defaults to foregroundColor if not specified.
  final Color? borderColor;

  /// Border width. Defaults to 2.
  final double borderWidth;

  /// Font size. Defaults to 18.
  final double fontSize;

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      width: width,
      height: height,
      child: OutlinedButton(
        onPressed: onPressed,
        style: OutlinedButton.styleFrom(
          backgroundColor: backgroundColor,
          foregroundColor: foregroundColor,
          side: BorderSide(
            color: borderColor ?? foregroundColor,
            width: borderWidth,
          ),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(8),
          ),
        ),
        child: Text(
          label,
          style: TextStyle(
            fontSize: fontSize,
            fontWeight: FontWeight.bold,
          ),
        ),
      ),
    );
  }
}


===== FILE: lib/ui/components/menu_scaffold.dart =====
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

/// A scaffold wrapper for menu pages with consistent black/white styling.
///
/// Handles:
/// - Black background
/// - Optional AppBar with back button
/// - Immersive mode re-application on build
/// - SafeArea for content
///
/// Use this for all menu pages to maintain consistency and DRY principles.
class MenuScaffold extends StatelessWidget {
  const MenuScaffold({
    super.key,
    required this.child,
    this.title,
    this.showAppBar = true,
  });

  /// The main content of the page.
  final Widget child;

  /// Optional title for the AppBar. If null, no title is shown.
  final String? title;

  /// Whether to show the AppBar with back button. Defaults to true.
  final bool showAppBar;

  @override
  Widget build(BuildContext context) {
    // Re-apply immersive mode to prevent system UI from reappearing
    SystemChrome.setEnabledSystemUIMode(SystemUiMode.immersiveSticky);

    return Scaffold(
      backgroundColor: Colors.black,
      appBar: showAppBar
          ? AppBar(
              title: title != null
                  ? Text(title!, style: const TextStyle(color: Colors.white))
                  : null,
              backgroundColor: Colors.black,
              iconTheme: const IconThemeData(color: Colors.white),
            )
          : null,
      body: SafeArea(child: child),
    );
  }
}


===== FILE: lib/ui/components/overlay_button.dart =====
import 'package:flutter/material.dart';

class OverlayButton extends StatelessWidget {
  const OverlayButton({
    super.key,
    required this.label,
    required this.onPressed,
  });

  final String label;
  final VoidCallback? onPressed;

  @override
  Widget build(BuildContext context) {
    return TextButton(
      onPressed: onPressed,
      style: TextButton.styleFrom(
        foregroundColor: const Color(0xFFFFFFFF),
        backgroundColor: const Color(0xAA000000),
        padding: const EdgeInsets.symmetric(horizontal: 18, vertical: 10),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(10),
          side: const BorderSide(color: Color(0xFFFFFFFF)),
        ),
      ),
      child: Text(
        label,
        style: const TextStyle(fontSize: 14, fontWeight: FontWeight.w600),
      ),
    );
  }
}


===== FILE: lib/ui/components/placeholder_page.dart =====
import 'package:flutter/material.dart';

import 'menu_scaffold.dart';

/// A reusable placeholder page for features not yet implemented.
///
/// Displays the page title and "Coming Soon" text with consistent styling.
/// Use this for any menu pages that are placeholders for future features.
class PlaceholderPage extends StatelessWidget {
  const PlaceholderPage({
    super.key,
    required this.title,
    this.message = 'Coming Soon',
  });

  /// The title shown in the AppBar.
  final String title;

  /// The placeholder message shown in the center. Defaults to "Coming Soon".
  final String message;

  @override
  Widget build(BuildContext context) {
    return MenuScaffold(
      title: title,
      child: Center(
        child: Text(
          message,
          style: const TextStyle(
            fontSize: 24,
            color: Colors.white54,
          ),
        ),
      ),
    );
  }
}


===== FILE: lib/ui/controls/action_button.dart =====
import 'package:flutter/material.dart';

import 'cooldown_ring.dart';

// lib/ui/controls/action_button.dart

class ActionButton extends StatelessWidget {
  const ActionButton({
    super.key,
    required this.label,
    required this.icon,
    required this.onPressed,
    this.affordable = true,
    this.cooldownTicksLeft = 0,
    this.cooldownTicksTotal = 0,
    this.size = 72,
    this.backgroundColor = const Color(0x33000000),
    this.foregroundColor = Colors.white,
    this.labelFontSize = 12,
    this.labelGap = 2,
  });

  final String label;
  final IconData icon;
  final VoidCallback onPressed;
  final bool affordable;
  final int cooldownTicksLeft;
  final int cooldownTicksTotal;
  final double size;
  final Color backgroundColor;
  final Color foregroundColor;
  final double labelFontSize;
  final double labelGap;

  @override
  Widget build(BuildContext context) {
    final interactable = affordable && cooldownTicksLeft <= 0;
    final effectiveForeground =
        affordable ? foregroundColor : _disabledForeground(foregroundColor);
    final effectiveBackground =
        affordable ? backgroundColor : _disabledBackground(backgroundColor);

    return SizedBox(
      width: size,
      height: size,
      child: Stack(
        fit: StackFit.expand,
        children: [
          Material(
            color: effectiveBackground,
            shape: const CircleBorder(),
            child: InkWell(
              customBorder: const CircleBorder(),
              onTapDown: interactable ? (_) => onPressed() : null,
              onTap: null,
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(icon, color: effectiveForeground),
                  SizedBox(height: labelGap),
                  Text(
                    label,
                    style: TextStyle(
                      fontSize: labelFontSize,
                      color: effectiveForeground,
                    ),
                  ),
                ],
              ),
            ),
          ),
          IgnorePointer(
            child: CooldownRing(
              cooldownTicksLeft: cooldownTicksLeft,
              cooldownTicksTotal: cooldownTicksTotal,
            ),
          ),
        ],
      ),
    );
  }

  Color _disabledForeground(Color color) => color.withValues(alpha: 0.35);
  Color _disabledBackground(Color color) =>
      color.withValues(alpha: color.a * 0.6);
}



===== FILE: lib/ui/controls/controls_tuning.dart =====
import 'dart:ui';

import 'package:flutter/foundation.dart';

enum ControlsJoystickKind { fixed, floating }

@immutable
class ControlsTuning {
  const ControlsTuning({
    this.edgePadding = 16,
    this.bottomEdgePadding = 16,
    this.buttonGap = 12,
    this.rowGap = 12,
    this.joystickKind = ControlsJoystickKind.floating,
    this.fixedJoystick = const FixedJoystickTuning(),
    this.floatingJoystick = const FloatingJoystickTuning(),
    this.actionButton = const ActionButtonTuning(),
    this.directionalActionButton = const DirectionalActionButtonTuning(),
  });

  final double edgePadding;
  final double bottomEdgePadding;
  final double buttonGap;
  final double rowGap;

  final ControlsJoystickKind joystickKind;
  final FixedJoystickTuning fixedJoystick;
  final FloatingJoystickTuning floatingJoystick;

  final ActionButtonTuning actionButton;
  final DirectionalActionButtonTuning directionalActionButton;

  static const floating = ControlsTuning();
  static const fixed = ControlsTuning(
    joystickKind: ControlsJoystickKind.fixed,
  );
}

@immutable
class ActionButtonTuning {
  const ActionButtonTuning({
    this.size = 52,
    this.backgroundColor = const Color(0x33000000),
    this.foregroundColor = const Color(0xFFFFFFFF),
    this.labelFontSize = 8,
    this.labelGap = 2,
  });

  final double size;
  final Color backgroundColor;
  final Color foregroundColor;
  final double labelFontSize;
  final double labelGap;
}

@immutable
class DirectionalActionButtonTuning {
  const DirectionalActionButtonTuning({
    this.size = 52,
    this.deadzoneRadius = 12,
    this.backgroundColor = const Color(0x33000000),
    this.foregroundColor = const Color(0xFFFFFFFF),
    this.labelFontSize = 8,
    this.labelGap = 2,
  });

  final double size;
  final double deadzoneRadius;
  final Color backgroundColor;
  final Color foregroundColor;
  final double labelFontSize;
  final double labelGap;
}

@immutable
class FixedJoystickTuning {
  const FixedJoystickTuning({
    this.size = 120,
    this.knobSize = 56,
    this.baseColor = const Color(0x33000000),
    this.baseBorderColor = const Color(0x55FFFFFF),
    this.baseBorderWidth = 1,
    this.knobColor = const Color(0x66FFFFFF),
    this.knobBorderColor = const Color(0x88FFFFFF),
    this.knobBorderWidth = 1,
  });

  final double size;
  final double knobSize;
  final Color baseColor;
  final Color baseBorderColor;
  final double baseBorderWidth;
  final Color knobColor;
  final Color knobBorderColor;
  final double knobBorderWidth;
}

@immutable
class FloatingJoystickTuning {
  const FloatingJoystickTuning({
    this.areaSize = 220,
    this.baseSize = 120,
    this.knobSize = 56,
    this.followSmoothing = 0.25,
    this.baseColor = const Color(0x33000000),
    this.baseBorderColor = const Color(0x55FFFFFF),
    this.baseBorderWidth = 1,
    this.knobColor = const Color(0x66FFFFFF),
    this.knobBorderColor = const Color(0x88FFFFFF),
    this.knobBorderWidth = 1,
  });

  final double areaSize;
  final double baseSize;
  final double knobSize;
  final double followSmoothing;
  final Color baseColor;
  final Color baseBorderColor;
  final double baseBorderWidth;
  final Color knobColor;
  final Color knobBorderColor;
  final double knobBorderWidth;
}


===== FILE: lib/ui/controls/cooldown_ring.dart =====
import 'dart:math' as math;

import 'package:flutter/widgets.dart';

class CooldownRing extends StatelessWidget {
  const CooldownRing({
    super.key,
    required this.cooldownTicksLeft,
    required this.cooldownTicksTotal,
    this.thickness = 3,
    this.trackColor = const Color(0x66FFFFFF),
    this.progressColor = const Color(0xFFFFFFFF),
  });

  final int cooldownTicksLeft;
  final int cooldownTicksTotal;
  final double thickness;
  final Color trackColor;
  final Color progressColor;

  @override
  Widget build(BuildContext context) {
    if (cooldownTicksLeft <= 0 || cooldownTicksTotal <= 0) {
      return const SizedBox.shrink();
    }

    final clampedLeft = cooldownTicksLeft.clamp(0, cooldownTicksTotal);
    final elapsed = 1.0 - (clampedLeft / cooldownTicksTotal);

    return CustomPaint(
      painter: _CooldownRingPainter(
        elapsedFraction: elapsed.clamp(0.0, 1.0),
        thickness: thickness,
        trackColor: trackColor,
        progressColor: progressColor,
      ),
    );
  }
}

class _CooldownRingPainter extends CustomPainter {
  _CooldownRingPainter({
    required this.elapsedFraction,
    required this.thickness,
    required this.trackColor,
    required this.progressColor,
  });

  final double elapsedFraction;
  final double thickness;
  final Color trackColor;
  final Color progressColor;

  @override
  void paint(Canvas canvas, Size size) {
    final inset = thickness / 2;
    final rect = Rect.fromLTWH(
      inset,
      inset,
      size.width - thickness,
      size.height - thickness,
    );

    final trackPaint = Paint()
      ..color = trackColor
      ..style = PaintingStyle.stroke
      ..strokeWidth = thickness;

    final progressPaint = Paint()
      ..color = progressColor
      ..style = PaintingStyle.stroke
      ..strokeWidth = thickness
      ..strokeCap = StrokeCap.round;

    const startAngle = -math.pi / 2;
    canvas.drawArc(rect, startAngle, math.pi * 2, false, trackPaint);
    if (elapsedFraction > 0) {
      canvas.drawArc(
        rect,
        startAngle,
        math.pi * 2 * elapsedFraction,
        false,
        progressPaint,
      );
    }
  }

  @override
  bool shouldRepaint(covariant _CooldownRingPainter oldDelegate) {
    return oldDelegate.elapsedFraction != elapsedFraction ||
        oldDelegate.thickness != thickness ||
        oldDelegate.trackColor != trackColor ||
        oldDelegate.progressColor != progressColor;
  }
}


===== FILE: lib/ui/controls/directional_action_button.dart =====
import 'dart:math' as math;

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

import '../../game/input/aim_preview.dart';
import '../../game/input/aim_quantizer.dart';
import 'cooldown_ring.dart';

class DirectionalActionButton extends StatefulWidget {
  const DirectionalActionButton({
    super.key,
    required this.label,
    required this.icon,
    required this.onAimDir,
    required this.onAimClear,
    required this.onCommit,
    required this.projectileAimPreview,
    this.cancelHitboxRect,
    this.affordable = true,
    this.cooldownTicksLeft = 0,
    this.cooldownTicksTotal = 0,
    this.size = 72,
    this.deadzoneRadius = 12,
    this.backgroundColor = const Color(0x33000000),
    this.foregroundColor = Colors.white,
    this.labelFontSize = 12,
    this.labelGap = 2,
  });

  final String label;
  final IconData icon;
  final void Function(double x, double y) onAimDir;
  final VoidCallback onAimClear;
  final VoidCallback onCommit;
  final AimPreviewModel projectileAimPreview;
  final ValueListenable<Rect?>? cancelHitboxRect;
  final bool affordable;
  final int cooldownTicksLeft;
  final int cooldownTicksTotal;
  final double size;
  final double deadzoneRadius;
  final Color backgroundColor;
  final Color foregroundColor;
  final double labelFontSize;
  final double labelGap;

  @override
  State<DirectionalActionButton> createState() =>
      _DirectionalActionButtonState();
}

class _DirectionalActionButtonState extends State<DirectionalActionButton> {
  int? _pointer;
  bool _canceled = false;

  @override
  Widget build(BuildContext context) {
    final interactable = widget.affordable && widget.cooldownTicksLeft <= 0;
    final effectiveForeground = widget.affordable
        ? widget.foregroundColor
        : _disabledForeground(widget.foregroundColor);
    final effectiveBackground = widget.affordable
        ? widget.backgroundColor
        : _disabledBackground(widget.backgroundColor);

    return SizedBox(
      width: widget.size,
      height: widget.size,
      child: Stack(
        fit: StackFit.expand,
        children: [
          IgnorePointer(
            ignoring: !interactable,
            child: Listener(
              onPointerDown: _handlePointerDown,
              onPointerMove: _handlePointerMove,
              onPointerUp: _handlePointerUp,
              onPointerCancel: _handlePointerCancel,
              child: Material(
                color: effectiveBackground,
                shape: const CircleBorder(),
                child: Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Icon(widget.icon, color: effectiveForeground),
                      SizedBox(height: widget.labelGap),
                      Text(
                        widget.label,
                        style: TextStyle(
                          fontSize: widget.labelFontSize,
                          color: effectiveForeground,
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            ),
          ),
          IgnorePointer(
            child: CooldownRing(
              cooldownTicksLeft: widget.cooldownTicksLeft,
              cooldownTicksTotal: widget.cooldownTicksTotal,
            ),
          ),
        ],
      ),
    );
  }

  void _handlePointerDown(PointerDownEvent event) {
    if (_pointer != null) return;
    _pointer = event.pointer;
    _canceled = false;
    widget.projectileAimPreview.begin();
    widget.onAimClear();
    _updateAim(event.localPosition);
  }

  void _handlePointerMove(PointerMoveEvent event) {
    if (event.pointer != _pointer) return;
    _updateAim(event.localPosition);
  }

  void _handlePointerUp(PointerUpEvent event) {
    if (event.pointer != _pointer) return;

    // Cancel is decided by where the pointer is released in *screen space*.
    // (The cancel hitbox cannot receive pointer events because the pointer
    // started on this button, so we must hit-test using the global position.)
    final cancelRect = widget.cancelHitboxRect?.value;
    if (cancelRect != null && cancelRect.contains(event.position)) {
      _cancelAim();
    }

    if (!_canceled) {
      widget.onCommit();
    }
    _resetAim();
  }

  void _handlePointerCancel(PointerCancelEvent event) {
    if (event.pointer != _pointer) return;
    // System canceled the pointer stream -> treat as Cancel (never commit).
    _cancelAim();
    _resetAim();
  }

  void _updateAim(Offset localPosition) {
    if (_canceled) return;
    final center = Offset(widget.size / 2, widget.size / 2);
    final dx = localPosition.dx - center.dx;
    final dy = localPosition.dy - center.dy;
    final len = math.sqrt(dx * dx + dy * dy);
    if (len <= widget.deadzoneRadius) {
      widget.onAimClear();
      widget.projectileAimPreview.clearAim();
      return;
    }
    final nx = dx / len;
    final ny = dy / len;
    final qx = AimQuantizer.quantize(nx);
    final qy = AimQuantizer.quantize(ny);
    widget.onAimDir(qx, qy);
    widget.projectileAimPreview.updateAim(qx, qy);
  }

  void _cancelAim() {
    if (_canceled) return;
    _canceled = true;
    widget.onAimClear();
    widget.projectileAimPreview.end();
  }

  void _resetAim() {
    _pointer = null;
    _canceled = false;
    widget.onAimClear();
    widget.projectileAimPreview.end();
  }

  Color _disabledForeground(Color color) => color.withValues(alpha: 0.35);

  Color _disabledBackground(Color color) =>
      color.withValues(alpha: color.a * 0.6);
}


===== FILE: lib/ui/controls/fixed_joystick.dart =====
import 'package:flutter/widgets.dart';

/// Fixed-position horizontal joystick.
///
/// - Only outputs an X axis in `[-1, 1]`.
/// - Centered at the widget's bounds; drag left/right to set axis.
class FixedJoystick extends StatefulWidget {
  const FixedJoystick({
    super.key,
    required this.onAxisChanged,
    this.size = 120,
    this.knobSize = 56,
    this.baseColor = const Color(0x33000000),
    this.baseBorderColor = const Color(0x55FFFFFF),
    this.baseBorderWidth = 1,
    this.knobColor = const Color(0x66FFFFFF),
    this.knobBorderColor = const Color(0x88FFFFFF),
    this.knobBorderWidth = 1,
  });

  final ValueChanged<double> onAxisChanged;
  final double size;
  final double knobSize;
  final Color baseColor;
  final Color baseBorderColor;
  final double baseBorderWidth;
  final Color knobColor;
  final Color knobBorderColor;
  final double knobBorderWidth;

  @override
  State<FixedJoystick> createState() => _FixedJoystickState();
}

class _FixedJoystickState extends State<FixedJoystick> {
  double _axis = 0;

  @override
  Widget build(BuildContext context) {
    final baseSize = widget.size;
    final knobSize = widget.knobSize;
    final radius = (baseSize - knobSize) / 2;

    return SizedBox(
      width: baseSize,
      height: baseSize,
      child: GestureDetector(
        onPanStart: (d) => _update(d.localPosition, radius),
        onPanUpdate: (d) => _update(d.localPosition, radius),
        onPanEnd: (_) => _setAxis(0),
        onPanCancel: () => _setAxis(0),
        child: Stack(
          children: [
            Positioned.fill(
              child: Center(
                child: Container(
                  width: baseSize,
                  height: baseSize,
                  decoration: BoxDecoration(
                    color: widget.baseColor,
                    shape: BoxShape.circle,
                    border: Border.all(
                      color: widget.baseBorderColor,
                      width: widget.baseBorderWidth,
                    ),
                  ),
                ),
              ),
            ),
            Positioned.fill(
              child: Center(
                child: Transform.translate(
                  offset: Offset(_axis * radius, 0),
                  child: Container(
                    width: knobSize,
                    height: knobSize,
                    decoration: BoxDecoration(
                      color: widget.knobColor,
                      shape: BoxShape.circle,
                      border: Border.all(
                        color: widget.knobBorderColor,
                        width: widget.knobBorderWidth,
                      ),
                    ),
                  ),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  void _update(Offset local, double radius) {
    final center = Offset(widget.size / 2, widget.size / 2);
    final dx = local.dx - center.dx;
    final clamped = dx.clamp(-radius, radius);
    final axis = radius <= 0 ? 0.0 : clamped / radius;
    _setAxis(axis);
  }

  void _setAxis(double axis) {
    final a = axis.clamp(-1.0, 1.0);
    if (a == _axis) return;
    setState(() => _axis = a);
    widget.onAxisChanged(a);
  }
}


===== FILE: lib/ui/controls/floating_joystick.dart =====
import 'package:flutter/widgets.dart';

/// Floating horizontal joystick.
///
/// - Touch anywhere inside the widget bounds to place the base.
/// - Drag left/right to set axis in `[-1, 1]`.
/// - Soft-follow: when dragged past the knob radius, the base eases toward the
///   pointer so the gesture stays comfortable.
/// - Release to snap back to center and hide.
class FloatingJoystick extends StatefulWidget {
  const FloatingJoystick({
    super.key,
    required this.onAxisChanged,
    this.areaSize = 220,
    this.baseSize = 120,
    this.knobSize = 56,
    this.followSmoothing = 0.25,
    this.baseColor = const Color(0x33000000),
    this.baseBorderColor = const Color(0x55FFFFFF),
    this.baseBorderWidth = 1,
    this.knobColor = const Color(0x66FFFFFF),
    this.knobBorderColor = const Color(0x88FFFFFF),
    this.knobBorderWidth = 1,
  });

  final ValueChanged<double> onAxisChanged;

  /// Size of the touch area (square).
  final double areaSize;

  /// Visual size of the joystick base circle.
  final double baseSize;

  /// Visual size of the joystick knob circle.
  final double knobSize;

  /// How strongly the base follows the pointer when stretched past the knob
  /// radius.
  ///
  /// - `0`: no follow (base stays where pressed).
  /// - `1`: hard follow (base snaps to keep the pointer on the edge).
  final double followSmoothing;
  final Color baseColor;
  final Color baseBorderColor;
  final double baseBorderWidth;
  final Color knobColor;
  final Color knobBorderColor;
  final double knobBorderWidth;

  @override
  State<FloatingJoystick> createState() => _FloatingJoystickState();
}

class _FloatingJoystickState extends State<FloatingJoystick> {
  int? _activePointer;
  Offset? _baseCenter;
  double _axis = 0;

  @override
  Widget build(BuildContext context) {
    final areaSize = widget.areaSize;
    final baseSize = widget.baseSize;
    final knobSize = widget.knobSize;
    final radius = (baseSize - knobSize) / 2;

    return SizedBox(
      width: areaSize,
      height: areaSize,
      child: Listener(
        behavior: HitTestBehavior.opaque,
        onPointerDown: (e) => _onPointerDown(e, radius),
        onPointerMove: (e) => _onPointerMove(e, radius),
        onPointerUp: _onPointerUp,
        onPointerCancel: _onPointerCancel,
        child: Stack(
          children: [
            if (_baseCenter case final baseCenter?) ...[
              _JoystickBase(
                center: baseCenter,
                size: baseSize,
                color: widget.baseColor,
                borderColor: widget.baseBorderColor,
                borderWidth: widget.baseBorderWidth,
              ),
              _JoystickKnob(
                center: baseCenter.translate(_axis * radius, 0),
                size: knobSize,
                color: widget.knobColor,
                borderColor: widget.knobBorderColor,
                borderWidth: widget.knobBorderWidth,
              ),
            ],
          ],
        ),
      ),
    );
  }

  void _onPointerDown(PointerDownEvent event, double radius) {
    if (_activePointer != null) return;
    final center = _clampBaseCenter(event.localPosition);
    setState(() {
      _activePointer = event.pointer;
      _baseCenter = center;
      _axis = 0;
    });
    widget.onAxisChanged(0);
  }

  void _onPointerMove(PointerMoveEvent event, double radius) {
    if (event.pointer != _activePointer) return;
    final baseCenter = _baseCenter;
    if (baseCenter == null) return;

    final pointer = event.localPosition;

    var nextBaseCenter = baseCenter;
    if (radius > 0) {
      final delta = pointer - baseCenter;
      final dist = delta.distance;
      if (dist > radius && dist > 0) {
        final targetBaseCenter = pointer - (delta / dist) * radius;
        final t = widget.followSmoothing.clamp(0.0, 1.0).toDouble();
        nextBaseCenter =
            Offset.lerp(baseCenter, targetBaseCenter, t) ?? baseCenter;
        nextBaseCenter = _clampBaseCenter(nextBaseCenter);
      }
    }

    final dx = pointer.dx - nextBaseCenter.dx;
    final clamped = dx.clamp(-radius, radius);
    final axis = radius <= 0 ? 0.0 : clamped / radius;
    _setBaseAndAxis(baseCenter: nextBaseCenter, axis: axis);
  }

  void _onPointerUp(PointerUpEvent event) {
    if (event.pointer != _activePointer) return;
    _reset();
  }

  void _onPointerCancel(PointerCancelEvent event) {
    if (event.pointer != _activePointer) return;
    _reset();
  }

  Offset _clampBaseCenter(Offset local) {
    final areaSize = widget.areaSize;
    final baseSize = widget.baseSize;
    final halfBase = baseSize / 2;

    if (areaSize <= baseSize) {
      return Offset(areaSize / 2, areaSize / 2);
    }

    final clampedX = local.dx.clamp(halfBase, areaSize - halfBase).toDouble();
    final clampedY = local.dy.clamp(halfBase, areaSize - halfBase).toDouble();
    return Offset(clampedX, clampedY);
  }

  void _reset() {
    final shouldNotify = _axis != 0;
    setState(() {
      _activePointer = null;
      _baseCenter = null;
      _axis = 0;
    });
    if (shouldNotify) widget.onAxisChanged(0);
  }

  void _setBaseAndAxis({required Offset baseCenter, required double axis}) {
    final nextAxis = axis.clamp(-1.0, 1.0);
    final axisChanged = nextAxis != _axis;
    final baseChanged = baseCenter != _baseCenter;
    if (!axisChanged && !baseChanged) return;

    setState(() {
      _baseCenter = baseCenter;
      _axis = nextAxis;
    });
    if (axisChanged) widget.onAxisChanged(nextAxis);
  }
}

class _JoystickBase extends StatelessWidget {
  const _JoystickBase({
    required this.center,
    required this.size,
    required this.color,
    required this.borderColor,
    required this.borderWidth,
  });

  final Offset center;
  final double size;
  final Color color;
  final Color borderColor;
  final double borderWidth;

  @override
  Widget build(BuildContext context) {
    return Positioned(
      left: center.dx - size / 2,
      top: center.dy - size / 2,
      width: size,
      height: size,
      child: Container(
        decoration: BoxDecoration(
          color: color,
          shape: BoxShape.circle,
          border: Border.all(color: borderColor, width: borderWidth),
        ),
      ),
    );
  }
}

class _JoystickKnob extends StatelessWidget {
  const _JoystickKnob({
    required this.center,
    required this.size,
    required this.color,
    required this.borderColor,
    required this.borderWidth,
  });

  final Offset center;
  final double size;
  final Color color;
  final Color borderColor;
  final double borderWidth;

  @override
  Widget build(BuildContext context) {
    return Positioned(
      left: center.dx - size / 2,
      top: center.dy - size / 2,
      width: size,
      height: size,
      child: Container(
        decoration: BoxDecoration(
          color: color,
          shape: BoxShape.circle,
          border: Border.all(color: borderColor, width: borderWidth),
        ),
      ),
    );
  }
}


===== FILE: lib/ui/controls/runner_controls_overlay(radial).dart =====
import 'dart:math' as math;

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

import '../../game/input/aim_preview.dart';
import 'package:rpg_runner/core/snapshots/enums.dart';
import 'action_button.dart';
import 'controls_tuning.dart';
import 'directional_action_button.dart';
import 'fixed_joystick.dart';
import 'floating_joystick.dart';

class RunnerControlsOverlay extends StatelessWidget {
  const RunnerControlsOverlay({
    super.key,
    required this.onMoveAxis,
    required this.onJumpPressed,
    required this.onDashPressed,
    required this.onSecondaryPressed,
    required this.onBonusPressed,
    required this.onBonusCommitted,
    required this.onProjectileCommitted,
    required this.onProjectilePressed,
    required this.onProjectileAimDir,
    required this.onProjectileAimClear,
    required this.projectileAimPreview,
    required this.projectileAffordable,
    required this.projectileCooldownTicksLeft,
    required this.projectileCooldownTicksTotal,
    required this.onMeleeAimDir,
    required this.onMeleeAimClear,
    required this.onMeleeCommitted,
    required this.onMeleePressed,
    required this.meleeAimPreview,
    required this.aimCancelHitboxRect,
    required this.meleeAffordable,
    required this.meleeCooldownTicksLeft,
    required this.meleeCooldownTicksTotal,
    required this.meleeInputMode,
    required this.projectileInputMode,
    required this.bonusInputMode,
    required this.bonusUsesMeleeAim,
    required this.jumpAffordable,
    required this.dashAffordable,
    required this.dashCooldownTicksLeft,
    required this.dashCooldownTicksTotal,
    required this.secondaryAffordable,
    required this.secondaryCooldownTicksLeft,
    required this.secondaryCooldownTicksTotal,
    required this.bonusAffordable,
    required this.bonusCooldownTicksLeft,
    required this.bonusCooldownTicksTotal,
    this.tuning = ControlsTuning.fixed,
  });

  final ValueChanged<double> onMoveAxis;
  final VoidCallback onJumpPressed;
  final VoidCallback onDashPressed;
  final VoidCallback onSecondaryPressed;
  final VoidCallback onBonusPressed;
  final VoidCallback onBonusCommitted;
  final VoidCallback onProjectileCommitted;
  final VoidCallback onProjectilePressed;
  final void Function(double x, double y) onProjectileAimDir;
  final VoidCallback onProjectileAimClear;
  final AimPreviewModel projectileAimPreview;
  final bool projectileAffordable;
  final int projectileCooldownTicksLeft;
  final int projectileCooldownTicksTotal;
  final void Function(double x, double y) onMeleeAimDir;
  final VoidCallback onMeleeAimClear;
  final VoidCallback onMeleeCommitted;
  final VoidCallback onMeleePressed;
  final AimPreviewModel meleeAimPreview;
  final ValueListenable<Rect?> aimCancelHitboxRect;
  final bool meleeAffordable;
  final int meleeCooldownTicksLeft;
  final int meleeCooldownTicksTotal;
  final AbilityInputMode meleeInputMode;
  final AbilityInputMode projectileInputMode;

  final AbilityInputMode bonusInputMode;
  final bool bonusUsesMeleeAim;
  final bool jumpAffordable;
  final bool dashAffordable;
  final int dashCooldownTicksLeft;
  final int dashCooldownTicksTotal;
  final bool secondaryAffordable;
  final int secondaryCooldownTicksLeft;
  final int secondaryCooldownTicksTotal;
  final bool bonusAffordable;
  final int bonusCooldownTicksLeft;
  final int bonusCooldownTicksTotal;
  final ControlsTuning tuning;

  @override
  Widget build(BuildContext context) {
    final t = tuning;
    final action = t.actionButton;
    final directional = t.directionalActionButton;
    final jumpSize = action.size * 1.4;
    final smallActionSize = action.size * 0.9;
    final smallDirectionalSize = directional.size * 0.9;
    final smallDeadzoneRadius = directional.deadzoneRadius * 0.9;

    // Arrange the 5 action slots (Mobility, Secondary, Primary, Projectile, Bonus)
    // in a clean radial arc around the Jump button.

    Offset polar(double radius, double degrees) {
      final radians = degrees * math.pi / 180.0;
      return Offset(math.cos(radians) * radius, math.sin(radians) * radius);
    }

    double rightFor(Offset centerOffset, double targetSize) {
      return t.edgePadding + jumpSize * 0.5 - centerOffset.dx - targetSize * 0.5;
    }

    double bottomFor(Offset centerOffset, double targetSize) {
      return t.edgePadding + jumpSize * 0.5 - centerOffset.dy - targetSize * 0.5;
    }

    final jumpRadius = jumpSize * 0.5;
    final ringGap = t.buttonGap * 0.9;
    final ringRadius =
        jumpRadius + math.max(smallDirectionalSize, smallActionSize) * 0.5 + ringGap;

    // Evenly spread the 5 action buttons over an arc above/left of the jump.
    // Degrees follow the standard unit circle, but note Flutter's Y axis points down.
    const startDeg = 160.0;
    const stepDeg = 35.0;

    final dashOffset = polar(ringRadius, startDeg + stepDeg * 0);
    final meleeOffset = polar(ringRadius, startDeg + stepDeg * 0.2);
    final secondaryOffset = polar(ringRadius, startDeg + stepDeg * 1.6);
    final projectileOffset = polar(ringRadius, startDeg + stepDeg * 3);
    final bonusOffset = polar(ringRadius, startDeg + stepDeg * 4);

    return Stack(
      children: [
        Positioned(
          left: t.edgePadding,
          bottom: t.bottomEdgePadding,
          child: t.joystickKind == ControlsJoystickKind.floating
              ? FloatingJoystick(
                  onAxisChanged: onMoveAxis,
                  areaSize: t.floatingJoystick.areaSize,
                  baseSize: t.floatingJoystick.baseSize,
                  knobSize: t.floatingJoystick.knobSize,
                  followSmoothing: t.floatingJoystick.followSmoothing,
                  baseColor: t.floatingJoystick.baseColor,
                  baseBorderColor: t.floatingJoystick.baseBorderColor,
                  baseBorderWidth: t.floatingJoystick.baseBorderWidth,
                  knobColor: t.floatingJoystick.knobColor,
                  knobBorderColor: t.floatingJoystick.knobBorderColor,
                  knobBorderWidth: t.floatingJoystick.knobBorderWidth,
                )
              : FixedJoystick(
                  onAxisChanged: onMoveAxis,
                  size: t.fixedJoystick.size,
                  knobSize: t.fixedJoystick.knobSize,
                  baseColor: t.fixedJoystick.baseColor,
                  baseBorderColor: t.fixedJoystick.baseBorderColor,
                  baseBorderWidth: t.fixedJoystick.baseBorderWidth,
                  knobColor: t.fixedJoystick.knobColor,
                  knobBorderColor: t.fixedJoystick.knobBorderColor,
                  knobBorderWidth: t.fixedJoystick.knobBorderWidth,
                ),
        ),
        Positioned(
          right: rightFor(projectileOffset, smallDirectionalSize),
          bottom: bottomFor(projectileOffset, smallDirectionalSize),
          child: projectileInputMode == AbilityInputMode.tap
              ? ActionButton(
                  label: 'Projectile',
                  icon: Icons.auto_awesome,
                  onPressed: onProjectilePressed,
                  affordable: projectileAffordable,
                  cooldownTicksLeft: projectileCooldownTicksLeft,
                  cooldownTicksTotal: projectileCooldownTicksTotal,
                  size: smallDirectionalSize,
                  backgroundColor: action.backgroundColor,
                  foregroundColor: action.foregroundColor,
                  labelFontSize: action.labelFontSize,
                  labelGap: action.labelGap,
                )
              : DirectionalActionButton(
                  label: 'Projectile',
                  icon: Icons.auto_awesome,
                  onAimDir: onProjectileAimDir,
                  onAimClear: onProjectileAimClear,
                  onCommit: onProjectileCommitted,
                  projectileAimPreview: projectileAimPreview,
                  cancelHitboxRect: aimCancelHitboxRect,
                  affordable: projectileAffordable,
                  cooldownTicksLeft: projectileCooldownTicksLeft,
                  cooldownTicksTotal: projectileCooldownTicksTotal,
                  size: smallDirectionalSize,
                  deadzoneRadius: smallDeadzoneRadius,
                  backgroundColor: directional.backgroundColor,
                  foregroundColor: directional.foregroundColor,
                  labelFontSize: directional.labelFontSize,
                  labelGap: directional.labelGap,
                ),
        ),
        Positioned(
          right: rightFor(bonusOffset, smallActionSize),
          bottom: bottomFor(bonusOffset, smallActionSize),
          child: bonusInputMode == AbilityInputMode.tap
              ? ActionButton(
                  label: 'Bonus',
                  icon: Icons.star,
                  onPressed: onBonusPressed,
                  affordable: bonusAffordable,
                  cooldownTicksLeft: bonusCooldownTicksLeft,
                  cooldownTicksTotal: bonusCooldownTicksTotal,
                  size: smallActionSize,
                  backgroundColor: action.backgroundColor,
                  foregroundColor: action.foregroundColor,
                  labelFontSize: action.labelFontSize,
                  labelGap: action.labelGap,
                )
              : DirectionalActionButton(
                  label: 'Bonus',
                  icon: Icons.star,
                  onAimDir: bonusUsesMeleeAim ? onMeleeAimDir : onProjectileAimDir,
                  onAimClear: bonusUsesMeleeAim ? onMeleeAimClear : onProjectileAimClear,
                  onCommit: onBonusCommitted,
                  projectileAimPreview:
                      bonusUsesMeleeAim ? meleeAimPreview : projectileAimPreview,
                  cancelHitboxRect: aimCancelHitboxRect,
                  affordable: bonusAffordable,
                  cooldownTicksLeft: bonusCooldownTicksLeft,
                  cooldownTicksTotal: bonusCooldownTicksTotal,
                  size: smallDirectionalSize,
                  deadzoneRadius: smallDeadzoneRadius,
                  backgroundColor: directional.backgroundColor,
                  foregroundColor: directional.foregroundColor,
                  labelFontSize: directional.labelFontSize,
                  labelGap: directional.labelGap,
                ),
        ),
        Positioned(
          right: rightFor(secondaryOffset, smallActionSize),
          bottom: bottomFor(secondaryOffset, smallActionSize),
          child: ActionButton(
            label: 'Sec',
            icon: Icons.shield,
            onPressed: onSecondaryPressed,
            affordable: secondaryAffordable,
            cooldownTicksLeft: secondaryCooldownTicksLeft,
            cooldownTicksTotal: secondaryCooldownTicksTotal,
            size: smallActionSize,
            backgroundColor: action.backgroundColor,
            foregroundColor: action.foregroundColor,
            labelFontSize: action.labelFontSize,
            labelGap: action.labelGap,
          ),
        ),
        Positioned(
          right: rightFor(meleeOffset, smallDirectionalSize),
          bottom: bottomFor(meleeOffset, smallDirectionalSize),
          child: meleeInputMode == AbilityInputMode.tap
              ? ActionButton(
                  label: 'Atk',
                  icon: Icons.close,
                  onPressed: onMeleePressed,
                  affordable: meleeAffordable,
                  cooldownTicksLeft: meleeCooldownTicksLeft,
                  cooldownTicksTotal: meleeCooldownTicksTotal,
                  size: smallDirectionalSize,
                  backgroundColor: action.backgroundColor,
                  foregroundColor: action.foregroundColor,
                  labelFontSize: action.labelFontSize,
                  labelGap: action.labelGap,
                )
              : DirectionalActionButton(
                  label: 'Atk',
                  icon: Icons.close,
                  onAimDir: onMeleeAimDir,
                  onAimClear: onMeleeAimClear,
                  onCommit: onMeleeCommitted,
                  projectileAimPreview: meleeAimPreview,
                  cancelHitboxRect: aimCancelHitboxRect,
                  affordable: meleeAffordable,
                  cooldownTicksLeft: meleeCooldownTicksLeft,
                  cooldownTicksTotal: meleeCooldownTicksTotal,
                  size: smallDirectionalSize,
                  deadzoneRadius: smallDeadzoneRadius,
                  backgroundColor: directional.backgroundColor,
                  foregroundColor: directional.foregroundColor,
                  labelFontSize: directional.labelFontSize,
                  labelGap: directional.labelGap,
                ),
        ),
        Positioned(
          right: rightFor(dashOffset, smallActionSize),
          bottom: bottomFor(dashOffset, smallActionSize),
          child: ActionButton(
            label: 'Dash',
            icon: Icons.flash_on,
            onPressed: onDashPressed,
            affordable: dashAffordable,
            cooldownTicksLeft: dashCooldownTicksLeft,
            cooldownTicksTotal: dashCooldownTicksTotal,
            size: smallActionSize,
            backgroundColor: action.backgroundColor,
            foregroundColor: action.foregroundColor,
            labelFontSize: action.labelFontSize,
            labelGap: action.labelGap,
          ),
        ),
        Positioned(
          right: t.edgePadding,
          bottom: t.edgePadding,
          child: ActionButton(
            label: 'Jump',
            icon: Icons.arrow_upward,
            onPressed: onJumpPressed,
            affordable: jumpAffordable,
            size: jumpSize,
            backgroundColor: action.backgroundColor,
            foregroundColor: action.foregroundColor,
            labelFontSize: action.labelFontSize,
            labelGap: action.labelGap,
          ),
        ),
      ],
    );
  }
}


===== FILE: lib/ui/controls/runner_controls_overlay.dart =====
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

import '../../game/input/aim_preview.dart';
import 'package:rpg_runner/core/snapshots/enums.dart';
import 'action_button.dart';
import 'controls_tuning.dart';
import 'directional_action_button.dart';
import 'fixed_joystick.dart';
import 'floating_joystick.dart';

class RunnerControlsOverlay extends StatelessWidget {
  const RunnerControlsOverlay({
    super.key,
    required this.onMoveAxis,
    required this.onJumpPressed,
    required this.onDashPressed,
    required this.onSecondaryPressed,
    required this.onBonusPressed,
    required this.onBonusCommitted,
    required this.onProjectileCommitted,
    required this.onProjectilePressed,
    required this.onProjectileAimDir,
    required this.onProjectileAimClear,
    required this.projectileAimPreview,
    required this.projectileAffordable,
    required this.projectileCooldownTicksLeft,
    required this.projectileCooldownTicksTotal,
    required this.onMeleeAimDir,
    required this.onMeleeAimClear,
    required this.onMeleeCommitted,
    required this.onMeleePressed,
    required this.meleeAimPreview,
    required this.aimCancelHitboxRect,
    required this.meleeAffordable,
    required this.meleeCooldownTicksLeft,
    required this.meleeCooldownTicksTotal,
    required this.meleeInputMode,
    required this.projectileInputMode,
    required this.bonusInputMode,
    required this.bonusUsesMeleeAim,
    required this.jumpAffordable,
    required this.dashAffordable,
    required this.dashCooldownTicksLeft,
    required this.dashCooldownTicksTotal,
    required this.secondaryAffordable,
    required this.secondaryCooldownTicksLeft,
    required this.secondaryCooldownTicksTotal,
    required this.bonusAffordable,
    required this.bonusCooldownTicksLeft,
    required this.bonusCooldownTicksTotal,
    this.tuning = ControlsTuning.fixed,
  });

  final ValueChanged<double> onMoveAxis;
  final VoidCallback onJumpPressed;
  final VoidCallback onDashPressed;
  final VoidCallback onSecondaryPressed;
  final VoidCallback onBonusPressed;
  final VoidCallback onBonusCommitted;
  final VoidCallback onProjectileCommitted;
  final VoidCallback onProjectilePressed;
  final void Function(double x, double y) onProjectileAimDir;
  final VoidCallback onProjectileAimClear;
  final AimPreviewModel projectileAimPreview;
  final bool projectileAffordable;
  final int projectileCooldownTicksLeft;
  final int projectileCooldownTicksTotal;
  final void Function(double x, double y) onMeleeAimDir;
  final VoidCallback onMeleeAimClear;
  final VoidCallback onMeleeCommitted;
  final VoidCallback onMeleePressed;
  final AimPreviewModel meleeAimPreview;
  final ValueListenable<Rect?> aimCancelHitboxRect;
  final bool meleeAffordable;
  final int meleeCooldownTicksLeft;
  final int meleeCooldownTicksTotal;
  final AbilityInputMode meleeInputMode;
  final AbilityInputMode projectileInputMode;

  final AbilityInputMode bonusInputMode;
  final bool bonusUsesMeleeAim;
  final bool jumpAffordable;
  final bool dashAffordable;
  final int dashCooldownTicksLeft;
  final int dashCooldownTicksTotal;
  final bool secondaryAffordable;
  final int secondaryCooldownTicksLeft;
  final int secondaryCooldownTicksTotal;
  final bool bonusAffordable;
  final int bonusCooldownTicksLeft;
  final int bonusCooldownTicksTotal;
  final ControlsTuning tuning;

  @override
  Widget build(BuildContext context) {
    final t = tuning;
    final action = t.actionButton;
    final directional = t.directionalActionButton;

    // Uniform size for all buttons in the grid
    final btnSize = action.size;

    // Grid configuration
    final gap = t.buttonGap;

    // 2x3 Grid definition (col, row) -> 0-indexed
    // col 0 is rightmost, row 0 is bottom
    //
    // [Secondary (0,1)] [Projectile (1,1)] [Bonus (2,1)]
    // [Jump (0,0)]      [Melee (1,0)]      [Dash (2,0)]

    double rightForCol(int col) {
      return t.edgePadding + col * (btnSize + gap);
    }

    double bottomForRow(int row) {
      return t.edgePadding + row * (btnSize + gap);
    }

    return Stack(
      children: [
        Positioned(
          left: t.edgePadding,
          bottom: t.bottomEdgePadding,
          child: t.joystickKind == ControlsJoystickKind.floating
              ? FloatingJoystick(
                  onAxisChanged: onMoveAxis,
                  areaSize: t.floatingJoystick.areaSize,
                  baseSize: t.floatingJoystick.baseSize,
                  knobSize: t.floatingJoystick.knobSize,
                  followSmoothing: t.floatingJoystick.followSmoothing,
                  baseColor: t.floatingJoystick.baseColor,
                  baseBorderColor: t.floatingJoystick.baseBorderColor,
                  baseBorderWidth: t.floatingJoystick.baseBorderWidth,
                  knobColor: t.floatingJoystick.knobColor,
                  knobBorderColor: t.floatingJoystick.knobBorderColor,
                  knobBorderWidth: t.floatingJoystick.knobBorderWidth,
                )
              : FixedJoystick(
                  onAxisChanged: onMoveAxis,
                  size: t.fixedJoystick.size,
                  knobSize: t.fixedJoystick.knobSize,
                  baseColor: t.fixedJoystick.baseColor,
                  baseBorderColor: t.fixedJoystick.baseBorderColor,
                  baseBorderWidth: t.fixedJoystick.baseBorderWidth,
                  knobColor: t.fixedJoystick.knobColor,
                  knobBorderColor: t.fixedJoystick.knobBorderColor,
                  knobBorderWidth: t.fixedJoystick.knobBorderWidth,
                ),
        ),

        // --- Row 1 (Top) ---

        // Mob (Dash): Col 0, Row 1 (Top Right)
        Positioned(
          right: rightForCol(0),
          bottom: bottomForRow(1),
          child: ActionButton(
            label: 'Mob',
            icon: Icons.flash_on,
            onPressed: onDashPressed,
            affordable: dashAffordable,
            cooldownTicksLeft: dashCooldownTicksLeft,
            cooldownTicksTotal: dashCooldownTicksTotal,
            size: btnSize,
            backgroundColor: action.backgroundColor,
            foregroundColor: action.foregroundColor,
            labelFontSize: action.labelFontSize,
            labelGap: action.labelGap,
          ),
        ),

        // Prim (Melee): Col 1, Row 1 (Top Middle)
        Positioned(
          right: rightForCol(1),
          bottom: bottomForRow(1),
          child: meleeInputMode == AbilityInputMode.tap
              ? ActionButton(
                  label: 'Prim',
                  icon: Icons.close,
                  onPressed: onMeleePressed,
                  affordable: meleeAffordable,
                  cooldownTicksLeft: meleeCooldownTicksLeft,
                  cooldownTicksTotal: meleeCooldownTicksTotal,
                  size: btnSize,
                  backgroundColor: action.backgroundColor,
                  foregroundColor: action.foregroundColor,
                  labelFontSize: action.labelFontSize,
                  labelGap: action.labelGap,
                )
              : DirectionalActionButton(
                  label: 'Prim',
                  icon: Icons.close,
                  onAimDir: onMeleeAimDir,
                  onAimClear: onMeleeAimClear,
                  onCommit: onMeleeCommitted,
                  projectileAimPreview: meleeAimPreview,
                  cancelHitboxRect: aimCancelHitboxRect,
                  affordable: meleeAffordable,
                  cooldownTicksLeft: meleeCooldownTicksLeft,
                  cooldownTicksTotal: meleeCooldownTicksTotal,
                  size: btnSize,
                  deadzoneRadius: directional.deadzoneRadius,
                  backgroundColor: directional.backgroundColor,
                  foregroundColor: directional.foregroundColor,
                  labelFontSize: directional.labelFontSize,
                  labelGap: directional.labelGap,
                ),
        ),

        // Proj (Projectile): Col 2, Row 1 (Top Left)
        Positioned(
          right: rightForCol(2),
          bottom: bottomForRow(1),
          child: projectileInputMode == AbilityInputMode.tap
              ? ActionButton(
                  label: 'Proj',
                  icon: Icons.auto_awesome,
                  onPressed: onProjectilePressed,
                  affordable: projectileAffordable,
                  cooldownTicksLeft: projectileCooldownTicksLeft,
                  cooldownTicksTotal: projectileCooldownTicksTotal,
                  size: btnSize,
                  backgroundColor: action.backgroundColor,
                  foregroundColor: action.foregroundColor,
                  labelFontSize: action.labelFontSize,
                  labelGap: action.labelGap,
                )
              : DirectionalActionButton(
                  label: 'Proj',
                  icon: Icons.auto_awesome,
                  onAimDir: onProjectileAimDir,
                  onAimClear: onProjectileAimClear,
                  onCommit: onProjectileCommitted,
                  projectileAimPreview: projectileAimPreview,
                  cancelHitboxRect: aimCancelHitboxRect,
                  affordable: projectileAffordable,
                  cooldownTicksLeft: projectileCooldownTicksLeft,
                  cooldownTicksTotal: projectileCooldownTicksTotal,
                  size: btnSize,
                  deadzoneRadius:
                      directional.deadzoneRadius, // Use standard deadzone
                  backgroundColor: directional.backgroundColor,
                  foregroundColor: directional.foregroundColor,
                  labelFontSize: directional.labelFontSize,
                  labelGap: directional.labelGap,
                ),
        ),

        // --- Row 0 (Bottom) ---

        // Jump: Col 0, Row 0 (Bottom Right)
        Positioned(
          right: rightForCol(0),
          bottom: bottomForRow(0),
          child: ActionButton(
            label: 'Jump',
            icon: Icons.arrow_upward,
            onPressed: onJumpPressed,
            affordable: jumpAffordable,
            size: btnSize,
            backgroundColor: action.backgroundColor,
            foregroundColor: action.foregroundColor,
            labelFontSize: action.labelFontSize,
            labelGap: action.labelGap,
          ),
        ),

        // Sec (Secondary): Col 1, Row 0 (Bottom Middle)
        Positioned(
          right: rightForCol(1),
          bottom: bottomForRow(0),
          child: ActionButton(
            label: 'Sec',
            icon: Icons.shield,
            onPressed: onSecondaryPressed,
            affordable: secondaryAffordable,
            cooldownTicksLeft: secondaryCooldownTicksLeft,
            cooldownTicksTotal: secondaryCooldownTicksTotal,
            size: btnSize,
            backgroundColor: action.backgroundColor,
            foregroundColor: action.foregroundColor,
            labelFontSize: action.labelFontSize,
            labelGap: action.labelGap,
          ),
        ),

        // Bonus: Col 2, Row 0 (Bottom Left)
        Positioned(
          right: rightForCol(2),
          bottom: bottomForRow(0),
          child: bonusInputMode == AbilityInputMode.tap
              ? ActionButton(
                  label: 'Bonus',
                  icon: Icons.star,
                  onPressed: onBonusPressed,
                  affordable: bonusAffordable,
                  cooldownTicksLeft: bonusCooldownTicksLeft,
                  cooldownTicksTotal: bonusCooldownTicksTotal,
                  size: btnSize,
                  backgroundColor: action.backgroundColor,
                  foregroundColor: action.foregroundColor,
                  labelFontSize: action.labelFontSize,
                  labelGap: action.labelGap,
                )
              : DirectionalActionButton(
                  label: 'Bonus',
                  icon: Icons.star,
                  onAimDir: bonusUsesMeleeAim
                      ? onMeleeAimDir
                      : onProjectileAimDir,
                  onAimClear: bonusUsesMeleeAim
                      ? onMeleeAimClear
                      : onProjectileAimClear,
                  onCommit: onBonusCommitted,
                  projectileAimPreview: bonusUsesMeleeAim
                      ? meleeAimPreview
                      : projectileAimPreview,
                  cancelHitboxRect: aimCancelHitboxRect,
                  affordable: bonusAffordable,
                  cooldownTicksLeft: bonusCooldownTicksLeft,
                  cooldownTicksTotal: bonusCooldownTicksTotal,
                  size: btnSize,
                  deadzoneRadius: directional.deadzoneRadius,
                  backgroundColor: directional.backgroundColor,
                  foregroundColor: directional.foregroundColor,
                  labelFontSize: directional.labelFontSize,
                  labelGap: directional.labelGap,
                ),
        ),
      ],
    );
  }
}


===== FILE: lib/ui/dev_menu_page.dart =====
import 'package:flutter/material.dart';

import 'menus/runner_menu_page.dart';

/// Development-only menu used by the standalone host app (`lib/main.dart`).
///
/// Not part of the embeddable runner API. Host apps should integrate the game
/// via `RunnerGameWidget` / `createRunnerGameRoute` (see `lib/runner.dart`).
class DevMenuPage extends StatelessWidget {
  const DevMenuPage({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text(
          'rpg Runner (Dev)',
          style: TextStyle(color: Colors.white),
        ),
        backgroundColor: Color.fromARGB(255, 6, 21, 48),
      ),
      body: Center(
        child: FilledButton(
          onPressed: () {
            Navigator.of(context).push(
              MaterialPageRoute<void>(
                builder: (context) => const RunnerMenuPage(),
              ),
            );
          },
          child: const Text('Menu'),
        ),
      ),
    );
  }
}


===== FILE: lib/ui/hud/game/aim_cancel_button_overlay.dart =====
import 'package:flutter/material.dart';

import '../../../game/input/aim_preview.dart';

/// Visual-only cancel affordance for aimed actions.
///
/// Important: this widget does *not* receive pointer events when the player
/// started the gesture on an action button (hit testing is frozen on pointer
/// down). The action buttons must hit-test this widget's global rect on release.
class AimCancelButtonOverlay extends StatefulWidget {
  const AimCancelButtonOverlay({
    super.key,
    required this.projectileAimPreview,
    required this.meleeAimPreview,
    required this.hitboxRect,
  });

  final AimPreviewModel projectileAimPreview;
  final AimPreviewModel meleeAimPreview;

  /// Global rect (screen space) of the cancel hitbox.
  ///
  /// Directional buttons read this on pointer-up to decide whether to cancel.
  final ValueNotifier<Rect?> hitboxRect;

  @override
  State<AimCancelButtonOverlay> createState() => _AimCancelButtonOverlayState();
}

class _AimCancelButtonOverlayState extends State<AimCancelButtonOverlay> {
  final GlobalKey _hitboxKey = GlobalKey();

  @override
  void initState() {
    super.initState();
    widget.projectileAimPreview.addListener(_onAimChanged);
    widget.meleeAimPreview.addListener(_onAimChanged);
    _onAimChanged();
  }

  @override
  void didUpdateWidget(covariant AimCancelButtonOverlay oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.projectileAimPreview != widget.projectileAimPreview) {
      oldWidget.projectileAimPreview.removeListener(_onAimChanged);
      widget.projectileAimPreview.addListener(_onAimChanged);
    }
    if (oldWidget.meleeAimPreview != widget.meleeAimPreview) {
      oldWidget.meleeAimPreview.removeListener(_onAimChanged);
      widget.meleeAimPreview.addListener(_onAimChanged);
    }
    if (oldWidget.hitboxRect != widget.hitboxRect) {
      // Force recompute if the target notifier changed.
      WidgetsBinding.instance.addPostFrameCallback((_) => _syncHitboxRect());
    }
    _onAimChanged();
  }

  @override
  void dispose() {
    widget.projectileAimPreview.removeListener(_onAimChanged);
    widget.meleeAimPreview.removeListener(_onAimChanged);
    widget.hitboxRect.value = null;
    super.dispose();
  }

  bool get _active =>
      widget.projectileAimPreview.value.active || widget.meleeAimPreview.value.active;

  void _onAimChanged() {
    if (!mounted) return;
    setState(() {});
    WidgetsBinding.instance.addPostFrameCallback((_) => _syncHitboxRect());
  }

  void _syncHitboxRect() {
    if (!mounted) return;

    if (!_active) {
      if (widget.hitboxRect.value != null) {
        widget.hitboxRect.value = null;
      }
      return;
    }

    final ctx = _hitboxKey.currentContext;
    if (ctx == null) return;
    final ro = ctx.findRenderObject();
    if (ro is! RenderBox || !ro.hasSize) return;

    final topLeft = ro.localToGlobal(Offset.zero);
    final rect = topLeft & ro.size;

    if (widget.hitboxRect.value != rect) {
      widget.hitboxRect.value = rect;
    }
  }

  @override
  Widget build(BuildContext context) {
    if (!_active) return const SizedBox.shrink();

    // Fixed screen-space location between clock (top-center) and distance (top-right).
    // The hitbox is intentionally larger than the icon for mobile ergonomics.
    return Positioned(
      top: 56,
      right: 180,
      child: IgnorePointer(
        // Visual only; directional buttons do the hit-test in screen space.
        ignoring: true,
        child: SizedBox(
          key: _hitboxKey,
          width: 56,
          height: 56,
          child: DecoratedBox(
            decoration: BoxDecoration(
              color: const Color.fromARGB(26, 255, 0, 0),
              borderRadius: BorderRadius.circular(28),
            ),
            child: const Center(
              child: Icon(
                Icons.close,
                size: 22,
                color: Colors.white,
              ),
            ),
          ),
        ),
      ),
    );
  }
}


===== FILE: lib/ui/hud/game/exit_button_overlay.dart =====
import 'package:flutter/material.dart';

class ExitButtonOverlay extends StatelessWidget {
  const ExitButtonOverlay({
    super.key,
    required this.onPressed,
    required this.highlight,
  });

  final VoidCallback? onPressed;
  final bool highlight;

  @override
  Widget build(BuildContext context) {
    return Align(
      alignment: Alignment.topRight,
      child: Padding(
        padding: const EdgeInsets.all(8),
        child: IconButton(
          onPressed: onPressed,
          icon: const Icon(Icons.close),
          color: highlight ? Colors.white : null,
        ),
      ),
    );
  }
}


===== FILE: lib/ui/hud/game/game_overlay.dart =====
import 'package:flutter/widgets.dart';

import '../../../game/game_controller.dart';
import '../../../game/input/aim_preview.dart';
import '../../../game/input/runner_input_router.dart';
import '../../controls/runner_controls_overlay.dart';
import 'package:rpg_runner/core/abilities/ability_def.dart';
import '../../runner_game_ui_state.dart';
import 'pause_overlay.dart';
import 'ready_overlay.dart';
import 'top_center_hud_overlay.dart';
import 'top_left_hud_overlay.dart';
import 'top_right_hud_overlay.dart';
import 'aim_cancel_button_overlay.dart';

class GameOverlay extends StatelessWidget {
  const GameOverlay({
    super.key,
    required this.controller,
    required this.input,
    required this.projectileAimPreview,
    required this.meleeAimPreview,
    required this.aimCancelHitboxRect,
    required this.uiState,
    required this.onStart,
    required this.onTogglePause,
    required this.showExitButton,
    required this.onExit,
    required this.exitConfirmOpen,
    required this.onExitConfirmResume,
    required this.onExitConfirmExit,
  });

  final GameController controller;
  final RunnerInputRouter input;
  final AimPreviewModel projectileAimPreview;
  final AimPreviewModel meleeAimPreview;
  final ValueNotifier<Rect?> aimCancelHitboxRect;
  final RunnerGameUiState uiState;
  final VoidCallback onStart;
  final VoidCallback onTogglePause;
  final bool showExitButton;
  final VoidCallback? onExit;
  final bool exitConfirmOpen;
  final VoidCallback onExitConfirmResume;
  final VoidCallback onExitConfirmExit;

  @override
  Widget build(BuildContext context) {
    final hud = controller.snapshot.hud;

    return Stack(
      fit: StackFit.expand,
      children: [
        IgnorePointer(
          ignoring: !uiState.isRunning,
          child: RunnerControlsOverlay(
            onMoveAxis: input.setMoveAxis,
            onJumpPressed: input.pressJump,
            onDashPressed: input.pressDash,
            onSecondaryPressed: input.pressSecondary,
            onBonusPressed: input.pressBonus,
            onBonusCommitted: () => input.commitBonusWithAim(
              clearAim: true,
              usesMeleeAim: hud.bonusUsesMeleeAim,
            ),
            onProjectileCommitted: () =>
                input.commitProjectileWithAim(clearAim: true),
            onProjectilePressed: input.pressProjectile,
            onProjectileAimDir: input.setProjectileAimDir,
            onProjectileAimClear: input.clearProjectileAimDir,
            projectileAimPreview: projectileAimPreview,
            projectileAffordable: hud.canAffordProjectile,
            projectileCooldownTicksLeft:
                hud.cooldownTicksLeft[CooldownGroup.projectile],
            projectileCooldownTicksTotal:
                hud.cooldownTicksTotal[CooldownGroup.projectile],
            onMeleeAimDir: input.setMeleeAimDir,
            onMeleeAimClear: input.clearMeleeAimDir,
            onMeleeCommitted: input.commitMeleeStrike,
            onMeleePressed: input.pressStrike,
            meleeAimPreview: meleeAimPreview,
            aimCancelHitboxRect: aimCancelHitboxRect,
            meleeAffordable: hud.canAffordMelee,
            meleeCooldownTicksLeft:
                hud.cooldownTicksLeft[CooldownGroup.primary],
            meleeCooldownTicksTotal:
                hud.cooldownTicksTotal[CooldownGroup.primary],
            meleeInputMode: hud.meleeInputMode,
            projectileInputMode: hud.projectileInputMode,
            bonusInputMode: hud.bonusInputMode,
            bonusUsesMeleeAim: hud.bonusUsesMeleeAim,
            jumpAffordable: hud.canAffordJump,
            dashAffordable: hud.canAffordDash,
            dashCooldownTicksLeft:
                hud.cooldownTicksLeft[CooldownGroup.mobility],
            dashCooldownTicksTotal:
                hud.cooldownTicksTotal[CooldownGroup.mobility],
            secondaryAffordable: hud.canAffordSecondary,
            secondaryCooldownTicksLeft:
                hud.cooldownTicksLeft[CooldownGroup.secondary],
            secondaryCooldownTicksTotal:
                hud.cooldownTicksTotal[CooldownGroup.secondary],
            bonusAffordable: hud.canAffordBonus,
            bonusCooldownTicksLeft:
                hud.cooldownTicksLeft[CooldownGroup.bonus0],
            bonusCooldownTicksTotal:
                hud.cooldownTicksTotal[CooldownGroup.bonus0],
          ),
        ),
        PauseOverlay(
          visible: uiState.showPauseOverlay,
          exitConfirmOpen: exitConfirmOpen,
          onResume: onExitConfirmResume,
          onExit: onExitConfirmExit,
        ),
        ReadyOverlay(visible: uiState.showReadyOverlay, onTap: onStart),
        Align(
          alignment: Alignment.topLeft,
          child: Padding(
            padding: const EdgeInsets.all(12),
            child: TopLeftHudOverlay(controller: controller),
          ),
        ),
        TopCenterHudOverlay(
          controller: controller,
          uiState: uiState,
          onStart: onStart,
          onTogglePause: onTogglePause,
        ),
        AimCancelButtonOverlay(
          projectileAimPreview: projectileAimPreview,
          meleeAimPreview: meleeAimPreview,
          hitboxRect: aimCancelHitboxRect,
        ),
        TopRightHudOverlay(
          controller: controller,
          showExitButton: showExitButton,
          onExit: onExit,
        ),
      ],
    );
  }
}


===== FILE: lib/ui/hud/game/pause_overlay.dart =====
import 'package:flutter/material.dart';

import '../../components/overlay_button.dart';

class PauseOverlay extends StatelessWidget {
  const PauseOverlay({
    super.key,
    required this.visible,
    required this.exitConfirmOpen,
    required this.onResume,
    required this.onExit,
  });

  final bool visible;
  final bool exitConfirmOpen;
  final VoidCallback onResume;
  final VoidCallback onExit;

  @override
  Widget build(BuildContext context) {
    if (!visible) return const SizedBox.shrink();

    return SizedBox.expand(
      child: ColoredBox(
        color: const Color(0x66000000),
        child: SafeArea(
          minimum: const EdgeInsets.all(18),
          child: Center(
            child: exitConfirmOpen
                ? Column(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      const Text(
                        'Want to exit?',
                        style: TextStyle(
                          color: Color(0xFFFFFFFF),
                          fontSize: 22,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                      const SizedBox(height: 14),
                      Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          OverlayButton(label: 'Resume', onPressed: onResume),
                          const SizedBox(width: 12),
                          OverlayButton(label: 'Exit', onPressed: onExit),
                        ],
                      ),
                    ],
                  )
                : const SizedBox.shrink(),
          ),
        ),
      ),
    );
  }
}


===== FILE: lib/ui/hud/game/ready_overlay.dart =====
import 'package:flutter/widgets.dart';

class ReadyOverlay extends StatelessWidget {
  const ReadyOverlay({super.key, required this.visible, required this.onTap});

  final bool visible;
  final VoidCallback onTap;

  @override
  Widget build(BuildContext context) {
    if (!visible) return const SizedBox.shrink();

    return GestureDetector(
      behavior: HitTestBehavior.opaque,
      onTap: onTap,
      child: const ColoredBox(
        color: Color(0x88000000),
        child: Center(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Text(
                'Tap to start',
                style: TextStyle(
                  color: Color(0xFFFFFFFF),
                  fontSize: 28,
                  fontWeight: FontWeight.w600,
                ),
              ),
              SizedBox(height: 8),
              Text(
                'Survive as long as possible',
                style: TextStyle(color: Color(0xB3FFFFFF), fontSize: 14),
              ),
            ],
          ),
        ),
      ),
    );
  }
}


===== FILE: lib/ui/hud/game/score_overlay.dart =====
import 'dart:ui' show Color, FontFeature;

import 'package:flutter/widgets.dart';

import '../../../game/game_controller.dart';

class ScoreOverlay extends StatelessWidget {
  const ScoreOverlay({
    super.key,
    required this.controller,
    this.padding = const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
  });

  final GameController controller;
  final EdgeInsets padding;

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: controller,
      builder: (context, _) {
        final distanceMeters =
            (controller.snapshot.distance / 100.0).floor();
        final collectibles = controller.snapshot.hud.collectibles;
        return IgnorePointer(
          child: RepaintBoundary(
            child: Container(
              padding: padding,
              decoration: BoxDecoration(
                color: const Color(0x66000000),
                borderRadius: BorderRadius.circular(10),
              ),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Text(
                    'Distance ${distanceMeters}m',
                    textAlign: TextAlign.center,
                    style: const TextStyle(
                      fontSize: 14,
                      color: Color(0xFFFFFFFF),
                      fontFeatures: [FontFeature.tabularFigures()],
                    ),
                  ),
                  const SizedBox(height: 2),
                  Text(
                    'Collectibles $collectibles',
                    textAlign: TextAlign.center,
                    style: const TextStyle(
                      fontSize: 14,
                      color: Color(0xFFFFFFFF),
                      fontFeatures: [FontFeature.tabularFigures()],
                    ),
                  ),
                ],
              ),
            ),
          ),
        );
      },
    );
  }
}


===== FILE: lib/ui/hud/game/start_pause_button_overlay.dart =====
import 'package:flutter/material.dart';

import '../../runner_game_ui_state.dart';

class StartPauseButtonOverlay extends StatelessWidget {
  const StartPauseButtonOverlay({
    super.key,
    required this.uiState,
    required this.onStart,
    required this.onTogglePause,
  });

  final RunnerGameUiState uiState;
  final VoidCallback onStart;
  final VoidCallback onTogglePause;

  @override
  Widget build(BuildContext context) {
    return IconButton(
      onPressed: uiState.gameOver
          ? null
          : () {
              if (!uiState.started) {
                onStart();
                return;
              }
              onTogglePause();
            },
      icon: Icon(uiState.paused ? Icons.play_arrow : Icons.pause),
      color: Colors.white,
      tooltip: uiState.paused ? 'Play' : 'Pause',
    );
  }
}


===== FILE: lib/ui/hud/game/survival_timer_overlay.dart =====
import 'package:flutter/widgets.dart';

import '../../../game/game_controller.dart';

class SurvivalTimerOverlay extends StatelessWidget {
  const SurvivalTimerOverlay({
    super.key,
    required this.controller,
    this.padding = const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
  });

  final GameController controller;
  final EdgeInsets padding;

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: controller,
      builder: (context, _) {
        final ticks = controller.snapshot.tick;
        final hz = controller.tickHz;

        final totalSeconds = ticks ~/ hz;
        final minutes = totalSeconds ~/ 60;
        final seconds = totalSeconds % 60;

        final text =
            '${minutes.toString().padLeft(2, '0')}:${seconds.toString().padLeft(2, '0')}';

        return IgnorePointer(
          child: RepaintBoundary(
            child: Container(
              padding: padding,
              decoration: BoxDecoration(
                color: const Color(0x66000000),
                borderRadius: BorderRadius.circular(10),
              ),
              child: Text(
                text,
                textAlign: TextAlign.center,
                style: const TextStyle(
                  fontSize: 18,
                  color: Color(0xFFFFFFFF),
                  fontFeatures: [FontFeature.tabularFigures()],
                ),
              ),
            ),
          ),
        );
      },
    );
  }
}


===== FILE: lib/ui/hud/game/top_center_hud_overlay.dart =====
import 'package:flutter/material.dart';

import '../../../game/game_controller.dart';
import 'survival_timer_overlay.dart';
import '../../runner_game_ui_state.dart';
import 'start_pause_button_overlay.dart';

class TopCenterHudOverlay extends StatelessWidget {
  const TopCenterHudOverlay({
    super.key,
    required this.controller,
    required this.uiState,
    required this.onStart,
    required this.onTogglePause,
  });

  final GameController controller;
  final RunnerGameUiState uiState;
  final VoidCallback onStart;
  final VoidCallback onTogglePause;

  @override
  Widget build(BuildContext context) {
    return Align(
      alignment: Alignment.topCenter,
      child: Padding(
        padding: const EdgeInsets.only(top: 8),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            SurvivalTimerOverlay(controller: controller),
            const SizedBox(width: 8),
            StartPauseButtonOverlay(
              uiState: uiState,
              onStart: onStart,
              onTogglePause: onTogglePause,
            ),
          ],
        ),
      ),
    );
  }
}


===== FILE: lib/ui/hud/game/top_left_hud_overlay.dart =====
import 'package:flutter/widgets.dart';

import '../../../game/game_controller.dart';

class TopLeftHudOverlay extends StatelessWidget {
  const TopLeftHudOverlay({required this.controller, super.key});

  final GameController controller;

  static const double _barWidth = 140;
  static const double _barHeight = 6;
  static const double _barGap = 4;

  @override
  Widget build(BuildContext context) {
    final totalHeight = _barHeight * 3 + _barGap * 2;

    return AnimatedBuilder(
      animation: controller,
      builder: (context, _) {
        final hud = controller.snapshot.hud;
        return IgnorePointer(
          child: RepaintBoundary(
            child: SizedBox(
              width: _barWidth,
              height: totalHeight,

              child: CustomPaint(
                painter: _HudBarsPainter(
                  hp: hud.hp,
                  hpMax: hud.hpMax,
                  mana: hud.mana,
                  manaMax: hud.manaMax,
                  stamina: hud.stamina,
                  staminaMax: hud.staminaMax,
                  barWidth: _barWidth,
                  barHeight: _barHeight,
                  barGap: _barGap,
                ),
              ),
            ),
          ),
        );
      },
    );
  }
}

class _HudBarsPainter extends CustomPainter {
  _HudBarsPainter({
    required this.hp,
    required this.hpMax,
    required this.mana,
    required this.manaMax,
    required this.stamina,
    required this.staminaMax,
    required this.barWidth,
    required this.barHeight,
    required this.barGap,
  });

  final double hp;
  final double hpMax;
  final double mana;
  final double manaMax;
  final double stamina;
  final double staminaMax;
  final double barWidth;
  final double barHeight;
  final double barGap;

  static final Paint _back = Paint()..color = const Color(0xAA000000);
  static final Paint _outline = Paint()
    ..color = const Color(0xFFFFFFFF)
    ..style = PaintingStyle.stroke
    ..strokeWidth = 1;
  static final Paint _hp = Paint()..color = const Color(0xFFDC4440);
  static final Paint _mana = Paint()..color = const Color(0xFF2D98DA);
  static final Paint _stamina = Paint()..color = const Color(0xFF4CD137);

  @override
  void paint(Canvas canvas, Size size) {
    _drawBar(
      canvas,
      y: 0,
      value: hp,
      max: hpMax,
      fill: _hp,
    );
    _drawBar(
      canvas,
      y: barHeight + barGap,
      value: mana,
      max: manaMax,
      fill: _mana,
    );
    _drawBar(
      canvas,
      y: (barHeight + barGap) * 2,
      value: stamina,
      max: staminaMax,
      fill: _stamina,
    );
  }

  void _drawBar(
    Canvas canvas, {
    required double y,
    required double value,
    required double max,
    required Paint fill,
  }) {
    final backRect = Rect.fromLTWH(0, y, barWidth, barHeight);
    canvas.drawRect(backRect, _back);
    canvas.drawRect(backRect, _outline);

    if (max <= 0) return;
    final t = (value / max).clamp(0.0, 1.0);
    if (t <= 0) return;
    canvas.drawRect(Rect.fromLTWH(0, y, barWidth * t, barHeight), fill);
  }

  @override
  bool shouldRepaint(covariant _HudBarsPainter oldDelegate) {
    return hp != oldDelegate.hp ||
        hpMax != oldDelegate.hpMax ||
        mana != oldDelegate.mana ||
        manaMax != oldDelegate.manaMax ||
        stamina != oldDelegate.stamina ||
        staminaMax != oldDelegate.staminaMax ||
        barWidth != oldDelegate.barWidth ||
        barHeight != oldDelegate.barHeight ||
        barGap != oldDelegate.barGap;
  }
}


===== FILE: lib/ui/hud/game/top_right_hud_overlay.dart =====
import 'package:flutter/material.dart';

import '../../../game/game_controller.dart';
import 'score_overlay.dart';

class TopRightHudOverlay extends StatelessWidget {
  const TopRightHudOverlay({
    super.key,
    required this.controller,
    required this.showExitButton,
    required this.onExit,
  });

  final GameController controller;
  final bool showExitButton;
  final VoidCallback? onExit;

  @override
  Widget build(BuildContext context) {
    return Align(
      alignment: Alignment.topRight,
      child: Padding(
        padding: const EdgeInsets.all(8),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            ScoreOverlay(controller: controller),
            if (showExitButton) ...[
              const SizedBox(width: 8),
              IconButton(
                onPressed: onExit,
                icon: const Icon(Icons.close),
                color: Colors.white,
                disabledColor: Colors.white,
              ),
            ],
          ],
        ),
      ),
    );
  }
}


===== FILE: lib/ui/hud/gameover/game_over_header.dart =====
import 'package:flutter/material.dart';

class GameOverHeader extends StatelessWidget {
  const GameOverHeader({
    super.key,
    required this.subtitleDeathReason,
    required this.displayScore,
  });

  final String? subtitleDeathReason;
  final int? displayScore;

  @override
  Widget build(BuildContext context) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        const Text(
          'Game Over',
          style: TextStyle(
            color: Color(0xFFFFFFFF),
            fontSize: 28,
            fontWeight: FontWeight.w600,
          ),
        ),
        if (subtitleDeathReason != null) ...[
          const SizedBox(height: 8),
          Text(
            subtitleDeathReason!,
            style: const TextStyle(
              color: Color(0xFFFFFFFF),
              fontSize: 14,
              fontWeight: FontWeight.w500,
            ),
            textAlign: TextAlign.center,
          ),
        ],
        if (displayScore != null) ...[
          const SizedBox(height: 14),
          Text(
            'Score: $displayScore',
            style: const TextStyle(
              color: Color(0xFFFFFFFF),
              fontSize: 16,
              fontWeight: FontWeight.w600,
            ),
            textAlign: TextAlign.center,
          ),
        ],
      ],
    );
  }
}


===== FILE: lib/ui/hud/gameover/game_over_overlay.dart =====
import 'package:flutter/material.dart';
import 'package:flutter/scheduler.dart';

import '../../../core/enemies/enemy_id.dart';
import '../../../core/events/game_event.dart';
import '../../../core/levels/level_id.dart';
import '../../../core/projectiles/projectile_id.dart';
import '../../../core/scoring/run_score_breakdown.dart';
import '../../../core/tuning/score_tuning.dart';
import '../../leaderboard/leaderboard_store.dart';
import 'game_over_header.dart';
import 'leaderboard_panel.dart';
import 'restart_exit_buttons.dart';
import 'score_breakdown_formatter.dart';
import 'score_distribution.dart';
import 'score_feed_controller.dart';
import '../../components/overlay_button.dart';
// import '../../../core/spells/spell_id.dart';

class GameOverOverlay extends StatefulWidget {
  const GameOverOverlay({
    super.key,
    required this.visible,
    required this.onRestart,
    required this.onExit,
    required this.showExitButton,
    required this.levelId,
    required this.runEndedEvent,
    required this.scoreTuning,
    required this.tickHz,
    this.leaderboardStore,
  });

  final bool visible;
  final VoidCallback onRestart;
  final VoidCallback? onExit;
  final bool showExitButton;
  final LevelId levelId;
  final RunEndedEvent? runEndedEvent;
  final ScoreTuning scoreTuning;
  final int tickHz;
  final LeaderboardStore? leaderboardStore;

  @override
  State<GameOverOverlay> createState() => _GameOverOverlayState();
}

class _GameOverOverlayState extends State<GameOverOverlay>
    with SingleTickerProviderStateMixin {
  late final RunScoreBreakdown _breakdown;
  late final ScoreFeedController _feedController;

  Ticker? _ticker;
  Duration _lastElapsed = Duration.zero;

  @override
  void initState() {
    super.initState();
    _breakdown = _buildBreakdown();
    _feedController = ScoreFeedController(
      rows: _breakdown.rows,
      totalPoints: _breakdown.totalPoints,
    );
  }

  RunScoreBreakdown _buildBreakdown() {
    final event = widget.runEndedEvent;
    if (event == null) {
      return const RunScoreBreakdown(rows: <RunScoreRow>[], totalPoints: 0);
    }

    return buildRunScoreBreakdown(
      tick: event.tick,
      distanceUnits: event.distance,
      collectibles: event.stats.collectibles,
      collectibleScore: event.stats.collectibleScore,
      enemyKillCounts: event.stats.enemyKillCounts,
      tuning: widget.scoreTuning,
      tickHz: widget.tickHz,
    );
  }

  void _startFeed() {
    if (_feedController.startFeed()) {
      _startTicker();
      setState(() {});
    }
  }

  void _startTicker() {
    _ticker?.dispose();
    _lastElapsed = Duration.zero;
    _ticker = createTicker(_onTick)..start();
  }

  void _stopTicker() {
    final ticker = _ticker;
    if (ticker == null) return;
    ticker.stop();
    ticker.dispose();
    _ticker = null;
  }

  void _onTick(Duration elapsed) {
    if (_feedController.feedState != ScoreFeedState.feeding) return;

    final dt = (elapsed - _lastElapsed).inMicroseconds.toDouble() / 1000000.0;
    _lastElapsed = elapsed;
    if (dt <= 0) return;

    final changed = _feedController.tick(dt);
    if (_feedController.feedState == ScoreFeedState.complete) {
      _stopTicker();
    }
    if (changed && mounted) setState(() {});
  }

  void _completeFeed() {
    _feedController.completeFeed();
    _stopTicker();
  }

  void _onCollectPressed() {
    if (_feedController.feedState == ScoreFeedState.idle) {
      _startFeed();
      return;
    }
    if (_feedController.feedState == ScoreFeedState.feeding) {
      _completeFeed();
      setState(() {});
    }
  }

  void _completeThen(VoidCallback? action) {
    if (_feedController.feedState != ScoreFeedState.complete) {
      _completeFeed();
      setState(() {});
    }
    if (action == null) return;
    WidgetsBinding.instance.addPostFrameCallback((_) => action());
  }

  @override
  void dispose() {
    _stopTicker();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    if (!widget.visible) return const SizedBox.shrink();

    final subtitleDeathReason = _buildSubtitleDeathReason(widget.runEndedEvent);
    final showCollectButton =
        _feedController.totalPoints > 0 &&
        _feedController.feedState != ScoreFeedState.complete;
    final showScoreInHeader =
        _feedController.feedState == ScoreFeedState.complete;
    final collectLabel = _feedController.feedState == ScoreFeedState.idle
        ? 'Collect score'
        : 'Skip';
    final rowLabels = [
      for (var i = 0; i < _feedController.rows.length; i += 1)
        formatScoreRow(
          _feedController.rows[i].row,
          _feedController.rows[i].remainingPoints,
          enemyName: _enemyName,
        ),
    ];

    return SizedBox.expand(
      child: ColoredBox(
        color: const Color(0x88000000),
        child: SafeArea(
          minimum: const EdgeInsets.all(18),
          child: Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Expanded(
                flex: 2,
                child: Align(
                  alignment: Alignment.topCenter,
                  child: Column(
                    mainAxisSize: MainAxisSize.max,
                    children: [
                      GameOverHeader(
                        subtitleDeathReason: subtitleDeathReason,
                        displayScore: showScoreInHeader
                            ? _feedController.displayScore
                            : null,
                      ),
                      const SizedBox(height: 14),
                      if (showCollectButton)
                        OverlayButton(
                          label: collectLabel,
                          onPressed: _onCollectPressed,
                        )
                      else
                        RestartExitButtons(
                          restartButton: OverlayButton(
                            label: 'Restart',
                            onPressed: () => _completeThen(widget.onRestart),
                          ),
                          exitButton: widget.showExitButton
                              ? OverlayButton(
                                  label: 'Exit',
                                  onPressed: () => _completeThen(widget.onExit),
                                )
                              : null,
                        ),
                      const SizedBox(height: 16),
                      Flexible(child: ScoreDistribution(rowLabels: rowLabels)),
                    ],
                  ),
                ),
              ),
              Expanded(
                flex: 1,
                child: Align(
                  alignment: Alignment.topCenter,
                  child: LeaderboardPanel(
                    levelId: widget.levelId,
                    runEndedEvent: widget.runEndedEvent,
                    scoreTuning: widget.scoreTuning,
                    tickHz: widget.tickHz,
                    revealCurrentRunScore:
                        _feedController.feedState == ScoreFeedState.complete,
                    leaderboardStore: widget.leaderboardStore,
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

String? _buildSubtitleDeathReason(RunEndedEvent? event) {
  if (event == null) return null;
  switch (event.reason) {
    case RunEndReason.gaveUp:
      return 'You gave up the run.';
    case RunEndReason.fellBehindCamera:
      return 'You fell behind.';
    case RunEndReason.fellIntoGap:
      return 'You fell into a gap.';
    case RunEndReason.playerDied:
      return _buildDeathSubtitle(event.deathInfo);
  }
}

String _buildDeathSubtitle(DeathInfo? info) {
  if (info == null) return 'You died.';
  switch (info.kind) {
    case DeathSourceKind.projectile:
      return _buildProjectileDeath(info);
    case DeathSourceKind.meleeHitbox:
      return _buildMeleeDeath(info);
    case DeathSourceKind.statusEffect:
      return 'You succumbed to a status effect.';
    case DeathSourceKind.unknown:
      return 'You died.';
  }
}

String _buildProjectileDeath(DeathInfo info) {
  final projectileId = info.projectileId;
  if (projectileId == null) return 'You died.';
  final projectileName = _projectileName(projectileId);
  /* final spellName =
      info.spellId == null ? null : _spellName(info.spellId!); */
  final enemyName = info.enemyId == null ? null : _enemyName(info.enemyId!);

  final buffer = StringBuffer('Killed by $projectileName');
  /*   if (spellName != null) {
    buffer.write(' ($spellName)');
  } */
  if (enemyName != null) {
    buffer.write(' from $enemyName.');
  } else {
    buffer.write('.');
  }
  return buffer.toString();
}

String _buildMeleeDeath(DeathInfo info) {
  if (info.enemyId == null) return 'You died.';
  return 'Killed by a melee strike from a ${_enemyName(info.enemyId!)}.';
}

String _enemyName(EnemyId id) {
  switch (id) {
    case EnemyId.unocoDemon:
      return 'Unoco Demon';
    case EnemyId.grojib:
      return 'Ground enemy';
  }
}

String _projectileName(ProjectileId id) {
  switch (id) {
    case ProjectileId.iceBolt:
      return 'Ice Bolt';
    case ProjectileId.thunderBolt:
      return 'thunder Bolt';
    case ProjectileId.fireBolt:
      return 'Fire Bolt';
    case ProjectileId.throwingAxe:
      return 'Throwing Axe';
    case ProjectileId.throwingKnife:
      return 'Throwing Knife';
  }
}

/* String _spellName(SpellId id) {
  switch (id) {
    case SpellId.iceBolt:
      return 'Ice Bolt';
    case SpellId.thunderBolt:
      return 'thunder';
  }
} */


===== FILE: lib/ui/hud/gameover/leaderboard_panel.dart =====
import 'package:flutter/material.dart';

import '../../../core/events/game_event.dart';
import '../../../core/levels/level_id.dart';
import '../../../core/tuning/score_tuning.dart';
import '../../leaderboard/leaderboard_store.dart';
import '../../leaderboard/run_result.dart';
import '../../leaderboard/shared_prefs_leaderboard_store.dart';
import '../../levels/level_id_ui.dart';

class LeaderboardPanel extends StatefulWidget {
  const LeaderboardPanel({
    super.key,
    required this.levelId,
    required this.runEndedEvent,
    required this.scoreTuning,
    required this.tickHz,
    this.revealCurrentRunScore = true,
    this.leaderboardStore,
  });

  final LevelId levelId;
  final RunEndedEvent? runEndedEvent;
  final ScoreTuning scoreTuning;
  final int tickHz;
  final bool revealCurrentRunScore;
  final LeaderboardStore? leaderboardStore;

  @override
  State<LeaderboardPanel> createState() => _LeaderboardPanelState();
}

class _LeaderboardPanelState extends State<LeaderboardPanel> {
  late final LeaderboardStore _store;
  List<RunResult> _entries = const <RunResult>[];
  int? _currentRunId;
  bool _loaded = false;

  static const double _rankColWidth = 28;
  static const double _scoreColWidth = 64;
  static const double _distanceColWidth = 56;
  static const double _timeColWidth = 54;

  @override
  void initState() {
    super.initState();
    _store = widget.leaderboardStore ?? SharedPrefsLeaderboardStore();
    _loadLeaderboard();
  }

  Future<void> _loadLeaderboard() async {
    final event = widget.runEndedEvent;
    if (event == null) {
      final entries = await _store.loadTop10(levelId: widget.levelId);
      if (!mounted) return;
      setState(() {
        _entries = entries;
        _loaded = true;
      });
      return;
    }

    final draft = buildRunResult(
      event: event,
      scoreTuning: widget.scoreTuning,
      tickHz: widget.tickHz,
      endedAtMs: DateTime.now().millisecondsSinceEpoch,
    );
    final snapshot = await _store.addResult(
      levelId: widget.levelId,
      result: draft,
    );
    if (!mounted) return;
    setState(() {
      _entries = snapshot.entries;
      _currentRunId = snapshot.current.runId;
      _loaded = true;
    });
  }

  Widget _buildRow(int rank, RunResult entry) {
    final isCurrent = _currentRunId != null && entry.runId == _currentRunId;
    final color = isCurrent ? const Color(0xFFFFF59D) : const Color(0xFFFFFFFF);
    final scoreText =
        isCurrent && !widget.revealCurrentRunScore ? '—' : entry.score.toString();

    return DecoratedBox(
      decoration: isCurrent
          ? BoxDecoration(
              color: const Color(0x33FFFFFF),
              borderRadius: BorderRadius.circular(6),
            )
          : const BoxDecoration(),
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 3),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            SizedBox(
              width: _rankColWidth,
              child: Text(
                '#$rank',
                style: TextStyle(color: color),
              ),
            ),
            SizedBox(
              width: _scoreColWidth,
              child: Text(
                scoreText,
                textAlign: TextAlign.right,
                style: TextStyle(color: color),
              ),
            ),
            SizedBox(
              width: _distanceColWidth,
              child: Text(
                '${entry.distanceMeters}m',
                textAlign: TextAlign.right,
                style: TextStyle(color: color),
              ),
            ),
            SizedBox(
              width: _timeColWidth,
              child: Text(
                _formatTime(entry.durationSeconds),
                textAlign: TextAlign.right,
                style: TextStyle(color: color),
              ),
            ),
          ],
        ),
      ),
    );
  }

  String _formatTime(int totalSeconds) {
    final minutes = totalSeconds ~/ 60;
    final seconds = totalSeconds % 60;
    return '${minutes.toString().padLeft(2, '0')}:${seconds.toString().padLeft(2, '0')}';
  }

  @override
  Widget build(BuildContext context) {
    final titleStyle = const TextStyle(
      color: Color(0xFFFFFFFF),
      fontSize: 14,
      fontWeight: FontWeight.w600,
    );
    final textStyle = const TextStyle(
      color: Color(0xFFFFFFFF),
      fontSize: 12,
      fontWeight: FontWeight.w500,
    );

    Widget content;
    if (!_loaded) {
      content = Text('Loading leaderboard...', style: textStyle);
    } else if (_entries.isEmpty) {
      content = Text('No runs yet.', style: textStyle);
    } else {
      content = Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          for (var i = 0; i < _entries.length; i += 1) ...[
            _buildRow(i + 1, _entries[i]),
            if (i < _entries.length - 1) const SizedBox(height: 4),
          ],
        ],
      );
    }

    return ConstrainedBox(
      constraints: const BoxConstraints(maxWidth: 240),
      child: DecoratedBox(
        decoration: BoxDecoration(
          color: const Color(0x66000000),
          borderRadius: BorderRadius.circular(10),
        ),
        child: Padding(
          padding: const EdgeInsets.all(12),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text('${widget.levelId.displayName} Scoreboard', style: titleStyle),
              const SizedBox(height: 8),
              DefaultTextStyle(style: textStyle, child: content),
            ],
          ),
        ),
      ),
    );
  }
}


===== FILE: lib/ui/hud/gameover/restart_exit_buttons.dart =====
import 'package:flutter/material.dart';

class RestartExitButtons extends StatelessWidget {
  const RestartExitButtons({
    super.key,
    required this.restartButton,
    this.exitButton,
    this.trailingButton,
  });

  final Widget restartButton;
  final Widget? exitButton;
  final Widget? trailingButton;

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      width: double.infinity,
      child: Stack(
        alignment: Alignment.center,
        children: [
          Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              restartButton,
              if (exitButton != null) ...[
                const SizedBox(width: 12),
                exitButton!,
              ],
            ],
          ),
          if (trailingButton != null)
            Align(alignment: Alignment.centerRight, child: trailingButton),
        ],
      ),
    );
  }
}


===== FILE: lib/ui/hud/gameover/score_breakdown_formatter.dart =====
import '../../../core/enemies/enemy_id.dart';
import '../../../core/scoring/run_score_breakdown.dart';

String formatScoreRow(
  RunScoreRow row,
  int remainingPoints, {
  required String Function(EnemyId id) enemyName,
}) {
  switch (row.kind) {
    case RunScoreRowKind.distance:
      return 'Distance: ${row.count}m -> $remainingPoints';
    case RunScoreRowKind.time:
      return 'Time: ${_formatTime(row.count)} -> $remainingPoints';
    case RunScoreRowKind.collectibles:
      return 'Collectibles: ${row.count} -> $remainingPoints';
    case RunScoreRowKind.enemyKill:
      final name = row.enemyId == null ? 'Enemy' : enemyName(row.enemyId!);
      return '$name x${row.count} -> $remainingPoints';
  }
}

String _formatTime(int totalSeconds) {
  final minutes = totalSeconds ~/ 60;
  final seconds = totalSeconds % 60;
  return '${minutes.toString().padLeft(2, '0')}:${seconds.toString().padLeft(2, '0')}';
}


===== FILE: lib/ui/hud/gameover/score_distribution.dart =====
import 'package:flutter/material.dart';

class ScoreDistribution extends StatelessWidget {
  const ScoreDistribution({
    super.key,
    required this.rowLabels,
  });

  final List<String> rowLabels;

  @override
  Widget build(BuildContext context) {
    return Scrollbar(
      child: SingleChildScrollView(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            for (var i = 0; i < rowLabels.length; i += 1) ...[
              Text(
                rowLabels[i],
                style: const TextStyle(
                  color: Color(0xFFFFFFFF),
                  fontSize: 14,
                  fontWeight: FontWeight.w500,
                ),
                textAlign: TextAlign.center,
              ),
              if (i < rowLabels.length - 1) const SizedBox(height: 4),
            ],
          ],
        ),
      ),
    );
  }
}


===== FILE: lib/ui/hud/gameover/score_feed_controller.dart =====
import '../../../core/scoring/run_score_breakdown.dart';

enum ScoreFeedState { idle, feeding, complete }

class ScoreFeedRowState {
  ScoreFeedRowState({
    required this.row,
    required this.pointsPerSecond,
  }) : remainingPoints = row.points;

  final RunScoreRow row;
  final double pointsPerSecond;
  int remainingPoints;
  double carry = 0.0;
}

class ScoreFeedController {
  ScoreFeedController({
    required List<RunScoreRow> rows,
    required this.totalPoints,
    double feedDurationSeconds = 0.8,
  }) : _rows = [
          for (final row in rows)
            ScoreFeedRowState(
              row: row,
              pointsPerSecond:
                  row.points <= 0 ? 0.0 : row.points / feedDurationSeconds,
            ),
        ],
        displayScore = 0,
        feedState =
            totalPoints > 0 ? ScoreFeedState.idle : ScoreFeedState.complete;

  final int totalPoints;
  final List<ScoreFeedRowState> _rows;

  int displayScore;
  ScoreFeedState feedState;

  List<ScoreFeedRowState> get rows => _rows;

  bool startFeed() {
    if (feedState != ScoreFeedState.idle || totalPoints <= 0) return false;
    feedState = ScoreFeedState.feeding;
    return true;
  }

  bool tick(double dtSeconds) {
    if (feedState != ScoreFeedState.feeding || dtSeconds <= 0) {
      return false;
    }

    var gained = 0;
    var anyRemaining = false;

    for (final row in _rows) {
      if (row.remainingPoints <= 0 || row.pointsPerSecond <= 0) continue;
      row.carry += dtSeconds * row.pointsPerSecond;
      final raw = row.carry.floor();
      if (raw <= 0) {
        anyRemaining = true;
        continue;
      }
      row.carry -= raw;
      final consume =
          raw > row.remainingPoints ? row.remainingPoints : raw;
      row.remainingPoints -= consume;
      gained += consume;
      if (row.remainingPoints > 0) anyRemaining = true;
    }

    if (gained > 0) {
      displayScore += gained;
      if (displayScore > totalPoints) displayScore = totalPoints;
    }

    if (!anyRemaining) {
      completeFeed();
      return true;
    }

    return gained > 0;
  }

  void completeFeed() {
    displayScore = totalPoints;
    for (final row in _rows) {
      row.remainingPoints = 0;
      row.carry = 0.0;
    }
    feedState = ScoreFeedState.complete;
  }
}


===== FILE: lib/ui/leaderboard/leaderboard_store.dart =====
import '../../core/levels/level_id.dart';

import 'run_result.dart';

class LeaderboardSnapshot {
  const LeaderboardSnapshot({
    required this.entries,
    required this.current,
  });

  final List<RunResult> entries;
  final RunResult current;
}

abstract class LeaderboardStore {
  Future<LeaderboardSnapshot> addResult({
    required LevelId levelId,
    required RunResult result,
  });

  Future<List<RunResult>> loadTop10({required LevelId levelId});
}


===== FILE: lib/ui/leaderboard/run_result.dart =====
import '../../core/events/game_event.dart';
import '../../core/scoring/run_score_breakdown.dart';
import '../../core/tuning/score_tuning.dart';

class RunResult {
  const RunResult({
    required this.runId,
    required this.endedAtMs,
    required this.endedReason,
    required this.score,
    required this.distanceMeters,
    required this.durationSeconds,
    required this.tick,
  });

  final int runId;
  final int endedAtMs;
  final RunEndReason endedReason;
  final int score;
  final int distanceMeters;
  final int durationSeconds;
  final int tick;

  RunResult copyWith({
    int? runId,
    int? endedAtMs,
  }) {
    return RunResult(
      runId: runId ?? this.runId,
      endedAtMs: endedAtMs ?? this.endedAtMs,
      endedReason: endedReason,
      score: score,
      distanceMeters: distanceMeters,
      durationSeconds: durationSeconds,
      tick: tick,
    );
  }

  Map<String, dynamic> toJson() => <String, dynamic>{
        'runId': runId,
        'endedAtMs': endedAtMs,
        'endedReason': endedReason.name,
        'score': score,
        'distanceMeters': distanceMeters,
        'durationSeconds': durationSeconds,
        'tick': tick,
      };

  static RunResult fromJson(Map<String, dynamic> json) {
    final reasonName = json['endedReason'] as String?;
    final reason = _reasonFromName(reasonName);
    return RunResult(
      runId: json['runId'] as int? ?? 0,
      endedAtMs: json['endedAtMs'] as int? ?? 0,
      endedReason: reason,
      score: json['score'] as int? ?? 0,
      distanceMeters: json['distanceMeters'] as int? ?? 0,
      durationSeconds: json['durationSeconds'] as int? ?? 0,
      tick: json['tick'] as int? ?? 0,
    );
  }

  static RunEndReason _reasonFromName(String? name) {
    if (name == null) return RunEndReason.playerDied;
    for (final value in RunEndReason.values) {
      if (value.name == name) return value;
    }
    return RunEndReason.playerDied;
  }
}

RunResult buildRunResult({
  required RunEndedEvent event,
  required ScoreTuning scoreTuning,
  required int tickHz,
  required int endedAtMs,
}) {
  final breakdown = buildRunScoreBreakdown(
    tick: event.tick,
    distanceUnits: event.distance,
    collectibles: event.stats.collectibles,
    collectibleScore: event.stats.collectibleScore,
    enemyKillCounts: event.stats.enemyKillCounts,
    tuning: scoreTuning,
    tickHz: tickHz,
  );

  final distanceMeters = (event.distance / kWorldUnitsPerMeter).floor();
  final durationSeconds = tickHz <= 0 ? 0 : event.tick ~/ tickHz;

  return RunResult(
    runId: 0,
    endedAtMs: endedAtMs,
    endedReason: event.reason,
    score: breakdown.totalPoints,
    distanceMeters: distanceMeters,
    durationSeconds: durationSeconds,
    tick: event.tick,
  );
}


===== FILE: lib/ui/leaderboard/shared_prefs_leaderboard_store.dart =====
import 'dart:convert';

import 'package:shared_preferences/shared_preferences.dart';

import '../../core/levels/level_id.dart';
import 'leaderboard_store.dart';
import 'run_result.dart';

class SharedPrefsLeaderboardStore implements LeaderboardStore {
  static const String _entriesKeyPrefix = 'leaderboard_v2_entries_';
  static const String _nextIdKeyPrefix = 'leaderboard_v2_next_id_';

  String _entriesKey(LevelId levelId) => '$_entriesKeyPrefix${levelId.name}';
  String _nextIdKey(LevelId levelId) => '$_nextIdKeyPrefix${levelId.name}';

  @override
  Future<LeaderboardSnapshot> addResult({
    required LevelId levelId,
    required RunResult result,
  }) async {
    final prefs = await SharedPreferences.getInstance();

    final nextId = (prefs.getInt(_nextIdKey(levelId)) ?? 1);
    final stored = result.copyWith(runId: nextId);
    final entries = _loadEntries(prefs, levelId);
    entries.add(stored);
    entries.sort(_compare);

    final top = entries.length > 10 ? entries.sublist(0, 10) : entries;
    await prefs.setString(_entriesKey(levelId), _encode(top));
    await prefs.setInt(_nextIdKey(levelId), nextId + 1);

    return LeaderboardSnapshot(
      entries: List<RunResult>.unmodifiable(top),
      current: stored,
    );
  }

  @override
  Future<List<RunResult>> loadTop10({required LevelId levelId}) async {
    final prefs = await SharedPreferences.getInstance();
    final entries = _loadEntries(prefs, levelId);
    entries.sort(_compare);
    if (entries.length > 10) return entries.sublist(0, 10);
    return List<RunResult>.unmodifiable(entries);
  }

  List<RunResult> _loadEntries(SharedPreferences prefs, LevelId levelId) {
    final raw = prefs.getString(_entriesKey(levelId));
    if (raw == null || raw.isEmpty) return <RunResult>[];

    final decoded = jsonDecode(raw);
    if (decoded is! List) return <RunResult>[];

    final entries = <RunResult>[];
    for (final entry in decoded) {
      if (entry is Map<String, dynamic>) {
        entries.add(RunResult.fromJson(entry));
      } else if (entry is Map) {
        entries.add(RunResult.fromJson(Map<String, dynamic>.from(entry)));
      }
    }
    return entries;
  }

  String _encode(List<RunResult> entries) {
    return jsonEncode(entries.map((entry) => entry.toJson()).toList());
  }

  int _compare(RunResult a, RunResult b) {
    if (a.score != b.score) return b.score.compareTo(a.score);
    if (a.endedAtMs != b.endedAtMs) {
      return b.endedAtMs.compareTo(a.endedAtMs);
    }
    return b.runId.compareTo(a.runId);
  }
}


===== FILE: lib/ui/levels/level_id_ui.dart =====
import '../../core/levels/level_id.dart';
import '../../core/levels/level_registry.dart';

/// UI-layer extensions for [LevelId].
extension LevelIdUi on LevelId {
  /// Human-readable display name for the level.
  String get displayName {
    switch (this) {
      case LevelId.defaultLevel:
        return 'Default';
      case LevelId.forest:
        return 'Forest';
      case LevelId.field:
        return 'Field';
    }
  }

  /// Theme identifier used for asset lookup.
  ///
  /// Resolves through [LevelRegistry] to get the authoritative themeId.
  /// Returns 'field' as fallback if the level has no theme set.
  String get themeId => LevelRegistry.byId(this).themeId ?? 'field';
}


===== FILE: lib/ui/menus/character_select_page.dart =====
import 'package:flutter/material.dart';

import '../components/placeholder_page.dart';

/// Placeholder page for Character Selection (coming soon).
class CharacterSelectPage extends StatelessWidget {
  const CharacterSelectPage({super.key});

  @override
  Widget build(BuildContext context) {
    return const PlaceholderPage(title: 'Character');
  }
}


===== FILE: lib/ui/menus/credits_page.dart =====
import 'package:flutter/material.dart';

import '../components/placeholder_page.dart';

/// Placeholder page for Credits (coming soon).
class CreditsPage extends StatelessWidget {
  const CreditsPage({super.key});

  @override
  Widget build(BuildContext context) {
    return const PlaceholderPage(title: 'Credits');
  }
}


===== FILE: lib/ui/menus/game_hub_page.dart =====
import 'package:flutter/material.dart';

import '../components/menu_button.dart';
import '../components/menu_scaffold.dart';
import 'character_select_page.dart';
import 'library_page.dart';
import 'options_page.dart';
import 'runner_menu_page.dart';
import 'store_page.dart';

/// Game hub page with navigation to all game features.
///
/// Displays 5 menu buttons on the left side:
/// - Character Selection
/// - Level Selection
/// - Library
/// - Store
/// - Options
class GameHubPage extends StatelessWidget {
  const GameHubPage({super.key});

  @override
  Widget build(BuildContext context) {
    return MenuScaffold(
      showAppBar: false,
      child: Row(
        children: [
          // Left half - navigation buttons
          Expanded(
            child: Padding(
              padding: const EdgeInsets.all(24),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  MenuButton(
                    label: 'CHARACTER',
                    onPressed: () => _navigateTo(
                      context,
                      const CharacterSelectPage(),
                    ),
                  ),
                  const SizedBox(height: 16),
                  MenuButton(
                    label: 'LEVELS',
                    onPressed: () => _navigateTo(
                      context,
                      const RunnerMenuPage(),
                    ),
                  ),
                  const SizedBox(height: 16),
                  MenuButton(
                    label: 'LIBRARY',
                    onPressed: () => _navigateTo(
                      context,
                      const LibraryPage(),
                    ),
                  ),
                  const SizedBox(height: 16),
                  MenuButton(
                    label: 'STORE',
                    onPressed: () => _navigateTo(
                      context,
                      const StorePage(),
                    ),
                  ),
                  const SizedBox(height: 16),
                  MenuButton(
                    label: 'OPTIONS',
                    onPressed: () => _navigateTo(
                      context,
                      const OptionsPage(),
                    ),
                  ),
                ],
              ),
            ),
          ),
          // Right half - reserved for future content (preview, character display, etc.)
          const Expanded(
            child: SizedBox.shrink(),
          ),
        ],
      ),
    );
  }

  void _navigateTo(BuildContext context, Widget page) {
    Navigator.of(context).push(
      MaterialPageRoute<void>(builder: (context) => page),
    );
  }
}


===== FILE: lib/ui/menus/level_select_section.dart =====
import 'package:flutter/material.dart';

import '../../core/levels/level_id.dart';
import '../components/level_card.dart';

/// Level selection section displaying level cards in a row.
class LevelSelectSection extends StatelessWidget {
  const LevelSelectSection({super.key, required this.onStartLevel});

  final void Function(LevelId levelId) onStartLevel;

  @override
  Widget build(BuildContext context) {
    return Row(
      children: [
        Expanded(
          child: LevelCard(
            levelId: LevelId.field,
            onTap: () => onStartLevel(LevelId.field),
          ),
        ),
        const SizedBox(width: 16),
        Expanded(
          child: LevelCard(
            levelId: LevelId.forest,
            onTap: () => onStartLevel(LevelId.forest),
          ),
        ),
      ],
    );
  }
}


===== FILE: lib/ui/menus/library_page.dart =====
import 'package:flutter/material.dart';

import '../components/placeholder_page.dart';

/// Placeholder page for Library (coming soon).
class LibraryPage extends StatelessWidget {
  const LibraryPage({super.key});

  @override
  Widget build(BuildContext context) {
    return const PlaceholderPage(title: 'Library');
  }
}


===== FILE: lib/ui/menus/main_menu_page.dart =====
import 'package:flutter/material.dart';

import '../components/menu_button.dart';
import '../components/menu_scaffold.dart';
import 'credits_page.dart';
import 'game_hub_page.dart';

/// The production main menu for the game.
///
/// Displays the game title and navigation buttons to Start and Credits.
class MainMenuPage extends StatelessWidget {
  const MainMenuPage({super.key});

  @override
  Widget build(BuildContext context) {
    return MenuScaffold(
      showAppBar: false,
      child: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            // Game title
            const Text(
              'rpg-runner',
              style: TextStyle(
                fontSize: 48,
                fontWeight: FontWeight.bold,
                color: Colors.white,
                letterSpacing: 2,
              ),
            ),
            const SizedBox(height: 64),

            // Start button
            MenuButton(
              label: 'START',
              onPressed: () => _navigateTo(context, const GameHubPage()),
            ),
            const SizedBox(height: 16),

            // Credits button
            MenuButton(
              label: 'CREDITS',
              onPressed: () => _navigateTo(context, const CreditsPage()),
            ),
          ],
        ),
      ),
    );
  }

  void _navigateTo(BuildContext context, Widget page) {
    Navigator.of(context).push(
      MaterialPageRoute<void>(builder: (context) => page),
    );
  }
}


===== FILE: lib/ui/menus/options_page.dart =====
import 'package:flutter/material.dart';

import '../components/placeholder_page.dart';

/// Placeholder page for Options (coming soon).
class OptionsPage extends StatelessWidget {
  const OptionsPage({super.key});

  @override
  Widget build(BuildContext context) {
    return const PlaceholderPage(title: 'Options');
  }
}


===== FILE: lib/ui/menus/runner_menu_page.dart =====
import 'dart:math';

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import '../../core/levels/level_id.dart';
import '../components/menu_scaffold.dart';
import '../runner_game_route.dart';
import 'level_select_section.dart';

/// Level selection page with level cards in a row.
class RunnerMenuPage extends StatelessWidget {
  const RunnerMenuPage({super.key});

  void _startLevel(BuildContext context, LevelId levelId) {
    final seed = Random().nextInt(1 << 31);
    Navigator.of(context).push(
      createRunnerGameRoute(
        seed: seed,
        levelId: levelId,
        restoreOrientations: const [
          DeviceOrientation.landscapeLeft,
          DeviceOrientation.landscapeRight,
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return MenuScaffold(
      title: 'Select Level',
      child: Padding(
        padding: const EdgeInsets.all(24),
        child: Center(
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 800),
            child: LevelSelectSection(
              onStartLevel: (levelId) => _startLevel(context, levelId),
            ),
          ),
        ),
      ),
    );
  }
}


===== FILE: lib/ui/menus/store_page.dart =====
import 'package:flutter/material.dart';

import '../components/placeholder_page.dart';

/// Placeholder page for Store (coming soon).
class StorePage extends StatelessWidget {
  const StorePage({super.key});

  @override
  Widget build(BuildContext context) {
    return const PlaceholderPage(title: 'Store');
  }
}


===== FILE: lib/ui/runner_game_route.dart =====
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import '../core/levels/level_id.dart';
import '../core/players/player_character_definition.dart';
import 'runner_game_widget.dart';
import 'scoped/scoped_preferred_orientations.dart';
import 'scoped/scoped_system_ui_mode.dart';

/// Embed-friendly route factory for hosting the mini-game in any Flutter app.
///
/// Host apps can `Navigator.push(createRunnerGameRoute(...))` without depending
/// on this package's development host app (`lib/main.dart`).
///
Route<void> createRunnerGameRoute({
  int seed = 1,
  LevelId levelId = LevelId.defaultLevel,
  PlayerCharacterId playerCharacterId = PlayerCharacterId.eloise,
  bool lockLandscape = true,
  List<DeviceOrientation>? restoreOrientations,
}) {
  return MaterialPageRoute<void>(
    builder: (context) {
      Widget child = RunnerGameWidget(
        seed: seed,
        levelId: levelId,
        playerCharacterId: playerCharacterId,
        onExit: () => Navigator.of(context).maybePop(),
      );

      if (lockLandscape) {
        child = ScopedPreferredOrientations(
          preferredOrientations: const [
            DeviceOrientation.landscapeLeft,
            DeviceOrientation.landscapeRight,
          ],
          restoreOrientations: restoreOrientations,
          child: child,
        );
      }

      // Hide status + nav bars only for this route.
      child = ScopedSystemUiMode(
        mode: SystemUiMode.immersiveSticky,
        restoreMode: SystemUiMode.edgeToEdge,
        child: child,
      );

      return Scaffold(body: child);
    },
  );
}


===== FILE: lib/ui/runner_game_ui_state.dart =====
class RunnerGameUiState {
  const RunnerGameUiState({
    required this.started,
    required this.paused,
    required this.gameOver,
  });

  final bool started;
  final bool paused;
  final bool gameOver;

  bool get canRun => started && !gameOver;

  bool get isRunning => canRun && !paused;

  bool get showReadyOverlay => !started;

  bool get showPauseOverlay => started && paused && !gameOver;
}


===== FILE: lib/ui/runner_game_widget.dart =====
import 'package:flame/game.dart';
import 'package:flutter/material.dart';

import '../core/contracts/render_contract.dart';
import '../core/game_core.dart';
import '../core/levels/level_id.dart';
import '../core/levels/level_registry.dart';
import '../core/players/player_character_definition.dart';
import '../core/players/player_character_registry.dart';
import '../game/game_controller.dart';
import '../game/input/aim_preview.dart';
import '../game/input/runner_input_router.dart';
import '../game/runner_flame_game.dart';
import 'hud/game/game_overlay.dart';
import 'hud/gameover/game_over_overlay.dart';
import 'runner_game_ui_state.dart';
import 'viewport/game_viewport.dart';
import 'viewport/viewport_metrics.dart';

/// Embed-friendly widget that hosts the mini-game.
///
/// Intended to be mounted by a host app. It owns its [GameController] and
/// cleans it up on dispose.
///
/// Viewport scaling is applied by [GameViewport] to keep the fixed virtual
/// resolution fitted to the available screen.
class RunnerGameWidget extends StatefulWidget {
  const RunnerGameWidget({
    super.key,
    this.seed = 1,
    this.levelId = LevelId.defaultLevel,
    this.playerCharacterId = PlayerCharacterId.eloise,
    this.onExit,
    this.showExitButton = true,
    this.viewportMode = ViewportScaleMode.pixelPerfectContain,
    this.viewportAlignment = Alignment.center,
  });

  /// Master RNG seed for deterministic generation.
  final int seed;

  /// Which core level definition to run.
  final LevelId levelId;

  /// Which player character to use for this run.
  final PlayerCharacterId playerCharacterId;

  final VoidCallback? onExit;
  final bool showExitButton;

  /// How the game view is scaled to the available screen.
  final ViewportScaleMode viewportMode;

  /// Where the scaled view is placed within the available screen.
  final Alignment viewportAlignment;

  @override
  State<RunnerGameWidget> createState() => _RunnerGameWidgetState();
}

class _RunnerGameWidgetState extends State<RunnerGameWidget>
    with WidgetsBindingObserver {
  bool _pausedByLifecycle = false;
  bool _started = false;
  bool _exitConfirmOpen = false;
  bool _pausedBeforeExitConfirm = false;

  late GameController _controller;
  late RunnerInputRouter _input;
  late AimPreviewModel _projectileAimPreview;
  late AimPreviewModel _meleeAimPreview;
  late ValueNotifier<Rect?> _aimCancelHitboxRect;
  late RunnerFlameGame _game;

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);

    _initGame();

    // Start in "ready" (paused) until the user taps to begin.
    _controller.setPaused(true);
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) =>
      _onLifecycle(state);

  void _onLifecycle(AppLifecycleState state) {
    final uiState = _buildUiState();
    if (state == AppLifecycleState.resumed) {
      if (_pausedByLifecycle && uiState.started && !uiState.gameOver) {
        _pausedByLifecycle = false;
        _controller.setPaused(false);
      }
      return;
    }

    // Only mark lifecycle-paused if we were actually running.
    _pausedByLifecycle = uiState.isRunning;
    _controller.setPaused(true);
    _clearInputs();
  }

  void _clearInputs() {
    _input.setMoveAxis(0);
    _input.clearProjectileAimDir();
    _input.clearMeleeAimDir();
    _projectileAimPreview.end();
    _meleeAimPreview.end();
    _input.pumpHeldInputs();
  }

  RunnerGameUiState _buildUiState() {
    final snapshot = _controller.snapshot;
    return RunnerGameUiState(
      started: _started,
      paused: snapshot.paused,
      gameOver: snapshot.gameOver,
    );
  }

  void _startGame() {
    setState(() => _started = true);
    _clearInputs();
    _controller.setPaused(false);
  }

  void _restartGame() {
    final oldController = _controller;
    final oldProjectilePreview = _projectileAimPreview;
    final oldMeleePreview = _meleeAimPreview;
    final oldAimCancelHitboxRect = _aimCancelHitboxRect;

    setState(() {
      _pausedByLifecycle = false;
      _started = false;
      _exitConfirmOpen = false;
      _initGame();
    });
    _controller.setPaused(true);
    _clearInputs();

    WidgetsBinding.instance.addPostFrameCallback((_) {
      oldController.shutdown();
      oldController.dispose();
      oldProjectilePreview.dispose();
      oldMeleePreview.dispose();
      oldAimCancelHitboxRect.dispose();
    });
  }

  void _openExitConfirm() {
    final wasPaused = _controller.snapshot.paused;
    if (!wasPaused) _clearInputs();
    _controller.setPaused(true);

    setState(() {
      _pausedBeforeExitConfirm = wasPaused;
      _exitConfirmOpen = true;
    });
  }

  void _closeExitConfirm({required bool resume}) {
    setState(() => _exitConfirmOpen = false);
    if (resume) {
      _controller.setPaused(_pausedBeforeExitConfirm);
    }
  }

  void _confirmExitGiveUp() {
    setState(() => _exitConfirmOpen = false);
    _controller.giveUp();
  }

  void _togglePause() {
    final paused = _controller.snapshot.paused;
    if (!paused) _clearInputs();
    _controller.setPaused(!paused);
  }

  void _initGame() {
    final playerCharacter =
        PlayerCharacterRegistry.byId[widget.playerCharacterId] ??
        PlayerCharacterRegistry.defaultCharacter;
    _controller = GameController(
      core: GameCore(
        seed: widget.seed,
        levelDefinition: LevelRegistry.byId(widget.levelId),
        playerCharacter: playerCharacter,
      ),
    );
    _input = RunnerInputRouter(controller: _controller);
    _projectileAimPreview = AimPreviewModel();
    _meleeAimPreview = AimPreviewModel();
    _aimCancelHitboxRect = ValueNotifier<Rect?>(null);
    _game = RunnerFlameGame(
      controller: _controller,
      input: _input,
      projectileAimPreview: _projectileAimPreview,
      meleeAimPreview: _meleeAimPreview,
      playerCharacter: playerCharacter,
    );
  }

  void _disposeGame() {
    _controller.shutdown();
    _controller.dispose();
    _projectileAimPreview.dispose();
    _meleeAimPreview.dispose();
    _aimCancelHitboxRect.dispose();
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    _disposeGame();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Stack(
      fit: StackFit.expand,
      children: [
        LayoutBuilder(
          builder: (context, constraints) {
            final devicePixelRatio = MediaQuery.devicePixelRatioOf(context);
            final metrics = computeViewportMetrics(
              constraints,
              devicePixelRatio,
              virtualWidth,
              virtualHeight,
              widget.viewportMode,
              alignment: widget.viewportAlignment,
            );
            Widget gameView = GameViewport(
              metrics: metrics,
              child: GameWidget(
                key: ValueKey(_game),
                game: _game,
                autofocus: false,
              ),
            );

            return gameView;
          },
        ),
        AnimatedBuilder(
          animation: _controller,
          builder: (context, _) {
            final uiState = _buildUiState();
            if (uiState.gameOver) {
              final runEndedEvent = _controller.lastRunEndedEvent;
              final runEndKey =
                  runEndedEvent?.tick ?? _controller.snapshot.tick;
              return GameOverOverlay(
                key: ValueKey('gameOver-$runEndKey-${runEndedEvent?.reason}'),
                visible: true,
                onRestart: _restartGame,
                onExit: widget.onExit,
                showExitButton: widget.showExitButton,
                levelId: _controller.snapshot.levelId,
                runEndedEvent: runEndedEvent,
                scoreTuning: _controller.scoreTuning,
                tickHz: _controller.tickHz,
              );
            }
            return GameOverlay(
              controller: _controller,
              input: _input,
              projectileAimPreview: _projectileAimPreview,
              meleeAimPreview: _meleeAimPreview,
              aimCancelHitboxRect: _aimCancelHitboxRect,
              uiState: uiState,
              onStart: _startGame,
              onTogglePause: _togglePause,
              showExitButton: widget.showExitButton,
              onExit: uiState.started && !uiState.gameOver
                  ? _openExitConfirm
                  : widget.onExit,
              exitConfirmOpen: _exitConfirmOpen,
              onExitConfirmResume: () => _closeExitConfirm(resume: true),
              onExitConfirmExit: _confirmExitGiveUp,
            );
          },
        ),
      ],
    );
  }
}


===== FILE: lib/ui/scoped/scoped_preferred_orientations.dart =====
import 'package:flutter/foundation.dart';
import 'package:flutter/services.dart';
import 'package:flutter/widgets.dart';

/// Applies `SystemChrome.setPreferredOrientations` while this widget is mounted.
///
/// This is intentionally scoped to a subtree (typically a route) so the runner
/// can be embedded in a host app without enforcing a global orientation policy.
///
/// Notes:
/// - Flutter does not expose the *previous* preferred orientations, so the
///   caller must decide what to restore on dispose.
/// - Platform-level orientation support (Android manifest / iOS Info.plist)
///   still needs to include the requested orientations.
class ScopedPreferredOrientations extends StatefulWidget {
  const ScopedPreferredOrientations({
    super.key,
    required this.preferredOrientations,
    required this.child,
    this.restoreOrientations,
  });

  final List<DeviceOrientation> preferredOrientations;
  final List<DeviceOrientation>? restoreOrientations;
  final Widget child;

  @override
  State<ScopedPreferredOrientations> createState() =>
      _ScopedPreferredOrientationsState();
}

class _ScopedPreferredOrientationsState
    extends State<ScopedPreferredOrientations> {
  @override
  void initState() {
    super.initState();
    SystemChrome.setPreferredOrientations(widget.preferredOrientations);
  }

  @override
  void didUpdateWidget(covariant ScopedPreferredOrientations oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (!listEquals(
      oldWidget.preferredOrientations,
      widget.preferredOrientations,
    )) {
      SystemChrome.setPreferredOrientations(widget.preferredOrientations);
    }
  }

  @override
  void dispose() {
    final restore = widget.restoreOrientations;
    if (restore != null) {
      SystemChrome.setPreferredOrientations(restore);
    }
    super.dispose();
  }

  @override
  Widget build(BuildContext context) => widget.child;
}


===== FILE: lib/ui/scoped/scoped_system_ui_mode.dart =====
import 'package:flutter/services.dart';
import 'package:flutter/widgets.dart';

/// Applies `SystemChrome.setEnabledSystemUIMode` while this widget is mounted.
///
/// Scoped to a subtree (typically a route) so embedding stays clean.
class ScopedSystemUiMode extends StatefulWidget {
  const ScopedSystemUiMode({
    super.key,
    required this.mode,
    required this.child,
    this.overlays,
    this.restoreMode = SystemUiMode.edgeToEdge,
    this.restoreOverlays,
  });

  final SystemUiMode mode;
  final List<SystemUiOverlay>? overlays;

  final SystemUiMode restoreMode;
  final List<SystemUiOverlay>? restoreOverlays;

  final Widget child;

  @override
  State<ScopedSystemUiMode> createState() => _ScopedSystemUiModeState();
}

class _ScopedSystemUiModeState extends State<ScopedSystemUiMode> {
  @override
  void initState() {
    super.initState();
    _apply();
  }

  @override
  void didUpdateWidget(covariant ScopedSystemUiMode oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.mode != widget.mode ||
        oldWidget.overlays != widget.overlays) {
      _apply();
    }
  }

  void _apply() {
    SystemChrome.setEnabledSystemUIMode(widget.mode, overlays: widget.overlays);
  }

  @override
  void dispose() {
    SystemChrome.setEnabledSystemUIMode(
      widget.restoreMode,
      overlays: widget.restoreOverlays,
    );
    super.dispose();
  }

  @override
  Widget build(BuildContext context) => widget.child;
}


===== FILE: lib/ui/viewport/game_viewport.dart =====
import 'package:flutter/widgets.dart';

import 'viewport_metrics.dart';

/// Scales a fixed virtual canvas into the available space.
///
/// Use [computeViewportMetrics] so rendering and input mapping share the same
/// view size + offset.
class GameViewport extends StatelessWidget {
  const GameViewport({
    super.key,
    required this.metrics,
    required this.child,
    this.letterboxColor = const Color(0xFF000000),
  });

  final ViewportMetrics metrics;
  final Widget child;
  final Color letterboxColor;

  @override
  Widget build(BuildContext context) {
    return ColoredBox(
      color: letterboxColor,
      child: ClipRect(
        child: SizedBox.expand(
          child: Stack(
            fit: StackFit.expand,
            children: [
              Positioned(
                left: metrics.offsetX,
                top: metrics.offsetY,
                width: metrics.viewW,
                height: metrics.viewH,
                child: child,
              ),
            ],
          ),
        ),
      ),
    );
  }
}


===== FILE: lib/ui/viewport/viewport_metrics.dart =====
import 'dart:math' as math;

import 'package:flutter/widgets.dart';
/// Viewport scaling modes for fitting a fixed virtual canvas to the screen.
enum ViewportScaleMode {
  /// Integer physical-pixel scale (pixel-perfect, no cropping).
  ///
  /// Fits the entire virtual canvas on-screen, letterboxing the remaining area.
  pixelPerfectContain,

  /// Integer physical-pixel scale (pixel-perfect, with cropping).
  ///
  /// Fully covers the screen by scaling up until both dimensions fit. Any
  /// overflow is cropped by the outer [ClipRect].
  pixelPerfectCover,
}

/// Shared viewport sizing results for rendering and input mapping.
@immutable
class ViewportMetrics {
  const ViewportMetrics({
    required this.viewW,
    required this.viewH,
    required this.offsetX,
    required this.offsetY,
  });

  /// Scaled viewport width in logical pixels.
  final double viewW;

  /// Scaled viewport height in logical pixels.
  final double viewH;

  /// Viewport top-left offset in logical pixels.
  final double offsetX;

  /// Viewport top-left offset in logical pixels.
  final double offsetY;
}

/// Computes shared viewport metrics from the current layout constraints.
ViewportMetrics computeViewportMetrics(
  BoxConstraints constraints,
  double devicePixelRatio,
  int virtualW,
  int virtualH,
  ViewportScaleMode mode, {
  Alignment alignment = Alignment.center,
}) {
  assert(devicePixelRatio > 0);
  assert(virtualW > 0);
  assert(virtualH > 0);

  final screenW = constraints.hasBoundedWidth ? constraints.maxWidth : 0.0;
  final screenH = constraints.hasBoundedHeight ? constraints.maxHeight : 0.0;
  final screenPxW = screenW * devicePixelRatio;
  final screenPxH = screenH * devicePixelRatio;

  final scaleW = screenPxW / virtualW;
  final scaleH = screenPxH / virtualH;

  final scalePx = switch (mode) {
    ViewportScaleMode.pixelPerfectContain =>
      math.max(1.0, math.min(scaleW, scaleH).floorToDouble()),
    ViewportScaleMode.pixelPerfectCover =>
      math.max(1.0, math.max(scaleW, scaleH).ceilToDouble()),
  };

  final viewPxW = virtualW * scalePx;
  final viewPxH = virtualH * scalePx;
  final viewW = viewPxW / devicePixelRatio;
  final viewH = viewPxH / devicePixelRatio;

  final alignX = (alignment.x + 1.0) * 0.5;
  final alignY = (alignment.y + 1.0) * 0.5;
  final offsetX = (screenW - viewW) * alignX;
  final offsetY = (screenH - viewH) * alignY;

  return ViewportMetrics(
    viewW: viewW,
    viewH: viewH,
    offsetX: offsetX,
    offsetY: offsetY,
  );
}

