REPO: C:\dev\walkscape_runner
COMMIT: bde253bd21babb113d923d0469b21b8f6f41a544
DATE: 2025-12-18 22:40:51


===== FILE: lib/AGENTS.md =====
# AGENTS.md

Instructions for AI coding agents (Codex, ChatGPT, etc.) when working in this repo.

## Project mission

Port an existing **SFML/C++ 2D runner** (tools\output\c++implementation.txt)into **Flutter (Dart) + Flame** while preserving gameplay feel and making the result **production-grade** (mobile performance, clean architecture, future online-ready).

## Working style (how to collaborate)

For any non-trivial task (anything that affects architecture, touches multiple layers/files, introduces a new subsystem, or changes a core contract):

- Brainstorm 1-3 viable approaches (with tradeoffs) before coding.
- Check whether a good solution already exists (repo patterns, Flame APIs, well-maintained packages) and prefer it when it fits the goals.
- Write a short plan (steps + acceptance criteria) and align on it before implementing.
- Ask clarifying questions when requirements are underspecified or multiple designs are plausible.

For trivial/surgical changes (tiny refactors, obvious bug fixes), proceed directly but keep changes minimal and consistent with existing patterns.

## Non-negotiable architecture

This project has **three hard layers**:

1. **Core (pure Dart simulation)**: deterministic gameplay + physics + AI + RNG
2. **Render (Flame)**: visuals only (sprites/animations/camera/parallax/VFX)
3. **UI (Flutter)**: menus, overlays, navigation, settings

Rules:

- **Core must not import Flutter or Flame.**
- Flame must not be authoritative for gameplay/collision.
- UI must not modify gameplay state directly; it sends **Commands** to the controller.
- The game must be embeddable: expose a reusable widget/route entrypoint; keep `lib/main.dart` as a dev host/demo only.

## Prefer existing solutions (when they fit the goals)

Before building something custom, check if a better solution already exists:

- In this repo (search for an existing pattern/component first)
- In Flame APIs (camera, viewport, parallax, input, effects)
- In well-maintained Dart/Flutter packages

Rule of thumb:

- Prefer Flame for *render concerns* (camera components, parallax rendering, effects).
- Prefer UI (Flutter) for *UI/input widgets* (joystick/buttons/menus/overlays).
- Prefer Core for *authoritative gameplay concerns* (movement/physics/collision, ability timing, damage rules), especially when determinism/networking is a goal.

## Determinism contract

- Simulation runs in **fixed ticks** (e.g. 60 Hz). Ticks are the only time authority.
- Inputs are **Commands** queued for a specific tick.
- RNG is seeded and owned by the Core. No wall-clock randomness.
- On app resume, clamp frame dt and **never** try to "catch up" thousands of ticks.

## Core data model

### Entity storage

- Use **SoA + SparseSet** per component type.
- Entity IDs are monotonic and **never reused**.

Iteration rules:

- Systems iterate via queries (no direct sparse/dense fiddling).
- Do not add/remove components or destroy entities mid-iteration. Queue structural changes and apply after system execution.
- Do not keep references to dense arrays across ticks.

### Snapshots & events

Core outputs:

- Immutable `GameStateSnapshot` for render/UI (serializable, renderer-friendly).
- Transient `GameEvent`s (spawn/despawn/hit/sfx/screenshake/reward, etc.).

Renderer/UI must:

- Treat snapshots as read-only.
- Interpolate visuals using (`prevSnapshot`, `currSnapshot`, `alpha`) but **never simulate**.

## World / camera / pixel-art rules

- Pick one **virtual resolution** (world units == virtual pixels).
- Use **integer scaling + letterboxing**. No fractional scaling, no shimmering.
- Snap camera + render positions to integer pixels inside the scaled viewport.

## Asset rules

- Assets are loaded **per scene**, not at boot.
- No asset loading during active gameplay.
- Unload game assets when leaving the mini-game route.

## Implementation sequencing

Follow the V0 plan (small, testable increments):

1. Scaffold + wiring (`lib/core`, `lib/game`, `lib/ui`)
2. Camera/viewport/parallax
3. Core collision + player run/jump
4. Mobile controls
5. Abilities/resources
6. Enemies (simple AI)
7. Deterministic spawning

If you deviate, explain why and keep the same boundaries.

## Code quality rules (Dart/Flutter)

- Keep the codebase modular and scalable:
  - prefer small, cohesive modules with clear boundaries
  - avoid tight coupling across Core/Render/UI; depend on stable contracts instead
  - keep public embedding API stable (`lib/runner.dart`), treat internal folders as refactorable
- Keep responsibilities narrow; avoid "god" classes that mix input/sim/render.
- Prefer explicit data flow: Commands in, snapshots/events out.
- Keep Core allocation-light: avoid per-tick new Lists/Maps in hot loops.
- Prefer `final`, `const`, and value types for small structs (e.g. `Vec2`).
- No `dynamic` in gameplay code (prefer typed payloads; if a temporary map is unavoidable, confine it to UI/debug only).
- Make side effects explicit: Core returns events; render/UI consume them.
- Keep changes consistent with existing style; avoid renames/reformatting unrelated code.
- Add/extend tests when relevant (especially when new behavior is introduced or existing behavior changes):
  - Core behavior: unit tests in `test/core/**` (`dart test`)
  - UI/viewport/widget behavior: widget tests where appropriate
- Keep docs in sync with code: update relevant docs whenever behavior, contracts, milestones, or public APIs change.

## What an agent must do on each task

When asked to implement/fix something:

1. Identify which layer it belongs to (Core vs Render vs UI).
2. Check for an existing solution/pattern that already fits the goal (repo + Flame + packages).
3. Propose a minimal plan (1-3 steps) and acceptance criteria.
4. Implement with deterministic rules intact.
5. Update docs/comments whenever a change affects behavior, contracts, milestones, or usage:
   - update `docs/plan.md` if architecture rules/contracts change
   - update `docs/v0-implementation-plan.md` if milestone checklist changes
   - update top-of-file docs and public API docs (`lib/runner.dart`, route/widget docs) when embedding/API expectations change
6. Add/extend relevant tests when new behavior is introduced or existing behavior changes (especially Core determinism and systems).
7. Provide:
   - files changed + why
   - how to run/verify (build + quick sanity checks)
   - follow-ups (next incremental step)

## What NOT to do

- Don't add Flutter/Flame imports into `lib/core/**`.
- Don't use Flame collision callbacks as gameplay truth.
- Don't introduce wall-clock timing in simulation (no `DateTime.now()`, no frame-dt gameplay).
- Don't "just make it work" by mixing UI/render/core responsibilities.

## Suggested folder layout

- `lib/core/`    - simulation, components, systems, RNG, commands, snapshots
- `lib/game/`    - Flame `Game`, entity view components, camera/parallax, render adapters
- `lib/ui/`      - menus, overlays, UI state, input widgets
- `test/`        - Core unit tests

---
If anything here conflicts with repo docs, treat repo docs as the source of truth.


===== FILE: lib/core/collision/static_world_geometry.dart =====
/// Static collision geometry owned by the Core simulation.
///
/// V0 starts with a tiny, hand-authored set (ground band + a couple platforms),
/// and later milestones replace/extend this with deterministic chunk spawning.
class StaticGroundPlane {
  const StaticGroundPlane({required this.topY});

  /// World-space Y coordinate of the ground surface (solid top).
  final double topY;
}

class StaticSolid {
  const StaticSolid({
    required this.minX,
    required this.minY,
    required this.maxX,
    required this.maxY,
    this.sides = sideTop,
    this.oneWayTop = true,
  }) : assert(maxX >= minX),
       assert(maxY >= minY);

  final double minX;
  final double minY;
  final double maxX;
  final double maxY;

  /// Which faces of this solid participate in collision resolution.
  ///
  /// For V0:
  /// - one-way platforms typically use `sideTop` only
  /// - obstacles typically use `sideAll`
  final int sides;

  /// If true, the top surface only collides while falling (platform behavior).
  ///
  /// This only applies when [sides] includes [sideTop].
  final bool oneWayTop;

  static const int sideNone = 0;
  static const int sideTop = 1 << 0;
  static const int sideBottom = 1 << 1;
  static const int sideLeft = 1 << 2;
  static const int sideRight = 1 << 3;
  static const int sideAll = sideTop | sideBottom | sideLeft | sideRight;
}

/// Immutable bundle of static solids for a run/session.
class StaticWorldGeometry {
  const StaticWorldGeometry({
    this.groundPlane,
    this.solids = const <StaticSolid>[],
  });

  /// Optional infinite ground plane (top surface only).
  final StaticGroundPlane? groundPlane;

  final List<StaticSolid> solids;
}


===== FILE: lib/core/collision/static_world_geometry_index.dart =====
import 'static_world_geometry.dart';

/// Pre-indexed view of static world geometry for faster collision queries.
///
/// This is constructed once (per run/session) and preserves the original solid
/// ordering in each face list to keep behavior deterministic.
class StaticWorldGeometryIndex {
  StaticWorldGeometryIndex._({
    required this.geometry,
    required this.groundPlane,
    required this.tops,
    required this.bottoms,
    required this.leftWalls,
    required this.rightWalls,
  });

  factory StaticWorldGeometryIndex.from(StaticWorldGeometry geometry) {
    final tops = <StaticSolid>[];
    final bottoms = <StaticSolid>[];
    final leftWalls = <StaticSolid>[];
    final rightWalls = <StaticSolid>[];

    for (final solid in geometry.solids) {
      final sides = solid.sides;
      if ((sides & StaticSolid.sideTop) != 0) tops.add(solid);
      if ((sides & StaticSolid.sideBottom) != 0) bottoms.add(solid);
      if ((sides & StaticSolid.sideLeft) != 0) leftWalls.add(solid);
      if ((sides & StaticSolid.sideRight) != 0) rightWalls.add(solid);
    }

    return StaticWorldGeometryIndex._(
      geometry: geometry,
      groundPlane: geometry.groundPlane,
      tops: List<StaticSolid>.unmodifiable(tops),
      bottoms: List<StaticSolid>.unmodifiable(bottoms),
      leftWalls: List<StaticSolid>.unmodifiable(leftWalls),
      rightWalls: List<StaticSolid>.unmodifiable(rightWalls),
    );
  }

  /// Source geometry (unchanged).
  final StaticWorldGeometry geometry;

  /// Optional infinite ground plane.
  final StaticGroundPlane? groundPlane;

  /// Solids with an enabled top face.
  final List<StaticSolid> tops;

  /// Solids with an enabled bottom face (ceilings).
  final List<StaticSolid> bottoms;

  /// Solids with an enabled left face (walls hit when moving right).
  final List<StaticSolid> leftWalls;

  /// Solids with an enabled right face (walls hit when moving left).
  final List<StaticSolid> rightWalls;
}


===== FILE: lib/core/combat/damage.dart =====
import '../ecs/entity_id.dart';

class DamageRequest {
  const DamageRequest({
    required this.target,
    required this.amount,
    this.source,
  });

  final EntityId target;
  final double amount;
  final EntityId? source;
}



===== FILE: lib/core/combat/faction.dart =====
enum Faction { player, enemy }



===== FILE: lib/core/commands/command.dart =====
/// Core input command model.
///
/// Commands are the only way UI can affect the simulation:
/// UI -> `GameController.enqueue(...)` -> Core applies them at a specific `tick`.
///
/// These command types are intentionally minimal placeholders for Milestone 0.
sealed class Command {
  const Command({required this.tick});

  /// Simulation tick at which this command must be applied.
  final int tick;
}

/// Player movement input for the given tick.
///
/// `axis` is typically in `[-1, 1]` (left/right), originating from a joystick.
final class MoveAxisCommand extends Command {
  const MoveAxisCommand({required super.tick, required this.axis});

  /// Horizontal movement axis, usually in `[-1, 1]`.
  final double axis;
}

/// One-shot jump press event for the given tick.
final class JumpPressedCommand extends Command {
  const JumpPressedCommand({required super.tick});
}

/// One-shot dash press event for the given tick.
final class DashPressedCommand extends Command {
  const DashPressedCommand({required super.tick});
}

/// One-shot attack press event for the given tick.
final class AttackPressedCommand extends Command {
  const AttackPressedCommand({required super.tick});
}

/// Continuous aim direction for the given tick.
///
/// The direction should be normalized (or near-normalized). It is expressed in
/// world space and used by casting/abilities.
final class AimDirCommand extends Command {
  const AimDirCommand({required super.tick, required this.x, required this.y});

  final double x;
  final double y;
}

/// Clears any held aim direction for the given tick.
///
/// This exists so input schedulers that pre-buffer future ticks can overwrite
/// previously-scheduled aim commands when the player releases aim input.
final class ClearAimDirCommand extends Command {
  const ClearAimDirCommand({required super.tick});
}

/// One-shot cast press event for the given tick.
final class CastPressedCommand extends Command {
  const CastPressedCommand({required super.tick});
}


===== FILE: lib/core/contracts/v0_render_contract.dart =====
/// V0 render + coordinate contract shared across layers.
///
/// These values are intentionally defined in `lib/core/**` (pure Dart) so Core,
/// Render (Flame), and UI (Flutter) can all agree on the same coordinate system
/// without introducing Flutter/Flame dependencies into the simulation.
///
/// V0 rules:
/// - Virtual resolution is fixed at 480×270 (16:9).
/// - 1 world unit == 1 virtual pixel.
/// - Axes/origin follow Flutter/Flame conventions: (0,0) top-left, +X right,
///   +Y down.
/// - Camera uses a fixed-resolution viewport and integer snapping.
///
/// Ground reference:
/// - The parallax set assets are 512×256.
/// - For `Field Layer 09.png`, the first non-transparent row starts at Y=241
///   within the image (measured from the asset in this repo).
/// - When bottom-aligning the 256px image into a 270px viewport, Y offset is
///   (270 - 256) = 14, therefore `v0GroundTopY = 14 + 241 = 255`.
const int v0VirtualWidth = 480;
const int v0VirtualHeight = 270;

const int v0FieldLayerImageWidth = 512;
const int v0FieldLayerImageHeight = 256;

const int v0FieldLayerBottomAlignedOffsetY =
    v0VirtualHeight - v0FieldLayerImageHeight; // 14

const int v0FieldLayer09OpaqueTopInImageY = 241;
const int v0GroundTopY =
    v0FieldLayerBottomAlignedOffsetY + v0FieldLayer09OpaqueTopInImageY; // 255

const double v0CameraFixedY = v0VirtualHeight / 2; // 135.0



===== FILE: lib/core/ecs/entity_id.dart =====
/// Opaque identifier for entities in the Core simulation.
///
/// Entity IDs are monotonic and never reused within a session.
typedef EntityId = int;


===== FILE: lib/core/ecs/queries.dart =====
import 'entity_id.dart';
import 'world.dart';

typedef MovementQueryFn =
    void Function(EntityId e, int mi, int ti, int ii, int bi, int ci, int si);

typedef ColliderQueryFn =
    void Function(EntityId e, int ti, int bi, int coli, int aabbi);

class EcsQueries {
  static void forMovementBodies(EcsWorld world, MovementQueryFn fn) {
    final movement = world.movement;
    final entities = movement.denseEntities;

    for (var mi = 0; mi < entities.length; mi += 1) {
      final e = entities[mi];

      final ti = world.transform.tryIndexOf(e);
      if (ti == null) continue;
      final ii = world.playerInput.tryIndexOf(e);
      if (ii == null) continue;
      final bi = world.body.tryIndexOf(e);
      if (bi == null) continue;
      final ci = world.collision.tryIndexOf(e);
      if (ci == null) continue;
      final si = world.stamina.tryIndexOf(e);
      if (si == null) continue;

      fn(e, mi, ti, ii, bi, ci, si);
    }
  }

  static void forColliders(EcsWorld world, ColliderQueryFn fn) {
    final aabb = world.colliderAabb;
    final entities = aabb.denseEntities;

    for (var aabbi = 0; aabbi < entities.length; aabbi += 1) {
      final e = entities[aabbi];

      final ti = world.transform.tryIndexOf(e);
      if (ti == null) continue;
      final bi = world.body.tryIndexOf(e);
      if (bi == null) continue;
      final coli = world.collision.tryIndexOf(e);
      if (coli == null) continue;

      fn(e, ti, bi, coli, aabbi);
    }
  }
}


===== FILE: lib/core/ecs/sparse_set.dart =====
import 'entity_id.dart';

/// Base sparse-set bookkeeping for component stores.
///
/// - `sparse[entity]` stores (denseIndex + 1), or 0 when absent.
/// - `denseEntities[denseIndex]` stores the owning [EntityId].
///
/// This enables:
/// - O(1) contains
/// - O(1) add/remove (swap-remove)
/// - cache-friendly iteration over `denseEntities`
abstract class SparseSet {
  final List<EntityId> denseEntities = <EntityId>[];
  final List<int> _sparse = <int>[];

  bool has(EntityId entity) {
    if (entity < 0) return false;
    if (entity >= _sparse.length) return false;
    return _sparse[entity] != 0;
  }

  int indexOf(EntityId entity) {
    final idxPlus1 = _sparse[entity];
    return idxPlus1 - 1;
  }

  int? tryIndexOf(EntityId entity) {
    if (!has(entity)) return null;
    return indexOf(entity);
  }

  void ensureCapacity(EntityId entity) {
    if (entity < _sparse.length) return;
    final toAdd = entity + 1 - _sparse.length;
    if (toAdd <= 0) return;
    _sparse.addAll(List<int>.filled(toAdd, 0));
  }

  int addEntity(EntityId entity) {
    ensureCapacity(entity);
    final existing = _sparse[entity];
    if (existing != 0) return existing - 1;

    final denseIndex = denseEntities.length;
    denseEntities.add(entity);
    _sparse[entity] = denseIndex + 1;
    onDenseAdded(denseIndex);
    return denseIndex;
  }

  void removeEntity(EntityId entity) {
    if (!has(entity)) return;

    final removeIndex = indexOf(entity);
    final lastIndex = denseEntities.length - 1;

    onSwapRemove(removeIndex, lastIndex);

    final lastEntity = denseEntities[lastIndex];
    denseEntities[removeIndex] = lastEntity;
    denseEntities.removeLast();

    _sparse[entity] = 0;
    if (removeIndex != lastIndex) {
      _sparse[lastEntity] = removeIndex + 1;
    }
  }

  /// Called after a new dense slot has been appended.
  void onDenseAdded(int denseIndex);

  /// Called before dense arrays are swap-removed from [removeIndex] and [lastIndex].
  void onSwapRemove(int removeIndex, int lastIndex);
}


===== FILE: lib/core/ecs/stores/body_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

/// Configuration for how an entity participates in physics.
///
/// This is intentionally "config-like" and reusable across players/enemies:
/// - `Transform` holds state (pos/vel)
/// - `Movement` holds controller-specific timers/state (coyote, dash, etc.)
/// - `Body` holds physics participation and constraints (gravity, clamps, kinematic)
class BodyDef {
  const BodyDef({
    this.enabled = true,
    this.isKinematic = false,
    this.useGravity = true,
    this.topOnlyGround = true,
    this.gravityScale = 1.0,
    this.maxVelX = 3000,
    this.maxVelY = 3000,
    this.sideMask = sideLeft | sideRight,
  });

  /// Master on/off switch for physics on this entity.
  final bool enabled;

  /// If true, physics does not integrate position/velocity (gameplay code drives it).
  final bool isKinematic;

  /// Whether gravity affects this body.
  final bool useGravity;

  /// If true, collision should resolve only top contacts (platformer-style).
  /// Used by `CollisionSystem` (later milestone).
  final bool topOnlyGround;

  /// Scale applied to global/tuning gravity (1.0 = normal gravity).
  final double gravityScale;

  /// Per-axis velocity clamps (safety caps).
  final double maxVelX;
  final double maxVelY;

  /// Horizontal collision sides bitmask (used by `CollisionSystem` later).
  final int sideMask;

  static const int sideNone = 0;
  static const int sideLeft = 1 << 0;
  static const int sideRight = 1 << 1;
}

/// SoA store for `Body` configuration.
class BodyStore extends SparseSet {
  final List<bool> enabled = <bool>[];
  final List<bool> isKinematic = <bool>[];
  final List<bool> useGravity = <bool>[];
  final List<bool> topOnlyGround = <bool>[];

  final List<double> gravityScale = <double>[];
  final List<double> maxVelX = <double>[];
  final List<double> maxVelY = <double>[];

  final List<int> sideMask = <int>[];

  void add(EntityId entity, BodyDef def) {
    final i = addEntity(entity);
    enabled[i] = def.enabled;
    isKinematic[i] = def.isKinematic;
    useGravity[i] = def.useGravity;
    topOnlyGround[i] = def.topOnlyGround;
    gravityScale[i] = def.gravityScale;
    maxVelX[i] = def.maxVelX;
    maxVelY[i] = def.maxVelY;
    sideMask[i] = def.sideMask;
  }

  @override
  void onDenseAdded(int denseIndex) {
    enabled.add(true);
    isKinematic.add(false);
    useGravity.add(true);
    topOnlyGround.add(true);
    gravityScale.add(1);
    maxVelX.add(3000);
    maxVelY.add(3000);
    sideMask.add(BodyDef.sideNone);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    enabled[removeIndex] = enabled[lastIndex];
    isKinematic[removeIndex] = isKinematic[lastIndex];
    useGravity[removeIndex] = useGravity[lastIndex];
    topOnlyGround[removeIndex] = topOnlyGround[lastIndex];
    gravityScale[removeIndex] = gravityScale[lastIndex];
    maxVelX[removeIndex] = maxVelX[lastIndex];
    maxVelY[removeIndex] = maxVelY[lastIndex];
    sideMask[removeIndex] = sideMask[lastIndex];

    enabled.removeLast();
    isKinematic.removeLast();
    useGravity.removeLast();
    topOnlyGround.removeLast();
    gravityScale.removeLast();
    maxVelX.removeLast();
    maxVelY.removeLast();
    sideMask.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/collider_aabb_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

/// AABB collider configuration for an entity.
///
/// Representation is center-based for stability:
/// - `Transform.pos` is treated as the entity center
/// - collider center is `pos + offset`
/// - extents are half-sizes in world units (virtual pixels)
class ColliderAabbDef {
  const ColliderAabbDef({
    required this.halfX,
    required this.halfY,
    this.offsetX = 0,
    this.offsetY = 0,
  });

  final double halfX;
  final double halfY;
  final double offsetX;
  final double offsetY;
}

/// SoA store for AABB collider config (half extents + offset).
class ColliderAabbStore extends SparseSet {
  final List<double> halfX = <double>[];
  final List<double> halfY = <double>[];
  final List<double> offsetX = <double>[];
  final List<double> offsetY = <double>[];

  void add(EntityId entity, ColliderAabbDef def) {
    final i = addEntity(entity);
    halfX[i] = def.halfX;
    halfY[i] = def.halfY;
    offsetX[i] = def.offsetX;
    offsetY[i] = def.offsetY;
  }

  @override
  void onDenseAdded(int denseIndex) {
    halfX.add(0);
    halfY.add(0);
    offsetX.add(0);
    offsetY.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    halfX[removeIndex] = halfX[lastIndex];
    halfY[removeIndex] = halfY[lastIndex];
    offsetX[removeIndex] = offsetX[lastIndex];
    offsetY[removeIndex] = offsetY[lastIndex];

    halfX.removeLast();
    halfY.removeLast();
    offsetX.removeLast();
    offsetY.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/collision_state_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

/// Per-tick collision results for an entity.
///
/// This is reset each tick by the CollisionSystem.
class CollisionStateStore extends SparseSet {
  final List<bool> grounded = <bool>[];
  final List<bool> hitCeiling = <bool>[];
  final List<bool> hitLeft = <bool>[];
  final List<bool> hitRight = <bool>[];

  void add(EntityId entity) {
    addEntity(entity);
  }

  void resetTick(EntityId entity) {
    final i = indexOf(entity);
    grounded[i] = false;
    hitCeiling[i] = false;
    hitLeft[i] = false;
    hitRight[i] = false;
  }

  @override
  void onDenseAdded(int denseIndex) {
    grounded.add(false);
    hitCeiling.add(false);
    hitLeft.add(false);
    hitRight.add(false);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    grounded[removeIndex] = grounded[lastIndex];
    hitCeiling[removeIndex] = hitCeiling[lastIndex];
    hitLeft[removeIndex] = hitLeft[lastIndex];
    hitRight[removeIndex] = hitRight[lastIndex];

    grounded.removeLast();
    hitCeiling.removeLast();
    hitLeft.removeLast();
    hitRight.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/cooldown_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

class CooldownDef {
  const CooldownDef({
    this.castCooldownTicksLeft = 0,
    this.meleeCooldownTicksLeft = 0,
  });

  final int castCooldownTicksLeft;
  final int meleeCooldownTicksLeft;
}

class CooldownStore extends SparseSet {
  final List<int> castCooldownTicksLeft = <int>[];
  final List<int> meleeCooldownTicksLeft = <int>[];

  void add(EntityId entity, [CooldownDef def = const CooldownDef()]) {
    final i = addEntity(entity);
    castCooldownTicksLeft[i] = def.castCooldownTicksLeft;
    meleeCooldownTicksLeft[i] = def.meleeCooldownTicksLeft;
  }

  @override
  void onDenseAdded(int denseIndex) {
    castCooldownTicksLeft.add(0);
    meleeCooldownTicksLeft.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    castCooldownTicksLeft[removeIndex] = castCooldownTicksLeft[lastIndex];
    meleeCooldownTicksLeft[removeIndex] = meleeCooldownTicksLeft[lastIndex];
    castCooldownTicksLeft.removeLast();
    meleeCooldownTicksLeft.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/faction_store.dart =====
import '../../combat/faction.dart';
import '../entity_id.dart';
import '../sparse_set.dart';

class FactionDef {
  const FactionDef({required this.faction});

  final Faction faction;
}

class FactionStore extends SparseSet {
  final List<Faction> faction = <Faction>[];

  void add(EntityId entity, FactionDef def) {
    final i = addEntity(entity);
    faction[i] = def.faction;
  }

  @override
  void onDenseAdded(int denseIndex) {
    faction.add(Faction.player);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    faction[removeIndex] = faction[lastIndex];
    faction.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/health_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

class HealthDef {
  const HealthDef({
    required this.hp,
    required this.hpMax,
    required this.regenPerSecond,
  });

  final double hp;
  final double hpMax;
  final double regenPerSecond;
}

class HealthStore extends SparseSet {
  final List<double> hp = <double>[];
  final List<double> hpMax = <double>[];
  final List<double> regenPerSecond = <double>[];

  void add(EntityId entity, HealthDef def) {
    final i = addEntity(entity);
    hp[i] = def.hp;
    hpMax[i] = def.hpMax;
    regenPerSecond[i] = def.regenPerSecond;
  }

  @override
  void onDenseAdded(int denseIndex) {
    hp.add(0);
    hpMax.add(0);
    regenPerSecond.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    hp[removeIndex] = hp[lastIndex];
    hpMax[removeIndex] = hpMax[lastIndex];
    regenPerSecond[removeIndex] = regenPerSecond[lastIndex];

    hp.removeLast();
    hpMax.removeLast();
    regenPerSecond.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/hit_once_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

class HitOnceStore extends SparseSet {
  final List<int> count = <int>[];
  final List<EntityId> hit0 = <EntityId>[];
  final List<EntityId> hit1 = <EntityId>[];
  final List<EntityId> hit2 = <EntityId>[];
  final List<EntityId> hit3 = <EntityId>[];

  void add(EntityId entity) {
    addEntity(entity);
  }

  bool hasHit(EntityId entity, EntityId target) {
    final i = indexOf(entity);
    final c = count[i];
    if (c <= 0) return false;
    if (hit0[i] == target) return true;
    if (c <= 1) return false;
    if (hit1[i] == target) return true;
    if (c <= 2) return false;
    if (hit2[i] == target) return true;
    if (c <= 3) return false;
    return hit3[i] == target;
  }

  void markHit(EntityId entity, EntityId target) {
    final i = indexOf(entity);
    var c = count[i];
    if (c <= 0) {
      hit0[i] = target;
      count[i] = 1;
      return;
    }
    if (c == 1) {
      hit1[i] = target;
      count[i] = 2;
      return;
    }
    if (c == 2) {
      hit2[i] = target;
      count[i] = 3;
      return;
    }
    if (c == 3) {
      hit3[i] = target;
      count[i] = 4;
      return;
    }
    // Saturate: in V0 we don't expect more than a few hits per swing.
  }

  @override
  void onDenseAdded(int denseIndex) {
    count.add(0);
    hit0.add(0);
    hit1.add(0);
    hit2.add(0);
    hit3.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    count[removeIndex] = count[lastIndex];
    hit0[removeIndex] = hit0[lastIndex];
    hit1[removeIndex] = hit1[lastIndex];
    hit2[removeIndex] = hit2[lastIndex];
    hit3[removeIndex] = hit3[lastIndex];

    count.removeLast();
    hit0.removeLast();
    hit1.removeLast();
    hit2.removeLast();
    hit3.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/hitbox_store.dart =====
import '../../combat/faction.dart';
import '../entity_id.dart';
import '../sparse_set.dart';

class HitboxDef {
  const HitboxDef({
    required this.owner,
    required this.faction,
    required this.damage,
    required this.halfX,
    required this.halfY,
    required this.offsetX,
    required this.offsetY,
  });

  final EntityId owner;
  final Faction faction;
  final double damage;
  final double halfX;
  final double halfY;
  final double offsetX;
  final double offsetY;
}

/// Short-lived damage hitbox used by melee attacks and area effects.
class HitboxStore extends SparseSet {
  final List<EntityId> owner = <EntityId>[];
  final List<Faction> faction = <Faction>[];
  final List<double> damage = <double>[];
  final List<double> halfX = <double>[];
  final List<double> halfY = <double>[];
  final List<double> offsetX = <double>[];
  final List<double> offsetY = <double>[];

  void add(EntityId entity, HitboxDef def) {
    final i = addEntity(entity);
    owner[i] = def.owner;
    faction[i] = def.faction;
    damage[i] = def.damage;
    halfX[i] = def.halfX;
    halfY[i] = def.halfY;
    offsetX[i] = def.offsetX;
    offsetY[i] = def.offsetY;
  }

  @override
  void onDenseAdded(int denseIndex) {
    owner.add(0);
    faction.add(Faction.player);
    damage.add(0);
    halfX.add(0);
    halfY.add(0);
    offsetX.add(0);
    offsetY.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    owner[removeIndex] = owner[lastIndex];
    faction[removeIndex] = faction[lastIndex];
    damage[removeIndex] = damage[lastIndex];
    halfX[removeIndex] = halfX[lastIndex];
    halfY[removeIndex] = halfY[lastIndex];
    offsetX[removeIndex] = offsetX[lastIndex];
    offsetY[removeIndex] = offsetY[lastIndex];

    owner.removeLast();
    faction.removeLast();
    damage.removeLast();
    halfX.removeLast();
    halfY.removeLast();
    offsetX.removeLast();
    offsetY.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/lifetime_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

class LifetimeDef {
  const LifetimeDef({required this.ticksLeft});

  final int ticksLeft;
}

class LifetimeStore extends SparseSet {
  final List<int> ticksLeft = <int>[];

  void add(EntityId entity, LifetimeDef def) {
    final i = addEntity(entity);
    ticksLeft[i] = def.ticksLeft;
  }

  @override
  void onDenseAdded(int denseIndex) {
    ticksLeft.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    ticksLeft[removeIndex] = ticksLeft[lastIndex];
    ticksLeft.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/mana_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

class ManaDef {
  const ManaDef({
    required this.mana,
    required this.manaMax,
    required this.regenPerSecond,
  });

  final double mana;
  final double manaMax;
  final double regenPerSecond;
}

class ManaStore extends SparseSet {
  final List<double> mana = <double>[];
  final List<double> manaMax = <double>[];
  final List<double> regenPerSecond = <double>[];

  void add(EntityId entity, ManaDef def) {
    final i = addEntity(entity);
    mana[i] = def.mana;
    manaMax[i] = def.manaMax;
    regenPerSecond[i] = def.regenPerSecond;
  }

  @override
  void onDenseAdded(int denseIndex) {
    mana.add(0);
    manaMax.add(0);
    regenPerSecond.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    mana[removeIndex] = mana[lastIndex];
    manaMax[removeIndex] = manaMax[lastIndex];
    regenPerSecond[removeIndex] = regenPerSecond[lastIndex];

    mana.removeLast();
    manaMax.removeLast();
    regenPerSecond.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/movement_store.dart =====
import '../../snapshots/enums.dart';
import '../entity_id.dart';
import '../sparse_set.dart';

/// Movement state for platformer-style motion (timers + grounded + facing).
class MovementStore extends SparseSet {
  final List<int> coyoteTicksLeft = <int>[];
  final List<int> jumpBufferTicksLeft = <int>[];

  final List<int> dashTicksLeft = <int>[];
  final List<int> dashCooldownTicksLeft = <int>[];
  final List<double> dashDirX = <double>[];

  final List<Facing> facing = <Facing>[];

  void add(EntityId entity, {required Facing facing}) {
    final i = addEntity(entity);
    this.facing[i] = facing;
  }

  bool isDashing(EntityId entity) => dashTicksLeft[indexOf(entity)] > 0;

  @override
  void onDenseAdded(int denseIndex) {
    coyoteTicksLeft.add(0);
    jumpBufferTicksLeft.add(0);
    dashTicksLeft.add(0);
    dashCooldownTicksLeft.add(0);
    dashDirX.add(1);
    facing.add(Facing.right);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    coyoteTicksLeft[removeIndex] = coyoteTicksLeft[lastIndex];
    jumpBufferTicksLeft[removeIndex] = jumpBufferTicksLeft[lastIndex];
    dashTicksLeft[removeIndex] = dashTicksLeft[lastIndex];
    dashCooldownTicksLeft[removeIndex] = dashCooldownTicksLeft[lastIndex];
    dashDirX[removeIndex] = dashDirX[lastIndex];
    facing[removeIndex] = facing[lastIndex];

    coyoteTicksLeft.removeLast();
    jumpBufferTicksLeft.removeLast();
    dashTicksLeft.removeLast();
    dashCooldownTicksLeft.removeLast();
    dashDirX.removeLast();
    facing.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/player_input_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

/// Per-tick player input (authoritative commands decoded by the core).
///
/// This is reset/overwritten each tick by `GameCore.applyCommands`.
class PlayerInputStore extends SparseSet {
  final List<double> moveAxis = <double>[];
  final List<bool> jumpPressed = <bool>[];
  final List<bool> dashPressed = <bool>[];
  final List<bool> attackPressed = <bool>[];
  final List<double> aimDirX = <double>[];
  final List<double> aimDirY = <double>[];
  final List<bool> castPressed = <bool>[];

  void add(EntityId entity) {
    addEntity(entity);
  }

  void resetTickInputs(EntityId entity) {
    final i = indexOf(entity);
    moveAxis[i] = 0;
    jumpPressed[i] = false;
    dashPressed[i] = false;
    attackPressed[i] = false;
    aimDirX[i] = 0;
    aimDirY[i] = 0;
    castPressed[i] = false;
  }

  @override
  void onDenseAdded(int denseIndex) {
    moveAxis.add(0);
    jumpPressed.add(false);
    dashPressed.add(false);
    attackPressed.add(false);
    aimDirX.add(0);
    aimDirY.add(0);
    castPressed.add(false);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    moveAxis[removeIndex] = moveAxis[lastIndex];
    jumpPressed[removeIndex] = jumpPressed[lastIndex];
    dashPressed[removeIndex] = dashPressed[lastIndex];
    attackPressed[removeIndex] = attackPressed[lastIndex];
    aimDirX[removeIndex] = aimDirX[lastIndex];
    aimDirY[removeIndex] = aimDirY[lastIndex];
    castPressed[removeIndex] = castPressed[lastIndex];

    moveAxis.removeLast();
    jumpPressed.removeLast();
    dashPressed.removeLast();
    attackPressed.removeLast();
    aimDirX.removeLast();
    aimDirY.removeLast();
    castPressed.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/projectile_store.dart =====
import '../../combat/faction.dart';
import '../../projectiles/projectile_id.dart';
import '../entity_id.dart';
import '../sparse_set.dart';

class ProjectileDef {
  const ProjectileDef({
    required this.projectileId,
    required this.faction,
    required this.owner,
    required this.dirX,
    required this.dirY,
    required this.speedUnitsPerSecond,
    required this.damage,
  });

  final ProjectileId projectileId;
  final Faction faction;
  final EntityId owner;
  final double dirX;
  final double dirY;
  final double speedUnitsPerSecond;
  final double damage;
}

class ProjectileStore extends SparseSet {
  final List<ProjectileId> projectileId = <ProjectileId>[];
  final List<Faction> faction = <Faction>[];
  final List<EntityId> owner = <EntityId>[];
  final List<double> dirX = <double>[];
  final List<double> dirY = <double>[];
  final List<double> speedUnitsPerSecond = <double>[];
  final List<double> damage = <double>[];

  void add(EntityId entity, ProjectileDef def) {
    final i = addEntity(entity);
    projectileId[i] = def.projectileId;
    faction[i] = def.faction;
    owner[i] = def.owner;
    dirX[i] = def.dirX;
    dirY[i] = def.dirY;
    speedUnitsPerSecond[i] = def.speedUnitsPerSecond;
    damage[i] = def.damage;
  }

  @override
  void onDenseAdded(int denseIndex) {
    projectileId.add(ProjectileId.iceBolt);
    faction.add(Faction.player);
    owner.add(0);
    dirX.add(1.0);
    dirY.add(0.0);
    speedUnitsPerSecond.add(0.0);
    damage.add(0.0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    projectileId[removeIndex] = projectileId[lastIndex];
    faction[removeIndex] = faction[lastIndex];
    owner[removeIndex] = owner[lastIndex];
    dirX[removeIndex] = dirX[lastIndex];
    dirY[removeIndex] = dirY[lastIndex];
    speedUnitsPerSecond[removeIndex] = speedUnitsPerSecond[lastIndex];
    damage[removeIndex] = damage[lastIndex];

    projectileId.removeLast();
    faction.removeLast();
    owner.removeLast();
    dirX.removeLast();
    dirY.removeLast();
    speedUnitsPerSecond.removeLast();
    damage.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/spell_origin_store.dart =====
import '../../spells/spell_id.dart';
import '../entity_id.dart';
import '../sparse_set.dart';

class SpellOriginDef {
  const SpellOriginDef({required this.spellId});

  final SpellId spellId;
}

class SpellOriginStore extends SparseSet {
  final List<SpellId> spellId = <SpellId>[];

  void add(EntityId entity, SpellOriginDef def) {
    final i = addEntity(entity);
    spellId[i] = def.spellId;
  }

  @override
  void onDenseAdded(int denseIndex) {
    spellId.add(SpellId.iceBolt);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    spellId[removeIndex] = spellId[lastIndex];
    spellId.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/stamina_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

class StaminaDef {
  const StaminaDef({
    required this.stamina,
    required this.staminaMax,
    required this.regenPerSecond,
  });

  final double stamina;
  final double staminaMax;
  final double regenPerSecond;
}

class StaminaStore extends SparseSet {
  final List<double> stamina = <double>[];
  final List<double> staminaMax = <double>[];
  final List<double> regenPerSecond = <double>[];

  void add(EntityId entity, StaminaDef def) {
    final i = addEntity(entity);
    stamina[i] = def.stamina;
    staminaMax[i] = def.staminaMax;
    regenPerSecond[i] = def.regenPerSecond;
  }

  @override
  void onDenseAdded(int denseIndex) {
    stamina.add(0);
    staminaMax.add(0);
    regenPerSecond.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    stamina[removeIndex] = stamina[lastIndex];
    staminaMax[removeIndex] = staminaMax[lastIndex];
    regenPerSecond[removeIndex] = regenPerSecond[lastIndex];

    stamina.removeLast();
    staminaMax.removeLast();
    regenPerSecond.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/transform_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

/// SoA store for `Transform` (position + velocity).
class TransformStore extends SparseSet {
  final List<double> posX = <double>[];
  final List<double> posY = <double>[];
  final List<double> velX = <double>[];
  final List<double> velY = <double>[];

  void add(
    EntityId entity, {
    required double posX,
    required double posY,
    required double velX,
    required double velY,
  }) {
    final i = addEntity(entity);
    this.posX[i] = posX;
    this.posY[i] = posY;
    this.velX[i] = velX;
    this.velY[i] = velY;
  }

  void setPosXY(EntityId entity, double x, double y) {
    final i = indexOf(entity);
    posX[i] = x;
    posY[i] = y;
  }

  void setVelXY(EntityId entity, double x, double y) {
    final i = indexOf(entity);
    velX[i] = x;
    velY[i] = y;
  }

  @override
  void onDenseAdded(int denseIndex) {
    posX.add(0);
    posY.add(0);
    velX.add(0);
    velY.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    posX[removeIndex] = posX[lastIndex];
    posY[removeIndex] = posY[lastIndex];
    velX[removeIndex] = velX[lastIndex];
    velY[removeIndex] = velY[lastIndex];

    posX.removeLast();
    posY.removeLast();
    velX.removeLast();
    velY.removeLast();
  }
}


===== FILE: lib/core/ecs/systems/cast_system.dart =====
import 'dart:math';

import '../../combat/faction.dart';
import '../../projectiles/projectile_catalog.dart';
import '../../snapshots/enums.dart';
import '../../spells/spell_catalog.dart';
import '../../spells/spell_id.dart';
import '../../util/double_math.dart';
import '../../tuning/v0_ability_tuning.dart';
import '../../tuning/v0_movement_tuning.dart';
import '../entity_id.dart';
import '../world.dart';
import '../stores/lifetime_store.dart';
import '../stores/projectile_store.dart';
import '../stores/spell_origin_store.dart';

class CastSystem {
  CastSystem({
    required this.spells,
    required this.projectiles,
    required this.abilities,
    required this.movement,
  });

  final SpellCatalog spells;
  final ProjectileCatalogDerived projectiles;
  final V0AbilityTuningDerived abilities;
  final V0MovementTuningDerived movement;

  void step(EcsWorld world, {required EntityId player}) {
    if (!world.playerInput.has(player) ||
        !world.transform.has(player) ||
        !world.movement.has(player) ||
        !world.mana.has(player) ||
        !world.cooldown.has(player)) {
      return;
    }

    final ii = world.playerInput.indexOf(player);
    if (!world.playerInput.castPressed[ii]) return;

    final ci = world.cooldown.indexOf(player);
    if (world.cooldown.castCooldownTicksLeft[ci] > 0) return;

    const spellId = SpellId.iceBolt;
    final spell = spells.get(spellId);
    final projectileId = spell.projectileId;
    if (projectileId == null) return;

    final spellStats = spell.stats;
    final proj = projectiles.base.get(projectileId);

    final mi = world.mana.indexOf(player);
    final mana = world.mana.mana[mi];
    if (mana < spellStats.manaCost) return;

    world.mana.mana[mi] = clampDouble(
      mana - spellStats.manaCost,
      0.0,
      world.mana.manaMax[mi],
    );

    world.cooldown.castCooldownTicksLeft[ci] = abilities.castCooldownTicks;

    final ti = world.transform.indexOf(player);
    final facing = world.movement.facing[world.movement.indexOf(player)];

    final rawAimX = world.playerInput.aimDirX[ii];
    final rawAimY = world.playerInput.aimDirY[ii];

    double aimX;
    double aimY;
    if (rawAimX == 0 && rawAimY == 0) {
      aimX = facing == Facing.right ? 1.0 : -1.0;
      aimY = 0.0;
    } else {
      final len2 = rawAimX * rawAimX + rawAimY * rawAimY;
      if (len2 <= 1e-12) {
        aimX = facing == Facing.right ? 1.0 : -1.0;
        aimY = 0.0;
      } else {
        final invLen = 1.0 / sqrt(len2);
        aimX = rawAimX * invLen;
        aimY = rawAimY * invLen;
      }
    }

    final spawnOffset = movement.base.playerRadius * 0.5;
    final originX = world.transform.posX[ti] + aimX * spawnOffset;
    final originY = world.transform.posY[ti] + aimY * spawnOffset;

    final projEntity = world.createEntity();
    world.transform.add(
      projEntity,
      posX: originX,
      posY: originY,
      velX: 0.0,
      velY: 0.0,
    );
    world.projectile.add(
      projEntity,
      ProjectileDef(
        projectileId: projectileId,
        faction: Faction.player,
        owner: player,
        dirX: aimX,
        dirY: aimY,
        speedUnitsPerSecond: proj.speedUnitsPerSecond,
        damage: spellStats.damage,
      ),
    );
    world.spellOrigin.add(projEntity, const SpellOriginDef(spellId: spellId));
    world.lifetime.add(
      projEntity,
      LifetimeDef(ticksLeft: projectiles.lifetimeTicks(projectileId)),
    );
  }
}


===== FILE: lib/core/ecs/systems/collision_system.dart =====
import '../../collision/static_world_geometry_index.dart';
import '../../tuning/v0_movement_tuning.dart';
import '../queries.dart';
import '../stores/body_store.dart';
import '../world.dart';

/// Integrates positions and resolves collisions (V0: ground band only).
///
/// Order within a tick:
/// - MovementSystem computes velocities (including gravity, jump/dash).
/// - CollisionSystem integrates `pos += vel * dt`, resolves collisions, and
///   finalizes grounded/contact state for the tick.
class CollisionSystem {
  void step(
    EcsWorld world,
    V0MovementTuningDerived tuning, {
    required StaticWorldGeometryIndex staticWorld,
  }) {
    final dt = tuning.dtSeconds;
    const eps = 1e-3;

    EcsQueries.forColliders(world, (e, ti, bi, coli, aabbi) {
      if (!world.body.enabled[bi]) return;

      // Reset per-tick collision results.
      world.collision.resetTick(e);

      // Kinematic bodies are excluded from physics integration/resolution.
      if (world.body.isKinematic[bi]) {
        return;
      }

      final prevPosX = world.transform.posX[ti];
      final prevPosY = world.transform.posY[ti];

      // Integrate position from the current velocity.
      world.transform.posX[ti] += world.transform.velX[ti] * dt;
      world.transform.posY[ti] += world.transform.velY[ti] * dt;

      final halfX = world.colliderAabb.halfX[aabbi];
      final halfY = world.colliderAabb.halfY[aabbi];
      final offsetX = world.colliderAabb.offsetX[aabbi];
      final offsetY = world.colliderAabb.offsetY[aabbi];

      final prevCenterX = prevPosX + offsetX;
      final prevCenterY = prevPosY + offsetY;
      final prevBottom = prevCenterY + halfY;

      final centerX = world.transform.posX[ti] + offsetX;
      final centerY = world.transform.posY[ti] + offsetY;
      final minX = centerX - halfX;
      final maxX = centerX + halfX;
      final bottom = centerY + halfY;
      final top = centerY - halfY;

      // Vertical top resolution (one-way platforms): only while moving downward.
      double? bestTopY;
      if (world.transform.velY[ti] > 0) {
        for (final solid in staticWorld.tops) {
          final overlapX = maxX > solid.minX + eps && minX < solid.maxX - eps;
          if (!overlapX) continue;

          final topY = solid.minY;
          final crossesTop =
              prevBottom <= topY + eps && bottom >= topY - eps;
          if (!crossesTop) continue;

          if (solid.oneWayTop == false) {
            // Fully solid top surface; same resolution as one-way, just without
            // any additional gating.
          }

          if (bestTopY == null || topY < bestTopY) {
            bestTopY = topY;
          }
        }
      }

      // Vertical bottom resolution (ceilings): only while moving upward.
      double? bestBottomY;
      if (world.transform.velY[ti] < 0) {
        final prevTop = prevCenterY - halfY;
        for (final solid in staticWorld.bottoms) {
          final overlapX = maxX > solid.minX + eps && minX < solid.maxX - eps;
          if (!overlapX) continue;

          final bottomY = solid.maxY;
          final crossesBottom =
              prevTop >= bottomY - eps && top <= bottomY + eps;
          if (!crossesBottom) continue;

          if (bestBottomY == null || bottomY > bestBottomY) {
            bestBottomY = bottomY;
          }
        }
      }

      // Ground is treated as an infinite solid with a top at `v0GroundTopY`.
      // It competes with platforms: if a platform is higher (smaller Y), it
      // should win.
      final groundPlane = staticWorld.groundPlane;
      if (groundPlane != null) {
        final groundTopY = groundPlane.topY;
        if (world.transform.velY[ti] > 0 &&
            prevBottom <= groundTopY + eps &&
            bottom >= groundTopY - eps) {
          if (bestTopY == null || groundTopY < bestTopY) {
            bestTopY = groundTopY;
          }
        }
      }

      if (bestTopY != null) {
        world.transform.posY[ti] = bestTopY - offsetY - halfY;
        if (world.transform.velY[ti] > 0) {
          world.transform.velY[ti] = 0;
        }
        world.collision.grounded[coli] = true;
      } else if (bestBottomY != null) {
        world.transform.posY[ti] = bestBottomY - offsetY + halfY;
        if (world.transform.velY[ti] < 0) {
          world.transform.velY[ti] = 0;
        }
        world.collision.hitCeiling[coli] = true;
      }

      // Recompute AABB after vertical resolution for stable side overlap tests.
      final resolvedCenterX = world.transform.posX[ti] + offsetX;
      final resolvedCenterY = world.transform.posY[ti] + offsetY;
      //final resolvedMinX = resolvedCenterX - halfX;
      //final resolvedMaxX = resolvedCenterX + halfX;
      final resolvedMinY = resolvedCenterY - halfY;
      final resolvedMaxY = resolvedCenterY + halfY;

      // Horizontal resolution against static solids (V0: obstacles/walls only).
      final sideMask = world.body.sideMask[bi];
      final velX = world.transform.velX[ti];

      if (velX > 0 && (sideMask &  BodyDef.sideRight) != 0) {
        final prevRight = prevCenterX + halfX;
        final right = resolvedCenterX + halfX;
        double? bestWallX;

        for (final solid in staticWorld.leftWalls) {
          final overlapY =
              resolvedMaxY > solid.minY + eps && resolvedMinY < solid.maxY - eps;
          if (!overlapY) continue;

          final wallX = solid.minX;
          final crossesWall = prevRight <= wallX + eps && right >= wallX - eps;
          if (!crossesWall) continue;

          if (bestWallX == null || wallX < bestWallX) {
            bestWallX = wallX;
          }
        }

        if (bestWallX != null) {
          world.transform.posX[ti] = bestWallX - offsetX - halfX;
          world.transform.velX[ti] = 0;
          world.collision.hitRight[coli] = true;
        }
      } else if (velX < 0 && (sideMask & BodyDef.sideLeft) != 0) {
        final prevLeft = prevCenterX - halfX;
        final left = resolvedCenterX - halfX;
        double? bestWallX;

        for (final solid in staticWorld.rightWalls) {
          final overlapY =
              resolvedMaxY > solid.minY + eps && resolvedMinY < solid.maxY - eps;
          if (!overlapY) continue;

          final wallX = solid.maxX;
          final crossesWall = prevLeft >= wallX - eps && left <= wallX + eps;
          if (!crossesWall) continue;

          if (bestWallX == null || wallX > bestWallX) {
            bestWallX = wallX;
          }
        }

        if (bestWallX != null) {
          world.transform.posX[ti] = bestWallX - offsetX + halfX;
          world.transform.velX[ti] = 0;
          world.collision.hitLeft[coli] = true;
        }
      }
    });
  }
}


===== FILE: lib/core/ecs/systems/cooldown_system.dart =====
import '../world.dart';

class CooldownSystem {
  void step(EcsWorld world) {
    final store = world.cooldown;
    for (var i = 0; i < store.denseEntities.length; i += 1) {
      if (store.castCooldownTicksLeft[i] > 0) {
        store.castCooldownTicksLeft[i] -= 1;
      }
      if (store.meleeCooldownTicksLeft[i] > 0) {
        store.meleeCooldownTicksLeft[i] -= 1;
      }
    }
  }
}


===== FILE: lib/core/ecs/systems/damage_system.dart =====
import '../../combat/damage.dart';
import '../../util/double_math.dart';
import '../world.dart';

class DamageSystem {
  final List<DamageRequest> _pending = <DamageRequest>[];

  void queue(DamageRequest request) {
    if (request.amount <= 0) return;
    _pending.add(request);
  }

  void step(EcsWorld world) {
    if (_pending.isEmpty) return;

    final health = world.health;
    for (final req in _pending) {
      if (!health.has(req.target)) continue;
      final hi = health.indexOf(req.target);
      health.hp[hi] = clampDouble(
        health.hp[hi] - req.amount,
        0.0,
        health.hpMax[hi],
      );
    }
    _pending.clear();
  }
}


===== FILE: lib/core/ecs/systems/hitbox_damage_system.dart =====
import '../../combat/damage.dart';
import '../../combat/faction.dart';
import '../world.dart';

class HitboxDamageSystem {
  void step(EcsWorld world, void Function(DamageRequest request) queueDamage) {
    final hitboxes = world.hitbox;
    if (hitboxes.denseEntities.isEmpty) return;

    final targets = world.health;
    if (targets.denseEntities.isEmpty) return;

    for (var hi = 0; hi < hitboxes.denseEntities.length; hi += 1) {
      final hb = hitboxes.denseEntities[hi];
      if (!world.transform.has(hb)) continue;
      if (!world.hitOnce.has(hb)) continue;

      final hbTi = world.transform.indexOf(hb);
      final hbCx = world.transform.posX[hbTi];
      final hbCy = world.transform.posY[hbTi];
      final hbHalfX = hitboxes.halfX[hi];
      final hbHalfY = hitboxes.halfY[hi];

      final hbMinX = hbCx - hbHalfX;
      final hbMaxX = hbCx + hbHalfX;
      final hbMinY = hbCy - hbHalfY;
      final hbMaxY = hbCy + hbHalfY;

      final owner = hitboxes.owner[hi];
      final sourceFaction = hitboxes.faction[hi];

      for (var ti = 0; ti < targets.denseEntities.length; ti += 1) {
        final target = targets.denseEntities[ti];
        if (target == owner) continue;

        final fi = world.faction.tryIndexOf(target);
        if (fi == null) continue;
        final targetFaction = world.faction.faction[fi];
        if (_isFriendlyFire(sourceFaction, targetFaction)) continue;

        final targetTi = world.transform.tryIndexOf(target);
        if (targetTi == null) continue;
        final aabbi = world.colliderAabb.tryIndexOf(target);
        if (aabbi == null) continue;

        final tcx = world.transform.posX[targetTi] + world.colliderAabb.offsetX[aabbi];
        final tcy = world.transform.posY[targetTi] + world.colliderAabb.offsetY[aabbi];
        final thx = world.colliderAabb.halfX[aabbi];
        final thy = world.colliderAabb.halfY[aabbi];

        final tMinX = tcx - thx;
        final tMaxX = tcx + thx;
        final tMinY = tcy - thy;
        final tMaxY = tcy + thy;

        final overlaps =
            hbMinX < tMaxX && hbMaxX > tMinX && hbMinY < tMaxY && hbMaxY > tMinY;
        if (!overlaps) continue;

        if (world.hitOnce.hasHit(hb, target)) continue;
        world.hitOnce.markHit(hb, target);

        queueDamage(DamageRequest(target: target, amount: hitboxes.damage[hi]));
      }
    }
  }

  bool _isFriendlyFire(Faction a, Faction b) => a == b;
}


===== FILE: lib/core/ecs/systems/lifetime_system.dart =====
import '../entity_id.dart';
import '../world.dart';

/// Decrements `LifetimeStore.ticksLeft` and despawns entities when it reaches 0.
///
/// This is intentionally generic so any timed entity type can reuse it
/// (projectiles, pickups, hazards, VFX, etc.).
class LifetimeSystem {
  final List<EntityId> _toDespawn = <EntityId>[];

  void step(EcsWorld world) {
    final lifetimes = world.lifetime;
    if (lifetimes.denseEntities.isEmpty) return;

    _toDespawn.clear();

    for (var li = 0; li < lifetimes.denseEntities.length; li += 1) {
      final e = lifetimes.denseEntities[li];
      final ticksLeft = lifetimes.ticksLeft[li];
      if (ticksLeft <= 0) {
        _toDespawn.add(e);
        continue;
      }

      final next = ticksLeft - 1;
      lifetimes.ticksLeft[li] = next;
      if (next <= 0) {
        _toDespawn.add(e);
      }
    }

    for (final e in _toDespawn) {
      world.destroyEntity(e);
    }
  }
}



===== FILE: lib/core/ecs/systems/melee_system.dart =====
import '../../combat/faction.dart';
import '../../snapshots/enums.dart';
import '../../tuning/v0_ability_tuning.dart';
import '../../tuning/v0_movement_tuning.dart';
import '../entity_id.dart';
import '../stores/hitbox_store.dart';
import '../stores/lifetime_store.dart';
import '../world.dart';

class MeleeSystem {
  const MeleeSystem({
    required this.abilities,
    required this.movement,
  });

  final V0AbilityTuningDerived abilities;
  final V0MovementTuningDerived movement;

  void step(EcsWorld world, {required EntityId player}) {
    _updateHitboxTransforms(world);
    _trySpawnPlayerMelee(world, player: player);
  }

  void _trySpawnPlayerMelee(EcsWorld world, {required EntityId player}) {
    if (!world.playerInput.has(player)) return;
    if (!world.transform.has(player)) return;
    if (!world.movement.has(player)) return;
    if (!world.stamina.has(player)) return;
    if (!world.cooldown.has(player)) return;

    final ii = world.playerInput.indexOf(player);
    if (!world.playerInput.attackPressed[ii]) return;

    final si = world.stamina.indexOf(player);
    if (world.stamina.stamina[si] < abilities.base.meleeStaminaCost) return;

    final ci = world.cooldown.indexOf(player);
    if (world.cooldown.meleeCooldownTicksLeft[ci] > 0) return;

    final mi = world.movement.indexOf(player);
    final facing = world.movement.facing[mi];
    final dirX = (facing == Facing.right) ? 1.0 : -1.0;

    final halfX = abilities.base.meleeHitboxSizeX * 0.5;
    final halfY = abilities.base.meleeHitboxSizeY * 0.5;

    // origin = playerPos + aimDir * (playerRadius * 0.5) for casts
    // melee uses facing-only:
    // center = playerPos + dirX * (playerRadius * 0.5 + halfX)
    final forward = movement.base.playerRadius * 0.5 + halfX;
    final offsetX = dirX * forward;
    const offsetY = 0.0;

    final ti = world.transform.indexOf(player);
    final hitX = world.transform.posX[ti] + offsetX;
    final hitY = world.transform.posY[ti] + offsetY;

    final hitbox = world.createEntity();
    world.transform.add(hitbox, posX: hitX, posY: hitY, velX: 0.0, velY: 0.0);
    world.hitbox.add(
      hitbox,
      HitboxDef(
        owner: player,
        faction: Faction.player,
        damage: abilities.base.meleeDamage,
        halfX: halfX,
        halfY: halfY,
        offsetX: offsetX,
        offsetY: offsetY,
      ),
    );
    world.hitOnce.add(hitbox);
    world.lifetime.add(hitbox, LifetimeDef(ticksLeft: abilities.meleeActiveTicks));

    world.cooldown.meleeCooldownTicksLeft[ci] = abilities.meleeCooldownTicks;
    world.stamina.stamina[si] -= abilities.base.meleeStaminaCost;
  }

  void _updateHitboxTransforms(EcsWorld world) {
    final hitboxes = world.hitbox;
    for (var hi = 0; hi < hitboxes.denseEntities.length; hi += 1) {
      final e = hitboxes.denseEntities[hi];
      if (!world.transform.has(e)) continue;

      final owner = hitboxes.owner[hi];
      if (!world.transform.has(owner)) continue;

      final ownerTi = world.transform.indexOf(owner);
      final x = world.transform.posX[ownerTi] + hitboxes.offsetX[hi];
      final y = world.transform.posY[ownerTi] + hitboxes.offsetY[hi];

      world.transform.setPosXY(e, x, y);
    }
  }
}


===== FILE: lib/core/ecs/systems/movement_system.dart =====
import '../../snapshots/enums.dart';
import '../../tuning/v0_movement_tuning.dart';
import '../../tuning/v0_resource_tuning.dart';
import '../queries.dart';
import '../world.dart';

/// Applies platformer-style movement for entities with:
/// - Transform
/// - PlayerInput
/// - Movement
/// - Body
///
/// MovementSystem writes velocities only (input/jump/dash/gravity/clamps).
/// Position integration and collision resolution are handled by CollisionSystem.
class MovementSystem {
  void step(
    EcsWorld world,
    V0MovementTuningDerived tuning, {
    required V0ResourceTuning resources,
  }) {
    final dt = tuning.dtSeconds;
    final t = tuning.base;

    EcsQueries.forMovementBodies(world, (e, mi, ti, ii, bi, ci, si) {
      if (!world.body.enabled[bi]) return;
      if (world.body.isKinematic[bi]) {
        return;
      }

      // Timers.
      if (world.movement.dashCooldownTicksLeft[mi] > 0) {
        world.movement.dashCooldownTicksLeft[mi] -= 1;
      }
      if (world.movement.dashTicksLeft[mi] > 0) {
        world.movement.dashTicksLeft[mi] -= 1;
      }
      if (world.movement.jumpBufferTicksLeft[mi] > 0) {
        world.movement.jumpBufferTicksLeft[mi] -= 1;
      }

      final wasGrounded = world.collision.grounded[ci];
      if (wasGrounded) {
        world.movement.coyoteTicksLeft[mi] = tuning.coyoteTicks;
      } else if (world.movement.coyoteTicksLeft[mi] > 0) {
        world.movement.coyoteTicksLeft[mi] -= 1;
      }

      // Buffer jump on edge-triggered press.
      if (world.playerInput.jumpPressed[ii]) {
        world.movement.jumpBufferTicksLeft[mi] = tuning.jumpBufferTicks;
      }

      // Dash request.
      if (world.playerInput.dashPressed[ii]) {
        _tryStartDash(
          world,
          mi: mi,
          ti: ti,
          ii: ii,
          si: si,
          tuning: tuning,
          staminaCost: resources.dashStaminaCost,
        );
      }

      final dashing = world.movement.dashTicksLeft[mi] > 0;

      if (dashing) {
        world.transform.velX[ti] = world.movement.dashDirX[mi] * t.dashSpeedX;
        world.transform.velY[ti] = 0;
      } else {
        world.transform.velX[ti] = _applyHorizontalMove(
          world.transform.velX[ti],
          world.playerInput.moveAxis[ii],
          dt,
          tuning,
        );

        // Jump attempt before gravity (to match the previous behavior).
        if (world.movement.jumpBufferTicksLeft[mi] > 0 &&
            (wasGrounded || world.movement.coyoteTicksLeft[mi] > 0)) {
          if (world.stamina.stamina[si] >= resources.jumpStaminaCost) {
            world.stamina.stamina[si] -= resources.jumpStaminaCost;

            world.transform.velY[ti] = -t.jumpSpeed;
            world.movement.jumpBufferTicksLeft[mi] = 0;
            world.movement.coyoteTicksLeft[mi] = 0;
          }
        }

        // Gravity.
        if (world.body.useGravity[bi]) {
          final scaledGravity = t.gravityY * world.body.gravityScale[bi];
          world.transform.velY[ti] += scaledGravity * dt;
        }
      }

      // Clamp speeds.
      world.transform.velX[ti] = world.transform.velX[ti]
          .clamp(-world.body.maxVelX[bi], world.body.maxVelX[bi])
          .toDouble();
      world.transform.velY[ti] = world.transform.velY[ti]
          .clamp(-world.body.maxVelY[bi], world.body.maxVelY[bi])
          .toDouble();
    });
  }

  double _applyHorizontalMove(
    double velocityX,
    double axis,
    double dt,
    V0MovementTuningDerived tuning,
  ) {
    final t = tuning.base;
    if (axis != 0) {
      final desiredX = axis * t.maxSpeedX;
      final deltaX = desiredX - velocityX;
      final maxDelta = t.accelerationX * dt;
      if (deltaX.abs() > maxDelta) {
        return velocityX + (deltaX > 0 ? maxDelta : -maxDelta);
      }
      return desiredX;
    }

    final speedX = velocityX.abs();
    if (speedX <= 0) return 0;
    final drop = t.decelerationX * dt;
    if (speedX <= drop || speedX <= t.minMoveSpeed) {
      return 0;
    }
    return velocityX + (velocityX > 0 ? -drop : drop);
  }

  void _tryStartDash(
    EcsWorld world, {
    required int mi,
    required int ti,
    required int ii,
    required int si,
    required V0MovementTuningDerived tuning,
    required double staminaCost,
  }) {
    if (world.movement.dashTicksLeft[mi] > 0) return;
    if (world.movement.dashCooldownTicksLeft[mi] > 0) return;
    if (world.stamina.stamina[si] < staminaCost) return;

    final axis = world.playerInput.moveAxis[ii];
    final dirX = axis != 0
        ? (axis > 0 ? 1.0 : -1.0)
        : (world.movement.facing[mi] == Facing.right ? 1.0 : -1.0);

    world.movement.dashDirX[mi] = dirX;
    world.movement.facing[mi] = dirX > 0 ? Facing.right : Facing.left;

    world.movement.dashTicksLeft[mi] = tuning.dashDurationTicks;
    world.movement.dashCooldownTicksLeft[mi] = tuning.dashCooldownTicks;

    // Cancel vertical motion so dash doesn't inherit jump/fall.
    world.transform.velY[ti] = 0;

    world.stamina.stamina[si] -= staminaCost;
  }
}


===== FILE: lib/core/ecs/systems/projectile_system.dart =====
import '../../tuning/v0_movement_tuning.dart';
import '../world.dart';

class ProjectileSystem {
  void step(EcsWorld world, V0MovementTuningDerived movement) {
    final dt = movement.dtSeconds;
    final projectiles = world.projectile;

    for (var pi = 0; pi < projectiles.denseEntities.length; pi += 1) {
      final e = projectiles.denseEntities[pi];
      if (!world.transform.has(e)) {
        continue;
      }

      final ti = world.transform.indexOf(e);

      final vx = projectiles.dirX[pi] * projectiles.speedUnitsPerSecond[pi];
      final vy = projectiles.dirY[pi] * projectiles.speedUnitsPerSecond[pi];

      world.transform.velX[ti] = vx;
      world.transform.velY[ti] = vy;

      world.transform.posX[ti] += vx * dt;
      world.transform.posY[ti] += vy * dt;
    }
  }
}


===== FILE: lib/core/ecs/systems/resource_regen_system.dart =====
import '../../util/double_math.dart';
import '../world.dart';

class ResourceRegenSystem {
  void step(EcsWorld world, {required double dtSeconds}) {
    _regenHealth(world, dtSeconds);
    _regenMana(world, dtSeconds);
    _regenStamina(world, dtSeconds);
  }

  void _regenHealth(EcsWorld world, double dtSeconds) {
    final store = world.health;
    for (var i = 0; i < store.denseEntities.length; i += 1) {
      final max = store.hpMax[i];
      if (max <= 0) continue;
      final current = store.hp[i];
      if (current >= max) continue;
      final regen = store.regenPerSecond[i];
      if (regen <= 0) continue;
      store.hp[i] = clampDouble(current + regen * dtSeconds, 0.0, max);
    }
  }

  void _regenMana(EcsWorld world, double dtSeconds) {
    final store = world.mana;
    for (var i = 0; i < store.denseEntities.length; i += 1) {
      final max = store.manaMax[i];
      if (max <= 0) continue;
      final current = store.mana[i];
      if (current >= max) continue;
      final regen = store.regenPerSecond[i];
      if (regen <= 0) continue;
      store.mana[i] = clampDouble(current + regen * dtSeconds, 0.0, max);
    }
  }

  void _regenStamina(EcsWorld world, double dtSeconds) {
    final store = world.stamina;
    for (var i = 0; i < store.denseEntities.length; i += 1) {
      final max = store.staminaMax[i];
      if (max <= 0) continue;
      final current = store.stamina[i];
      if (current >= max) continue;
      final regen = store.regenPerSecond[i];
      if (regen <= 0) continue;
      store.stamina[i] = clampDouble(current + regen * dtSeconds, 0.0, max);
    }
  }
}


===== FILE: lib/core/ecs/world.dart =====
import '../snapshots/enums.dart';
import '../combat/faction.dart';
import 'entity_id.dart';
import 'stores/body_store.dart';
import 'stores/collider_aabb_store.dart';
import 'stores/collision_state_store.dart';
import 'stores/cooldown_store.dart';
import 'stores/faction_store.dart';
import 'stores/health_store.dart';
import 'stores/hit_once_store.dart';
import 'stores/hitbox_store.dart';
import 'stores/lifetime_store.dart';
import 'stores/mana_store.dart';
import 'stores/movement_store.dart';
import 'stores/player_input_store.dart';
import 'stores/projectile_store.dart';
import 'stores/spell_origin_store.dart';
import 'stores/stamina_store.dart';
import 'stores/transform_store.dart';

/// Minimal ECS world container (V0).
///
/// Entity IDs are monotonic and never reused.
class EcsWorld {
  EntityId _nextEntityId = 1;

  final TransformStore transform = TransformStore();
  final PlayerInputStore playerInput = PlayerInputStore();
  final MovementStore movement = MovementStore();
  final BodyStore body = BodyStore();
  final ColliderAabbStore colliderAabb = ColliderAabbStore();
  final CollisionStateStore collision = CollisionStateStore();
  final CooldownStore cooldown = CooldownStore();
  final FactionStore faction = FactionStore();
  final HealthStore health = HealthStore();
  final ManaStore mana = ManaStore();
  final StaminaStore stamina = StaminaStore();
  final ProjectileStore projectile = ProjectileStore();
  final HitboxStore hitbox = HitboxStore();
  final HitOnceStore hitOnce = HitOnceStore();
  final LifetimeStore lifetime = LifetimeStore();
  final SpellOriginStore spellOrigin = SpellOriginStore();

  EntityId createEntity() {
    final id = _nextEntityId;
    _nextEntityId += 1;
    return id;
  }

  EntityId createPlayer({
    required double posX,
    required double posY,
    required double velX,
    required double velY,
    required Facing facing,
    required bool grounded,
    required BodyDef body,
    required ColliderAabbDef collider,
    required HealthDef health,
    required ManaDef mana,
    required StaminaDef stamina,
  }) {
    final id = createEntity();
    transform.add(id, posX: posX, posY: posY, velX: velX, velY: velY);
    playerInput.add(id);
    movement.add(id, facing: facing);
    this.body.add(id, body);
    colliderAabb.add(id, collider);
    collision.add(id);
    cooldown.add(id);
    faction.add(id, const FactionDef(faction: Faction.player));
    this.health.add(id, health);
    this.mana.add(id, mana);
    this.stamina.add(id, stamina);
    collision.grounded[collision.indexOf(id)] = grounded;
    return id;
  }

  void destroyEntity(EntityId entity) {
    transform.removeEntity(entity);
    playerInput.removeEntity(entity);
    movement.removeEntity(entity);
    body.removeEntity(entity);
    colliderAabb.removeEntity(entity);
    collision.removeEntity(entity);
    cooldown.removeEntity(entity);
    faction.removeEntity(entity);
    health.removeEntity(entity);
    mana.removeEntity(entity);
    stamina.removeEntity(entity);
    projectile.removeEntity(entity);
    hitbox.removeEntity(entity);
    hitOnce.removeEntity(entity);
    lifetime.removeEntity(entity);
    spellOrigin.removeEntity(entity);
  }
}


===== FILE: lib/core/events/game_event.dart =====
/// Core -> Render/UI event model.
///
/// Events are transient side effects emitted by the simulation (SFX triggers,
/// screen shake, spawn/despawn notifications, etc.). Render/UI may consume them
/// once; gameplay truth still comes from snapshots.
sealed class GameEvent {
  const GameEvent();
}


===== FILE: lib/core/game_core.dart =====
// Authoritative, deterministic simulation layer (pure Dart).
//
// This is the "truth" of the game: it applies tick-stamped commands, advances
// the simulation by fixed ticks, and produces snapshots/events for the
// renderer/UI. It must not import Flutter or Flame.
import 'dart:math';

import 'commands/command.dart';
import 'collision/static_world_geometry.dart';
import 'collision/static_world_geometry_index.dart';
import 'contracts/v0_render_contract.dart';
import 'ecs/entity_id.dart';
import 'ecs/stores/collider_aabb_store.dart';
import 'ecs/systems/collision_system.dart';
import 'ecs/systems/cooldown_system.dart';
import 'ecs/systems/cast_system.dart';
import 'ecs/systems/damage_system.dart';
import 'ecs/systems/hitbox_damage_system.dart';
import 'ecs/systems/lifetime_system.dart';
import 'ecs/systems/melee_system.dart';
import 'ecs/systems/movement_system.dart';
import 'ecs/systems/projectile_system.dart';
import 'ecs/systems/resource_regen_system.dart';
import 'ecs/stores/body_store.dart';
import 'ecs/stores/health_store.dart';
import 'ecs/stores/mana_store.dart';
import 'ecs/stores/stamina_store.dart';
import 'ecs/world.dart';
import 'math/vec2.dart';
import 'snapshots/enums.dart';
import 'snapshots/entity_render_snapshot.dart';
import 'snapshots/game_state_snapshot.dart';
import 'snapshots/player_hud_snapshot.dart';
import 'snapshots/static_solid_snapshot.dart';
import 'projectiles/projectile_catalog.dart';
import 'spells/spell_catalog.dart';
import 'tuning/v0_ability_tuning.dart';
import 'tuning/v0_movement_tuning.dart';
import 'tuning/v0_resource_tuning.dart';

const StaticWorldGeometry v0DefaultStaticWorldGeometry = StaticWorldGeometry(
  groundPlane: StaticGroundPlane(topY: v0GroundTopY * 1.0),
  solids: <StaticSolid>[
    // A small one-way platform to validate collisions/visuals.
    StaticSolid(
      minX: 120,
      minY: 200,
      maxX: 280,
      maxY: 216,
      sides: StaticSolid.sideTop,
      oneWayTop: true,
    ),

    // A simple obstacle block to validate side collisions + jumping.
    StaticSolid(
      minX: 320,
      minY: 220,
      maxX: 344,
      maxY: v0GroundTopY * 1.0,
      sides: StaticSolid.sideAll,
      oneWayTop: false,
    ),
  ],
);

/// Minimal placeholder `GameCore` used to validate architecture wiring.
///
/// This will be replaced by the full ECS/systems implementation in later
/// milestones. The core invariants remain: fixed ticks, command-driven input,
/// deterministic state updates, snapshot output.
class GameCore {
  GameCore({
    required this.seed,
    this.tickHz = v0DefaultTickHz,
    V0MovementTuning movementTuning = const V0MovementTuning(),
    V0ResourceTuning resourceTuning = const V0ResourceTuning(),
    V0AbilityTuning abilityTuning = const V0AbilityTuning(),
    SpellCatalog spellCatalog = const SpellCatalog(),
    ProjectileCatalog projectileCatalog = const ProjectileCatalog(),
    BodyDef? playerBody,
    StaticWorldGeometry? staticWorldGeometry,
  }) : _movement = V0MovementTuningDerived.from(
         movementTuning,
         tickHz: tickHz,
       ),
       _resourceTuning = resourceTuning,
       _abilities = V0AbilityTuningDerived.from(abilityTuning, tickHz: tickHz),
       _spells = spellCatalog,
       _projectiles = ProjectileCatalogDerived.from(
         projectileCatalog,
         tickHz: tickHz,
       ),
       staticWorldGeometry = staticWorldGeometry ?? v0DefaultStaticWorldGeometry {
    _world = EcsWorld();
    _movementSystem = MovementSystem();
    _collisionSystem = CollisionSystem();
    _cooldownSystem = CooldownSystem();
    _projectileSystem = ProjectileSystem();
    _lifetimeSystem = LifetimeSystem();
    _damageSystem = DamageSystem();
    _meleeSystem = MeleeSystem(abilities: _abilities, movement: _movement);
    _hitboxDamageSystem = HitboxDamageSystem();
    _resourceRegenSystem = ResourceRegenSystem();
    _castSystem = CastSystem(
      spells: _spells,
      projectiles: _projectiles,
      abilities: _abilities,
      movement: _movement,
    );

    final spawnX = 80.0;
    final spawnY =
        (this.staticWorldGeometry.groundPlane?.topY ?? v0GroundTopY.toDouble()) -
        _movement.base.playerRadius;
    final defaultBody = BodyDef(
      enabled: true,
      isKinematic: false,
      useGravity: true,
      topOnlyGround: true,
      gravityScale: 1.0,
      maxVelX: _movement.base.maxVelX,
      maxVelY: _movement.base.maxVelY,
      sideMask: BodyDef.sideLeft | BodyDef.sideRight,
    );
    _player = _world.createPlayer(
      posX: spawnX,
      posY: spawnY,
      velX: 0.0,
      velY: 0.0,
      facing: Facing.right,
      grounded: true,
      body: playerBody ?? defaultBody,
      collider: ColliderAabbDef(
        halfX: _movement.base.playerRadius,
        halfY: _movement.base.playerRadius,
      ),
      health: HealthDef(
        hp: _resourceTuning.playerHpStart ?? _resourceTuning.playerHpMax,
        hpMax: _resourceTuning.playerHpMax,
        regenPerSecond: _resourceTuning.playerHpRegenPerSecond,
      ),
      mana: ManaDef(
        mana: _resourceTuning.playerManaStart ?? _resourceTuning.playerManaMax,
        manaMax: _resourceTuning.playerManaMax,
        regenPerSecond: _resourceTuning.playerManaRegenPerSecond,
      ),
      stamina: StaminaDef(
        stamina:
            _resourceTuning.playerStaminaStart ?? _resourceTuning.playerStaminaMax,
        staminaMax: _resourceTuning.playerStaminaMax,
        regenPerSecond: _resourceTuning.playerStaminaRegenPerSecond,
      ),
    );
  }

  /// Seed used for deterministic generation/RNG.
  final int seed;

  /// Fixed simulation tick frequency.
  final int tickHz;

  /// Static world geometry for this run/session.
  final StaticWorldGeometry staticWorldGeometry;
  late final StaticWorldGeometryIndex _staticWorldIndex =
      StaticWorldGeometryIndex.from(staticWorldGeometry);

  late final List<StaticSolidSnapshot> _staticSolidsSnapshot =
      List<StaticSolidSnapshot>.unmodifiable(
        staticWorldGeometry.solids.map(
          (s) => StaticSolidSnapshot(
            minX: s.minX,
            minY: s.minY,
            maxX: s.maxX,
            maxY: s.maxY,
            sides: s.sides,
            oneWayTop: s.oneWayTop,
          ),
        ),
      );

  final V0MovementTuningDerived _movement;
  final V0ResourceTuning _resourceTuning;
  final V0AbilityTuningDerived _abilities;
  final SpellCatalog _spells;
  final ProjectileCatalogDerived _projectiles;

  late final EcsWorld _world;
  late final MovementSystem _movementSystem;
  late final CollisionSystem _collisionSystem;
  late final CooldownSystem _cooldownSystem;
  late final ProjectileSystem _projectileSystem;
  late final LifetimeSystem _lifetimeSystem;
  late final DamageSystem _damageSystem;
  late final MeleeSystem _meleeSystem;
  late final HitboxDamageSystem _hitboxDamageSystem;
  late final ResourceRegenSystem _resourceRegenSystem;
  late final CastSystem _castSystem;
  late final EntityId _player;

  /// Current simulation tick.
  int tick = 0;

  /// Whether simulation should advance.
  bool paused = false;

  /// Run progression metric (placeholder).
  double distance = 0;

  double get playerPosX =>
      _world.transform.posX[_world.transform.indexOf(_player)];
  double get playerPosY =>
      _world.transform.posY[_world.transform.indexOf(_player)];

  void setPlayerPosXY(double x, double y) =>
      _world.transform.setPosXY(_player, x, y);

  double get playerVelX =>
      _world.transform.velX[_world.transform.indexOf(_player)];
  double get playerVelY =>
      _world.transform.velY[_world.transform.indexOf(_player)];

  void setPlayerVelXY(double x, double y) =>
      _world.transform.setVelXY(_player, x, y);

  bool get playerGrounded =>
      _world.collision.grounded[_world.collision.indexOf(_player)];

  Facing get playerFacing =>
      _world.movement.facing[_world.movement.indexOf(_player)];
  set playerFacing(Facing value) {
    _world.movement.facing[_world.movement.indexOf(_player)] = value;
  }

  int get playerCastCooldownTicksLeft =>
      _world.cooldown.castCooldownTicksLeft[_world.cooldown.indexOf(_player)];

  int get playerMeleeCooldownTicksLeft =>
      _world.cooldown.meleeCooldownTicksLeft[_world.cooldown.indexOf(_player)];

  /// Applies all commands scheduled for the current tick.
  ///
  /// In the final architecture, commands are the only mechanism for the UI to
  /// influence the simulation.
  void applyCommands(List<Command> commands) {
    _world.playerInput.resetTickInputs(_player);
    final inputIndex = _world.playerInput.indexOf(_player);
    final movementIndex = _world.movement.indexOf(_player);

    for (final command in commands) {
      switch (command) {
        case MoveAxisCommand(:final axis):
          final clamped = axis.clamp(-1.0, 1.0);
          _world.playerInput.moveAxis[inputIndex] = clamped;

          if (_world.movement.dashTicksLeft[movementIndex] == 0) {
            if (clamped < 0) {
              playerFacing = Facing.left;
            } else if (clamped > 0) {
              playerFacing = Facing.right;
            }
          }
        case JumpPressedCommand():
          _world.playerInput.jumpPressed[inputIndex] = true;
        case DashPressedCommand():
          _world.playerInput.dashPressed[inputIndex] = true;
        case AttackPressedCommand():
          _world.playerInput.attackPressed[inputIndex] = true;
          break;
        case AimDirCommand(:final x, :final y):
          _world.playerInput.aimDirX[inputIndex] = x;
          _world.playerInput.aimDirY[inputIndex] = y;
        case ClearAimDirCommand():
          _world.playerInput.aimDirX[inputIndex] = 0;
          _world.playerInput.aimDirY[inputIndex] = 0;
        case CastPressedCommand():
          _world.playerInput.castPressed[inputIndex] = true;
      }
    }
  }

  /// Advances the simulation by exactly one fixed tick.
  void stepOneTick() {
    if (paused) return;

    tick += 1;
    _cooldownSystem.step(_world);
    _movementSystem.step(_world, _movement, resources: _resourceTuning);
    _collisionSystem.step(
      _world,
      _movement,
      staticWorld: _staticWorldIndex,
    );
    _projectileSystem.step(_world, _movement);
    _castSystem.step(_world, player: _player);
    _meleeSystem.step(_world, player: _player);
    _hitboxDamageSystem.step(_world, _damageSystem.queue);
    _damageSystem.step(_world);
    _resourceRegenSystem.step(_world, dtSeconds: _movement.dtSeconds);

    // Cleanup last so effect entities get their full last tick to act.
    _lifetimeSystem.step(_world);

    distance += max(0.0, playerVelX) * _movement.dtSeconds;
  }

  /// Builds an immutable snapshot for render/UI consumption.
  GameStateSnapshot buildSnapshot() {
    final tuning = _movement.base;
    final mi = _world.movement.indexOf(_player);
    final dashing = _world.movement.dashTicksLeft[mi] > 0;
    final onGround = _world.collision.grounded[_world.collision.indexOf(_player)];
    final hi = _world.health.indexOf(_player);
    final mai = _world.mana.indexOf(_player);
    final si = _world.stamina.indexOf(_player);

    final AnimKey anim;
    if (dashing) {
      anim = AnimKey.run;
    } else if (!onGround) {
      anim = playerVelY < 0 ? AnimKey.jump : AnimKey.fall;
    } else if (playerVelX.abs() > tuning.minMoveSpeed) {
      anim = AnimKey.run;
    } else {
      anim = AnimKey.idle;
    }

    final playerPos = Vec2(playerPosX, playerPosY);
    final playerVel = Vec2(playerVelX, playerVelY);

    final entities = <EntityRenderSnapshot>[
      EntityRenderSnapshot(
        id: _player,
        kind: EntityKind.player,
        pos: playerPos,
        vel: playerVel,
        size: Vec2(tuning.playerRadius * 2, tuning.playerRadius * 2),
        facing: playerFacing,
        anim: anim,
        grounded: onGround,
      ),
    ];

    final projectileStore = _world.projectile;
    for (var pi = 0; pi < projectileStore.denseEntities.length; pi += 1) {
      final e = projectileStore.denseEntities[pi];
      if (!(_world.transform.has(e))) continue;
      final ti = _world.transform.indexOf(e);

      final projectileId = projectileStore.projectileId[pi];
      final proj = _projectiles.base.get(projectileId);
      final colliderSize = Vec2(proj.colliderSizeX, proj.colliderSizeY);

      final dx = projectileStore.dirX[pi];
      final facing = dx >= 0 ? Facing.right : Facing.left;

      entities.add(
        EntityRenderSnapshot(
          id: e,
          kind: EntityKind.projectile,
          pos: Vec2(_world.transform.posX[ti], _world.transform.posY[ti]),
          vel: Vec2(_world.transform.velX[ti], _world.transform.velY[ti]),
          size: colliderSize,
          projectileId: projectileId,
          facing: facing,
          anim: AnimKey.idle,
          grounded: false,
        ),
      );
    }

    final hitboxes = _world.hitbox;
    for (var hi = 0; hi < hitboxes.denseEntities.length; hi += 1) {
      final e = hitboxes.denseEntities[hi];
      if (!(_world.transform.has(e))) continue;
      final ti = _world.transform.indexOf(e);

      final size = Vec2(hitboxes.halfX[hi] * 2, hitboxes.halfY[hi] * 2);
      final facing = hitboxes.offsetX[hi] >= 0 ? Facing.right : Facing.left;

      entities.add(
        EntityRenderSnapshot(
          id: e,
          kind: EntityKind.trigger,
          pos: Vec2(_world.transform.posX[ti], _world.transform.posY[ti]),
          size: size,
          facing: facing,
          anim: AnimKey.hit,
          grounded: false,
        ),
      );
    }

    return GameStateSnapshot(
      tick: tick,
      seed: seed,
      distance: distance,
      paused: paused,
      hud: PlayerHudSnapshot(
        hp: _world.health.hp[hi],
        hpMax: _world.health.hpMax[hi],
        mana: _world.mana.mana[mai],
        manaMax: _world.mana.manaMax[mai],
        stamina: _world.stamina.stamina[si],
        staminaMax: _world.stamina.staminaMax[si],
        score: 0,
        coins: 0,
      ),
      entities: entities,
      staticSolids: _staticSolidsSnapshot,
    );
  }
}


===== FILE: lib/core/math/vec2.dart =====
/// Minimal 2D vector type used by the Core simulation.
///
/// This is intentionally kept small and dependency-free so `lib/core/**` can
/// stay pure Dart (no Flutter/Flame imports) and deterministic.
class Vec2 {
  const Vec2(this.x, this.y);

  /// X coordinate, in world units (virtual pixels).
  final double x;

  /// Y coordinate, in world units (virtual pixels).
  final double y;

  /// Returns a copy with a different X value.
  Vec2 withX(double value) => Vec2(value, y);

  /// Returns a copy with a different Y value.
  Vec2 withY(double value) => Vec2(x, value);

  /// Vector addition.
  Vec2 operator +(Vec2 other) => Vec2(x + other.x, y + other.y);

  /// Vector subtraction.
  Vec2 operator -(Vec2 other) => Vec2(x - other.x, y - other.y);

  /// Scalar multiplication.
  Vec2 scale(double factor) => Vec2(x * factor, y * factor);
}


===== FILE: lib/core/projectiles/projectile_catalog.dart =====
import '../util/tick_math.dart';

import 'projectile_id.dart';

class ProjectileArchetype {
  const ProjectileArchetype({
    required this.speedUnitsPerSecond,
    required this.lifetimeSeconds,
    required this.colliderSizeX,
    required this.colliderSizeY,
  });

  final double speedUnitsPerSecond;
  final double lifetimeSeconds;

  /// Full extents, in world units (virtual pixels).
  final double colliderSizeX;
  final double colliderSizeY;
}

class ProjectileCatalog {
  const ProjectileCatalog();

  ProjectileArchetype get(ProjectileId id) {
    switch (id) {
      case ProjectileId.iceBolt:
        return const ProjectileArchetype(
          speedUnitsPerSecond: 1600.0,
          lifetimeSeconds: 1.0,
          colliderSizeX: 18.0,
          colliderSizeY: 8.0,
        );
      case ProjectileId.lightningBolt:
        return const ProjectileArchetype(
          speedUnitsPerSecond: 900.0,
          lifetimeSeconds: 1.2,
          colliderSizeX: 16.0,
          colliderSizeY: 8.0,
        );
    }
  }
}

class ProjectileCatalogDerived {
  const ProjectileCatalogDerived._({required this.tickHz, required this.base});

  factory ProjectileCatalogDerived.from(
    ProjectileCatalog base, {
    required int tickHz,
  }) {
    if (tickHz <= 0) {
      throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
    }
    return ProjectileCatalogDerived._(tickHz: tickHz, base: base);
  }

  final int tickHz;
  final ProjectileCatalog base;

  int lifetimeTicks(ProjectileId id) {
    return ticksFromSecondsCeil(base.get(id).lifetimeSeconds, tickHz);
  }
}


===== FILE: lib/core/projectiles/projectile_id.dart =====
enum ProjectileId { iceBolt, lightningBolt }



===== FILE: lib/core/README.md =====
# Core (Pure Dart)

Authoritative, deterministic simulation code only.

- No Flutter imports
- No Flame imports
- Commands in, snapshots/events out



===== FILE: lib/core/snapshots/entity_render_snapshot.dart =====
// Renderer-facing entity data extracted from the Core at the end of a tick.
//
// This is a read-only, serializable view of entity state for rendering only.
// It must not leak internal core storage details.
import '../math/vec2.dart';
import '../projectiles/projectile_id.dart';
import 'enums.dart';

/// Render-only view of an entity.
class EntityRenderSnapshot {
  const EntityRenderSnapshot({
    required this.id,
    required this.kind,
    required this.pos,
    required this.facing,
    required this.anim,
    required this.grounded,
    this.vel,
    this.size,
    this.projectileId,
    this.z,
    this.animFrame,
  });

  /// Stable entity identifier (protocol-stable).
  final int id;

  /// Broad entity classification for choosing visuals/behavior.
  final EntityKind kind;

  /// World position in virtual pixels.
  final Vec2 pos;

  /// Optional world velocity (useful for facing/animation).
  final Vec2? vel;

  /// Optional full extents in world units (virtual pixels).
  ///
  /// Render-only hint for placeholder shapes (e.g. projectile rectangles).
  final Vec2? size;

  /// Optional projectile archetype id (set when [kind] is [EntityKind.projectile]).
  final ProjectileId? projectileId;

  /// Optional sort key for render ordering.
  final double? z;

  /// Facing direction for choosing sprites/poses.
  final Facing facing;

  /// Whether the entity is grounded at the end of the tick.
  ///
  /// This is authoritative collision state from Core (do not infer from anim).
  final bool grounded;

  /// Logical animation selection (renderer maps to assets).
  final AnimKey anim;

  /// Optional frame hint for deterministic animation in replays/networking.
  final int? animFrame;
}


===== FILE: lib/core/snapshots/enums.dart =====
// Protocol-stable enums used by snapshots (and later networking).
//
// Keep these enums stable over time because they are part of the render
// contract and may become part of the network protocol.
//
// These enums are "logical" (game meaning), not asset/texture names.

/// Logical animation state (not tied to any specific texture or asset).
enum AnimKey {
  idle,
  run,
  jump,
  fall,
  hit,
  cast,
  death,
  spawn,
}

/// Broad entity classification used by the renderer and (later) networking.
enum EntityKind {
  player,
  enemy,
  projectile,
  obstacle,
  pickup,
  hazard,
  trigger,
}

/// Horizontal facing direction for animation/aiming.
enum Facing {
  left,
  right,
}


===== FILE: lib/core/snapshots/game_state_snapshot.dart =====
// Immutable snapshot of the full game state needed by Render/UI.
//
// Built by the Core after each fixed simulation tick and treated as read-only
// by Flame/Flutter. This is the primary contract between Core and the rest of
// the app.
import 'entity_render_snapshot.dart';
import 'player_hud_snapshot.dart';
import 'static_solid_snapshot.dart';

/// Snapshot of the current game state at a specific simulation tick.
class GameStateSnapshot {
  const GameStateSnapshot({
    required this.tick,
    required this.seed,
    required this.distance,
    required this.paused,
    required this.hud,
    required this.entities,
    required this.staticSolids,
  });

  /// Current simulation tick.
  final int tick;

  /// Seed used for deterministic generation/RNG.
  final int seed;

  /// Distance progressed in the run (placeholder for V0).
  final double distance;

  /// Whether the simulation is currently paused.
  final bool paused;

  /// HUD-only player stats.
  final PlayerHudSnapshot hud;

  /// Render-only entity list for the current tick.
  final List<EntityRenderSnapshot> entities;

  /// Render-only static collision geometry (platforms/obstacles) for this run.
  final List<StaticSolidSnapshot> staticSolids;
}


===== FILE: lib/core/snapshots/player_hud_snapshot.dart =====
/// HUD-only data extracted from the Core.
///
/// Split from entity snapshots so the UI can render player stats without
/// scanning all entities every frame.
class PlayerHudSnapshot {
  const PlayerHudSnapshot({
    required this.hp,
    required this.hpMax,
    required this.mana,
    required this.manaMax,
    required this.stamina,
    required this.staminaMax,
    required this.score,
    required this.coins,
  });

  /// Current health.
  final double hp;

  /// Maximum health.
  final double hpMax;

  /// Current mana (resource for spells).
  final double mana;

  /// Maximum mana.
  final double manaMax;

  /// Current stamina (resource for physical actions like jump/dash).
  final double stamina;

  /// Maximum stamina.
  final double staminaMax;

  /// Run score (placeholder for V0).
  final int score;

  /// Collected coins (placeholder for V0).
  final int coins;
}


===== FILE: lib/core/snapshots/static_solid_snapshot.dart =====
/// Renderer-facing snapshot for one piece of static collision geometry.
///
/// This is a read-only view for rendering/debug overlays. Authoritative
/// collision still lives in Core using `StaticWorldGeometry`.
class StaticSolidSnapshot {
  const StaticSolidSnapshot({
    required this.minX,
    required this.minY,
    required this.maxX,
    required this.maxY,
    required this.sides,
    required this.oneWayTop,
  });

  final double minX;
  final double minY;
  final double maxX;
  final double maxY;

  /// Bitmask of enabled faces.
  final int sides;

  /// Whether the top face behaves as one-way (platform).
  final bool oneWayTop;
}



===== FILE: lib/core/spells/spell_catalog.dart =====
import '../projectiles/projectile_id.dart';
import 'spell_id.dart';

class ProjectileSpellStats {
  const ProjectileSpellStats({
    required this.manaCost,
    required this.damage,
  });

  final double manaCost;
  final double damage;
}

class SpellDef {
  const SpellDef({
    required this.stats,
    required this.projectileId,
  });

  /// Spell-specific gameplay stats (resource cost, damage, etc).
  final ProjectileSpellStats stats;

  /// Optional projectile mapping. Non-projectile spells have `null`.
  final ProjectileId? projectileId;
}

class SpellCatalog {
  const SpellCatalog();

  SpellDef get(SpellId id) {
    switch (id) {
      case SpellId.iceBolt:
        return const SpellDef(
          stats: ProjectileSpellStats(manaCost: 10.0, damage: 25.0),
          projectileId: ProjectileId.iceBolt,
        );
      case SpellId.lightning:
        return const SpellDef(
          stats: ProjectileSpellStats(manaCost: 10.0, damage: 10.0),
          projectileId: ProjectileId.lightningBolt,
        );
    }
  }
}


===== FILE: lib/core/spells/spell_id.dart =====
enum SpellId { iceBolt, lightning }



===== FILE: lib/core/tuning/v0_ability_tuning.dart =====
import '../util/tick_math.dart';

class V0AbilityTuning {
  const V0AbilityTuning({
    this.castCooldownSeconds = 0.25,
    this.meleeCooldownSeconds = 0.30,
    this.meleeActiveSeconds = 0.10,
    this.meleeStaminaCost = 15.0,
    this.meleeDamage = 25.0,
    this.meleeHitboxSizeX = 32.0,
    this.meleeHitboxSizeY = 16.0,
  });

  final double castCooldownSeconds;

  final double meleeCooldownSeconds;
  final double meleeActiveSeconds;
  final double meleeStaminaCost;
  final double meleeDamage;

  /// Full extents in world units (virtual pixels).
  final double meleeHitboxSizeX;
  final double meleeHitboxSizeY;
}

class V0AbilityTuningDerived {
  const V0AbilityTuningDerived._({
    required this.tickHz,
    required this.base,
    required this.castCooldownTicks,
    required this.meleeCooldownTicks,
    required this.meleeActiveTicks,
  });

  factory V0AbilityTuningDerived.from(
    V0AbilityTuning base, {
    required int tickHz,
  }) {
    if (tickHz <= 0) {
      throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
    }

    return V0AbilityTuningDerived._(
      tickHz: tickHz,
      base: base,
      castCooldownTicks: ticksFromSecondsCeil(base.castCooldownSeconds, tickHz),
      meleeCooldownTicks: ticksFromSecondsCeil(base.meleeCooldownSeconds, tickHz),
      meleeActiveTicks: ticksFromSecondsCeil(base.meleeActiveSeconds, tickHz),
    );
  }

  final int tickHz;
  final V0AbilityTuning base;

  final int castCooldownTicks;
  final int meleeCooldownTicks;
  final int meleeActiveTicks;
}


===== FILE: lib/core/tuning/v0_movement_tuning.dart =====
import '../util/tick_math.dart';

/// V0 movement/physics tuning for the Core simulation.
///
/// All units are expressed in world units ("virtual pixels") and seconds:
/// - speeds: world units / second
/// - acceleration: world units / second^2
/// - times: seconds (converted to fixed-tick counts at runtime)
///
/// The derived values are computed once per [tickHz] and then used in the hot
/// per-tick loop to keep the core allocation-light.
const int v0DefaultTickHz = 60;

/// Authoritative movement constants (expressed in seconds-based units).
class V0MovementTuning {
  const V0MovementTuning({
    this.playerRadius = 8,
    this.maxSpeedX = 500,
    this.accelerationX = 1200,
    this.decelerationX = 800,
    this.minMoveSpeed = 5,
    this.gravityY = 2400,
    this.maxVelX = 3000,
    this.maxVelY = 3000,
    this.jumpSpeed = 1200,
    this.coyoteTimeSeconds = 0.10,
    this.jumpBufferSeconds = 0.12,
    this.dashSpeedX = 1100,
    this.dashDurationSeconds = 0.20,
    this.dashCooldownSeconds = 3.0,
  });

  /// Player "collision" radius in world units (used for ground contact in V0).
  final double playerRadius;

  /// Target max horizontal speed when holding move input.
  final double maxSpeedX;
  final double accelerationX;
  final double decelerationX;
  final double minMoveSpeed;

  /// Gravity acceleration (positive is downward).
  final double gravityY;

  /// Speed clamps (safety caps).
  final double maxVelX;
  final double maxVelY;

  /// Instantaneous jump vertical speed (negative is upward).
  final double jumpSpeed;

  /// Jump forgiveness windows (platformer-style).
  final double coyoteTimeSeconds;
  final double jumpBufferSeconds;

  /// Dash parameters.
  final double dashSpeedX;
  final double dashDurationSeconds;
  final double dashCooldownSeconds;
}

/// Derived, tick-based tuning computed for a specific [tickHz].
class V0MovementTuningDerived {
  const V0MovementTuningDerived._({
    required this.tickHz,
    required this.dtSeconds,
    required this.base,
    required this.coyoteTicks,
    required this.jumpBufferTicks,
    required this.dashDurationTicks,
    required this.dashCooldownTicks,
  });

  factory V0MovementTuningDerived.from(
    V0MovementTuning base, {
    required int tickHz,
  }) {
    if (tickHz <= 0) {
      throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
    }
    return V0MovementTuningDerived._(
      tickHz: tickHz,
      dtSeconds: 1.0 / tickHz,
      base: base,
      coyoteTicks: ticksFromSecondsCeil(base.coyoteTimeSeconds, tickHz),
      jumpBufferTicks: ticksFromSecondsCeil(base.jumpBufferSeconds, tickHz),
      dashDurationTicks: ticksFromSecondsCeil(base.dashDurationSeconds, tickHz),
      dashCooldownTicks: ticksFromSecondsCeil(base.dashCooldownSeconds, tickHz),
    );
  }

  final int tickHz;
  final double dtSeconds;
  final V0MovementTuning base;

  final int coyoteTicks;
  final int jumpBufferTicks;
  final int dashDurationTicks;
  final int dashCooldownTicks;
}


===== FILE: lib/core/tuning/v0_resource_tuning.dart =====
/// Resource tuning for V0 (author in seconds, applied per fixed tick).
///
/// Values are based on the C++ reference (`tools/output/c++implementation.txt`).
class V0ResourceTuning {
  const V0ResourceTuning({
    this.playerHpMax = 100,
    this.playerHpRegenPerSecond = 1,
    this.playerManaMax = 100,
    this.playerManaRegenPerSecond = 3,
    this.playerStaminaMax = 100,
    this.playerStaminaRegenPerSecond = 1,
    this.playerHpStart,
    this.playerManaStart,
    this.playerStaminaStart,
    this.jumpStaminaCost = 2,
    this.dashStaminaCost = 2,
  });

  final double playerHpMax;
  final double playerHpRegenPerSecond;

  final double playerManaMax;
  final double playerManaRegenPerSecond;

  final double playerStaminaMax;
  final double playerStaminaRegenPerSecond;

  /// Optional starting values. When null, the corresponding `*Max` is used.
  final double? playerHpStart;
  final double? playerManaStart;
  final double? playerStaminaStart;

  /// Action costs (C++ reference: 2 stamina each for jump + dash).
  final double jumpStaminaCost;
  final double dashStaminaCost;
}


===== FILE: lib/core/util/double_math.dart =====
import 'dart:math';

double clampDouble(double v, double lo, double hi) => max(lo, min(hi, v));



===== FILE: lib/core/util/tick_math.dart =====
import 'dart:math';

/// Converts a duration in seconds to a positive tick count for a fixed tick rate.
///
/// Rules:
/// - `seconds <= 0` => `0` ticks
/// - otherwise `max(1, ceil(seconds * tickHz))`
int ticksFromSecondsCeil(double seconds, int tickHz) {
  if (tickHz <= 0) {
    throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
  }
  if (seconds <= 0) return 0;
  return max(1, (seconds * tickHz).ceil());
}



===== FILE: lib/game/components/hud_bars_component.dart =====
import 'dart:ui';

import 'package:flame/components.dart';

import '../game_controller.dart';

class HudBarsComponent extends PositionComponent {
  HudBarsComponent({
    required GameController controller,
    this.barWidth = 140,
    this.barHeight = 6,
    this.barGap = 4,
    super.position,
    super.anchor,
  }) : _controller = controller;

  final GameController _controller;

  final double barWidth;
  final double barHeight;
  final double barGap;

  final Paint _back = Paint()..color = const Color(0xAA000000);
  final Paint _outline = Paint()
    ..color = const Color(0xFFFFFFFF)
    ..style = PaintingStyle.stroke
    ..strokeWidth = 1;

  final Paint _hp = Paint()..color = const Color(0xFFDC4440);
  final Paint _mana = Paint()..color = const Color(0xFF2D98DA);
  final Paint _stamina = Paint()..color = const Color(0xFF4CD137);

  @override
  void render(Canvas canvas) {
    super.render(canvas);

    final hud = _controller.snapshot.hud;

    _drawBar(
      canvas,
      y: 0,
      value: hud.hp,
      max: hud.hpMax,
      fill: _hp,
    );
    _drawBar(
      canvas,
      y: barHeight + barGap,
      value: hud.mana,
      max: hud.manaMax,
      fill: _mana,
    );
    _drawBar(
      canvas,
      y: (barHeight + barGap) * 2,
      value: hud.stamina,
      max: hud.staminaMax,
      fill: _stamina,
    );
  }

  void _drawBar(
    Canvas canvas, {
    required double y,
    required double value,
    required double max,
    required Paint fill,
  }) {
    final x = 0.0;
    final w = barWidth;
    final h = barHeight;

    final backRect = Rect.fromLTWH(x, y, w, h);
    canvas.drawRect(backRect, _back);
    canvas.drawRect(backRect, _outline);

    if (max <= 0) return;
    final t = (value / max).clamp(0.0, 1.0);
    if (t <= 0) return;
    canvas.drawRect(Rect.fromLTWH(x, y, w * t, h), fill);
  }
}


===== FILE: lib/game/components/pixel_parallax_backdrop_component.dart =====
import 'dart:ui' as ui;

import 'package:flame/components.dart';
import 'package:flame/game.dart';
import 'package:flutter/painting.dart';

import '../util/math_util.dart';

/// A pixel-art friendly parallax backdrop that enforces integer-pixel motion.
///
/// This component is intended to be mounted under `game.camera.backdrop`, so it
/// renders *behind* the world and is not affected by camera movement (we apply
/// parallax offsets manually based on the camera viewfinder).
///
/// Each layer:
/// - draws at 1:1 (world units == virtual pixels)
/// - uses `FilterQuality.none` (no blur)
/// - can optionally snap scroll offsets to integer pixels (reduces shimmer but
///   produces "steppy" motion on slow layers)
class PixelParallaxBackdropComponent extends Component
    with HasGameReference<FlameGame> {
  PixelParallaxBackdropComponent({
    required this.virtualWidth,
    required this.virtualHeight,
    required this.layers,
    this.snapScrollToPixels = true,
  });

  final int virtualWidth;
  final int virtualHeight;
  final List<PixelParallaxLayerSpec> layers;

  /// When true, each layer's scroll offset is snapped to integer pixels.
  ///
  /// When false, sub-pixel scrolling is allowed (smoother motion) but will
  /// introduce shimmer on pixel art. This is a deliberate tradeoff.
  final bool snapScrollToPixels;

  late final List<ui.Image> _images;
  int? _prevCameraLeftX;
  late final List<double> _scroll;

  final Paint _paint = Paint()..filterQuality = FilterQuality.none;

  @override
  Future<void> onLoad() async {
    await super.onLoad();
    _images = await Future.wait(
      layers.map((layer) => game.images.load(layer.assetPath)),
    );
    _scroll = List<double>.filled(layers.length, 0);
  }

  @override
  void update(double dt) {
    super.update(dt);

    final viewWidth = virtualWidth;
    final cameraLeftX =
        (game.camera.viewfinder.position.x - viewWidth / 2).round();

    final prev = _prevCameraLeftX;
    _prevCameraLeftX = cameraLeftX;
    if (prev == null) return;

    final delta = cameraLeftX - prev;
    if (delta == 0) return;

    for (var i = 0; i < layers.length; i++) {
      _scroll[i] += delta * layers[i].parallaxFactor;
      _scroll[i] = positiveModDouble(_scroll[i], _images[i].width.toDouble());
    }
  }

  @override
  void render(ui.Canvas canvas) {
    super.render(canvas);

    final viewWidth = virtualWidth;
    final viewHeight = virtualHeight;

    canvas.save();
    canvas.clipRect(
      ui.Rect.fromLTWH(0, 0, viewWidth.toDouble(), viewHeight.toDouble()),
    );

    for (var i = 0; i < layers.length; i++) {
      final image = _images[i];

      final imageW = image.width;
      final imageH = image.height;
      final y = (viewHeight - imageH).toDouble(); // bottom-aligned

      final scroll = snapScrollToPixels ? _scroll[i].roundToDouble() : _scroll[i];
      final offsetPx = -scroll;
      final startX = positiveModDouble(offsetPx, imageW.toDouble());

      for (var x = startX - imageW; x < viewWidth; x += imageW) {
        canvas.drawImage(image, ui.Offset(x, y), _paint);
      }
    }

    canvas.restore();
  }
}

/// One parallax layer spec.
class PixelParallaxLayerSpec {
  const PixelParallaxLayerSpec({
    required this.assetPath,
    required this.parallaxFactor,
  });

  final String assetPath;

  /// `0.0` means static background, `1.0` moves with the camera.
  ///
  /// Values are snapped to integer pixels after multiplication.
  final double parallaxFactor;
}


===== FILE: lib/game/components/tiled_ground_band_component.dart =====
import 'dart:ui' as ui;

import 'package:flame/components.dart';
import 'package:flame/game.dart';
import 'package:flutter/painting.dart';

import '../util/math_util.dart';

/// World-space ground band placeholder (visual reference for Milestone 1).
///
/// This draws `Field Layer 09.png` as a horizontally tiled strip in *world
/// coordinates* so it naturally moves 1.0× with the camera.
///
/// Collision is handled later in Core (Milestone 2). For now, this provides a
/// stable visual ground reference for camera + pixel-perfect sanity checks.
class TiledGroundBandComponent extends Component
    with HasGameReference<FlameGame> {
  TiledGroundBandComponent({
    required this.assetPath,
    this.virtualWidth,
    required this.virtualHeight,
    this.renderInBackdrop = false,
  }) {
    if (renderInBackdrop && virtualWidth == null) {
      throw ArgumentError(
        'virtualWidth is required when renderInBackdrop is true',
      );
    }
  }

  final String assetPath;
  final int? virtualWidth;
  final int virtualHeight;
  final bool renderInBackdrop;

  late final ui.Image _image;
  final Paint _paint = Paint()..filterQuality = FilterQuality.none;

  @override
  Future<void> onLoad() async {
    await super.onLoad();
    _image = await game.images.load(assetPath);
  }

  @override
  void render(ui.Canvas canvas) {
    super.render(canvas);

    if (renderInBackdrop) {
      final viewWidth = virtualWidth!;

      final tileW = _image.width;
      final tileH = _image.height;
      final y = (virtualHeight - tileH).toDouble(); // bottom aligned

      final cameraLeftX =
          (game.camera.viewfinder.position.x - viewWidth / 2);
      final offsetPx = -cameraLeftX;
      final startX = positiveModDouble(offsetPx, tileW.toDouble());

      canvas.save();
      canvas.clipRect(
        ui.Rect.fromLTWH(0, 0, viewWidth.toDouble(), virtualHeight.toDouble()),
      );

      for (var x = startX - tileW; x < viewWidth; x += tileW) {
        canvas.drawImage(_image, ui.Offset(x, y), _paint);
      }

      canvas.restore();
      return;
    }

    final visible = game.camera.visibleWorldRect;

    final tileW = _image.width;
    final tileH = _image.height;
    final y = (virtualHeight - tileH).toDouble(); // bottom aligned to viewport

    final left = visible.left.floor();
    final right = visible.right.ceil();

    final startTile = _floorDiv(left, tileW) - 1;
    final endTile = _floorDiv(right, tileW) + 1;

    for (var tile = startTile; tile <= endTile; tile++) {
      final x = (tile * tileW).toDouble();
      canvas.drawImage(_image, ui.Offset(x, y), _paint);
    }
  }

  int _floorDiv(int a, int b) {
    if (b <= 0) throw ArgumentError.value(b, 'b', 'must be > 0');
    if (a >= 0) return a ~/ b;
    return -(((-a) + b - 1) ~/ b);
  }
}


===== FILE: lib/game/game_controller.dart =====
// Bridge between Core simulation and the Flutter/Flame runtime.
//
// Responsibilities:
// - Owns the `GameCore` instance
// - Queues tick-stamped input commands
// - Runs a fixed-tick simulation loop using an accumulator
// - Exposes (`prevSnapshot`, `snapshot`, `alpha`) for render interpolation
// - Buffers transient `GameEvent`s for Render/UI to consume
import 'dart:math';

import '../core/commands/command.dart';
import '../core/events/game_event.dart';
import '../core/game_core.dart';
import '../core/snapshots/game_state_snapshot.dart';
import 'tick_input_frame.dart';

/// Owns the simulation clock and provides a stable interface to UI/renderer.
class GameController {
  GameController({required GameCore core, this.tickHz = 60, this.inputLead = 1})
    : _core = core {
    if (tickHz <= 0) {
      throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
    }
    if (inputLead < 1) {
      throw ArgumentError.value(inputLead, 'inputLead', 'must be >= 1');
    }
    if (tickHz != _core.tickHz) {
      throw ArgumentError(
        'GameController.tickHz ($tickHz) must match GameCore.tickHz (${_core.tickHz}).',
      );
    }
    _curr = _core.buildSnapshot();
    _prev = _curr;
  }

  final GameCore _core;

  /// Fixed simulation tick frequency.
  final int tickHz;

  /// How many ticks ahead local input is scheduled by default.
  ///
  /// `1` means "next tick".
  final int inputLead;

  /// Buffered commands keyed by their target tick.
  final Map<int, TickInputFrame> _inputsByTick = <int, TickInputFrame>{};

  final List<Command> _commandScratch = <Command>[];
  final TickInputFrame _frameScratch = TickInputFrame();

  /// Buffered transient events produced by the core.
  final List<GameEvent> _events = <GameEvent>[];

  late GameStateSnapshot _prev;
  late GameStateSnapshot _curr;

  /// Accumulated time for fixed-tick simulation.
  double _accumulatorSeconds = 0;

  /// Current simulation tick (authoritative).
  int get tick => _core.tick;

  /// Latest snapshot produced by the core.
  GameStateSnapshot get snapshot => _curr;

  /// Previous snapshot (used for render interpolation).
  GameStateSnapshot get prevSnapshot => _prev;

  /// Interpolation factor between `prevSnapshot` and `snapshot` for rendering.
  double get alpha {
    final dtTick = 1.0 / tickHz;
    return (_accumulatorSeconds / dtTick).clamp(0, 1);
  }

  /// Enqueues a command to be applied at its declared tick.
  void enqueue(Command command) {
    final frame = _inputsByTick.putIfAbsent(command.tick, () => TickInputFrame());
    frame.apply(command);
  }

  /// Helper to schedule a command for the next tick (plus `inputLead`).
  void enqueueForNextTick(Command Function(int tick) factory) {
    enqueue(factory(tick + inputLead));
  }

  /// Drains and clears all buffered transient events.
  List<GameEvent> drainEvents() {
    if (_events.isEmpty) return const <GameEvent>[];
    final drained = List<GameEvent>.unmodifiable(_events);
    _events.clear();
    return drained;
  }

  /// Pauses/unpauses the simulation.
  void setPaused(bool value) {
    if (_core.paused == value) return;
    _core.paused = value;
    _accumulatorSeconds = 0;
    _prev = _core.buildSnapshot();
    _curr = _prev;
  }

  /// Permanently stops this controller for the current session.
  ///
  /// Use this when leaving the mini-game route (dispose), NOT for backgrounding
  /// (that's what [setPaused] is for).
  ///
  /// What it does:
  /// - pauses the core
  /// - clears queued commands (prevents "stuck input" on next mount)
  /// - clears buffered transient events
  /// - resets interpolation state (accumulator + snapshots)
  void shutdown() {
    // Pause regardless of current state (do NOT early-return like setPaused()).
    _core.paused = true;

    // Drop any in-flight fixed-tick accumulation.
    _accumulatorSeconds = 0;

    // Kill transient buffers so nothing leaks across sessions.
    _inputsByTick.clear();
    _events.clear();

    // Make snapshots consistent with the paused state.
    _curr = _core.buildSnapshot();
    _prev = _curr;
  }

  /// Advances the simulation clock based on a variable frame delta.
  ///
  /// This uses an accumulator to execute a fixed number of simulation ticks.
  /// `dtSeconds` is clamped to avoid "spiral of death" after app resumes.
  void advanceFrame(double dtSeconds, {double dtFrameMaxSeconds = 0.1}) {
    if (dtSeconds.isNaN || dtSeconds.isInfinite) return;
    if (_core.paused) {
      _accumulatorSeconds = 0;
      return;
    }

    final clamped = max(0.0, min(dtSeconds, dtFrameMaxSeconds));
    _accumulatorSeconds += clamped;

    final dtTick = 1.0 / tickHz;

    while (_accumulatorSeconds >= dtTick) {
      final nextTick = _core.tick + 1;
      final input = _inputsByTick.remove(nextTick) ?? _frameScratch;
      _applyTickInput(nextTick, input);
      _core.stepOneTick();

      _prev = _curr;
      _curr = _core.buildSnapshot();
      _accumulatorSeconds -= dtTick;
    }
  }

  void _applyTickInput(int tick, TickInputFrame input) {
    _commandScratch.clear();

    final axis = input.moveAxis;
    if (axis != 0) {
      _commandScratch.add(MoveAxisCommand(tick: tick, axis: axis));
    }

    if (input.aimDirSet) {
      _commandScratch.add(
        AimDirCommand(
          tick: tick,
          x: input.aimDirX,
          y: input.aimDirY,
        ),
      );
    }
    if (input.jumpPressed) {
      _commandScratch.add(JumpPressedCommand(tick: tick));
    }
    if (input.dashPressed) {
      _commandScratch.add(DashPressedCommand(tick: tick));
    }
    if (input.attackPressed) {
      _commandScratch.add(AttackPressedCommand(tick: tick));
    }
    if (input.castPressed) {
      _commandScratch.add(CastPressedCommand(tick: tick));
    }

    _core.applyCommands(_commandScratch);

    // If this is a scratch fallback, it will be reset by the next use anyway.
    // For frames stored in the map we drop the instance after remove().
    input.reset();
  }
}


===== FILE: lib/game/input/runner_input_router.dart =====
import 'dart:math';

import '../../core/commands/command.dart';
import '../game_controller.dart';

/// Shared input scheduler for multiple input sources (touch + keyboard + mouse).
///
/// - Holds the current continuous inputs (move axis, aim direction).
/// - Schedules them into the GameController for upcoming ticks so Core receives
///   tick-stamped Commands.
/// - Schedules edge-triggered presses (jump/dash/attack/cast) for the next tick.
class RunnerInputRouter {
  RunnerInputRouter({required this.controller});

  final GameController controller;

  static const double _aimQuantizeScale = 256.0;

  double _moveAxis = 0;
  double _lastScheduledAxis = 0;
  int _axisScheduledThroughTick = 0;

  bool _aimSet = false;
  bool _lastScheduledAimSet = false;
  double _aimX = 0;
  double _aimY = 0;
  double _lastScheduledAimX = 0;
  double _lastScheduledAimY = 0;
  int _aimScheduledThroughTick = 0;

  static double _quantizeAim(double value) {
    if (value == 0) return 0;
    return (value * _aimQuantizeScale).roundToDouble() / _aimQuantizeScale;
  }

  void setMoveAxis(double axis) {
    _moveAxis = axis.clamp(-1.0, 1.0);
  }

  /// Sets the aim direction (should be normalized or near-normalized).
  void setAimDir(double x, double y) {
    final qx = _quantizeAim(x);
    final qy = _quantizeAim(y);

    if (_aimSet && qx == _aimX && qy == _aimY) {
      return;
    }

    _aimSet = true;
    _aimX = qx;
    _aimY = qy;
  }

  void clearAimDir() {
    _aimSet = false;
    _aimX = 0;
    _aimY = 0;
  }

  void pressJump() => controller.enqueueForNextTick(
        (tick) => JumpPressedCommand(tick: tick),
      );

  void pressDash() => controller.enqueueForNextTick(
        (tick) => DashPressedCommand(tick: tick),
      );

  void pressAttack() => controller.enqueueForNextTick(
        (tick) => AttackPressedCommand(tick: tick),
      );

  void pressCast() => controller.enqueueForNextTick(
        (tick) => CastPressedCommand(tick: tick),
      );

  /// Presses cast on the next tick and ensures the aim direction is set for the same tick.
  void pressCastWithAim() {
    final tick = controller.tick + controller.inputLead;
    if (_aimSet) {
      controller.enqueue(AimDirCommand(tick: tick, x: _aimX, y: _aimY));
    }
    controller.enqueue(CastPressedCommand(tick: tick));
  }

  /// Schedules the current held inputs across upcoming ticks.
  ///
  /// Call once per frame before `controller.advanceFrame(dt)`.
  void pumpHeldInputs() {
    _scheduleHeldMoveAxis();
    _scheduleHeldAimDir();
  }

  void _scheduleHeldMoveAxis() {
    final axis = _moveAxis;

    if (axis == 0 && _lastScheduledAxis == 0) {
      // No held axis and nothing to override.
      _axisScheduledThroughTick = controller.tick;
      return;
    }

    if (axis != _lastScheduledAxis) {
      // Axis changed (including to 0); reschedule to overwrite any already
      // buffered ticks.
      _axisScheduledThroughTick = controller.tick;
      _lastScheduledAxis = axis;
    }

    final maxTicksPerFrame = (controller.tickHz * 0.1).ceil();
    final targetMaxTick =
        controller.tick + controller.inputLead + maxTicksPerFrame;

    final startTick = max(controller.tick + 1, _axisScheduledThroughTick + 1);
    for (var t = startTick; t <= targetMaxTick; t += 1) {
      controller.enqueue(MoveAxisCommand(tick: t, axis: axis));
    }
    _axisScheduledThroughTick = targetMaxTick;
  }

  void _scheduleHeldAimDir() {
    if (!_aimSet && !_lastScheduledAimSet) {
      // No held aim and nothing to override.
      _aimScheduledThroughTick = controller.tick;
      return;
    }

    if (_aimSet != _lastScheduledAimSet) {
      _aimScheduledThroughTick = controller.tick;
      _lastScheduledAimSet = _aimSet;
      _lastScheduledAimX = _aimX;
      _lastScheduledAimY = _aimY;
    }

    if (_aimSet && (_aimX != _lastScheduledAimX || _aimY != _lastScheduledAimY)) {
      // Reschedule ahead when the aim vector changes.
      _aimScheduledThroughTick = controller.tick;
      _lastScheduledAimX = _aimX;
      _lastScheduledAimY = _aimY;
    }

    final maxTicksPerFrame = (controller.tickHz * 0.1).ceil();
    final targetMaxTick =
        controller.tick + controller.inputLead + maxTicksPerFrame;

    final startTick = max(controller.tick + 1, _aimScheduledThroughTick + 1);
    for (var t = startTick; t <= targetMaxTick; t += 1) {
      if (_aimSet) {
        controller.enqueue(AimDirCommand(tick: t, x: _aimX, y: _aimY));
      } else {
        controller.enqueue(ClearAimDirCommand(tick: t));
      }
    }
    _aimScheduledThroughTick = targetMaxTick;
  }
}


===== FILE: lib/game/README.md =====
# Game (Flame)

Flame rendering layer.

- Renders from core snapshots (read-only)
- Handles camera/parallax/VFX/audio
- Must not own authoritative gameplay state



===== FILE: lib/game/runner_flame_game.dart =====
// Flame rendering layer for the runner (Milestone 0 placeholder).
//
// Reads the latest `GameStateSnapshot` from `GameController` each frame and
// renders a minimal representation (a player dot + debug text). This file is
// intentionally tiny and non-authoritative: gameplay truth lives in Core.
import 'package:flame/components.dart';
import 'package:flame/game.dart';
import 'package:flutter/widgets.dart';

import '../core/contracts/v0_render_contract.dart';
import '../core/snapshots/entity_render_snapshot.dart';
import '../core/snapshots/enums.dart';
import '../core/snapshots/static_solid_snapshot.dart';
import 'input/runner_input_router.dart';
import 'components/pixel_parallax_backdrop_component.dart';
import 'components/tiled_ground_band_component.dart';
import 'components/hud_bars_component.dart';
import 'game_controller.dart';

/// Minimal Flame `Game` that renders from snapshots.
class RunnerFlameGame extends FlameGame {
  RunnerFlameGame({required this.controller, required this.input})
    : super(
        camera: CameraComponent.withFixedResolution(
          width: v0VirtualWidth.toDouble(),
          height: v0VirtualHeight.toDouble(),
        ),
      );

  /// Bridge/controller that owns the simulation and produces snapshots.
  final GameController controller;

  /// Input scheduler/aggregator (touch + keyboard + mouse).
  final RunnerInputRouter input;

  late final CircleComponent _player;
  late final TextComponent _debugText;
  final List<RectangleComponent> _staticSolids = <RectangleComponent>[];
  final Map<int, RectangleComponent> _projectiles = <int, RectangleComponent>{};
  final Paint _projectilePaint = Paint()..color = const Color(0xFF60A5FA);
  final Map<int, RectangleComponent> _hitboxes = <int, RectangleComponent>{};
  final Paint _hitboxPaint = Paint()..color = const Color(0x66EF4444);

  @override
  Future<void> onLoad() async {
    await super.onLoad();

    camera.backdrop.add(
      PixelParallaxBackdropComponent(
        virtualWidth: v0VirtualWidth,
        virtualHeight: v0VirtualHeight,
        snapScrollToPixels: false,
        layers: const [
          PixelParallaxLayerSpec(
            assetPath: 'parallax/field/Field Layer 01.png',
            parallaxFactor: 0.10,
          ),
          PixelParallaxLayerSpec(
            assetPath: 'parallax/field/Field Layer 02.png',
            parallaxFactor: 0.15,
          ),
          PixelParallaxLayerSpec(
            assetPath: 'parallax/field/Field Layer 03.png',
            parallaxFactor: 0.20,
          ),
          PixelParallaxLayerSpec(
            assetPath: 'parallax/field/Field Layer 04.png',
            parallaxFactor: 0.30,
          ),
          PixelParallaxLayerSpec(
            assetPath: 'parallax/field/Field Layer 05.png',
            parallaxFactor: 0.40,
          ),
          PixelParallaxLayerSpec(
            assetPath: 'parallax/field/Field Layer 06.png',
            parallaxFactor: 0.50,
          ),
          PixelParallaxLayerSpec(
            assetPath: 'parallax/field/Field Layer 07.png',
            parallaxFactor: 0.60,
          ),
          PixelParallaxLayerSpec(
            assetPath: 'parallax/field/Field Layer 08.png',
            parallaxFactor: 0.70,
          ),
        ],
      )..priority = -30,
    );

    camera.backdrop.add(
      TiledGroundBandComponent(
        assetPath: 'parallax/field/Field Layer 09.png',
        virtualWidth: v0VirtualWidth,
        virtualHeight: v0VirtualHeight,
        renderInBackdrop: true,
      )..priority = -20,
    );

    camera.backdrop.add(
      PixelParallaxBackdropComponent(
        virtualWidth: v0VirtualWidth,
        virtualHeight: v0VirtualHeight,
        snapScrollToPixels: false,
        layers: const [
          PixelParallaxLayerSpec(
            assetPath: 'parallax/field/Field Layer 10.png',
            parallaxFactor: 1.0,
          ),
        ],
      )..priority = -10,
    );

    _player = CircleComponent(
      radius: 8,
      paint: Paint()..color = const Color(0xFF4ADE80),
      anchor: Anchor.center,
    );
    world.add(_player);

    _mountStaticSolids(controller.snapshot.staticSolids);

    _debugText = TextComponent(
      text: '',
      position: Vector2(8, 8),
      anchor: Anchor.topLeft,
      textRenderer: TextPaint(
        style: const TextStyle(
          fontSize: 14,
          color: Color.fromARGB(255, 255, 0, 0),
        ),
      ),
    );
    camera.viewport.add(_debugText);

    camera.viewport.add(
      HudBarsComponent(
        controller: controller,
        position: Vector2(8, 8),
        anchor: Anchor.topLeft,
      )..priority = 100,
    );
  }

  @override
  void update(double dt) {
    input.pumpHeldInputs();

    super.update(dt);

    // Step the deterministic core using the frame delta, then render the
    // newest snapshot.
    controller.advanceFrame(dt);
    final snapshot = controller.snapshot;

    final player = _findPlayer(snapshot.entities);
    if (player != null) {
      final snappedX = player.pos.x.roundToDouble();
      final snappedY = player.pos.y.roundToDouble();
      _player.position.setValues(snappedX, snappedY);
      camera.viewfinder.position = Vector2(
        snappedX,
        v0CameraFixedY.roundToDouble(),
      );
    }

    _syncProjectiles(snapshot.entities);
    _syncHitboxes(snapshot.entities);

    assert(() {
      _debugText.text =
          'tick=${snapshot.tick} seed=${snapshot.seed} x=${player?.pos.x.toStringAsFixed(1) ?? '-'} y=${player?.pos.y.toStringAsFixed(1) ?? '-'} anim=${player?.anim.name ?? '-'}';
      return true;
    }());
  }

  void _mountStaticSolids(List<StaticSolidSnapshot> solids) {
    if (solids.isEmpty) return;

    for (final solid in solids) {
      final color = solid.oneWayTop
          ? const Color(0x6648BB78) // green-ish translucent
          : const Color(0x668B5CF6); // purple translucent

      final rect = RectangleComponent(
        position: Vector2(solid.minX, solid.minY),
        size: Vector2(solid.maxX - solid.minX, solid.maxY - solid.minY),
        paint: Paint()..color = color,
      );
      rect.priority = -5;
      _staticSolids.add(rect);
      world.add(rect);
    }
  }

  /// Finds the player entity in the snapshot.
  EntityRenderSnapshot? _findPlayer(List<EntityRenderSnapshot> entities) {
    for (final e in entities) {
      if (e.kind == EntityKind.player) return e;
    }
    return null;
  }

  void _syncProjectiles(List<EntityRenderSnapshot> entities) {
    final seen = <int>{};

    for (final e in entities) {
      if (e.kind != EntityKind.projectile) continue;
      seen.add(e.id);

      var view = _projectiles[e.id];
      if (view == null) {
        final size = e.size;
        view = RectangleComponent(
          size: Vector2(size?.x ?? 8.0, size?.y ?? 8.0),
          anchor: Anchor.center,
          paint: _projectilePaint,
        );
        view.priority = -1;
        _projectiles[e.id] = view;
        world.add(view);
      } else {
        final size = e.size;
        if (size != null) {
          view.size.setValues(size.x, size.y);
        }
      }

      view.position.setValues(
        e.pos.x.roundToDouble(),
        e.pos.y.roundToDouble(),
      );
    }

    if (_projectiles.isEmpty) return;
    final toRemove = <int>[];
    for (final id in _projectiles.keys) {
      if (!seen.contains(id)) toRemove.add(id);
    }
    for (final id in toRemove) {
      _projectiles.remove(id)?.removeFromParent();
    }
  }

  void _syncHitboxes(List<EntityRenderSnapshot> entities) {
    final seen = <int>{};

    for (final e in entities) {
      if (e.kind != EntityKind.trigger) continue;
      seen.add(e.id);

      var view = _hitboxes[e.id];
      if (view == null) {
        final size = e.size;
        view = RectangleComponent(
          size: Vector2(size?.x ?? 8.0, size?.y ?? 8.0),
          anchor: Anchor.center,
          paint: _hitboxPaint,
        );
        view.priority = 1;
        _hitboxes[e.id] = view;
        world.add(view);
      } else {
        final size = e.size;
        if (size != null) {
          view.size.setValues(size.x, size.y);
        }
      }

      view.position.setValues(
        e.pos.x.roundToDouble(),
        e.pos.y.roundToDouble(),
      );
    }

    if (_hitboxes.isEmpty) return;
    final toRemove = <int>[];
    for (final id in _hitboxes.keys) {
      if (!seen.contains(id)) toRemove.add(id);
    }
    for (final id in toRemove) {
      _hitboxes.remove(id)?.removeFromParent();
    }
  }

  @override
  void onRemove() {
    images.clearCache();
    super.onRemove();
  }
}


===== FILE: lib/game/tick_input_frame.dart =====
import '../core/commands/command.dart';

/// Aggregated per-tick input for the simulation.
///
/// This replaces `List<Command>` buffering for a given tick to avoid duplicate
/// commands (e.g. multiple MoveAxis updates for the same tick).
class TickInputFrame {
  double moveAxis = 0;
  bool jumpPressed = false;
  bool dashPressed = false;
  bool attackPressed = false;
  bool aimDirSet = false;
  double aimDirX = 0;
  double aimDirY = 0;
  bool castPressed = false;

  void apply(Command command) {
    switch (command) {
      case MoveAxisCommand(:final axis):
        moveAxis = axis.clamp(-1.0, 1.0);
      case JumpPressedCommand():
        jumpPressed = true;
      case DashPressedCommand():
        dashPressed = true;
      case AttackPressedCommand():
        attackPressed = true;
      case AimDirCommand(:final x, :final y):
        aimDirSet = true;
        aimDirX = x;
        aimDirY = y;
      case ClearAimDirCommand():
        aimDirSet = false;
        aimDirX = 0;
        aimDirY = 0;
      case CastPressedCommand():
        castPressed = true;
    }
  }

  void reset() {
    moveAxis = 0;
    jumpPressed = false;
    dashPressed = false;
    attackPressed = false;
    aimDirSet = false;
    aimDirX = 0;
    aimDirY = 0;
    castPressed = false;
  }
}


===== FILE: lib/game/util/math_util.dart =====
double positiveModDouble(double value, double mod) {
  if (mod <= 0) throw ArgumentError.value(mod, 'mod', 'must be > 0');
  final r = value % mod;
  return r < 0 ? r + mod : r;
}



===== FILE: lib/main.dart =====
import 'package:flutter/material.dart';

import 'ui/dev_menu_page.dart';

/// Development-only host app for running the mini-game standalone.
///
/// The runner is intended to be embedded in another Flutter app via
/// `RunnerGameWidget` / `createRunnerGameRoute` (see `lib/runner.dart`).
/// Keep `main.dart` free of assumptions that would prevent embedding.
void main() {
  runApp(const _DevApp());
}

class _DevApp extends StatelessWidget {
  const _DevApp();

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Walkscape Runner (Dev)',
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(
          seedColor: const Color.fromARGB(255, 6, 21, 48),
        ),
        useMaterial3: true,
      ),
      home: const DevMenuPage(),
    );
  }
}


===== FILE: lib/runner.dart =====
// Public entrypoint ("barrel file") for embedding the runner in a host app.
//
// Host apps should import only this file:
// `import 'package:walkscape_runner/runner.dart';`
//
// This keeps the public API stable while allowing internal folders/files to
// evolve without breaking downstream imports.
export 'ui/runner_game_route.dart';
export 'ui/runner_game_widget.dart';


===== FILE: lib/ui/controls/fixed_joystick.dart =====
import 'package:flutter/widgets.dart';

/// Fixed-position horizontal joystick (V0).
///
/// - Only outputs an X axis in `[-1, 1]`.
/// - Centered at the widget's bounds; drag left/right to set axis.
class FixedJoystick extends StatefulWidget {
  const FixedJoystick({
    super.key,
    required this.onAxisChanged,
    this.size = 120,
    this.knobSize = 56,
  });

  final ValueChanged<double> onAxisChanged;
  final double size;
  final double knobSize;

  @override
  State<FixedJoystick> createState() => _FixedJoystickState();
}

class _FixedJoystickState extends State<FixedJoystick> {
  double _axis = 0;

  @override
  Widget build(BuildContext context) {
    final baseSize = widget.size;
    final knobSize = widget.knobSize;
    final radius = (baseSize - knobSize) / 2;

    return SizedBox(
      width: baseSize,
      height: baseSize,
      child: GestureDetector(
        onPanStart: (d) => _update(d.localPosition, radius),
        onPanUpdate: (d) => _update(d.localPosition, radius),
        onPanEnd: (_) => _setAxis(0),
        onPanCancel: () => _setAxis(0),
        child: CustomPaint(
          painter: _JoystickPainter(axis: _axis),
          child: Stack(
            children: [
              Positioned.fill(
                child: Center(
                  child: Container(
                    width: baseSize,
                    height: baseSize,
                    decoration: BoxDecoration(
                      color: const Color(0x33000000),
                      shape: BoxShape.circle,
                      border: Border.all(color: const Color(0x55FFFFFF)),
                    ),
                  ),
                ),
              ),
              Positioned.fill(
                child: Center(
                  child: Transform.translate(
                    offset: Offset(_axis * radius, 0),
                    child: Container(
                      width: knobSize,
                      height: knobSize,
                      decoration: BoxDecoration(
                        color: const Color(0x66FFFFFF),
                        shape: BoxShape.circle,
                        border: Border.all(color: const Color(0x88FFFFFF)),
                      ),
                    ),
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  void _update(Offset local, double radius) {
    final center = Offset(widget.size / 2, widget.size / 2);
    final dx = local.dx - center.dx;
    final clamped = dx.clamp(-radius, radius);
    final axis = radius <= 0 ? 0.0 : clamped / radius;
    _setAxis(axis);
  }

  void _setAxis(double axis) {
    final a = axis.clamp(-1.0, 1.0);
    if (a == _axis) return;
    setState(() => _axis = a);
    widget.onAxisChanged(a);
  }
}

class _JoystickPainter extends CustomPainter {
  const _JoystickPainter({required this.axis});

  final double axis;

  @override
  void paint(Canvas canvas, Size size) {
    // No-op; visuals are via Containers. Keep painter for future extensions.
  }

  @override
  bool shouldRepaint(covariant _JoystickPainter oldDelegate) =>
      oldDelegate.axis != axis;
}


===== FILE: lib/ui/controls/runner_controls_overlay.dart =====
import 'package:flutter/material.dart';

import 'fixed_joystick.dart';

class RunnerControlsOverlay extends StatelessWidget {
  const RunnerControlsOverlay({
    super.key,
    required this.onMoveAxis,
    required this.onJumpPressed,
    required this.onDashPressed,
    required this.onAttackPressed,
  });

  final ValueChanged<double> onMoveAxis;
  final VoidCallback onJumpPressed;
  final VoidCallback onDashPressed;
  final VoidCallback onAttackPressed;

  @override
  Widget build(BuildContext context) {
    return SafeArea(
      child: Stack(
        children: [
          Positioned(
            left: 16,
            bottom: 16,
            child: FixedJoystick(onAxisChanged: onMoveAxis),
          ),
          Positioned(
            right: 16,
            bottom: 16,
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                _ActionButton(
                  label: 'Jump',
                  icon: Icons.arrow_upward,
                  onPressed: onJumpPressed,
                ),
                const SizedBox(height: 12),
                _ActionButton(
                  label: 'Dash',
                  icon: Icons.flash_on,
                  onPressed: onDashPressed,
                ),
                const SizedBox(height: 12),
                _ActionButton(
                  label: 'Atk',
                  icon: Icons.close,
                  onPressed: onAttackPressed,
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}

class _ActionButton extends StatelessWidget {
  const _ActionButton({
    required this.label,
    required this.icon,
    required this.onPressed,
  });

  final String label;
  final IconData icon;
  final VoidCallback onPressed;

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      width: 72,
      height: 72,
      child: Material(
        color: const Color(0x33000000),
        shape: const CircleBorder(),
        child: InkWell(
          customBorder: const CircleBorder(),
          onTap: onPressed,
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(icon, color: Colors.white),
              const SizedBox(height: 2),
              Text(
                label,
                style: const TextStyle(fontSize: 12, color: Colors.white),
              ),
            ],
          ),
        ),
      ),
    );
  }
}



===== FILE: lib/ui/dev_menu_page.dart =====
import 'dart:math';

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import 'runner_game_route.dart';

/// Development-only menu used by the standalone host app (`lib/main.dart`).
///
/// Not part of the embeddable runner API. Host apps should integrate the game
/// via `RunnerGameWidget` / `createRunnerGameRoute` (see `lib/runner.dart`).
class DevMenuPage extends StatelessWidget {
  const DevMenuPage({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text(
          'Walkscape Runner (Dev)',
          style: TextStyle(color: Colors.white),
        ),
        backgroundColor: Color.fromARGB(255, 6, 21, 48),
      ),
      body: Center(
        child: FilledButton(
          onPressed: () {
            final seed = Random().nextInt(1 << 31);
            Navigator.of(context).push(
              createRunnerGameRoute(
                seed: seed,
                restoreOrientations: const [DeviceOrientation.portraitUp],
              ),
            );
          },
          child: const Text('Start'),
        ),
      ),
    );
  }
}


===== FILE: lib/ui/input/debug_keyboard_adapter.dart =====
import 'package:flutter/foundation.dart';
import 'package:flutter/services.dart';
import 'package:flutter/widgets.dart';

import '../../game/input/runner_input_router.dart';

/// Debug-only keyboard adapter (not part of V0 mobile input).
///
/// Supports BOTH:
/// - physical positions (WASD scan codes) for layout-agnostic behavior
/// - logical letters (ZQSD / WASD) for layout-friendly behavior (esp. Web/emulator quirks)
class DebugKeyboardAdapter extends StatefulWidget {
  const DebugKeyboardAdapter({
    super.key,
    required this.input,
    required this.child,
    this.enabled = kDebugMode,
  });

  final RunnerInputRouter input;
  final Widget child;
  final bool enabled;

  @override
  State<DebugKeyboardAdapter> createState() => _DebugKeyboardAdapterState();
}

class _DebugKeyboardAdapterState extends State<DebugKeyboardAdapter> {
  final FocusNode _focusNode = FocusNode(debugLabel: 'DebugKeyboardAdapter');

  final Set<PhysicalKeyboardKey> _physDown = <PhysicalKeyboardKey>{};
  final Set<LogicalKeyboardKey> _logDown = <LogicalKeyboardKey>{};

  @override
  void dispose() {
    _focusNode.dispose();
    super.dispose();
  }

  bool _isDown({
    PhysicalKeyboardKey? physical,
    LogicalKeyboardKey? logical,
    Iterable<PhysicalKeyboardKey> physicalAny = const [],
    Iterable<LogicalKeyboardKey> logicalAny = const [],
  }) {
    if (physical != null && _physDown.contains(physical)) return true;
    if (logical != null && _logDown.contains(logical)) return true;
    for (final k in physicalAny) {
      if (_physDown.contains(k)) return true;
    }
    for (final k in logicalAny) {
      if (_logDown.contains(k)) return true;
    }
    return false;
  }

  KeyEventResult _onKeyEvent(FocusNode node, KeyEvent event) {
    if (!widget.enabled) return KeyEventResult.ignored;

    if (event is KeyDownEvent) {
      _physDown.add(event.physicalKey);
      _logDown.add(event.logicalKey);

      final jumpPressed = _isDown(
        physicalAny: const [
          PhysicalKeyboardKey.space,
          PhysicalKeyboardKey.arrowUp,
          PhysicalKeyboardKey.keyW, // WASD physical position
        ],
        logicalAny: const [
          LogicalKeyboardKey.space,
          LogicalKeyboardKey.arrowUp,
          LogicalKeyboardKey.keyW, // QWERTY letter
          LogicalKeyboardKey.keyZ, // AZERTY letter
        ],
      );

      // Only fire jump on the actual KeyDown event (not every frame)
      // but ignore repeats by checking event.repeat if you want.
      if (jumpPressed) {
        widget.input.pressJump();
      }
    } else if (event is KeyUpEvent) {
      _physDown.remove(event.physicalKey);
      _logDown.remove(event.logicalKey);
    }

    final heldLeft = _isDown(
      physicalAny: const [PhysicalKeyboardKey.arrowLeft, PhysicalKeyboardKey.keyA],
      logicalAny: const [LogicalKeyboardKey.arrowLeft, LogicalKeyboardKey.keyA, LogicalKeyboardKey.keyQ],
    );

    final heldRight = _isDown(
      physicalAny: const [PhysicalKeyboardKey.arrowRight, PhysicalKeyboardKey.keyD],
      logicalAny: const [LogicalKeyboardKey.arrowRight, LogicalKeyboardKey.keyD],
    );

    if (heldLeft && !heldRight) {
      widget.input.setMoveAxis(-1);
    } else if (heldRight && !heldLeft) {
      widget.input.setMoveAxis(1);
    } else {
      widget.input.setMoveAxis(0);
    }

    return KeyEventResult.handled;
  }

  @override
  Widget build(BuildContext context) {
    if (!widget.enabled) return widget.child;

    // Crucial: clicking the game view should re-grab focus, otherwise KeyUp
    // can be missed and input feels “not continuous”.
    return Focus(
      autofocus: true,
      focusNode: _focusNode,
      onKeyEvent: _onKeyEvent,
      child: Listener(
        behavior: HitTestBehavior.translucent,
        onPointerDown: (_) => FocusScope.of(context).requestFocus(_focusNode),
        child: widget.child,
      ),
    );
  }
}


===== FILE: lib/ui/input/debug_mouse_adapter.dart =====
import 'package:flutter/foundation.dart';
import 'package:flutter/gestures.dart';
import 'package:flutter/widgets.dart';

import '../../game/game_controller.dart';
import '../../game/input/runner_input_router.dart';
import 'v0_viewport_mapper.dart';

/// Debug-only mouse adapter (not part of V0 mobile input).
///
/// - Move: updates AimDir.
/// - Left click: Attack.
/// - Middle click (or tertiary): Dash.
/// - Right click: Cast with aim.
class DebugMouseAdapter extends StatelessWidget {
  const DebugMouseAdapter({
    super.key,
    required this.controller,
    required this.input,
    required this.mapper,
    required this.child,
    this.enabled = kDebugMode,
  });

  final GameController controller;
  final RunnerInputRouter input;
  final V0ViewportMapper mapper;
  final Widget child;
  final bool enabled;

  @override
  Widget build(BuildContext context) {
    if (!enabled) return child;

    return Listener(
      behavior: HitTestBehavior.translucent,
      onPointerHover: (e) {
        if (e.kind != PointerDeviceKind.mouse) return;
        final dir = mapper.aimDirFromLocal(e.localPosition, controller.snapshot);
        if (dir == null) return;
        input.setAimDir(dir.x, dir.y);
      },
      onPointerMove: (e) {
        if (e.kind != PointerDeviceKind.mouse) return;
        final dir = mapper.aimDirFromLocal(e.localPosition, controller.snapshot);
        if (dir == null) return;
        input.setAimDir(dir.x, dir.y);
      },
      onPointerDown: (e) {
        if (e.kind != PointerDeviceKind.mouse) return;

        final dir = mapper.aimDirFromLocal(e.localPosition, controller.snapshot);
        if (dir != null) {
          input.setAimDir(dir.x, dir.y);
        }

        final b = e.buttons;

        final isDash = (b & kMiddleMouseButton) != 0 || (b & kTertiaryButton) != 0;
        final isAttack = (b & kPrimaryButton) != 0;
        final isCast = (b & kSecondaryButton) != 0;

        if (isDash) input.pressDash();
        if (isAttack) input.pressAttack();
        if (isCast) input.pressCastWithAim();
      },
      child: child,
    );
  }
}


===== FILE: lib/ui/input/touch_game_view_adapter.dart =====
import 'package:flutter/gestures.dart';
import 'package:flutter/widgets.dart';

import '../../game/game_controller.dart';
import '../../game/input/runner_input_router.dart';
import 'v0_viewport_mapper.dart';

/// Handles touch interactions on the game view (V0).
///
/// - Tap on the game view: sets aim dir (from tap position) and triggers cast.
class TouchGameViewAdapter extends StatelessWidget {
  const TouchGameViewAdapter({
    super.key,
    required this.controller,
    required this.input,
    required this.mapper,
    required this.child,
  });

  final GameController controller;
  final RunnerInputRouter input;
  final V0ViewportMapper mapper;
  final Widget child;

  @override
  Widget build(BuildContext context) {
    return Listener(
      onPointerDown: (e) {
        if (e.kind == PointerDeviceKind.mouse) return;
        final dir = mapper.aimDirFromLocal(e.localPosition, controller.snapshot);
        if (dir != null) {
          input.setAimDir(dir.x, dir.y);
          input.pressCastWithAim();
        } else {
          input.pressCast();
        }
      },
      child: child,
    );
  }
}



===== FILE: lib/ui/input/v0_viewport_mapper.dart =====
import 'dart:math' as math;

import 'package:flutter/widgets.dart';

import '../../core/contracts/v0_render_contract.dart';
import '../../core/math/vec2.dart';
import '../../core/snapshots/game_state_snapshot.dart';

/// Helper for mapping local pointer positions into V0 world-space aim direction.
///
/// This follows the pixel-perfect viewport rules (integer physical-pixel scale
/// + letterbox) so aim lines up with what the player sees.
class V0ViewportMapper {
  V0ViewportMapper._({
    required this.viewW,
    required this.viewH,
    required this.offsetX,
    required this.offsetY,
  });

  factory V0ViewportMapper.fromConstraints(
    BoxConstraints constraints, {
    required double devicePixelRatio,
  }) {
    final screenPxW = constraints.maxWidth * devicePixelRatio;
    final screenPxH = constraints.maxHeight * devicePixelRatio;
    final scaleW = (screenPxW / v0VirtualWidth).floor();
    final scaleH = (screenPxH / v0VirtualHeight).floor();
    final scale = math.max(1, math.min(scaleW, scaleH));

    final viewW = (v0VirtualWidth * scale) / devicePixelRatio;
    final viewH = (v0VirtualHeight * scale) / devicePixelRatio;
    final offsetX = (constraints.maxWidth - viewW) / 2;
    final offsetY = (constraints.maxHeight - viewH) / 2;

    return V0ViewportMapper._(
      viewW: viewW,
      viewH: viewH,
      offsetX: offsetX,
      offsetY: offsetY,
    );
  }

  final double viewW;
  final double viewH;
  final double offsetX;
  final double offsetY;

  Vec2? aimDirFromLocal(Offset localPos, GameStateSnapshot snapshot) {
    final inViewportX = localPos.dx - offsetX;
    final inViewportY = localPos.dy - offsetY;
    if (inViewportX < 0 ||
        inViewportY < 0 ||
        inViewportX > viewW ||
        inViewportY > viewH) {
      return null;
    }

    if (snapshot.entities.isEmpty) return null;
    final player = snapshot.entities.first;

    final vx = (inViewportX / viewW) * v0VirtualWidth;
    final vy = (inViewportY / viewH) * v0VirtualHeight;

    final camCenterX = player.pos.x.roundToDouble();
    final camCenterY = v0CameraFixedY.roundToDouble();

    final worldX = camCenterX - (v0VirtualWidth / 2) + vx;
    final worldY = camCenterY - (v0VirtualHeight / 2) + vy;

    final dx = worldX - player.pos.x;
    final dy = worldY - player.pos.y;
    final len = math.sqrt(dx * dx + dy * dy);
    if (len <= 1e-9) return const Vec2(0, 0);
    return Vec2(dx / len, dy / len);
  }
}



===== FILE: lib/ui/pixel_perfect_viewport.dart =====
import 'dart:math';

import 'package:flutter/widgets.dart';

/// Renders a child at an integer *physical pixel* scale of a fixed virtual size,
/// with deterministic letterboxing.
///
/// This is the Flutter-side implementation of the "pixel-perfect" viewport
/// rules from `docs/plan.md`:
/// - virtual size is fixed (e.g., 480×270)
/// - scale is an integer in physical pixels (never fractional)
/// - remaining space is letterboxed with a solid color
///
/// Use [alignment] to control where letterboxing appears (e.g.
/// `Alignment.center` for centered letterbox, `Alignment.bottomLeft` to keep
/// the bottom-left edge pinned).
///
/// Note: this only guarantees correct sizing/letterboxing. The Flame side
/// still needs a fixed-resolution viewport/camera setup to ensure world units
/// map to virtual pixels (handled in later milestones).
class PixelPerfectViewport extends StatelessWidget {
  const PixelPerfectViewport({
    super.key,
    required this.virtualWidth,
    required this.virtualHeight,
    required this.child,
    this.letterboxColor = const Color(0xFF000000),
    this.alignment = Alignment.center,
  });

  final int virtualWidth;
  final int virtualHeight;
  final Widget child;
  final Color letterboxColor;
  final AlignmentGeometry alignment;

  @override
  Widget build(BuildContext context) {
    final devicePixelRatio = MediaQuery.devicePixelRatioOf(context);

    return LayoutBuilder(
      builder: (context, constraints) {
        if (!constraints.hasBoundedWidth || !constraints.hasBoundedHeight) {
          return child;
        }

        final screenPxW = constraints.maxWidth * devicePixelRatio;
        final screenPxH = constraints.maxHeight * devicePixelRatio;

        final scale = max(1, _computeLetterboxScale(screenPxW, screenPxH));

        final renderLogicalW = (virtualWidth * scale) / devicePixelRatio;
        final renderLogicalH = (virtualHeight * scale) / devicePixelRatio;

        final sizedChild = SizedBox(
          width: renderLogicalW,
          height: renderLogicalH,
          child: child,
        );

        return ColoredBox(
          color: letterboxColor,
          child: ClipRect(
            child: SizedBox.expand(
              child: Align(alignment: alignment, child: sizedChild),
            ),
          ),
        );
      },
    );
  }

  int _computeLetterboxScale(double screenPxW, double screenPxH) {
    final scaleW = screenPxW / virtualWidth;
    final scaleH = screenPxH / virtualHeight;
    return min(scaleW.floor(), scaleH.floor());
  }
}


===== FILE: lib/ui/README.md =====
# UI (Flutter)

Flutter UI layer (menus, overlays, input widgets).

- Sends high-level commands to the `GameController`
- Must not mutate core gameplay state directly



===== FILE: lib/ui/runner_game_route.dart =====
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import 'runner_game_widget.dart';
import 'scoped_preferred_orientations.dart';

/// Embed-friendly route factory for hosting the mini-game in any Flutter app.
///
/// Host apps can `Navigator.push(createRunnerGameRoute(...))` without depending
/// on this package's development host app (`lib/main.dart`).
///
Route<void> createRunnerGameRoute({
  int seed = 1,
  bool lockLandscape = true,
  List<DeviceOrientation>? restoreOrientations,
}) {
  return MaterialPageRoute<void>(
    builder: (context) {
      Widget child = RunnerGameWidget(
        seed: seed,
        onExit: () => Navigator.of(context).maybePop(),
        enableDebugInput: true,
      );

      if (lockLandscape) {
        child = ScopedPreferredOrientations(
          preferredOrientations: const [
            DeviceOrientation.landscapeLeft,
            DeviceOrientation.landscapeRight,
          ],
          restoreOrientations: restoreOrientations,
          child: child,
        );
      }

      return Scaffold(body: child);
    },
  );
}


===== FILE: lib/ui/runner_game_widget.dart =====
import 'package:flame/game.dart';
import 'package:flutter/material.dart';

import '../core/contracts/v0_render_contract.dart';
import '../core/game_core.dart';
import '../game/game_controller.dart';
import '../game/input/runner_input_router.dart';
import '../game/runner_flame_game.dart';
import 'controls/runner_controls_overlay.dart';
import 'input/debug_keyboard_adapter.dart';
import 'input/debug_mouse_adapter.dart';
import 'pixel_perfect_viewport.dart';
import 'input/touch_game_view_adapter.dart';
import 'input/v0_viewport_mapper.dart';

/// Embed-friendly widget that hosts the mini-game.
///
/// Intended to be mounted by a host app. It owns its [GameController] and
/// cleans it up on dispose.
///
/// Pixel scaling is applied by [PixelPerfectViewport] to keep the fixed virtual
/// resolution letterboxed to the available screen.
class RunnerGameWidget extends StatefulWidget {
  const RunnerGameWidget({
    super.key,
    this.seed = 1,
    this.onExit,
    this.showExitButton = true,
    this.enableDebugInput = false,
  });

  final int seed;

  final VoidCallback? onExit;
  final bool showExitButton;
  final bool enableDebugInput;

  @override
  State<RunnerGameWidget> createState() => _RunnerGameWidgetState();
}

class _RunnerGameWidgetState extends State<RunnerGameWidget>
    with WidgetsBindingObserver {
  bool _pausedByLifecycle = false;

  late final GameController _controller = GameController(
    core: GameCore(seed: widget.seed),
  );
  late final RunnerInputRouter _input =
      RunnerInputRouter(controller: _controller);
  late final RunnerFlameGame _game = RunnerFlameGame(
    controller: _controller,
    input: _input,
  );

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) =>
      _onLifecycle(state);

  void _onLifecycle(AppLifecycleState state) {
    if (state == AppLifecycleState.resumed) {
      if (_pausedByLifecycle) {
        _pausedByLifecycle = false;
        _controller.setPaused(false);
      }
      return;
    }
    _pausedByLifecycle = true;
    _controller.setPaused(true);
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    _controller.shutdown();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Stack(
      fit: StackFit.expand,
      children: [
        LayoutBuilder(
          builder: (context, constraints) {
            final mapper = V0ViewportMapper.fromConstraints(
              constraints,
              devicePixelRatio: MediaQuery.devicePixelRatioOf(context),
            );

            Widget gameView = PixelPerfectViewport(
              virtualWidth: v0VirtualWidth,
              virtualHeight: v0VirtualHeight,
              child: GameWidget(game: _game, autofocus: false),
            );

            gameView = TouchGameViewAdapter(
              controller: _controller,
              input: _input,
              mapper: mapper,
              child: gameView,
            );

            if (widget.enableDebugInput) {
              gameView = DebugMouseAdapter(
                controller: _controller,
                input: _input,
                mapper: mapper,
                child: gameView,
              );
              gameView = DebugKeyboardAdapter(input: _input, child: gameView);
            }

            return gameView;
          },
        ),
        RunnerControlsOverlay(
          onMoveAxis: _input.setMoveAxis,
          onJumpPressed: _input.pressJump,
          onDashPressed: _input.pressDash,
          onAttackPressed: _input.pressAttack,
        ),
        if (widget.showExitButton)
          Positioned(
            top: 8,
            left: 8,
            child: SafeArea(
              child: IconButton(
                onPressed: widget.onExit,
                icon: const Icon(Icons.close),
              ),
            ),
          ),
      ],
    );
  }
}


===== FILE: lib/ui/scoped_preferred_orientations.dart =====
import 'package:flutter/foundation.dart';
import 'package:flutter/services.dart';
import 'package:flutter/widgets.dart';

/// Applies `SystemChrome.setPreferredOrientations` while this widget is mounted.
///
/// This is intentionally scoped to a subtree (typically a route) so the runner
/// can be embedded in a host app without enforcing a global orientation policy.
///
/// Notes:
/// - Flutter does not expose the *previous* preferred orientations, so the
///   caller must decide what to restore on dispose.
/// - Platform-level orientation support (Android manifest / iOS Info.plist)
///   still needs to include the requested orientations.
class ScopedPreferredOrientations extends StatefulWidget {
  const ScopedPreferredOrientations({
    super.key,
    required this.preferredOrientations,
    required this.child,
    this.restoreOrientations,
  });

  final List<DeviceOrientation> preferredOrientations;
  final List<DeviceOrientation>? restoreOrientations;
  final Widget child;

  @override
  State<ScopedPreferredOrientations> createState() =>
      _ScopedPreferredOrientationsState();
}

class _ScopedPreferredOrientationsState
    extends State<ScopedPreferredOrientations> {
  @override
  void initState() {
    super.initState();
    SystemChrome.setPreferredOrientations(widget.preferredOrientations);
  }

  @override
  void didUpdateWidget(covariant ScopedPreferredOrientations oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (!listEquals(
      oldWidget.preferredOrientations,
      widget.preferredOrientations,
    )) {
      SystemChrome.setPreferredOrientations(widget.preferredOrientations);
    }
  }

  @override
  void dispose() {
    final restore = widget.restoreOrientations;
    if (restore != null) {
      SystemChrome.setPreferredOrientations(restore);
    }
    super.dispose();
  }

  @override
  Widget build(BuildContext context) => widget.child;
}

