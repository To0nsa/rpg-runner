REPO: C:\dev\walkscape_runner
COMMIT: e381bbedc30da5478c57205bab643dde1610e2af
DATE: 2026-01-07 12:31:15


===== FILE: lib/AGENTS.md =====
# AGENTS.md

Instructions for AI coding agents (Codex, ChatGPT, etc.) when working in this repo.

## Project mission

Port an existing **SFML/C++ 2D runner** (tools\output\c++implementation.txt)into **Flutter (Dart) + Flame** while preserving gameplay feel and making the result **production-grade** (mobile performance, clean architecture, future online-ready).

## Working style (how to collaborate)

## Consent before changing code

When the user asks a question (e.g. “how do I…?”, “why…?”, “is it possible…?”) or explicitly says “no code / just answer”:

- **Do not make code changes or run refactors.** Provide an answer with options/tradeoffs only.
- If implementation would help, **ask for confirmation first** (e.g. “Want me to implement option A?”) before editing files.

Only implement changes when the user clearly requests it (e.g. “please implement”, “make the change”, “can you do X in the repo?”).

For any non-trivial task (anything that affects architecture, touches multiple layers/files, introduces a new subsystem, or changes a core contract):

- Brainstorm 1-3 viable approaches (with tradeoffs) before coding.
- Check whether a good solution already exists (repo patterns, Flame APIs, well-maintained packages) and prefer it when it fits the goals.
- Write a short plan (steps + acceptance criteria) and align on it before implementing.
- Ask clarifying questions when requirements are underspecified or multiple designs are plausible.

For trivial/surgical changes (tiny refactors, obvious bug fixes), proceed directly but keep changes minimal and consistent with existing patterns.

## Non-negotiable architecture

This project has **three hard layers**:

1. **Core (pure Dart simulation)**: deterministic gameplay + physics + AI + RNG
2. **Render (Flame)**: visuals only (sprites/animations/camera/parallax/VFX)
3. **UI (Flutter)**: menus, overlays, navigation, settings

Rules:

- **Core must not import Flutter or Flame.**
- Flame must not be authoritative for gameplay/collision.
- UI must not modify gameplay state directly; it sends **Commands** to the controller.
- The game must be embeddable: expose a reusable widget/route entrypoint; keep `lib/main.dart` as a dev host/demo only.

## Prefer existing solutions (when they fit the goals)

Before building something custom, check if a better solution already exists:

- In this repo (search for an existing pattern/component first)
- In Flame APIs (camera, viewport, parallax, input, effects)
- In well-maintained Dart/Flutter packages

Rule of thumb:

- Prefer Flame for *render concerns* (camera components, parallax rendering, effects).
- Prefer UI (Flutter) for *UI/input widgets* (joystick/buttons/menus/overlays).
- Prefer Core for *authoritative gameplay concerns* (movement/physics/collision, ability timing, damage rules), especially when determinism/networking is a goal.

## Determinism contract

- Simulation runs in **fixed ticks** (e.g. 60 Hz). Ticks are the only time authority.
- Inputs are **Commands** queued for a specific tick.
- RNG is seeded and owned by the Core. No wall-clock randomness.
- On app resume, clamp frame dt and **never** try to "catch up" thousands of ticks.

## Core data model

### Entity storage

- Use **SoA + SparseSet** per component type.
- Entity IDs are monotonic and **never reused**.

Iteration rules:

- Systems iterate via queries (no direct sparse/dense fiddling).
- Do not add/remove components or destroy entities mid-iteration. Queue structural changes and apply after system execution.
- Do not keep references to dense arrays across ticks.

### Snapshots & events

Core outputs:

- Immutable `GameStateSnapshot` for render/UI (serializable, renderer-friendly).
- Transient `GameEvent`s (spawn/despawn/hit/sfx/screenshake/reward, etc.).

Renderer/UI must:

- Treat snapshots as read-only.
- Interpolate visuals using (`prevSnapshot`, `currSnapshot`, `alpha`) but **never simulate**.

## World / camera / pixel-art rules

- Pick one **virtual resolution** (world units == virtual pixels).
- Use **integer scaling + letterboxing**. No fractional scaling, no shimmering.
- Snap camera + render positions to integer pixels inside the scaled viewport.

## Asset rules

- Assets are loaded **per scene**, not at boot.
- No asset loading during active gameplay.
- Unload game assets when leaving the mini-game route.

## Implementation sequencing

Follow the V0 plan (small, testable increments):

1. Scaffold + wiring (`lib/core`, `lib/game`, `lib/ui`)
2. Camera/viewport/parallax
3. Core collision + player run/jump
4. Mobile controls
5. Abilities/resources
6. Enemies (simple AI)
7. Deterministic spawning

If you deviate, explain why and keep the same boundaries.

## Code quality rules (Dart/Flutter)

- Keep the codebase modular and scalable:
  - prefer small, cohesive modules with clear boundaries
  - avoid tight coupling across Core/Render/UI; depend on stable contracts instead
  - keep public embedding API stable (`lib/runner.dart`), treat internal folders as refactorable
- Keep responsibilities narrow; avoid "god" classes that mix input/sim/render.
- Prefer explicit data flow: Commands in, snapshots/events out.
- Keep Core allocation-light: avoid per-tick new Lists/Maps in hot loops.
- Prefer `final`, `const`, and value types for small structs (e.g. `Vec2`).
- No `dynamic` in gameplay code (prefer typed payloads; if a temporary map is unavoidable, confine it to UI/debug only).
- Make side effects explicit: Core returns events; render/UI consume them.
- Keep changes consistent with existing style; avoid renames/reformatting unrelated code.
- Add/extend tests when relevant (especially when new behavior is introduced or existing behavior changes):
  - Core behavior: unit tests in `test/core/**` (`dart test`)
  - UI/viewport/widget behavior: widget tests where appropriate
- Keep docs in sync with code: update relevant docs whenever behavior, contracts, milestones, or public APIs change.

## What an agent must do on each task

When asked to implement/fix something:

1. Identify which layer it belongs to (Core vs Render vs UI).
2. Check for an existing solution/pattern that already fits the goal (repo + Flame + packages).
3. Propose a minimal plan (1-3 steps) and acceptance criteria.
4. Implement with deterministic rules intact.
5. Update docs/comments whenever a change affects behavior, contracts, milestones, or usage:
   - update `docs/plan.md` if architecture rules/contracts change
   - update `docs/v0-implementation-plan.md` if milestone checklist changes
   - update top-of-file docs and public API docs (`lib/runner.dart`, route/widget docs) when embedding/API expectations change
6. Add/extend relevant tests when new behavior is introduced or existing behavior changes (especially Core determinism and systems).
7. Provide:
   - files changed + why
   - how to run/verify (build + quick sanity checks)
   - follow-ups (next incremental step)

## What NOT to do

- Don't add Flutter/Flame imports into `lib/core/**`.
- Don't use Flame collision callbacks as gameplay truth.
- Don't introduce wall-clock timing in simulation (no `DateTime.now()`, no frame-dt gameplay).
- Don't "just make it work" by mixing UI/render/core responsibilities.

## Suggested folder layout

- `lib/core/`    - simulation, components, systems, RNG, commands, snapshots
- `lib/game/`    - Flame `Game`, entity view components, camera/parallax, render adapters
- `lib/ui/`      - menus, overlays, UI state, input widgets
- `test/`        - Core unit tests

---
If anything here conflicts with repo docs, treat repo docs as the source of truth.


===== FILE: lib/core/camera/autoscroll_camera.dart =====
import '../util/smoothing.dart';
import '../util/double_math.dart';
import '../tuning/camera_tuning.dart';

class CameraState {
  const CameraState({
    required this.centerX,
    required this.targetX,
    required this.speedX,
  });

  /// Current visual center X of the camera view.
  final double centerX;

  /// The "ideal" center position the camera is trying to reach.
  /// This leads [centerX] and pulls it forward via smoothing.
  final double targetX;

  /// Current scroll speed (pixels/second).
  final double speedX;

  /// Creates a copy with updated fields.
  CameraState copyWith({
    double? centerX,
    double? targetX,
    double? speedX,
  }) {
    return CameraState(
      centerX: centerX ?? this.centerX,
      targetX: targetX ?? this.targetX,
      speedX: speedX ?? this.speedX,
    );
  }
}

/// Deterministic auto-scroll camera (Core).
///
/// Mirrors the reference behavior:
/// - baseline target speed with ease-in acceleration
/// - camera center eases toward a monotonic target X (never moves backward)
/// - player can pull the target forward only after passing a follow threshold
class AutoscrollCamera {
  AutoscrollCamera({
    required this.viewWidth,
    required CameraTuningDerived tuning,
    required CameraState initial,
  })  : _tuning = tuning,
        _state = initial;

  final double viewWidth;
  final CameraTuningDerived _tuning;

  CameraState get state => _state;
  CameraState _state;

  double left() => _state.centerX - viewWidth * 0.5;
  double right() => _state.centerX + viewWidth * 0.5;

  /// The X coordinate where the player starts pushing the camera forward.
  ///
  /// Calculated as a ratio of the viewport width from the left edge.
  double followThresholdX() => left() + _tuning.followThresholdRatio * viewWidth;

  /// Advances camera simulation by [dtSeconds].
  ///
  /// [playerX] is nullable to handle cases where the player is dead or despawned.
  void updateTick({
    required double dtSeconds,
    required double? playerX,
  }) {
    final t = _tuning;

    // 1. Update base scroll speed (accelerate/decelerate towards target speed).
    var speedX = _state.speedX;
    if (speedX < t.targetSpeedX) {
      speedX = clampDouble(speedX + t.accelX * dtSeconds, 0.0, t.targetSpeedX);
    } else if (speedX > t.targetSpeedX) {
      speedX = clampDouble(speedX - t.accelX * dtSeconds, t.targetSpeedX, speedX);
    }

    // 2. Integrate target position based on speed.
    var targetX = _state.targetX + speedX * dtSeconds;

    // 3. Player catch-up logic.
    // If the player pushes past the threshold, the target point is pulled forward.
    // This allows the player to run faster than the scroll speed without staying
    // pinned to the edge (camera speeds up to catch them).
    if (playerX != null) {
      final threshold = followThresholdX();
      if (playerX > threshold) {
        final alphaT = expSmoothingFactor(t.targetCatchupLerp, dtSeconds);
        final newTarget = targetX + (playerX - targetX) * alphaT;
        targetX = targetX > newTarget ? targetX : newTarget;
      }
    }

    // 4. Smooth the actual camera center towards the target.
    final alpha = expSmoothingFactor(t.catchupLerp, dtSeconds);
    var centerX = _state.centerX + (targetX - _state.centerX) * alpha;

    // 5. Monotonicity clamp: the camera is an auto-scroller, it never goes left.
    if (centerX < _state.centerX) centerX = _state.centerX;
    if (targetX < _state.targetX) targetX = _state.targetX;

    _state = _state.copyWith(centerX: centerX, targetX: targetX, speedX: speedX);
  }
}


===== FILE: lib/core/collision/static_world_geometry.dart =====
/// Static collision geometry owned by the Core simulation.
///
/// Starts with a set of base geometry (ground band), and extended with
/// deterministic chunk spawning.
class StaticGroundPlane {
  const StaticGroundPlane({required this.topY});

  /// World-space Y coordinate of the ground surface (solid top).
  final double topY;
}

/// A "hole" in the infinite ground plane where the player can fall through.
///
/// Use this to create pits or interruptions in the otherwise continuous ground.
class StaticGroundGap {
  const StaticGroundGap({required this.minX, required this.maxX})
    : assert(maxX >= minX);

  /// Start X coordinate of the gap (inclusive start of hole).
  final double minX;

  /// End X coordinate of the gap (inclusive end of hole).
  final double maxX;
}

/// A pre-computed walkable 1D segment for faster collision and navigation.
///
/// These are typically generated from the [StaticGroundPlane] minus any
/// [StaticGroundGap]s.
class StaticGroundSegment {
  const StaticGroundSegment({
    required this.minX,
    required this.maxX,
    required this.topY,
    this.chunkIndex = StaticSolid.groundChunk,
    this.localSegmentIndex = -1,
  }) : assert(maxX >= minX);

  /// Start X coordinate of the walkable surface.
  final double minX;

  /// End X coordinate of the walkable surface.
  final double maxX;

  /// Y coordinate of the surface (constant height).
  final double topY;

  /// Chunk index this segment was generated from, or [StaticSolid.groundChunk].
  final int chunkIndex;

  /// Stable local index within the chunk pattern authoring list.
  final int localSegmentIndex;
}

/// A generic AABB obstacle or platform in the world.
///
/// Can represent solid blocks, walls, floating platforms (one-way), or ceilings.
class StaticSolid {
  const StaticSolid({
    required this.minX,
    required this.minY,
    required this.maxX,
    required this.maxY,
    this.sides = sideTop,
    this.oneWayTop = true,
    this.chunkIndex = noChunk,
    this.localSolidIndex = -1,
  }) : assert(maxX >= minX),
       assert(maxY >= minY);

  /// Left edge world coordinate.
  final double minX;

  /// Bottom edge world coordinate.
  final double minY;

  /// Right edge world coordinate.
  final double maxX;

  /// Top edge world coordinate.
  final double maxY;

  /// Which faces of this solid participate in collision resolution.
  ///
  /// - one-way platforms typically use `sideTop` only
  /// - obstacles typically use `sideAll`
  final int sides;

  /// If true, the top surface only collides while falling (platform behavior).
  ///
  /// This only applies when [sides] includes [sideTop].
  final bool oneWayTop;

  /// Chunk index this solid was generated from (streaming), or [noChunk] for
  /// base/static geometry.
  final int chunkIndex;

  /// Stable local index within the chunk pattern authoring list.
  ///
  /// If negative, callers should derive a stable index from the owning list.
  final int localSolidIndex;

  /// Collision side flags.
  static const int sideNone = 0;
  static const int sideTop = 1 << 0;
  static const int sideBottom = 1 << 1;
  static const int sideLeft = 1 << 2;
  static const int sideRight = 1 << 3;
  static const int sideAll = sideTop | sideBottom | sideLeft | sideRight;

  /// Sentinel for solids not tied to a streamed chunk.
  static const int noChunk = -2;

  /// Reserved chunk index for always-on surfaces (e.g. ground plane).
  static const int groundChunk = -1;
}

/// Immutable bundle of static solids for a run/session.
class StaticWorldGeometry {
  const StaticWorldGeometry({
    this.groundPlane,
    this.groundSegments = const <StaticGroundSegment>[],
    this.solids = const <StaticSolid>[],
    this.groundGaps = const <StaticGroundGap>[],
  });

  /// Optional infinite ground plane (top surface only).
  final StaticGroundPlane? groundPlane;

  /// Walkable ground segments (used for collision + navigation).
  final List<StaticGroundSegment> groundSegments;

  /// Arbitrary static solids (platforms, walls, blocks).
  final List<StaticSolid> solids;

  /// Holes in the ground plane (world-space X ranges).
  final List<StaticGroundGap> groundGaps;
}


===== FILE: lib/core/collision/static_world_geometry_index.dart =====
import 'static_world_geometry.dart';
export 'static_world_geometry.dart';

/// Pre-indexed view of static world geometry for faster collision queries.
///
/// This is constructed once (per run/session) and preserves the original solid
/// ordering in each face list to keep behavior deterministic.
class StaticWorldGeometryIndex {
  StaticWorldGeometryIndex._({
    required this.geometry,
    required this.groundPlane,
    required this.groundSegments,
    required this.groundGaps,
    required List<StaticSolid> tops,
    required List<StaticSolid> bottoms,
    required List<StaticSolid> leftWalls,
    required List<StaticSolid> rightWalls,
    required double maxTopWidth,
    required double maxBottomWidth,
    required double maxLeftWidth,
    required double maxRightWidth,
  })  : _tops = tops,
        _bottoms = bottoms,
        _leftWalls = leftWalls,
        _rightWalls = rightWalls,
        _maxTopWidth = maxTopWidth,
        _maxBottomWidth = maxBottomWidth,
        _maxLeftWidth = maxLeftWidth,
        _maxRightWidth = maxRightWidth;

  /// Creates a spatial index from the raw static geometry.
  ///
  /// This process involves:
  /// 1. Categorizing solids by their active sides (top, bottom, left, right).
  /// 2. Sorting each list by [minX] to enable binary search.
  /// 3. Computing max widths for each list to optimize overlap queries.
  /// 4. Merging the ground plane and gaps into a unified list of walkable segments.
  factory StaticWorldGeometryIndex.from(StaticWorldGeometry geometry) {
    final tops = <StaticSolid>[];
    final bottoms = <StaticSolid>[];
    final leftWalls = <StaticSolid>[];
    final rightWalls = <StaticSolid>[];

    for (final solid in geometry.solids) {
      final sides = solid.sides;
      if ((sides & StaticSolid.sideTop) != 0) tops.add(solid);
      if ((sides & StaticSolid.sideBottom) != 0) bottoms.add(solid);
      if ((sides & StaticSolid.sideLeft) != 0) leftWalls.add(solid);
      if ((sides & StaticSolid.sideRight) != 0) rightWalls.add(solid);
    }

    // Sort for binary search.
    _sortByMinX(tops);
    _sortByMinX(bottoms);
    _sortByMinX(leftWalls);
    _sortByMinX(rightWalls);

    final groundSegments = _buildGroundSegments(geometry);
    // Ground segments are already sorted by _buildGroundSegments.

    final groundGaps = geometry.groundGaps.isEmpty
        ? const <StaticGroundGap>[]
        : List<StaticGroundGap>.unmodifiable(
            List<StaticGroundGap>.from(geometry.groundGaps),
          );

    return StaticWorldGeometryIndex._(
      geometry: geometry,
      groundPlane: geometry.groundPlane,
      groundSegments: groundSegments,
      groundGaps: groundGaps,
      tops: List<StaticSolid>.unmodifiable(tops),
      bottoms: List<StaticSolid>.unmodifiable(bottoms),
      leftWalls: List<StaticSolid>.unmodifiable(leftWalls),
      rightWalls: List<StaticSolid>.unmodifiable(rightWalls),
      maxTopWidth: _computeMaxWidth(tops),
      maxBottomWidth: _computeMaxWidth(bottoms),
      maxLeftWidth: _computeMaxWidth(leftWalls),
      maxRightWidth: _computeMaxWidth(rightWalls),
    );
  }

  /// Source geometry (unchanged).
  final StaticWorldGeometry geometry;

  /// Optional infinite ground plane.
  final StaticGroundPlane? groundPlane;

  /// Walkable ground segments (used for collision + navigation).
  final List<StaticGroundSegment> groundSegments;

  /// Ground gaps (holes in the ground plane).
  final List<StaticGroundGap> groundGaps;

  /// Solids with an enabled top face.
  final List<StaticSolid> _tops;

  /// Solids with an enabled bottom face (ceilings).
  final List<StaticSolid> _bottoms;

  /// Solids with an enabled left face (walls hit when moving right).
  final List<StaticSolid> _leftWalls;

  /// Solids with an enabled right face (walls hit when moving left).
  final List<StaticSolid> _rightWalls;

  final double _maxTopWidth;
  final double _maxBottomWidth;
  final double _maxLeftWidth;
  final double _maxRightWidth;

  /// Fills [out] with solids overlapping the range [minX, maxX].
  ///
  /// Uses binary search to find potential candidates in O(log N) time.
  void queryTops(double minX, double maxX, List<StaticSolid> out) {
    _query(_tops, minX, maxX, _maxTopWidth, out);
  }

  /// Fills [out] with solids overlapping the range [minX, maxX].
  ///
  /// Uses binary search to find potential candidates in O(log N) time.
  void queryBottoms(double minX, double maxX, List<StaticSolid> out) {
    _query(_bottoms, minX, maxX, _maxBottomWidth, out);
  }

  /// Fills [out] with solids overlapping the range [minX, maxX].
  ///
  /// Uses binary search to find potential candidates in O(log N) time.
  void queryLeftWalls(double minX, double maxX, List<StaticSolid> out) {
    _query(_leftWalls, minX, maxX, _maxLeftWidth, out);
  }

  /// Fills [out] with solids overlapping the range [minX, maxX].
  ///
  /// Uses binary search to find potential candidates in O(log N) time.
  void queryRightWalls(double minX, double maxX, List<StaticSolid> out) {
    _query(_rightWalls, minX, maxX, _maxRightWidth, out);
  }

  /// Fills [out] with ground segments overlapping the range [minX, maxX].
  ///
  /// Ground segments are guaranteed to be sorted and disjoint, allowing efficient
  /// traversal.
  void queryGroundSegments(double minX, double maxX, List<StaticGroundSegment> out) {
    final start = _lowerBoundSegments(groundSegments, minX);
    for (var i = start; i < groundSegments.length; i += 1) {
      final seg = groundSegments[i];
      if (seg.minX >= maxX) break;
      if (seg.maxX > minX) {
        out.add(seg);
      }
    }
  }

  /// Internal helper to query a sorted list of solids.
  ///
  /// [maxWidth] is used to determine the search window. Since the list is sorted
  /// by [minX], a solid can only overlap if its [minX] is within [maxWidth] of
  /// the query's [minX].
  static void _query(
    List<StaticSolid> list,
    double minX,
    double maxX,
    double maxWidth,
    List<StaticSolid> out,
  ) {
    final lowerBoundX = minX - maxWidth;
    final start = _lowerBound(list, lowerBoundX);

    for (var i = start; i < list.length; i += 1) {
      final s = list[i];
      if (s.minX >= maxX) break;
      if (s.maxX > minX) {
        out.add(s);
      }
    }
  }
}

void _sortByMinX(List<StaticSolid> list) {
  list.sort((a, b) => a.minX.compareTo(b.minX));
}

double _computeMaxWidth(List<StaticSolid> list) {
  var maxW = 0.0;
  for (final s in list) {
    final w = s.maxX - s.minX;
    if (w > maxW) maxW = w;
  }
  return maxW;
}

/// Standard binary search (lower bound) for `List<StaticSolid>`.
/// Returns the first index where `list[i].minX >= xValue`.
int _lowerBound(List<StaticSolid> list, double xValue) {
  var min = 0;
  var max = list.length;
  while (min < max) {
    final mid = min + ((max - min) >> 1);
    final element = list[mid];
    if (element.minX < xValue) {
      min = mid + 1;
    } else {
      max = mid;
    }
  }
  return min;
}

/// Specialized search for ground segments.
/// Returns the first index where `list[i].maxX > xValue`.
/// Since ground segments are disjoint, finding where they end relative to the
/// query start is a good entry point.
int _lowerBoundSegments(List<StaticGroundSegment> list, double xValue) {
  var min = 0;
  var max = list.length;
  while (min < max) {
    final mid = min + ((max - min) >> 1);
    if (list[mid].maxX <= xValue) {
      min = mid + 1;
    } else {
      max = mid;
    }
  }
  return min;
}

/// Helper to unify the ground plane and gaps into a single sorted list of
/// walkable segments.
List<StaticGroundSegment> _buildGroundSegments(StaticWorldGeometry geometry) {
  // If segments are already provided (e.g. from a chunk generator), use them.
  if (geometry.groundSegments.isNotEmpty) {
    return List<StaticGroundSegment>.unmodifiable(geometry.groundSegments);
  }

  // If no ground plane exists, there are no segments (void world).
  final groundPlane = geometry.groundPlane;
  if (groundPlane == null) {
    return const <StaticGroundSegment>[];
  }

  // If there are no gaps, the ground is a single infinite plane.
  if (geometry.groundGaps.isEmpty) {
    return List<StaticGroundSegment>.unmodifiable(<StaticGroundSegment>[
      StaticGroundSegment(
        minX: double.negativeInfinity,
        maxX: double.infinity,
        topY: groundPlane.topY,
        chunkIndex: StaticSolid.groundChunk,
        localSegmentIndex: 0,
      ),
    ]);
  }

  // 1. Sort gaps by minX to process them in order.
  final gaps = List<StaticGroundGap>.from(geometry.groundGaps)
    ..sort((a, b) => a.minX.compareTo(b.minX));

  // 2. Merge overlapping or adjacent gaps into fewer, larger gaps.
  final merged = <StaticGroundGap>[];
  for (final gap in gaps) {
    if (merged.isEmpty) {
      merged.add(gap);
      continue;
    }
    final last = merged.last;
    if (gap.minX <= last.maxX) {
      // Overlapping or touching gap. Extend the last gap if needed.
      if (gap.maxX > last.maxX) {
        merged[merged.length - 1] =
            StaticGroundGap(minX: last.minX, maxX: gap.maxX);
      }
    } else {
      // Disjoint gap.
      merged.add(gap);
    }
  }

  // 3. Create segments strictly *between* the merged gaps.
  final segments = <StaticGroundSegment>[];
  var cursor = double.negativeInfinity;
  var localIndex = 0;
  for (final gap in merged) {
    // If there is space between the current cursor (end of last gap) and
    // the start of this gap, create a segment.
    if (gap.minX > cursor) {
      segments.add(
        StaticGroundSegment(
          minX: cursor,
          maxX: gap.minX,
          topY: groundPlane.topY,
          chunkIndex: StaticSolid.groundChunk,
          localSegmentIndex: localIndex,
        ),
      );
      localIndex += 1;
    }
    // Move cursor to the end of this gap.
    cursor = gap.maxX > cursor ? gap.maxX : cursor;
  }

  // 4. Create the final segment from the last gap to infinity.
  if (cursor < double.infinity) {
    segments.add(
      StaticGroundSegment(
        minX: cursor,
        maxX: double.infinity,
        topY: groundPlane.topY,
        chunkIndex: StaticSolid.groundChunk,
        localSegmentIndex: localIndex,
      ),
    );
  }

  return List<StaticGroundSegment>.unmodifiable(segments);
}


===== FILE: lib/core/combat/damage.dart =====
import '../ecs/entity_id.dart';
import '../enemies/enemy_id.dart';
import '../events/game_event.dart';
import '../projectiles/projectile_id.dart';
import '../spells/spell_id.dart';

/// Represents a request to apply damage to an entity.
///
/// This structure captures the target, the amount of damage, and comprehensive
/// metadata about the source of the damage (entity, enemy type, projectile, spell)
/// to be used for combat logic, death events, and statistics.
class DamageRequest {
  const DamageRequest({
    required this.target,
    required this.amount,
    this.source,
    this.sourceKind = DeathSourceKind.unknown,
    this.sourceEnemyId,
    this.sourceProjectileId,
    this.sourceSpellId,
  });

  /// The entity receiving the damage.
  final EntityId target;

  /// The amount of health points to deduct.
  final double amount;

  /// The optional entity responsible for dealing the damage (e.g. the shooter).
  final EntityId? source;

  /// Categorization of the damage source for death messages or analytics.
  final DeathSourceKind sourceKind;

  /// If the dissolved source was an enemy, its static ID.
  final EnemyId? sourceEnemyId;

  /// If the damage came from a projectile, its static ID.
  final ProjectileId? sourceProjectileId;

  /// If the damage came from a spell, its static ID.
  final SpellId? sourceSpellId;
}


===== FILE: lib/core/combat/faction.dart =====
/// Defines the side an entity belongs to in combat.
///
/// Factions determine friend-or-foe relationships for targeting and collision.
enum Faction {
  /// The player and their allies/summons.
  player,

  /// Hostile entities that attack the player.
  enemy
}



===== FILE: lib/core/commands/command.dart =====
/// Core input command model for the deterministic simulation.
///
/// Commands represent discrete user inputs scheduled for a specific simulation tick.
/// To ensure determinism, the UI must schedule commands in advance (via `GameController.enqueue`),
/// and the Core processes them only when the simulation clock reaches the specified [tick].
sealed class Command {
  const Command({required this.tick});

  /// Simulation tick at which this command must be applied.
  final int tick;
}

/// Player movement input for the given tick.
///
/// `axis` is typically in `[-1, 1]` (left/right), originating from a joystick.
final class MoveAxisCommand extends Command {
  const MoveAxisCommand({required super.tick, required this.axis});

  /// Horizontal movement axis, usually in `[-1, 1]`.
  final double axis;
}

/// One-shot jump press event for the given tick.
final class JumpPressedCommand extends Command {
  const JumpPressedCommand({required super.tick});
}

/// One-shot dash press event for the given tick.
final class DashPressedCommand extends Command {
  const DashPressedCommand({required super.tick});
}

/// One-shot attack press event for the given tick.
final class AttackPressedCommand extends Command {
  const AttackPressedCommand({required super.tick});
}

/// Continuous projectile aim direction for the given tick.
///
/// The direction should be normalized (or near-normalized). It is expressed in
/// world space and used by casting/abilities.
final class ProjectileAimDirCommand extends Command {
  const ProjectileAimDirCommand({required super.tick, required this.x, required this.y});

  final double x;
  final double y;
}

/// Continuous melee aim direction for the given tick.
///
/// The direction should be normalized (or near-normalized). It is expressed in
/// world space and used by melee attacks.
final class MeleeAimDirCommand extends Command {
  const MeleeAimDirCommand({
    required super.tick,
    required this.x,
    required this.y,
  });

  final double x;
  final double y;
}

/// Clears any held projectile aim direction for the given tick.
///
/// This exists so input schedulers that pre-buffer future ticks can overwrite
/// previously-scheduled aim commands when the player releases aim input.
final class ClearProjectileAimDirCommand extends Command {
  const ClearProjectileAimDirCommand({required super.tick});
}

/// Clears any held melee aim direction for the given tick.
final class ClearMeleeAimDirCommand extends Command {
  const ClearMeleeAimDirCommand({required super.tick});
}

/// One-shot cast press event for the given tick.
final class CastPressedCommand extends Command {
  const CastPressedCommand({required super.tick});
}


===== FILE: lib/core/contracts/render_contract.dart =====
/// Defines the virtual resolution and coordinate system constants for the valid
/// gameplay area.
///
/// These values are the "truth" for the simulation and the renderer.
/// The renderer scales this virtual viewport to fit the actual screen.
library;

/// The fixed virtual width of the gameplay view in logic units (pixels).
const int virtualWidth = 600;

/// The fixed virtual height of the gameplay view in logic units (pixels).
const int virtualHeight = 270;

// -- Asset / Layer dimensions --

/// Width of the background/field layer images.
const int fieldLayerImageWidth = 512;

/// Height of the background/field layer images.
const int fieldLayerImageHeight = 256;

/// Vertical offset to align the bottom of the field layer image with the
/// bottom of the virtual viewport.
///
/// `virtualHeight (270) - fieldLayerImageHeight (256) = 14`.
const int fieldLayerBottomAlignedOffsetY =
    virtualHeight - fieldLayerImageHeight; // 14

/// The Y-coordinate within the field layer image where the ground visual
/// starts (opaque top). Based on asset analysis.
/// used to calculate [groundTopY].
const int fieldLayer09OpaqueTopInImageY = 241;

/// The world-space Y coordinate of the ground surface.
///
/// Calculated as `fieldLayerBottomAlignedOffsetY + fieldLayer09OpaqueTopInImageY`.
/// Entities standing on the ground will have their `maxY` at this value.
const int groundTopY =
    fieldLayerBottomAlignedOffsetY + fieldLayer09OpaqueTopInImageY; // 255

/// The fixed Y coordinate for the camera center.
///
/// The camera only scrolls horizontally.
const double cameraFixedY = virtualHeight / 2; // 135.0

// -- Gameplay Constants --

/// Length of the ray cast for projectile aiming.
const double projectileAimRayLength = virtualWidth * 0.5;

/// Length of the ray cast for melee aiming.
const double meleeAimRayLength = virtualWidth * 0.20;


===== FILE: lib/core/ecs/entity_factory.dart =====
import '../combat/faction.dart';
import '../enemies/enemy_id.dart';
import '../snapshots/enums.dart';
import '../util/deterministic_rng.dart';
import 'entity_id.dart';
import 'stores/body_store.dart';
import 'stores/collider_aabb_store.dart';
import 'stores/enemies/enemy_store.dart';
import 'stores/faction_store.dart';
import 'stores/enemies/flying_enemy_steering_store.dart';
import 'stores/enemies/ground_enemy_chase_offset_store.dart';
import 'stores/health_store.dart';
import 'stores/mana_store.dart';
import 'stores/stamina_store.dart';
import 'world.dart';

/// Factory for creating complex entities composed of multiple components.
///
/// This class encapsulates the logic for assembling entities from their constituent
/// components. It ensures that all necessary components are added and initialized
/// correctly for each entity type (e.g., Player, Enemy).
class EntityFactory {
  /// Creates a factory bound to the given [world].
  EntityFactory(this.world);

  /// The [EcsWorld] into which entities will be created.
  final EcsWorld world;

  /// Creates a fully assembled Player entity.
  ///
  /// Adds the following components:
  /// - [TransformStore]: Position and velocity.
  /// - [PlayerInputStore]: Marks this entity as controllable by player input.
  /// - [MovementStore]: Handles movement logic and facing direction.
  /// - [BodyStore]: Physics body properties (mass, friction, etc.).
  /// - [ColliderAabbStore]: Axis-aligned bounding box for collision detection.
  /// - [CollisionStateStore]: Tracks current collision state.
  /// - [CooldownStore]: Manages ability cooldowns.
  /// - [CastIntentStore]: Tracks intent to cast spells.
  /// - [FactionStore]: Sets the faction to [Faction.player].
  /// - [HealthStore]: Health points and max health.
  /// - [InvulnerabilityStore]: Grants temporary invulnerability after damage.
  /// - [LastDamageStore]: Tracks the last source of damage for UI/effects.
  /// - [ManaStore]: Mana points and max mana.
  /// - [MeleeIntentStore]: Tracks intent to perform melee attacks.
  /// - [StaminaStore]: Stamina points and max stamina.
  ///
  /// The [grounded] parameter sets the initial ground state in the collision store.
  EntityId createPlayer({
    required double posX,
    required double posY,
    required double velX,
    required double velY,
    required Facing facing,
    required bool grounded,
    required BodyDef body,
    required ColliderAabbDef collider,
    required HealthDef health,
    required ManaDef mana,
    required StaminaDef stamina,
  }) {
    final id = world.createEntity();
    world.transform.add(id, posX: posX, posY: posY, velX: velX, velY: velY);
    world.playerInput.add(id);
    world.movement.add(id, facing: facing);
    world.body.add(id, body);
    world.colliderAabb.add(id, collider);
    world.collision.add(id);
    world.cooldown.add(id);
    world.castIntent.add(id);
    world.faction.add(id, const FactionDef(faction: Faction.player));
    world.health.add(id, health);
    world.invulnerability.add(id);
    world.lastDamage.add(id);
    world.mana.add(id, mana);
    world.meleeIntent.add(id);
    world.stamina.add(id, stamina);
    world.collision.grounded[world.collision.indexOf(id)] = grounded;
    return id;
  }

  /// Creates an Enemy entity based on the provided [enemyId].
  ///
  /// Adds common components for all enemies:
  /// - [TransformStore]: Position and velocity.
  /// - [BodyStore]: Physics properties.
  /// - [ColliderAabbStore]: Collision boounding box.
  /// - [CollisionStateStore]: Collision state tracking.
  /// - [CooldownStore]: Ability cooldowns.
  /// - [CastIntentStore]: Spell casting intent.
  /// - [FactionStore]: Sets faction to [Faction.enemy].
  /// - [HealthStore], [ManaStore], [StaminaStore]: Vital stats.
  /// - [MeleeIntentStore]: Melee attack intent.
  /// - [EnemyStore]: Identifies the entity as an enemy and stores its type.
  ///
  /// Adds specific components based on [enemyId]:
  /// - [EnemyId.flyingEnemy]: Adds [FlyingEnemySteeringStore] for air movement.
  /// - [EnemyId.groundEnemy]: Adds [SurfaceNavStateStore] and [GroundEnemyChaseOffsetStore]
  ///   for ground-based navigation and chasing behavior.
  EntityId createEnemy({
    required EnemyId enemyId,
    required double posX,
    required double posY,
    required double velX,
    required double velY,
    required Facing facing,
    required BodyDef body,
    required ColliderAabbDef collider,
    required HealthDef health,
    required ManaDef mana,
    required StaminaDef stamina,
  }) {
    final id = world.createEntity();
    world.transform.add(id, posX: posX, posY: posY, velX: velX, velY: velY);
    world.body.add(id, body);
    world.colliderAabb.add(id, collider);
    world.collision.add(id);
    world.cooldown.add(id);
    world.castIntent.add(id);
    world.faction.add(id, const FactionDef(faction: Faction.enemy));
    world.health.add(id, health);
    world.mana.add(id, mana);
    world.meleeIntent.add(id);
    world.stamina.add(id, stamina);
    world.enemy.add(id, EnemyDef(enemyId: enemyId, facing: facing));
    if (enemyId == EnemyId.flyingEnemy) {
      world.flyingEnemySteering.add(
        id,
        FlyingEnemySteeringDef(rngState: seedFrom(world.seed, id)),
      );
    }
    if (enemyId == EnemyId.groundEnemy) {
      world.surfaceNav.add(id);
      world.groundEnemyChaseOffset.add(
        id,
        GroundEnemyChaseOffsetDef(rngState: seedFrom(world.seed, id)),
      );
    }
    return id;
  }
}


===== FILE: lib/core/ecs/entity_id.dart =====
/// Opaque identifier for entities in the Core simulation.
///
/// An [EntityId] is a simple integer that uniquely identifies an entity within
/// the [EcsWorld]. It serves as a key to access components associated with
/// the entity across different [SparseSet] stores.
///
/// Entity IDs are managed by the [EcsWorld]. When an entity is destroyed, its
/// ID is recycled and may be assigned to a new entity in the future to keep the
/// range of active IDs compact, which benefits the performance of sparse sets.
typedef EntityId = int;


===== FILE: lib/core/ecs/hit/aabb_hit_utils.dart =====
import '../../combat/faction.dart';
import '../entity_id.dart';
import '../world.dart';

/// Shared helpers for hit resolution math + filtering.
///
/// IMPORTANT:
/// - Keep these helpers allocation-free and deterministic.
/// - Systems still own iteration/selection rules (e.g. "first hit wins") until
///   Hit Resolution Module is fully unified.

/// Checks if two factions are allied.
///
/// Used for friendly-fire logic (skipping hits on allies).
bool areAllies(Faction a, Faction b) => a == b;

/// Per-tick cache of "damageable collider targets" to reduce repeated sparse
/// lookups in hot loops.
///
/// A target is included if it has:
/// - `HealthStore` (source list)
/// - `FactionStore` (for friendly-fire filtering)
/// - `TransformStore` + `ColliderAabbStore` (for overlap tests)
///
/// Determinism: preserves `HealthStore.denseEntities` iteration order.
class DamageableTargetCache {
  /// The [EntityId] of the target.
  final List<EntityId> entities = <EntityId>[];
  /// The [Faction] of the target.
  final List<Faction> factions = <Faction>[];

  // World-space collider center and half extents (Parallel arrays).
  final List<double> centerX = <double>[];
  final List<double> centerY = <double>[];
  final List<double> halfX = <double>[];
  final List<double> halfY = <double>[];

  int get length => entities.length;
  bool get isEmpty => entities.isEmpty;

  /// Rebuilds the cache by iterating directly over all entities with Health.
  ///
  /// This is an O(N) operation where N is the number of entities with Health,
  /// but it avoids O(log N) or hashing costs during the hot hit-check loop.
  void rebuild(EcsWorld world) {
    // 1. Reset state.
    entities.clear();
    factions.clear();
    centerX.clear();
    centerY.clear();
    halfX.clear();
    halfY.clear();

    final health = world.health;
    if (health.denseEntities.isEmpty) return;

    // 2. Iterate source (HealthStore) to find potential targets.
    for (var i = 0; i < health.denseEntities.length; i += 1) {
      final e = health.denseEntities[i];

      // 3. Filter: Must have Faction, Transform, and Collider.
      // (Using tryIndexOf avoids exception overhead for missing components)
      final fi = world.faction.tryIndexOf(e);
      if (fi == null) continue;
      final ti = world.transform.tryIndexOf(e);
      if (ti == null) continue;
      final aabbi = world.colliderAabb.tryIndexOf(e);
      if (aabbi == null) continue;

      // 4. Pre-calculate world-space AABB to save work during hit tests.
      // (Transform Pos + Collider Offset)
      final cx = world.transform.posX[ti] + world.colliderAabb.offsetX[aabbi];
      final cy = world.transform.posY[ti] + world.colliderAabb.offsetY[aabbi];

      // 5. Commit valid target to cache.
      entities.add(e);
      factions.add(world.faction.faction[fi]);
      centerX.add(cx);
      centerY.add(cy);
      halfX.add(world.colliderAabb.halfX[aabbi]);
      halfY.add(world.colliderAabb.halfY[aabbi]);
    }
  }
}

/// Checks strict overlap between two AABBs defined by Min/Max coordinates.
///
/// Returns true if they overlap. Touching edges does NOT count as overlap.
bool aabbOverlapsMinMax({
  required double aMinX,
  required double aMaxX,
  required double aMinY,
  required double aMaxY,
  required double bMinX,
  required double bMaxX,
  required double bMinY,
  required double bMaxY,
}) {
  // Classic Separating Axis Theorem (SAT):
  // Overlap exists if and only if ranges overlap on BOTH X and Y axes.
  // (Start of A < End of B) AND (End of A > Start of B)
  return aMinX < bMaxX && aMaxX > bMinX && aMinY < bMaxY && aMaxY > bMinY;
}

/// Checks strict overlap between two AABBs defined by Center/Half-Extents.
bool aabbOverlapsCenters({
  required double aCenterX,
  required double aCenterY,
  required double aHalfX,
  required double aHalfY,
  required double bCenterX,
  required double bCenterY,
  required double bHalfX,
  required double bHalfY,
}) {
  return aabbOverlapsMinMax(
    aMinX: aCenterX - aHalfX,
    aMaxX: aCenterX + aHalfX,
    aMinY: aCenterY - aHalfY,
    aMaxY: aCenterY + aHalfY,
    bMinX: bCenterX - bHalfX,
    bMaxX: bCenterX + bHalfX,
    bMinY: bCenterY - bHalfY,
    bMaxY: bCenterY + bHalfY,
  );
}

/// Helper that resolves entity indices to world components and checks overlap.
bool aabbOverlapsWorldColliders(
  EcsWorld world, {
  required int aTransformIndex,
  required int aAabbIndex,
  required int bTransformIndex,
  required int bAabbIndex,
}) {
  // 1. Resolve world-space AABB for Entity A.
  final aCenterX = world.transform.posX[aTransformIndex] +
      world.colliderAabb.offsetX[aAabbIndex];
  final aCenterY = world.transform.posY[aTransformIndex] +
      world.colliderAabb.offsetY[aAabbIndex];
  final aHalfX = world.colliderAabb.halfX[aAabbIndex];
  final aHalfY = world.colliderAabb.halfY[aAabbIndex];

  // 2. Resolve world-space AABB for Entity B.
  final bCenterX = world.transform.posX[bTransformIndex] +
      world.colliderAabb.offsetX[bAabbIndex];
  final bCenterY = world.transform.posY[bTransformIndex] +
      world.colliderAabb.offsetY[bAabbIndex];
  final bHalfX = world.colliderAabb.halfX[bAabbIndex];
  final bHalfY = world.colliderAabb.halfY[bAabbIndex];

  // 3. Check overlap.
  return aabbOverlapsCenters(
    aCenterX: aCenterX,
    aCenterY: aCenterY,
    aHalfX: aHalfX,
    aHalfY: aHalfY,
    bCenterX: bCenterX,
    bCenterY: bCenterY,
    bHalfX: bHalfX,
    bHalfY: bHalfY,
  );
}


===== FILE: lib/core/ecs/hit/capsule_hit_utils.dart =====
import 'dart:math' as math;

const double _segmentEps = 1e-12;

/// Checks if a capsule (line segment + radius) intersects an Axis-Aligned Bounding Box (AABB).
///
/// The capsule is defined by start point ([ax], [ay]), end point ([bx], [by]),
/// and [radius]. The AABB is defined by min/max coordinates.
///
/// This works by padding the AABB by the capsule radius and performing a segment-to-box
/// intersection test.
bool capsuleIntersectsAabb({
  required double ax,
  required double ay,
  required double bx,
  required double by,
  required double radius,
  required double minX,
  required double minY,
  required double maxX,
  required double maxY,
}) {
  final r = radius < 0 ? 0.0 : radius;
  // Expanding the AABB by the radius allows us to treat the capsule as a simple
  // line segment against the larger box.
  return _segmentIntersectsAabb(
    ax: ax,
    ay: ay,
    bx: bx,
    by: by,
    minX: minX - r,
    minY: minY - r,
    maxX: maxX + r,
    maxY: maxY + r,
  );
}

/// Core segment-AABB intersection test using slab method logic.
///
/// Checks if the line segment from A to B intersects the given AABB.
bool _segmentIntersectsAabb({
  required double ax,
  required double ay,
  required double bx,
  required double by,
  required double minX,
  required double minY,
  required double maxX,
  required double maxY,
}) {
  final dx = bx - ax;
  final dy = by - ay;
  var t0 = 0.0;
  var t1 = 1.0;

  // --- X-axis slab test ---
  if (dx.abs() < _segmentEps) {
    // Segment is parallel to Y-axis. If X is outside, no intersection.
    if (ax < minX || ax > maxX) return false;
  } else {
    // Compute intersection times (t) with X-planes.
    final inv = 1.0 / dx;
    var tNear = (minX - ax) * inv;
    var tFar = (maxX - ax) * inv;
    if (tNear > tFar) {
      final tmp = tNear;
      tNear = tFar;
      tFar = tmp;
    }
    // Narrow the valid segment range [t0, t1].
    t0 = math.max(t0, tNear);
    t1 = math.min(t1, tFar);
    // If range becomes invalid, segment missed.
    if (t0 > t1) return false;
  }

  // --- Y-axis slab test ---
  if (dy.abs() < _segmentEps) {
    // Segment is parallel to X-axis. If Y is outside, no intersection.
    if (ay < minY || ay > maxY) return false;
  } else {
    // Compute intersection times (t) with Y-planes.
    final inv = 1.0 / dy;
    var tNear = (minY - ay) * inv;
    var tFar = (maxY - ay) * inv;
    if (tNear > tFar) {
      final tmp = tNear;
      tNear = tFar;
      tFar = tmp;
    }
    // Further narrow the valid segment range.
    t0 = math.max(t0, tNear);
    t1 = math.min(t1, tFar);
    // If range becomes invalid, segment missed.
    if (t0 > t1) return false;
  }

  // Intersection confirmed if we survived both slab tests.
  return true;
}


===== FILE: lib/core/ecs/hit/hit_resolver.dart =====
import 'dart:math' as math;

import '../../combat/faction.dart';
import '../entity_id.dart';
import '../spatial/broadphase_grid.dart';
import 'aabb_hit_utils.dart';
import 'capsule_hit_utils.dart';

/// Shared narrowphase + deterministic hit candidate ordering.
///
/// Responsibilities:
/// - broadphase query
/// - filtering (owner exclusion + friendly-fire)
/// - AABB overlap test
/// - deterministic ordering (EntityId ascending)
///
/// Non-responsibilities:
/// - world mutation (damage, despawns, HitOnce marking)
class HitResolver {
  // Temporary list to hold candidates from the broadphase before processing.
  final List<int> _candidates = <int>[];

  /// Collects ALL entities intersecting the given AABB into [outTargetIndices].
  ///
  /// The results are filtered strictly (overlaps only) and loosely (owner/friendly fire),
  /// and are guaranteed to be sorted by [EntityId].
  void collectOrderedOverlapsCenters({
    required BroadphaseGrid broadphase,
    required double centerX,
    required double centerY,
    required double halfX,
    required double halfY,
    required EntityId owner,
    required Faction sourceFaction,
    required List<int> outTargetIndices,
  }) {
    outTargetIndices.clear();

    // 1. Broadphase Query + deterministic sort.
    final hasCandidates = _prepareCandidates(
      broadphase: broadphase,
      minX: centerX - halfX,
      minY: centerY - halfY,
      maxX: centerX + halfX,
      maxY: centerY + halfY,
    );
    if (!hasCandidates) return;

    // 2. Narrowphase Check on processed candidates.
    for (var i = 0; i < _candidates.length; i += 1) {
      final targetIndex = _candidates[i];

      // 2a. Filter logic (Owner + Faction).
      if (!_isValidTarget(targetIndex, broadphase, owner, sourceFaction)) {
        continue;
      }

      // 2b. Exact AABB overlap test.
      if (!aabbOverlapsCenters(
        aCenterX: centerX,
        aCenterY: centerY,
        aHalfX: halfX,
        aHalfY: halfY,
        bCenterX: broadphase.targets.centerX[targetIndex],
        bCenterY: broadphase.targets.centerY[targetIndex],
        bHalfX: broadphase.targets.halfX[targetIndex],
        bHalfY: broadphase.targets.halfY[targetIndex],
      )) {
        continue;
      }

      // 3. Collect valid hit.
      outTargetIndices.add(targetIndex);
    }
  }

  /// Returns the FIRST entity intersecting the given AABB (lowest EntityId).
  int? firstOrderedOverlapCenters({
    required BroadphaseGrid broadphase,
    required double centerX,
    required double centerY,
    required double halfX,
    required double halfY,
    required EntityId owner,
    required Faction sourceFaction,
  }) {
    // 1. Broadphase Query.
    final hasCandidates = _prepareCandidates(
      broadphase: broadphase,
      minX: centerX - halfX,
      minY: centerY - halfY,
      maxX: centerX + halfX,
      maxY: centerY + halfY,
    );
    if (!hasCandidates) return null;

    // 2. Determine the first valid hit.
    for (var i = 0; i < _candidates.length; i += 1) {
      final targetIndex = _candidates[i];

      // 2a. Filter logic.
      if (!_isValidTarget(targetIndex, broadphase, owner, sourceFaction)) {
        continue;
      }

      // 2b. Exact AABB overlap test.
      if (!aabbOverlapsCenters(
        aCenterX: centerX,
        aCenterY: centerY,
        aHalfX: halfX,
        aHalfY: halfY,
        bCenterX: broadphase.targets.centerX[targetIndex],
        bCenterY: broadphase.targets.centerY[targetIndex],
        bHalfX: broadphase.targets.halfX[targetIndex],
        bHalfY: broadphase.targets.halfY[targetIndex],
      )) {
        continue;
      }

      // 3. Return immediately on first hit (Sorted by EntityId).
      return targetIndex;
    }

    return null;
  }

  /// Collects ALL entities intersecting the given capsule into [outTargetIndices].
  void collectOrderedOverlapsCapsule({
    required BroadphaseGrid broadphase,
    required double ax,
    required double ay,
    required double bx,
    required double by,
    required double radius,
    required EntityId owner,
    required Faction sourceFaction,
    required List<int> outTargetIndices,
  }) {
    outTargetIndices.clear();

    // 1. Broadphase Query using capsule AABB bounds.
    final hasCandidates = _prepareCandidates(
      broadphase: broadphase,
      minX: math.min(ax, bx) - radius,
      minY: math.min(ay, by) - radius,
      maxX: math.max(ax, bx) + radius,
      maxY: math.max(ay, by) + radius,
    );
    if (!hasCandidates) return;

    // 2. Narrowphase Check.
    for (var i = 0; i < _candidates.length; i += 1) {
      final targetIndex = _candidates[i];

      // 2a. Filter logic.
      if (!_isValidTarget(targetIndex, broadphase, owner, sourceFaction)) {
        continue;
      }

      final targetCenterX = broadphase.targets.centerX[targetIndex];
      final targetCenterY = broadphase.targets.centerY[targetIndex];
      final targetHalfX = broadphase.targets.halfX[targetIndex];
      final targetHalfY = broadphase.targets.halfY[targetIndex];

      // 2b. Capsule vs AABB intersection test.
      if (!capsuleIntersectsAabb(
        ax: ax,
        ay: ay,
        bx: bx,
        by: by,
        radius: radius,
        minX: targetCenterX - targetHalfX,
        minY: targetCenterY - targetHalfY,
        maxX: targetCenterX + targetHalfX,
        maxY: targetCenterY + targetHalfY,
      )) {
        continue;
      }

      // 3. Collect valid hit.
      outTargetIndices.add(targetIndex);
    }
  }

  /// Returns the FIRST entity intersecting the given capsule (lowest EntityId).
  int? firstOrderedOverlapCapsule({
    required BroadphaseGrid broadphase,
    required double ax,
    required double ay,
    required double bx,
    required double by,
    required double radius,
    required EntityId owner,
    required Faction sourceFaction,
  }) {
    // 1. Broadphase Query.
    final hasCandidates = _prepareCandidates(
      broadphase: broadphase,
      minX: math.min(ax, bx) - radius,
      minY: math.min(ay, by) - radius,
      maxX: math.max(ax, bx) + radius,
      maxY: math.max(ay, by) + radius,
    );
    if (!hasCandidates) return null;

    // 2. Determine the first valid hit.
    for (var i = 0; i < _candidates.length; i += 1) {
      final targetIndex = _candidates[i];

      // 2a. Filter logic.
      if (!_isValidTarget(targetIndex, broadphase, owner, sourceFaction)) {
        continue;
      }

      final targetCenterX = broadphase.targets.centerX[targetIndex];
      final targetCenterY = broadphase.targets.centerY[targetIndex];
      final targetHalfX = broadphase.targets.halfX[targetIndex];
      final targetHalfY = broadphase.targets.halfY[targetIndex];

      // 2b. Capsule vs AABB intersection test.
      if (!capsuleIntersectsAabb(
        ax: ax,
        ay: ay,
        bx: bx,
        by: by,
        radius: radius,
        minX: targetCenterX - targetHalfX,
        minY: targetCenterY - targetHalfY,
        maxX: targetCenterX + targetHalfX,
        maxY: targetCenterY + targetHalfY,
      )) {
        continue;
      }

      // 3. Return immediately on first hit.
      return targetIndex;
    }

    return null;
  }

  /// Helper: Runs broadphase query and sorts results by EntityId.
  ///
  /// Returns `false` if no candidates were found.
  bool _prepareCandidates({
    required BroadphaseGrid broadphase,
    required double minX,
    required double minY,
    required double maxX,
    required double maxY,
  }) {
    // 1. Get raw cell-based candidates (contains duplicates if spanning cells).
    broadphase.queryAabbMinMax(
      minX: minX,
      minY: minY,
      maxX: maxX,
      maxY: maxY,
      outTargetIndices: _candidates,
    );
    if (_candidates.isEmpty) return false;

    // 2. Sort by EntityId to ensure deterministic order (1, 2, 3...)
    // regardless of cell iteration order.
    _sortCandidatesByEntityId(broadphase);
    return true;
  }

  /// Helper: Checks non-geometric filtering rules.
  ///
  /// - Excludes [owner] (can't hit self).
  /// - Excludes allies of [sourceFaction] (friendly fire).
  bool _isValidTarget(
    int targetIndex,
    BroadphaseGrid broadphase,
    EntityId owner,
    Faction sourceFaction,
  ) {
    final target = broadphase.targets.entities[targetIndex];
    if (target == owner) return false;

    return !areAllies(
      sourceFaction,
      broadphase.targets.factions[targetIndex],
    );
  }

  void _sortCandidatesByEntityId(BroadphaseGrid broadphase) {
    _candidates.sort(
      (a, b) => broadphase.targets.entities[a].compareTo(
        broadphase.targets.entities[b],
      ),
    );
  }
}


===== FILE: lib/core/ecs/queries.dart =====
import 'entity_id.dart';
import 'world.dart';

/// Callback signature for iterating over entities with movement-related components.
///
/// [e] is the Entity ID.
/// [mi], [ti], [ii], [bi], [ci], [si] are the **dense indices** for:
/// - [mi]: MovementStore
/// - [ti]: TransformStore
/// - [ii]: PlayerInputStore
/// - [bi]: BodyStore
/// - [ci]: CollisionStateStore
/// - [si]: StaminaStore
typedef MovementQueryFn =
    void Function(EntityId e, int mi, int ti, int ii, int bi, int ci, int si);

/// Callback signature for iterating over entities with collision-related components.
///
/// [e] is the Entity ID.
/// [ti], [bi], [coli], [aabbi] are the **dense indices** for:
/// - [ti]: TransformStore
/// - [bi]: BodyStore
/// - [coli]: CollisionStateStore
/// - [aabbi]: ColliderAabbStore
typedef ColliderQueryFn =
    void Function(EntityId e, int ti, int bi, int coli, int aabbi);

/// Provides optimized iteration methods for groups of components used in common systems.
///
/// These static methods perform "joins" across multiple component stores. They iterate
/// efficiently by driving the loop with the "primary" store (usually the one expected
/// to have the fewest entities or the one we want to iterate linearly) and checking
/// for the presence of other required components.
class EcsQueries {
  /// Iterates over all entities that have [MovementStore], [TransformStore],
  /// [PlayerInputStore], [BodyStore], [CollisionStateStore], and [StaminaStore].
  ///
  /// This query is typically used by the [MovementSystem] to process player movement.
  /// It effectively filters for "controllable physics bodies".
  static void forMovementBodies(EcsWorld world, MovementQueryFn fn) {
    // We drive iteration with the MovementStore.
    final movement = world.movement;
    final entities = movement.denseEntities;

    for (var mi = 0; mi < entities.length; mi += 1) {
      final e = entities[mi];

      // Check existence and get indices for all other required components.
      final ti = world.transform.tryIndexOf(e);
      if (ti == null) continue;
      final ii = world.playerInput.tryIndexOf(e);
      if (ii == null) continue;
      final bi = world.body.tryIndexOf(e);
      if (bi == null) continue;
      final ci = world.collision.tryIndexOf(e);
      if (ci == null) continue;
      final si = world.stamina.tryIndexOf(e);
      if (si == null) continue;

      fn(e, mi, ti, ii, bi, ci, si);
    }
  }

  /// Iterates over all entities that have [ColliderAabbStore], [TransformStore],
  /// [BodyStore], and [CollisionStateStore].
  ///
  /// This query finds all physical objects that can collide. It is used by the
  /// [CollisionSystem] to resolve physics interactions.
  static void forColliders(EcsWorld world, ColliderQueryFn fn) {
    // Drive iteration with the ColliderAabbStore.
    final aabb = world.colliderAabb;
    final entities = aabb.denseEntities;

    for (var aabbi = 0; aabbi < entities.length; aabbi += 1) {
      final e = entities[aabbi];

      final ti = world.transform.tryIndexOf(e);
      if (ti == null) continue;
      final bi = world.body.tryIndexOf(e);
      if (bi == null) continue;
      final coli = world.collision.tryIndexOf(e);
      if (coli == null) continue;

      fn(e, ti, bi, coli, aabbi);
    }
  }
}


===== FILE: lib/core/ecs/sparse_set.dart =====
import 'entity_id.dart';

/// Base sparse-set bookkeeping for component stores.
///
/// A sparse set is a data structure that efficiently maps a potentially sparse range
/// of integers (the entity IDs) to a dense, contiguous array of data.
///
/// Internally, it maintains two lists:
/// - `_sparse`: An array indexed by [EntityId]. `_sparse[entity]` stores the
///   index into `denseEntities` plus 1 (0 indicates the entity is not present).
/// - `denseEntities`: A list of [EntityId]s packed contiguously. This allows for
///   fast iteration over all entities that possess this component.
///
/// Subclasses (Component Stores) will maintain their own component data in parallel
/// arrays, also indexed by the values stored in `_sparse` (the "dense index").
///
/// Capabilities:
/// - O(1) membership check (`has`).
/// - O(1) lookup of component data index (`indexOf`).
/// - O(1) insertion (`addEntity`).
/// - O(1) removal (`removeEntity`) using the "swap-and-pop" technique.
/// - Cache-friendly iteration over `denseEntities`.
abstract class SparseSet {
  /// The list of entities that have this component, packed densely.
  /// Iterating this list is the standard way to process all components of this type.
  final List<EntityId> denseEntities = <EntityId>[];

  /// The sparse array mapping EntityId to (denseIndex + 1).
  /// A value of 0 means the entity does not have this component.
  final List<int> _sparse = <int>[];

  /// Returns true if [entity] has this component.
  bool has(EntityId entity) {
    if (entity < 0) return false;
    if (entity >= _sparse.length) return false;
    return _sparse[entity] != 0;
  }

  /// Returns the dense index for [entity].
  ///
  /// Throws if the entity does not have this component. Use [has] or [tryIndexOf] to check.
  int indexOf(EntityId entity) {
    final idxPlus1 = _sparse[entity];
    return idxPlus1 - 1;
  }

  /// Returns the dense index for [entity], or null if it doesn't have this component.
  int? tryIndexOf(EntityId entity) {
    if (entity < 0 || entity >= _sparse.length) return null;
    final idxPlus1 = _sparse[entity];
    if (idxPlus1 == 0) return null;
    return idxPlus1 - 1;
  }

  /// Ensures the internal sparse array is large enough to hold [entity].
  void ensureCapacity(EntityId entity) {
    if (entity < _sparse.length) return;
    final toAdd = entity + 1 - _sparse.length;
    if (toAdd <= 0) return;
    _sparse.addAll(List<int>.filled(toAdd, 0));
  }

  /// Registers [entity] with this store.
  ///
  /// Returns the new stable dense index for this entity's component data.
  /// If the entity is already present, returns its existing dense index.
  ///
  /// Subclasses should call this first, then add their data to their parallel arrays.
  int addEntity(EntityId entity) {
    ensureCapacity(entity);
    final existing = _sparse[entity];
    if (existing != 0) return existing - 1;

    final denseIndex = denseEntities.length;
    denseEntities.add(entity);
    _sparse[entity] = denseIndex + 1;
    onDenseAdded(denseIndex);
    return denseIndex;
  }

  /// Removes [entity] from this store.
  ///
  /// Uses "swap-and-pop" to remove in O(1):
  /// 1. The component data for the entity to be removed is swapped with the
  ///    last component in the dense arrays.
  /// 2. The mapping in `_sparse` for the swapped entity is updated.
  /// 3. The last element is removed (popped).
  ///
  /// This operation changes the dense index of the entity that was at the end.
  void removeEntity(EntityId entity) {
    if (!has(entity)) return;

    final removeIndex = indexOf(entity);
    final lastIndex = denseEntities.length - 1;

    // Hook for subclasses to swap their data arrays before we modify indices.
    onSwapRemove(removeIndex, lastIndex);

    final lastEntity = denseEntities[lastIndex];
    denseEntities[removeIndex] = lastEntity;
    denseEntities.removeLast();

    _sparse[entity] = 0;
    if (removeIndex != lastIndex) {
      // Update the sparse map for the entity that was moved into the empty slot.
      _sparse[lastEntity] = removeIndex + 1;
    }
  }

  /// Called after a new dense slot has been appended.
  /// Subclasses should rely on this to know when a valid index has been established,
  /// though usually they just push data to their lists.
  void onDenseAdded(int denseIndex);

  /// Called before dense arrays are swap-removed from [removeIndex] and [lastIndex].
  ///
  /// Subclasses MUST perform the swap on their parallel data lists inside this method:
  /// `dataList[removeIndex] = dataList[lastIndex]; dataList.removeLast();`
  void onSwapRemove(int removeIndex, int lastIndex);
}


===== FILE: lib/core/ecs/spatial/broadphase_grid.dart =====
import '../hit/aabb_hit_utils.dart';
import '../world.dart';
import 'grid_index_2d.dart';

/// Deterministic broadphase grid rebuilt each tick from dynamic damageable AABBs.
///
/// This grid implementation uses spatial hashing to bucket entities into cells.
/// AABBs that overlap multiple cells are added to all corresponding buckets.
///
/// **Memory Strategy**:
/// - [targets]: Rebuilt every frame to store flat arrays of AABB components.
/// - [_buckets]: Map of cell keys to lists of target indices. Keys are removed
///   when buckets become empty to keep the map size bounded to the visible/active
///   world (vital for infinite runners).
/// - [_bucketPool]: Reuses `List<int>` instances to avoid allocation churn.
/// - [_seenStampByTargetIndex]: Used for O(1) deduplication during queries (avoiding `Set`).
///
/// **Determinism**:
/// - The grid structure itself is order-independent for population.
/// - [queryAabbMinMax] iterates cells in a strict (Y then X) order.
/// - Note: The order of indices *within* a bucket is insertion order (index order in [targets]).
///   Since [targets] is rebuilt by iterating the [EcsWorld], this order depends on
///   Entity ID iteration order.
class BroadphaseGrid {
  BroadphaseGrid({required GridIndex2D index}) : _index = index;

  /// Helper for grid math (coordinate conversion, key packing).
  final GridIndex2D _index;

  /// Stores component data for all damageable entities in the current frame.
  /// Rebuilt at the start of `rebuild()`.
  final DamageableTargetCache targets = DamageableTargetCache();

  // cellKey -> list of target indices into `targets`.
  final Map<int, List<int>> _buckets = <int, List<int>>{};
  // Tracks keys currently in `_buckets` to allow fast iteration/clearing without
  // scanning the whole map (if it were sparse/large).
  final List<int> _activeKeys = <int>[];
  // Pool of lists to avoid allocating new Lists every frame.
  final List<List<int>> _bucketPool = <List<int>>[];

  // Per-query dedup for targets that span multiple cells.
  // We use a "timestamp" strategy: each query increments `_stamp`.
  // If `seen[target] == _stamp`, we've already added it this query.
  final List<int> _seenStampByTargetIndex = <int>[];
  int _stamp = 0;

  /// Rebuilds the spatial grid from the current state of [world].
  ///
  /// This must be called once per tick before any queries are performed.
  void rebuild(EcsWorld world) {
    targets.rebuild(world);

    // clear() old buckets and return lists to the pool.
    // We remove keys from the map to keep the map size small (only active cells).
    for (var i = 0; i < _activeKeys.length; i += 1) {
      final key = _activeKeys[i];
      final bucket = _buckets.remove(key);
      if (bucket == null) continue;
      bucket.clear();
      _bucketPool.add(bucket);
    }
    _activeKeys.clear();

    if (targets.isEmpty) return;

    // Populate buckets.
    for (var ti = 0; ti < targets.length; ti += 1) {
      final cx = targets.centerX[ti];
      final cy = targets.centerY[ti];
      final hx = targets.halfX[ti];
      final hy = targets.halfY[ti];

      // Calculate AABB min/max in world space.
      final minX = cx - hx;
      final maxX = cx + hx;
      final minY = cy - hy;
      final maxY = cy + hy;

      // Convert world AABB to cell index range (inclusive).
      final minCx = _index.worldToCellX(minX);
      final maxCx = _index.worldToCellX(maxX);
      final minCy = _index.worldToCellY(minY);
      final maxCy = _index.worldToCellY(maxY);

      // Add target to every cell its AABB overlaps.
      // This handles "large" entities that span multiple grid cells.
      for (var cellY = minCy; cellY <= maxCy; cellY += 1) {
        for (var cellX = minCx; cellX <= maxCx; cellX += 1) {
          final key = _index.cellKey(cellX, cellY);
          var bucket = _buckets[key];
          if (bucket == null) {
            // Get a list from the pool or allocate new.
            bucket = _bucketPool.isNotEmpty ? _bucketPool.removeLast() : <int>[];
            _buckets[key] = bucket;
            _activeKeys.add(key);
          }
          // Store the target index (not EntityId) for fast lookups.
          bucket.add(ti);
        }
      }
    }
  }

  /// Fills [outTargetIndices] with unique target indices whose AABBs may overlap
  /// the query AABB.
  ///
  /// This involves a broadphase lookup (finding grid cells) and deduplication.
  ///
  /// IMPORTANT (determinism):
  /// - Cell scan order is stable (y then x, increasing).
  /// - The output order depends on bucket insertion order (which depends on entity order).
  /// - Callers must sort by `targets.entities[targetIndex]` if they need a stable
  ///   per-query hit selection order.
  void queryAabbMinMax({
    required double minX,
    required double minY,
    required double maxX,
    required double maxY,
    required List<int> outTargetIndices,
  }) {
    outTargetIndices.clear();
    if (targets.isEmpty) return;

    _stamp += 1;

    // Handle stamp overflow (wrap around)
    if (_stamp == 0x7FFFFFFF) {
      // Reset all seen stamps to 0 so we can safely start over at 1
      for (var i = 0; i < _seenStampByTargetIndex.length; i += 1) {
        _seenStampByTargetIndex[i] = 0;
      }
      _stamp = 1;
    }

    final minCx = _index.worldToCellX(minX);
    final maxCx = _index.worldToCellX(maxX);
    final minCy = _index.worldToCellY(minY);
    final maxCy = _index.worldToCellY(maxY);

    // Ensure strict capacity for the seen array to match current targets.
    // This handles the case where new targets were added in `rebuild`.
    if (_seenStampByTargetIndex.length < targets.length) {
      final missing = targets.length - _seenStampByTargetIndex.length;
      for (var i = 0; i < missing; i += 1) {
        _seenStampByTargetIndex.add(0);
      }
    }

    // Iterate over all cells touched by the query AABB.
    // Order: Row by row (Y), then column by column (X).
    for (var cellY = minCy; cellY <= maxCy; cellY += 1) {
      for (var cellX = minCx; cellX <= maxCx; cellX += 1) {
        final key = _index.cellKey(cellX, cellY);
        final bucket = _buckets[key];
        
        // Skip empty cells.
        if (bucket == null || bucket.isEmpty) continue;

        // Iterate contents of the bucket.
        // Elements are roughly sorted by insertion order (EntityId order).
        for (var bi = 0; bi < bucket.length; bi += 1) {
          final targetIndex = bucket[bi];
          
          // Use stamp to check if already visited this query.
          // This avoids adding the same entity multiple times if it spans multiple cells.
          if (_seenStampByTargetIndex[targetIndex] == _stamp) continue;
          _seenStampByTargetIndex[targetIndex] = _stamp;
          outTargetIndices.add(targetIndex);
        }
      }
    }
  }
}


===== FILE: lib/core/ecs/spatial/grid_index_2d.dart =====
import '../../util/vec2.dart';

class CellAabb {
  const CellAabb({
    required this.minX,
    required this.minY,
    required this.maxX,
    required this.maxY,
  });

  /// World space minimum X coordinate of the cell.
  final double minX;

  /// World space minimum Y coordinate of the cell.
  final double minY;

  /// World space maximum X coordinate of the cell.
  final double maxX;

  /// World space maximum Y coordinate of the cell.
  final double maxY;
}

/// Generic 2D grid math + hashing utility.
///
/// This is intentionally reusable for both:
/// - dynamic broadphase buckets (Milestone 9), and
/// - future nav/cost grids (later milestone).
///
/// IMPORTANT (determinism):
/// - `cellKey(cx, cy)` must be stable and must not use Dart `hashCode`.
class GridIndex2D {
  GridIndex2D({required this.cellSize}) : invCellSize = 1.0 / cellSize;

  /// The width/height of a single square grid cell in world units.
  final double cellSize;

  /// Precomputed `1.0 / cellSize` to avoid divisions in tight loops.
  final double invCellSize;

  /// Converts world X coordinate to grid cell X index.
  /// Uses floor() to handle negative coordinates correctly.
  int worldToCellX(double x) => (x * invCellSize).floor();

  /// Converts world Y coordinate to grid cell Y index.
  int worldToCellY(double y) => (y * invCellSize).floor();

  /// returns the top-left (min) world position of the cell at [cx], [cy].
  Vec2 cellToWorldMin(int cx, int cy) => Vec2(cx * cellSize, cy * cellSize);

  CellAabb cellAabb(int cx, int cy) {
    final minX = cx * cellSize;
    final minY = cy * cellSize;
    return CellAabb(
      minX: minX,
      minY: minY,
      maxX: minX + cellSize,
      maxY: minY + cellSize,
    );
  }

  /// Packs signed (cx, cy) into a single int key (two 32-bit lanes).
  ///
  /// The key is constructed by placing `cy` in the upper 32 bits and `cx` in the
  /// lower 32 bits.
  ///
  /// **Platform Note**: This logic relies on Dart's 64-bit integers (VM/Native).
  /// On the web, where `int` is a double and bitwise operations are 32-bit,
  /// this will lose data (collisions) for keys requiring >32 bits.
  /// For cross-platform safety use a String key or customized class, or ensure
  /// coordinates fit in 16 bits (packed to 32).
  int cellKey(int cx, int cy) {
    // Mask to 32 bits to treat as unsigned for packing, then shift.
    return ((cy & 0xFFFFFFFF) << 32) | (cx & 0xFFFFFFFF);
  }

  /// Iterates 4 neighbors (or 8 if [diagonal] is true) around [cx], [cy].
  ///
  /// Order is guaranteed for determinism:
  /// 1. Cardinals: N, W, E, S
  /// 2. Diagonals (if enabled): NW, NE, SW, SE
  void forNeighbors(
    int cx,
    int cy, {
    bool diagonal = false,
    required void Function(int nx, int ny) visit,
  }) {
    // Stable order (N, W, E, S), then diagonals (NW, NE, SW, SE).
    visit(cx, cy - 1); // North
    visit(cx - 1, cy); // West
    visit(cx + 1, cy); // East
    visit(cx, cy + 1); // South

    if (!diagonal) return;
    
    visit(cx - 1, cy - 1); // NW
    visit(cx + 1, cy - 1); // NE
    visit(cx - 1, cy + 1); // SW
    visit(cx + 1, cy + 1); // SE
  }
}



===== FILE: lib/core/ecs/stores/body_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

/// Configuration for how an entity participates in physics.
///
/// This is intentionally "config-like" and reusable across players/enemies:
/// - `Transform` holds state (pos/vel)
/// - `Movement` holds controller-specific timers/state (coyote, dash, etc.)
/// - `Body` holds physics participation and constraints (gravity, clamps, kinematic)
class BodyDef {
  const BodyDef({
    this.enabled = true,
    this.isKinematic = false,
    this.useGravity = true,
    this.ignoreCeilings = false,
    this.topOnlyGround = true,
    this.gravityScale = 1.0,
    this.maxVelX = defaultMaxVelX,
    this.maxVelY = defaultMaxVelY,
    this.sideMask = sideLeft | sideRight,
  });

  /// Default velocity cap (safety limit).
  static const double defaultMaxVelX = 3000.0;
  static const double defaultMaxVelY = 3000.0;

  /// Master on/off switch for physics on this entity.
  final bool enabled;

  /// If true, physics does not integrate position/velocity (gameplay code drives it).
  final bool isKinematic;

  /// Whether gravity affects this body.
  final bool useGravity;

  /// If true, upward motion ignores bottom faces (ceilings).
  final bool ignoreCeilings;

  /// If true, collision should resolve only top contacts (platformer-style).
  /// Used by `CollisionSystem` (later milestone).
  final bool topOnlyGround;

  /// Scale applied to global/tuning gravity (1.0 = normal gravity).
  final double gravityScale;

  /// Per-axis velocity clamps (safety caps).
  final double maxVelX;
  final double maxVelY;

  /// Horizontal collision sides bitmask (used by `CollisionSystem` later).
  final int sideMask;

  static const int sideNone = 0;
  static const int sideLeft = 1 << 0;
  static const int sideRight = 1 << 1;
}

/// SoA store for `Body` configuration.
class BodyStore extends SparseSet {
  final List<bool> enabled = <bool>[];
  final List<bool> isKinematic = <bool>[];
  final List<bool> useGravity = <bool>[];
  final List<bool> ignoreCeilings = <bool>[];
  final List<bool> topOnlyGround = <bool>[];

  final List<double> gravityScale = <double>[];
  final List<double> maxVelX = <double>[];
  final List<double> maxVelY = <double>[];

  final List<int> sideMask = <int>[];

  void add(EntityId entity, BodyDef def) {
    final i = addEntity(entity);
    enabled[i] = def.enabled;
    isKinematic[i] = def.isKinematic;
    useGravity[i] = def.useGravity;
    ignoreCeilings[i] = def.ignoreCeilings;
    topOnlyGround[i] = def.topOnlyGround;
    gravityScale[i] = def.gravityScale;
    maxVelX[i] = def.maxVelX;
    maxVelY[i] = def.maxVelY;
    sideMask[i] = def.sideMask;
  }

  @override
  void onDenseAdded(int denseIndex) {
    enabled.add(true);
    isKinematic.add(false);
    useGravity.add(true);
    ignoreCeilings.add(false);
    topOnlyGround.add(true);
    gravityScale.add(1);
    maxVelX.add(BodyDef.defaultMaxVelX);
    maxVelY.add(BodyDef.defaultMaxVelY);
    sideMask.add(BodyDef.sideLeft | BodyDef.sideRight);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    enabled[removeIndex] = enabled[lastIndex];
    isKinematic[removeIndex] = isKinematic[lastIndex];
    useGravity[removeIndex] = useGravity[lastIndex];
    ignoreCeilings[removeIndex] = ignoreCeilings[lastIndex];
    topOnlyGround[removeIndex] = topOnlyGround[lastIndex];
    gravityScale[removeIndex] = gravityScale[lastIndex];
    maxVelX[removeIndex] = maxVelX[lastIndex];
    maxVelY[removeIndex] = maxVelY[lastIndex];
    sideMask[removeIndex] = sideMask[lastIndex];

    enabled.removeLast();
    isKinematic.removeLast();
    useGravity.removeLast();
    ignoreCeilings.removeLast();
    topOnlyGround.removeLast();
    gravityScale.removeLast();
    maxVelX.removeLast();
    maxVelY.removeLast();
    sideMask.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/cast_intent_store.dart =====
import '../../spells/spell_id.dart';
import '../entity_id.dart';
import '../sparse_set.dart';

class CastIntentDef {
  const CastIntentDef({
    required this.spellId,
    required this.dirX,
    required this.dirY,
    required this.fallbackDirX,
    required this.fallbackDirY,
    required this.originOffset,
    required this.cooldownTicks,
    required this.tick,
  });

  final SpellId spellId;
  final double dirX;
  final double dirY;
  final double fallbackDirX;
  final double fallbackDirY;
  final double originOffset;
  final int cooldownTicks;

  /// Tick stamp for this intent.
  ///
  /// Use `-1` for "no intent". An intent is valid only when `tick == currentTick`.
  final int tick;
}

/// Per-entity "cast a spell this tick" intent.
///
/// This is written by player/enemy intent writers and consumed by `SpellCastSystem`.
///
/// **Usage**: Persistent component. Intents are set via `set()` with a `tick` stamp.
/// Old intents are ignored if `tick` matches current game tick.
/// This avoids the overhead of adding/removing components every frame.
class CastIntentStore extends SparseSet {
  final List<SpellId> spellId = <SpellId>[];
  final List<double> dirX = <double>[];
  final List<double> dirY = <double>[];
  final List<double> fallbackDirX = <double>[];
  final List<double> fallbackDirY = <double>[];
  final List<double> originOffset = <double>[];
  final List<int> cooldownTicks = <int>[];
  final List<int> tick = <int>[];

  void add(EntityId entity) {
    addEntity(entity);
  }

  void set(EntityId entity, CastIntentDef def) {
    assert(
      has(entity),
      'CastIntentStore.set called for entity without CastIntentStore; add the component at spawn time.',
    );
    final i = indexOf(entity);
    spellId[i] = def.spellId;
    dirX[i] = def.dirX;
    dirY[i] = def.dirY;
    fallbackDirX[i] = def.fallbackDirX;
    fallbackDirY[i] = def.fallbackDirY;
    originOffset[i] = def.originOffset;
    cooldownTicks[i] = def.cooldownTicks;
    tick[i] = def.tick;
  }

  @override
  void onDenseAdded(int denseIndex) {
    spellId.add(SpellId.iceBolt);
    dirX.add(0.0);
    dirY.add(0.0);
    fallbackDirX.add(1.0);
    fallbackDirY.add(0.0);
    originOffset.add(0.0);
    cooldownTicks.add(0);
    tick.add(-1);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    spellId[removeIndex] = spellId[lastIndex];
    dirX[removeIndex] = dirX[lastIndex];
    dirY[removeIndex] = dirY[lastIndex];
    fallbackDirX[removeIndex] = fallbackDirX[lastIndex];
    fallbackDirY[removeIndex] = fallbackDirY[lastIndex];
    originOffset[removeIndex] = originOffset[lastIndex];
    cooldownTicks[removeIndex] = cooldownTicks[lastIndex];
    tick[removeIndex] = tick[lastIndex];

    spellId.removeLast();
    dirX.removeLast();
    dirY.removeLast();
    fallbackDirX.removeLast();
    fallbackDirY.removeLast();
    originOffset.removeLast();
    cooldownTicks.removeLast();
    tick.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/collectible_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

class CollectibleDef {
  const CollectibleDef({required this.value});

  final int value;
}

/// SoA store for collectible metadata.
///
/// Holds the value/score of the collectible.
class CollectibleStore extends SparseSet {
  final List<int> value = <int>[];

  void add(EntityId entity, CollectibleDef def) {
    final i = addEntity(entity);
    value[i] = def.value;
  }

  @override
  void onDenseAdded(int denseIndex) {
    value.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    value[removeIndex] = value[lastIndex];
    value.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/collider_aabb_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

/// AABB collider configuration for an entity.
///
/// Representation is center-based for stability:
/// - `Transform.pos` is treated as the entity center
/// - collider center is `pos + offset`
/// - extents are half-sizes in world units (virtual pixels)
class ColliderAabbDef {
  const ColliderAabbDef({
    required this.halfX,
    required this.halfY,
    this.offsetX = 0,
    this.offsetY = 0,
  });

  final double halfX;
  final double halfY;
  final double offsetX;
  final double offsetY;
}

/// SoA store for AABB collider config (half extents + offset).
///
/// Collision bounds are distinct from render bounds or hitbox bounds (which are temporary).
class ColliderAabbStore extends SparseSet {
  final List<double> halfX = <double>[];
  final List<double> halfY = <double>[];
  final List<double> offsetX = <double>[];
  final List<double> offsetY = <double>[];

  void add(EntityId entity, ColliderAabbDef def) {
    final i = addEntity(entity);
    halfX[i] = def.halfX;
    halfY[i] = def.halfY;
    offsetX[i] = def.offsetX;
    offsetY[i] = def.offsetY;
  }

  @override
  void onDenseAdded(int denseIndex) {
    halfX.add(0);
    halfY.add(0);
    offsetX.add(0);
    offsetY.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    halfX[removeIndex] = halfX[lastIndex];
    halfY[removeIndex] = halfY[lastIndex];
    offsetX[removeIndex] = offsetX[lastIndex];
    offsetY[removeIndex] = offsetY[lastIndex];

    halfX.removeLast();
    halfY.removeLast();
    offsetX.removeLast();
    offsetY.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/collision_state_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

/// Per-tick collision results for an entity.
///
/// This is reset each tick by the CollisionSystem.
/// These flags track *physical* collision (blocking), not combat hits.
class CollisionStateStore extends SparseSet {
  final List<bool> grounded = <bool>[];
  final List<bool> hitCeiling = <bool>[];
  final List<bool> hitLeft = <bool>[];
  final List<bool> hitRight = <bool>[];

  void add(EntityId entity) {
    addEntity(entity);
  }

  void resetTick(EntityId entity) {
    final i = indexOf(entity);
    grounded[i] = false;
    hitCeiling[i] = false;
    hitLeft[i] = false;
    hitRight[i] = false;
  }

  @override
  void onDenseAdded(int denseIndex) {
    grounded.add(false);
    hitCeiling.add(false);
    hitLeft.add(false);
    hitRight.add(false);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    grounded[removeIndex] = grounded[lastIndex];
    hitCeiling[removeIndex] = hitCeiling[lastIndex];
    hitLeft[removeIndex] = hitLeft[lastIndex];
    hitRight[removeIndex] = hitRight[lastIndex];

    grounded.removeLast();
    hitCeiling.removeLast();
    hitLeft.removeLast();
    hitRight.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/cooldown_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

class CooldownDef {
  const CooldownDef({
    this.castCooldownTicksLeft = 0,
    this.meleeCooldownTicksLeft = 0,
  });

  final int castCooldownTicksLeft;
  final int meleeCooldownTicksLeft;
}

/// Tracks ability cooldowns (ticks remaining).
class CooldownStore extends SparseSet {
  final List<int> castCooldownTicksLeft = <int>[];
  final List<int> meleeCooldownTicksLeft = <int>[];

  void add(EntityId entity, [CooldownDef def = const CooldownDef()]) {
    final i = addEntity(entity);
    castCooldownTicksLeft[i] = def.castCooldownTicksLeft;
    meleeCooldownTicksLeft[i] = def.meleeCooldownTicksLeft;
  }

  @override
  void onDenseAdded(int denseIndex) {
    castCooldownTicksLeft.add(0);
    meleeCooldownTicksLeft.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    castCooldownTicksLeft[removeIndex] = castCooldownTicksLeft[lastIndex];
    meleeCooldownTicksLeft[removeIndex] = meleeCooldownTicksLeft[lastIndex];
    castCooldownTicksLeft.removeLast();
    meleeCooldownTicksLeft.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/enemies/enemy_store.dart =====
import '../../../enemies/enemy_id.dart';
import '../../../snapshots/enums.dart';
import '../../entity_id.dart';
import '../../sparse_set.dart';

class EnemyDef {
  const EnemyDef({
    required this.enemyId,
    this.facing = Facing.left,
  });

  final EnemyId enemyId;
  final Facing facing;
}

/// Minimal enemy marker + per-enemy state.
///
/// Indicates this entity is an enemy and which type it is.
/// Also holds facing direction.
class EnemyStore extends SparseSet {
  final List<EnemyId> enemyId = <EnemyId>[];
  final List<Facing> facing = <Facing>[];

  void add(EntityId entity, EnemyDef def) {
    final i = addEntity(entity);
    enemyId[i] = def.enemyId;
    facing[i] = def.facing;
  }

  @override
  void onDenseAdded(int denseIndex) {
    enemyId.add(EnemyId.flyingEnemy);
    facing.add(Facing.left);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    enemyId[removeIndex] = enemyId[lastIndex];
    facing[removeIndex] = facing[lastIndex];

    enemyId.removeLast();
    facing.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/enemies/flying_enemy_steering_store.dart =====
import '../../entity_id.dart';
import '../../sparse_set.dart';

class FlyingEnemySteeringDef {
  const FlyingEnemySteeringDef({
    required this.rngState,
  });

  final int rngState;
}

/// Per flying enemy steering state for deterministic hover behavior.
///
/// Holds RNG state and smoothed target ranges to make enemies wobble nicely.
class FlyingEnemySteeringStore extends SparseSet {
  final List<int> rngState = <int>[];
  final List<bool> initialized = <bool>[];
  final List<double> desiredRange = <double>[];
  final List<double> desiredRangeHoldLeftS = <double>[];
  final List<double> flightTargetAboveGround = <double>[];
  final List<double> flightTargetHoldLeftS = <double>[];

  void add(EntityId entity, FlyingEnemySteeringDef def) {
    final i = addEntity(entity);
    rngState[i] = def.rngState;
    initialized[i] = false;
    desiredRange[i] = 0.0;
    desiredRangeHoldLeftS[i] = 0.0;
    flightTargetAboveGround[i] = 0.0;
    flightTargetHoldLeftS[i] = 0.0;
  }

  @override
  void onDenseAdded(int denseIndex) {
    rngState.add(1);
    initialized.add(false);
    desiredRange.add(0.0);
    desiredRangeHoldLeftS.add(0.0);
    flightTargetAboveGround.add(0.0);
    flightTargetHoldLeftS.add(0.0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    rngState[removeIndex] = rngState[lastIndex];
    initialized[removeIndex] = initialized[lastIndex];
    desiredRange[removeIndex] = desiredRange[lastIndex];
    desiredRangeHoldLeftS[removeIndex] = desiredRangeHoldLeftS[lastIndex];
    flightTargetAboveGround[removeIndex] = flightTargetAboveGround[lastIndex];
    flightTargetHoldLeftS[removeIndex] = flightTargetHoldLeftS[lastIndex];

    rngState.removeLast();
    initialized.removeLast();
    desiredRange.removeLast();
    desiredRangeHoldLeftS.removeLast();
    flightTargetAboveGround.removeLast();
    flightTargetHoldLeftS.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/enemies/ground_enemy_chase_offset_store.dart =====
import '../../entity_id.dart';
import '../../sparse_set.dart';

class GroundEnemyChaseOffsetDef {
  const GroundEnemyChaseOffsetDef({
    required this.rngState,
  });

  final int rngState;
}

/// Per ground enemy chase offset state for deterministic path separation.
///
/// Ensures multiple enemies don't stack perfectly on top of one another while chasing.
class GroundEnemyChaseOffsetStore extends SparseSet {
  final List<int> rngState = <int>[];
  final List<double> chaseOffsetX = <double>[];
  final List<double> chaseSpeedScale = <double>[];
  final List<bool> initialized = <bool>[];

  void add(EntityId entity, GroundEnemyChaseOffsetDef def) {
    final i = addEntity(entity);
    rngState[i] = def.rngState;
    chaseOffsetX[i] = 0.0;
    chaseSpeedScale[i] = 1.0;
    initialized[i] = false;
  }

  @override
  void onDenseAdded(int denseIndex) {
    rngState.add(1);
    chaseOffsetX.add(0.0);
    chaseSpeedScale.add(1.0);
    initialized.add(false);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    rngState[removeIndex] = rngState[lastIndex];
    chaseOffsetX[removeIndex] = chaseOffsetX[lastIndex];
    chaseSpeedScale[removeIndex] = chaseSpeedScale[lastIndex];
    initialized[removeIndex] = initialized[lastIndex];

    rngState.removeLast();
    chaseOffsetX.removeLast();
    chaseSpeedScale.removeLast();
    initialized.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/enemies/surface_nav_state_store.dart =====
import '../../../navigation/surface_id.dart';
import '../../entity_id.dart';
import '../../sparse_set.dart';

/// Per-entity pathfinding state.
///
/// Tracks the current surface segment, the target segment, and the calculated path edges.
/// Used by `SurfaceNavigationSystem` to move ground enemies.
class SurfaceNavStateStore extends SparseSet {
  final List<int> graphVersion = <int>[];
  final List<int> repathTicksLeft = <int>[];
  final List<int> currentSurfaceId = <int>[];
  final List<int> targetSurfaceId = <int>[];
  final List<int> activeEdgeIndex = <int>[];
  final List<int> pathCursor = <int>[];
  final List<List<int>> pathEdges = <List<int>>[];

  void add(EntityId entity) {
    addEntity(entity);
  }

  @override
  void onDenseAdded(int denseIndex) {
    graphVersion.add(-1);
    repathTicksLeft.add(0);
    currentSurfaceId.add(surfaceIdUnknown);
    targetSurfaceId.add(surfaceIdUnknown);
    activeEdgeIndex.add(-1);
    pathCursor.add(0);
    pathEdges.add(<int>[]);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    graphVersion[removeIndex] = graphVersion[lastIndex];
    repathTicksLeft[removeIndex] = repathTicksLeft[lastIndex];
    currentSurfaceId[removeIndex] = currentSurfaceId[lastIndex];
    targetSurfaceId[removeIndex] = targetSurfaceId[lastIndex];
    activeEdgeIndex[removeIndex] = activeEdgeIndex[lastIndex];
    pathCursor[removeIndex] = pathCursor[lastIndex];
    pathEdges[removeIndex] = pathEdges[lastIndex];

    graphVersion.removeLast();
    repathTicksLeft.removeLast();
    currentSurfaceId.removeLast();
    targetSurfaceId.removeLast();
    activeEdgeIndex.removeLast();
    pathCursor.removeLast();
    pathEdges.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/faction_store.dart =====
import '../../combat/faction.dart';
import '../entity_id.dart';
import '../sparse_set.dart';

class FactionDef {
  const FactionDef({required this.faction});

  final Faction faction;
}

class FactionStore extends SparseSet {
  final List<Faction> faction = <Faction>[];

  void add(EntityId entity, FactionDef def) {
    final i = addEntity(entity);
    faction[i] = def.faction;
  }

  @override
  void onDenseAdded(int denseIndex) {
    // Default to player if not specified.
    faction.add(Faction.player);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    faction[removeIndex] = faction[lastIndex];
    faction.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/health_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

class HealthDef {
  const HealthDef({
    required this.hp,
    required this.hpMax,
    required this.regenPerSecond,
  });

  final double hp;
  final double hpMax;
  final double regenPerSecond;
}

/// Tracks current and max hit points for damageable entities.
class HealthStore extends SparseSet {
  final List<double> hp = <double>[];
  final List<double> hpMax = <double>[];
  final List<double> regenPerSecond = <double>[];

  void add(EntityId entity, HealthDef def) {
    final i = addEntity(entity);
    hp[i] = def.hp;
    hpMax[i] = def.hpMax;
    regenPerSecond[i] = def.regenPerSecond;
  }

  @override
  void onDenseAdded(int denseIndex) {
    hp.add(0);
    hpMax.add(0);
    regenPerSecond.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    hp[removeIndex] = hp[lastIndex];
    hpMax[removeIndex] = hpMax[lastIndex];
    regenPerSecond[removeIndex] = regenPerSecond[lastIndex];

    hp.removeLast();
    hpMax.removeLast();
    regenPerSecond.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/hit_once_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

/// Tracks unique hit targets for a single attack instance (e.g. one swing).
///
/// **Optimization**: Uses inline fields (`hit0`...`hit3`) instead of a `List`
/// to avoid allocation per entity per frame. Saturation limit is 4 targets.
class HitOnceStore extends SparseSet {
  final List<int> count = <int>[];
  final List<EntityId> hit0 = <EntityId>[];
  final List<EntityId> hit1 = <EntityId>[];
  final List<EntityId> hit2 = <EntityId>[];
  final List<EntityId> hit3 = <EntityId>[];

  void add(EntityId entity) {
    addEntity(entity);
  }

  bool hasHit(EntityId entity, EntityId target) {
    final i = indexOf(entity);
    final c = count[i];
    if (c > 4) return true; // saturated: treat as "already hit everything"
    if (c <= 0) return false;
    if (hit0[i] == target) return true;
    if (c <= 1) return false;
    if (hit1[i] == target) return true;
    if (c <= 2) return false;
    if (hit2[i] == target) return true;
    if (c <= 3) return false;
    return hit3[i] == target;
  }

  void markHit(EntityId entity, EntityId target) {
    final i = indexOf(entity);
    var c = count[i];
    if (c > 4) return; // already saturated
    if (c <= 0) {
      hit0[i] = target;
      count[i] = 1;
      return;
    }
    if (c == 1) {
      hit1[i] = target;
      count[i] = 2;
      return;
    }
    if (c == 2) {
      hit2[i] = target;
      count[i] = 3;
      return;
    }
    if (c == 3) {
      hit3[i] = target;
      count[i] = 4;
      return;
    }
    // We don't expect more than 4 hits per swing.
    //
    // IMPORTANT (determinism + safety): once saturated, treat as "already hit"
    // for any target so a single swing cannot multi-hit due to overflow.
    count[i] = 5;
  }

  @override
  void onDenseAdded(int denseIndex) {
    count.add(0);
    hit0.add(0);
    hit1.add(0);
    hit2.add(0);
    hit3.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    count[removeIndex] = count[lastIndex];
    hit0[removeIndex] = hit0[lastIndex];
    hit1[removeIndex] = hit1[lastIndex];
    hit2[removeIndex] = hit2[lastIndex];
    hit3[removeIndex] = hit3[lastIndex];

    count.removeLast();
    hit0.removeLast();
    hit1.removeLast();
    hit2.removeLast();
    hit3.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/hitbox_store.dart =====
import '../../combat/faction.dart';
import '../entity_id.dart';
import '../sparse_set.dart';

class HitboxDef {
  const HitboxDef({
    required this.owner,
    required this.faction,
    required this.damage,
    required this.halfX,
    required this.halfY,
    required this.offsetX,
    required this.offsetY,
    required this.dirX,
    required this.dirY,
  });

  final EntityId owner;
  final Faction faction;
  final double damage;
  final double halfX;
  final double halfY;
  final double offsetX;
  final double offsetY;
  final double dirX;
  final double dirY;
}

/// Short-lived damage hitbox used by melee attacks and area effects.
///
/// These entities usually exist for only a few frames (attack windows).
/// They are queried by `HitboxDamageSystem`.
class HitboxStore extends SparseSet {
  final List<EntityId> owner = <EntityId>[];
  final List<Faction> faction = <Faction>[];
  final List<double> damage = <double>[];
  final List<double> halfX = <double>[];
  final List<double> halfY = <double>[];
  final List<double> offsetX = <double>[];
  final List<double> offsetY = <double>[];
  final List<double> dirX = <double>[];
  final List<double> dirY = <double>[];

  void add(EntityId entity, HitboxDef def) {
    final i = addEntity(entity);
    owner[i] = def.owner;
    faction[i] = def.faction;
    damage[i] = def.damage;
    halfX[i] = def.halfX;
    halfY[i] = def.halfY;
    offsetX[i] = def.offsetX;
    offsetY[i] = def.offsetY;
    dirX[i] = def.dirX;
    dirY[i] = def.dirY;
  }

  @override
  void onDenseAdded(int denseIndex) {
    owner.add(0);
    faction.add(Faction.player);
    damage.add(0);
    halfX.add(0);
    halfY.add(0);
    offsetX.add(0);
    offsetY.add(0);
    dirX.add(1.0);
    dirY.add(0.0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    owner[removeIndex] = owner[lastIndex];
    faction[removeIndex] = faction[lastIndex];
    damage[removeIndex] = damage[lastIndex];
    halfX[removeIndex] = halfX[lastIndex];
    halfY[removeIndex] = halfY[lastIndex];
    offsetX[removeIndex] = offsetX[lastIndex];
    offsetY[removeIndex] = offsetY[lastIndex];
    dirX[removeIndex] = dirX[lastIndex];
    dirY[removeIndex] = dirY[lastIndex];

    owner.removeLast();
    faction.removeLast();
    damage.removeLast();
    halfX.removeLast();
    halfY.removeLast();
    offsetX.removeLast();
    offsetY.removeLast();
    dirX.removeLast();
    dirY.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/lifetime_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

class LifetimeDef {
  const LifetimeDef({required this.ticksLeft});

  final int ticksLeft;
}

/// Tracks entity lifetime in ticks. Entity is despawned when `ticksLeft <= 0`.
class LifetimeStore extends SparseSet {
  final List<int> ticksLeft = <int>[];

  void add(EntityId entity, LifetimeDef def) {
    final i = addEntity(entity);
    ticksLeft[i] = def.ticksLeft;
  }

  @override
  void onDenseAdded(int denseIndex) {
    ticksLeft.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    ticksLeft[removeIndex] = ticksLeft[lastIndex];
    ticksLeft.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/mana_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

class ManaDef {
  const ManaDef({
    required this.mana,
    required this.manaMax,
    required this.regenPerSecond,
  });

  final double mana;
  final double manaMax;
  final double regenPerSecond;
}

/// Tracks current and max mana for spellcasters (Player).
class ManaStore extends SparseSet {
  final List<double> mana = <double>[];
  final List<double> manaMax = <double>[];
  final List<double> regenPerSecond = <double>[];

  void add(EntityId entity, ManaDef def) {
    final i = addEntity(entity);
    mana[i] = def.mana;
    manaMax[i] = def.manaMax;
    regenPerSecond[i] = def.regenPerSecond;
  }

  @override
  void onDenseAdded(int denseIndex) {
    mana.add(0);
    manaMax.add(0);
    regenPerSecond.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    mana[removeIndex] = mana[lastIndex];
    manaMax[removeIndex] = manaMax[lastIndex];
    regenPerSecond[removeIndex] = regenPerSecond[lastIndex];

    mana.removeLast();
    manaMax.removeLast();
    regenPerSecond.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/melee_intent_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

class MeleeIntentDef {
  const MeleeIntentDef({
    required this.damage,
    required this.halfX,
    required this.halfY,
    required this.offsetX,
    required this.offsetY,
    required this.dirX,
    required this.dirY,
    required this.activeTicks,
    required this.cooldownTicks,
    required this.staminaCost,
    required this.tick,
  });

  final double damage;
  final double halfX;
  final double halfY;
  final double offsetX;
  final double offsetY;
  final double dirX;
  final double dirY;
  final int activeTicks;
  final int cooldownTicks;
  final double staminaCost;

  /// Tick stamp for this intent.
  ///
  /// Use `-1` for "no intent". An intent is valid only when `tick == currentTick`.
  final int tick;
}

/// Per-entity "perform a melee attack this tick" intent.
///
/// This is written by player/enemy intent writers and consumed by `MeleeAttackSystem`.
///
/// **Usage**: Persistent component. Intents are set via `set()` with a `tick` stamp.
/// Old intents are ignored if `tick` matches current game tick.
class MeleeIntentStore extends SparseSet {
  final List<double> damage = <double>[];
  final List<double> halfX = <double>[];
  final List<double> halfY = <double>[];
  final List<double> offsetX = <double>[];
  final List<double> offsetY = <double>[];
  final List<double> dirX = <double>[];
  final List<double> dirY = <double>[];
  final List<int> activeTicks = <int>[];
  final List<int> cooldownTicks = <int>[];
  final List<double> staminaCost = <double>[];
  final List<int> tick = <int>[];

  void add(EntityId entity) {
    addEntity(entity);
  }

  void set(EntityId entity, MeleeIntentDef def) {
    assert(
      has(entity),
      'MeleeIntentStore.set called for entity without MeleeIntentStore; add the component at spawn time.',
    );
    final i = indexOf(entity);
    damage[i] = def.damage;
    halfX[i] = def.halfX;
    halfY[i] = def.halfY;
    offsetX[i] = def.offsetX;
    offsetY[i] = def.offsetY;
    dirX[i] = def.dirX;
    dirY[i] = def.dirY;
    activeTicks[i] = def.activeTicks;
    cooldownTicks[i] = def.cooldownTicks;
    staminaCost[i] = def.staminaCost;
    tick[i] = def.tick;
  }

  @override
  void onDenseAdded(int denseIndex) {
    damage.add(0.0);
    halfX.add(0.0);
    halfY.add(0.0);
    offsetX.add(0.0);
    offsetY.add(0.0);
    dirX.add(1.0);
    dirY.add(0.0);
    activeTicks.add(0);
    cooldownTicks.add(0);
    staminaCost.add(0.0);
    tick.add(-1);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    damage[removeIndex] = damage[lastIndex];
    halfX[removeIndex] = halfX[lastIndex];
    halfY[removeIndex] = halfY[lastIndex];
    offsetX[removeIndex] = offsetX[lastIndex];
    offsetY[removeIndex] = offsetY[lastIndex];
    dirX[removeIndex] = dirX[lastIndex];
    dirY[removeIndex] = dirY[lastIndex];
    activeTicks[removeIndex] = activeTicks[lastIndex];
    cooldownTicks[removeIndex] = cooldownTicks[lastIndex];
    staminaCost[removeIndex] = staminaCost[lastIndex];
    tick[removeIndex] = tick[lastIndex];

    damage.removeLast();
    halfX.removeLast();
    halfY.removeLast();
    offsetX.removeLast();
    offsetY.removeLast();
    dirX.removeLast();
    dirY.removeLast();
    activeTicks.removeLast();
    cooldownTicks.removeLast();
    staminaCost.removeLast();
    tick.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/player/gravity_control_store.dart =====
import '../../entity_id.dart';
import '../../sparse_set.dart';

/// Tracks entities that are temporarily ignoring global gravity.
///
/// Used by movement skills (e.g. Dash) to keep the player straight.
/// Entities are removed from this store when `suppressGravityTicksLeft` hits 0.
class GravityControlStore extends SparseSet {
  final List<int> suppressGravityTicksLeft = <int>[];

  void setSuppressForTicks(EntityId entity, int ticks) {
    if (ticks <= 0) {
      removeEntity(entity);
      return;
    }

    final i = addEntity(entity);
    suppressGravityTicksLeft[i] = ticks;
  }

  @override
  void onDenseAdded(int denseIndex) {
    suppressGravityTicksLeft.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    suppressGravityTicksLeft[removeIndex] = suppressGravityTicksLeft[lastIndex];
    suppressGravityTicksLeft.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/player/invulnerability_store.dart =====
import '../../entity_id.dart';
import '../../sparse_set.dart';

class InvulnerabilityDef {
  const InvulnerabilityDef({this.ticksLeft = 0});

  final int ticksLeft;
}

/// Per-entity invulnerability window after taking damage.
///
/// This store is only attached to the player (no enemy i-frames).
class InvulnerabilityStore extends SparseSet {
  final List<int> ticksLeft = <int>[];

  void add(EntityId entity, [InvulnerabilityDef def = const InvulnerabilityDef()]) {
    final i = addEntity(entity);
    ticksLeft[i] = def.ticksLeft;
  }

  @override
  void onDenseAdded(int denseIndex) {
    ticksLeft.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    ticksLeft[removeIndex] = ticksLeft[lastIndex];
    ticksLeft.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/player/last_damage_store.dart =====
import '../../../enemies/enemy_id.dart';
import '../../../events/game_event.dart';
import '../../../projectiles/projectile_id.dart';
import '../../../spells/spell_id.dart';
import '../../entity_id.dart';
import '../../sparse_set.dart';

/// Per-entity record of the last applied damage metadata.
///
/// Used to populate the "Game Over" screen with cause of death.
class LastDamageStore extends SparseSet {
  final List<DeathSourceKind> kind = <DeathSourceKind>[];
  final List<EnemyId> enemyId = <EnemyId>[];
  final List<bool> hasEnemyId = <bool>[];
  final List<ProjectileId> projectileId = <ProjectileId>[];
  final List<bool> hasProjectileId = <bool>[];
  final List<SpellId> spellId = <SpellId>[];
  final List<bool> hasSpellId = <bool>[];
  final List<double> amount = <double>[];
  final List<int> tick = <int>[];

  void add(EntityId entity) {
    addEntity(entity);
  }

  @override
  void onDenseAdded(int denseIndex) {
    kind.add(DeathSourceKind.unknown);
    enemyId.add(EnemyId.flyingEnemy);
    hasEnemyId.add(false);
    projectileId.add(ProjectileId.iceBolt);
    hasProjectileId.add(false);
    spellId.add(SpellId.iceBolt);
    hasSpellId.add(false);
    amount.add(0.0);
    tick.add(-1);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    kind[removeIndex] = kind[lastIndex];
    enemyId[removeIndex] = enemyId[lastIndex];
    hasEnemyId[removeIndex] = hasEnemyId[lastIndex];
    projectileId[removeIndex] = projectileId[lastIndex];
    hasProjectileId[removeIndex] = hasProjectileId[lastIndex];
    spellId[removeIndex] = spellId[lastIndex];
    hasSpellId[removeIndex] = hasSpellId[lastIndex];
    amount[removeIndex] = amount[lastIndex];
    tick[removeIndex] = tick[lastIndex];

    kind.removeLast();
    enemyId.removeLast();
    hasEnemyId.removeLast();
    projectileId.removeLast();
    hasProjectileId.removeLast();
    spellId.removeLast();
    hasSpellId.removeLast();
    amount.removeLast();
    tick.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/player/movement_store.dart =====
import '../../../snapshots/enums.dart';
import '../../entity_id.dart';
import '../../sparse_set.dart';

/// Movement state for platformer-style motion (timers + grounded + facing).
///
/// Contains transient state counters for precise movement tech:
/// - Coyote time (jump after leaving ledge)
/// - Jump buffer (press before landing)
/// - Dash state
class MovementStore extends SparseSet {
  final List<int> coyoteTicksLeft = <int>[];
  final List<int> jumpBufferTicksLeft = <int>[];

  final List<int> dashTicksLeft = <int>[];
  final List<int> dashCooldownTicksLeft = <int>[];
  final List<double> dashDirX = <double>[];

  final List<Facing> facing = <Facing>[];

  void add(EntityId entity, {required Facing facing}) {
    final i = addEntity(entity);
    this.facing[i] = facing;
  }

  bool isDashing(EntityId entity) => dashTicksLeft[indexOf(entity)] > 0;

  @override
  void onDenseAdded(int denseIndex) {
    coyoteTicksLeft.add(0);
    jumpBufferTicksLeft.add(0);
    dashTicksLeft.add(0);
    dashCooldownTicksLeft.add(0);
    dashDirX.add(1);
    facing.add(Facing.right);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    coyoteTicksLeft[removeIndex] = coyoteTicksLeft[lastIndex];
    jumpBufferTicksLeft[removeIndex] = jumpBufferTicksLeft[lastIndex];
    dashTicksLeft[removeIndex] = dashTicksLeft[lastIndex];
    dashCooldownTicksLeft[removeIndex] = dashCooldownTicksLeft[lastIndex];
    dashDirX[removeIndex] = dashDirX[lastIndex];
    facing[removeIndex] = facing[lastIndex];

    coyoteTicksLeft.removeLast();
    jumpBufferTicksLeft.removeLast();
    dashTicksLeft.removeLast();
    dashCooldownTicksLeft.removeLast();
    dashDirX.removeLast();
    facing.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/player/player_input_store.dart =====
import '../../entity_id.dart';
import '../../sparse_set.dart';

/// Per-tick player input (authoritative commands decoded by the core).
///
/// This is reset/overwritten each tick by `GameCore.applyCommands`.
/// All actions are boolean or axis values used by `MovementSystem` and decision systems.
class PlayerInputStore extends SparseSet {
  final List<double> moveAxis = <double>[];
  final List<bool> jumpPressed = <bool>[];
  final List<bool> dashPressed = <bool>[];
  final List<bool> attackPressed = <bool>[];
  final List<double> projectileAimDirX = <double>[];
  final List<double> projectileAimDirY = <double>[];
  final List<double> meleeAimDirX = <double>[];
  final List<double> meleeAimDirY = <double>[];
  final List<bool> castPressed = <bool>[];

  void add(EntityId entity) {
    addEntity(entity);
  }

  void resetTickInputs(EntityId entity) {
    final i = indexOf(entity);
    moveAxis[i] = 0;
    jumpPressed[i] = false;
    dashPressed[i] = false;
    attackPressed[i] = false;
    projectileAimDirX[i] = 0;
    projectileAimDirY[i] = 0;
    meleeAimDirX[i] = 0;
    meleeAimDirY[i] = 0;
    castPressed[i] = false;
  }

  @override
  void onDenseAdded(int denseIndex) {
    moveAxis.add(0);
    jumpPressed.add(false);
    dashPressed.add(false);
    attackPressed.add(false);
    projectileAimDirX.add(0);
    projectileAimDirY.add(0);
    meleeAimDirX.add(0);
    meleeAimDirY.add(0);
    castPressed.add(false);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    moveAxis[removeIndex] = moveAxis[lastIndex];
    jumpPressed[removeIndex] = jumpPressed[lastIndex];
    dashPressed[removeIndex] = dashPressed[lastIndex];
    attackPressed[removeIndex] = attackPressed[lastIndex];
    projectileAimDirX[removeIndex] = projectileAimDirX[lastIndex];
    projectileAimDirY[removeIndex] = projectileAimDirY[lastIndex];
    meleeAimDirX[removeIndex] = meleeAimDirX[lastIndex];
    meleeAimDirY[removeIndex] = meleeAimDirY[lastIndex];
    castPressed[removeIndex] = castPressed[lastIndex];

    moveAxis.removeLast();
    jumpPressed.removeLast();
    dashPressed.removeLast();
    attackPressed.removeLast();
    projectileAimDirX.removeLast();
    projectileAimDirY.removeLast();
    meleeAimDirX.removeLast();
    meleeAimDirY.removeLast();
    castPressed.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/projectile_store.dart =====
import '../../combat/faction.dart';
import '../../projectiles/projectile_id.dart';
import '../entity_id.dart';
import '../sparse_set.dart';

class ProjectileDef {
  const ProjectileDef({
    required this.projectileId,
    required this.faction,
    required this.owner,
    required this.dirX,
    required this.dirY,
    required this.speedUnitsPerSecond,
    required this.damage,
  });

  final ProjectileId projectileId;
  final Faction faction;
  final EntityId owner;
  final double dirX;
  final double dirY;
  final double speedUnitsPerSecond;
  final double damage;
}

/// Immutable metadata for active projectiles.
///
/// Combines with `Transform` (for position) and `ColliderAabb` (for hit detection).
class ProjectileStore extends SparseSet {
  final List<ProjectileId> projectileId = <ProjectileId>[];
  final List<Faction> faction = <Faction>[];
  final List<EntityId> owner = <EntityId>[];
  final List<double> dirX = <double>[];
  final List<double> dirY = <double>[];
  final List<double> speedUnitsPerSecond = <double>[];
  final List<double> damage = <double>[];

  void add(EntityId entity, ProjectileDef def) {
    final i = addEntity(entity);
    projectileId[i] = def.projectileId;
    faction[i] = def.faction;
    owner[i] = def.owner;
    dirX[i] = def.dirX;
    dirY[i] = def.dirY;
    speedUnitsPerSecond[i] = def.speedUnitsPerSecond;
    damage[i] = def.damage;
  }

  @override
  void onDenseAdded(int denseIndex) {
    projectileId.add(ProjectileId.iceBolt);
    faction.add(Faction.player);
    owner.add(0);
    dirX.add(1.0);
    dirY.add(0.0);
    speedUnitsPerSecond.add(0.0);
    damage.add(0.0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    projectileId[removeIndex] = projectileId[lastIndex];
    faction[removeIndex] = faction[lastIndex];
    owner[removeIndex] = owner[lastIndex];
    dirX[removeIndex] = dirX[lastIndex];
    dirY[removeIndex] = dirY[lastIndex];
    speedUnitsPerSecond[removeIndex] = speedUnitsPerSecond[lastIndex];
    damage[removeIndex] = damage[lastIndex];

    projectileId.removeLast();
    faction.removeLast();
    owner.removeLast();
    dirX.removeLast();
    dirY.removeLast();
    speedUnitsPerSecond.removeLast();
    damage.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/restoration_item_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

enum RestorationStat {
  health,
  mana,
  stamina,
}

class RestorationItemDef {
  const RestorationItemDef({required this.stat});

  final RestorationStat stat;
}

/// SoA store for restoration item metadata (health/mana/stamina).
class RestorationItemStore extends SparseSet {
  final List<RestorationStat> stat = <RestorationStat>[];

  void add(EntityId entity, RestorationItemDef def) {
    final i = addEntity(entity);
    stat[i] = def.stat;
  }

  @override
  void onDenseAdded(int denseIndex) {
    stat.add(RestorationStat.health);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    stat[removeIndex] = stat[lastIndex];
    stat.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/spell_origin_store.dart =====
import '../../spells/spell_id.dart';
import '../entity_id.dart';
import '../sparse_set.dart';

class SpellOriginDef {
  const SpellOriginDef({required this.spellId});

  final SpellId spellId;
}

/// Metadata for spell projectile entities (spawned by CastIntent).
class SpellOriginStore extends SparseSet {
  final List<SpellId> spellId = <SpellId>[];

  void add(EntityId entity, SpellOriginDef def) {
    final i = addEntity(entity);
    spellId[i] = def.spellId;
  }

  @override
  void onDenseAdded(int denseIndex) {
    spellId.add(SpellId.iceBolt);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    spellId[removeIndex] = spellId[lastIndex];
    spellId.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/stamina_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

class StaminaDef {
  const StaminaDef({
    required this.stamina,
    required this.staminaMax,
    required this.regenPerSecond,
  });

  final double stamina;
  final double staminaMax;
  final double regenPerSecond;
}

/// Tracks stamina for dashing and melee attacks.
class StaminaStore extends SparseSet {
  final List<double> stamina = <double>[];
  final List<double> staminaMax = <double>[];
  final List<double> regenPerSecond = <double>[];

  void add(EntityId entity, StaminaDef def) {
    final i = addEntity(entity);
    stamina[i] = def.stamina;
    staminaMax[i] = def.staminaMax;
    regenPerSecond[i] = def.regenPerSecond;
  }

  @override
  void onDenseAdded(int denseIndex) {
    stamina.add(0);
    staminaMax.add(0);
    regenPerSecond.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    stamina[removeIndex] = stamina[lastIndex];
    staminaMax[removeIndex] = staminaMax[lastIndex];
    regenPerSecond[removeIndex] = regenPerSecond[lastIndex];

    stamina.removeLast();
    staminaMax.removeLast();
    regenPerSecond.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/transform_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

/// SoA store for `Transform` (position + velocity).
///
/// This is the "hot" store accessed by almost every system.
class TransformStore extends SparseSet {
  final List<double> posX = <double>[];
  final List<double> posY = <double>[];
  final List<double> velX = <double>[];
  final List<double> velY = <double>[];

  void add(
    EntityId entity, {
    required double posX,
    required double posY,
    required double velX,
    required double velY,
  }) {
    final i = addEntity(entity);
    this.posX[i] = posX;
    this.posY[i] = posY;
    this.velX[i] = velX;
    this.velY[i] = velY;
  }

  void setPosXY(EntityId entity, double x, double y) {
    final i = indexOf(entity);
    posX[i] = x;
    posY[i] = y;
  }

  void setVelXY(EntityId entity, double x, double y) {
    final i = indexOf(entity);
    velX[i] = x;
    velY[i] = y;
  }

  @override
  void onDenseAdded(int denseIndex) {
    posX.add(0);
    posY.add(0);
    velX.add(0);
    velY.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    posX[removeIndex] = posX[lastIndex];
    posY[removeIndex] = posY[lastIndex];
    velX[removeIndex] = velX[lastIndex];
    velY[removeIndex] = velY[lastIndex];

    posX.removeLast();
    posY.removeLast();
    velX.removeLast();
    velY.removeLast();
  }
}


===== FILE: lib/core/ecs/systems/collectible_system.dart =====
import '../hit/aabb_hit_utils.dart';
import '../entity_id.dart';
import '../world.dart';
import '../../tuning/collectible_tuning.dart';

/// System responsible for updating collectible entities (e.g. coins).
///
/// It handles:
/// 1. Despawning collectibles that have fallen behind the camera.
/// 2. Detecting collisions between the player and collectibles.
/// 3. Triggering collection callbacks and destroying collected entities.
class CollectibleSystem {
  // Recycled list to avoid per-frame allocations for destruction.
  final List<EntityId> _toDespawn = <EntityId>[];

  /// Updates all collectibles.
  ///
  /// [cameraLeft] is the world-space X coordinate of the left edge of the camera,
  /// used for culling entities that are no longer visible.
  void step(
    EcsWorld world, {
    required EntityId player,
    required double cameraLeft,
    required CollectibleTuning tuning,
    required void Function(int value) onCollected,
  }) {
    final collectibles = world.collectible;
    if (collectibles.denseEntities.isEmpty) return;

    // Pre-resolve player components to avoid looking them up for every collectible.
    final playerTi = world.transform.tryIndexOf(player);
    final playerAi = world.colliderAabb.tryIndexOf(player);
    final canCollect = playerTi != null && playerAi != null;

    _toDespawn.clear();

    final despawnLimit = cameraLeft - tuning.despawnBehindCameraMargin;
    for (var ci = 0; ci < collectibles.denseEntities.length; ci += 1) {
      final e = collectibles.denseEntities[ci];
      final ti = world.transform.tryIndexOf(e);
      final ai = world.colliderAabb.tryIndexOf(e);
      // Skip if entity is missing required components (malformed entity).
      if (ti == null || ai == null) continue;

      final centerX = world.transform.posX[ti] + world.colliderAabb.offsetX[ai];
      
      // 1. Culling: Despawn if far behind the camera.
      if (centerX < despawnLimit) {
        _toDespawn.add(e);
        continue;
      }

      // 2. Collection: Check AABB overlap with player.
      if (canCollect) {
        final overlaps = aabbOverlapsWorldColliders(
          world,
          aTransformIndex: ti,
          aAabbIndex: ai,
          bTransformIndex: playerTi,
          bAabbIndex: playerAi,
        );
        if (overlaps) {
          onCollected(collectibles.value[ci]);
          _toDespawn.add(e);
        }
      }
    }

    // Apply deferred destruction.
    for (final e in _toDespawn) {
      world.destroyEntity(e);
    }
  }
}


===== FILE: lib/core/ecs/systems/collision_system.dart =====
import '../../collision/static_world_geometry_index.dart';
import '../../tuning/movement_tuning.dart';
import '../queries.dart';
import '../stores/body_store.dart';
import '../world.dart';

/// Handles physics integration and collision resolution for dynamic entities.
///
/// This system operates in three main steps:
/// 1.  **Integration**: Updates position based on velocity (`pos += vel * dt`).
/// 2.  **Vertical Resolution**:
///     -   Checks floors (ground segments and one-way platforms).
///     -   Checks ceilings (if not ignored).
///     -   Snaps position to the contact surface and zeroes vertical velocity.
/// 3.  **Horizontal Resolution**:
///     -   Checks walls in the direction of movement.
///     -   Stops horizontal movement upon collision.
///
/// Order within a tick:
/// - PlayerMovementSystem computes control velocities (jump/dash/horizontal).
/// - GravitySystem applies vertical gravity acceleration.
/// - CollisionSystem integrates `pos += vel * dt`, resolves collisions, and
///   finalizes grounded/contact state for the tick.
class CollisionSystem {
  // Reusable buffers to avoid allocations during collision queries.
  final List<StaticSolid> _queryBuffer = <StaticSolid>[];
  final List<StaticGroundSegment> _groundSegBuffer = <StaticGroundSegment>[];

  /// Runs the physics update for one tick.
  ///
  /// [tuning] provides the delta time [dtSeconds].
  /// [staticWorld] is the spatial index for static geometry (floors, walls).
  void step(
    EcsWorld world,
    MovementTuningDerived tuning, {
    required StaticWorldGeometryIndex staticWorld,
  }) {
    final dt = tuning.dtSeconds;
    // Epsilon for floating point comparisons and overlap tolerance.
    const eps = 1e-3;

    EcsQueries.forColliders(world, (e, ti, bi, coli, aabbi) {
      if (!world.body.enabled[bi]) return;

      // Reset per-tick collision flags (grounded, hitCeiling, etc.).
      world.collision.resetTick(e);

      // Kinematic bodies are excluded from physics integration/resolution.
      // They are moved manually by other systems.
      if (world.body.isKinematic[bi]) {
        return;
      }


      final prevPosX = world.transform.posX[ti];
      final prevPosY = world.transform.posY[ti];

      // Integrate position from the current velocity.
      world.transform.posX[ti] += world.transform.velX[ti] * dt;
      world.transform.posY[ti] += world.transform.velY[ti] * dt;

      final halfX = world.colliderAabb.halfX[aabbi];
      final halfY = world.colliderAabb.halfY[aabbi];
      final offsetX = world.colliderAabb.offsetX[aabbi];
      final offsetY = world.colliderAabb.offsetY[aabbi];

      final prevCenterX = prevPosX + offsetX;
      final prevCenterY = prevPosY + offsetY;
      final prevBottom = prevCenterY + halfY;

      final centerX = world.transform.posX[ti] + offsetX;
      final centerY = world.transform.posY[ti] + offsetY;
      final minX = centerX - halfX;
      final maxX = centerX + halfX;
      final bottom = centerY + halfY;
      final top = centerY - halfY;

      // Vertical top resolution (one-way platforms): only while moving downward.
      double? bestTopY;
      if (world.transform.velY[ti] > 0) {
        _queryBuffer.clear();
        staticWorld.queryTops(minX + eps, maxX - eps, _queryBuffer);
        for (final solid in _queryBuffer) {
          final topY = solid.minY;
          final crossesTop =
              prevBottom <= topY + eps && bottom >= topY - eps;
          if (!crossesTop) continue;

          //if (solid.oneWayTop == false) {
            // Fully solid top surface; same resolution as one-way, just without
            // any additional gating.
          //}

          if (bestTopY == null || topY < bestTopY) {
            bestTopY = topY;
          }
        }
      }

      // Check ceilings.
      // Only resolve if moving upward and the body collides with ceilings.
      double? bestBottomY;
      if (world.transform.velY[ti] < 0 && !world.body.ignoreCeilings[bi]) {
        final prevTop = prevCenterY - halfY;
        _queryBuffer.clear();
        staticWorld.queryBottoms(minX + eps, maxX - eps, _queryBuffer);
        for (final solid in _queryBuffer) {
          final bottomY = solid.maxY;
          // Check if we crossed the surface from below to above.
          final crossesBottom =
              prevTop >= bottomY - eps && top <= bottomY + eps;
          if (!crossesBottom) continue;

          // Keep the lowest ceiling (maximum Y) encountered.
          if (bestBottomY == null || bottomY > bestBottomY) {
            bestBottomY = bottomY;
          }
        }
      }

      // Check Ground Segments (optimized horizontal strips for ground).
      // Treated same as one-way platforms.
      if (world.transform.velY[ti] > 0) {
        _groundSegBuffer.clear();
        staticWorld.queryGroundSegments(minX + eps, maxX - eps, _groundSegBuffer);
        for (final seg in _groundSegBuffer) {
          final groundTopY = seg.topY;
          final crossesTop =
              prevBottom <= groundTopY + eps && bottom >= groundTopY - eps;
          if (!crossesTop) continue;
          
          if (bestTopY == null || groundTopY < bestTopY) {
            bestTopY = groundTopY;
          }
        }
      }

      // Apply vertical resolution.
      if (bestTopY != null) {
        // Landed on floor.
        world.transform.posY[ti] = bestTopY - offsetY - halfY;
        if (world.transform.velY[ti] > 0) {
          world.transform.velY[ti] = 0;
        }
        world.collision.grounded[coli] = true;
      } else if (bestBottomY != null) {
        // Hit ceiling.
        world.transform.posY[ti] = bestBottomY - offsetY + halfY;
        if (world.transform.velY[ti] < 0) {
          world.transform.velY[ti] = 0;
        }
        world.collision.hitCeiling[coli] = true;
      }

      // Horizontal Resolution
      // Recompute AABB after vertical resolution for stable side overlap tests.
      // This prevents "snagging" on walls due to slight vertical overlap that should have been resolved.
      final resolvedCenterX = world.transform.posX[ti] + offsetX;
      final resolvedCenterY = world.transform.posY[ti] + offsetY;
      final resolvedMinY = resolvedCenterY - halfY;
      final resolvedMaxY = resolvedCenterY + halfY;

      // Resolve against static walls.
      final sideMask = world.body.sideMask[bi];
      final velX = world.transform.velX[ti];

      if (velX > 0 && (sideMask &  BodyDef.sideRight) != 0) {
        // Moving Right.
        final prevRight = prevCenterX + halfX;
        final right = resolvedCenterX + halfX;
        double? bestWallX;

        _queryBuffer.clear();
        staticWorld.queryLeftWalls(prevRight - eps, right + eps, _queryBuffer);

        for (final solid in _queryBuffer) {
          // Filter by vertical overlap (y-axis).
          final overlapY =
              resolvedMaxY > solid.minY + eps && resolvedMinY < solid.maxY - eps;
          if (!overlapY) continue;

          final wallX = solid.minX;
          // Check if we crossed the wall line.
          final crossesWall = prevRight <= wallX + eps && right >= wallX - eps;
          if (!crossesWall) continue;

          if (bestWallX == null || wallX < bestWallX) {
            bestWallX = wallX;
          }
        }

        if (bestWallX != null) {
          // Hit right wall.
          world.transform.posX[ti] = bestWallX - offsetX - halfX;
          world.transform.velX[ti] = 0;
          world.collision.hitRight[coli] = true;
        }
      } else if (velX < 0 && (sideMask & BodyDef.sideLeft) != 0) {
        // Moving Left.
        final prevLeft = prevCenterX - halfX;
        final left = resolvedCenterX - halfX;
        double? bestWallX;

        _queryBuffer.clear();
        staticWorld.queryRightWalls(left - eps, prevLeft + eps, _queryBuffer);

        for (final solid in _queryBuffer) {
          // Filter by vertical overlap (y-axis).
          final overlapY =
              resolvedMaxY > solid.minY + eps && resolvedMinY < solid.maxY - eps;
          if (!overlapY) continue;

          final wallX = solid.maxX;
          // Check if we crossed the wall line from right to left.
          final crossesWall = prevLeft >= wallX - eps && left <= wallX + eps;
          if (!crossesWall) continue;

          // Keep the rightmost wall (maximum X) encountered.
          if (bestWallX == null || wallX > bestWallX) {
            bestWallX = wallX;
          }
        }

        if (bestWallX != null) {
          // Hit left wall.
          world.transform.posX[ti] = bestWallX - offsetX + halfX;
          world.transform.velX[ti] = 0;
          world.collision.hitLeft[coli] = true;
        }
      }
    });
  }
}


===== FILE: lib/core/ecs/systems/cooldown_system.dart =====
import '../world.dart';

/// Decrements active action cooldowns (melee, cast) for all entities each tick.
class CooldownSystem {
  /// Runs the cooldown logic.
  ///
  /// Iterates over all entities with a [CooldownStore] and reduces their
  /// remaining tick counts by 1, clamping at 0.
  void step(EcsWorld world) {
    final store = world.cooldown;
    // Iterate over dense arrays for cache efficiency.
    for (var i = 0; i < store.denseEntities.length; i += 1) {
      if (store.castCooldownTicksLeft[i] > 0) {
        store.castCooldownTicksLeft[i] -= 1;
      }
      if (store.meleeCooldownTicksLeft[i] > 0) {
        store.meleeCooldownTicksLeft[i] -= 1;
      }
    }
  }
}


===== FILE: lib/core/ecs/systems/damage_system.dart =====
import '../../combat/damage.dart';
import '../../util/double_math.dart';
import '../world.dart';

/// Central system for validating and applying damage to entities.
///
/// Handles:
/// 1.  Processing queued [DamageRequest]s.
/// 2.  Checking invulnerability frames (i-frames).
/// 3.  Reducing [HealthStore] HP.
/// 4.  Recording [LastDamageStore] details (source, amount) for UI/logic.
/// 5.  Applying post-hit invulnerability.
class DamageSystem {
  DamageSystem({required this.invulnerabilityTicksOnHit});

  /// Number of ticks an entity is invulnerable after taking damage.
  final int invulnerabilityTicksOnHit;
  
  // Buffer for damage requests to be processed in `step`.
  final List<DamageRequest> _pending = <DamageRequest>[];

  /// Queues a damage request for the next frame.
  ///
  /// Requests with `amount <= 0` are ignored immediately.
  void queue(DamageRequest request) {
    if (request.amount <= 0) return;
    _pending.add(request);
  }

  /// Processes all pending damage requests.
  void step(EcsWorld world, {required int currentTick}) {
    if (_pending.isEmpty) return;

    final health = world.health;
    final invuln = world.invulnerability;
    final lastDamage = world.lastDamage;
    
    for (final req in _pending) {
      // 1. Resolve Health component.
      // Use tryIndexOf (returns int?) to combine "has check" and "get index"
      // into a single lookup for performance.
      final hi = health.tryIndexOf(req.target);
      if (hi == null) continue;

      // 2. Resolve Invulnerability component (optional).
      final ii = invuln.tryIndexOf(req.target);

      // Invulnerability applies only to entities that have `InvulnerabilityStore`
      // attached.
      if (ii != null && invuln.ticksLeft[ii] > 0) {
        continue; // Damage negated.
      }

      final prevHp = health.hp[hi];
      final nextHp = clampDouble(
        prevHp - req.amount,
        0.0,
        health.hpMax[hi],
      );
      health.hp[hi] = nextHp;

      // 3. Record Last Damage details (if store exists).
      // Only useful if damage was actually taken.
      if (nextHp < prevHp) {
        final li = lastDamage.tryIndexOf(req.target);
        if (li != null) {
          lastDamage.kind[li] = req.sourceKind;
          lastDamage.amount[li] = req.amount;
          lastDamage.tick[li] = currentTick;

          if (req.sourceEnemyId != null) {
            lastDamage.enemyId[li] = req.sourceEnemyId!;
            lastDamage.hasEnemyId[li] = true;
          } else {
            lastDamage.hasEnemyId[li] = false;
          }

          if (req.sourceProjectileId != null) {
            lastDamage.projectileId[li] = req.sourceProjectileId!;
            lastDamage.hasProjectileId[li] = true;
          } else {
            lastDamage.hasProjectileId[li] = false;
          }

          if (req.sourceSpellId != null) {
            lastDamage.spellId[li] = req.sourceSpellId!;
            lastDamage.hasSpellId[li] = true;
          } else {
            lastDamage.hasSpellId[li] = false;
          }
        }
      }

      // 4. Apply new Invulnerability frames.
      if (invulnerabilityTicksOnHit > 0 && ii != null) {
        invuln.ticksLeft[ii] = invulnerabilityTicksOnHit;
      }
    }
    _pending.clear();
  }
}


===== FILE: lib/core/ecs/systems/enemy_system.dart =====
import 'dart:math';

import 'package:walkscape_runner/core/ecs/entity_id.dart';

import '../../enemies/enemy_id.dart';
import '../../snapshots/enums.dart';
import '../../projectiles/projectile_catalog.dart';
import '../../spells/spell_catalog.dart';
import '../../spells/spell_id.dart';
import '../../tuning/flying_enemy_tuning.dart';
import '../../tuning/ground_enemy_tuning.dart';
import '../../util/deterministic_rng.dart';
import '../../util/double_math.dart';
import '../../util/velocity_math.dart';
import '../../navigation/surface_graph.dart';
import '../../navigation/surface_id.dart';
import '../../navigation/surface_navigator.dart';
import '../../navigation/surface_spatial_index.dart';
import '../stores/cast_intent_store.dart';
import '../stores/melee_intent_store.dart';
import '../world.dart';

/// Handles AI logic for enemies (steering and attacks).
///
/// Responsibilities:
/// 1.  **Steering**: Computes velocities to move enemies toward their targets
///     (Player) or patrol points. Supports both flying (direct/boid-like) and
///     ground (pathfinding over surface graph) locomotion.
/// 2.  **Attacks**: Decisions on when to attack. Writes intent to [CastIntentStore]
///     (ranged) or [MeleeIntentStore] (melee), which are executed by downstream
///     systems like `SpellCastSystem` or `MeleeSystem`.
class EnemySystem {
  EnemySystem({
    required this.flyingEnemyTuning,
    required this.groundEnemyTuning,
    required this.surfaceNavigator,
    required this.spells,
    required this.projectiles,
  });

  final FlyingEnemyTuningDerived flyingEnemyTuning;
  final GroundEnemyTuningDerived groundEnemyTuning;
  final SurfaceNavigator surfaceNavigator;
  final SpellCatalog spells;
  final ProjectileCatalogDerived projectiles;

  /// The navigation graph for ground enemies. Can be null if the level has no surface data.
  SurfaceGraph? _surfaceGraph;
  /// Spatial index for quick lookup of surfaces/edges near an entity.
  SurfaceSpatialIndex? _surfaceIndex;
  /// Version tracker to detect graph updates and invalidate cached paths if necessary.
  int _surfaceGraphVersion = 0;

  /// Updates the navigation graph used by ground enemies.
  ///
  /// This should be called whenever the level geometry changes or is loaded.
  void setSurfaceGraph({
    required SurfaceGraph graph,
    required SurfaceSpatialIndex spatialIndex,
    required int graphVersion,
  }) {
    _surfaceGraph = graph;
    _surfaceIndex = spatialIndex;
    _surfaceGraphVersion = graphVersion;
  }

  /// Calculates and applies steering velocities for all active enemies.
  ///
  /// This traverses the enemy list, determines the player's position, and delegates
  /// to specific steering implementations ([_steerFlyingEnemy] or [_steerGroundEnemy]).
  void stepSteering(
    EcsWorld world, {
    required EntityId player,
    required double groundTopY,
    required double dtSeconds,
  }) {
    // If the player doesn't exist (e.g. dead or not spawned), enemies have no target.
    if (!world.transform.has(player)) return;

    // Cache player position/physics data once to avoid repeated lookups inside the loop.
    final playerTi = world.transform.indexOf(player);
    final playerX = world.transform.posX[playerTi];
    final playerY = world.transform.posY[playerTi];

    // Determine if player is grounded (relevant for ground enemies tracking).
    final playerGrounded = world.collision.has(player)
        ? world.collision.grounded[world.collision.indexOf(player)]
        : false;
    
    // Calculate player bounds for accurate targeting (e.g., aiming at center/bottom).
    var playerHalfX = 0.0;
    var playerBottomY = playerY;
    if (world.colliderAabb.has(player)) {
      final ai = world.colliderAabb.indexOf(player);
      playerHalfX = world.colliderAabb.halfX[ai];
      final offsetY = world.colliderAabb.offsetY[ai];
      playerBottomY = playerY + offsetY + world.colliderAabb.halfY[ai];
    }

    final enemies = world.enemy;
    // Iterate over all entities tagged as enemies.
    for (var ei = 0; ei < enemies.denseEntities.length; ei += 1) {
      final e = enemies.denseEntities[ei];
      final ti = world.transform.tryIndexOf(e);
      if (ti == null) continue; // Should not happen if data integrity is maintained.

      final ex = world.transform.posX[ti];
      final ey = world.transform.posY[ti];
      
      /// TODO(Optimization): If enemy types grow significantly, consider separating
      /// entities into specialized systems queries or sorting component arrays by
      /// EnemyId to minimize branch mispredictions and improve cache locality.
      switch (enemies.enemyId[ei]) {
        case EnemyId.flyingEnemy:
          _steerFlyingEnemy(
            world,
            enemyIndex: ei,
            enemy: e,
            enemyTi: ti,
            playerX: playerX,
            playerY: playerY,
            ex: ex,
            ey: ey,
            groundTopY: groundTopY,
            dtSeconds: dtSeconds,
          );
        case EnemyId.groundEnemy:
          _steerGroundEnemy(
            world,
            enemyIndex: ei,
            enemy: e,
            enemyTi: ti,
            playerX: playerX,
            playerBottomY: playerBottomY,
            playerHalfX: playerHalfX,
            playerGrounded: playerGrounded,
            ex: ex,
            dtSeconds: dtSeconds,
          );
      }
    }
  }

  /// Evaluates attack opportunities for all enemies.
  ///
  /// This checks distance/line-of-sight (implicitly or explicitly) and cooldowns.
  /// If an attack is viable, it writes an intent to the respective intent store.
  void stepAttacks(
    EcsWorld world, {
    required EntityId player,
    required int currentTick,
  }) {
    if (!world.transform.has(player)) return;
    
    // Pre-calculate player center for aiming.
    final playerTi = world.transform.indexOf(player);
    final playerX = world.transform.posX[playerTi];
    final playerY = world.transform.posY[playerTi];
    final playerVelX = world.transform.velX[playerTi];
    final playerVelY = world.transform.velY[playerTi];
    var playerCenterX = playerX;
    var playerCenterY = playerY;
    if (world.colliderAabb.has(player)) {
      final ai = world.colliderAabb.indexOf(player);
      playerCenterX += world.colliderAabb.offsetX[ai];
      playerCenterY += world.colliderAabb.offsetY[ai];
    }

    final enemies = world.enemy;
    for (var ei = 0; ei < enemies.denseEntities.length; ei += 1) {
      final e = enemies.denseEntities[ei];
      final ti = world.transform.tryIndexOf(e);
      if (ti == null) continue;
      
      // Cooldown check is cheap, but requires the store.
      // Assuming all enemies have cooldowns, but safer to check.
      if (!world.cooldown.has(e)) continue;

      final ex = world.transform.posX[ti];
      final ey = world.transform.posY[ti];

      switch (enemies.enemyId[ei]) {
        case EnemyId.flyingEnemy:
          var enemyCenterX = ex;
          var enemyCenterY = ey;
          if (world.colliderAabb.has(e)) {
            final ai = world.colliderAabb.indexOf(e);
            enemyCenterX += world.colliderAabb.offsetX[ai];
            enemyCenterY += world.colliderAabb.offsetY[ai];
          }
          _writeFlyingEnemyCastIntent(
            world,
            enemy: e,
            enemyCenterX: enemyCenterX,
            enemyCenterY: enemyCenterY,
            playerCenterX: playerCenterX,
            playerCenterY: playerCenterY,
            playerVelX: playerVelX,
            playerVelY: playerVelY,
            currentTick: currentTick,
          );
        case EnemyId.groundEnemy:
          _writeGroundEnemyMeleeIntent(
            world,
            enemy: e,
            enemyIndex: ei,
            ex: ex,
            ey: ey,
            playerX: playerX,
            currentTick: currentTick,
          );
      }
    }
  }

  /// Implements "Boids-like" or direct steering for flying enemies.
  ///
  /// Behavior:
  /// - Maintains a specific horizontal distance heavily (hovering left/right of player).
  /// - Maintains a specific height above ground (bobbing).
  /// - Randomizes target parameters periodically to add organic noise.
  void _steerFlyingEnemy(
    EcsWorld world, {
    required int enemyIndex,
    required EntityId enemy,
    required int enemyTi,
    required double playerX,
    required double playerY,
    required double ex,
    required double ey,
    required double groundTopY,
    required double dtSeconds,
  }) {
    if (dtSeconds <= 0.0) return;
    final tuning = flyingEnemyTuning;
    
    // Ensure steering state exists. Contains RNG state and current target timers.
    if (!world.flyingEnemySteering.has(enemy)) {
      assert(
        false,
        'EnemySystem requires FlyingEnemySteeringStore on flying enemies; add it at spawn time.',
      );
      return;
    }

    final steering = world.flyingEnemySteering;
    final si = steering.indexOf(enemy);

    var rngState = steering.rngState[si];
    // Helper to advance RNG and get a range.
    double nextRange(double min, double max) {
      rngState = nextUint32(rngState);
      return rangeDouble(rngState, min, max);
    }

    // -- Initialization --
    // If first frame, randomize initial targets (range to hold, height to fly at).
    if (!steering.initialized[si]) {
      steering.initialized[si] = true;
      steering.desiredRangeHoldLeftS[si] = nextRange(
        tuning.base.flyingEnemyDesiredRangeHoldMinSeconds,
        tuning.base.flyingEnemyDesiredRangeHoldMaxSeconds,
      );
      steering.desiredRange[si] = nextRange(
        tuning.base.flyingEnemyDesiredRangeMin,
        tuning.base.flyingEnemyDesiredRangeMax,
      );
      steering.flightTargetHoldLeftS[si] = 0.0;
      steering.flightTargetAboveGround[si] = nextRange(
        tuning.base.flyingEnemyMinHeightAboveGround,
        tuning.base.flyingEnemyMaxHeightAboveGround,
      );
    }

    // -- Horizontal Logic --
    // Decay timer for holding the current desired range.
    var desiredRangeHoldLeftS = steering.desiredRangeHoldLeftS[si];
    var desiredRange = steering.desiredRange[si];

    if (desiredRangeHoldLeftS > 0.0) {
      desiredRangeHoldLeftS -= dtSeconds;
    } else {
      // Pick new range target when timer expires.
      desiredRangeHoldLeftS = nextRange(
        tuning.base.flyingEnemyDesiredRangeHoldMinSeconds,
        tuning.base.flyingEnemyDesiredRangeHoldMaxSeconds,
      );
      desiredRange = nextRange(
        tuning.base.flyingEnemyDesiredRangeMin,
        tuning.base.flyingEnemyDesiredRangeMax,
      );
    }

    final dx = playerX - ex;
    final distX = dx.abs();
    // Face the player.
    if (distX > 1e-6) {
      world.enemy.facing[enemyIndex] = dx >= 0 ? Facing.right : Facing.left;
    }

    // Calculate desired horizontal velocity to maintain `desiredRange`.
    final slack = tuning.base.flyingEnemyHoldSlack;
    double desiredVelX = 0.0;
    if (distX > 1e-6) {
      final dirToPlayerX = dx >= 0 ? 1.0 : -1.0;
      final error = distX - desiredRange;

      // Only move if outside the slack (hysteresis) zone to prevent jitter.
      if (error.abs() > slack) {
        final slowRadiusX = tuning.base.flyingEnemySlowRadiusX;
        // Dampen speed as we approach the target range (arrival behavior).
        final t = slowRadiusX > 0.0
            ? clampDouble((error.abs() - slack) / slowRadiusX, 0.0, 1.0)
            : 1.0;
        final speed = t * tuning.base.flyingEnemyMaxSpeedX;
        // If error > 0, we are too far -> move towards player.
        // If error < 0, we are too close -> move away from player.
        desiredVelX = (error > 0.0 ? dirToPlayerX : -dirToPlayerX) * speed;
      }
    }

    // -- Vertical Logic --
    // Decay timer for vertical target hold.
    var flightTargetHoldLeftS = steering.flightTargetHoldLeftS[si];
    var flightTargetAboveGround = steering.flightTargetAboveGround[si];
    if (flightTargetHoldLeftS > 0.0) {
      flightTargetHoldLeftS -= dtSeconds;
    } else {
      flightTargetHoldLeftS = nextRange(
        tuning.base.flyingEnemyFlightTargetHoldMinSeconds,
        tuning.base.flyingEnemyFlightTargetHoldMaxSeconds,
      );
      flightTargetAboveGround = nextRange(
        tuning.base.flyingEnemyMinHeightAboveGround,
        tuning.base.flyingEnemyMaxHeightAboveGround,
      );
    }

    // Simple P-controller for height.
    final targetY = groundTopY - flightTargetAboveGround;
    final deltaY = targetY - ey;
    double desiredVelY = clampDouble(
      deltaY * tuning.base.flyingEnemyVerticalKp,
      -tuning.base.flyingEnemyMaxSpeedY,
      tuning.base.flyingEnemyMaxSpeedY,
    );
    if (deltaY.abs() <= tuning.base.flyingEnemyVerticalDeadzone) {
      desiredVelY = 0.0;
    }

    // -- Physics Integration --
    final currentVelX = world.transform.velX[enemyTi];
    world.transform.velX[enemyTi] = applyAccelDecel(
      current: currentVelX,
      desired: desiredVelX,
      dtSeconds: dtSeconds,
      accelPerSecond: tuning.base.flyingEnemyAccelX,
      decelPerSecond: tuning.base.flyingEnemyDecelX,
    );
    world.transform.velY[enemyTi] = desiredVelY;

    // Write back state.
    steering.desiredRangeHoldLeftS[si] = desiredRangeHoldLeftS;
    steering.desiredRange[si] = desiredRange;
    steering.flightTargetHoldLeftS[si] = flightTargetHoldLeftS;
    steering.flightTargetAboveGround[si] = flightTargetAboveGround;
    steering.rngState[si] = rngState;
  }

  /// Implements pathfinding and steering for ground enemies.
  ///
  /// This uses [SurfaceNavigator] to compute the next immediate move (jump/walk)
  /// towards the player. It also handles "chase offsets" to prevent enemies from
  /// stacking perfectly on top of each other.
  void _steerGroundEnemy(
    EcsWorld world, {
    required int enemyIndex,
    required EntityId enemy,
    required int enemyTi,
    required double playerX,
    required double playerBottomY,
    required double playerHalfX,
    required bool playerGrounded,
    required double ex,
    required double dtSeconds,
  }) {
    if (dtSeconds <= 0.0) return;
    final tuning = groundEnemyTuning;

    final navIndex = world.surfaceNav.tryIndexOf(enemy);
    if (navIndex == null) return;

    // Optimized: Resolve chase offset store once and pass index to avoid re-lookup.
    final chaseIndex = world.groundEnemyChaseOffset.tryIndexOf(enemy);
    if (chaseIndex == null) return;

    // Lazy initialization of random chase parameters.
    _ensureChaseOffsetInitialized(world, chaseIndex, enemy);

    final chaseOffset = world.groundEnemyChaseOffset;
    final chaseOffsetX = chaseOffset.chaseOffsetX[chaseIndex];
    final chaseSpeedScale = chaseOffset.chaseSpeedScale[chaseIndex];

    // -- Target Selection --
    // "Collapse" behavior: when very close to player, ignore chase offset and
    // move directly to player (to attack). Otherwise, maintain offset.
    final collapseDistX = tuning.base.groundEnemyMeleeRangeX +
        tuning.base.groundEnemyStopDistanceX;
    final distToPlayerX = (playerX - ex).abs();
    
    // Calculate melee offset (which side of the player to stand on).
    final meleeOffsetMaxX = tuning.base.groundEnemyChaseOffsetMeleeX.abs();
    final meleeOffsetAbs = min(meleeOffsetMaxX, chaseOffsetX.abs());
    final meleeOffsetX = meleeOffsetAbs == 0.0
        ? 0.0
        : (chaseOffsetX >= 0.0 ? meleeOffsetAbs : -meleeOffsetAbs);
    
    final effectiveTargetX = distToPlayerX <= collapseDistX
        ? playerX + meleeOffsetX
        : playerX + chaseOffsetX;
    final navTargetX = playerX; // Navigation (A*) always targets the player directly.

    // -- Pathfinding Query --
    final graph = _surfaceGraph;
    final spatialIndex = _surfaceIndex;
    double? noPlanSurfaceMinX;
    double? noPlanSurfaceMaxX;
    SurfaceNavIntent intent;
    
    // If graph is missing or navigation not possible, fallback to no-op/dumb chase.
    if (graph == null ||
        spatialIndex == null ||
        !world.colliderAabb.has(enemy)) {
      intent = SurfaceNavIntent(
        desiredX: effectiveTargetX,
        jumpNow: false,
        hasPlan: false,
      );
    } else {
      final ai = world.colliderAabb.indexOf(enemy);
      final enemyHalfX = world.colliderAabb.halfX[ai];
      final enemyHalfY = world.colliderAabb.halfY[ai];
      final offsetY = world.colliderAabb.offsetY[ai];
      final enemyBottomY = world.transform.posY[enemyTi] + offsetY + enemyHalfY;
      final grounded =
          world.collision.has(enemy) &&
          world.collision.grounded[world.collision.indexOf(enemy)];

      // Query the navigator for what to do this frame.
      intent = surfaceNavigator.update(
        navStore: world.surfaceNav,
        navIndex: navIndex,
        graph: graph,
        spatialIndex: spatialIndex,
        graphVersion: _surfaceGraphVersion,
        entityX: ex,
        entityBottomY: enemyBottomY,
        entityHalfWidth: enemyHalfX,
        entityGrounded: grounded,
        targetX: navTargetX,
        targetBottomY: playerBottomY,
        targetHalfWidth: playerHalfX,
        targetGrounded: playerGrounded,
      );

      // -- Fallback Logic --
      // If the navigator defines no plan (e.g. lost track or arrived), we still
      // want to move towards `desiredX` (chase behavior), BUT we must be careful
      // not to walk off a ledge blindly.
      if (!intent.hasPlan) {
        var desiredX = effectiveTargetX;
        // Clamp desiredX to the current surface's bounds to stop at edges.
        final currentSurfaceId = world.surfaceNav.currentSurfaceId[navIndex];
        if (currentSurfaceId != surfaceIdUnknown) {
          final currentIndex = graph.indexOfSurfaceId(currentSurfaceId);
          if (currentIndex != null) {
            final surface = graph.surfaces[currentIndex];
            final minX = surface.xMin + enemyHalfX;
            final maxX = surface.xMax - enemyHalfX;
            if (minX <= maxX) {
              desiredX = clampDouble(desiredX, minX, maxX);
              noPlanSurfaceMinX = minX;
              noPlanSurfaceMaxX = maxX;
            }
          }
        }

        intent = SurfaceNavIntent(
          desiredX: desiredX,
          jumpNow: false,
          hasPlan: false,
        );
      }
    }

    // Speed scale is intended to break symmetric chasing overlaps.
    // However, when executing a precise plan (like a Jump edge), we used standard
    // speed to ensure the physics align with the pre-calculated jump arc.
    final effectiveSpeedScale = intent.hasPlan ? 1.0 : chaseSpeedScale;

    _applyGroundEnemyPhysics(
      world,
      enemyIndex: enemyIndex,
      enemyTi: enemyTi,
      ex: ex,
      intent: intent,
      effectiveSpeedScale: effectiveSpeedScale,
      dtSeconds: dtSeconds,
      safeSurfaceMinX: noPlanSurfaceMinX,
      safeSurfaceMaxX: noPlanSurfaceMaxX,
      navIndex: navIndex,
      graph: graph,
    );
  }

  /// Calculates aim and registers a spell cast intent for flying enemies.
  void _writeFlyingEnemyCastIntent(
    EcsWorld world, {
    required EntityId enemy,
    required double enemyCenterX,
    required double enemyCenterY,
    required double playerCenterX,
    required double playerCenterY,
    required double playerVelX,
    required double playerVelY,
    required int currentTick,
  }) {
    final tuning = flyingEnemyTuning;
    if (!world.castIntent.has(enemy)) {
      assert(
        false,
        'EnemySystem requires CastIntentStore on enemies; add it at spawn time.',
      );
      return;
    }

    // Determine projectile properties for aiming.
    const spellId = SpellId.lightning; // Hardcoded for this enemy type currently.
    final projectileId = spells.get(spellId).projectileId;
    final projectileSpeed = projectileId == null
        ? null
        : projectiles.base.get(projectileId).speedUnitsPerSecond;
    
    // -- Aim Leading --
    var targetX = playerCenterX;
    var targetY = playerCenterY;
    if (projectileSpeed != null && projectileSpeed > 0.0) {
      final dx = playerCenterX - enemyCenterX;
      final dy = playerCenterY - enemyCenterY;
      final distance = sqrt(dx * dx + dy * dy);
      // Rough estimation of time-to-impact to predict player position.
      final leadSeconds = clampDouble(
        distance / projectileSpeed,
        tuning.base.flyingEnemyAimLeadMinSeconds,
        tuning.base.flyingEnemyAimLeadMaxSeconds,
      );
      targetX = playerCenterX + playerVelX * leadSeconds;
      targetY = playerCenterY + playerVelY * leadSeconds;
    }

    // Write intent. Actual spawning handles cooldown/mana checks.
    world.castIntent.set(
      enemy,
      CastIntentDef(
        spellId: spellId,
        dirX: targetX - enemyCenterX,
        dirY: targetY - enemyCenterY,
        fallbackDirX: 1.0,
        fallbackDirY: 0.0,
        originOffset: tuning.base.flyingEnemyCastOriginOffset,
        cooldownTicks: tuning.flyingEnemyCastCooldownTicks,
        tick: currentTick,
      ),
    );
  }

  /// Checks range and registers a melee attack intent for ground enemies.
  void _writeGroundEnemyMeleeIntent(
    EcsWorld world, {
    required EntityId enemy,
    required int enemyIndex,
    required double ex,
    required double ey,
    required double playerX,
    required int currentTick,
  }) {
    final tuning = groundEnemyTuning;
    if (!world.meleeIntent.has(enemy)) {
      assert(
        false,
        'EnemySystem requires MeleeIntentStore on enemies; add it at spawn time.',
      );
      return;
    }
    if (!world.colliderAabb.has(enemy)) {
      assert(
        false,
        'GroundEnemy melee requires ColliderAabbStore on the enemy to compute hitbox offset.',
      );
      return;
    }
    
    // Simple range check.
    final dx = (playerX - ex).abs();
    if (dx > tuning.base.groundEnemyMeleeRangeX) return;

    // Determine hitbox position based on facing direction.
    final facing = world.enemy.facing[enemyIndex];
    final dirX = facing == Facing.right ? 1.0 : -1.0;

    final halfX = tuning.base.groundEnemyMeleeHitboxSizeX * 0.5;
    final halfY = tuning.base.groundEnemyMeleeHitboxSizeY * 0.5;

    final ownerHalfX =
        world.colliderAabb.halfX[world.colliderAabb.indexOf(enemy)];
    final offsetX = dirX * (ownerHalfX * 0.5 + halfX);
    const offsetY = 0.0;

    // Write intent.
    world.meleeIntent.set(
      enemy,
      MeleeIntentDef(
        damage: tuning.base.groundEnemyMeleeDamage,
        halfX: halfX,
        halfY: halfY,
        offsetX: offsetX,
        offsetY: offsetY,
        dirX: dirX,
        dirY: 0.0,
        activeTicks: tuning.groundEnemyMeleeActiveTicks,
        cooldownTicks: tuning.groundEnemyMeleeCooldownTicks,
        staminaCost: 0.0,
        tick: currentTick,
      ),
    );
  }

  /// Ensures that the ground enemy has valid initialized chase offsets.
  ///
  /// Adds randomness to tracking so multiple enemies don't overlap perfectly.
  void _ensureChaseOffsetInitialized(
    EcsWorld world,
    int chaseIndex,
    EntityId enemy,
  ) {
    // world.groundEnemyChaseOffset.has(enemy) is guaranteed primarily by caller.
    final chaseOffset = world.groundEnemyChaseOffset;
    if (chaseOffset.initialized[chaseIndex]) return;

    final tuning = groundEnemyTuning;
    var rngState = chaseOffset.rngState[chaseIndex];
    if (rngState == 0) {
      rngState = enemy; // Seed with entity ID for determinism.
    }
    
    // Choose a random horizontal offset relative to the player.
    final maxAbs = tuning.base.groundEnemyChaseOffsetMaxX.abs();
    var offsetX = 0.0;
    if (maxAbs > 0.0) {
      rngState = nextUint32(rngState);
      offsetX = rangeDouble(rngState, -maxAbs, maxAbs);
      final minAbs = clampDouble(
        tuning.base.groundEnemyChaseOffsetMinAbsX,
        0.0,
        maxAbs,
      );
      final absOffset = offsetX.abs();
      // Ensure the offset isn't too small (which would defeat the purpose).
      if (absOffset < minAbs) {
        offsetX = offsetX >= 0.0 ? minAbs : -minAbs;
        if (absOffset == 0.0) {
          offsetX = minAbs;
        }
      }
    }

    // Choose a slight variation in speed.
    rngState = nextUint32(rngState);
    final speedScale = rangeDouble(
      rngState,
      tuning.base.groundEnemyChaseSpeedScaleMin,
      tuning.base.groundEnemyChaseSpeedScaleMax,
    );
    chaseOffset.initialized[chaseIndex] = true;
    chaseOffset.chaseOffsetX[chaseIndex] = offsetX;
    chaseOffset.chaseSpeedScale[chaseIndex] = speedScale;
    chaseOffset.rngState[chaseIndex] = rngState;
  }

  /// Low-level physics application for ground enemies based on [SurfaceNavIntent].
  void _applyGroundEnemyPhysics(
    EcsWorld world, {
    required int enemyIndex,
    required int enemyTi,
    required double ex,
    required SurfaceNavIntent intent,
    required double effectiveSpeedScale,
    required double dtSeconds,
    required double? safeSurfaceMinX,
    required double? safeSurfaceMaxX,
    required int navIndex,
    required SurfaceGraph? graph,
  }) {
    final tuning = groundEnemyTuning;
    final dx = intent.desiredX - ex;
    double desiredVelX = 0.0;

    // -- Horizontal Movement --
    if (intent.commitMoveDirX != 0) {
      // If navigation explicitly requests a direction (e.g., preparing for jump).
      final dirX = intent.commitMoveDirX.toDouble();
      world.enemy.facing[enemyIndex] = dirX > 0 ? Facing.right : Facing.left;
      desiredVelX = dirX * tuning.base.groundEnemySpeedX * effectiveSpeedScale;
    } else if (dx.abs() > tuning.base.groundEnemyStopDistanceX) {
      // Standard seek behavior logic.
      final dirX = dx >= 0 ? 1.0 : -1.0;
      world.enemy.facing[enemyIndex] = dirX > 0 ? Facing.right : Facing.left;
      desiredVelX = dirX * tuning.base.groundEnemySpeedX * effectiveSpeedScale;
    }

    // -- Jumping --
    if (intent.jumpNow) {
      world.transform.velY[enemyTi] = -tuning.base.groundEnemyJumpSpeed;
    }

    // -- Physics Update --
    final currentVelX = world.transform.velX[enemyTi];
    final nextVelX = applyAccelDecel(
      current: currentVelX,
      desired: desiredVelX,
      dtSeconds: dtSeconds,
      accelPerSecond: tuning.base.groundEnemyAccelX,
      decelPerSecond: tuning.base.groundEnemyDecelX,
    );

    // -- Jump Velocity Snapping --
    // If we are executing a jump edge, we might need to "snap" velocity to exactly
    // what is required to make the gap, overriding acceleration/deceleration.
    // This fixes issues where enemies undershoot/overshoot jumps due to frame variances.
    double? jumpSnapVelX;
    if (intent.hasPlan && intent.jumpNow && graph != null) {
      final activeEdgeIndex = world.surfaceNav.activeEdgeIndex[navIndex];
      if (activeEdgeIndex >= 0 && activeEdgeIndex < graph.edges.length) {
        final edge = graph.edges[activeEdgeIndex];
        if (edge.kind == SurfaceEdgeKind.jump && edge.travelTicks > 0) {
          final travelSeconds = edge.travelTicks * dtSeconds;
          if (travelSeconds > 0.0) {
            final dxAbs = (edge.landingX - ex).abs();
            final requiredAbs = dxAbs / travelSeconds;
            // Only snap if it's reasonable (bounded by current/desired speeds).
            final desiredAbs = desiredVelX.abs();
            final currentAbs = currentVelX.abs();
            final snapAbs = min(desiredAbs, max(currentAbs, requiredAbs));
            // Apply if the snap velocity is actually faster (avoid getting stuck).
            if (snapAbs > nextVelX.abs()) {
              final sign = desiredVelX >= 0.0 ? 1.0 : -1.0;
              jumpSnapVelX = sign * snapAbs;
            }
          }
        }
      }
    }

    world.transform.velX[enemyTi] = jumpSnapVelX ?? nextVelX;

    // -- Ledge Safety --
    // If we have no plan (wandering/chasing blindly), hard stop at surface edges.
    if (!intent.hasPlan && safeSurfaceMinX != null && safeSurfaceMaxX != null) {
      final stopDist = tuning.base.groundEnemyStopDistanceX;
      final nextVelX = world.transform.velX[enemyTi];
      if (nextVelX > 0.0 && ex >= safeSurfaceMaxX - stopDist) {
        world.transform.velX[enemyTi] = 0.0;
      } else if (nextVelX < 0.0 && ex <= safeSurfaceMinX + stopDist) {
        world.transform.velX[enemyTi] = 0.0;
      }
    }
  }
}


===== FILE: lib/core/ecs/systems/gravity_system.dart =====
import '../../tuning/movement_tuning.dart';
import '../../tuning/physics_tuning.dart';
import '../world.dart';

/// Applies gravity to all enabled, non-kinematic bodies that opt into gravity.
///
/// Gravity is applied before collision integration/resolution each tick.
class GravitySystem {
  void step(
    EcsWorld world,
    MovementTuningDerived movement, {
    required PhysicsTuning physics,
  }) {
    final dt = movement.dtSeconds;
    if (dt <= 0.0) return;

    final gravityY = physics.gravityY;
    final bodies = world.body;

    for (var bi = 0; bi < bodies.denseEntities.length; bi += 1) {
      final e = bodies.denseEntities[bi];

      final ti = world.transform.tryIndexOf(e);
      if (ti == null) continue;

      if (!bodies.enabled[bi]) continue;
      if (bodies.isKinematic[bi]) continue;
      if (!bodies.useGravity[bi]) continue;

      // -- Gravity Suppression Logic --
      // Check if gravity is temporarily suppressed for this entity (e.g. during a dash).
      final gci = world.gravityControl.tryIndexOf(e);
      if (gci != null) {
        final ticksLeft = world.gravityControl.suppressGravityTicksLeft[gci];
        
        if (ticksLeft > 0) {
          // Decrement timer.
          final nextTicks = ticksLeft - 1;
          world.gravityControl.suppressGravityTicksLeft[gci] = nextTicks;
          
          // If timer just expired, remove the component so gravity resumes NEXT tick.
          if (nextTicks <= 0) {
            world.gravityControl.removeEntity(e);
          }
          // Skip gravity application for this frame.
          continue;
        } else {
          // Component exists but is stale (0 or negative ticks), remove it and apply gravity immediately.
          world.gravityControl.removeEntity(e);
        }
      }

      // -- Apply Gravity --
      final scaledGravityY = gravityY * bodies.gravityScale[bi];
      world.transform.velY[ti] += scaledGravityY * dt;

      // -- Terminal Velocity --
      final maxVelY = bodies.maxVelY[bi];
      world.transform.velY[ti] = world.transform.velY[ti]
          .clamp(-maxVelY, maxVelY);
    }
  }
}


===== FILE: lib/core/ecs/systems/health_despawn_system.dart =====
import '../../enemies/enemy_id.dart';
import '../entity_id.dart';
import '../world.dart';

/// Despawns any non-player entity with `HealthStore` and `hp <= 0`.
///
/// **Responsibilities**:
/// *   Scans all entities with health.
/// *   Identifies those with zero or negative health points.
/// *   reports enemy deaths (for score/quests) via [outEnemiesKilled].
/// *   Removes the dead entities from the ECS world.
///
/// **IMPORTANT**: The player is intentionally exempt because player "death" is a
/// different gameplay flow (game over / respawn / end-run) than despawning an
/// entity in-place.
class HealthDespawnSystem {
  /// Internal buffer to hold entities scheduled for destruction this frame.
  /// Used to avoid modifying the entity collection while iterating over it.
  final List<EntityId> _toDespawn = <EntityId>[];

  /// Runs the system logic.
  ///
  /// [outEnemiesKilled] is an optional list that, if provided, will be populated
  /// with the [EnemyId]s of any enemies destroyed this frame.
  void step(
    EcsWorld world, {
    required EntityId player,
    List<EnemyId>? outEnemiesKilled,
  }) {
    final health = world.health;
    // Optimization: If no entities have health components, there's nothing to check.
    if (health.denseEntities.isEmpty) return;

    // Reset buffer for this frame.
    _toDespawn.clear();

    // -- Pass 1: Identification --
    // Iterate over all entities participating in the health system.
    for (var i = 0; i < health.denseEntities.length; i += 1) {
      final e = health.denseEntities[i];
      
      // Safety check: The player should never be despawned by this system.
      if (e == player) continue;
      
      // If health is depleted, mark for destruction.
      if (health.hp[i] <= 0.0) {
        _toDespawn.add(e);
      }
    }

    // -- Pass 2: Reporting & Destruction --
    // Process the list of doomed entities.
    for (final e in _toDespawn) {
      // If the caller wants to know about enemy kills (e.g. for scoring)...
      if (outEnemiesKilled != null) {
        // ...check if the dying entity was actually an enemy.
        final enemyIndex = world.enemy.tryIndexOf(e);
        if (enemyIndex != null) {
          outEnemiesKilled.add(world.enemy.enemyId[enemyIndex]);
        }
      }
      
      // Permanently remove the entity and all its components from the world.
      world.destroyEntity(e);
    }
  }
}


===== FILE: lib/core/ecs/systems/hitbox_damage_system.dart =====
import '../../combat/damage.dart';
import '../../events/game_event.dart';
import '../hit/hit_resolver.dart';
import '../spatial/broadphase_grid.dart';
import '../world.dart';

/// Detects collisions between active hitboxes (melee attacks) and vulnerable targets.
///
/// **Responsibilities**:
/// *   Iterate over all active hitboxes (entities with `HitboxStore`).
/// *   Perform broadphase/narrowphase collision checks against potential targets.
/// *   Filter hits based on faction (Friendly fire prevention).
/// *   Enforce "Hit Once" logic to prevent a single frame of attack from dealing damage every tick.
/// *   Queue [DamageRequest]s for resolved hits.
class HitboxDamageSystem {
  /// Helper for spatial queries and overlap sorting.
  final HitResolver _resolver = HitResolver();
  
  /// Reused buffer to store indices of overlapping entities each frame.
  final List<int> _overlaps = <int>[];

  /// Executes the system logic.
  ///
  /// [queueDamage] is a callback to the central event system to register damage.
  /// [broadphase] provides the spatial index of all damageable entities this frame.
  void step(
    EcsWorld world,
    void Function(DamageRequest request) queueDamage,
    BroadphaseGrid broadphase,
  ) {
    final hitboxes = world.hitbox;
    // Early exit if no active attacks exist.
    if (hitboxes.denseEntities.isEmpty) return;

    // Early exit if there are no targets to hit.
    if (broadphase.targets.isEmpty) return;

    // Process each active hitbox.
    for (var hi = 0; hi < hitboxes.denseEntities.length; hi += 1) {
      final hb = hitboxes.denseEntities[hi];
      
      // Hitboxes must have a position (Transform) to overlap anything.
      if (!world.transform.has(hb)) continue;
      
      // Hitboxes must have a HitOnce state to track who they've already damaged.
      // This prevents "machine gun" damage from a lingering sword swing.
      if (!world.hitOnce.has(hb)) continue;

      final hbTi = world.transform.indexOf(hb);
      final hbCx = world.transform.posX[hbTi];
      final hbCy = world.transform.posY[hbTi];
      final hbHalfX = hitboxes.halfX[hi];
      final hbHalfY = hitboxes.halfY[hi];
      final hbDirX = hitboxes.dirX[hi];
      final hbDirY = hitboxes.dirY[hi];

      // Calculate capsule segment endpoints.
      // We interpret `halfX` as the half-length along the direction vector,
      // and `halfY` as the capsule radius (thickness).
      // This effectively creates a capsule centered at (hbCx, hbCy) oriented along (hbDirX, hbDirY).
      final ax = hbCx - hbDirX * hbHalfX;
      final ay = hbCy - hbDirY * hbHalfX;
      final bx = hbCx + hbDirX * hbHalfX;
      final by = hbCy + hbDirY * hbHalfX;

      final owner = hitboxes.owner[hi];
      final sourceFaction = hitboxes.faction[hi];
      
      // Resolve enemy ID efficiently if the owner is an enemy.
      // This is used for kill credit/stats.
      final enemyIndex = world.enemy.tryIndexOf(owner);
      final enemyId = enemyIndex != null
          ? world.enemy.enemyId[enemyIndex]
          : null;

      // Ensure buffer is clear before collection (safety measure).
      _overlaps.clear();
      
      // Query the spatial grid for potential overlaps.
      // This handles the geometric check (Capsule vs Target Bounds) and Faction check.
      _resolver.collectOrderedOverlapsCapsule(
        broadphase: broadphase,
        ax: ax,
        ay: ay,
        bx: bx,
        by: by,
        radius: hbHalfY,
        owner: owner,
        sourceFaction: sourceFaction,
        outTargetIndices: _overlaps,
      );
      if (_overlaps.isEmpty) continue;

      // Register hits for verified overlaps.
      for (var i = 0; i < _overlaps.length; i += 1) {
        final ti = _overlaps[i];
        final target = broadphase.targets.entities[ti];
        
        // "Hit Once" Check: Has this specific hitbox entity already struck this specific target entity?
        if (world.hitOnce.hasHit(hb, target)) continue;
        
        // Mark as hit so we don't damage them again this swing.
        world.hitOnce.markHit(hb, target);

        // Send the damage request.
        queueDamage(
          DamageRequest(
            target: target,
            amount: hitboxes.damage[hi],
            source: owner,
            sourceKind: DeathSourceKind.meleeHitbox,
            sourceEnemyId: enemyId,
          ),
        );
      }
    }
  }
}


===== FILE: lib/core/ecs/systems/hitbox_follow_owner_system.dart =====
import '../world.dart';

/// Synchronizes the position of hitbox entities with their owners.
///
/// **Responsibilities**:
/// *   Iterate over all active hitboxes (entities with `HitboxStore`).
/// *   Retrieve the owner's current position.
/// *   Apply the hitbox's local offset (defined at spawn).
/// *   Update the hitbox's `Transform` component to match the calculated world position.
///
/// **Usage Note**:
/// This system ensures that a sword swing or projectile hitbox moves *with* the
/// character/projectile effectively. It runs every tick to prevent "hitbox drift".
class HitboxFollowOwnerSystem {
  /// Executes the synchronization logic.
  void step(EcsWorld world) {
    final hitboxes = world.hitbox;
    // Early exit if no hitboxes exist.
    if (hitboxes.denseEntities.isEmpty) return;

    for (var hi = 0; hi < hitboxes.denseEntities.length; hi += 1) {
      final hitbox = hitboxes.denseEntities[hi];
      
      // Safety: The hitbox entity itself must have a Transform component to be positioned.
      if (!world.transform.has(hitbox)) continue;

      final owner = hitboxes.owner[hi];
      
      // If the owner has been destroyed or lacks a transform,
      // we cannot position the hitbox relative to it.
      final ownerTi = world.transform.tryIndexOf(owner);
      if (ownerTi == null) continue;

      // Calculate world position: Owner Position + Local Offset.
      final x = world.transform.posX[ownerTi] + hitboxes.offsetX[hi];
      final y = world.transform.posY[ownerTi] + hitboxes.offsetY[hi];

      // specific Snap behavior: We overwrite the position completely.
      // Physics forces are not applied here; it's a hard attachment.
      world.transform.setPosXY(hitbox, x, y);
    }
  }
}



===== FILE: lib/core/ecs/systems/invulnerability_system.dart =====
import '../world.dart';

/// Manages temporary invulnerability frames (i-frames).
///
/// **Responsibilities**:
/// *   Decrements invulnerability timers each tick.
/// *   Removes the `InvulnerabilityStore` component when the timer expires.
class InvulnerabilitySystem {
  void step(EcsWorld world) {
    final store = world.invulnerability;
    // Iterate backwards to allow safe removal of entities (Swap-Remove safe).
    for (var i = store.denseEntities.length - 1; i >= 0; i--) {
      // Decrement.
      if (store.ticksLeft[i] > 0) {
        store.ticksLeft[i] -= 1;
      }

      // Cleanup logic: If expired, remove the component so other systems
      // (collision/damage) know the entity is vulnerable again.
      if (store.ticksLeft[i] <= 0) {
        final e = store.denseEntities[i];
        store.removeEntity(e);
      }
    }
  }
}



===== FILE: lib/core/ecs/systems/lifetime_system.dart =====
import '../entity_id.dart';
import '../world.dart';

/// Determines when temporary entities should expire.
///
/// **Responsibilities**:
/// *   Decrements the life timer (`LifetimeStore.ticksLeft`) for all participating entities every tick.
/// *   Despawns entities when their timer reaches zero.
///
/// **Usage**:
/// Generic system used for particles, projectiles, transient UI markers, or timed buffs
/// that need to clean themselves up automatically.
class LifetimeSystem {
  /// Buffer for entities to destroy.
  /// Used to avoid `ConcurrentModificationException` when modifying the ECS state during iteration.
  final List<EntityId> _toDespawn = <EntityId>[];

  /// Executes the system logic.
  void step(EcsWorld world) {
    final lifetimes = world.lifetime;
    // Optimization: Skip processing if no timed entities exist.
    if (lifetimes.denseEntities.isEmpty) return;

    // Reset the buffer for this frame.
    _toDespawn.clear();

    // Iterate over all entities with a lifetime component.
    for (var li = 0; li < lifetimes.denseEntities.length; li += 1) {
      final e = lifetimes.denseEntities[li];
      
      // Decrement the timer (Tick down).
      lifetimes.ticksLeft[li]--;
      
      // If time has run out (or was force-set to <= 0), mark for destruction.
      if (lifetimes.ticksLeft[li] <= 0) {
        _toDespawn.add(e);
      }
    }

    // Process the destruction queue.
    for (final e in _toDespawn) {
      world.destroyEntity(e);
    }
  }
}



===== FILE: lib/core/ecs/systems/melee_attack_system.dart =====
import '../stores/hitbox_store.dart';
import '../stores/lifetime_store.dart';
import '../world.dart';

/// Processes requests to perform melee attacks.
///
/// **Responsibilities**:
/// *   Consumes [MeleeIntentStore] intents created by input or enemy AI.
/// *   Validates attack requirements (Cooldown, Stamina availability).
/// *   Deducts resource costs (Stamina, Cooldown Reset).
/// *   Spawns the actual "Hitbox" entity that performs collision checks.
///
/// **Workflow**:
/// 1.  Filter intents that match the [currentTick] (synchronization).
/// 2.  Validate Attacker State (Must exist, have cooldown component, etc.).
/// 3.  Check Costs (Is cooldown ready? Is there enough stamina?).
/// 4.  **Execute**:
///     *   Deduct Stamina.
///     *   Set Cooldown.
///     *   Create Hitbox entity with [HitboxDef], [HitOnce], and [LifetimeDef].
class MeleeAttackSystem {
  /// Runs the system logic.
  ///
  /// [currentTick] is required to ensure we only process intents generated for THIS frame,
  /// preserving determinism.
  void step(EcsWorld world, {required int currentTick}) {
    final intents = world.meleeIntent;
    if (intents.denseEntities.isEmpty) return;
    
    // Iterate through all intents.
    for (var ii = 0; ii < intents.denseEntities.length; ii += 1) {
      if (intents.tick[ii] != currentTick) continue;

      final attacker = intents.denseEntities[ii];

      // Invalidate now so accidental multi-pass execution in the same tick cannot
      // double-attack. (Intent is still ignored next tick due to stamp mismatch.)
      intents.tick[ii] = -1;

      // -- Validation & Resource Checks --

      // Attacker must exist physically.
      final attackerTi = world.transform.tryIndexOf(attacker);
      if (attackerTi == null) continue;

      // Attacker must respond to cooldowns.
      final ci = world.cooldown.tryIndexOf(attacker);
      if (ci == null) continue;
      if (world.cooldown.meleeCooldownTicksLeft[ci] > 0) continue;

      // Attacker must have a faction to determine who they hit.
      final fi = world.faction.tryIndexOf(attacker);
      if (fi == null) continue;
      final faction = world.faction.faction[fi];

      // Stamina check.
      final staminaCost = intents.staminaCost[ii];
      int? si;
      double? nextStamina;
      
      if (staminaCost > 0) {
        // Optimization: Resolve index directly.
        si = world.stamina.tryIndexOf(attacker);
        if (si == null) continue; // No stamina component = cannot attack if cost > 0.
        
        final currentStamina = world.stamina.stamina[si];
        if (currentStamina < staminaCost) continue; // Not enough stamina.
        nextStamina = currentStamina - staminaCost;
      }

      // -- Execution --

      // Spawn the hitbox.
      final hitbox = world.createEntity();
      world.transform.add(
        hitbox,
        // HitboxFollowOwnerSystem will position from `owner + offset`.
        // Initialize at owner's position to prevent 1-frame visual glitch.
        posX: world.transform.posX[attackerTi],
        posY: world.transform.posY[attackerTi],
        velX: 0.0,
        velY: 0.0,
      );
      world.hitbox.add(
        hitbox,
        HitboxDef(
          owner: attacker,
          faction: faction,
          damage: intents.damage[ii],
          halfX: intents.halfX[ii],
          halfY: intents.halfY[ii],
          offsetX: intents.offsetX[ii],
          offsetY: intents.offsetY[ii],
          dirX: intents.dirX[ii],
          dirY: intents.dirY[ii],
        ),
      );
      // Ensure hitbox only hits things once.
      world.hitOnce.add(hitbox);
      // Hitbox is ephemeral.
      world.lifetime.add(
        hitbox,
        LifetimeDef(ticksLeft: intents.activeTicks[ii]),
      );

      // Apply costs.
      if (si != null) {
        world.stamina.stamina[si] = nextStamina!;
      }
      // Set cooldown.
      world.cooldown.meleeCooldownTicksLeft[ci] = intents.cooldownTicks[ii];
    }
  }
}


===== FILE: lib/core/ecs/systems/player_cast_system.dart =====
import '../../snapshots/enums.dart';
import '../../spells/spell_id.dart';
import '../../tuning/ability_tuning.dart';
import '../../tuning/movement_tuning.dart';
import '../entity_id.dart';
import '../stores/cast_intent_store.dart';
import '../world.dart';

/// Translates player input into a [CastIntentDef] for the [SpellCastSystem].
///
/// **Responsibilities**:
/// *   Checks if the cast button is pressed.
/// *   Determines aiming direction based on input or facing direction.
/// *   Registers a cast intent to be processed (cooldown/mana checks happen downstream).
class PlayerCastSystem {
  const PlayerCastSystem({
    required this.abilities,
    required this.movement,
  });

  final AbilityTuningDerived abilities;
  final MovementTuningDerived movement;

  void step(EcsWorld world, {required EntityId player, required int currentTick}) {
    // -- 1. Component Checks --
    
    // We need input to know if casting.
    final inputIndex = world.playerInput.tryIndexOf(player);
    if (inputIndex == null) return;

    // We need movement data for facing direction (fallback aim).
    final movementIndex = world.movement.tryIndexOf(player);
    if (movementIndex == null) return;
    
    // Check if the store exists (should be added at spawn).
    if (!world.castIntent.has(player)) {
      assert(
        false,
        'PlayerCastSystem requires CastIntentStore on the player; add it at spawn time.',
      );
      return;
    }

    // -- 2. Input Logic --

    // If button not pressed, do nothing.
    if (!world.playerInput.castPressed[inputIndex]) return;

    // TODO: Look up equipped spell instead of hardcoding.
    const spellId = SpellId.iceBolt;

    final facing = world.movement.facing[movementIndex];

    final rawAimX = world.playerInput.projectileAimDirX[inputIndex];
    final rawAimY = world.playerInput.projectileAimDirY[inputIndex];

    // Determine aim direction.
    // If rawAim is essentially zero/unbiased (e.g. controller neutral), use facing.
    // However, currently we pass fallbackDirX to the intent store separately.
    final fallbackDirX = facing == Facing.right ? 1.0 : -1.0;
    
    // Offset from the player's center where the spell appears.
    final spawnOffset = movement.base.playerRadius * 0.5;

    // -- 3. Write Intent --

    // IMPORTANT: PlayerCastSystem writes intent only; execution happens in
    // `SpellCastSystem` which owns mana/cooldown rules and projectile spawning.
    world.castIntent.set(
      player,
      CastIntentDef(
        spellId: spellId,
        dirX: rawAimX,
        dirY: rawAimY,
        fallbackDirX: fallbackDirX,
        fallbackDirY: 0.0,
        originOffset: spawnOffset,
        cooldownTicks: abilities.castCooldownTicks,
        tick: currentTick,
      ),
    );
  }
}


===== FILE: lib/core/ecs/systems/player_melee_system.dart =====
import 'dart:math';

import '../../snapshots/enums.dart';
import '../../tuning/ability_tuning.dart';
import '../../tuning/movement_tuning.dart';
import '../entity_id.dart';
import '../stores/melee_intent_store.dart';
import '../world.dart';

/// Translates player input into a [MeleeIntentDef] for the [MeleeAttackSystem].
///
/// **Responsibilities**:
/// *   Checks input state (Attack button).
/// *   Calculates attack direction (Analog aim or Facing fallback).
/// *   Calculates hitbox offsets based on attack reach.
/// *   Registers intent (Costs/Cooldowns checked downstream).
class PlayerMeleeSystem {
  const PlayerMeleeSystem({required this.abilities, required this.movement});

  final AbilityTuningDerived abilities;
  final MovementTuningDerived movement;

  void step(
    EcsWorld world, {
    required EntityId player,
    required int currentTick,
  }) {
    // -- 1. Component Checks --
    
    // Check if the store exists (should be added at spawn).
    if (!world.meleeIntent.has(player)) {
      assert(
        false,
        'PlayerMeleeSystem requires MeleeIntentStore on the player; add it at spawn time.',
      );
      return;
    }

    // Input is required to know if attacking.
    final inputIndex = world.playerInput.tryIndexOf(player);
    if (inputIndex == null) return;
    
    // Movement is required for facing direction fallback.
    final movementIndex = world.movement.tryIndexOf(player);
    if (movementIndex == null) return;

    // -- 2. Input Logic --

    // If button not pressed, early exit.
    if (!world.playerInput.attackPressed[inputIndex]) return;

    final facing = world.movement.facing[movementIndex];
    final aimX = world.playerInput.meleeAimDirX[inputIndex];
    final aimY = world.playerInput.meleeAimDirY[inputIndex];
    final len2 = aimX * aimX + aimY * aimY;

    // Normalize aim direction if valid, otherwise fallback to facing direction.
    final double dirX;
    final double dirY;
    if (len2 > 1e-12) {
      final invLen = 1.0 / sqrt(len2);
      dirX = aimX * invLen;
      dirY = aimY * invLen;
    } else {
      dirX = (facing == Facing.right) ? 1.0 : -1.0;
      dirY = 0.0;
    }

    // -- 3. Intent Calculation --

    final halfX = abilities.base.meleeHitboxSizeX * 0.5;
    final halfY = abilities.base.meleeHitboxSizeY * 0.5;

    // Calculate how far in front of the player the hitbox should appear.
    // origin = playerPos + aimDir * (playerRadius * 0.5 + maxDimension)
    final forward = movement.base.playerRadius * 0.5 + max(halfX, halfY);
    final offsetX = dirX * forward;
    final offsetY = dirY * forward;

    // IMPORTANT: PlayerMeleeSystem writes intent only; execution happens in
    // `MeleeAttackSystem` which owns stamina/cooldown rules and hitbox spawning.
    world.meleeIntent.set(
      player,
      MeleeIntentDef(
        damage: abilities.base.meleeDamage,
        halfX: halfX,
        halfY: halfY,
        offsetX: offsetX,
        offsetY: offsetY,
        dirX: dirX,
        dirY: dirY,
        activeTicks: abilities.meleeActiveTicks,
        cooldownTicks: abilities.meleeCooldownTicks,
        staminaCost: abilities.base.meleeStaminaCost,
        tick: currentTick,
      ),
    );
  }
}


===== FILE: lib/core/ecs/systems/player_movement_system.dart =====
import '../../snapshots/enums.dart';
import '../../tuning/movement_tuning.dart';
import '../../tuning/resource_tuning.dart';
import '../../util/velocity_math.dart';
import '../entity_id.dart';
import '../queries.dart';
import '../world.dart';

/// Applies platformer-style movement for entities with:
/// - Transform
/// - PlayerInput
/// - Movement
/// - Body
///
/// PlayerMovementSystem writes velocities only (input/jump/dash/gravity/clamps).
/// Position integration and collision resolution are handled by CollisionSystem.
///
/// **Responsibilities**:
/// *   Update movement state timers (Dash cooldown, Coyote time, Jump buffer).
/// *   Process Input (Dash request, Jump request, Horizontal move).
/// *   Apply velocities based on state.
class PlayerMovementSystem {
  void step(
    EcsWorld world,
    MovementTuningDerived tuning, {
    required ResourceTuning resources,
  }) {
    final dt = tuning.dtSeconds;
    final t = tuning.base;

    // Iterate over all controllable entities (Join: Movement + Input + Body +...).
    // Uses EcsQueries to efficiently fetch entities with all required components.
    EcsQueries.forMovementBodies(world, (e, mi, ti, ii, bi, ci, si) {
      if (!world.body.enabled[bi]) return;
      
      // Kinematic bodies are moved by scripts/physics directly, not by player input.
      if (world.body.isKinematic[bi]) {
        return;
      }

      // -- Timers --
      // Decrement state timers. These track cooldowns and temporary states (dash, buffers).
      if (world.movement.dashCooldownTicksLeft[mi] > 0) {
        world.movement.dashCooldownTicksLeft[mi] -= 1;
      }
      if (world.movement.dashTicksLeft[mi] > 0) {
        world.movement.dashTicksLeft[mi] -= 1;
      }
      if (world.movement.jumpBufferTicksLeft[mi] > 0) {
        world.movement.jumpBufferTicksLeft[mi] -= 1;
      }

      // -- Coyote Time --
      // "Coyote Time" allows the player to jump for a few frames after walking off a ledge.
      // - If currently grounded (from CollisionSystem last frame), reset the timer to full.
      // - If in air, decrement the timer.
      final wasGrounded = world.collision.grounded[ci];
      if (wasGrounded) {
        world.movement.coyoteTicksLeft[mi] = tuning.coyoteTicks;
      } else if (world.movement.coyoteTicksLeft[mi] > 0) {
        world.movement.coyoteTicksLeft[mi] -= 1;
      }

      // -- Input Buffering --
      // Buffer a jump request if pressed this frame.
      // This allows a jump input slightly BEFORE landing to still register as a jump upon landing.
      if (world.playerInput.jumpPressed[ii]) {
        world.movement.jumpBufferTicksLeft[mi] = tuning.jumpBufferTicks;
      }

      // -- Dash Logic --
      // Attempt to start a dash if requested.
      // Dash is an atomic action that overrides normal movement.
      if (world.playerInput.dashPressed[ii]) {
        _tryStartDash(
          world,
          entity: e,
          mi: mi,
          ti: ti,
          ii: ii,
          si: si,
          tuning: tuning,
          staminaCost: resources.dashStaminaCost,
        );
      }

      final dashing = world.movement.dashTicksLeft[mi] > 0;

      // -- Horizontal Movement --
      if (dashing) {
        // [State: Dashing]
        // Lock velocity to the dash direction and speed.
        // Zero out Y velocity to prevent gravity from affecting the dash arc (linear dash).
        world.transform.velX[ti] = world.movement.dashDirX[mi] * t.dashSpeedX;
        world.transform.velY[ti] = 0;
      } else {
        // [State: Normal Control]
        final axis = world.playerInput.moveAxis[ii];
        
        // Visuals: Update facing direction based on input.
        // This is decoupled from velocity to allow "turning" animations before velocity flips.
        if (axis != 0) {
          world.movement.facing[mi] = axis > 0 ? Facing.right : Facing.left;
        }

        // Apply horizontal acceleration/deceleration.
        world.transform.velX[ti] = _applyHorizontalMove(
          world.transform.velX[ti],
          axis,
          dt,
          tuning,
        );

        // -- Jumping --
        // Execute Jump if:
        // 1. Jump is buffered (Pressed recently).
        // 2. Player can jump (Grounded OR Coyote Time active).
        // 3. Sufficient Stamina.
        if (world.movement.jumpBufferTicksLeft[mi] > 0 &&
            (wasGrounded || world.movement.coyoteTicksLeft[mi] > 0)) {
          if (world.stamina.stamina[si] >= resources.jumpStaminaCost) {
            world.stamina.stamina[si] -= resources.jumpStaminaCost;

            // Apply instantaneous upward velocity.
            world.transform.velY[ti] = -t.jumpSpeed;
            
            // Consume the buffer and coyote time immediately to prevent double-jumping
            // in the same window.
            world.movement.jumpBufferTicksLeft[mi] = 0;
            world.movement.coyoteTicksLeft[mi] = 0;
          }
        }
      }

      // -- Limits --
      // Soft cap on horizontal velocity to prevent runaway speeds from external forces.
      world.transform.velX[ti] = world.transform.velX[ti]
          .clamp(-world.body.maxVelX[bi], world.body.maxVelX[bi]);
    });
  }

  /// Calculates the new horizontal velocity using linear acceleration/deceleration.
  ///
  /// Note:
  /// - Uses [t.decelerationX] when `axis == 0` (Stopping).
  /// - Uses [t.accelerationX] for both Speeding Up and Turning (changing direction).
  /// - Snaps to 0 if speed is below [t.minMoveSpeed] and input is 0.
  double _applyHorizontalMove(
    double velocityX,
    double axis,
    double dt,
    MovementTuningDerived tuning,
  ) {
    final t = tuning.base;
    final desiredX = axis == 0.0 ? 0.0 : axis * t.maxSpeedX;
    return applyAccelDecel(
      current: velocityX,
      desired: desiredX,
      dtSeconds: dt,
      accelPerSecond: t.accelerationX,
      decelPerSecond: t.decelerationX,
      minStopSpeed: t.minMoveSpeed,
    );
  }

  /// Attempts to initiate a dash action.
  ///
  /// **Logic**:
  /// 1.  **Checks**: Must not be Dashing, Cooldown active, or Insufficient Stamina.
  /// 2.  **Direction**: Prioritizes raw input [axis]. If neutral, uses current [facing].
  /// 3.  **Physics**: Cancels vertical velocity and suppresses gravity for duration.
  /// 4.  **State**: Sets cooldowns and consumes stamina.
  void _tryStartDash(
    EcsWorld world, {
    required EntityId entity,
    required int mi,
    required int ti,
    required int ii,
    required int si,
    required MovementTuningDerived tuning,
    required double staminaCost,
  }) {
    if (world.movement.dashTicksLeft[mi] > 0) return;
    if (world.movement.dashCooldownTicksLeft[mi] > 0) return;
    if (world.stamina.stamina[si] < staminaCost) return;

    // Determine Dash Direction:
    // - If holding direction: Dash that way.
    // - If neutral: Dash forward (current facing).
    final axis = world.playerInput.moveAxis[ii];
    final dirX = axis != 0
        ? (axis > 0 ? 1.0 : -1.0)
        : (world.movement.facing[mi] == Facing.right ? 1.0 : -1.0);

    world.movement.dashDirX[mi] = dirX;
    world.movement.facing[mi] = dirX > 0 ? Facing.right : Facing.left;

    world.movement.dashTicksLeft[mi] = tuning.dashDurationTicks;
    world.movement.dashCooldownTicksLeft[mi] = tuning.dashCooldownTicks;

    // Cancel vertical motion so dash doesn't inherit jump/fall.
    // Suppress gravity to ensure linear horizontal movement.
    world.transform.velY[ti] = 0;
    world.gravityControl.setSuppressForTicks(entity, tuning.dashDurationTicks);

    world.stamina.stamina[si] -= staminaCost;
  }
}


===== FILE: lib/core/ecs/systems/projectile_hit_system.dart =====
import '../../combat/damage.dart';
import '../../events/game_event.dart';
import '../entity_id.dart';
import '../hit/hit_resolver.dart';
import '../spatial/broadphase_grid.dart';
import '../world.dart';

/// Handles collision detection for projectiles against potentially damageable targets.
///
/// **Responsibilities**:
/// - Iterates all active projectiles.
/// - Calculates a swept capsule shape for the projectile based on its velocity/direction.
/// - Queries the [BroadphaseGrid] for collisions.
/// - Queues [DamageRequest] and despawns the projectile on impact.
class ProjectileHitSystem {
  final List<EntityId> _toDespawn = <EntityId>[];
  final HitResolver _resolver = HitResolver();

  /// Runs the system logic for a single tick.
  ///
  /// [queueDamage] is a callback to the central `DamageSystem` or event queue.
  /// [broadphase] provides spatial acceleration for finding targets efficiently.
  void step(
    EcsWorld world,
    void Function(DamageRequest request) queueDamage,
    BroadphaseGrid broadphase,
  ) {
    // Optimization: If there are no targets to hit, projectiles just fly.
    if (broadphase.targets.isEmpty) return;
    
    final projectiles = world.projectile;
    if (projectiles.denseEntities.isEmpty) return;

    _toDespawn.clear();

    // Cache store references for efficient lookup (Hoisting).
    final transforms = world.transform;
    final colliders = world.colliderAabb;
    final enemies = world.enemy;
    final spellOrigins = world.spellOrigin;

    final count = projectiles.denseEntities.length;
    for (var pi = 0; pi < count; pi += 1) {
      final p = projectiles.denseEntities[pi];
      
      // Validation: Projectiles must have physical presence.
      final ti = transforms.tryIndexOf(p);
      if (ti == null) continue;

      final ci = colliders.tryIndexOf(p);
      if (ci == null) continue;

      // -- Geometry Construction --
      // Projectiles are modeled as capsules (swept circles) oriented along their velocity vector.
      // - [offsetX/Y]: Center offset relative to transform.
      // - [halfX]: Interpreted as half-length of the capsule shaft.
      // - [halfY]: Interpreted as the radius (thickness) of the projectile.
      final pcx = transforms.posX[ti] + colliders.offsetX[ci];
      final pcy = transforms.posY[ti] + colliders.offsetY[ci];
      
      final halfLength = colliders.halfX[ci];
      final radius = colliders.halfY[ci];
      
      final dirX = projectiles.dirX[pi];
      final dirY = projectiles.dirY[pi];

      // Calculate the start (A) and end (B) points of the capsule segment.
      // The segment is centered at (pcx, pcy) and extends halfLength in both directions along (dirX, dirY).
      final ax = pcx - dirX * halfLength;
      final ay = pcy - dirY * halfLength;
      final bx = pcx + dirX * halfLength;
      final by = pcy + dirY * halfLength;

      // -- Hit Resolution --
      final owner = projectiles.owner[pi];
      final sourceFaction = projectiles.faction[pi];

      // Query the broadphase for the first valid intersection.
      // This respects "Friendly Fire" rules via [sourceFaction].
      final targetIndex = _resolver.firstOrderedOverlapCapsule(
        broadphase: broadphase,
        ax: ax,
        ay: ay,
        bx: bx,
        by: by,
        radius: radius,
        owner: owner,
        sourceFaction: sourceFaction,
      );

      // -- Impact Handling --
      if (targetIndex != null) {
        // Optimization: Resolve heavy metadata (EnemyId, SpellId) ONLY when a hit actually occurs.
        // Doing this before the hit check would waste cycles for the 99% of frames a projectile is just flying.
        final ei = enemies.tryIndexOf(owner);
        final enemyId = ei != null ? enemies.enemyId[ei] : null;
        
        final si = spellOrigins.tryIndexOf(p);
        final spellId = si != null ? spellOrigins.spellId[si] : null;

        // Dispatch damage event.
        queueDamage(
          DamageRequest(
            target: broadphase.targets.entities[targetIndex],
            amount: projectiles.damage[pi],
            source: owner,
            sourceKind: DeathSourceKind.projectile,
            sourceEnemyId: enemyId,
            sourceProjectileId: projectiles.projectileId[pi],
            sourceSpellId: spellId,
          ),
        );
        
        // Mark projectile for removal.
        // We defer removal until after the loop or use a list to avoid modifying the collection while iterating
        // (though we are iterating by index here, deferred removal is safer/cleaner pattern).
        _toDespawn.add(p);
      }
    }

    // Process despawns.
    for (final e in _toDespawn) {
      world.destroyEntity(e);
    }
  }
}


===== FILE: lib/core/ecs/systems/projectile_system.dart =====
import '../../tuning/movement_tuning.dart';
import '../world.dart';

/// Moves active projectiles based on their linear velocity.
///
/// **Responsibilities**:
/// - Updates `velX` and `velY` (for use by renderers/interpolation).
/// - Explicitly integrates position: `pos += vel * dt`.
///
/// Note: Projectiles are typically simple kinematic objects that do not participate
/// in the full physics/collision resolution loop (no `Body` component), hence the
/// manual position integration here.
class ProjectileSystem {
  void step(EcsWorld world, MovementTuningDerived movement) {
    final dt = movement.dtSeconds;
    final projectiles = world.projectile;
    final transforms = world.transform;

    // Iterate efficiently over dense projectile arrays.
    final count = projectiles.denseEntities.length;
    for (var pi = 0; pi < count; pi += 1) {
      final e = projectiles.denseEntities[pi];
      
      final ti = transforms.tryIndexOf(e);
      if (ti == null) continue;

      // Calculate velocity from direction and speed.
      final vx = projectiles.dirX[pi] * projectiles.speedUnitsPerSecond[pi];
      final vy = projectiles.dirY[pi] * projectiles.speedUnitsPerSecond[pi];

      // Update Transform velocity (useful for other systems/debug).
      transforms.velX[ti] = vx;
      transforms.velY[ti] = vy;

      // Explicit Euler integration: pos += vel * dt
      // We do this here because projectiles lack a 'Body' component for simplicity
      // and thus aren't moved by the main physics solver.
      transforms.posX[ti] += vx * dt;
      transforms.posY[ti] += vy * dt;
    }
  }
}


===== FILE: lib/core/ecs/systems/resource_regen_system.dart =====
import '../../util/double_math.dart';
import '../world.dart';

/// Periodically regenerates Health, Mana, and Stamina for all entities.
///
/// **Responsibilities**:
/// - Iterates over all entities with [Health], [Mana], or [Stamina].
/// - Applies regeneration rates (`regenPerSecond`) scaled by `dtSeconds`.
/// - Clamps values to `[0, Max]`.
///
/// **Performance**:
/// - Uses direct dense array iteration (Structure of Arrays) for cache efficiency.
/// - Skips full resources and zero-regen entities early.
class ResourceRegenSystem {
  void step(EcsWorld world, {required double dtSeconds}) {
    _regenHealth(world, dtSeconds);
    _regenMana(world, dtSeconds);
    _regenStamina(world, dtSeconds);
  }

  void _regenHealth(EcsWorld world, double dtSeconds) {
    final store = world.health;
    final count = store.denseEntities.length;
    // Iterate contiguous arrays directly (SoA pattern).
    for (var i = 0; i < count; i += 1) {
      final max = store.hpMax[i];
      if (max <= 0) continue;
      
      final current = store.hp[i];
      if (current >= max) continue;
      
      final regen = store.regenPerSecond[i];
      if (regen <= 0) continue;
      
      store.hp[i] = clampDouble(current + regen * dtSeconds, 0.0, max);
    }
  }

  void _regenMana(EcsWorld world, double dtSeconds) {
    final store = world.mana;
    final count = store.denseEntities.length;
    for (var i = 0; i < count; i += 1) {
      final max = store.manaMax[i];
      if (max <= 0) continue;
      
      final current = store.mana[i];
      if (current >= max) continue;
      
      final regen = store.regenPerSecond[i];
      if (regen <= 0) continue;
      
      store.mana[i] = clampDouble(current + regen * dtSeconds, 0.0, max);
    }
  }

  void _regenStamina(EcsWorld world, double dtSeconds) {
    final store = world.stamina;
    final count = store.denseEntities.length;
    for (var i = 0; i < count; i += 1) {
      final max = store.staminaMax[i];
      if (max <= 0) continue;
      
      final current = store.stamina[i];
      if (current >= max) continue;
      
      final regen = store.regenPerSecond[i];
      if (regen <= 0) continue;
      
      store.stamina[i] = clampDouble(current + regen * dtSeconds, 0.0, max);
    }
  }
}


===== FILE: lib/core/ecs/systems/restoration_item_system.dart =====
import 'dart:math' as math;
import '../entity_id.dart';
import '../world.dart';
import '../stores/restoration_item_store.dart';
import '../../tuning/restoration_item_tuning.dart';

/// Handles the lifecycle and collision of restoration pickups (Health/Mana/Stamina potions).
///
/// **Responsibilities**:
/// - Despawns items that fall too far behind the camera.
/// - Checks for collision with the Player.
/// - Applies restoration effects and despawns on pickup.
class RestorationItemSystem {
  final List<EntityId> _toDespawn = <EntityId>[];

  /// Executes the system logic for a single frame.
  ///
  /// - [player]: The valid [EntityId] of the local player character.
  /// - [cameraLeft]: The X coordinate of the camera's left edge (used for culling).
  /// - [tuning]: Configuration values for pickup ranges and restore amounts.
  void step(
    EcsWorld world, {
    required EntityId player,
    required double cameraLeft,
    required RestorationItemTuning tuning,
  }) {
    final items = world.restorationItem;
    // Early exit if no items exist to process.
    if (items.denseEntities.isEmpty) return;
    
    _toDespawn.clear();
    final despawnLimit = cameraLeft - tuning.despawnBehindCameraMargin;

    // -- Resolve Player AABB (Optimization) --
    // We cache the player's world-space bounds once per frame.
    final transforms = world.transform;
    final colliders = world.colliderAabb;

    final pTi = transforms.tryIndexOf(player);
    final pCi = colliders.tryIndexOf(player);
    
    // Bounds: Min/Max X/Y
    double pMinX = 0, pMaxX = 0, pMinY = 0, pMaxY = 0;
    bool playerActive = false;

    if (pTi != null && pCi != null) {
      playerActive = true;
      final cx = transforms.posX[pTi] + colliders.offsetX[pCi];
      final cy = transforms.posY[pTi] + colliders.offsetY[pCi];
      final hx = colliders.halfX[pCi];
      final hy = colliders.halfY[pCi];
      pMinX = cx - hx;
      pMaxX = cx + hx;
      pMinY = cy - hy;
      pMaxY = cy + hy;
    }

    // -- Iterate Items --
    final count = items.denseEntities.length;
    for (var ii = 0; ii < count; ii += 1) {
      final e = items.denseEntities[ii];
      
      final ti = transforms.tryIndexOf(e);
      // Skip items that are missing spatial components (malformed entities).
      if (ti == null) continue;
      
      final ci = colliders.tryIndexOf(e);
      if (ci == null) continue;

      final cx = transforms.posX[ti] + colliders.offsetX[ci];
      
      // 1. Despawn Logic (Garbage Collection)
      if (cx < despawnLimit) {
        _toDespawn.add(e);
        continue;
      }

      // 2. Collision Check (Pickup)
      if (playerActive) {
        final cy = transforms.posY[ti] + colliders.offsetY[ci];
        final hx = colliders.halfX[ci];
        final hy = colliders.halfY[ci];

        // AABB Overlap Logic:
        final overlaps = (cx - hx) < pMaxX && 
                         (cx + hx) > pMinX && 
                         (cy - hy) < pMaxY && 
                         (cy + hy) > pMinY;

        if (overlaps) {
          _applyRestore(
            world,
            player: player,
            stat: items.stat[ii],
            percent: tuning.restorePercent,
          );
          _toDespawn.add(e);
        }
      }
    }

    // Process all despawns in batch at the end of the frame.
    for (final e in _toDespawn) {
      world.destroyEntity(e);
    }
  }

  /// RESTORES a specific stat on the target [player].
  ///
  /// - [percent]: Percentage of MAX value to restore (0.0 to 1.0).
  /// - Scales based on the player's Max HP/Mana/Stamina.
  /// - Clamps to Max value (prevents overhealing).
  void _applyRestore(
    EcsWorld world, {
    required EntityId player,
    required RestorationStat stat,
    required double percent,
  }) {
    // Note: We use min/max checks to ensure we don't overheal or divide by zero.
    switch (stat) {
      case RestorationStat.health:
        final index = world.health.tryIndexOf(player);
        if (index != null) {
          final max = world.health.hpMax[index];
          if (max > 0) {
            world.health.hp[index] = math.min(max, world.health.hp[index] + max * percent);
          }
        }
      case RestorationStat.mana:
        final index = world.mana.tryIndexOf(player);
        if (index != null) {
          final max = world.mana.manaMax[index];
          if (max > 0) {
            world.mana.mana[index] = math.min(max, world.mana.mana[index] + max * percent);
          }
        }
      case RestorationStat.stamina:
        final index = world.stamina.tryIndexOf(player);
        if (index != null) {
          final max = world.stamina.staminaMax[index];
          if (max > 0) {
            world.stamina.stamina[index] = math.min(max, world.stamina.stamina[index] + max * percent);
          }
        }
    }
  }
}


===== FILE: lib/core/ecs/systems/spell_cast_system.dart =====
import '../../spells/spawn_spell_projectile.dart';
import '../../spells/spell_catalog.dart';
import '../../util/double_math.dart';
import '../world.dart';
import '../../projectiles/projectile_catalog.dart';

/// Executes [CastIntentStore] intents by spawning projectiles and managing resources.
///
/// **Responsibilities**:
/// - Consumes [CastIntent] stamped with the `currentTick`.
/// - Checks validation (Cooldowns, Mana cost, Entity existence).
/// - Spawns Spell Projectiles via [spawnSpellProjectileFromCaster].
/// - Deducts Mana and applies Cooldown IF spawn succeeds.
///
/// **Logic**:
/// - Intents are processed only once per tick.
/// - Invalidated immediately (`tick = -1`) to prevent double-execution.
class SpellCastSystem {
  SpellCastSystem({
    required this.spells,
    required this.projectiles,
  });

  final SpellCatalog spells;
  final ProjectileCatalogDerived projectiles;

  void step(EcsWorld world, {required int currentTick}) {
    final intents = world.castIntent;
    if (intents.denseEntities.isEmpty) return;

    // Cache stores for efficient access
    final transforms = world.transform;
    final cooldowns = world.cooldown;
    final manas = world.mana;
    final factions = world.faction;

    final count = intents.denseEntities.length;
    for (var ii = 0; ii < count; ii += 1) {
      if (intents.tick[ii] != currentTick) continue;

      final caster = intents.denseEntities[ii];

      // Safe-guard: Invalidate intent immediately to prevent re-entry within the same tick.
      intents.tick[ii] = -1;

      // -- Validation Checks --
      // Must have position, cooldowns, and mana components.
      final ti = transforms.tryIndexOf(caster);
      if (ti == null) continue;

      final ci = cooldowns.tryIndexOf(caster);
      if (ci == null) continue;
      
      // Check cooldown (must be ready).
      if (cooldowns.castCooldownTicksLeft[ci] > 0) continue;

      final mi = manas.tryIndexOf(caster);
      if (mi == null) continue;

      // Check Mana Cost.
      final spellId = intents.spellId[ii];
      final def = spells.get(spellId);
      final currentMana = manas.mana[mi];
      
      if (currentMana < def.stats.manaCost) continue;

      // Faction is optional generally, but required for projectile ownership usually.
      final fi = factions.tryIndexOf(caster);
      if (fi == null) continue;
      final faction = factions.faction[fi];

      // -- Execution --
      final spawned = spawnSpellProjectileFromCaster(
        world,
        spells: spells,
        projectiles: projectiles,
        spellId: spellId,
        faction: faction,
        owner: caster,
        casterX: transforms.posX[ti],
        casterY: transforms.posY[ti],
        originOffset: intents.originOffset[ii],
        dirX: intents.dirX[ii],
        dirY: intents.dirY[ii],
        fallbackDirX: intents.fallbackDirX[ii],
        fallbackDirY: intents.fallbackDirY[ii],
      );

      // Only apply costs if the spell actually did something (spawned).
      if (spawned == null) continue;

      manas.mana[mi] = clampDouble(
        currentMana - def.stats.manaCost,
        0.0,
        manas.manaMax[mi],
      );
      
      cooldowns.castCooldownTicksLeft[ci] = intents.cooldownTicks[ii];
    }
  }
}


===== FILE: lib/core/ecs/world.dart =====
import 'entity_id.dart';
import 'sparse_set.dart';
import 'stores/body_store.dart';
import 'stores/collider_aabb_store.dart';
import 'stores/collision_state_store.dart';
import 'stores/cooldown_store.dart';
import 'stores/cast_intent_store.dart';
import 'stores/collectible_store.dart';
import 'stores/player/gravity_control_store.dart';
import 'stores/enemies/flying_enemy_steering_store.dart';
import 'stores/faction_store.dart';
import 'stores/enemies/enemy_store.dart';
import 'stores/enemies/ground_enemy_chase_offset_store.dart';
import 'stores/health_store.dart';
import 'stores/hit_once_store.dart';
import 'stores/hitbox_store.dart';
import 'stores/player/invulnerability_store.dart';
import 'stores/player/last_damage_store.dart';
import 'stores/lifetime_store.dart';
import 'stores/mana_store.dart';
import 'stores/melee_intent_store.dart';
import 'stores/player/movement_store.dart';
import 'stores/player/player_input_store.dart';
import 'stores/projectile_store.dart';
import 'stores/restoration_item_store.dart';
import 'stores/spell_origin_store.dart';
import 'stores/stamina_store.dart';
import 'stores/enemies/surface_nav_state_store.dart';
import 'stores/transform_store.dart';

/// Minimal Entity Component System (ECS) world container.
///
/// The [EcsWorld] is the central hub of the ECS architecture. It manages the
/// creation and destruction of entities ([EntityId]) and acts as a registry
/// for all Component Stores.
///
/// Design philosophy:
/// - **Structure-of-Arrays (SoA):** Data is stored in parallel arrays within each
///   [SparseSet] component store, rather than as objects on the entity.
/// - **Composition over Inheritance:** Game objects are defined by the collection
///   of components they possess.
/// - **Pooling:** Entity IDs are recycled to keep memory usage compact and predictable.
///
/// To add functionality to the game, Systems (logic) query this World for Entities
/// with specific components and operate on them.
class EcsWorld {
  /// Creates a new ECS World with an optional [seed] for deterministic behavior.
  EcsWorld({int seed = 0}) : seed = seed;

  /// Seed used for deterministic RNG in the core, passed to components that need it.
  final int seed;

  /// Counter for generating new unique Entity IDs.
  EntityId _nextEntityId = 1;

  /// Pool of recycled Entity IDs available for reuse.
  final List<EntityId> _freeIds = <EntityId>[];

  /// Fast lookup set for recycled IDs to prevent double-freeing.
  final Set<EntityId> _freeIdsSet = <EntityId>{};

  /// Registry of all registered component stores.
  final List<SparseSet> _stores = <SparseSet>[];

  /// Helper to register a store with the world so it receives lifecycle events (like entity destruction).
  T _register<T extends SparseSet>(T store) {
    _stores.add(store);
    return store;
  }

  // --- Component Stores ---
  // Each store manages a specific type of data for entities.

  /// Stores position (x, y) and velocity (vx, vy).
  late final TransformStore transform = _register(TransformStore());

  /// Helper components for handling user input events.
  late final PlayerInputStore playerInput = _register(PlayerInputStore());

  /// Logic and state for movement, including facing direction.
  late final MovementStore movement = _register(MovementStore());

  /// Physics properties like mass, friction, and restitution.
  late final BodyStore body = _register(BodyStore());

  /// Axis-Aligned Bounding Box (AABB) for collision detection.
  late final ColliderAabbStore colliderAabb = _register(ColliderAabbStore());

  /// Runtime state of collisions (e.g., is grounded, wall contact).
  late final CollisionStateStore collision = _register(CollisionStateStore());

  /// Generic cooldown timer for abilities or actions.
  late final CooldownStore cooldown = _register(CooldownStore());

  /// Tracks the player's intent to cast a spell (button presses).
  late final CastIntentStore castIntent = _register(CastIntentStore());

  /// Marks an entity as a collectible item (e.g., coin, power-up).
  late final CollectibleStore collectible = _register(CollectibleStore());

  /// Defines an item that restores stats (health/mana) when collected.
  late final RestorationItemStore restorationItem = _register(RestorationItemStore());

  /// Allows an entity to control or defy gravity.
  late final GravityControlStore gravityControl = _register(GravityControlStore());

  /// Defines which faction (Player, Enemy, Neutral) an entity belongs to.
  late final FactionStore faction = _register(FactionStore());

  /// Manages Health Points (HP) and max HP.
  late final HealthStore health = _register(HealthStore());

  /// Grants temporary invulnerability (i-frames).
  late final InvulnerabilityStore invulnerability = _register(InvulnerabilityStore());

  /// Records the last entity/source that dealt damage to this entity.
  late final LastDamageStore lastDamage = _register(LastDamageStore());

  /// Manages Mana Points (MP) and max MP.
  late final ManaStore mana = _register(ManaStore());

  /// Tracks the player's intent to perform a melee attack.
  late final MeleeIntentStore meleeIntent = _register(MeleeIntentStore());

  /// Manages Stamina Points (SP) and max SP.
  late final StaminaStore stamina = _register(StaminaStore());

  /// Marks an entity as a projectile and defines its properties.
  late final ProjectileStore projectile = _register(ProjectileStore());

  /// Defines an area that deals damage or effects on contact.
  late final HitboxStore hitbox = _register(HitboxStore());

  /// Ensures a hitbox only affects a target once per interaction.
  late final HitOnceStore hitOnce = _register(HitOnceStore());

  /// Despawns entities after a set duration.
  late final LifetimeStore lifetime = _register(LifetimeStore());

  /// Links a spell effect back to its caster or origin point.
  late final SpellOriginStore spellOrigin = _register(SpellOriginStore());

  /// State for ground enemies navigating terrain (jumping gaps/walls).
  late final SurfaceNavStateStore surfaceNav = _register(SurfaceNavStateStore());

  /// Identifies an entity as a specific type of enemy.
  late final EnemyStore enemy = _register(EnemyStore());

  /// Steering behaviors for flying enemies.
  late final FlyingEnemySteeringStore flyingEnemySteering = _register(FlyingEnemySteeringStore());

  /// AI state for ground enemies to create offset chasing behaviors.
  late final GroundEnemyChaseOffsetStore groundEnemyChaseOffset =
      _register(GroundEnemyChaseOffsetStore());

  /// Allocates a new [EntityId].
  ///
  /// Prefers reusing ID from the free pool if available; otherwise increments the counter.
  EntityId createEntity() {
    if (_freeIds.isNotEmpty) {
      final id = _freeIds.removeLast();
      _freeIdsSet.remove(id);
      return id;
    }
    final id = _nextEntityId;
    _nextEntityId += 1;
    return id;
  }

  /// Destroys [entity], removing it from all component stores.
  ///
  /// The ID is returned to the free pool for future reuse.
  /// Does nothing if the entity is already destroyed/free.
  void destroyEntity(EntityId entity) {
    if (_freeIdsSet.contains(entity)) {
      return;
    }
    for (final store in _stores) {
      store.removeEntity(entity);
    }
    _freeIds.add(entity);
    _freeIdsSet.add(entity);
  }
}


===== FILE: lib/core/enemies/enemy_catalog.dart =====
import '../ecs/stores/body_store.dart';
import '../ecs/stores/collider_aabb_store.dart';
import '../ecs/stores/health_store.dart';
import '../ecs/stores/mana_store.dart';
import '../ecs/stores/stamina_store.dart';
import 'enemy_id.dart';

/// Defines the base stats and physics properties for an enemy type.
///
/// This data is "static" (read-only) configuration used to initialize
/// the ECS components effectively when an enemy spawns.
class EnemyArchetype {
  const EnemyArchetype({
    required this.body,
    required this.collider,
    required this.health,
    required this.mana,
    required this.stamina,
  });

  /// Physics configuration (Gravity, Constraints, Kinematics).
  final BodyDef body;
  
  /// Hitbox size (Collision).
  final ColliderAabbDef collider;
  
  /// Vitals (HP, Mana, Stamina) configuration.
  final HealthDef health;
  final ManaDef mana;
  final StaminaDef stamina;
}

/// Central registry for Enemy Definitions.
///
/// **Usage**:
/// - Accessed by `EnemySpawnSystem` (or similar) to hydration entities.
/// - Decouples "What an enemy is" from "How to spawn it".
class EnemyCatalog {
  const EnemyCatalog();

  /// Returns the static archetype definition for a given [EnemyId].
  ///
  /// Note: The returned objects are `const` and allocation-light.
  EnemyArchetype get(EnemyId id) {
    switch (id) {
      case EnemyId.flyingEnemy:
        return const EnemyArchetype(
          body: BodyDef(
            isKinematic: false,
            useGravity: false,
            gravityScale: 0.0,
            sideMask: BodyDef.sideNone,
            maxVelX: 800.0,
            maxVelY: 800.0,
          ),
          collider: ColliderAabbDef(halfX: 12.0, halfY: 12.0),
          health: HealthDef(hp: 20.0, hpMax: 20.0, regenPerSecond: 0.5),
          mana: ManaDef(mana: 80.0, manaMax: 80.0, regenPerSecond: 5.0),
          stamina: StaminaDef(stamina: 0.0, staminaMax: 0.0, regenPerSecond: 0.0),
        );
        
      case EnemyId.groundEnemy:
        return const EnemyArchetype(
          body: BodyDef(
            isKinematic: false,
            useGravity: true,
            ignoreCeilings: true,
            gravityScale: 1.0,
            sideMask: BodyDef.sideLeft | BodyDef.sideRight,
          ),
          collider: ColliderAabbDef(halfX: 12.0, halfY: 12.0),
          health: HealthDef(hp: 20.0, hpMax: 20.0, regenPerSecond: 0.5),
          mana: ManaDef(mana: 0.0, manaMax: 0.0, regenPerSecond: 0.0),
          stamina: StaminaDef(stamina: 0.0, staminaMax: 0.0, regenPerSecond: 0.0),
        );
    }
  }
}



===== FILE: lib/core/enemies/enemy_id.dart =====
/// Unique identifiers for enemy types.
///
/// **Usage**:
/// - Used for spawning via `SpawnSystem`.
/// - keys for `EnemyCatalog` lookup.
/// - Stable identifiers for networking/snapshots (protocol-stable).
enum EnemyId {
  /// A basic flying enemy that ignores gravity and casts spells.
  flyingEnemy,

  /// A basic ground chasing enemy that is affected by gravity.
  groundEnemy,
}



===== FILE: lib/core/events/game_event.dart =====
/// Core -> Render/UI event model.
///
/// **Architecture**:
/// - "Events" in this context are **transient side effects** emitted by the simulation.
/// - Examples: SFX triggers, Particle spawns, Run completion, Screen shake.
/// - They are distinct from "State" (Snapshots). State is continuous; Events are discrete.
///
/// **Usage**:
/// - Systems emit events into a queue.
/// - The GameController or UI layer consumes them (e.g., to play a sound or show a dialog).
/// - Events are fire-and-forget.
library;
import '../enemies/enemy_id.dart';
import '../projectiles/projectile_id.dart';
import '../spells/spell_id.dart';

part 'run_events.dart';

/// Base sealed class for all simulation events.
sealed class GameEvent {
  const GameEvent();
}


===== FILE: lib/core/events/run_events.dart =====
part of 'game_event.dart';

/// The specific cause for a run ending.
enum RunEndReason {
  /// Player was too slow and scrolled off the screen.
  fellBehindCamera,
  
  /// Player fell into a death pit.
  fellIntoGap,
  
  /// HP reached 0 (combat death).
  playerDied,
  
  /// User manually exited the run.
  gaveUp,
}

/// Identifies the category of damage source that caused death.
enum DeathSourceKind {
  projectile,
  meleeHitbox,
  unknown,
}

/// Detailed context about what killed the player.
class DeathInfo {
  const DeathInfo({
    required this.kind,
    this.enemyId,
    this.projectileId,
    this.spellId,
  });

  /// Category of the damage source.
  final DeathSourceKind kind;
  
  /// The [EnemyId] responsible (if applicable).
  final EnemyId? enemyId;
  
  /// The [ProjectileId] responsible (if applicable).
  final ProjectileId? projectileId;
  
  /// The [SpellId] responsible (if applicable).
  final SpellId? spellId;
}

/// Aggregate statistics collected during a run.
class RunEndStats {
  const RunEndStats({
    required this.collectibles,
    required this.collectibleScore,
    required this.enemyKillCounts,
  });

  /// Total count of collectibles picked up.
  final int collectibles;
  
  /// Total score value of collectibles.
  final int collectibleScore;

  /// Kill counts per enemy type.
  ///
  /// **Ordering**: Indices strictly align with [EnemyId.values].
  /// `enemyKillCounts[i]` corresponds to the kills for the enemy at `EnemyId.values[i]`.
  final List<int> enemyKillCounts;
}

/// Event emitted when the game session terminates.
///
/// Contains all necessary data to display the "Game Over" screen.
class RunEndedEvent extends GameEvent {
  const RunEndedEvent({
    required this.tick,
    required this.distance,
    required this.reason,
    required this.stats,
    this.deathInfo,
  });

  /// The tick on which the run ended.
  final int tick;
  
  /// Total distance traveled (meters/pixels).
  final double distance;
  
  /// Why the run ended (Death vs GiveUp).
  final RunEndReason reason;
  
  /// Performance stats.
  final RunEndStats stats;
  
  /// Details on the lethal hit (if applicable).
  final DeathInfo? deathInfo;
}


===== FILE: lib/core/game_core.dart =====
// Authoritative, deterministic simulation layer (pure Dart).
//
// This is the "truth" of the game: it applies tick-stamped commands, advances
// the simulation by fixed ticks, and produces snapshots/events for the
// renderer/UI. It must not import Flutter or Flame.
import 'dart:math';

import 'commands/command.dart';
import 'camera/autoscroll_camera.dart';
import 'collision/static_world_geometry_index.dart';
import 'contracts/render_contract.dart';
import 'ecs/entity_id.dart';
import 'ecs/entity_factory.dart';
import 'ecs/hit/aabb_hit_utils.dart';
import 'ecs/spatial/broadphase_grid.dart';
import 'ecs/spatial/grid_index_2d.dart';
import 'ecs/systems/collision_system.dart';
import 'ecs/systems/collectible_system.dart';
import 'ecs/systems/cooldown_system.dart';
import 'ecs/systems/gravity_system.dart';
import 'ecs/systems/player_cast_system.dart';
import 'ecs/systems/spell_cast_system.dart';
import 'ecs/systems/damage_system.dart';
import 'ecs/systems/health_despawn_system.dart';
import 'ecs/systems/enemy_system.dart';
import 'ecs/systems/hitbox_damage_system.dart';
import 'ecs/systems/hitbox_follow_owner_system.dart';
import 'ecs/systems/invulnerability_system.dart';
import 'ecs/systems/lifetime_system.dart';
import 'ecs/systems/player_melee_system.dart';
import 'ecs/systems/melee_attack_system.dart';
import 'ecs/systems/player_movement_system.dart';
import 'ecs/systems/projectile_system.dart';
import 'ecs/systems/projectile_hit_system.dart';
import 'ecs/systems/resource_regen_system.dart';
import 'ecs/systems/restoration_item_system.dart';
import 'ecs/stores/body_store.dart';
import 'ecs/stores/collider_aabb_store.dart';
import 'ecs/stores/collectible_store.dart';
import 'ecs/stores/restoration_item_store.dart';
import 'ecs/world.dart';
import 'enemies/enemy_catalog.dart';
import 'enemies/enemy_id.dart';
import 'events/game_event.dart';
import 'util/vec2.dart';
import 'navigation/jump_template.dart';
import 'navigation/nav_tolerances.dart';
import 'navigation/surface_graph.dart';
import 'navigation/surface_graph_builder.dart';
import 'navigation/surface_navigator.dart';
import 'navigation/surface_pathfinder.dart';
import 'navigation/surface_spatial_index.dart';
import 'players/player_catalog.dart';
import 'snapshots/enums.dart';
import 'snapshots/entity_render_snapshot.dart';
import 'snapshots/game_state_snapshot.dart';
import 'snapshots/player_hud_snapshot.dart';
import 'snapshots/static_ground_gap_snapshot.dart';
import 'snapshots/static_solid_snapshot.dart';
import 'projectiles/projectile_catalog.dart';
import 'spells/spell_catalog.dart';
import 'spells/spell_id.dart';
import 'track/track_streamer.dart';
import 'tuning/ability_tuning.dart';
import 'tuning/combat_tuning.dart';
import 'tuning/flying_enemy_tuning.dart';
import 'tuning/ground_enemy_tuning.dart';
import 'tuning/movement_tuning.dart';
import 'tuning/navigation_tuning.dart';
import 'tuning/physics_tuning.dart';
import 'tuning/resource_tuning.dart';
import 'tuning/score_tuning.dart';
import 'tuning/camera_tuning.dart';
import 'tuning/collectible_tuning.dart';
import 'tuning/restoration_item_tuning.dart';
import 'tuning/spatial_grid_tuning.dart';
import 'tuning/track_tuning.dart';
import 'util/deterministic_rng.dart';
import 'util/tick_math.dart';

/// Minimal placeholder `GameCore` used to validate architecture wiring.
///
/// This will be replaced by the full ECS/systems implementation in later
/// milestones. The core invariants remain: fixed ticks, command-driven input,
/// deterministic state updates, snapshot output.
class GameCore {
  GameCore({
    required this.seed,
    this.tickHz = defaultTickHz,
    PhysicsTuning physicsTuning = const PhysicsTuning(),
    MovementTuning movementTuning = const MovementTuning(),
    ResourceTuning resourceTuning = const ResourceTuning(),
    AbilityTuning abilityTuning = const AbilityTuning(),
    CombatTuning combatTuning = const CombatTuning(),
    FlyingEnemyTuning flyingEnemyTuning = const FlyingEnemyTuning(),
    GroundEnemyTuning groundEnemyTuning = const GroundEnemyTuning(),
    NavigationTuning navigationTuning = const NavigationTuning(),
    SpatialGridTuning spatialGridTuning = const SpatialGridTuning(),
    CameraTuning cameraTuning = const CameraTuning(),
    TrackTuning trackTuning = const TrackTuning(),
    CollectibleTuning collectibleTuning = const CollectibleTuning(),
    RestorationItemTuning restorationItemTuning =
        const RestorationItemTuning(),
    ScoreTuning scoreTuning = const ScoreTuning(),
    SpellCatalog spellCatalog = const SpellCatalog(),
    ProjectileCatalog projectileCatalog = const ProjectileCatalog(),
    EnemyCatalog enemyCatalog = const EnemyCatalog(),
    PlayerCatalog playerCatalog = const PlayerCatalog(),
    StaticWorldGeometry staticWorldGeometry = const StaticWorldGeometry(
      groundPlane: StaticGroundPlane(topY: groundTopY * 1.0),
    ),
  }) : _movement = MovementTuningDerived.from(movementTuning, tickHz: tickHz),
       _physicsTuning = physicsTuning,
       _resourceTuning = resourceTuning,
       _abilities = AbilityTuningDerived.from(abilityTuning, tickHz: tickHz),
       _combat = CombatTuningDerived.from(combatTuning, tickHz: tickHz),
       _flyingEnemyTuning = FlyingEnemyTuningDerived.from(
         flyingEnemyTuning,
         tickHz: tickHz,
       ),
       _groundEnemyTuning = GroundEnemyTuningDerived.from(
         groundEnemyTuning,
         tickHz: tickHz,
       ),
       _navigationTuning = navigationTuning,
       _spatialGridTuning = spatialGridTuning,
       _spells = spellCatalog,
       _projectiles = ProjectileCatalogDerived.from(
         projectileCatalog,
         tickHz: tickHz,
       ),
       _enemyCatalog = enemyCatalog,
       _playerCatalog = playerCatalog,
       _baseStaticWorldGeometry = staticWorldGeometry,
       _scoreTuning = scoreTuning,
       _trackTuning = trackTuning,
       _collectibleTuning = collectibleTuning,
       _restorationItemTuning = restorationItemTuning {
    _world = EcsWorld(seed: seed);
    _entityFactory = EntityFactory(_world);
    _movementSystem = PlayerMovementSystem();
    _collisionSystem = CollisionSystem();
    _cooldownSystem = CooldownSystem();
    _gravitySystem = GravitySystem();
    _projectileSystem = ProjectileSystem();
    _projectileHitSystem = ProjectileHitSystem();
    _broadphaseGrid = BroadphaseGrid(
      index: GridIndex2D(cellSize: _spatialGridTuning.broadphaseCellSize),
    );
    _hitboxFollowOwnerSystem = HitboxFollowOwnerSystem();
    _lifetimeSystem = LifetimeSystem();
    _invulnerabilitySystem = InvulnerabilitySystem();
    _damageSystem = DamageSystem(
      invulnerabilityTicksOnHit: _combat.invulnerabilityTicks,
    );
    _healthDespawnSystem = HealthDespawnSystem();
    _meleeSystem = PlayerMeleeSystem(
      abilities: _abilities,
      movement: _movement,
    );
    _hitboxDamageSystem = HitboxDamageSystem();
    _collectibleSystem = CollectibleSystem();
    _restorationItemSystem = RestorationItemSystem();
    _resourceRegenSystem = ResourceRegenSystem();
    _castSystem = PlayerCastSystem(abilities: _abilities, movement: _movement);
    _spellCastSystem = SpellCastSystem(
      spells: _spells,
      projectiles: _projectiles,
    );
    _meleeAttackSystem = MeleeAttackSystem();
    _surfaceGraphBuilder = SurfaceGraphBuilder(
      surfaceGrid: GridIndex2D(cellSize: _spatialGridTuning.broadphaseCellSize),
      takeoffSampleMaxStep: _navigationTuning.takeoffSampleMaxStep,
    );
    _groundEnemyJumpTemplate = JumpReachabilityTemplate.build(
      JumpProfile(
        jumpSpeed: _groundEnemyTuning.base.groundEnemyJumpSpeed,
        gravityY: _physicsTuning.gravityY,
        maxAirTicks: _groundEnemyMaxAirTicks(),
        airSpeedX: _groundEnemyTuning.base.groundEnemySpeedX,
        dtSeconds: _movement.dtSeconds,
        agentHalfWidth: _enemyCatalog.get(EnemyId.groundEnemy).collider.halfX,
      ),
    );
    _surfacePathfinder = SurfacePathfinder(
      maxExpandedNodes: _navigationTuning.maxExpandedNodes,
      runSpeedX: _groundEnemyTuning.base.groundEnemySpeedX,
      edgePenaltySeconds: _navigationTuning.edgePenaltySeconds,
    );
    _surfaceNavigator = SurfaceNavigator(
      pathfinder: _surfacePathfinder,
      repathCooldownTicks: _navigationTuning.repathCooldownTicks,
      surfaceEps: _navigationTuning.surfaceEps,
      takeoffEps: max(
        _navigationTuning.takeoffEpsMin,
        _groundEnemyTuning.base.groundEnemyStopDistanceX,
      ),
    );
    _enemySystem = EnemySystem(
      flyingEnemyTuning: _flyingEnemyTuning,
      groundEnemyTuning: _groundEnemyTuning,
      surfaceNavigator: _surfaceNavigator,
      spells: _spells,
      projectiles: _projectiles,
    );
    _cameraTuning = CameraTuningDerived.from(
      cameraTuning,
      movement: _movement,
    );
    _camera = AutoscrollCamera(
      viewWidth: virtualWidth.toDouble(),
      tuning: _cameraTuning,
      initial: CameraState(
        centerX: virtualWidth * 0.5,
        targetX: virtualWidth * 0.5,
        speedX: 0.0,
      ),
    );

    _setStaticWorldGeometry(_baseStaticWorldGeometry);

    final spawnX = 400.0;
    final playerArchetype = PlayerCatalogDerived.from(
      _playerCatalog,
      movement: _movement,
      resources: _resourceTuning,
    ).archetype;
    final playerCollider = playerArchetype.collider;
    final spawnY =
        (_staticWorldGeometry.groundPlane?.topY ?? groundTopY.toDouble()) -
        (playerCollider.offsetY + playerCollider.halfY);
    _player = _entityFactory.createPlayer(
      posX: spawnX,
      posY: spawnY,
      velX: 0.0,
      velY: 0.0,
      facing: playerArchetype.facing,
      grounded: true,
      body: playerArchetype.body,
      collider: playerCollider,
      health: playerArchetype.health,
      mana: playerArchetype.mana,
      stamina: playerArchetype.stamina,
    );

    // Milestone 12: stream deterministic chunks (static solids + enemy spawns).
    // Track streaming is controlled by `trackTuning.enabled`. When enabled, the
    // streamed solids are merged on top of the provided base geometry.
    if (_trackTuning.enabled) {
      final effectiveGroundTopY =
          _staticWorldGeometry.groundPlane?.topY ?? groundTopY.toDouble();
      _trackStreamer = TrackStreamer(
        seed: seed,
        tuning: _trackTuning,
        groundTopY: effectiveGroundTopY,
      );
      _trackStreamerStep();
    }
  }

  EntityId _spawnFlyingEnemy({
    required double spawnX,
    required double groundTopY,
  }) {
    // Enemy spawn stats come from a centralized catalog so these hardcoded spawns
    // don't diverge from future deterministic spawning rules.
    final archetype = _enemyCatalog.get(EnemyId.flyingEnemy);
    final flyingEnemy = _entityFactory.createEnemy(
      enemyId: EnemyId.flyingEnemy,
      posX: spawnX,
      posY: groundTopY - _flyingEnemyTuning.base.flyingEnemyHoverOffsetY,
      velX: 0.0,
      velY: 0.0,
      facing: Facing.left,
      body: archetype.body,
      collider: archetype.collider,
      health: archetype.health,
      mana: archetype.mana,
      stamina: archetype.stamina,
    );

    // Avoid immediate spawn-tick casting (keeps early-game tests stable).
    _world.cooldown.castCooldownTicksLeft[_world.cooldown.indexOf(
          flyingEnemy,
        )] =
        _flyingEnemyTuning.flyingEnemyCastCooldownTicks;

    return flyingEnemy;
  }

  EntityId _spawnGroundEnemy({
    required double spawnX,
    required double groundTopY,
  }) {
    final archetype = _enemyCatalog.get(EnemyId.groundEnemy);

    // GroundEnemy uses the archetype, but clamps should stay aligned with the
    // current movement tuning.
    return _entityFactory.createEnemy(
      enemyId: EnemyId.groundEnemy,
      posX: spawnX,
      posY: groundTopY - archetype.collider.halfY,
      velX: 0.0,
      velY: 0.0,
      facing: Facing.left,
      body: BodyDef(
        enabled: archetype.body.enabled,
        isKinematic: archetype.body.isKinematic,
        useGravity: archetype.body.useGravity,
        ignoreCeilings: archetype.body.ignoreCeilings,
        topOnlyGround: archetype.body.topOnlyGround,
        gravityScale: archetype.body.gravityScale,
        maxVelX: _movement.base.maxVelX,
        maxVelY: _movement.base.maxVelY,
        sideMask: archetype.body.sideMask,
      ),
      collider: archetype.collider,
      health: archetype.health,
      mana: archetype.mana,
      stamina: archetype.stamina,
    );
  }

  EntityId _spawnCollectibleAt(double x, double y) {
    final half = _collectibleTuning.collectibleSize * 0.5;
    final entity = _world.createEntity();
    _world.transform.add(entity, posX: x, posY: y, velX: 0.0, velY: 0.0);
    _world.colliderAabb.add(
      entity,
      ColliderAabbDef(halfX: half, halfY: half),
    );
    _world.collectible.add(
      entity,
      CollectibleDef(value: _collectibleTuning.valuePerCollectible),
    );
    return entity;
  }

  EntityId _spawnRestorationItemAt(
    double x,
    double y,
    RestorationStat stat,
  ) {
    final half = _restorationItemTuning.itemSize * 0.5;
    final entity = _world.createEntity();
    _world.transform.add(entity, posX: x, posY: y, velX: 0.0, velY: 0.0);
    _world.colliderAabb.add(
      entity,
      ColliderAabbDef(halfX: half, halfY: half),
    );
    _world.restorationItem.add(
      entity,
      RestorationItemDef(stat: stat),
    );
    return entity;
  }

  void _spawnCollectiblesForChunk(int chunkIndex, double chunkStartX) {
    final tuning = _collectibleTuning;
    if (!tuning.enabled) return;
    if (chunkIndex < tuning.spawnStartChunkIndex) return;
    if (tuning.maxPerChunk <= 0) return;

    final graph = _surfaceGraph;
    final spatialIndex = _surfaceSpatialIndex;
    if (graph == null || spatialIndex == null || graph.surfaces.isEmpty) {
      return;
    }

    final minX = chunkStartX + tuning.chunkEdgeMarginX;
    final maxX = chunkStartX + _trackTuning.chunkWidth - tuning.chunkEdgeMarginX;
    if (maxX <= minX) return;

    var rngState = seedFrom(seed, chunkIndex ^ 0xC011EC7);
    rngState = nextUint32(rngState);
    final countRange = tuning.maxPerChunk - tuning.minPerChunk + 1;
    final targetCount = tuning.minPerChunk + (rngState % countRange);
    if (targetCount <= 0) return;

    _collectibleSpawnXs.clear();
    final halfSize = tuning.collectibleSize * 0.5;
    final maxAttempts = tuning.maxAttemptsPerChunk;
    for (var attempt = 0;
        attempt < maxAttempts && _collectibleSpawnXs.length < targetCount;
        attempt += 1) {
      rngState = nextUint32(rngState);
      var x = rangeDouble(rngState, minX, maxX);
      x = _snapToGrid(x, _trackTuning.gridSnap);
      if (x < minX || x > maxX) continue;

      if (tuning.minSpacingX > 0.0) {
        var spaced = true;
        for (final prevX in _collectibleSpawnXs) {
          if ((prevX - x).abs() < tuning.minSpacingX) {
            spaced = false;
            break;
          }
        }
        if (!spaced) continue;
      }

      final surfaceY = _highestSurfaceYAtX(x);
      if (surfaceY == null) continue;
      final centerY = surfaceY - tuning.surfaceClearanceY - halfSize;
      if (_overlapsAnySolid(
        centerX: x,
        centerY: centerY,
        halfSize: halfSize,
        margin: tuning.noSpawnMargin,
      )) {
        continue;
      }

      _spawnCollectibleAt(x, centerY);
      _collectibleSpawnXs.add(x);
    }
  }

  void _spawnRestorationItemForChunk(int chunkIndex, double chunkStartX) {
    final tuning = _restorationItemTuning;
    if (!tuning.enabled) return;
    if (chunkIndex < tuning.spawnStartChunkIndex) return;
    if (tuning.spawnEveryChunks <= 0) return;

    final phase = seedFrom(seed, 0xA17E5A7) % tuning.spawnEveryChunks;
    if ((chunkIndex - phase) % tuning.spawnEveryChunks != 0) return;

    final graph = _surfaceGraph;
    final spatialIndex = _surfaceSpatialIndex;
    if (graph == null || spatialIndex == null || graph.surfaces.isEmpty) {
      return;
    }

    final minX = chunkStartX + tuning.chunkEdgeMarginX;
    final maxX = chunkStartX + _trackTuning.chunkWidth - tuning.chunkEdgeMarginX;
    if (maxX <= minX) return;

    final stat = _lowestResourceStat();
    var rngState = seedFrom(seed, chunkIndex ^ 0xA57A11);
    final halfSize = tuning.itemSize * 0.5;
    for (var attempt = 0; attempt < tuning.maxAttemptsPerSpawn; attempt += 1) {
      rngState = nextUint32(rngState);
      var x = rangeDouble(rngState, minX, maxX);
      x = _snapToGrid(x, _trackTuning.gridSnap);
      if (x < minX || x > maxX) continue;

      final surfaceY = _highestSurfaceYAtX(x);
      if (surfaceY == null) continue;
      final centerY = surfaceY - tuning.surfaceClearanceY - halfSize;
      if (_overlapsAnySolid(
        centerX: x,
        centerY: centerY,
        halfSize: halfSize,
        margin: tuning.noSpawnMargin,
      )) {
        continue;
      }
      if (_overlapsAnyCollectible(
        centerX: x,
        centerY: centerY,
        halfSize: halfSize,
        margin: tuning.noSpawnMargin,
      )) {
        continue;
      }

      _spawnRestorationItemAt(x, centerY, stat);
      return;
    }
  }

  /// Seed used for deterministic generation/RNG.
  final int seed;

  /// Fixed simulation tick frequency.
  final int tickHz;

  /// Base static world geometry for this run/session (hand-authored seed state).
  final StaticWorldGeometry _baseStaticWorldGeometry;

  /// Current static world geometry (base + any streamed chunk solids).
  StaticWorldGeometry get staticWorldGeometry => _staticWorldGeometry;
  late StaticWorldGeometry _staticWorldGeometry;
  late StaticWorldGeometryIndex _staticWorldIndex;
  late List<StaticSolidSnapshot> _staticSolidsSnapshot;
  late List<StaticGroundGapSnapshot> _staticGroundGapsSnapshot;

  final MovementTuningDerived _movement;
  final PhysicsTuning _physicsTuning;
  final ResourceTuning _resourceTuning;
  final AbilityTuningDerived _abilities;
  final CombatTuningDerived _combat;
  final FlyingEnemyTuningDerived _flyingEnemyTuning;
  final GroundEnemyTuningDerived _groundEnemyTuning;
  final NavigationTuning _navigationTuning;
  final SpatialGridTuning _spatialGridTuning;
  late final CameraTuningDerived _cameraTuning;
  final ScoreTuning _scoreTuning;
  final TrackTuning _trackTuning;
  final CollectibleTuning _collectibleTuning;
  final RestorationItemTuning _restorationItemTuning;
  final SpellCatalog _spells;
  final ProjectileCatalogDerived _projectiles;
  final EnemyCatalog _enemyCatalog;
  final PlayerCatalog _playerCatalog;
  late final SurfaceGraphBuilder _surfaceGraphBuilder;
  late final JumpReachabilityTemplate _groundEnemyJumpTemplate;
  int _surfaceGraphVersion = 0;

  TrackStreamer? _trackStreamer;

  late final EcsWorld _world;
  late final EntityFactory _entityFactory;
  late final PlayerMovementSystem _movementSystem;
  late final CollisionSystem _collisionSystem;
  late final CooldownSystem _cooldownSystem;
  late final GravitySystem _gravitySystem;
  late final ProjectileSystem _projectileSystem;
  late final ProjectileHitSystem _projectileHitSystem;
  late final BroadphaseGrid _broadphaseGrid;
  late final HitboxFollowOwnerSystem _hitboxFollowOwnerSystem;
  late final CollectibleSystem _collectibleSystem;
  late final RestorationItemSystem _restorationItemSystem;
  late final LifetimeSystem _lifetimeSystem;
  late final InvulnerabilitySystem _invulnerabilitySystem;
  late final DamageSystem _damageSystem;
  late final HealthDespawnSystem _healthDespawnSystem;
  late final EnemySystem _enemySystem;
  late final SurfacePathfinder _surfacePathfinder;
  late final SurfaceNavigator _surfaceNavigator;
  late final PlayerMeleeSystem _meleeSystem;
  late final MeleeAttackSystem _meleeAttackSystem;
  late final HitboxDamageSystem _hitboxDamageSystem;
  late final ResourceRegenSystem _resourceRegenSystem;
  late final PlayerCastSystem _castSystem;
  late final SpellCastSystem _spellCastSystem;
  late final EntityId _player;
  late final AutoscrollCamera _camera;

  final List<GameEvent> _events = <GameEvent>[];
  final List<EnemyId> _killedEnemiesScratch = <EnemyId>[];
  final List<int> _enemyKillCounts =
      List<int>.filled(EnemyId.values.length, 0);
  final List<int> _surfaceQueryCandidates = <int>[];
  final List<double> _collectibleSpawnXs = <double>[];

  SurfaceGraph? _surfaceGraph;
  SurfaceSpatialIndex? _surfaceSpatialIndex;
  double _surfaceMinY = 0.0;
  double _surfaceMaxY = 0.0;

  /// Current simulation tick.
  int tick = 0;

  /// Whether simulation should advance.
  bool paused = false;

  /// Whether the run has ended (simulation is frozen).
  bool gameOver = false;

  ScoreTuning get scoreTuning => _scoreTuning;

  /// Run progression metric (placeholder).
  double distance = 0;

  /// Collected collectibles (placeholder for V0).
  int collectibles = 0;

  /// Collectible score value (not yet applied to run score).
  int collectibleScore = 0;

  double get playerPosX =>
      _world.transform.posX[_world.transform.indexOf(_player)];
  double get playerPosY =>
      _world.transform.posY[_world.transform.indexOf(_player)];

  void setPlayerPosXY(double x, double y) =>
      _world.transform.setPosXY(_player, x, y);

  double get playerVelX =>
      _world.transform.velX[_world.transform.indexOf(_player)];
  double get playerVelY =>
      _world.transform.velY[_world.transform.indexOf(_player)];

  void setPlayerVelXY(double x, double y) =>
      _world.transform.setVelXY(_player, x, y);

  bool get playerGrounded =>
      _world.collision.grounded[_world.collision.indexOf(_player)];

  Facing get playerFacing =>
      _world.movement.facing[_world.movement.indexOf(_player)];
  set playerFacing(Facing value) {
    _world.movement.facing[_world.movement.indexOf(_player)] = value;
  }

  int get playerCastCooldownTicksLeft =>
      _world.cooldown.castCooldownTicksLeft[_world.cooldown.indexOf(_player)];

  int get playerMeleeCooldownTicksLeft =>
      _world.cooldown.meleeCooldownTicksLeft[_world.cooldown.indexOf(_player)];

  /// Applies all commands scheduled for the current tick.
  ///
  /// In the final architecture, commands are the only mechanism for the UI to
  /// influence the simulation.
  void applyCommands(List<Command> commands) {
    _world.playerInput.resetTickInputs(_player);
    final inputIndex = _world.playerInput.indexOf(_player);
    final movementIndex = _world.movement.indexOf(_player);

    for (final command in commands) {
      switch (command) {
        case MoveAxisCommand(:final axis):
          final clamped = axis.clamp(-1.0, 1.0);
          _world.playerInput.moveAxis[inputIndex] = clamped;

          if (_world.movement.dashTicksLeft[movementIndex] == 0) {
            if (clamped < 0) {
              playerFacing = Facing.left;
            } else if (clamped > 0) {
              playerFacing = Facing.right;
            }
          }
        case JumpPressedCommand():
          _world.playerInput.jumpPressed[inputIndex] = true;
        case DashPressedCommand():
          _world.playerInput.dashPressed[inputIndex] = true;
        case AttackPressedCommand():
          _world.playerInput.attackPressed[inputIndex] = true;
          break;
        case ProjectileAimDirCommand(:final x, :final y):
          _world.playerInput.projectileAimDirX[inputIndex] = x;
          _world.playerInput.projectileAimDirY[inputIndex] = y;
        case MeleeAimDirCommand(:final x, :final y):
          _world.playerInput.meleeAimDirX[inputIndex] = x;
          _world.playerInput.meleeAimDirY[inputIndex] = y;
        case ClearProjectileAimDirCommand():
          _world.playerInput.projectileAimDirX[inputIndex] = 0;
          _world.playerInput.projectileAimDirY[inputIndex] = 0;
        case ClearMeleeAimDirCommand():
          _world.playerInput.meleeAimDirX[inputIndex] = 0;
          _world.playerInput.meleeAimDirY[inputIndex] = 0;
        case CastPressedCommand():
          _world.playerInput.castPressed[inputIndex] = true;
      }
    }
  }

  /// Advances the simulation by exactly one fixed tick.
  void stepOneTick() {
    if (paused || gameOver) return;

    tick += 1;

    _trackStreamerStep();

    _cooldownSystem.step(_world);
    _invulnerabilitySystem.step(_world);

    final effectiveGroundTopY =
        staticWorldGeometry.groundPlane?.topY ?? groundTopY.toDouble();
    _enemySystem.stepSteering(
      _world,
      player: _player,
      groundTopY: effectiveGroundTopY,
      dtSeconds: _movement.dtSeconds,
    );

    _movementSystem.step(_world, _movement, resources: _resourceTuning);
    _gravitySystem.step(_world, _movement, physics: _physicsTuning);
    _collisionSystem.step(_world, _movement, staticWorld: _staticWorldIndex);

    distance += max(0.0, playerVelX) * _movement.dtSeconds;

    if (_checkFellIntoGap(effectiveGroundTopY)) {
      gameOver = true;
      paused = true;
      _events.add(
        RunEndedEvent(
          tick: tick,
          distance: distance,
          reason: RunEndReason.fellIntoGap,
          stats: _buildRunEndStats(),
        ),
      );
      return;
    }

    _camera.updateTick(dtSeconds: _movement.dtSeconds, playerX: playerPosX);
    if (_checkFellBehindCamera()) {
      gameOver = true;
      paused = true;
      _events.add(
        RunEndedEvent(
          tick: tick,
          distance: distance,
          reason: RunEndReason.fellBehindCamera,
          stats: _buildRunEndStats(),
        ),
      );
      return;
    }

    _collectibleSystem.step(
      _world,
      player: _player,
      cameraLeft: _camera.left(),
      tuning: _collectibleTuning,
      onCollected: (value) {
        collectibles += 1;
        collectibleScore += value;
      },
    );
    _restorationItemSystem.step(
      _world,
      player: _player,
      cameraLeft: _camera.left(),
      tuning: _restorationItemTuning,
    );

    // Rebuild broadphase after movement/collision so damageable target positions
    // are final for the tick before any hit queries run.
    _broadphaseGrid.rebuild(_world);

    // Move already-existing projectiles before spawning new ones so newly spawned
    // projectiles remain at their spawn positions until the next tick.
    _projectileSystem.step(_world, _movement);

    // IMPORTANT (determinism): intent writers run in a fixed order (enemy first,
    // then player), and shared execution consumes only intents stamped for this tick.
    _enemySystem.stepAttacks(_world, player: _player, currentTick: tick);
    _castSystem.step(_world, player: _player, currentTick: tick);
    _meleeSystem.step(_world, player: _player, currentTick: tick);

    // Execute intents after all writers have run.
    _spellCastSystem.step(_world, currentTick: tick);
    _meleeAttackSystem.step(_world, currentTick: tick);

    // Position hitboxes from their owner + offset so spawn-time positions are
    // consistent and don't drift (single source of truth is `HitboxStore.offset`).
    _hitboxFollowOwnerSystem.step(_world);

    // Resolve hits after all attacks have been spawned so both newly spawned
    // projectiles and hitboxes can hit on their spawn tick.
    _projectileHitSystem.step(_world, _damageSystem.queue, _broadphaseGrid);
    _hitboxDamageSystem.step(_world, _damageSystem.queue, _broadphaseGrid);
    _damageSystem.step(_world, currentTick: tick);
    _killedEnemiesScratch.clear();
    _healthDespawnSystem.step(
      _world,
      player: _player,
      outEnemiesKilled: _killedEnemiesScratch,
    );
    if (_killedEnemiesScratch.isNotEmpty) {
      _recordEnemyKills(_killedEnemiesScratch);
    }
    if (_isPlayerDead()) {
      final deathInfo = _buildDeathInfo();
      gameOver = true;
      paused = true;
      _events.add(
        RunEndedEvent(
          tick: tick,
          distance: distance,
          reason: RunEndReason.playerDied,
          stats: _buildRunEndStats(),
          deathInfo: deathInfo,
        ),
      );
      return;
    }
    _resourceRegenSystem.step(_world, dtSeconds: _movement.dtSeconds);

    // Cleanup last so effect entities get their full last tick to act.
    _lifetimeSystem.step(_world);
  }

  void _recordEnemyKills(List<EnemyId> killedEnemies) {
    for (final enemyId in killedEnemies) {
      final index = enemyId.index;
      if (index < 0 || index >= _enemyKillCounts.length) continue;
      _enemyKillCounts[index] += 1;
    }
  }

  RunEndStats _buildRunEndStats() => RunEndStats(
    collectibles: collectibles,
    collectibleScore: collectibleScore,
    enemyKillCounts: List<int>.unmodifiable(_enemyKillCounts),
  );

  void giveUp() {
    if (gameOver) return;
    gameOver = true;
    paused = true;
    _events.add(
      RunEndedEvent(
        tick: tick,
        distance: distance,
        reason: RunEndReason.gaveUp,
        stats: _buildRunEndStats(),
      ),
    );
  }

  bool _isPlayerDead() {
    final hi = _world.health.tryIndexOf(_player);
    if (hi == null) return false;
    return _world.health.hp[hi] <= 0.0;
  }

  DeathInfo? _buildDeathInfo() {
    final li = _world.lastDamage.tryIndexOf(_player);
    if (li == null) return null;

    final kind = _world.lastDamage.kind[li];
    if (kind == DeathSourceKind.unknown) return null;

    return DeathInfo(
      kind: kind,
      enemyId: _world.lastDamage.hasEnemyId[li]
          ? _world.lastDamage.enemyId[li]
          : null,
      projectileId: _world.lastDamage.hasProjectileId[li]
          ? _world.lastDamage.projectileId[li]
          : null,
      spellId: _world.lastDamage.hasSpellId[li]
          ? _world.lastDamage.spellId[li]
          : null,
    );
  }

  bool _checkFellBehindCamera() {
    if (!(_world.transform.has(_player) && _world.colliderAabb.has(_player))) {
      return false;
    }

    final ti = _world.transform.indexOf(_player);
    final ai = _world.colliderAabb.indexOf(_player);
    final centerX = _world.transform.posX[ti] + _world.colliderAabb.offsetX[ai];
    final right = centerX + _world.colliderAabb.halfX[ai];
    return right < _camera.left();
  }

  bool _checkFellIntoGap(double groundTopY) {
    if (!(_world.transform.has(_player) && _world.colliderAabb.has(_player))) {
      return false;
    }

    const gapKillOffsetY = 400.0;
    final ti = _world.transform.indexOf(_player);
    final ai = _world.colliderAabb.indexOf(_player);
    final bottomY =
        _world.transform.posY[ti] +
        _world.colliderAabb.offsetY[ai] +
        _world.colliderAabb.halfY[ai];
    return bottomY > groundTopY + gapKillOffsetY;
  }

  void _trackStreamerStep() {
    final streamer = _trackStreamer;
    if (streamer == null) return;

    final result = streamer.step(
      cameraLeft: _camera.left(),
      cameraRight: _camera.right(),
      spawnEnemy: (enemyId, x) {
        final effectiveGroundTopY =
          _staticWorldGeometry.groundPlane?.topY ?? groundTopY.toDouble();
        switch (enemyId) {
          case EnemyId.flyingEnemy:
            _spawnFlyingEnemy(spawnX: x, groundTopY: effectiveGroundTopY);
          case EnemyId.groundEnemy:
            _spawnGroundEnemy(spawnX: x, groundTopY: effectiveGroundTopY);
        }
      },
    );

    if (!result.changed) return;

    // Rebuild collision index only when geometry changes (spawn/cull).
    final combinedSolids = <StaticSolid>[
      ..._baseStaticWorldGeometry.solids,
      ...streamer.dynamicSolids,
    ];
    final combinedSegments = <StaticGroundSegment>[
      ..._baseStaticWorldGeometry.groundSegments,
      ...streamer.dynamicGroundSegments,
    ];
    final combinedGaps = <StaticGroundGap>[
      ..._baseStaticWorldGeometry.groundGaps,
      ...streamer.dynamicGroundGaps,
    ];
    _setStaticWorldGeometry(
      StaticWorldGeometry(
        groundPlane: _baseStaticWorldGeometry.groundPlane,
        groundSegments: List<StaticGroundSegment>.unmodifiable(
          combinedSegments,
        ),
        solids: List<StaticSolid>.unmodifiable(combinedSolids),
        groundGaps: List<StaticGroundGap>.unmodifiable(combinedGaps),
      ),
    );

    if (result.spawnedChunks.isNotEmpty) {
      for (final chunk in result.spawnedChunks) {
        if (_collectibleTuning.enabled) {
          _spawnCollectiblesForChunk(chunk.index, chunk.startX);
        }
        if (_restorationItemTuning.enabled) {
          _spawnRestorationItemForChunk(chunk.index, chunk.startX);
        }
      }
    }
  }

  void _setStaticWorldGeometry(StaticWorldGeometry geometry) {
    _staticWorldGeometry = geometry;
    _staticWorldIndex = StaticWorldGeometryIndex.from(geometry);
    _staticSolidsSnapshot = _buildStaticSolidsSnapshot(geometry);
    _staticGroundGapsSnapshot = _buildGroundGapsSnapshot(geometry);
    _rebuildSurfaceGraph();
  }

  void _rebuildSurfaceGraph() {
    _surfaceGraphVersion += 1;
    final result = _surfaceGraphBuilder.build(
      geometry: _staticWorldGeometry,
      jumpTemplate: _groundEnemyJumpTemplate,
    );
    _surfaceGraph = result.graph;
    _surfaceSpatialIndex = result.spatialIndex;
    _surfaceMinY = 0.0;
    _surfaceMaxY = 0.0;
    if (result.graph.surfaces.isNotEmpty) {
      var minY = result.graph.surfaces.first.yTop;
      var maxY = minY;
      for (var i = 1; i < result.graph.surfaces.length; i += 1) {
        final y = result.graph.surfaces[i].yTop;
        if (y < minY) minY = y;
        if (y > maxY) maxY = y;
      }
      _surfaceMinY = minY;
      _surfaceMaxY = maxY;
    }
    _enemySystem.setSurfaceGraph(
      graph: result.graph,
      spatialIndex: result.spatialIndex,
      graphVersion: _surfaceGraphVersion,
    );
  }

  int _groundEnemyMaxAirTicks() {
    final gravity = _physicsTuning.gravityY;
    if (gravity <= 0) {
      return ticksFromSecondsCeil(1.0, tickHz);
    }
    final jumpSpeed = _groundEnemyTuning.base.groundEnemyJumpSpeed.abs();
    final baseAirSeconds = (2.0 * jumpSpeed) / gravity;
    return ticksFromSecondsCeil(baseAirSeconds * 1.5, tickHz);
  }

  double _snapToGrid(double x, double grid) {
    if (grid <= 0) return x;
    return (x / grid).roundToDouble() * grid;
  }

  double? _highestSurfaceYAtX(double x) {
    final graph = _surfaceGraph;
    final spatialIndex = _surfaceSpatialIndex;
    if (graph == null || spatialIndex == null || graph.surfaces.isEmpty) {
      return null;
    }

    final minY = _surfaceMinY - navSpatialEps;
    final maxY = _surfaceMaxY + navSpatialEps;
    _surfaceQueryCandidates.clear();
    spatialIndex.queryAabb(
      minX: x - navSpatialEps,
      minY: minY,
      maxX: x + navSpatialEps,
      maxY: maxY,
      outSurfaceIndices: _surfaceQueryCandidates,
    );

    double? bestY;
    int? bestId;
    for (final i in _surfaceQueryCandidates) {
      final s = graph.surfaces[i];
      if (x < s.xMin - navGeomEps || x > s.xMax + navGeomEps) continue;
      if (bestY == null || s.yTop < bestY - navTieEps) {
        bestY = s.yTop;
        bestId = s.id;
      } else if ((s.yTop - bestY).abs() <= navTieEps && s.id < bestId!) {
        bestY = s.yTop;
        bestId = s.id;
      }
    }

    return bestY;
  }

  bool _overlapsAnySolid({
    required double centerX,
    required double centerY,
    required double halfSize,
    required double margin,
  }) {
    if (_staticWorldGeometry.solids.isEmpty) return false;

    final minX = centerX - halfSize - margin;
    final maxX = centerX + halfSize + margin;
    final minY = centerY - halfSize - margin;
    final maxY = centerY + halfSize + margin;

    for (final solid in _staticWorldGeometry.solids) {
      final overlaps = aabbOverlapsMinMax(
        aMinX: minX,
        aMaxX: maxX,
        aMinY: minY,
        aMaxY: maxY,
        bMinX: solid.minX,
        bMaxX: solid.maxX,
        bMinY: solid.minY,
        bMaxY: solid.maxY,
      );
      if (overlaps) return true;
    }
    return false;
  }

  bool _overlapsAnyCollectible({
    required double centerX,
    required double centerY,
    required double halfSize,
    required double margin,
  }) {
    final collectibles = _world.collectible;
    if (collectibles.denseEntities.isEmpty) return false;

    final minX = centerX - halfSize - margin;
    final maxX = centerX + halfSize + margin;
    final minY = centerY - halfSize - margin;
    final maxY = centerY + halfSize + margin;

    for (var ci = 0; ci < collectibles.denseEntities.length; ci += 1) {
      final e = collectibles.denseEntities[ci];
      if (!(_world.transform.has(e) && _world.colliderAabb.has(e))) continue;
      final ti = _world.transform.indexOf(e);
      final ai = _world.colliderAabb.indexOf(e);
      final cx = _world.transform.posX[ti] + _world.colliderAabb.offsetX[ai];
      final cy = _world.transform.posY[ti] + _world.colliderAabb.offsetY[ai];
      final overlaps = aabbOverlapsMinMax(
        aMinX: minX,
        aMaxX: maxX,
        aMinY: minY,
        aMaxY: maxY,
        bMinX: cx - _world.colliderAabb.halfX[ai],
        bMaxX: cx + _world.colliderAabb.halfX[ai],
        bMinY: cy - _world.colliderAabb.halfY[ai],
        bMaxY: cy + _world.colliderAabb.halfY[ai],
      );
      if (overlaps) return true;
    }

    return false;
  }

  RestorationStat _lowestResourceStat() {
    final hi = _world.health.tryIndexOf(_player);
    final mi = _world.mana.tryIndexOf(_player);
    final si = _world.stamina.tryIndexOf(_player);
    if (hi == null || mi == null || si == null) {
      return RestorationStat.health;
    }

    var best = RestorationStat.health;
    var bestValue = _world.health.hp[hi];
    var bestMax = _world.health.hpMax[hi];

    final mana = _world.mana.mana[mi];
    final manaMax = _world.mana.manaMax[mi];
    if (_ratioLess(mana, manaMax, bestValue, bestMax)) {
      best = RestorationStat.mana;
      bestValue = mana;
      bestMax = manaMax;
    }

    final stamina = _world.stamina.stamina[si];
    final staminaMax = _world.stamina.staminaMax[si];
    if (_ratioLess(stamina, staminaMax, bestValue, bestMax)) {
      best = RestorationStat.stamina;
    }

    return best;
  }

  bool _ratioLess(
    double valueA,
    double maxA,
    double valueB,
    double maxB,
  ) {
    if (maxA <= 0) return false;
    if (maxB <= 0) return true;
    return valueA * maxB < valueB * maxA;
  }

  static List<StaticSolidSnapshot> _buildStaticSolidsSnapshot(
    StaticWorldGeometry geometry,
  ) {
    return List<StaticSolidSnapshot>.unmodifiable(
      geometry.solids.map(
        (s) => StaticSolidSnapshot(
          minX: s.minX,
          minY: s.minY,
          maxX: s.maxX,
          maxY: s.maxY,
          sides: s.sides,
          oneWayTop: s.oneWayTop,
        ),
      ),
    );
  }

  static List<StaticGroundGapSnapshot> _buildGroundGapsSnapshot(
    StaticWorldGeometry geometry,
  ) {
    if (geometry.groundGaps.isEmpty) {
      return const <StaticGroundGapSnapshot>[];
    }
    return List<StaticGroundGapSnapshot>.unmodifiable(
      geometry.groundGaps.map(
        (g) => StaticGroundGapSnapshot(minX: g.minX, maxX: g.maxX),
      ),
    );
  }

  List<GameEvent> drainEvents() {
    if (_events.isEmpty) return const <GameEvent>[];
    final drained = List<GameEvent>.unmodifiable(_events);
    _events.clear();
    return drained;
  }

  /// Builds an immutable snapshot for render/UI consumption.
  GameStateSnapshot buildSnapshot() {
    final tuning = _movement.base;
    final mi = _world.movement.indexOf(_player);
    final dashing = _world.movement.dashTicksLeft[mi] > 0;
    final onGround =
        _world.collision.grounded[_world.collision.indexOf(_player)];
    final hi = _world.health.indexOf(_player);
    final mai = _world.mana.indexOf(_player);
    final si = _world.stamina.indexOf(_player);
    final ci = _world.cooldown.indexOf(_player);

    final stamina = _world.stamina.stamina[si];
    final mana = _world.mana.mana[mai];
    final projectileManaCost = _spells.get(SpellId.iceBolt).stats.manaCost;

    final canAffordJump = stamina >= _resourceTuning.jumpStaminaCost;
    final canAffordDash = stamina >= _resourceTuning.dashStaminaCost;
    final canAffordMelee = stamina >= _abilities.base.meleeStaminaCost;
    final canAffordProjectile = mana >= projectileManaCost;

    final dashCooldownTicksLeft = _world.movement.dashCooldownTicksLeft[mi];
    final meleeCooldownTicksLeft = _world.cooldown.meleeCooldownTicksLeft[ci];
    final projectileCooldownTicksLeft =
        _world.cooldown.castCooldownTicksLeft[ci];

    final AnimKey anim;
    if (dashing) {
      anim = AnimKey.run;
    } else if (!onGround) {
      anim = playerVelY < 0 ? AnimKey.jump : AnimKey.fall;
    } else if (playerVelX.abs() > tuning.minMoveSpeed) {
      anim = AnimKey.run;
    } else {
      anim = AnimKey.idle;
    }

    final playerPos = Vec2(playerPosX, playerPosY);
    final playerVel = Vec2(playerVelX, playerVelY);

    final entities = <EntityRenderSnapshot>[
      EntityRenderSnapshot(
        id: _player,
        kind: EntityKind.player,
        pos: playerPos,
        vel: playerVel,
        size: Vec2(tuning.playerRadius * 2, tuning.playerRadius * 2),
        facing: playerFacing,
        anim: anim,
        grounded: onGround,
      ),
    ];

    final projectileStore = _world.projectile;
    for (var pi = 0; pi < projectileStore.denseEntities.length; pi += 1) {
      final e = projectileStore.denseEntities[pi];
      if (!(_world.transform.has(e))) continue;
      final ti = _world.transform.indexOf(e);

      final projectileId = projectileStore.projectileId[pi];
      final proj = _projectiles.base.get(projectileId);
      final colliderSize = Vec2(proj.colliderSizeX, proj.colliderSizeY);

      final dirX = projectileStore.dirX[pi];
      final dirY = projectileStore.dirY[pi];
      final facing = dirX >= 0 ? Facing.right : Facing.left;
      final rotationRad = atan2(dirY, dirX);

      entities.add(
        EntityRenderSnapshot(
          id: e,
          kind: EntityKind.projectile,
          pos: Vec2(_world.transform.posX[ti], _world.transform.posY[ti]),
          vel: Vec2(_world.transform.velX[ti], _world.transform.velY[ti]),
          size: colliderSize,
          projectileId: projectileId,
          facing: facing,
          rotationRad: rotationRad,
          anim: AnimKey.idle,
          grounded: false,
        ),
      );
    }

    final hitboxes = _world.hitbox;
    for (var hi = 0; hi < hitboxes.denseEntities.length; hi += 1) {
      final e = hitboxes.denseEntities[hi];
      if (!(_world.transform.has(e))) continue;
      final ti = _world.transform.indexOf(e);

      final size = Vec2(hitboxes.halfX[hi] * 2, hitboxes.halfY[hi] * 2);
      final dirX = hitboxes.dirX[hi];
      final dirY = hitboxes.dirY[hi];
      final facing = dirX >= 0 ? Facing.right : Facing.left;
      final rotationRad = atan2(dirY, dirX);

      entities.add(
        EntityRenderSnapshot(
          id: e,
          kind: EntityKind.trigger,
          pos: Vec2(_world.transform.posX[ti], _world.transform.posY[ti]),
          size: size,
          facing: facing,
          rotationRad: rotationRad,
          anim: AnimKey.hit,
          grounded: false,
        ),
      );
    }

    final collectiblesStore = _world.collectible;
    for (var ci = 0; ci < collectiblesStore.denseEntities.length; ci += 1) {
      final e = collectiblesStore.denseEntities[ci];
      if (!(_world.transform.has(e))) continue;
      final ti = _world.transform.indexOf(e);

      Vec2? size;
      if (_world.colliderAabb.has(e)) {
        final aabbi = _world.colliderAabb.indexOf(e);
        size = Vec2(
          _world.colliderAabb.halfX[aabbi] * 2,
          _world.colliderAabb.halfY[aabbi] * 2,
        );
      }

      entities.add(
        EntityRenderSnapshot(
          id: e,
          kind: EntityKind.pickup,
          pos: Vec2(_world.transform.posX[ti], _world.transform.posY[ti]),
          size: size,
          facing: Facing.right,
          pickupVariant: PickupVariant.collectible,
          rotationRad: pi * 0.25,
          anim: AnimKey.idle,
          grounded: false,
        ),
      );
    }

    final restorationStore = _world.restorationItem;
    for (var ri = 0; ri < restorationStore.denseEntities.length; ri += 1) {
      final e = restorationStore.denseEntities[ri];
      if (!(_world.transform.has(e))) continue;
      final ti = _world.transform.indexOf(e);

      Vec2? size;
      if (_world.colliderAabb.has(e)) {
        final aabbi = _world.colliderAabb.indexOf(e);
        size = Vec2(
          _world.colliderAabb.halfX[aabbi] * 2,
          _world.colliderAabb.halfY[aabbi] * 2,
        );
      }

      final stat = restorationStore.stat[ri];
      int variant;
      switch (stat) {
        case RestorationStat.health:
          variant = PickupVariant.restorationHealth;
        case RestorationStat.mana:
          variant = PickupVariant.restorationMana;
        case RestorationStat.stamina:
          variant = PickupVariant.restorationStamina;
      }

      entities.add(
        EntityRenderSnapshot(
          id: e,
          kind: EntityKind.pickup,
          pos: Vec2(_world.transform.posX[ti], _world.transform.posY[ti]),
          size: size,
          facing: Facing.right,
          pickupVariant: variant,
          rotationRad: pi * 0.25,
          anim: AnimKey.idle,
          grounded: false,
        ),
      );
    }

    final enemies = _world.enemy;
    for (var ei = 0; ei < enemies.denseEntities.length; ei += 1) {
      final e = enemies.denseEntities[ei];
      if (!(_world.transform.has(e))) continue;
      final ti = _world.transform.indexOf(e);

      Vec2? size;
      if (_world.colliderAabb.has(e)) {
        final aabbi = _world.colliderAabb.indexOf(e);
        size = Vec2(
          _world.colliderAabb.halfX[aabbi] * 2,
          _world.colliderAabb.halfY[aabbi] * 2,
        );
      }

      entities.add(
        EntityRenderSnapshot(
          id: e,
          kind: EntityKind.enemy,
          pos: Vec2(_world.transform.posX[ti], _world.transform.posY[ti]),
          vel: Vec2(_world.transform.velX[ti], _world.transform.velY[ti]),
          size: size,
          facing: enemies.facing[ei],
          anim: AnimKey.idle,
          grounded: _world.collision.has(e)
              ? _world.collision.grounded[_world.collision.indexOf(e)]
              : false,
        ),
      );
    }

    return GameStateSnapshot(
      tick: tick,
      seed: seed,
      distance: distance,
      paused: paused,
      gameOver: gameOver,
      cameraCenterX: _camera.state.centerX,
      cameraCenterY: cameraFixedY,
      hud: PlayerHudSnapshot(
        hp: _world.health.hp[hi],
        hpMax: _world.health.hpMax[hi],
        mana: mana,
        manaMax: _world.mana.manaMax[mai],
        stamina: stamina,
        staminaMax: _world.stamina.staminaMax[si],
        canAffordJump: canAffordJump,
        canAffordDash: canAffordDash,
        canAffordMelee: canAffordMelee,
        canAffordProjectile: canAffordProjectile,
        dashCooldownTicksLeft: dashCooldownTicksLeft,
        dashCooldownTicksTotal: _movement.dashCooldownTicks,
        meleeCooldownTicksLeft: meleeCooldownTicksLeft,
        meleeCooldownTicksTotal: _abilities.meleeCooldownTicks,
        projectileCooldownTicksLeft: projectileCooldownTicksLeft,
        projectileCooldownTicksTotal: _abilities.castCooldownTicks,
        collectibles: collectibles,
        collectibleScore: collectibleScore,
      ),
      entities: entities,
      staticSolids: _staticSolidsSnapshot,
      groundGaps: _staticGroundGapsSnapshot,
    );
  }
}


===== FILE: lib/core/navigation/jump_template.dart =====
import 'nav_tolerances.dart';

class JumpProfile {
  const JumpProfile({
    required this.jumpSpeed,
    required this.gravityY,
    required this.maxAirTicks,
    required this.airSpeedX,
    required this.dtSeconds,
    required this.agentHalfWidth,
  }) : assert(maxAirTicks > 0),
       assert(dtSeconds > 0);

  /// Instantaneous jump vertical speed (negative is upward).
  final double jumpSpeed;

  /// Gravity acceleration (positive is downward).
  final double gravityY;

  /// Fixed tick timestep (seconds).
  final double dtSeconds;

  /// Maximum air time horizon to consider (ticks).
  final int maxAirTicks;

  /// Assumed constant horizontal speed while airborne.
  final double airSpeedX;

  /// Collider half-width (used by callers when clamping landing ranges).
  final double agentHalfWidth;
}

class JumpSample {
  const JumpSample({
    required this.tick,
    required this.prevY,
    required this.y,
    required this.velY,
    required this.maxDx,
  });

  final int tick;
  final double prevY;
  final double y;
  final double velY;
  final double maxDx;
}

class JumpLanding {
  const JumpLanding({required this.tick, required this.maxDx});

  final int tick;
  final double maxDx;
}

class JumpReachabilityTemplate {
  JumpReachabilityTemplate._({
    required this.profile,
    required this.samples,
    required this.minDy,
    required this.maxDy,
    required this.maxDx,
  });

  final JumpProfile profile;
  final List<JumpSample> samples;
  final double minDy;
  final double maxDy;
  final double maxDx;

  factory JumpReachabilityTemplate.build(JumpProfile profile) {
    final samples = <JumpSample>[];

    var y = 0.0;
    var velY = -profile.jumpSpeed;
    final dt = profile.dtSeconds;
    var minDy = 0.0;
    var maxDy = 0.0;
    var maxDxOverall = 0.0;

    for (var tick = 1; tick <= profile.maxAirTicks; tick += 1) {
      final prevY = y;
      velY += profile.gravityY * dt;
      y += velY * dt;
      final maxDx = profile.airSpeedX * dt * tick;
      if (y < minDy) minDy = y;
      if (y > maxDy) maxDy = y;
      if (maxDx > maxDxOverall) maxDxOverall = maxDx;
      samples.add(
        JumpSample(
          tick: tick,
          prevY: prevY,
          y: y,
          velY: velY,
          maxDx: maxDx,
        ),
      );
    }

    return JumpReachabilityTemplate._(
      profile: profile,
      samples: List<JumpSample>.unmodifiable(samples),
      minDy: minDy,
      maxDy: maxDy,
      maxDx: maxDxOverall,
    );
  }

  /// Returns the earliest landing tick whose vertical crossing is descending
  /// and whose horizontal reach overlaps [dxMin, dxMax].
  JumpLanding? findFirstLanding({
    required double dy,
    required double dxMin,
    required double dxMax,
    double eps = navGeomEps,
  }) {
    if (dxMin > dxMax) return null;

    for (final sample in samples) {
      if (sample.velY < 0) continue; // Still ascending.
      final crosses =
          (sample.prevY <= dy + eps) && (sample.y >= dy - eps);
      if (!crosses) continue;

      final maxDx = sample.maxDx;
      if (dxMin > maxDx + eps) continue;
      if (dxMax < -maxDx - eps) continue;
      return JumpLanding(tick: sample.tick, maxDx: maxDx);
    }

    return null;
  }
}

int estimateFallTicks({
  required double dy,
  required double gravityY,
  required double dtSeconds,
  required int maxTicks,
}) {
  if (dy <= 0) return 0;
  var y = 0.0;
  var velY = 0.0;
  for (var tick = 1; tick <= maxTicks; tick += 1) {
    velY += gravityY * dtSeconds;
    y += velY * dtSeconds;
    if (y >= dy) return tick;
  }
  return maxTicks;
}


===== FILE: lib/core/navigation/nav_tolerances.dart =====
/// Navigation-wide numeric tolerances.
///
/// Keep this intentionally small: for now we use one epsilon everywhere so
/// tuning stays straightforward. The aliases keep callsites semantically clear
/// and make it easy to split values later if needed.
library;

/// Default epsilon used across navigation.
const double navEps = 1e-6;

/// Epsilon for "these two world-space doubles should be equal" cases.
const double navGeomEps = navEps;

/// Epsilon used for runtime spatial queries / thickness.
const double navSpatialEps = navEps;

/// Epsilon used for deterministic tie-breaking in comparisons (e.g., A* f/g
/// ties).
const double navTieEps = navEps;


===== FILE: lib/core/navigation/surface_extractor.dart =====
import '../collision/static_world_geometry.dart';
import 'nav_tolerances.dart';
import 'surface_id.dart';
import 'walk_surface.dart';

class SurfaceExtractor {
  SurfaceExtractor({
    this.mergeEps = navGeomEps,
    this.groundPadding = 1024.0,
  });

  final double mergeEps;
  final double groundPadding;

  List<WalkSurface> extract(StaticWorldGeometry geometry) {
    final segments = <_SurfaceSegment>[];
    const groundPieceStride = 1000;

    var minX = double.infinity;
    var maxX = double.negativeInfinity;
    for (var i = 0; i < geometry.solids.length; i += 1) {
      final solid = geometry.solids[i];
      if (solid.minX < minX) minX = solid.minX;
      if (solid.maxX > maxX) maxX = solid.maxX;

      if ((solid.sides & StaticSolid.sideTop) == 0) continue;

      var localSolidIndex = solid.localSolidIndex;
      if (localSolidIndex < 0) {
        if (solid.chunkIndex != StaticSolid.noChunk) {
          throw StateError(
            'Chunk solid is missing a localSolidIndex; check track streamer.',
          );
        }
        localSolidIndex = i;
      }

      final id = packSurfaceId(
        chunkIndex: solid.chunkIndex,
        localSolidIndex: localSolidIndex,
      );
      segments.add(
        _SurfaceSegment(
          id: id,
          xMin: solid.minX,
          xMax: solid.maxX,
          yTop: solid.minY,
        ),
      );
    }

    if (geometry.groundSegments.isNotEmpty) {
      for (var gi = 0; gi < geometry.groundSegments.length; gi += 1) {
        final ground = geometry.groundSegments[gi];
        var localSegmentIndex = ground.localSegmentIndex;
        if (localSegmentIndex < 0) {
          if (ground.chunkIndex != StaticSolid.noChunk) {
            throw StateError(
              'Ground segment is missing a localSegmentIndex; check track streamer.',
            );
          }
          localSegmentIndex = gi;
        }
        final blockers = _collectGroundBlockers(
          geometry.solids,
          const <StaticGroundGap>[],
          ground.topY,
          mergeEps,
        );
        final groundSegments = _subtractRanges(
          ground.minX,
          ground.maxX,
          blockers,
          mergeEps,
        );
        for (var i = 0; i < groundSegments.length; i += 1) {
          final seg = groundSegments[i];
          final id = packSurfaceId(
            chunkIndex: ground.chunkIndex,
            localSolidIndex: localSegmentIndex * groundPieceStride + i,
          );
          segments.add(
            _SurfaceSegment(
              id: id,
              xMin: seg.min,
              xMax: seg.max,
              yTop: ground.topY,
            ),
          );
        }
      }
    } else {
      final groundPlane = geometry.groundPlane;
      if (groundPlane != null) {
        final baseMinX = minX.isFinite ? minX : 0.0;
        final baseMaxX = maxX.isFinite ? maxX : 0.0;
        final groundMinX = baseMinX - groundPadding;
        final groundMaxX = baseMaxX + groundPadding;
        final blockers = _collectGroundBlockers(
          geometry.solids,
          geometry.groundGaps,
          groundPlane.topY,
          mergeEps,
        );
        final groundSegments = _subtractRanges(
          groundMinX,
          groundMaxX,
          blockers,
          mergeEps,
        );
        for (var i = 0; i < groundSegments.length; i += 1) {
          final seg = groundSegments[i];
          segments.add(
            _SurfaceSegment(
              id: packSurfaceId(
                chunkIndex: StaticSolid.groundChunk,
                localSolidIndex: i,
              ),
              xMin: seg.min,
              xMax: seg.max,
              yTop: groundPlane.topY,
            ),
          );
        }
      }
    }

    if (segments.isEmpty) {
      return const <WalkSurface>[];
    }

    segments.sort(_compareSegments);

    final merged = <WalkSurface>[];
    var current = segments.first;
    for (var i = 1; i < segments.length; i += 1) {
      final next = segments[i];
      final sameY = (next.yTop - current.yTop).abs() <= mergeEps;
      final touches = next.xMin <= current.xMax + mergeEps;
      if (sameY && touches) {
        if (next.xMax > current.xMax) {
          current = current.copyWith(xMax: next.xMax);
        }
      } else {
        merged.add(
          WalkSurface(
            id: current.id,
            xMin: current.xMin,
            xMax: current.xMax,
            yTop: current.yTop,
          ),
        );
        current = next;
      }
    }

    merged.add(
      WalkSurface(
        id: current.id,
        xMin: current.xMin,
        xMax: current.xMax,
        yTop: current.yTop,
      ),
    );

    return List<WalkSurface>.unmodifiable(merged);
  }
}

class _SurfaceSegment {
  const _SurfaceSegment({
    required this.id,
    required this.xMin,
    required this.xMax,
    required this.yTop,
  });

  final int id;
  final double xMin;
  final double xMax;
  final double yTop;

  _SurfaceSegment copyWith({double? xMax}) {
    return _SurfaceSegment(
      id: id,
      xMin: xMin,
      xMax: xMax ?? this.xMax,
      yTop: yTop,
    );
  }
}

class _Range {
  _Range(this.min, this.max);

  double min;
  double max;
}

List<_Range> _collectGroundBlockers(
  List<StaticSolid> solids,
  List<StaticGroundGap> gaps,
  double groundTopY,
  double eps,
) {
  final blockers = <_Range>[];
  for (final solid in solids) {
    final hasWalls =
        (solid.sides & (StaticSolid.sideLeft | StaticSolid.sideRight)) != 0;
    if (!hasWalls) continue;
    final touchesGround =
        solid.minY <= groundTopY + eps && solid.maxY >= groundTopY - eps;
    if (!touchesGround) continue;
    blockers.add(_Range(solid.minX, solid.maxX));
  }

  for (final gap in gaps) {
    blockers.add(_Range(gap.minX, gap.maxX));
  }

  if (blockers.isEmpty) return blockers;

  blockers.sort((a, b) => a.min.compareTo(b.min));
  final merged = <_Range>[blockers.first];
  for (var i = 1; i < blockers.length; i += 1) {
    final current = blockers[i];
    final last = merged.last;
    if (current.min <= last.max + eps) {
      if (current.max > last.max) {
        last.max = current.max;
      }
    } else {
      merged.add(_Range(current.min, current.max));
    }
  }

  return merged;
}

List<_Range> _subtractRanges(
  double min,
  double max,
  List<_Range> blockers,
  double eps,
) {
  if (blockers.isEmpty) {
    return <_Range>[_Range(min, max)];
  }

  final segments = <_Range>[];
  var cursor = min;
  for (final blocker in blockers) {
    if (blocker.max <= min + eps) continue;
    if (blocker.min >= max - eps) break;
    final blockMin = blocker.min < min ? min : blocker.min;
    final blockMax = blocker.max > max ? max : blocker.max;
    if (blockMin > cursor + eps) {
      segments.add(_Range(cursor, blockMin));
    }
    if (blockMax > cursor) {
      cursor = blockMax;
    }
  }
  if (cursor < max - eps) {
    segments.add(_Range(cursor, max));
  }
  return segments;
}

int _compareSegments(_SurfaceSegment a, _SurfaceSegment b) {
  if (a.yTop < b.yTop) return -1;
  if (a.yTop > b.yTop) return 1;
  if (a.xMin < b.xMin) return -1;
  if (a.xMin > b.xMin) return 1;
  if (a.xMax < b.xMax) return -1;
  if (a.xMax > b.xMax) return 1;
  if (a.id < b.id) return -1;
  if (a.id > b.id) return 1;
  return 0;
}


===== FILE: lib/core/navigation/surface_graph.dart =====
import 'walk_surface.dart';

enum SurfaceEdgeKind { jump, drop }

class SurfaceEdge {
  const SurfaceEdge({
    required this.to,
    required this.kind,
    required this.takeoffX,
    required this.landingX,
    required this.travelTicks,
    required this.cost,
  });

  final int to;
  final SurfaceEdgeKind kind;
  final double takeoffX;
  final double landingX;
  final int travelTicks;
  final double cost;
}

class SurfaceGraph {
  SurfaceGraph({
    required List<WalkSurface> surfaces,
    required List<int> edgeOffsets,
    required List<SurfaceEdge> edges,
    required Map<int, int> indexById,
  })  : surfaces = List<WalkSurface>.unmodifiable(surfaces),
        edgeOffsets = List<int>.unmodifiable(edgeOffsets),
        edges = List<SurfaceEdge>.unmodifiable(edges),
        _indexById = Map<int, int>.unmodifiable(indexById);

  final List<WalkSurface> surfaces;
  final List<int> edgeOffsets;
  final List<SurfaceEdge> edges;
  final Map<int, int> _indexById;

  int? indexOfSurfaceId(int id) => _indexById[id];

  Iterable<SurfaceEdge> edgesFor(int surfaceIndex) sync* {
    final start = edgeOffsets[surfaceIndex];
    final end = edgeOffsets[surfaceIndex + 1];
    for (var i = start; i < end; i += 1) {
      yield edges[i];
    }
  }
}



===== FILE: lib/core/navigation/surface_graph_builder.dart =====
import '../collision/static_world_geometry.dart';
import '../ecs/spatial/grid_index_2d.dart';
import 'jump_template.dart';
import 'nav_tolerances.dart';
import 'surface_extractor.dart';
import 'surface_graph.dart';
import 'surface_spatial_index.dart';
import 'walk_surface.dart';

class SurfaceGraphBuildResult {
  const SurfaceGraphBuildResult({
    required this.graph,
    required this.spatialIndex,
  });

  final SurfaceGraph graph;
  final SurfaceSpatialIndex spatialIndex;
}

class SurfaceGraphBuilder {
  SurfaceGraphBuilder({
    required GridIndex2D surfaceGrid,
    SurfaceExtractor? extractor,
    this.standableEps = navGeomEps,
    this.dropSampleOffset = navSpatialEps,
    this.takeoffSampleMaxStep = 64.0,
  })  : _surfaceGrid = surfaceGrid,
        _extractor = extractor ?? SurfaceExtractor();

  final GridIndex2D _surfaceGrid;
  final SurfaceExtractor _extractor;
  final double standableEps;
  final double dropSampleOffset;
  final double takeoffSampleMaxStep;

  SurfaceGraphBuildResult build({
    required StaticWorldGeometry geometry,
    required JumpReachabilityTemplate jumpTemplate,
  }) {
    final surfaces = _extractor.extract(geometry);
    final spatialIndex = SurfaceSpatialIndex(index: _surfaceGrid);
    spatialIndex.rebuild(surfaces);

    final indexById = <int, int>{};
    for (var i = 0; i < surfaces.length; i += 1) {
      indexById[surfaces[i].id] = i;
    }

    final edges = <SurfaceEdge>[];
    final edgeOffsets = List<int>.filled(surfaces.length + 1, 0);
    final tempCandidates = <int>[];

    for (var i = 0; i < surfaces.length; i += 1) {
      edgeOffsets[i] = edges.length;
      final from = surfaces[i];
      final standable = _standableRange(
        from,
        jumpTemplate.profile.agentHalfWidth,
        standableEps,
      );
      if (standable == null) {
        edgeOffsets[i + 1] = edges.length;
        continue;
      }

      final takeoffXs = _takeoffSamples(
        standable.min,
        standable.max,
        jumpTemplate.maxDx,
        takeoffSampleMaxStep,
      );

      final dropSamples = _dropSamples(standable.min, standable.max);
      final dropMid = (standable.min + standable.max) * 0.5;
      for (final dropX in dropSamples) {
        final landingIndex = _findFirstSurfaceBelow(
          surfaces,
          dropX,
          from.yTop,
          jumpTemplate.profile.agentHalfWidth,
        );
        if (landingIndex == null) continue;
        final landingSurface = surfaces[landingIndex];
        final dy = landingSurface.yTop - from.yTop;
        final fallTicks = estimateFallTicks(
          dy: dy,
          gravityY: jumpTemplate.profile.gravityY,
          dtSeconds: jumpTemplate.profile.dtSeconds,
          maxTicks: jumpTemplate.profile.maxAirTicks,
        );
        final offset = dropX <= dropMid ? -dropSampleOffset : dropSampleOffset;
        final takeoffX = dropX + offset;
        final edge = SurfaceEdge(
          to: landingIndex,
          kind: SurfaceEdgeKind.drop,
          takeoffX: takeoffX,
          landingX: _clamp(
            dropX,
            landingSurface.xMin + jumpTemplate.profile.agentHalfWidth,
            landingSurface.xMax - jumpTemplate.profile.agentHalfWidth,
          ),
          travelTicks: fallTicks,
          cost: fallTicks * jumpTemplate.profile.dtSeconds,
        );
        edges.add(edge);
      }

      for (final takeoffX in takeoffXs) {
        final minX = takeoffX - jumpTemplate.maxDx;
        final maxX = takeoffX + jumpTemplate.maxDx;
        final minY = from.yTop + jumpTemplate.minDy;
        final maxY = from.yTop + jumpTemplate.maxDy;

        spatialIndex.queryAabb(
          minX: minX,
          minY: minY,
          maxX: maxX,
          maxY: maxY,
          outSurfaceIndices: tempCandidates,
        );

        tempCandidates.sort(
          (a, b) => surfaces[a].id.compareTo(surfaces[b].id),
        );

        for (final targetIndex in tempCandidates) {
          if (targetIndex == i) continue;
          final target = surfaces[targetIndex];
          final landing = _standableRange(
            target,
            jumpTemplate.profile.agentHalfWidth,
            standableEps,
          );
          if (landing == null) continue;

          final dy = target.yTop - from.yTop;
          final dxMin = landing.min - takeoffX;
          final dxMax = landing.max - takeoffX;
          final landingTick = jumpTemplate.findFirstLanding(
            dy: dy,
            dxMin: dxMin,
            dxMax: dxMax,
          );
          if (landingTick == null) continue;

          final reachMin = takeoffX - landingTick.maxDx;
          final reachMax = takeoffX + landingTick.maxDx;
          final low = reachMin > landing.min ? reachMin : landing.min;
          final high = reachMax < landing.max ? reachMax : landing.max;
          if (low > high + standableEps) continue;

          final edge = SurfaceEdge(
            to: targetIndex,
            kind: SurfaceEdgeKind.jump,
            takeoffX: takeoffX,
            landingX: (low + high) * 0.5,
            travelTicks: landingTick.tick,
            cost: landingTick.tick * jumpTemplate.profile.dtSeconds,
          );
          edges.add(edge);
        }
      }

      edgeOffsets[i + 1] = edges.length;
    }

    return SurfaceGraphBuildResult(
      graph: SurfaceGraph(
        surfaces: surfaces,
        edgeOffsets: edgeOffsets,
        edges: edges,
        indexById: indexById,
      ),
      spatialIndex: spatialIndex,
    );
  }
}

class _Range {
  const _Range(this.min, this.max);

  final double min;
  final double max;
}

_Range? _standableRange(WalkSurface surface, double halfWidth, double eps) {
  final min = surface.xMin + halfWidth;
  final max = surface.xMax - halfWidth;
  if (min > max + eps) return null;
  return _Range(min, max);
}

List<double> _takeoffSamples(
  double min,
  double max,
  double maxDx,
  double maxStep,
) {
  if (max <= min) {
    return <double>[min];
  }

  var step = maxDx;
  if (maxStep > 0 && step > maxStep) {
    step = maxStep;
  }

  if (step <= navGeomEps || (max - min) <= step) {
    final mid = (min + max) * 0.5;
    return _dedupeSamples(<double>[min, mid, max]);
  }

  final samples = <double>[];
  for (var x = min; x <= max; x += step) {
    samples.add(x);
  }
  if ((max - samples.last).abs() > navGeomEps) {
    samples.add(max);
  }
  return _dedupeSamples(samples);
}

List<double> _dropSamples(double min, double max) {
  final samples = <double>[min, max];
  return _dedupeSamples(samples);
}

List<double> _dedupeSamples(
  List<double> samples, {
  double eps = navGeomEps,
}) {
  samples.sort();
  final deduped = <double>[];
  for (final s in samples) {
    if (deduped.isEmpty || (s - deduped.last).abs() > eps) {
      deduped.add(s);
    }
  }
  return deduped;
}

int? _findFirstSurfaceBelow(
  List<WalkSurface> surfaces,
  double x,
  double fromY,
  double halfWidth,
) {
  int? bestIndex;
  double? bestY;

  for (var i = 0; i < surfaces.length; i += 1) {
    final s = surfaces[i];
    if (s.yTop <= fromY) continue;
    final minX = s.xMin + halfWidth;
    final maxX = s.xMax - halfWidth;
    if (minX > maxX) continue;
    if (x < minX || x > maxX) continue;
    if (bestY == null || s.yTop < bestY) {
      bestY = s.yTop;
      bestIndex = i;
    } else if ((s.yTop - bestY).abs() < navTieEps) {
      if (s.id < surfaces[bestIndex!].id) {
        bestIndex = i;
      }
    }
  }

  return bestIndex;
}

double _clamp(double v, double min, double max) {
  if (v < min) return min;
  if (v > max) return max;
  return v;
}


===== FILE: lib/core/navigation/surface_id.dart =====
const int surfaceKindTop = 0;
const int surfaceIdUnknown = -1;

/// Packs a surface identity into a stable, comparable 64-bit key.
///
/// Ordering is lexicographic by (chunkIndex, localSolidIndex, surfaceKind).
int packSurfaceId({
  required int chunkIndex,
  required int localSolidIndex,
  int surfaceKind = surfaceKindTop,
}) {
  if (localSolidIndex < 0) {
    throw ArgumentError.value(
      localSolidIndex,
      'localSolidIndex',
      'must be >= 0',
    );
  }
  final chunk = (chunkIndex ^ 0x80000000) & 0xFFFFFFFF;
  final local = ((localSolidIndex << 2) | (surfaceKind & 0x3)) & 0xFFFFFFFF;
  return (chunk << 32) | local;
}

int unpackChunkIndex(int surfaceId) {
  final chunk = (surfaceId >> 32) & 0xFFFFFFFF;
  return (chunk ^ 0x80000000);
}

int unpackLocalSolidIndex(int surfaceId) {
  final local = surfaceId & 0xFFFFFFFF;
  return local >> 2;
}

int unpackSurfaceKind(int surfaceId) {
  return surfaceId & 0x3;
}


===== FILE: lib/core/navigation/surface_navigator.dart =====
import '../ecs/stores/enemies/surface_nav_state_store.dart';
import 'nav_tolerances.dart';
import 'surface_graph.dart';
import 'surface_id.dart';
import 'surface_pathfinder.dart';
import 'surface_spatial_index.dart';

class SurfaceNavIntent {
  const SurfaceNavIntent({
    required this.desiredX,
    required this.jumpNow,
    required this.hasPlan,
    this.commitMoveDirX = 0,
  });

  final double desiredX;
  final bool jumpNow;
  final bool hasPlan;

  /// Movement commit direction while approaching/executing an edge.
  ///
  /// When non-zero (-1 or +1), the locomotion controller should keep moving in
  /// this direction even if it would normally stop near `desiredX`, and it
  /// should not reverse direction due to tiny `desiredX` overshoots.
  ///
  /// This is primarily used to ensure drop edges actually leave the takeoff
  /// surface (walk past the ledge) instead of stopping "close enough".
  final int commitMoveDirX;
}

class SurfaceNavigator {
  SurfaceNavigator({
    required this.pathfinder,
    this.repathCooldownTicks = 30,
    this.surfaceEps = navSpatialEps,
    this.takeoffEps = 2.0,
  });

  final SurfacePathfinder pathfinder;
  final int repathCooldownTicks;
  final double surfaceEps;
  final double takeoffEps;
  final List<int> _candidateBuffer = <int>[];

  SurfaceNavIntent update({
    required SurfaceNavStateStore navStore,
    required int navIndex,
    required SurfaceGraph graph,
    required SurfaceSpatialIndex spatialIndex,
    required int graphVersion,
    required double entityX,
    required double entityBottomY,
    required double entityHalfWidth,
    required bool entityGrounded,
    required double targetX,
    required double targetBottomY,
    required double targetHalfWidth,
    required bool targetGrounded,
  }) {
    final prevCurrentId = navStore.currentSurfaceId[navIndex];
    final prevTargetId = navStore.targetSurfaceId[navIndex];

    var currentSurfaceId = prevCurrentId;
    if (entityGrounded) {
      final currentIndex = _locateSurfaceIndex(
        graph,
        spatialIndex,
        _candidateBuffer,
        entityX,
        entityBottomY,
        entityHalfWidth,
        surfaceEps,
      );
      currentSurfaceId = currentIndex == null
          ? surfaceIdUnknown
          : graph.surfaces[currentIndex].id;
    }

    var targetSurfaceId = prevTargetId;
    if (targetGrounded) {
      final targetIndex = _locateSurfaceIndex(
        graph,
        spatialIndex,
        _candidateBuffer,
        targetX,
        targetBottomY,
        targetHalfWidth,
        surfaceEps,
      );
      targetSurfaceId = targetIndex == null
          ? surfaceIdUnknown
          : graph.surfaces[targetIndex].id;
    }

    if (navStore.graphVersion[navIndex] != graphVersion) {
      navStore.graphVersion[navIndex] = graphVersion;
      navStore.pathEdges[navIndex].clear();
      navStore.pathCursor[navIndex] = 0;
      navStore.activeEdgeIndex[navIndex] = -1;
      navStore.repathTicksLeft[navIndex] = 0;
    }

    navStore.currentSurfaceId[navIndex] = currentSurfaceId;
    navStore.targetSurfaceId[navIndex] = targetSurfaceId;

    if (navStore.repathTicksLeft[navIndex] > 0) {
      navStore.repathTicksLeft[navIndex] -= 1;
    }

    final plan = navStore.pathEdges[navIndex];
    final surfaceChanged =
        currentSurfaceId != prevCurrentId || targetSurfaceId != prevTargetId;

    if (surfaceChanged) {
      navStore.repathTicksLeft[navIndex] = 0;
    }

    if (entityGrounded &&
        navStore.repathTicksLeft[navIndex] == 0 &&
        currentSurfaceId != surfaceIdUnknown &&
        targetSurfaceId != surfaceIdUnknown) {
      final startIndex = graph.indexOfSurfaceId(currentSurfaceId);
      final goalIndex = graph.indexOfSurfaceId(targetSurfaceId);
      if (startIndex != null && goalIndex != null) {
        final found = pathfinder.findPath(
          graph,
          startIndex: startIndex,
          goalIndex: goalIndex,
          outEdges: plan,
          startX: entityX,
          goalX: targetX,
        );
        navStore.pathCursor[navIndex] = 0;
        navStore.activeEdgeIndex[navIndex] = -1;
        if (!found) {
          plan.clear();
        }
      }
      navStore.repathTicksLeft[navIndex] = repathCooldownTicks;
    }

    if (currentSurfaceId != surfaceIdUnknown &&
        currentSurfaceId == targetSurfaceId) {
      plan.clear();
      navStore.pathCursor[navIndex] = 0;
      navStore.activeEdgeIndex[navIndex] = -1;
      return SurfaceNavIntent(
        desiredX: targetX,
        jumpNow: false,
        hasPlan: false,
      );
    }

    final cursor = navStore.pathCursor[navIndex];
    if (plan.isEmpty || cursor >= plan.length) {
      navStore.activeEdgeIndex[navIndex] = -1;
      return SurfaceNavIntent(
        desiredX: targetX,
        jumpNow: false,
        hasPlan: false,
      );
    }

    final edgeIndex = plan[cursor];
    final edge = graph.edges[edgeIndex];

    if (navStore.activeEdgeIndex[navIndex] >= 0) {
      if (entityGrounded &&
          currentSurfaceId != surfaceIdUnknown &&
          currentSurfaceId == graph.surfaces[edge.to].id) {
        navStore.activeEdgeIndex[navIndex] = -1;
        navStore.pathCursor[navIndex] = cursor + 1;
        return SurfaceNavIntent(
          desiredX: targetX,
          jumpNow: false,
          hasPlan: true,
        );
      }

      if (edge.kind == SurfaceEdgeKind.drop && entityGrounded) {
        return SurfaceNavIntent(
          desiredX: edge.takeoffX,
          jumpNow: false,
          hasPlan: true,
          commitMoveDirX: _dropCommitDirX(edge),
        );
      }
      return SurfaceNavIntent(
        desiredX: edge.landingX,
        jumpNow: false,
        hasPlan: true,
      );
    }

    final closeEnough = (entityX - edge.takeoffX).abs() <= takeoffEps;
    if (entityGrounded && closeEnough) {
      navStore.activeEdgeIndex[navIndex] = edgeIndex;

      final jumpNow = edge.kind == SurfaceEdgeKind.jump;
      return SurfaceNavIntent(
        desiredX:
            edge.kind == SurfaceEdgeKind.drop ? edge.takeoffX : edge.landingX,
        jumpNow: jumpNow,
        hasPlan: true,
        commitMoveDirX:
            edge.kind == SurfaceEdgeKind.drop ? _dropCommitDirX(edge) : 0,
      );
    }

    return SurfaceNavIntent(
      desiredX: edge.takeoffX,
      jumpNow: false,
      hasPlan: true,
    );
  }
}

int _dropCommitDirX(SurfaceEdge edge) {
  // Drop edges use a takeoff point nudged beyond the ledge. Commit in that
  // direction so locomotion cannot "stop short" and never leave the surface.
  if (edge.takeoffX < edge.landingX) return 1;
  if (edge.takeoffX > edge.landingX) return -1;
  // Fallback: in the unlikely case of an exact tie, just don't commit.
  return 0;
}

int? _locateSurfaceIndex(
  SurfaceGraph graph,
  SurfaceSpatialIndex spatialIndex,
  List<int> candidates,
  double x,
  double bottomY,
  double halfWidth,
  double eps,
) {
  final minX = x - halfWidth;
  final maxX = x + halfWidth;
  final minY = bottomY - eps;
  final maxY = bottomY + eps;

  spatialIndex.queryAabb(
    minX: minX,
    minY: minY,
    maxX: maxX,
    maxY: maxY,
    outSurfaceIndices: candidates,
  );

  int? bestIndex;
  double? bestY;
  for (final i in candidates) {
    final s = graph.surfaces[i];
    if (s.xMin > maxX || s.xMax < minX) continue;
    if ((s.yTop - bottomY).abs() > eps) continue;

    if (bestY == null || s.yTop < bestY) {
      bestY = s.yTop;
      bestIndex = i;
    } else if ((s.yTop - bestY).abs() <= eps) {
      if (s.id < graph.surfaces[bestIndex!].id) {
        bestIndex = i;
      }
    }
  }

  return bestIndex;
}


===== FILE: lib/core/navigation/surface_pathfinder.dart =====
import 'surface_graph.dart';
import 'nav_tolerances.dart';

class SurfacePathfinder {
  SurfacePathfinder({
    required this.maxExpandedNodes,
    required this.runSpeedX,
    this.edgePenaltySeconds = 0.0,
  }) : assert(maxExpandedNodes > 0),
       assert(runSpeedX > 0),
       assert(edgePenaltySeconds >= 0.0);

  final int maxExpandedNodes;
  final double runSpeedX;
  final double edgePenaltySeconds;

  final List<double> _gScore = <double>[];
  final List<double> _fScore = <double>[];
  final List<int> _cameFromEdge = <int>[];
  final List<int> _cameFromNode = <int>[];
  final List<int> _open = <int>[];
  final List<int> _openStamp = <int>[];
  final List<int> _reconstruct = <int>[];
  final List<int> _nodeGenerations = <int>[];
  int _searchGeneration = 0;

  bool findPath(
    SurfaceGraph graph, {
    required int startIndex,
    required int goalIndex,
    required List<int> outEdges,
    double? startX,
    double? goalX,
  }) {
    outEdges.clear();
    if (startIndex == goalIndex) return true;

    _ensureSize(graph.surfaces.length);
    _searchGeneration += 1;

    _touch(startIndex);
    _open.clear();
    _open.add(startIndex);
    _openStamp[startIndex] = 1;
    _gScore[startIndex] = 0.0;
    _fScore[startIndex] = _heuristic(graph, startIndex, goalIndex);

    var expanded = 0;
    while (_open.isNotEmpty && expanded < maxExpandedNodes) {
      final current = _popBest(graph);
      if (current == goalIndex) {
        _reconstructPath(goalIndex, outEdges);
        return true;
      }

      expanded += 1;

      final start = graph.edgeOffsets[current];
      final end = graph.edgeOffsets[current + 1];
      for (var ei = start; ei < end; ei += 1) {
        final edge = graph.edges[ei];
        final neighbor = edge.to;
        _touch(neighbor);
        final edgeCost = edge.cost +
            _runCost(
              graph,
              current,
              edge,
              startIndex: startIndex,
              startX: startX,
            ) +
            _goalLandingCost(
              edge,
              neighbor: neighbor,
              goalIndex: goalIndex,
              goalX: goalX,
            ) +
            edgePenaltySeconds;
        final tentative = _gScore[current] + edgeCost;
        if (tentative >= _gScore[neighbor]) continue;

        _cameFromEdge[neighbor] = ei;
        _cameFromNode[neighbor] = current;
        _gScore[neighbor] = tentative;
        _fScore[neighbor] =
            tentative + _heuristic(graph, neighbor, goalIndex);

        if (_openStamp[neighbor] != 1) {
          _open.add(neighbor);
          _openStamp[neighbor] = 1;
        }
      }
    }

    return false;
  }

  double _heuristic(SurfaceGraph graph, int from, int goal) {
    final dx = (graph.surfaces[goal].centerX - graph.surfaces[from].centerX).abs();
    return dx / runSpeedX;
  }

  double _runCost(
    SurfaceGraph graph,
    int fromIndex,
    SurfaceEdge edge, {
    required int startIndex,
    required double? startX,
  }) {
    final fromSurface = graph.surfaces[fromIndex];
    final originX =
        (fromIndex == startIndex && startX != null) ? startX : fromSurface.centerX;
    final dx = (edge.takeoffX - originX).abs();
    return dx / runSpeedX;
  }

  double _goalLandingCost(
    SurfaceEdge edge, {
    required int neighbor,
    required int goalIndex,
    required double? goalX,
  }) {
    if (goalX == null) return 0.0;
    if (neighbor != goalIndex) return 0.0;
    final dx = (edge.landingX - goalX).abs();
    return dx / runSpeedX;
  }

  int _popBest(SurfaceGraph graph) {
    var bestIndex = 0;
    var bestNode = _open[0];
    for (var i = 1; i < _open.length; i += 1) {
      final node = _open[i];
      if (_isBetter(graph, node, bestNode)) {
        bestIndex = i;
        bestNode = node;
      }
    }

    final last = _open.removeLast();
    if (bestIndex < _open.length) {
      _open[bestIndex] = last;
    }
    _openStamp[bestNode] = 0;
    return bestNode;
  }

  bool _isBetter(SurfaceGraph graph, int a, int b) {
    final fa = _fScore[a];
    final fb = _fScore[b];
    if (fa < fb - navTieEps) return true;
    if (fa > fb + navTieEps) return false;
    final ga = _gScore[a];
    final gb = _gScore[b];
    if (ga < gb - navTieEps) return true;
    if (ga > gb + navTieEps) return false;
    return graph.surfaces[a].id < graph.surfaces[b].id;
  }

  void _reconstructPath(int goalIndex, List<int> outEdges) {
    _reconstruct.clear();
    var current = goalIndex;
    while (_cameFromEdge[current] != -1) {
      _reconstruct.add(_cameFromEdge[current]);
      current = _cameFromNode[current];
    }
    for (var i = _reconstruct.length - 1; i >= 0; i -= 1) {
      outEdges.add(_reconstruct[i]);
    }
  }

  void _ensureSize(int count) {
    while (_gScore.length < count) {
      _gScore.add(double.infinity);
      _fScore.add(double.infinity);
      _cameFromEdge.add(-1);
      _cameFromNode.add(-1);
      _openStamp.add(0);
      _nodeGenerations.add(0);
    }
  }

  void _touch(int index) {
    if (_nodeGenerations[index] != _searchGeneration) {
      _gScore[index] = double.infinity;
      _fScore[index] = double.infinity;
      _cameFromEdge[index] = -1;
      _cameFromNode[index] = -1;
      _openStamp[index] = 0;
      _nodeGenerations[index] = _searchGeneration;
    }
  }
}


===== FILE: lib/core/navigation/surface_spatial_index.dart =====
import '../ecs/spatial/grid_index_2d.dart';
import 'nav_tolerances.dart';
import 'walk_surface.dart';

/// Spatial index for walkable surface segments.
///
/// Built only when static geometry changes (graph rebuild).
class SurfaceSpatialIndex {
  SurfaceSpatialIndex({
    required GridIndex2D index,
    this.surfaceThickness = navSpatialEps,
  }) : _index = index;

  final GridIndex2D _index;
  final double surfaceThickness;

  final Map<int, List<int>> _buckets = <int, List<int>>{};
  final List<int> _activeKeys = <int>[];
  final List<List<int>> _bucketPool = <List<int>>[];

  final List<int> _seenStampBySurface = <int>[];
  int _stamp = 0;
  int _surfaceCount = 0;

  void rebuild(List<WalkSurface> surfaces) {
    for (var i = 0; i < _activeKeys.length; i += 1) {
      final key = _activeKeys[i];
      final bucket = _buckets.remove(key);
      if (bucket == null) continue;
      bucket.clear();
      _bucketPool.add(bucket);
    }
    _activeKeys.clear();

    _surfaceCount = surfaces.length;
    if (surfaces.isEmpty) return;

    for (var si = 0; si < surfaces.length; si += 1) {
      final surface = surfaces[si];
      final minX = surface.xMin;
      final maxX = surface.xMax;
      final minY = surface.yTop - surfaceThickness;
      final maxY = surface.yTop + surfaceThickness;

      final minCx = _index.worldToCellX(minX);
      final maxCx = _index.worldToCellX(maxX);
      final minCy = _index.worldToCellY(minY);
      final maxCy = _index.worldToCellY(maxY);

      for (var cellY = minCy; cellY <= maxCy; cellY += 1) {
        for (var cellX = minCx; cellX <= maxCx; cellX += 1) {
          final key = _index.cellKey(cellX, cellY);
          var bucket = _buckets[key];
          if (bucket == null) {
            bucket = _bucketPool.isNotEmpty ? _bucketPool.removeLast() : <int>[];
            _buckets[key] = bucket;
            _activeKeys.add(key);
          }
          bucket.add(si);
        }
      }
    }
  }

  /// Fills [outSurfaceIndices] with unique surface indices overlapping the AABB.
  void queryAabb({
    required double minX,
    required double minY,
    required double maxX,
    required double maxY,
    required List<int> outSurfaceIndices,
  }) {
    outSurfaceIndices.clear();
    if (_activeKeys.isEmpty) return;

    _stamp += 1;
    if (_stamp == 0x7FFFFFFF) {
      for (var i = 0; i < _seenStampBySurface.length; i += 1) {
        _seenStampBySurface[i] = 0;
      }
      _stamp = 1;
    }

    final minCx = _index.worldToCellX(minX);
    final maxCx = _index.worldToCellX(maxX);
    final minCy = _index.worldToCellY(minY);
    final maxCy = _index.worldToCellY(maxY);

    if (_seenStampBySurface.length < _surfaceCount) {
      final missing = _surfaceCount - _seenStampBySurface.length;
      for (var i = 0; i < missing; i += 1) {
        _seenStampBySurface.add(0);
      }
    }

    for (var cellY = minCy; cellY <= maxCy; cellY += 1) {
      for (var cellX = minCx; cellX <= maxCx; cellX += 1) {
        final key = _index.cellKey(cellX, cellY);
        final bucket = _buckets[key];
        if (bucket == null || bucket.isEmpty) continue;

        for (var bi = 0; bi < bucket.length; bi += 1) {
          final surfaceIndex = bucket[bi];
          if (_seenStampBySurface[surfaceIndex] == _stamp) continue;
          _seenStampBySurface[surfaceIndex] = _stamp;
          outSurfaceIndices.add(surfaceIndex);
        }
      }
    }
  }
}


===== FILE: lib/core/navigation/walk_surface.dart =====
class WalkSurface {
  const WalkSurface({
    required this.id,
    required this.xMin,
    required this.xMax,
    required this.yTop,
  }) : assert(xMax >= xMin);

  /// Packed surface id (see `surface_id.dart`).
  final int id;

  /// Inclusive horizontal bounds for the walkable top segment.
  final double xMin;
  final double xMax;

  /// World-space Y coordinate of the top surface.
  final double yTop;

  double get centerX => (xMin + xMax) * 0.5;
}



===== FILE: lib/core/players/player_archetype.dart =====
import '../ecs/stores/body_store.dart';
import '../ecs/stores/collider_aabb_store.dart';
import '../ecs/stores/health_store.dart';
import '../ecs/stores/mana_store.dart';
import '../ecs/stores/stamina_store.dart';
import '../snapshots/enums.dart';

class PlayerArchetype {
  const PlayerArchetype({
    required this.collider,
    required this.body,
    required this.health,
    required this.mana,
    required this.stamina,
    this.facing = Facing.right,
  });

  final ColliderAabbDef collider;

  /// Template for how the player participates in physics (body flags/constraints).
  final BodyDef body;

  final HealthDef health;
  final ManaDef mana;
  final StaminaDef stamina;

  /// Default facing direction at spawn time.
  final Facing facing;
}


===== FILE: lib/core/players/player_catalog.dart =====
import '../ecs/stores/body_store.dart';
import '../ecs/stores/collider_aabb_store.dart';
import '../ecs/stores/health_store.dart';
import '../ecs/stores/mana_store.dart';
import '../ecs/stores/stamina_store.dart';
import '../snapshots/enums.dart';
import '../tuning/movement_tuning.dart';
import '../tuning/resource_tuning.dart';
import 'player_archetype.dart';

class PlayerCatalog {
  const PlayerCatalog({
    this.bodyTemplate = const BodyDef(
      isKinematic: false,
      useGravity: true,
      ignoreCeilings: false,
      topOnlyGround: true,
      gravityScale: 1.0,
      sideMask: BodyDef.sideLeft | BodyDef.sideRight,
    ),
    this.facing = Facing.right,
  });

  /// Template for how the player participates in physics.
  ///
  /// `maxVelX/maxVelY` are filled from `MovementTuning` during derivation so
  /// movement tuning remains the single source of truth for clamps.
  final BodyDef bodyTemplate;

  /// Default facing direction at spawn time.
  final Facing facing;
}

class PlayerCatalogDerived {
  const PlayerCatalogDerived._({required this.archetype});

  factory PlayerCatalogDerived.from(
    PlayerCatalog base, {
    required MovementTuningDerived movement,
    required ResourceTuning resources,
  }) {
    final body = BodyDef(
      enabled: base.bodyTemplate.enabled,
      isKinematic: base.bodyTemplate.isKinematic,
      useGravity: base.bodyTemplate.useGravity,
      ignoreCeilings: base.bodyTemplate.ignoreCeilings,
      topOnlyGround: base.bodyTemplate.topOnlyGround,
      gravityScale: base.bodyTemplate.gravityScale,
      maxVelX: movement.base.maxVelX,
      maxVelY: movement.base.maxVelY,
      sideMask: base.bodyTemplate.sideMask,
    );

    final collider = ColliderAabbDef(
      halfX: movement.base.playerRadius,
      halfY: movement.base.playerRadius,
    );

    final health = HealthDef(
      hp: resources.playerHpMax,
      hpMax: resources.playerHpMax,
      regenPerSecond: resources.playerHpRegenPerSecond,
    );
    final mana = ManaDef(
      mana: resources.playerManaMax,
      manaMax: resources.playerManaMax,
      regenPerSecond: resources.playerManaRegenPerSecond,
    );
    final stamina = StaminaDef(
      stamina: resources.playerStaminaMax,
      staminaMax: resources.playerStaminaMax,
      regenPerSecond: resources.playerStaminaRegenPerSecond,
    );

    return PlayerCatalogDerived._(
      archetype: PlayerArchetype(
        collider: collider,
        body: body,
        health: health,
        mana: mana,
        stamina: stamina,
        facing: base.facing,
      ),
    );
  }

  final PlayerArchetype archetype;
}


===== FILE: lib/core/projectiles/projectile_catalog.dart =====
import '../util/tick_math.dart';

import 'projectile_id.dart';

class ProjectileArchetype {
  const ProjectileArchetype({
    required this.speedUnitsPerSecond,
    required this.lifetimeSeconds,
    required this.colliderSizeX,
    required this.colliderSizeY,
  });

  final double speedUnitsPerSecond;
  final double lifetimeSeconds;

  /// Full extents, in world units (virtual pixels).
  final double colliderSizeX;
  final double colliderSizeY;
}

class ProjectileCatalog {
  const ProjectileCatalog();

  ProjectileArchetype get(ProjectileId id) {
    switch (id) {
      case ProjectileId.iceBolt:
        return const ProjectileArchetype(
          speedUnitsPerSecond: 1600.0,
          lifetimeSeconds: 1.0,
          colliderSizeX: 18.0,
          colliderSizeY: 8.0,
        );
      case ProjectileId.lightningBolt:
        return const ProjectileArchetype(
          speedUnitsPerSecond: 900.0,
          lifetimeSeconds: 1.2,
          colliderSizeX: 16.0,
          colliderSizeY: 8.0,
        );
    }
  }
}

class ProjectileCatalogDerived {
  const ProjectileCatalogDerived._({required this.tickHz, required this.base});

  factory ProjectileCatalogDerived.from(
    ProjectileCatalog base, {
    required int tickHz,
  }) {
    if (tickHz <= 0) {
      throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
    }
    return ProjectileCatalogDerived._(tickHz: tickHz, base: base);
  }

  final int tickHz;
  final ProjectileCatalog base;

  int lifetimeTicks(ProjectileId id) {
    return ticksFromSecondsCeil(base.get(id).lifetimeSeconds, tickHz);
  }
}


===== FILE: lib/core/projectiles/projectile_id.dart =====
enum ProjectileId { iceBolt, lightningBolt }



===== FILE: lib/core/scoring/run_score_breakdown.dart =====
import '../enemies/enemy_id.dart';
import '../tuning/score_tuning.dart';

enum RunScoreRowKind { distance, time, collectibles, enemyKill }

class RunScoreRow {
  const RunScoreRow({
    required this.kind,
    required this.count,
    required this.points,
    this.enemyId,
  });

  /// Row type (distance/time/collectibles/enemy kills).
  final RunScoreRowKind kind;

  /// Amount shown on the left side (meters, seconds, collectibles, kills).
  final int count;

  /// Total points contributed by this row.
  final int points;

  /// Enemy kind for kill rows.
  final EnemyId? enemyId;
}

class RunScoreBreakdown {
  const RunScoreBreakdown({
    required this.rows,
    required this.totalPoints,
  });

  final List<RunScoreRow> rows;
  final int totalPoints;
}

RunScoreBreakdown buildRunScoreBreakdown({
  required int tick,
  required double distanceUnits,
  required int collectibles,
  required int collectibleScore,
  required List<int> enemyKillCounts,
  required ScoreTuning tuning,
  required int tickHz,
  int unitsPerMeter = 100,
}) {
  final meters =
      unitsPerMeter <= 0 ? 0 : (distanceUnits / unitsPerMeter).floor();
  final timeSeconds = tickHz <= 0 ? 0 : tick ~/ tickHz;

  final rows = <RunScoreRow>[
    RunScoreRow(
      kind: RunScoreRowKind.distance,
      count: meters,
      points: meters * tuning.distanceScorePerMeter,
    ),
    RunScoreRow(
      kind: RunScoreRowKind.time,
      count: timeSeconds,
      points: timeSeconds * tuning.timeScorePerSecond,
    ),
    RunScoreRow(
      kind: RunScoreRowKind.collectibles,
      count: collectibles,
      points: collectibleScore,
    ),
  ];

  for (final enemyId in EnemyId.values) {
    final index = enemyId.index;
    final kills = index < enemyKillCounts.length ? enemyKillCounts[index] : 0;
    if (kills <= 0) continue;
    rows.add(
      RunScoreRow(
        kind: RunScoreRowKind.enemyKill,
        count: kills,
        points: kills * _enemyKillScore(tuning, enemyId),
        enemyId: enemyId,
      ),
    );
  }

  var totalPoints = 0;
  for (final row in rows) {
    totalPoints += row.points;
  }

  return RunScoreBreakdown(
    rows: List<RunScoreRow>.unmodifiable(rows),
    totalPoints: totalPoints,
  );
}

int _enemyKillScore(ScoreTuning tuning, EnemyId enemyId) {
  switch (enemyId) {
    case EnemyId.groundEnemy:
      return tuning.groundEnemyKillScore;
    case EnemyId.flyingEnemy:
      return tuning.flyingEnemyKillScore;
  }
}


===== FILE: lib/core/snapshots/entity_render_snapshot.dart =====
// Renderer-facing entity data extracted from the Core at the end of a tick.
//
// This is a read-only, serializable view of entity state for rendering only.
// It must not leak internal core storage details.
import '../util/vec2.dart';
import '../projectiles/projectile_id.dart';
import 'enums.dart';

/// Render-only view of an entity.
class EntityRenderSnapshot {
  const EntityRenderSnapshot({
    required this.id,
    required this.kind,
    required this.pos,
    required this.facing,
    required this.anim,
    required this.grounded,
    this.vel,
    this.size,
    this.projectileId,
    this.pickupVariant,
    this.z,
    this.rotationRad = 0.0,
    this.animFrame,
  });

  /// Stable entity identifier (protocol-stable).
  final int id;

  /// Broad entity classification for choosing visuals/behavior.
  final EntityKind kind;

  /// World position in virtual pixels.
  final Vec2 pos;

  /// Optional world velocity (useful for facing/animation).
  final Vec2? vel;

  /// Optional full extents in world units (virtual pixels).
  ///
  /// Render-only hint for placeholder shapes (e.g. projectile rectangles).
  final Vec2? size;

  /// Optional projectile archetype id (set when [kind] is [EntityKind.projectile]).
  final ProjectileId? projectileId;

  /// Optional pickup variant for render-only pickup styling.
  final int? pickupVariant;

  /// Optional sort key for render ordering.
  final double? z;

  /// Optional rotation (radians) for rendering orientation.
  final double rotationRad;

  /// Facing direction for choosing sprites/poses.
  final Facing facing;

  /// Whether the entity is grounded at the end of the tick.
  ///
  /// This is authoritative collision state from Core (do not infer from anim).
  final bool grounded;

  /// Logical animation selection (renderer maps to assets).
  final AnimKey anim;

  /// Optional frame hint for deterministic animation in replays/networking.
  final int? animFrame;
}

/// Variant codes for pickup rendering (color/style mapping).
class PickupVariant {
  static const int collectible = 0;
  static const int restorationHealth = 1;
  static const int restorationMana = 2;
  static const int restorationStamina = 3;
}


===== FILE: lib/core/snapshots/enums.dart =====
// Protocol-stable enums used by snapshots (and later networking).
//
// Keep these enums stable over time because they are part of the render
// contract and may become part of the network protocol.
//
// These enums are "logical" (game meaning), not asset/texture names.

/// Logical animation state (not tied to any specific texture or asset).
enum AnimKey {
  idle,
  run,
  jump,
  fall,
  hit,
  cast,
  death,
  spawn,
}

/// Broad entity classification used by the renderer and (later) networking.
enum EntityKind {
  player,
  enemy,
  projectile,
  obstacle,
  pickup,
  hazard,
  trigger,
}

/// Horizontal facing direction for animation/aiming.
enum Facing {
  left,
  right,
}


===== FILE: lib/core/snapshots/game_state_snapshot.dart =====
// Immutable snapshot of the full game state needed by Render/UI.
//
// Built by the Core after each fixed simulation tick and treated as read-only
// by Flame/Flutter. This is the primary contract between Core and the rest of
// the app.
import 'entity_render_snapshot.dart';
import 'player_hud_snapshot.dart';
import 'static_ground_gap_snapshot.dart';
import 'static_solid_snapshot.dart';

/// Snapshot of the current game state at a specific simulation tick.
class GameStateSnapshot {
  const GameStateSnapshot({
    required this.tick,
    required this.seed,
    required this.distance,
    required this.paused,
    required this.gameOver,
    required this.cameraCenterX,
    required this.cameraCenterY,
    required this.hud,
    required this.entities,
    required this.staticSolids,
    required this.groundGaps,
  });

  /// Current simulation tick.
  final int tick;

  /// Seed used for deterministic generation/RNG.
  final int seed;

  /// Distance progressed in the run (placeholder for V0).
  final double distance;

  /// Whether the simulation is currently paused.
  final bool paused;

  /// Whether the run has ended (simulation is frozen).
  final bool gameOver;

  /// Camera center used for rendering this snapshot.
  final double cameraCenterX;
  final double cameraCenterY;

  /// HUD-only player stats.
  final PlayerHudSnapshot hud;

  /// Render-only entity list for the current tick.
  final List<EntityRenderSnapshot> entities;

  /// Render-only static collision geometry (platforms/obstacles) for this run.
  final List<StaticSolidSnapshot> staticSolids;

  /// Render-only ground gaps (holes in the ground band).
  final List<StaticGroundGapSnapshot> groundGaps;
}


===== FILE: lib/core/snapshots/player_hud_snapshot.dart =====
/// HUD-only data extracted from the Core.
///
/// Split from entity snapshots so the UI can render player stats without
/// scanning all entities every frame.
class PlayerHudSnapshot {
  const PlayerHudSnapshot({
    required this.hp,
    required this.hpMax,
    required this.mana,
    required this.manaMax,
    required this.stamina,
    required this.staminaMax,
    required this.canAffordJump,
    required this.canAffordDash,
    required this.canAffordMelee,
    required this.canAffordProjectile,
    required this.dashCooldownTicksLeft,
    required this.dashCooldownTicksTotal,
    required this.meleeCooldownTicksLeft,
    required this.meleeCooldownTicksTotal,
    required this.projectileCooldownTicksLeft,
    required this.projectileCooldownTicksTotal,
    required this.collectibles,
    required this.collectibleScore,
  });

  /// Current health.
  final double hp;

  /// Maximum health.
  final double hpMax;

  /// Current mana (resource for spells).
  final double mana;

  /// Maximum mana.
  final double manaMax;

  /// Current stamina (resource for physical actions like jump/dash).
  final double stamina;

  /// Maximum stamina.
  final double staminaMax;

  /// Whether stamina is sufficient for jumping.
  final bool canAffordJump;

  /// Whether stamina is sufficient for dashing.
  final bool canAffordDash;

  /// Whether stamina is sufficient for melee.
  final bool canAffordMelee;

  /// Whether mana is sufficient for projectile casting.
  final bool canAffordProjectile;

  /// Remaining dash cooldown ticks.
  final int dashCooldownTicksLeft;

  /// Total dash cooldown ticks.
  final int dashCooldownTicksTotal;

  /// Remaining melee cooldown ticks.
  final int meleeCooldownTicksLeft;

  /// Total melee cooldown ticks.
  final int meleeCooldownTicksTotal;

  /// Remaining projectile cooldown ticks.
  final int projectileCooldownTicksLeft;

  /// Total projectile cooldown ticks.
  final int projectileCooldownTicksTotal;

  /// Collected collectibles (placeholder for V0).
  final int collectibles;

  /// Score value earned from collectibles (not yet applied to run score).
  final int collectibleScore;
}


===== FILE: lib/core/snapshots/static_ground_gap_snapshot.dart =====
/// Renderer-facing snapshot for a gap in the ground band.
///
/// This is a read-only view for rendering/debug overlays. Authoritative
/// collision still lives in Core using `StaticWorldGeometry`.
class StaticGroundGapSnapshot {
  const StaticGroundGapSnapshot({
    required this.minX,
    required this.maxX,
  });

  final double minX;
  final double maxX;
}


===== FILE: lib/core/snapshots/static_solid_snapshot.dart =====
/// Renderer-facing snapshot for one piece of static collision geometry.
///
/// This is a read-only view for rendering/debug overlays. Authoritative
/// collision still lives in Core using `StaticWorldGeometry`.
class StaticSolidSnapshot {
  const StaticSolidSnapshot({
    required this.minX,
    required this.minY,
    required this.maxX,
    required this.maxY,
    required this.sides,
    required this.oneWayTop,
  });

  final double minX;
  final double minY;
  final double maxX;
  final double maxY;

  /// Bitmask of enabled faces.
  final int sides;

  /// Whether the top face behaves as one-way (platform).
  final bool oneWayTop;
}



===== FILE: lib/core/spells/spawn_spell_projectile.dart =====
import 'dart:math';

import '../combat/faction.dart';
import '../ecs/entity_id.dart';
import '../ecs/stores/collider_aabb_store.dart';
import '../ecs/stores/lifetime_store.dart';
import '../ecs/stores/projectile_store.dart';
import '../ecs/stores/spell_origin_store.dart';
import '../ecs/world.dart';
import '../projectiles/projectile_catalog.dart';
import '../projectiles/projectile_id.dart';
import 'spell_catalog.dart';
import 'spell_id.dart';

// Centralize spell->projectile checks and direction normalization here so
// player/enemy casting cannot drift over time.
const _dirEps2 = 1e-12;

({double x, double y}) _normalizeDirOrFallback(
  double x,
  double y, {
  required double fallbackX,
  required double fallbackY,
}) {
  final len2 = x * x + y * y;
  if (len2 <= _dirEps2) {
    final fbLen2 = fallbackX * fallbackX + fallbackY * fallbackY;
    if (fbLen2 <= _dirEps2) {
      return (x: 1.0, y: 0.0);
    }
    final invLen = 1.0 / sqrt(fbLen2);
    return (x: fallbackX * invLen, y: fallbackY * invLen);
  }

  final invLen = 1.0 / sqrt(len2);
  return (x: x * invLen, y: y * invLen);
}

EntityId _spawnResolvedSpellProjectile(
  EcsWorld world, {
  required ProjectileCatalogDerived projectiles,
  required SpellId spellId,
  required ProjectileId projectileId,
  required Faction faction,
  required EntityId owner,
  required double originX,
  required double originY,
  required double dirX,
  required double dirY,
  required double speedUnitsPerSecond,
  required double damage,
}) {
  final proj = projectiles.base.get(projectileId);
  final halfX = proj.colliderSizeX * 0.5;
  final halfY = proj.colliderSizeY * 0.5;

  final entity = world.createEntity();
  world.transform.add(
    entity,
    posX: originX,
    posY: originY,
    velX: 0.0,
    velY: 0.0,
  );
  world.projectile.add(
    entity,
    ProjectileDef(
      projectileId: projectileId,
      faction: faction,
      owner: owner,
      dirX: dirX,
      dirY: dirY,
      speedUnitsPerSecond: speedUnitsPerSecond,
      damage: damage,
    ),
  );
  world.spellOrigin.add(entity, SpellOriginDef(spellId: spellId));
  world.lifetime.add(
    entity,
    LifetimeDef(ticksLeft: projectiles.lifetimeTicks(projectileId)),
  );

  // Projectiles participate in hit resolution using the same AABB model as actors.
  world.colliderAabb.add(entity, ColliderAabbDef(halfX: halfX, halfY: halfY));

  return entity;
}

/// Spawns a spell projectile from a caster position with a consistent origin
/// offset along the cast direction.
///
/// Call sites should pass the raw direction (e.g. aim vector, target delta) and
/// a normalized fallback (e.g. facing direction). This function normalizes once
/// and guarantees consistent behavior across player/enemy casting.
EntityId? spawnSpellProjectileFromCaster(
  EcsWorld world, {
  required SpellCatalog spells,
  required ProjectileCatalogDerived projectiles,
  required SpellId spellId,
  required Faction faction,
  required EntityId owner,
  required double casterX,
  required double casterY,
  required double originOffset,
  required double dirX,
  required double dirY,
  required double fallbackDirX,
  required double fallbackDirY,
}) {
  final spell = spells.get(spellId);
  final projectileId = spell.projectileId;
  if (projectileId == null) return null;

  final dir = _normalizeDirOrFallback(
    dirX,
    dirY,
    fallbackX: fallbackDirX,
    fallbackY: fallbackDirY,
  );

  final originX = casterX + dir.x * originOffset;
  final originY = casterY + dir.y * originOffset;

  return _spawnResolvedSpellProjectile(
    world,
    projectiles: projectiles,
    spellId: spellId,
    projectileId: projectileId,
    faction: faction,
    owner: owner,
    originX: originX,
    originY: originY,
    dirX: dir.x,
    dirY: dir.y,
    speedUnitsPerSecond: projectiles.base.get(projectileId).speedUnitsPerSecond,
    damage: spell.stats.damage,
  );
}

EntityId? spawnSpellProjectile(
  EcsWorld world, {
  required SpellCatalog spells,
  required ProjectileCatalogDerived projectiles,
  required SpellId spellId,
  required Faction faction,
  required EntityId owner,
  required double originX,
  required double originY,
  required double dirX,
  required double dirY,
}) {
  final spell = spells.get(spellId);
  final projectileId = spell.projectileId;
  if (projectileId == null) return null;

  final dir = _normalizeDirOrFallback(
    dirX,
    dirY,
    fallbackX: 1.0,
    fallbackY: 0.0,
  );

  return _spawnResolvedSpellProjectile(
    world,
    projectiles: projectiles,
    spellId: spellId,
    projectileId: projectileId,
    faction: faction,
    owner: owner,
    originX: originX,
    originY: originY,
    dirX: dir.x,
    dirY: dir.y,
    speedUnitsPerSecond: projectiles.base.get(projectileId).speedUnitsPerSecond,
    damage: spell.stats.damage,
  );
}


===== FILE: lib/core/spells/spell_catalog.dart =====
import '../projectiles/projectile_id.dart';
import 'spell_id.dart';

class ProjectileSpellStats {
  const ProjectileSpellStats({
    required this.manaCost,
    required this.damage,
  });

  final double manaCost;
  final double damage;
}

class SpellDef {
  const SpellDef({
    required this.stats,
    required this.projectileId,
  });

  /// Spell-specific gameplay stats (resource cost, damage, etc).
  final ProjectileSpellStats stats;

  /// Optional projectile mapping. Non-projectile spells have `null`.
  final ProjectileId? projectileId;
}

class SpellCatalog {
  const SpellCatalog();

  SpellDef get(SpellId id) {
    switch (id) {
      case SpellId.iceBolt:
        return const SpellDef(
          stats: ProjectileSpellStats(manaCost: 10.0, damage: 15.0),
          projectileId: ProjectileId.iceBolt,
        );
      case SpellId.lightning:
        return const SpellDef(
          stats: ProjectileSpellStats(manaCost: 10.0, damage: 5.0),
          projectileId: ProjectileId.lightningBolt,
        );
    }
  }
}


===== FILE: lib/core/spells/spell_id.dart =====
enum SpellId { iceBolt, lightning }



===== FILE: lib/core/track/track_streamer.dart =====
import '../collision/static_world_geometry.dart';
import '../enemies/enemy_id.dart';
import '../tuning/track_tuning.dart';

typedef SpawnEnemy = void Function(EnemyId enemyId, double x);

class V0TrackSpawnedChunk {
  const V0TrackSpawnedChunk({
    required this.index,
    required this.startX,
  });

  final int index;
  final double startX;
}

class V0TrackStreamStepResult {
  const V0TrackStreamStepResult({
    required this.changed,
    required this.spawnedChunks,
  });

  final bool changed;
  final List<V0TrackSpawnedChunk> spawnedChunks;
}

class V0ChunkPattern {
  const V0ChunkPattern({
    required this.name,
    this.platforms = const <_PlatformRel>[],
    this.obstacles = const <_ObstacleRel>[],
    this.groundGaps = const <_GapRel>[],
    this.spawnMarkers = const <_SpawnMarker>[],
  });

  final String name;
  final List<_PlatformRel> platforms;
  final List<_ObstacleRel> obstacles;
  final List<_GapRel> groundGaps;
  final List<_SpawnMarker> spawnMarkers;
}

class TrackStreamer {
  TrackStreamer({
    required this.seed,
    required this.tuning,
    required this.groundTopY,
  }) : _nextChunkIndex = 0,
       _nextChunkStartX = 0.0;

  final int seed;
  final TrackTuning tuning;
  final double groundTopY;

  int _nextChunkIndex;
  double _nextChunkStartX;

  final List<_ActiveChunk> _active = <_ActiveChunk>[];
  List<StaticSolid> _dynamicSolids = const <StaticSolid>[];
  List<StaticGroundSegment> _dynamicGroundSegments =
      const <StaticGroundSegment>[];
  List<StaticGroundGap> _dynamicGroundGaps = const <StaticGroundGap>[];

  /// Current streamed solids (excluding any caller-provided base solids).
  List<StaticSolid> get dynamicSolids => _dynamicSolids;

  /// Current streamed ground segments (excluding any base segments).
  List<StaticGroundSegment> get dynamicGroundSegments => _dynamicGroundSegments;

  /// Current streamed ground gaps (excluding any base gaps).
  List<StaticGroundGap> get dynamicGroundGaps => _dynamicGroundGaps;

  /// Advances chunk streaming based on the current camera bounds.
  ///
  /// Returns a step result (spawned chunks + whether geometry changed).
  V0TrackStreamStepResult step({
    required double cameraLeft,
    required double cameraRight,
    required SpawnEnemy spawnEnemy,
  }) {
    if (!tuning.enabled) {
      return const V0TrackStreamStepResult(
        changed: false,
        spawnedChunks: <V0TrackSpawnedChunk>[],
      );
    }

    var changed = false;
    final spawnedChunks = <V0TrackSpawnedChunk>[];

    // Spawn new chunks ahead of the camera.
    final spawnLimitX = cameraRight + tuning.spawnAheadMargin;
    while (_nextChunkStartX <= spawnLimitX) {
      final chunkIndex = _nextChunkIndex;
      final startX = _nextChunkStartX;
      final endX = startX + tuning.chunkWidth;

      final pattern = _patternFor(seed, chunkIndex);
      final solids = _buildSolids(
        pattern,
        chunkStartX: startX,
        chunkIndex: chunkIndex,
      );
      final ground = _buildGroundSegments(
        pattern,
        chunkStartX: startX,
        chunkIndex: chunkIndex,
      );
      _active.add(
        _ActiveChunk(
          index: chunkIndex,
          startX: startX,
          endX: endX,
          solids: solids,
          groundSegments: ground.segments,
          groundGaps: ground.gaps,
        ),
      );
      spawnedChunks.add(
        V0TrackSpawnedChunk(index: chunkIndex, startX: startX),
      );

      _spawnEnemiesForChunk(
        pattern,
        chunkIndex,
        chunkStartX: startX,
        spawnEnemy: spawnEnemy,
      );

      _nextChunkIndex += 1;
      _nextChunkStartX += tuning.chunkWidth;
      changed = true;
    }

    // Cull old chunks behind the camera.
    final cullLimitX = cameraLeft - tuning.cullBehindMargin;
    while (_active.isNotEmpty && _active.first.endX < cullLimitX) {
      _active.removeAt(0);
      changed = true;
    }

    if (changed) {
      final rebuilt = <StaticSolid>[];
      final rebuiltGroundSegments = <StaticGroundSegment>[];
      final rebuiltGroundGaps = <StaticGroundGap>[];
      for (final c in _active) {
        rebuilt.addAll(c.solids);
        rebuiltGroundSegments.addAll(c.groundSegments);
        rebuiltGroundGaps.addAll(c.groundGaps);
      }
      _dynamicSolids = List<StaticSolid>.unmodifiable(rebuilt);
      _dynamicGroundSegments =
          List<StaticGroundSegment>.unmodifiable(rebuiltGroundSegments);
      _dynamicGroundGaps =
          List<StaticGroundGap>.unmodifiable(rebuiltGroundGaps);
    }

    return V0TrackStreamStepResult(
      changed: changed,
      spawnedChunks: List<V0TrackSpawnedChunk>.unmodifiable(spawnedChunks),
    );
  }

  void _spawnEnemiesForChunk(
    V0ChunkPattern pattern,
    int chunkIndex, {
    required double chunkStartX,
    required SpawnEnemy spawnEnemy,
  }) {
    // Safety: keep the early run empty so the player isn't immediately swarmed.
    if (chunkIndex < 3) return;

    for (var i = 0; i < pattern.spawnMarkers.length; i += 1) {
      final m = pattern.spawnMarkers[i];
      assert(
        _withinChunk(m.x, 0.0),
        'Spawn marker out of chunk bounds: ${pattern.name}',
      );
      assert(_snapped(m.x), 'Spawn marker not snapped to grid: ${pattern.name}');
      final roll = _mix32(
        seed ^ (chunkIndex * 0x9e3779b9) ^ (i * 0x85ebca6b) ^ m.salt,
      );
      if ((roll % 100) >= m.chancePercent) continue;

      final x = chunkStartX + m.x;
      spawnEnemy(m.enemyId, x);
    }
  }

  List<StaticSolid> _buildSolids(
    V0ChunkPattern pattern, {
    required double chunkStartX,
    required int chunkIndex,
  }) {
    // Preserve author ordering for determinism (pattern order, then chunk order).
    final solids = <StaticSolid>[];
    var localSolidIndex = 0;

    for (final p in pattern.platforms) {
      assert(
        _withinChunk(p.x, p.width),
        'Platform out of chunk bounds: ${pattern.name}',
      );
      assert(_snapped(p.x) && _snapped(p.width) && _snapped(p.aboveGroundTop),
          'Platform not snapped to grid: ${pattern.name}');
      final topY = groundTopY - p.aboveGroundTop;
      solids.add(
        StaticSolid(
          minX: chunkStartX + p.x,
          minY: topY,
          maxX: chunkStartX + p.x + p.width,
          maxY: topY + p.thickness,
          sides: StaticSolid.sideTop,
          oneWayTop: true,
          chunkIndex: chunkIndex,
          localSolidIndex: localSolidIndex,
        ),
      );
      localSolidIndex += 1;
    }

    for (final o in pattern.obstacles) {
      assert(
        _withinChunk(o.x, o.width),
        'Obstacle out of chunk bounds: ${pattern.name}',
      );
      assert(_snapped(o.x) && _snapped(o.width) && _snapped(o.height),
          'Obstacle not snapped to grid: ${pattern.name}');
      solids.add(
        StaticSolid(
          minX: chunkStartX + o.x,
          minY: groundTopY - o.height,
          maxX: chunkStartX + o.x + o.width,
          maxY: groundTopY,
          sides: StaticSolid.sideAll,
          oneWayTop: false,
          chunkIndex: chunkIndex,
          localSolidIndex: localSolidIndex,
        ),
      );
      localSolidIndex += 1;
    }

    return solids;
  }

  _GroundBuildResult _buildGroundSegments(
    V0ChunkPattern pattern, {
    required double chunkStartX,
    required int chunkIndex,
  }) {
    final orderedGaps = List<_GapRel>.from(pattern.groundGaps);
    if (orderedGaps.isNotEmpty) {
      orderedGaps.sort((a, b) => a.x.compareTo(b.x));
    }

    final segments = <StaticGroundSegment>[];
    final gaps = <StaticGroundGap>[];
    var cursor = 0.0;
    var localSegmentIndex = 0;
    var lastGapEnd = -1.0;

    for (final gap in orderedGaps) {
      assert(
        _withinChunk(gap.x, gap.width),
        'Ground gap out of chunk bounds: ${pattern.name}',
      );
      assert(_snapped(gap.x) && _snapped(gap.width),
          'Ground gap not snapped to grid: ${pattern.name}');
      assert(
        gap.x >= lastGapEnd - 1e-6,
        'Ground gap overlaps previous: ${pattern.name}',
      );

      final gapStart = gap.x;
      final gapEnd = gap.x + gap.width;
      if (gapStart > cursor + 1e-6) {
        segments.add(
          StaticGroundSegment(
            minX: chunkStartX + cursor,
            maxX: chunkStartX + gapStart,
            topY: groundTopY,
            chunkIndex: chunkIndex,
            localSegmentIndex: localSegmentIndex,
          ),
        );
        localSegmentIndex += 1;
      }

      gaps.add(
        StaticGroundGap(
          minX: chunkStartX + gapStart,
          maxX: chunkStartX + gapEnd,
        ),
      );

      cursor = gapEnd > cursor ? gapEnd : cursor;
      lastGapEnd = gapEnd;
    }

    if (cursor < tuning.chunkWidth - 1e-6) {
      segments.add(
        StaticGroundSegment(
          minX: chunkStartX + cursor,
          maxX: chunkStartX + tuning.chunkWidth,
          topY: groundTopY,
          chunkIndex: chunkIndex,
          localSegmentIndex: localSegmentIndex,
        ),
      );
    }

    return _GroundBuildResult(segments: segments, gaps: gaps);
  }

  V0ChunkPattern _patternFor(int seed, int chunkIndex) {
    // Mild early-game safety: pick from easier patterns for the first few chunks.
    final isEarly = chunkIndex < 3;
    final pool = isEarly ? _easyPatterns : _allPatterns;
    final h = _mix32(seed ^ (chunkIndex * 0x9e3779b9) ^ 0x27d4eb2d);
    final idx = h % pool.length;
    return pool[idx];
  }

  // === Pattern library (authoring-layer) ===
  //
  // Notes:
  // - All coordinates are relative to the chunk start (x in [0, chunkWidth)).
  // - Y is expressed as "above ground top" (so 48 means 48 units above ground).
  // - Values are authored on a 16-unit grid for stability.

  static const double _t = 16.0; // platform thickness

  static const List<V0ChunkPattern> _easyPatterns = <V0ChunkPattern>[
    V0ChunkPattern(
      name: 'recovery-flat',
      platforms: <_PlatformRel>[],
      obstacles: <_ObstacleRel>[],
      groundGaps: <_GapRel>[],
      spawnMarkers: <_SpawnMarker>[],
    ),
    V0ChunkPattern(
      name: 'single-low-platform',
      platforms: <_PlatformRel>[
        _PlatformRel(x: 160, width: 160, aboveGroundTop: 48, thickness: _t),
      ],
      obstacles: <_ObstacleRel>[],
      groundGaps: <_GapRel>[
        _GapRel(x: 64, width: 96),
      ],
      spawnMarkers: <_SpawnMarker>[
        _SpawnMarker(enemyId: EnemyId.flyingEnemy, x: 240, chancePercent: 10, salt: 0x11),
      ],
    ),
    V0ChunkPattern(
      name: 'two-low-platforms',
      platforms: <_PlatformRel>[
        _PlatformRel(x: 64, width: 144, aboveGroundTop: 48, thickness: _t),
        _PlatformRel(x: 272, width: 144, aboveGroundTop: 64, thickness: _t),
      ],
      obstacles: <_ObstacleRel>[],
      groundGaps: <_GapRel>[],
      spawnMarkers: <_SpawnMarker>[
        _SpawnMarker(enemyId: EnemyId.groundEnemy, x: 448, chancePercent: 10, salt: 0x12),
      ],
    ),
  ];

  static const List<V0ChunkPattern> _allPatterns = <V0ChunkPattern>[
    // Recovery / breathers.
    ..._easyPatterns,

    // Platforming (optional; ground is always safe in V0).
    V0ChunkPattern(
      name: 'staggered-mid-platforms',
      platforms: <_PlatformRel>[
        _PlatformRel(x: 48, width: 160, aboveGroundTop: 64, thickness: _t),
        _PlatformRel(x: 256, width: 160, aboveGroundTop: 96, thickness: _t),
      ],
      groundGaps: <_GapRel>[
        _GapRel(x: 240, width: 128),
      ],
      spawnMarkers: <_SpawnMarker>[
        _SpawnMarker(enemyId: EnemyId.flyingEnemy, x: 352, chancePercent: 17, salt: 0x01),
      ],
    ),
    V0ChunkPattern(
      name: 'triple-runner-platforms',
      platforms: <_PlatformRel>[
        _PlatformRel(x: 32, width: 128, aboveGroundTop: 48, thickness: _t),
        _PlatformRel(x: 192, width: 128, aboveGroundTop: 80, thickness: _t),
        _PlatformRel(x: 352, width: 96, aboveGroundTop: 64, thickness: _t),
      ],
      groundGaps: <_GapRel>[],
      spawnMarkers: <_SpawnMarker>[
        _SpawnMarker(enemyId: EnemyId.flyingEnemy, x: 288, chancePercent: 15, salt: 0x02),
      ],
    ),
    V0ChunkPattern(
      name: 'high-platform-over-obstacle',
      platforms: <_PlatformRel>[
        _PlatformRel(x: 224, width: 192, aboveGroundTop: 112, thickness: _t),
      ],
      obstacles: <_ObstacleRel>[
        _ObstacleRel(x: 128, width: 48, height: 64),
      ],
      groundGaps: <_GapRel>[
        _GapRel(x: 176, width: 96),
      ],
      spawnMarkers: <_SpawnMarker>[
        _SpawnMarker(enemyId: EnemyId.groundEnemy, x: 320, chancePercent: 22, salt: 0x03),
      ],
    ),

    // Obstacles (ground blocks that force a jump/dash).
    V0ChunkPattern(
      name: 'single-block',
      obstacles: <_ObstacleRel>[
        _ObstacleRel(x: 224, width: 48, height: 64),
      ],
      groundGaps: <_GapRel>[
        _GapRel(x: 128, width: 96),
      ],
      spawnMarkers: <_SpawnMarker>[
        _SpawnMarker(enemyId: EnemyId.groundEnemy, x: 320, chancePercent: 17, salt: 0x04),
      ],
    ),
    V0ChunkPattern(
      name: 'double-blocks',
      obstacles: <_ObstacleRel>[
        _ObstacleRel(x: 160, width: 32, height: 48),
        _ObstacleRel(x: 288, width: 48, height: 64),
      ],
      groundGaps: <_GapRel>[],
      spawnMarkers: <_SpawnMarker>[
        _SpawnMarker(enemyId: EnemyId.flyingEnemy, x: 96, chancePercent: 12, salt: 0x05),
        _SpawnMarker(enemyId: EnemyId.groundEnemy, x: 352, chancePercent: 15, salt: 0x06),
      ],
    ),
    V0ChunkPattern(
      name: 'low-staircase-platforms',
      platforms: <_PlatformRel>[
        _PlatformRel(x: 48, width: 128, aboveGroundTop: 48, thickness: _t),
        _PlatformRel(x: 208, width: 128, aboveGroundTop: 64, thickness: _t),
        _PlatformRel(x: 368, width: 128, aboveGroundTop: 80, thickness: _t),
      ],
      groundGaps: <_GapRel>[
        _GapRel(x: 304, width: 96),
      ],
      spawnMarkers: <_SpawnMarker>[
        _SpawnMarker(enemyId: EnemyId.groundEnemy, x: 112, chancePercent: 15, salt: 0x07),
        _SpawnMarker(enemyId: EnemyId.flyingEnemy, x: 320, chancePercent: 15, salt: 0x08),
      ],
    ),
    V0ChunkPattern(
      name: 'wide-platform-gap',
      platforms: <_PlatformRel>[
        _PlatformRel(x: 32, width: 192, aboveGroundTop: 64, thickness: _t),
        _PlatformRel(x: 288, width: 192, aboveGroundTop: 64, thickness: _t),
      ],
      groundGaps: <_GapRel>[],
      spawnMarkers: <_SpawnMarker>[
        _SpawnMarker(enemyId: EnemyId.flyingEnemy, x: 192, chancePercent: 17, salt: 0x09),
        _SpawnMarker(enemyId: EnemyId.groundEnemy, x: 448, chancePercent: 15, salt: 0x0A),
      ],
    ),
    V0ChunkPattern(
      name: 'double-obstacle-lane',
      obstacles: <_ObstacleRel>[
        _ObstacleRel(x: 144, width: 48, height: 64),
        _ObstacleRel(x: 336, width: 48, height: 64),
      ],
      groundGaps: <_GapRel>[],
      spawnMarkers: <_SpawnMarker>[
        _SpawnMarker(enemyId: EnemyId.groundEnemy, x: 256, chancePercent: 17, salt: 0x0B),
        _SpawnMarker(enemyId: EnemyId.flyingEnemy, x: 80, chancePercent: 12, salt: 0x0C),
      ],
    ),
    V0ChunkPattern(
      name: 'mid-platform-overhang',
      platforms: <_PlatformRel>[
        _PlatformRel(x: 96, width: 160, aboveGroundTop: 96, thickness: _t),
        _PlatformRel(x: 384, width: 128, aboveGroundTop: 64, thickness: _t),
      ],
      obstacles: <_ObstacleRel>[
        _ObstacleRel(x: 320, width: 64, height: 80),
      ],
      groundGaps: <_GapRel>[],
      spawnMarkers: <_SpawnMarker>[
        _SpawnMarker(enemyId: EnemyId.flyingEnemy, x: 176, chancePercent: 15, salt: 0x0D),
        _SpawnMarker(enemyId: EnemyId.groundEnemy, x: 448, chancePercent: 15, salt: 0x0E),
      ],
    ),
    V0ChunkPattern(
      name: 'tight-platforms',
      platforms: <_PlatformRel>[
        _PlatformRel(x: 32, width: 96, aboveGroundTop: 80, thickness: _t),
        _PlatformRel(x: 160, width: 96, aboveGroundTop: 96, thickness: _t),
        _PlatformRel(x: 288, width: 96, aboveGroundTop: 80, thickness: _t),
      ],
      obstacles: <_ObstacleRel>[
        _ObstacleRel(x: 448, width: 48, height: 64),
      ],
      groundGaps: <_GapRel>[
        _GapRel(x: 112, width: 128)
      ],
      spawnMarkers: <_SpawnMarker>[
        _SpawnMarker(enemyId: EnemyId.flyingEnemy, x: 240, chancePercent: 15, salt: 0x0F),
        _SpawnMarker(enemyId: EnemyId.groundEnemy, x: 480, chancePercent: 12, salt: 0x10),
      ],
    ),
    V0ChunkPattern(
      name: 'ground-gap-small',
      groundGaps: <_GapRel>[
        _GapRel(x: 256, width: 64),
      ],
      spawnMarkers: <_SpawnMarker>[
        _SpawnMarker(enemyId: EnemyId.groundEnemy, x: 160, chancePercent: 12, salt: 0x21),
        _SpawnMarker(enemyId: EnemyId.flyingEnemy, x: 416, chancePercent: 12, salt: 0x22),
      ],
    ),
    V0ChunkPattern(
      name: 'ground-gap-wide',
      groundGaps: <_GapRel>[
        _GapRel(x: 224, width: 128),
      ],
      spawnMarkers: <_SpawnMarker>[
        _SpawnMarker(enemyId: EnemyId.flyingEnemy, x: 96, chancePercent: 12, salt: 0x23),
        _SpawnMarker(enemyId: EnemyId.groundEnemy, x: 480, chancePercent: 12, salt: 0x24),
      ],
    ),
  ];

  bool _withinChunk(double x, double width) {
    return x >= 0.0 && (x + width) <= tuning.chunkWidth;
  }

  bool _snapped(double v) {
    final s = tuning.gridSnap;
    final snapped = (v / s).roundToDouble() * s;
    return (v - snapped).abs() < 1e-9;
  }
}

class _ActiveChunk {
  const _ActiveChunk({
    required this.index,
    required this.startX,
    required this.endX,
    required this.solids,
    required this.groundSegments,
    required this.groundGaps,
  });

  final int index;
  final double startX;
  final double endX;
  final List<StaticSolid> solids;
  final List<StaticGroundSegment> groundSegments;
  final List<StaticGroundGap> groundGaps;
}

class _GroundBuildResult {
  const _GroundBuildResult({
    required this.segments,
    required this.gaps,
  });

  final List<StaticGroundSegment> segments;
  final List<StaticGroundGap> gaps;
}

class _PlatformRel {
  const _PlatformRel({
    required this.x,
    required this.width,
    required this.aboveGroundTop,
    required this.thickness,
  }) : assert(width > 0),
       assert(thickness > 0),
       assert(aboveGroundTop > 0);

  final double x;
  final double width;
  final double aboveGroundTop;
  final double thickness;
}

class _ObstacleRel {
  const _ObstacleRel({
    required this.x,
    required this.width,
    required this.height,
  }) : assert(width > 0),
       assert(height > 0);

  final double x;
  final double width;
  final double height;
}

class _GapRel {
  const _GapRel({
    required this.x,
    required this.width,
  }) : assert(width > 0);

  final double x;
  final double width;
}

class _SpawnMarker {
  const _SpawnMarker({
    required this.enemyId,
    required this.x,
    required this.chancePercent,
    required this.salt,
  }) : assert(chancePercent >= 0),
       assert(chancePercent <= 100);

  final EnemyId enemyId;
  final double x;
  final int chancePercent;
  final int salt;
}

int _mix32(int x) {
  // MurmurHash3 finalizer-like mix. Keep it explicitly 32-bit.
  var v = x & 0xffffffff;
  v ^= (v >> 16);
  v = (v * 0x7feb352d) & 0xffffffff;
  v ^= (v >> 15);
  v = (v * 0x846ca68b) & 0xffffffff;
  v ^= (v >> 16);
  return v & 0xffffffff;
}


===== FILE: lib/core/tuning/ability_tuning.dart =====
import '../util/tick_math.dart';

class AbilityTuning {
  const AbilityTuning({
    this.castCooldownSeconds = 0.25,
    this.meleeCooldownSeconds = 0.30,
    this.meleeActiveSeconds = 0.10,
    this.meleeStaminaCost = 5.0,
    this.meleeDamage = 15.0,
    this.meleeHitboxSizeX = 32.0,
    this.meleeHitboxSizeY = 16.0,
  });

  final double castCooldownSeconds;

  final double meleeCooldownSeconds;
  final double meleeActiveSeconds;
  final double meleeStaminaCost;
  final double meleeDamage;

  /// Full extents in world units (virtual pixels).
  final double meleeHitboxSizeX;
  final double meleeHitboxSizeY;
}

class AbilityTuningDerived {
  const AbilityTuningDerived._({
    required this.tickHz,
    required this.base,
    required this.castCooldownTicks,
    required this.meleeCooldownTicks,
    required this.meleeActiveTicks,
  });

  factory AbilityTuningDerived.from(
    AbilityTuning base, {
    required int tickHz,
  }) {
    if (tickHz <= 0) {
      throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
    }

    return AbilityTuningDerived._(
      tickHz: tickHz,
      base: base,
      castCooldownTicks: ticksFromSecondsCeil(base.castCooldownSeconds, tickHz),
      meleeCooldownTicks: ticksFromSecondsCeil(base.meleeCooldownSeconds, tickHz),
      meleeActiveTicks: ticksFromSecondsCeil(base.meleeActiveSeconds, tickHz),
    );
  }

  final int tickHz;
  final AbilityTuning base;

  final int castCooldownTicks;
  final int meleeCooldownTicks;
  final int meleeActiveTicks;
}


===== FILE: lib/core/tuning/camera_tuning.dart =====
import 'dart:math';

import 'movement_tuning.dart';

class CameraTuning {
  const CameraTuning({
    this.speedLagMulX = 1.0,
    this.accelX = 1200.0,
    this.followThresholdRatio = 0.5,
    this.catchupLerp = 8.0,
    this.targetCatchupLerp = 2.5,
  });

  /// Baseline auto-scroll lags behind `MovementTuning.maxSpeedX` by this multiplier.
  final double speedLagMulX;

  /// Acceleration used to ease camera speed toward its target speed.
  final double accelX;

  /// Threshold ratio (from left edge) after which the player can pull the camera forward.
  final double followThresholdRatio;

  /// Smoothing for camera center toward its target (per-second).
  final double catchupLerp;

  /// Smoothing for camera target toward player (per-second).
  final double targetCatchupLerp;
}

class CameraTuningDerived {
  const CameraTuningDerived({
    required this.targetSpeedX,
    required this.accelX,
    required this.followThresholdRatio,
    required this.catchupLerp,
    required this.targetCatchupLerp,
  });

  factory CameraTuningDerived.from(
    CameraTuning tuning, {
    required MovementTuningDerived movement,
  }) {
    final targetSpeedX = max(0.0, movement.base.maxSpeedX * tuning.speedLagMulX);
    return CameraTuningDerived(
      targetSpeedX: targetSpeedX,
      accelX: tuning.accelX,
      followThresholdRatio: tuning.followThresholdRatio,
      catchupLerp: tuning.catchupLerp,
      targetCatchupLerp: tuning.targetCatchupLerp,
    );
  }

  final double targetSpeedX;
  final double accelX;
  final double followThresholdRatio;
  final double catchupLerp;
  final double targetCatchupLerp;
}


===== FILE: lib/core/tuning/collectible_tuning.dart =====
/// V0 collectible spawning and value configuration.
class CollectibleTuning {
  const CollectibleTuning({
    this.enabled = true,
    this.minPerChunk = 1,
    this.maxPerChunk = 2,
    this.spawnStartChunkIndex = 2,
    this.collectibleSize = 10.0,
    this.surfaceClearanceY = 10.0,
    this.noSpawnMargin = 2.0,
    this.minSpacingX = 80.0,
    this.chunkEdgeMarginX = 32.0,
    this.maxAttemptsPerChunk = 40,
    this.despawnBehindCameraMargin = 900.0,
    this.valuePerCollectible = 50,
  }) : assert(maxPerChunk >= minPerChunk);

  final bool enabled;
  final int minPerChunk;
  final int maxPerChunk;
  final int spawnStartChunkIndex;
  final double collectibleSize;
  final double surfaceClearanceY;
  final double noSpawnMargin;
  final double minSpacingX;
  final double chunkEdgeMarginX;
  final int maxAttemptsPerChunk;
  final double despawnBehindCameraMargin;
  final int valuePerCollectible;
}


===== FILE: lib/core/tuning/combat_tuning.dart =====
import '../util/tick_math.dart';

class CombatTuning {
  const CombatTuning({this.invulnerabilitySeconds = 0.25});

  final double invulnerabilitySeconds;
}

class CombatTuningDerived {
  const CombatTuningDerived._({
    required this.tickHz,
    required this.base,
    required this.invulnerabilityTicks,
  });

  factory CombatTuningDerived.from(
    CombatTuning base, {
    required int tickHz,
  }) {
    if (tickHz <= 0) {
      throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
    }

    return CombatTuningDerived._(
      tickHz: tickHz,
      base: base,
      invulnerabilityTicks: ticksFromSecondsCeil(
        base.invulnerabilitySeconds,
        tickHz,
      ),
    );
  }

  final int tickHz;
  final CombatTuning base;

  final int invulnerabilityTicks;
}



===== FILE: lib/core/tuning/flying_enemy_tuning.dart =====
import '../util/tick_math.dart';

class FlyingEnemyTuning {
  const FlyingEnemyTuning({
    this.flyingEnemyHoverOffsetY = 150.0,
    this.flyingEnemyDesiredRangeMin = 50.0,
    this.flyingEnemyDesiredRangeMax = 90.0,
    this.flyingEnemyDesiredRangeHoldMinSeconds = 0.60,
    this.flyingEnemyDesiredRangeHoldMaxSeconds = 1.40,
    this.flyingEnemyHoldSlack = 20.0,
    this.flyingEnemyMaxSpeedX = 300.0,
    this.flyingEnemySlowRadiusX = 80.0,
    this.flyingEnemyAccelX = 600.0,
    this.flyingEnemyDecelX = 400.0,
    this.flyingEnemyMinHeightAboveGround = 100.0,
    this.flyingEnemyMaxHeightAboveGround = 240.0,
    this.flyingEnemyFlightTargetHoldMinSeconds = 1.5,
    this.flyingEnemyFlightTargetHoldMaxSeconds = 3.0,
    this.flyingEnemyMaxSpeedY = 300.0,
    this.flyingEnemyVerticalKp = 4.0,
    this.flyingEnemyVerticalDeadzone = 20.0,
    this.flyingEnemyAimLeadMinSeconds = 0.08,
    this.flyingEnemyAimLeadMaxSeconds = 0.40,
    this.flyingEnemyCastCooldownSeconds = 2.0,
    this.flyingEnemyCastOriginOffset = 20.0,
  });

  // Flying enemy steering.
  final double flyingEnemyHoverOffsetY;
  final double flyingEnemyDesiredRangeMin;
  final double flyingEnemyDesiredRangeMax;
  final double flyingEnemyDesiredRangeHoldMinSeconds;
  final double flyingEnemyDesiredRangeHoldMaxSeconds;
  final double flyingEnemyHoldSlack;
  final double flyingEnemyMaxSpeedX;
  final double flyingEnemySlowRadiusX;
  final double flyingEnemyAccelX;
  final double flyingEnemyDecelX;
  final double flyingEnemyMinHeightAboveGround;
  final double flyingEnemyMaxHeightAboveGround;
  final double flyingEnemyFlightTargetHoldMinSeconds;
  final double flyingEnemyFlightTargetHoldMaxSeconds;
  final double flyingEnemyMaxSpeedY;
  final double flyingEnemyVerticalKp;
  final double flyingEnemyVerticalDeadzone;

  // Flying enemy attacks.
  final double flyingEnemyAimLeadMinSeconds;
  final double flyingEnemyAimLeadMaxSeconds;
  final double flyingEnemyCastCooldownSeconds;
  final double flyingEnemyCastOriginOffset;
}

class FlyingEnemyTuningDerived {
  const FlyingEnemyTuningDerived._({
    required this.tickHz,
    required this.base,
    required this.flyingEnemyCastCooldownTicks,
  });

  factory FlyingEnemyTuningDerived.from(
    FlyingEnemyTuning base, {
    required int tickHz,
  }) {
    if (tickHz <= 0) {
      throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
    }

    return FlyingEnemyTuningDerived._(
      tickHz: tickHz,
      base: base,
      flyingEnemyCastCooldownTicks: ticksFromSecondsCeil(
        base.flyingEnemyCastCooldownSeconds,
        tickHz,
      ),
    );
  }

  final int tickHz;
  final FlyingEnemyTuning base;

  final int flyingEnemyCastCooldownTicks;
}


===== FILE: lib/core/tuning/ground_enemy_tuning.dart =====
import '../util/tick_math.dart';

class GroundEnemyTuning {
  const GroundEnemyTuning({
    this.groundEnemySpeedX = 300.0,
    this.groundEnemyStopDistanceX = 6.0,
    this.groundEnemyAccelX = 600.0,
    this.groundEnemyDecelX = 400.0,
    this.groundEnemyChaseOffsetMaxX = 18.0,
    this.groundEnemyChaseOffsetMinAbsX = 6.0,
    this.groundEnemyChaseOffsetMeleeX = 3.0,
    this.groundEnemyChaseSpeedScaleMin = 0.92,
    this.groundEnemyChaseSpeedScaleMax = 1.08,
    this.groundEnemyJumpSpeed = 500.0,
    this.groundEnemyMeleeRangeX = 26.0,
    this.groundEnemyMeleeCooldownSeconds = 1.0,
    this.groundEnemyMeleeActiveSeconds = 0.10,
    this.groundEnemyMeleeDamage = 5.0,
    this.groundEnemyMeleeHitboxSizeX = 28.0,
    this.groundEnemyMeleeHitboxSizeY = 16.0,
  });

  // Ground enemy steering.
  final double groundEnemySpeedX;
  final double groundEnemyStopDistanceX;
  final double groundEnemyAccelX;
  final double groundEnemyDecelX;
  final double groundEnemyChaseOffsetMaxX;
  final double groundEnemyChaseOffsetMinAbsX;
  final double groundEnemyChaseOffsetMeleeX;
  final double groundEnemyChaseSpeedScaleMin;
  final double groundEnemyChaseSpeedScaleMax;

  /// Instantaneous jump vertical speed (negative is upward).
  final double groundEnemyJumpSpeed;

  // Ground enemy melee.
  final double groundEnemyMeleeRangeX;
  final double groundEnemyMeleeCooldownSeconds;
  final double groundEnemyMeleeActiveSeconds;
  final double groundEnemyMeleeDamage;
  final double groundEnemyMeleeHitboxSizeX;
  final double groundEnemyMeleeHitboxSizeY;
}

class GroundEnemyTuningDerived {
  const GroundEnemyTuningDerived._({
    required this.tickHz,
    required this.base,
    required this.groundEnemyMeleeCooldownTicks,
    required this.groundEnemyMeleeActiveTicks,
  });

  factory GroundEnemyTuningDerived.from(
    GroundEnemyTuning base, {
    required int tickHz,
  }) {
    if (tickHz <= 0) {
      throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
    }

    return GroundEnemyTuningDerived._(
      tickHz: tickHz,
      base: base,
      groundEnemyMeleeCooldownTicks: ticksFromSecondsCeil(
        base.groundEnemyMeleeCooldownSeconds,
        tickHz,
      ),
      groundEnemyMeleeActiveTicks: ticksFromSecondsCeil(
        base.groundEnemyMeleeActiveSeconds,
        tickHz,
      ),
    );
  }

  final int tickHz;
  final GroundEnemyTuning base;

  final int groundEnemyMeleeCooldownTicks;
  final int groundEnemyMeleeActiveTicks;
}


===== FILE: lib/core/tuning/movement_tuning.dart =====
import '../util/tick_math.dart';

/// V0 movement/physics tuning for the Core simulation.
///
/// All units are expressed in world units ("virtual pixels") and seconds:
/// - speeds: world units / second
/// - acceleration: world units / second^2
/// - times: seconds (converted to fixed-tick counts at runtime)
///
/// The derived values are computed once per [tickHz] and then used in the hot
/// per-tick loop to keep the core allocation-light.
const int defaultTickHz = 60;

/// Authoritative movement constants (expressed in seconds-based units).
class MovementTuning {
  const MovementTuning({
    this.playerRadius = 8,
    this.maxSpeedX = 200,
    this.accelerationX = 600,
    this.decelerationX = 400,
    this.minMoveSpeed = 5,
    this.maxVelX = 1500,
    this.maxVelY = 1500,
    this.jumpSpeed = 500,
    this.coyoteTimeSeconds = 0.10,
    this.jumpBufferSeconds = 0.12,
    this.dashSpeedX = 550,
    this.dashDurationSeconds = 0.20,
    this.dashCooldownSeconds = 2.0,
  });

  /// Player "collision" radius in world units (used for ground contact in V0).
  final double playerRadius;

  /// Target max horizontal speed when holding move input.
  final double maxSpeedX;
  final double accelerationX;
  final double decelerationX;
  final double minMoveSpeed;

  /// Speed clamps (safety caps).
  final double maxVelX;
  final double maxVelY;

  /// Instantaneous jump vertical speed (negative is upward).
  final double jumpSpeed;

  /// Jump forgiveness windows (platformer-style).
  final double coyoteTimeSeconds;
  final double jumpBufferSeconds;

  /// Dash parameters.
  final double dashSpeedX;
  final double dashDurationSeconds;
  final double dashCooldownSeconds;
}

/// Derived, tick-based tuning computed for a specific [tickHz].
class MovementTuningDerived {
  const MovementTuningDerived._({
    required this.tickHz,
    required this.dtSeconds,
    required this.base,
    required this.coyoteTicks,
    required this.jumpBufferTicks,
    required this.dashDurationTicks,
    required this.dashCooldownTicks,
  });

  factory MovementTuningDerived.from(
    MovementTuning base, {
    required int tickHz,
  }) {
    if (tickHz <= 0) {
      throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
    }
    return MovementTuningDerived._(
      tickHz: tickHz,
      dtSeconds: 1.0 / tickHz,
      base: base,
      coyoteTicks: ticksFromSecondsCeil(base.coyoteTimeSeconds, tickHz),
      jumpBufferTicks: ticksFromSecondsCeil(base.jumpBufferSeconds, tickHz),
      dashDurationTicks: ticksFromSecondsCeil(base.dashDurationSeconds, tickHz),
      dashCooldownTicks: ticksFromSecondsCeil(base.dashCooldownSeconds, tickHz),
    );
  }

  final int tickHz;
  final double dtSeconds;
  final MovementTuning base;

  final int coyoteTicks;
  final int jumpBufferTicks;
  final int dashDurationTicks;
  final int dashCooldownTicks;
}


===== FILE: lib/core/tuning/navigation_tuning.dart =====
/// V0 navigation tuning for surface-graph based AI.
///
/// This is intentionally separate from movement/combat tunings:
/// - movement tuning controls the player's physical feel
/// - enemy tuning controls per-enemy locomotion abilities
/// - navigation tuning controls pathfinding + graph build tradeoffs
library;
import '../navigation/nav_tolerances.dart';

class NavigationTuning {
  const NavigationTuning({
    this.repathCooldownTicks = 30,
    this.maxExpandedNodes = 128,
    this.edgePenaltySeconds = 0.05,
    this.surfaceEps = navSpatialEps,
    this.takeoffEpsMin = 2.0,
    this.takeoffSampleMaxStep = 64.0,
  }) : assert(repathCooldownTicks >= 0),
       assert(maxExpandedNodes > 0),
       assert(edgePenaltySeconds >= 0.0),
       assert(surfaceEps > 0.0),
       assert(takeoffEpsMin >= 0.0),
       assert(takeoffSampleMaxStep > 0.0);

  /// Throttle replans per entity to avoid per-tick A* on mobile.
  final int repathCooldownTicks;

  /// Hard cap on A* node expansions (fail fast deterministically).
  final int maxExpandedNodes;

  /// Small per-edge penalty that biases toward fewer hops when costs tie.
  final double edgePenaltySeconds;

  /// Vertical tolerance when locating the current/target surface (world units).
  final double surfaceEps;

  /// Minimum horizontal tolerance for "close enough to takeoff" (world units).
  ///
  /// The actual takeoff epsilon can be increased by the locomotion controller
  /// (e.g. tied to an enemy's stop distance) to avoid "stops too early to jump".
  final double takeoffEpsMin;

  /// Maximum step between takeoff samples on long surfaces (world units).
  final double takeoffSampleMaxStep;
}


===== FILE: lib/core/tuning/physics_tuning.dart =====
/// V0 global physics tuning for the Core simulation.
///
/// This is intentionally separate from movement/ability/combat tunings so it can
/// evolve into per-level/biome physics profiles later (e.g. low-gravity zones).
class PhysicsTuning {
  const PhysicsTuning({
    this.gravityY = 1200,
  });

  /// Gravity acceleration (positive is downward), in world units / second^2.
  final double gravityY;
}



===== FILE: lib/core/tuning/resource_tuning.dart =====
/// Resource tuning for V0 (author in seconds, applied per fixed tick).
///
/// Values are based on the C++ reference (`tools/output/c++implementation.txt`).
class ResourceTuning {
  const ResourceTuning({
    this.playerHpMax = 100,
    this.playerHpRegenPerSecond = 0.5,
    this.playerManaMax = 100,
    this.playerManaRegenPerSecond = 2.0,
    this.playerStaminaMax = 100,
    this.playerStaminaRegenPerSecond = 1.0,
    this.jumpStaminaCost = 2,
    this.dashStaminaCost = 2,
  });

  final double playerHpMax;
  final double playerHpRegenPerSecond;

  final double playerManaMax;
  final double playerManaRegenPerSecond;

  final double playerStaminaMax;
  final double playerStaminaRegenPerSecond;

  /// Action costs (C++ reference: 2 stamina each for jump + dash).
  final double jumpStaminaCost;
  final double dashStaminaCost;
}


===== FILE: lib/core/tuning/restoration_item_tuning.dart =====
/// V0 restoration item spawning and restore configuration.
class RestorationItemTuning {
  const RestorationItemTuning({
    this.enabled = true,
    this.spawnEveryChunks = 16,
    this.spawnStartChunkIndex = 2,
    this.restorePercent = 0.30,
    this.itemSize = 12.0,
    this.surfaceClearanceY = 10.0,
    this.noSpawnMargin = 2.0,
    this.chunkEdgeMarginX = 32.0,
    this.maxAttemptsPerSpawn = 40,
    this.despawnBehindCameraMargin = 900.0,
  });

  final bool enabled;
  final int spawnEveryChunks;
  final int spawnStartChunkIndex;
  final double restorePercent;
  final double itemSize;
  final double surfaceClearanceY;
  final double noSpawnMargin;
  final double chunkEdgeMarginX;
  final int maxAttemptsPerSpawn;
  final double despawnBehindCameraMargin;
}


===== FILE: lib/core/tuning/score_tuning.dart =====
class ScoreTuning {
  const ScoreTuning({
    this.timeScorePerSecond = 5,
    this.distanceScorePerMeter = 5,
    this.groundEnemyKillScore = 100,
    this.flyingEnemyKillScore = 150,
  }) : assert(timeScorePerSecond >= 0),
       assert(distanceScorePerMeter >= 0),
       assert(groundEnemyKillScore >= 0),
       assert(flyingEnemyKillScore >= 0);

  /// Points per real-time second survived (implemented deterministically via tickHz).
  final int timeScorePerSecond;

  /// Points per whole meter traveled (100 world units = 1 meter).
  final int distanceScorePerMeter;

  /// Points for killing an enemy (by type).
  final int groundEnemyKillScore;
  final int flyingEnemyKillScore;
}


===== FILE: lib/core/tuning/spatial_grid_tuning.dart =====
/// Simulation tuning/config for grid-based spatial indexing (broadphase now,
/// navigation later).
///
/// Keep this separate from combat tuning: broadphase is a physics/simulation
/// concern, not a combat rule.
class SpatialGridTuning {
  const SpatialGridTuning({
    this.broadphaseCellSize = v0BroadphaseCellSize,
  });

  /// Default broadphase cell size for dynamic AABB queries.
  ///
  /// With current V0 collider sizes (player ~16x16, enemies ~24x24), `32.0`
  /// keeps candidate sets small while keeping grid math cheap.
  static const double v0BroadphaseCellSize = 32.0;

  final double broadphaseCellSize;
}



===== FILE: lib/core/tuning/track_tuning.dart =====
/// V0 track streaming / deterministic chunk spawning configuration.
///
/// This is simulation config (Core), not combat/ability tuning.
class TrackTuning {
  const TrackTuning({
    this.enabled = true,
    this.chunkWidth = 600.0,
    this.spawnAheadMargin = 600.0,
    this.cullBehindMargin = 600.0,
    this.gridSnap = 16.0,
  }) : assert(chunkWidth > 0),
       assert(spawnAheadMargin >= 0),
       assert(cullBehindMargin >= 0),
       assert(gridSnap > 0);

  /// If false, no chunk streaming is performed (static world only).
  final bool enabled;

  /// Width of a chunk in world units.
  final double chunkWidth;

  /// Spawn chunks while `cameraRight + spawnAheadMargin >= nextChunkStartX`.
  final double spawnAheadMargin;

  /// Cull chunks while `chunkEndX < cameraLeft - cullBehindMargin`.
  final double cullBehindMargin;

  /// Authoring grid snap for chunk patterns (world units).
  final double gridSnap;
}


===== FILE: lib/core/util/deterministic_rng.dart =====
const int _mask32 = 0xffffffff;
const int _nonZeroSeed = 0x6d2b79f5;

/// 32-bit mixing helper for deterministic seeds.
int mix32(int x) {
  var v = x & _mask32;
  v ^= (v >> 16);
  v = (v * 0x7feb352d) & _mask32;
  v ^= (v >> 15);
  v = (v * 0x846ca68b) & _mask32;
  v ^= (v >> 16);
  return v & _mask32;
}

/// Builds a non-zero 32-bit RNG state from a base seed and salt.
int seedFrom(int seed, int salt) {
  final mixed = mix32(seed ^ salt);
  return mixed == 0 ? _nonZeroSeed : mixed;
}

/// Xorshift32 step. Returns the next 32-bit state.
int nextUint32(int state) {
  var x = state & _mask32;
  if (x == 0) x = _nonZeroSeed;
  x ^= (x << 13) & _mask32;
  x ^= (x >> 17);
  x ^= (x << 5) & _mask32;
  return x & _mask32;
}

/// Converts a 32-bit state to a [0, 1] double (inclusive).
double uint32ToUnitDouble(int value) {
  return (value & _mask32) / _mask32;
}

/// Maps a 32-bit state to a [min, max] double range.
double rangeDouble(int value, double min, double max) {
  final lo = min <= max ? min : max;
  final hi = min <= max ? max : min;
  return lo + (hi - lo) * uint32ToUnitDouble(value);
}


===== FILE: lib/core/util/double_math.dart =====
import 'dart:math';

double clampDouble(double v, double lo, double hi) => max(lo, min(hi, v));



===== FILE: lib/core/util/smoothing.dart =====
import 'dart:math';

/// Returns a stable exponential smoothing factor in [0, 1] for the given
/// responsiveness `k` (per-second) and fixed tick dt.
///
/// Matches the common pattern: `alpha = 1 - exp(-k * dt)`.
double expSmoothingFactor(double k, double dtSeconds) {
  if (k <= 0) return 0.0;
  if (dtSeconds <= 0) return 0.0;
  return 1.0 - exp(-k * dtSeconds);
}



===== FILE: lib/core/util/tick_math.dart =====
import 'dart:math';

/// Converts a duration in seconds to a positive tick count for a fixed tick rate.
///
/// Rules:
/// - `seconds <= 0` => `0` ticks
/// - otherwise `max(1, ceil(seconds * tickHz))`
int ticksFromSecondsCeil(double seconds, int tickHz) {
  if (tickHz <= 0) {
    throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
  }
  if (seconds <= 0) return 0;
  return max(1, (seconds * tickHz).ceil());
}



===== FILE: lib/core/util/vec2.dart =====
/// A minimal, immutable 2D float vector.
///
/// **Design Goal**:
/// - Zero dependencies (Pure Dart).
/// - Lightweight (snapshot-friendly).
/// - Deterministic (used in Core simulation).
///
/// Generally used for passing positions and velocities across the Core -> UI boundary.
/// For heavy vector math within internal systems, raw `double` fields are preferred
/// (Structure of Arrays) to avoid allocation.
class Vec2 {
  /// Creates a new immutable vector at ([x], [y]).
  const Vec2(this.x, this.y);

  /// Zero vector (0, 0).
  static const Vec2 zero = Vec2(0, 0);

  /// X coordinate (Horizontal), usually in world units/pixels.
  final double x;

  /// Y coordinate (Vertical), usually in world units/pixels.
  final double y;

  /// Returns a new [Vec2] with [x] replaced by [value].
  Vec2 withX(double value) => Vec2(value, y);

  /// Returns a new [Vec2] with [y] replaced by [value].
  Vec2 withY(double value) => Vec2(x, value);

  /// Component-wise Addition.
  Vec2 operator +(Vec2 other) => Vec2(x + other.x, y + other.y);

  /// Component-wise Subtraction.
  Vec2 operator -(Vec2 other) => Vec2(x - other.x, y - other.y);

  /// Scalar Multiplication.
  Vec2 scale(double factor) => Vec2(x * factor, y * factor);

  @override
  String toString() => 'Vec2(${x.toStringAsFixed(2)}, ${y.toStringAsFixed(2)})';
  
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Vec2 &&
          runtimeType == other.runtimeType &&
          x == other.x &&
          y == other.y;

  @override
  int get hashCode => x.hashCode ^ y.hashCode;
}


===== FILE: lib/core/util/velocity_math.dart =====
double applyAccelDecel({
  required double current,
  required double desired,
  required double dtSeconds,
  required double accelPerSecond,
  required double decelPerSecond,
  double minStopSpeed = 0.0,
}) {
  if (dtSeconds <= 0.0) return current;
  if (desired == 0.0 && current.abs() <= minStopSpeed) return 0.0;

  final accel = desired == 0.0 ? decelPerSecond : accelPerSecond;
  final maxDelta = accel * dtSeconds;
  final delta = desired - current;
  if (delta.abs() > maxDelta) {
    return current + (delta > 0.0 ? maxDelta : -maxDelta);
  }
  return desired;
}


===== FILE: lib/game/components/aim_ray_component.dart =====
import 'package:flame/components.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/widgets.dart';

import '../../core/snapshots/entity_render_snapshot.dart';
import '../../core/snapshots/enums.dart';
import '../game_controller.dart';
import '../input/aim_preview.dart';

class AimRayComponent extends Component {
  AimRayComponent({
    required this.controller,
    required this.preview,
    required this.length,
    Paint? paint,
    this.drawWhenNoAim = true,
  }) : _paint =
           paint ??
           (Paint()
             ..color = const Color.fromARGB(255, 120, 165, 236)
             ..strokeWidth = 2
             ..strokeCap = StrokeCap.round);

  final GameController controller;
  final ValueListenable<AimPreviewState> preview;
  final double length;
  final bool drawWhenNoAim;

  final Paint _paint;

  @override
  void render(Canvas canvas) {
    final state = preview.value;
    if (!state.active) return;
    if (!state.hasAim && !drawWhenNoAim) return;

    final player = _findPlayer(controller.snapshot.entities);
    if (player == null) return;

    final (dirX, dirY) = _resolveDir(state, player);
    final startX = player.pos.x;
    final startY = player.pos.y;
    final endX = startX + dirX * length;
    final endY = startY + dirY * length;

    canvas.drawLine(Offset(startX, startY), Offset(endX, endY), _paint);
  }

  (double, double) _resolveDir(
    AimPreviewState state,
    EntityRenderSnapshot player,
  ) {
    if (state.hasAim) {
      return (state.dirX, state.dirY);
    }
    final facing = player.facing;
    return (facing == Facing.right ? 1.0 : -1.0, 0.0);
  }

  EntityRenderSnapshot? _findPlayer(List<EntityRenderSnapshot> entities) {
    for (final e in entities) {
      if (e.kind == EntityKind.player) return e;
    }
    return null;
  }
}


===== FILE: lib/game/components/pixel_parallax_backdrop_component.dart =====
import 'dart:ui' as ui;

import 'package:flame/components.dart';
import 'package:flame/game.dart';
import 'package:flutter/painting.dart';

import '../util/math_util.dart';

/// A pixel-art friendly parallax backdrop that enforces integer-pixel motion.
///
/// This component is intended to be mounted under `game.camera.backdrop`, so it
/// renders *behind* the world and is not affected by camera movement (we apply
/// parallax offsets manually based on the camera viewfinder).
///
/// Each layer:
/// - draws at 1:1 (world units == virtual pixels)
/// - uses `FilterQuality.none` (no blur)
/// - can optionally snap scroll offsets to integer pixels (reduces shimmer but
///   produces "steppy" motion on slow layers)
class PixelParallaxBackdropComponent extends Component
    with HasGameReference<FlameGame> {
  PixelParallaxBackdropComponent({
    required this.virtualWidth,
    required this.virtualHeight,
    required this.layers,
    this.snapScrollToPixels = true,
  });

  final int virtualWidth;
  final int virtualHeight;
  final List<PixelParallaxLayerSpec> layers;

  /// When true, each layer's scroll offset is snapped to integer pixels.
  ///
  /// When false, sub-pixel scrolling is allowed (smoother motion) but will
  /// introduce shimmer on pixel art. This is a deliberate tradeoff.
  final bool snapScrollToPixels;

  late final List<ui.Image> _images;
  int? _prevCameraLeftX;
  late final List<double> _scroll;

  final Paint _paint = Paint()..filterQuality = FilterQuality.none;

  @override
  Future<void> onLoad() async {
    await super.onLoad();
    _images = await Future.wait(
      layers.map((layer) => game.images.load(layer.assetPath)),
    );
    _scroll = List<double>.filled(layers.length, 0);
  }

  @override
  void update(double dt) {
    super.update(dt);

    final viewWidth = virtualWidth;
    final cameraLeftX =
        (game.camera.viewfinder.position.x - viewWidth / 2).round();

    final prev = _prevCameraLeftX;
    _prevCameraLeftX = cameraLeftX;
    if (prev == null) return;

    final delta = cameraLeftX - prev;
    if (delta == 0) return;

    for (var i = 0; i < layers.length; i++) {
      _scroll[i] += delta * layers[i].parallaxFactor;
      _scroll[i] = positiveModDouble(_scroll[i], _images[i].width.toDouble());
    }
  }

  @override
  void render(ui.Canvas canvas) {
    super.render(canvas);

    final viewWidth = virtualWidth;
    final viewHeight = virtualHeight;

    canvas.save();
    canvas.clipRect(
      ui.Rect.fromLTWH(0, 0, viewWidth.toDouble(), viewHeight.toDouble()),
    );

    for (var i = 0; i < layers.length; i++) {
      final image = _images[i];

      final imageW = image.width;
      final imageH = image.height;
      final y = (viewHeight - imageH).toDouble(); // bottom-aligned

      final scroll = snapScrollToPixels ? _scroll[i].roundToDouble() : _scroll[i];
      final offsetPx = -scroll;
      final startX = positiveModDouble(offsetPx, imageW.toDouble());

      for (var x = startX - imageW; x < viewWidth; x += imageW) {
        canvas.drawImage(image, ui.Offset(x, y), _paint);
      }
    }

    canvas.restore();
  }
}

/// One parallax layer spec.
class PixelParallaxLayerSpec {
  const PixelParallaxLayerSpec({
    required this.assetPath,
    required this.parallaxFactor,
  });

  final String assetPath;

  /// `0.0` means static background, `1.0` moves with the camera.
  ///
  /// Values are snapped to integer pixels after multiplication.
  final double parallaxFactor;
}


===== FILE: lib/game/components/tiled_ground_band_component.dart =====
import 'dart:ui' as ui;

import 'package:flame/components.dart';
import 'package:flame/game.dart';
import 'package:flutter/painting.dart';

import '../../core/snapshots/static_ground_gap_snapshot.dart';
import '../game_controller.dart';
import '../util/math_util.dart';

/// World-space ground band placeholder (visual reference for Milestone 1).
///
/// This draws `Field Layer 09.png` as a horizontally tiled strip in *world
/// coordinates* so it naturally moves 1.0× with the camera.
///
/// Collision is handled later in Core (Milestone 2). For now, this provides a
/// stable visual ground reference for camera + pixel-perfect sanity checks.
class TiledGroundBandComponent extends Component
    with HasGameReference<FlameGame> {
  TiledGroundBandComponent({
    required this.assetPath,
    required this.controller,
    this.virtualWidth,
    required this.virtualHeight,
    this.renderInBackdrop = false,
  }) {
    if (renderInBackdrop && virtualWidth == null) {
      throw ArgumentError(
        'virtualWidth is required when renderInBackdrop is true',
      );
    }
  }

  final String assetPath;
  final GameController controller;
  final int? virtualWidth;
  final int virtualHeight;
  final bool renderInBackdrop;

  late final ui.Image _image;
  final Paint _paint = Paint()..filterQuality = FilterQuality.none;
  final Paint _clearPaint = Paint()..blendMode = ui.BlendMode.clear;

  @override
  Future<void> onLoad() async {
    await super.onLoad();
    _image = await game.images.load(assetPath);
  }

  @override
  void render(ui.Canvas canvas) {
    super.render(canvas);

    if (renderInBackdrop) {
      final viewWidth = virtualWidth!;
      final gaps = controller.snapshot.groundGaps;

      final tileW = _image.width;
      final tileH = _image.height;
      final y = (virtualHeight - tileH).toDouble(); // bottom aligned

      final cameraLeftX =
          (game.camera.viewfinder.position.x - viewWidth / 2);
      final offsetPx = -cameraLeftX;
      final startX = positiveModDouble(offsetPx, tileW.toDouble());
      final clipRect =
          ui.Rect.fromLTWH(0, 0, viewWidth.toDouble(), virtualHeight.toDouble());

      if (gaps.isNotEmpty) {
        canvas.saveLayer(clipRect, Paint());
      } else {
        canvas.save();
      }
      canvas.clipRect(clipRect);

      for (var x = startX - tileW; x < viewWidth; x += tileW) {
        canvas.drawImage(_image, ui.Offset(x, y), _paint);
      }

      if (gaps.isNotEmpty) {
        _clearGapRects(
          canvas,
          gaps: gaps,
          offsetX: -cameraLeftX,
          visibleMinX: 0.0,
          visibleMaxX: viewWidth.toDouble(),
          y: y,
          height: tileH.toDouble(),
        );
      }

      canvas.restore();
      return;
    }

    final visible = game.camera.visibleWorldRect;
    final gaps = controller.snapshot.groundGaps;

    final tileW = _image.width;
    final tileH = _image.height;
    final y = (virtualHeight - tileH).toDouble(); // bottom aligned to viewport

    final left = visible.left.floor();
    final right = visible.right.ceil();

    final startTile = _floorDiv(left, tileW) - 1;
    final endTile = _floorDiv(right, tileW) + 1;

    if (gaps.isNotEmpty) {
      final clipRect = ui.Rect.fromLTRB(
        visible.left,
        0,
        visible.right,
        virtualHeight.toDouble(),
      );
      canvas.saveLayer(clipRect, Paint());
      canvas.clipRect(clipRect);
      for (var tile = startTile; tile <= endTile; tile++) {
        final x = (tile * tileW).toDouble();
        canvas.drawImage(_image, ui.Offset(x, y), _paint);
      }
      _clearGapRects(
        canvas,
        gaps: gaps,
        offsetX: 0.0,
        visibleMinX: visible.left,
        visibleMaxX: visible.right,
        y: y,
        height: tileH.toDouble(),
      );
      canvas.restore();
    } else {
      for (var tile = startTile; tile <= endTile; tile++) {
        final x = (tile * tileW).toDouble();
        canvas.drawImage(_image, ui.Offset(x, y), _paint);
      }
    }
  }

  void _clearGapRects(
    ui.Canvas canvas, {
    required List<StaticGroundGapSnapshot> gaps,
    required double offsetX,
    required double visibleMinX,
    required double visibleMaxX,
    required double y,
    required double height,
  }) {
    for (final gap in gaps) {
      final x0 = gap.minX + offsetX;
      final x1 = gap.maxX + offsetX;
      if (x1 < visibleMinX || x0 > visibleMaxX) continue;
      canvas.drawRect(ui.Rect.fromLTRB(x0, y, x1, y + height), _clearPaint);
    }
  }

  int _floorDiv(int a, int b) {
    if (b <= 0) throw ArgumentError.value(b, 'b', 'must be > 0');
    if (a >= 0) return a ~/ b;
    return -(((-a) + b - 1) ~/ b);
  }
}


===== FILE: lib/game/game_controller.dart =====
// Bridge between Core simulation and the Flutter/Flame runtime.
//
// Responsibilities:
// - Owns the `GameCore` instance
// - Queues tick-stamped input commands
// - Runs a fixed-tick simulation loop using an accumulator
// - Exposes (`prevSnapshot`, `snapshot`, `alpha`) for render interpolation
// - Buffers transient `GameEvent`s for Render/UI to consume
import 'dart:math';

import 'package:flutter/foundation.dart';

import '../core/commands/command.dart';
import '../core/events/game_event.dart';
import '../core/game_core.dart';
import '../core/snapshots/game_state_snapshot.dart';
import '../core/tuning/score_tuning.dart';
import 'tick_input_frame.dart';

/// Owns the simulation clock and provides a stable interface to UI/renderer.
class GameController extends ChangeNotifier {
  GameController({required GameCore core, this.tickHz = 60, this.inputLead = 1})
    : _core = core {
    if (tickHz <= 0) {
      throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
    }
    if (inputLead < 1) {
      throw ArgumentError.value(inputLead, 'inputLead', 'must be >= 1');
    }
    if (tickHz != _core.tickHz) {
      throw ArgumentError(
        'GameController.tickHz ($tickHz) must match GameCore.tickHz (${_core.tickHz}).',
      );
    }
    _curr = _core.buildSnapshot();
    _prev = _curr;
  }

  final GameCore _core;

  /// Fixed simulation tick frequency.
  final int tickHz;

  /// How many ticks ahead local input is scheduled by default.
  ///
  /// `1` means "next tick".
  final int inputLead;

  /// Buffered commands keyed by their target tick.
  final Map<int, TickInputFrame> _inputsByTick = <int, TickInputFrame>{};

  final List<Command> _commandScratch = <Command>[];
  final TickInputFrame _frameScratch = TickInputFrame();

  /// Buffered transient events produced by the core.
  final List<GameEvent> _events = <GameEvent>[];

  RunEndedEvent? lastRunEndedEvent;

  late GameStateSnapshot _prev;
  late GameStateSnapshot _curr;

  /// Accumulated time for fixed-tick simulation.
  double _accumulatorSeconds = 0;

  /// Current simulation tick (authoritative).
  int get tick => _core.tick;

  ScoreTuning get scoreTuning => _core.scoreTuning;

  /// Latest snapshot produced by the core.
  GameStateSnapshot get snapshot => _curr;

  /// Previous snapshot (used for render interpolation).
  GameStateSnapshot get prevSnapshot => _prev;

  /// Interpolation factor between `prevSnapshot` and `snapshot` for rendering.
  double get alpha {
    final dtTick = 1.0 / tickHz;
    return (_accumulatorSeconds / dtTick).clamp(0, 1);
  }

  /// Enqueues a command to be applied at its declared tick.
  void enqueue(Command command) {
    final frame = _inputsByTick.putIfAbsent(
      command.tick,
      () => TickInputFrame(),
    );
    frame.apply(command);
  }

  /// Helper to schedule a command for the next tick (plus `inputLead`).
  void enqueueForNextTick(Command Function(int tick) factory) {
    enqueue(factory(tick + inputLead));
  }

  /// Drains and clears all buffered transient events.
  List<GameEvent> drainEvents() {
    if (_events.isEmpty) return const <GameEvent>[];
    final drained = List<GameEvent>.unmodifiable(_events);
    _events.clear();
    return drained;
  }

  /// Pauses/unpauses the simulation.
  void setPaused(bool value) {
    if (_core.paused == value) return;
    _core.paused = value;
    _accumulatorSeconds = 0;
    _prev = _core.buildSnapshot();
    _curr = _prev;
    notifyListeners();
  }

  /// Permanently stops this controller for the current session.
  ///
  /// Use this when leaving the mini-game route (dispose), NOT for backgrounding
  /// (that's what [setPaused] is for).
  ///
  /// What it does:
  /// - pauses the core
  /// - clears queued commands (prevents "stuck input" on next mount)
  /// - clears buffered transient events
  /// - resets interpolation state (accumulator + snapshots)
  void shutdown() {
    // Pause regardless of current state (do NOT early-return like setPaused()).
    _core.paused = true;

    // Drop any in-flight fixed-tick accumulation.
    _accumulatorSeconds = 0;

    // Kill transient buffers so nothing leaks across sessions.
    _inputsByTick.clear();
    _events.clear();

    // Make snapshots consistent with the paused state.
    _curr = _core.buildSnapshot();
    _prev = _curr;
    lastRunEndedEvent = null;
    notifyListeners();
  }

  void giveUp() {
    if (_core.gameOver) return;
    _core.giveUp();
    _accumulatorSeconds = 0;

    final newEvents = _core.drainEvents();
    for (final event in newEvents) {
      if (event is RunEndedEvent) {
        lastRunEndedEvent = event;
      }
    }
    if (newEvents.isNotEmpty) {
      _events.addAll(newEvents);
    }

    _prev = _core.buildSnapshot();
    _curr = _prev;
    notifyListeners();
  }

  /// Advances the simulation clock based on a variable frame delta.
  ///
  /// This uses an accumulator to execute a fixed number of simulation ticks.
  /// `dtSeconds` is clamped to avoid "spiral of death" after app resumes.
  void advanceFrame(double dtSeconds, {double dtFrameMaxSeconds = 0.1}) {
    if (dtSeconds.isNaN || dtSeconds.isInfinite) return;
    if (_core.paused) {
      _accumulatorSeconds = 0;
      return;
    }

    final clamped = max(0.0, min(dtSeconds, dtFrameMaxSeconds));
    _accumulatorSeconds += clamped;

    final dtTick = 1.0 / tickHz;
    var didStep = false;

    while (_accumulatorSeconds >= dtTick) {
      if (_core.paused) {
        _accumulatorSeconds = 0;
        break;
      }
      final nextTick = _core.tick + 1;
      final input = _inputsByTick.remove(nextTick) ?? _frameScratch;
      _applyTickInput(nextTick, input);
      _core.stepOneTick();
      final newEvents = _core.drainEvents();
      for (final event in newEvents) {
        if (event is RunEndedEvent) {
          lastRunEndedEvent = event;
        }
      }
      _events.addAll(newEvents);

      _prev = _curr;
      _curr = _core.buildSnapshot();
      _accumulatorSeconds -= dtTick;
      didStep = true;

      // If the core became paused during the tick (e.g. game over), stop consuming
      // accumulator to avoid an infinite loop.
      if (_core.paused) {
        _accumulatorSeconds = 0;
        break;
      }
    }
    if (didStep) {
      notifyListeners();
    }
  }

  void _applyTickInput(int tick, TickInputFrame input) {
    _commandScratch.clear();

    final axis = input.moveAxis;
    if (axis != 0) {
      _commandScratch.add(MoveAxisCommand(tick: tick, axis: axis));
    }

    if (input.projectileAimDirSet) {
      _commandScratch.add(
        ProjectileAimDirCommand(tick: tick, x: input.projectileAimDirX, y: input.projectileAimDirY),
      );
    }
    if (input.meleeAimDirSet) {
      _commandScratch.add(
        MeleeAimDirCommand(
          tick: tick,
          x: input.meleeAimDirX,
          y: input.meleeAimDirY,
        ),
      );
    }
    if (input.jumpPressed) {
      _commandScratch.add(JumpPressedCommand(tick: tick));
    }
    if (input.dashPressed) {
      _commandScratch.add(DashPressedCommand(tick: tick));
    }
    if (input.attackPressed) {
      _commandScratch.add(AttackPressedCommand(tick: tick));
    }
    if (input.castPressed) {
      _commandScratch.add(CastPressedCommand(tick: tick));
    }

    _core.applyCommands(_commandScratch);

    // If this is a scratch fallback, it will be reset by the next use anyway.
    // For frames stored in the map we drop the instance after remove().
    input.reset();
  }
}


===== FILE: lib/game/input/aim_preview.dart =====
import 'package:flutter/foundation.dart';

class AimPreviewState {
  const AimPreviewState({
    required this.active,
    required this.hasAim,
    required this.dirX,
    required this.dirY,
  });

  final bool active;
  final bool hasAim;
  final double dirX;
  final double dirY;

  static const AimPreviewState inactive = AimPreviewState(
    active: false,
    hasAim: false,
    dirX: 0,
    dirY: 0,
  );
}

class AimPreviewModel extends ValueNotifier<AimPreviewState> {
  AimPreviewModel() : super(AimPreviewState.inactive);

  void begin() {
    value = const AimPreviewState(
      active: true,
      hasAim: false,
      dirX: 0,
      dirY: 0,
    );
  }

  void updateAim(double x, double y) {
    value = AimPreviewState(active: true, hasAim: true, dirX: x, dirY: y);
  }

  void clearAim() {
    value = const AimPreviewState(
      active: true,
      hasAim: false,
      dirX: 0,
      dirY: 0,
    );
  }

  void end() {
    value = AimPreviewState.inactive;
  }
}


===== FILE: lib/game/input/aim_quantizer.dart =====
class AimQuantizer {
  const AimQuantizer._();

  static const double _aimQuantizeScale = 256.0;

  static double quantize(double value) {
    if (value == 0) return 0;
    return (value * _aimQuantizeScale).roundToDouble() / _aimQuantizeScale;
  }
}


===== FILE: lib/game/input/runner_input_router.dart =====
import 'dart:math';

import '../../core/commands/command.dart';
import '../game_controller.dart';
import 'aim_quantizer.dart';

/// Shared input scheduler for multiple input sources (touch + keyboard + mouse).
///
/// - Holds the current continuous inputs (move axis, projectile aim direction).
/// - Schedules them into the GameController for upcoming ticks so Core receives
///   tick-stamped Commands.
/// - Schedules edge-triggered presses (jump/dash/attack/cast) for the next tick.
class RunnerInputRouter {
  RunnerInputRouter({required this.controller});

  final GameController controller;

  double _moveAxis = 0;
  double _lastScheduledAxis = 0;
  int _axisScheduledThroughTick = 0;

  bool _projectileAimSet = false;
  bool _projectileLastScheduledAimSet = false;
  double _projectileAimX = 0;
  double _projectileAimY = 0;
  double _projectileLastScheduledAimX = 0;
  double _projectileLastScheduledAimY = 0;
  int _projectileAimScheduledThroughTick = 0;
  int _projectileAimClearBlockedThroughTick = 0;

  bool _meleeAimSet = false;
  bool _lastScheduledMeleeAimSet = false;
  double _meleeAimX = 0;
  double _meleeAimY = 0;
  double _lastScheduledMeleeAimX = 0;
  double _lastScheduledMeleeAimY = 0;
  int _meleeAimScheduledThroughTick = 0;
  int _meleeAimClearBlockedThroughTick = 0;

  void setMoveAxis(double axis) {
    _moveAxis = axis.clamp(-1.0, 1.0);
  }

  /// Sets the projectile aim direction (should be normalized or near-normalized).
  void setProjectileAimDir(double x, double y) {
    final qx = AimQuantizer.quantize(x);
    final qy = AimQuantizer.quantize(y);

    if (_projectileAimSet && qx == _projectileAimX && qy == _projectileAimY) {
      return;
    }

    _projectileAimSet = true;
    _projectileAimX = qx;
    _projectileAimY = qy;
  }

  void clearProjectileAimDir() {
    _projectileAimSet = false;
    _projectileAimX = 0;
    _projectileAimY = 0;
  }

  /// Sets the melee aim direction (should be normalized or near-normalized).
  void setMeleeAimDir(double x, double y) {
    final qx = AimQuantizer.quantize(x);
    final qy = AimQuantizer.quantize(y);

    if (_meleeAimSet && qx == _meleeAimX && qy == _meleeAimY) {
      return;
    }

    _meleeAimSet = true;
    _meleeAimX = qx;
    _meleeAimY = qy;
  }

  void clearMeleeAimDir() {
    _meleeAimSet = false;
    _meleeAimX = 0;
    _meleeAimY = 0;
  }

  void pressJump() =>
      controller.enqueueForNextTick((tick) => JumpPressedCommand(tick: tick));

  void pressDash() =>
      controller.enqueueForNextTick((tick) => DashPressedCommand(tick: tick));

  void pressAttack() =>
      controller.enqueueForNextTick((tick) => AttackPressedCommand(tick: tick));

  void pressCast() =>
      controller.enqueueForNextTick((tick) => CastPressedCommand(tick: tick));

  /// Presses cast on the next tick and ensures the projectile aim direction is set
  /// for the same tick.
  void pressCastWithAim() {
    commitCastWithAim(clearAim: false);
  }

  /// Commits cast on the next tick using the current projectile aim dir (if set).
  ///
  /// When [clearAim] is true, clear commands are delayed until after the cast
  /// tick to avoid overwriting the aimed cast.
  void commitCastWithAim({required bool clearAim}) {
    final tick = controller.tick + controller.inputLead;
    final hadAim = _projectileAimSet;
    if (hadAim) {
      controller.enqueue(
        ProjectileAimDirCommand(
          tick: tick,
          x: _projectileAimX,
          y: _projectileAimY,
        ),
      );
    }
    controller.enqueue(CastPressedCommand(tick: tick));
    if (clearAim) {
      _projectileAimSet = false;
      _projectileAimX = 0;
      _projectileAimY = 0;
      if (hadAim) {
        _projectileAimClearBlockedThroughTick = max(
          _projectileAimClearBlockedThroughTick,
          tick,
        );
      }
    }
  }

  /// Commits a melee attack on the next tick using the current melee aim dir.
  void commitMeleeAttack() {
    final tick = controller.tick + controller.inputLead;
    final hadAim = _meleeAimSet;
    if (hadAim) {
      controller.enqueue(
        MeleeAimDirCommand(tick: tick, x: _meleeAimX, y: _meleeAimY),
      );
    } else {
      controller.enqueue(ClearMeleeAimDirCommand(tick: tick));
    }
    controller.enqueue(AttackPressedCommand(tick: tick));

    // Clear aim after commit (release behavior).
    _meleeAimSet = false;
    _meleeAimX = 0;
    _meleeAimY = 0;
    if (hadAim) {
      _meleeAimClearBlockedThroughTick = max(
        _meleeAimClearBlockedThroughTick,
        tick,
      );
    }
  }

  /// Schedules the current held inputs across upcoming ticks.
  ///
  /// Call once per frame before `controller.advanceFrame(dt)`.
  void pumpHeldInputs() {
    _scheduleHeldMoveAxis();
    _scheduleHeldProjectileAimDir();
    _scheduleHeldMeleeAimDir();
  }

  void _scheduleHeldMoveAxis() {
    final axis = _moveAxis;

    if (axis == 0 && _lastScheduledAxis == 0) {
      // No held axis and nothing to override.
      _axisScheduledThroughTick = controller.tick;
      return;
    }

    if (axis != _lastScheduledAxis) {
      // Axis changed (including to 0); reschedule to overwrite any already
      // buffered ticks.
      _axisScheduledThroughTick = controller.tick;
      _lastScheduledAxis = axis;
    }

    final maxTicksPerFrame = (controller.tickHz * 0.1).ceil();
    final targetMaxTick =
        controller.tick + controller.inputLead + maxTicksPerFrame;

    final startTick = max(controller.tick + 1, _axisScheduledThroughTick + 1);
    for (var t = startTick; t <= targetMaxTick; t += 1) {
      controller.enqueue(MoveAxisCommand(tick: t, axis: axis));
    }
    _axisScheduledThroughTick = targetMaxTick;
  }

  void _scheduleHeldProjectileAimDir() {
    if (!_projectileAimSet && !_projectileLastScheduledAimSet) {
      // No held aim and nothing to override.
      _projectileAimScheduledThroughTick = controller.tick;
      return;
    }

    if (_projectileAimSet != _projectileLastScheduledAimSet) {
      _projectileAimScheduledThroughTick = controller.tick;
      _projectileLastScheduledAimSet = _projectileAimSet;
      _projectileLastScheduledAimX = _projectileAimX;
      _projectileLastScheduledAimY = _projectileAimY;
    }

    if (_projectileAimSet &&
        (_projectileAimX != _projectileLastScheduledAimX ||
            _projectileAimY != _projectileLastScheduledAimY)) {
      // Reschedule ahead when the projectile aim vector changes.
      _projectileAimScheduledThroughTick = controller.tick;
      _projectileLastScheduledAimX = _projectileAimX;
      _projectileLastScheduledAimY = _projectileAimY;
    }

    final maxTicksPerFrame = (controller.tickHz * 0.1).ceil();
    final targetMaxTick =
        controller.tick + controller.inputLead + maxTicksPerFrame;

    var startTick = max(
      controller.tick + 1,
      _projectileAimScheduledThroughTick + 1,
    );
    if (!_projectileAimSet) {
      startTick = max(startTick, _projectileAimClearBlockedThroughTick + 1);
    }
    for (var t = startTick; t <= targetMaxTick; t += 1) {
      if (_projectileAimSet) {
        controller.enqueue(
          ProjectileAimDirCommand(
            tick: t,
            x: _projectileAimX,
            y: _projectileAimY,
          ),
        );
      } else {
        controller.enqueue(ClearProjectileAimDirCommand(tick: t));
      }
    }
    _projectileAimScheduledThroughTick = targetMaxTick;
  }

  void _scheduleHeldMeleeAimDir() {
    if (!_meleeAimSet && !_lastScheduledMeleeAimSet) {
      // No held aim and nothing to override.
      _meleeAimScheduledThroughTick = controller.tick;
      return;
    }

    if (_meleeAimSet != _lastScheduledMeleeAimSet) {
      _meleeAimScheduledThroughTick = controller.tick;
      _lastScheduledMeleeAimSet = _meleeAimSet;
      _lastScheduledMeleeAimX = _meleeAimX;
      _lastScheduledMeleeAimY = _meleeAimY;
    }

    if (_meleeAimSet &&
        (_meleeAimX != _lastScheduledMeleeAimX ||
            _meleeAimY != _lastScheduledMeleeAimY)) {
      // Reschedule ahead when the aim vector changes.
      _meleeAimScheduledThroughTick = controller.tick;
      _lastScheduledMeleeAimX = _meleeAimX;
      _lastScheduledMeleeAimY = _meleeAimY;
    }

    final maxTicksPerFrame = (controller.tickHz * 0.1).ceil();
    final targetMaxTick =
        controller.tick + controller.inputLead + maxTicksPerFrame;

    var startTick = max(controller.tick + 1, _meleeAimScheduledThroughTick + 1);
    if (!_meleeAimSet) {
      startTick = max(startTick, _meleeAimClearBlockedThroughTick + 1);
    }
    for (var t = startTick; t <= targetMaxTick; t += 1) {
      if (_meleeAimSet) {
        controller.enqueue(
          MeleeAimDirCommand(tick: t, x: _meleeAimX, y: _meleeAimY),
        );
      } else {
        controller.enqueue(ClearMeleeAimDirCommand(tick: t));
      }
    }
    _meleeAimScheduledThroughTick = targetMaxTick;
  }
}


===== FILE: lib/game/runner_flame_game.dart =====
// Flame rendering layer for the runner (Milestone 0 placeholder).
//
// Reads the latest `GameStateSnapshot` from `GameController` each frame and
// renders a minimal representation (a player dot + debug text). This file is
// intentionally tiny and non-authoritative: gameplay truth lives in Core.
import 'package:flame/components.dart';
import 'package:flame/game.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/widgets.dart';

import '../core/contracts/render_contract.dart';
import '../core/snapshots/entity_render_snapshot.dart';
import '../core/snapshots/enums.dart';
import '../core/snapshots/static_solid_snapshot.dart';
import 'input/runner_input_router.dart';
import 'input/aim_preview.dart';
import 'components/pixel_parallax_backdrop_component.dart';
import 'components/tiled_ground_band_component.dart';
import 'components/aim_ray_component.dart';
import 'game_controller.dart';

/// Minimal Flame `Game` that renders from snapshots.
class RunnerFlameGame extends FlameGame {
  RunnerFlameGame({
    required this.controller,
    required this.input,
    required this.projectileAimPreview,
    required this.meleeAimPreview,
  }) : super(
         camera: CameraComponent.withFixedResolution(
           width: virtualWidth.toDouble(),
           height: virtualHeight.toDouble(),
         ),
       );

  /// Bridge/controller that owns the simulation and produces snapshots.
  final GameController controller;

  /// Input scheduler/aggregator (touch + keyboard + mouse).
  final RunnerInputRouter input;

  /// UI-driven aim preview (render-only).
  final ValueListenable<AimPreviewState> projectileAimPreview;
  final ValueListenable<AimPreviewState> meleeAimPreview;

  late final CircleComponent _player;
  //late final TextComponent _debugText;
  final List<RectangleComponent> _staticSolids = <RectangleComponent>[];
  List<StaticSolidSnapshot>? _lastStaticSolidsSnapshot;
  final Map<int, RectangleComponent> _projectiles = <int, RectangleComponent>{};
  final Paint _projectilePaint = Paint()..color = const Color(0xFF60A5FA);
  final Map<int, RectangleComponent> _collectibles =
      <int, RectangleComponent>{};
  final Map<int, Paint> _pickupPaints = <int, Paint>{
    PickupVariant.collectible: Paint()..color = const Color(0xFFFFEB3B),
    PickupVariant.restorationHealth: Paint()..color = const Color(0xFFEF4444),
    PickupVariant.restorationMana: Paint()..color = const Color(0xFF3B82F6),
    PickupVariant.restorationStamina: Paint()..color = const Color(0xFF22C55E),
  };
  final Map<int, CircleComponent> _enemies = <int, CircleComponent>{};
  final List<Paint> _enemyPaints = <Paint>[
    Paint()..color = const Color(0xFFA855F7), // purple
    Paint()..color = const Color(0xFFF97316), // orange
  ];
  final Map<int, RectangleComponent> _hitboxes = <int, RectangleComponent>{};
  final Paint _hitboxPaint = Paint()..color = const Color(0x66EF4444);

  @override
  Future<void> onLoad() async {
    await super.onLoad();

    camera.backdrop.add(
      PixelParallaxBackdropComponent(
        virtualWidth: virtualWidth,
        virtualHeight: virtualHeight,
        snapScrollToPixels: false,
        layers: const [
          PixelParallaxLayerSpec(
            assetPath: 'parallax/field/Field Layer 01.png',
            parallaxFactor: 0.10,
          ),
          PixelParallaxLayerSpec(
            assetPath: 'parallax/field/Field Layer 02.png',
            parallaxFactor: 0.15,
          ),
          PixelParallaxLayerSpec(
            assetPath: 'parallax/field/Field Layer 03.png',
            parallaxFactor: 0.20,
          ),
          PixelParallaxLayerSpec(
            assetPath: 'parallax/field/Field Layer 04.png',
            parallaxFactor: 0.30,
          ),
          PixelParallaxLayerSpec(
            assetPath: 'parallax/field/Field Layer 05.png',
            parallaxFactor: 0.40,
          ),
          PixelParallaxLayerSpec(
            assetPath: 'parallax/field/Field Layer 06.png',
            parallaxFactor: 0.50,
          ),
          PixelParallaxLayerSpec(
            assetPath: 'parallax/field/Field Layer 07.png',
            parallaxFactor: 0.60,
          ),
          PixelParallaxLayerSpec(
            assetPath: 'parallax/field/Field Layer 08.png',
            parallaxFactor: 0.70,
          ),
        ],
      )..priority = -30,
    );

    camera.backdrop.add(
      TiledGroundBandComponent(
        assetPath: 'parallax/field/Field Layer 09.png',
        controller: controller,
        virtualWidth: virtualWidth,
        virtualHeight: virtualHeight,
        renderInBackdrop: true,
      )..priority = -20,
    );

    camera.backdrop.add(
      PixelParallaxBackdropComponent(
        virtualWidth: virtualWidth,
        virtualHeight: virtualHeight,
        snapScrollToPixels: false,
        layers: const [
          PixelParallaxLayerSpec(
            assetPath: 'parallax/field/Field Layer 10.png',
            parallaxFactor: 1.0,
          ),
        ],
      )..priority = -10,
    );

    _player = CircleComponent(
      radius: 8,
      paint: Paint()..color = const Color(0xFF4ADE80),
      anchor: Anchor.center,
    );
    world.add(_player);

    world.add(
      AimRayComponent(
        controller: controller,
        preview: projectileAimPreview,
        length: projectileAimRayLength,
        drawWhenNoAim: false,
      )..priority = 5,
    );

    world.add(
      AimRayComponent(
        controller: controller,
        preview: meleeAimPreview,
        length: meleeAimRayLength,
        drawWhenNoAim: false,
        paint: Paint()
          ..color = const Color(0xFFDC4440)
          ..strokeWidth = 2
          ..strokeCap = StrokeCap.round,
      )..priority = 6,
    );

    _mountStaticSolids(controller.snapshot.staticSolids);
    _lastStaticSolidsSnapshot = controller.snapshot.staticSolids;

    /*     _debugText = TextComponent(
      text: '',
      position: Vector2(8, 8),
      anchor: Anchor.topLeft,
      textRenderer: TextPaint(
        style: const TextStyle(
          fontSize: 14,
          color: Color.fromARGB(255, 255, 0, 0),
        ),
      ),
    );
    camera.viewport.add(_debugText); */
  }

  @override
  void update(double dt) {
    final snapshot = controller.snapshot;
    if (!snapshot.paused && !snapshot.gameOver) {
      input.pumpHeldInputs();
    }

    super.update(dt);

    // Step the deterministic core using the frame delta, then render the
    // newest snapshot.
    controller.advanceFrame(dt);
    final updatedSnapshot = controller.snapshot;
    _syncStaticSolids(updatedSnapshot.staticSolids);

    final player = _findPlayer(updatedSnapshot.entities);
    if (player != null) {
      final snappedX = player.pos.x.roundToDouble();
      final snappedY = player.pos.y.roundToDouble();
      _player.position.setValues(snappedX, snappedY);
    }
    camera.viewfinder.position = Vector2(
      updatedSnapshot.cameraCenterX.roundToDouble(),
      updatedSnapshot.cameraCenterY.roundToDouble(),
    );

    _syncEnemies(updatedSnapshot.entities);
    _syncProjectiles(updatedSnapshot.entities);
    _syncCollectibles(updatedSnapshot.entities);
    _syncHitboxes(updatedSnapshot.entities);

    /*     assert(() {
      _debugText.text =
          'tick=${snapshot.tick} seed=${snapshot.seed} x=${player?.pos.x.toStringAsFixed(1) ?? '-'} y=${player?.pos.y.toStringAsFixed(1) ?? '-'} anim=${player?.anim.name ?? '-'}';
      return true;
    }()); */
  }

  void _mountStaticSolids(List<StaticSolidSnapshot> solids) {
    if (solids.isEmpty) return;

    for (final solid in solids) {
      final color = solid.oneWayTop
          ? const Color(0x6648BB78) // green-ish translucent
          : const Color(0x668B5CF6); // purple translucent

      final rect = RectangleComponent(
        position: Vector2(solid.minX, solid.minY),
        size: Vector2(solid.maxX - solid.minX, solid.maxY - solid.minY),
        paint: Paint()..color = color,
      );
      rect.priority = -5;
      _staticSolids.add(rect);
      world.add(rect);
    }
  }

  /// Finds the player entity in the snapshot.
  EntityRenderSnapshot? _findPlayer(List<EntityRenderSnapshot> entities) {
    for (final e in entities) {
      if (e.kind == EntityKind.player) return e;
    }
    return null;
  }

  void _syncEnemies(List<EntityRenderSnapshot> entities) {
    final seen = <int>{};

    for (final e in entities) {
      if (e.kind != EntityKind.enemy) continue;
      seen.add(e.id);

      var view = _enemies[e.id];
      if (view == null) {
        final size = e.size;
        final radius =
            ((size != null) ? (size.x < size.y ? size.x : size.y) : 16.0) * 0.5;
        final paint = _enemyPaints[e.id % _enemyPaints.length];
        view = CircleComponent(
          radius: radius,
          anchor: Anchor.center,
          paint: paint,
        );
        view.priority = -2;
        _enemies[e.id] = view;
        world.add(view);
      } else {
        final size = e.size;
        if (size != null) {
          final radius = (size.x < size.y ? size.x : size.y) * 0.5;
          view.radius = radius;
        }
      }

      view.position.setValues(e.pos.x.roundToDouble(), e.pos.y.roundToDouble());
      view.angle = e.rotationRad;
    }

    if (_enemies.isEmpty) return;
    final toRemove = <int>[];
    for (final id in _enemies.keys) {
      if (!seen.contains(id)) toRemove.add(id);
    }
    for (final id in toRemove) {
      _enemies.remove(id)?.removeFromParent();
    }
  }

  void _syncProjectiles(List<EntityRenderSnapshot> entities) {
    final seen = <int>{};

    for (final e in entities) {
      if (e.kind != EntityKind.projectile) continue;
      seen.add(e.id);

      var view = _projectiles[e.id];
      if (view == null) {
        final size = e.size;
        view = RectangleComponent(
          size: Vector2(size?.x ?? 8.0, size?.y ?? 8.0),
          anchor: Anchor.center,
          paint: _projectilePaint,
        );
        view.priority = -1;
        _projectiles[e.id] = view;
        world.add(view);
      } else {
        final size = e.size;
        if (size != null) {
          view.size.setValues(size.x, size.y);
        }
      }

      view.position.setValues(e.pos.x.roundToDouble(), e.pos.y.roundToDouble());
      view.angle = e.rotationRad;
    }

    if (_projectiles.isEmpty) return;
    final toRemove = <int>[];
    for (final id in _projectiles.keys) {
      if (!seen.contains(id)) toRemove.add(id);
    }
    for (final id in toRemove) {
      _projectiles.remove(id)?.removeFromParent();
    }
  }

  void _syncCollectibles(List<EntityRenderSnapshot> entities) {
    final seen = <int>{};

    for (final e in entities) {
      if (e.kind != EntityKind.pickup) continue;
      seen.add(e.id);

      var view = _collectibles[e.id];
      final variant = e.pickupVariant ?? PickupVariant.collectible;
      final paint =
          _pickupPaints[variant] ?? _pickupPaints[PickupVariant.collectible]!;
      if (view == null) {
        final size = e.size;
        view = RectangleComponent(
          size: Vector2(size?.x ?? 8.0, size?.y ?? 8.0),
          anchor: Anchor.center,
          paint: paint,
        );
        view.priority = -1;
        _collectibles[e.id] = view;
        world.add(view);
      } else {
        final size = e.size;
        if (size != null) {
          view.size.setValues(size.x, size.y);
        }
        if (view.paint != paint) {
          view.paint = paint;
        }
      }

      view.position.setValues(e.pos.x.roundToDouble(), e.pos.y.roundToDouble());
      view.angle = e.rotationRad;
    }

    if (_collectibles.isEmpty) return;
    final toRemove = <int>[];
    for (final id in _collectibles.keys) {
      if (!seen.contains(id)) toRemove.add(id);
    }
    for (final id in toRemove) {
      _collectibles.remove(id)?.removeFromParent();
    }
  }

  void _syncHitboxes(List<EntityRenderSnapshot> entities) {
    final seen = <int>{};

    for (final e in entities) {
      if (e.kind != EntityKind.trigger) continue;
      seen.add(e.id);

      var view = _hitboxes[e.id];
      if (view == null) {
        final size = e.size;
        view = RectangleComponent(
          size: Vector2(size?.x ?? 8.0, size?.y ?? 8.0),
          anchor: Anchor.center,
          paint: _hitboxPaint,
        );
        view.priority = 1;
        _hitboxes[e.id] = view;
        world.add(view);
      } else {
        final size = e.size;
        if (size != null) {
          view.size.setValues(size.x, size.y);
        }
      }

      view.position.setValues(e.pos.x.roundToDouble(), e.pos.y.roundToDouble());
    }

    if (_hitboxes.isEmpty) return;
    final toRemove = <int>[];
    for (final id in _hitboxes.keys) {
      if (!seen.contains(id)) toRemove.add(id);
    }
    for (final id in toRemove) {
      _hitboxes.remove(id)?.removeFromParent();
    }
  }

  void _syncStaticSolids(List<StaticSolidSnapshot> solids) {
    // Core rebuilds the list only when geometry changes (spawn/cull),
    // so identity check is a cheap "version" check.
    if (identical(solids, _lastStaticSolidsSnapshot)) return;
    _lastStaticSolidsSnapshot = solids;

    for (final c in _staticSolids) {
      c.removeFromParent();
    }
    _staticSolids.clear();

    _mountStaticSolids(solids);
  }

  @override
  void onRemove() {
    images.clearCache();
    super.onRemove();
  }
}


===== FILE: lib/game/tick_input_frame.dart =====
import '../core/commands/command.dart';

/// Aggregated per-tick input for the simulation.
///
/// This replaces `List<Command>` buffering for a given tick to avoid duplicate
/// commands (e.g. multiple MoveAxis updates for the same tick).
class TickInputFrame {
  double moveAxis = 0;
  bool jumpPressed = false;
  bool dashPressed = false;
  bool attackPressed = false;
  bool projectileAimDirSet = false;
  double projectileAimDirX = 0;
  double projectileAimDirY = 0;
  bool meleeAimDirSet = false;
  double meleeAimDirX = 0;
  double meleeAimDirY = 0;
  bool castPressed = false;

  void apply(Command command) {
    switch (command) {
      case MoveAxisCommand(:final axis):
        moveAxis = axis.clamp(-1.0, 1.0);
      case JumpPressedCommand():
        jumpPressed = true;
      case DashPressedCommand():
        dashPressed = true;
      case AttackPressedCommand():
        attackPressed = true;
      case ProjectileAimDirCommand(:final x, :final y):
        projectileAimDirSet = true;
        projectileAimDirX = x;
        projectileAimDirY = y;
      case MeleeAimDirCommand(:final x, :final y):
        meleeAimDirSet = true;
        meleeAimDirX = x;
        meleeAimDirY = y;
      case ClearProjectileAimDirCommand():
        projectileAimDirSet = false;
        projectileAimDirX = 0;
        projectileAimDirY = 0;
      case ClearMeleeAimDirCommand():
        meleeAimDirSet = false;
        meleeAimDirX = 0;
        meleeAimDirY = 0;
      case CastPressedCommand():
        castPressed = true;
    }
  }

  void reset() {
    moveAxis = 0;
    jumpPressed = false;
    dashPressed = false;
    attackPressed = false;
    projectileAimDirSet = false;
    projectileAimDirX = 0;
    projectileAimDirY = 0;
    meleeAimDirSet = false;
    meleeAimDirX = 0;
    meleeAimDirY = 0;
    castPressed = false;
  }
}


===== FILE: lib/game/util/math_util.dart =====
double positiveModDouble(double value, double mod) {
  if (mod <= 0) throw ArgumentError.value(mod, 'mod', 'must be > 0');
  final r = value % mod;
  return r < 0 ? r + mod : r;
}



===== FILE: lib/main.dart =====
import 'package:flutter/material.dart';

import 'ui/dev_menu_page.dart';

/// Development-only host app for running the mini-game standalone.
///
/// The runner is intended to be embedded in another Flutter app via
/// `RunnerGameWidget` / `createRunnerGameRoute` (see `lib/runner.dart`).
/// Keep `main.dart` free of assumptions that would prevent embedding.
void main() {
  runApp(const _DevApp());
}

class _DevApp extends StatelessWidget {
  const _DevApp();

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Walkscape Runner (Dev)',
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(
          seedColor: const Color.fromARGB(255, 6, 21, 48),
        ),
        useMaterial3: true,
      ),
      home: const DevMenuPage(),
    );
  }
}


===== FILE: lib/runner.dart =====
// Public entrypoint ("barrel file") for embedding the runner in a host app.
//
// Host apps should import only this file:
// `import 'package:walkscape_runner/runner.dart';`
//
// This keeps the public API stable while allowing internal folders/files to
// evolve without breaking downstream imports.
export 'ui/runner_game_route.dart';
export 'ui/runner_game_widget.dart';


===== FILE: lib/ui/controls/action_button.dart =====
import 'package:flutter/material.dart';

import 'cooldown_ring.dart';

class ActionButton extends StatelessWidget {
  const ActionButton({
    super.key,
    required this.label,
    required this.icon,
    required this.onPressed,
    this.affordable = true,
    this.cooldownTicksLeft = 0,
    this.cooldownTicksTotal = 0,
    this.size = 72,
    this.backgroundColor = const Color(0x33000000),
    this.foregroundColor = Colors.white,
    this.labelFontSize = 12,
    this.labelGap = 2,
  });

  final String label;
  final IconData icon;
  final VoidCallback onPressed;
  final bool affordable;
  final int cooldownTicksLeft;
  final int cooldownTicksTotal;
  final double size;
  final Color backgroundColor;
  final Color foregroundColor;
  final double labelFontSize;
  final double labelGap;

  @override
  Widget build(BuildContext context) {
    final interactable = affordable && cooldownTicksLeft <= 0;
    final effectiveForeground = affordable
        ? foregroundColor
        : _disabledForeground(foregroundColor);
    final effectiveBackground = affordable
        ? backgroundColor
        : _disabledBackground(backgroundColor);

    return SizedBox(
      width: size,
      height: size,
      child: Stack(
        fit: StackFit.expand,
        children: [
          Material(
            color: effectiveBackground,
            shape: const CircleBorder(),
            child: InkWell(
              customBorder: const CircleBorder(),
              onTap: interactable ? onPressed : null,
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(icon, color: effectiveForeground),
                  SizedBox(height: labelGap),
                  Text(
                    label,
                    style: TextStyle(
                      fontSize: labelFontSize,
                      color: effectiveForeground,
                    ),
                  ),
                ],
              ),
            ),
          ),
          IgnorePointer(
            child: CooldownRing(
              cooldownTicksLeft: cooldownTicksLeft,
              cooldownTicksTotal: cooldownTicksTotal,
            ),
          ),
        ],
      ),
    );
  }

  Color _disabledForeground(Color color) => color.withValues(alpha: 0.35);

  Color _disabledBackground(Color color) =>
      color.withValues(alpha: color.a * 0.6);
}


===== FILE: lib/ui/controls/controls_tuning.dart =====
import 'dart:ui';

import 'package:flutter/foundation.dart';

enum ControlsJoystickKind { fixed, floating }

@immutable
class ControlsTuning {
  const ControlsTuning({
    this.edgePadding = 16,
    this.buttonGap = 12,
    this.rowGap = 12,
    this.joystickKind = ControlsJoystickKind.floating,
    this.fixedJoystick = const FixedJoystickTuning(),
    this.floatingJoystick = const FloatingJoystickTuning(),
    this.actionButton = const ActionButtonTuning(),
    this.directionalActionButton = const DirectionalActionButtonTuning(),
  });

  final double edgePadding;
  final double buttonGap;
  final double rowGap;

  final ControlsJoystickKind joystickKind;
  final FixedJoystickTuning fixedJoystick;
  final FloatingJoystickTuning floatingJoystick;

  final ActionButtonTuning actionButton;
  final DirectionalActionButtonTuning directionalActionButton;

  static const v0Floating = ControlsTuning();
  static const v0Fixed = ControlsTuning(
    joystickKind: ControlsJoystickKind.fixed,
  );
}

@immutable
class ActionButtonTuning {
  const ActionButtonTuning({
    this.size = 72,
    this.backgroundColor = const Color(0x33000000),
    this.foregroundColor = const Color(0xFFFFFFFF),
    this.labelFontSize = 12,
    this.labelGap = 2,
  });

  final double size;
  final Color backgroundColor;
  final Color foregroundColor;
  final double labelFontSize;
  final double labelGap;
}

@immutable
class DirectionalActionButtonTuning {
  const DirectionalActionButtonTuning({
    this.size = 72,
    this.deadzoneRadius = 12,
    this.backgroundColor = const Color(0x33000000),
    this.foregroundColor = const Color(0xFFFFFFFF),
    this.labelFontSize = 12,
    this.labelGap = 2,
  });

  final double size;
  final double deadzoneRadius;
  final Color backgroundColor;
  final Color foregroundColor;
  final double labelFontSize;
  final double labelGap;
}

@immutable
class FixedJoystickTuning {
  const FixedJoystickTuning({
    this.size = 120,
    this.knobSize = 56,
    this.baseColor = const Color(0x33000000),
    this.baseBorderColor = const Color(0x55FFFFFF),
    this.baseBorderWidth = 1,
    this.knobColor = const Color(0x66FFFFFF),
    this.knobBorderColor = const Color(0x88FFFFFF),
    this.knobBorderWidth = 1,
  });

  final double size;
  final double knobSize;
  final Color baseColor;
  final Color baseBorderColor;
  final double baseBorderWidth;
  final Color knobColor;
  final Color knobBorderColor;
  final double knobBorderWidth;
}

@immutable
class FloatingJoystickTuning {
  const FloatingJoystickTuning({
    this.areaSize = 220,
    this.baseSize = 120,
    this.knobSize = 56,
    this.followSmoothing = 0.25,
    this.baseColor = const Color(0x33000000),
    this.baseBorderColor = const Color(0x55FFFFFF),
    this.baseBorderWidth = 1,
    this.knobColor = const Color(0x66FFFFFF),
    this.knobBorderColor = const Color(0x88FFFFFF),
    this.knobBorderWidth = 1,
  });

  final double areaSize;
  final double baseSize;
  final double knobSize;
  final double followSmoothing;
  final Color baseColor;
  final Color baseBorderColor;
  final double baseBorderWidth;
  final Color knobColor;
  final Color knobBorderColor;
  final double knobBorderWidth;
}


===== FILE: lib/ui/controls/cooldown_ring.dart =====
import 'dart:math' as math;

import 'package:flutter/widgets.dart';

class CooldownRing extends StatelessWidget {
  const CooldownRing({
    super.key,
    required this.cooldownTicksLeft,
    required this.cooldownTicksTotal,
    this.thickness = 3,
    this.trackColor = const Color(0x66FFFFFF),
    this.progressColor = const Color(0xFFFFFFFF),
  });

  final int cooldownTicksLeft;
  final int cooldownTicksTotal;
  final double thickness;
  final Color trackColor;
  final Color progressColor;

  @override
  Widget build(BuildContext context) {
    if (cooldownTicksLeft <= 0 || cooldownTicksTotal <= 0) {
      return const SizedBox.shrink();
    }

    final clampedLeft = cooldownTicksLeft.clamp(0, cooldownTicksTotal);
    final elapsed = 1.0 - (clampedLeft / cooldownTicksTotal);

    return CustomPaint(
      painter: _CooldownRingPainter(
        elapsedFraction: elapsed.clamp(0.0, 1.0),
        thickness: thickness,
        trackColor: trackColor,
        progressColor: progressColor,
      ),
    );
  }
}

class _CooldownRingPainter extends CustomPainter {
  _CooldownRingPainter({
    required this.elapsedFraction,
    required this.thickness,
    required this.trackColor,
    required this.progressColor,
  });

  final double elapsedFraction;
  final double thickness;
  final Color trackColor;
  final Color progressColor;

  @override
  void paint(Canvas canvas, Size size) {
    final inset = thickness / 2;
    final rect = Rect.fromLTWH(
      inset,
      inset,
      size.width - thickness,
      size.height - thickness,
    );

    final trackPaint = Paint()
      ..color = trackColor
      ..style = PaintingStyle.stroke
      ..strokeWidth = thickness;

    final progressPaint = Paint()
      ..color = progressColor
      ..style = PaintingStyle.stroke
      ..strokeWidth = thickness
      ..strokeCap = StrokeCap.round;

    const startAngle = -math.pi / 2;
    canvas.drawArc(rect, startAngle, math.pi * 2, false, trackPaint);
    if (elapsedFraction > 0) {
      canvas.drawArc(
        rect,
        startAngle,
        math.pi * 2 * elapsedFraction,
        false,
        progressPaint,
      );
    }
  }

  @override
  bool shouldRepaint(covariant _CooldownRingPainter oldDelegate) {
    return oldDelegate.elapsedFraction != elapsedFraction ||
        oldDelegate.thickness != thickness ||
        oldDelegate.trackColor != trackColor ||
        oldDelegate.progressColor != progressColor;
  }
}


===== FILE: lib/ui/controls/directional_action_button.dart =====
import 'dart:math' as math;

import 'package:flutter/material.dart';

import '../../game/input/aim_preview.dart';
import '../../game/input/aim_quantizer.dart';
import 'cooldown_ring.dart';

class DirectionalActionButton extends StatefulWidget {
  const DirectionalActionButton({
    super.key,
    required this.label,
    required this.icon,
    required this.onAimDir,
    required this.onAimClear,
    required this.onCommit,
    required this.projectileAimPreview,
    this.affordable = true,
    this.cooldownTicksLeft = 0,
    this.cooldownTicksTotal = 0,
    this.size = 72,
    this.deadzoneRadius = 12,
    this.backgroundColor = const Color(0x33000000),
    this.foregroundColor = Colors.white,
    this.labelFontSize = 12,
    this.labelGap = 2,
  });

  final String label;
  final IconData icon;
  final void Function(double x, double y) onAimDir;
  final VoidCallback onAimClear;
  final VoidCallback onCommit;
  final AimPreviewModel projectileAimPreview;
  final bool affordable;
  final int cooldownTicksLeft;
  final int cooldownTicksTotal;
  final double size;
  final double deadzoneRadius;
  final Color backgroundColor;
  final Color foregroundColor;
  final double labelFontSize;
  final double labelGap;

  @override
  State<DirectionalActionButton> createState() =>
      _DirectionalActionButtonState();
}

class _DirectionalActionButtonState extends State<DirectionalActionButton> {
  int? _pointer;
  bool _leftButtonOnce = false;
  bool _canceled = false;

  @override
  Widget build(BuildContext context) {
    final interactable = widget.affordable && widget.cooldownTicksLeft <= 0;
    final effectiveForeground = widget.affordable
        ? widget.foregroundColor
        : _disabledForeground(widget.foregroundColor);
    final effectiveBackground = widget.affordable
        ? widget.backgroundColor
        : _disabledBackground(widget.backgroundColor);

    return SizedBox(
      width: widget.size,
      height: widget.size,
      child: Stack(
        fit: StackFit.expand,
        children: [
          IgnorePointer(
            ignoring: !interactable,
            child: Listener(
              onPointerDown: _handlePointerDown,
              onPointerMove: _handlePointerMove,
              onPointerUp: _handlePointerUp,
              onPointerCancel: _handlePointerCancel,
              child: Material(
                color: effectiveBackground,
                shape: const CircleBorder(),
                child: Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Icon(widget.icon, color: effectiveForeground),
                      SizedBox(height: widget.labelGap),
                      Text(
                        widget.label,
                        style: TextStyle(
                          fontSize: widget.labelFontSize,
                          color: effectiveForeground,
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            ),
          ),
          IgnorePointer(
            child: CooldownRing(
              cooldownTicksLeft: widget.cooldownTicksLeft,
              cooldownTicksTotal: widget.cooldownTicksTotal,
            ),
          ),
        ],
      ),
    );
  }

  void _handlePointerDown(PointerDownEvent event) {
    if (_pointer != null) return;
    _pointer = event.pointer;
    _leftButtonOnce = false;
    _canceled = false;
    widget.projectileAimPreview.begin();
    widget.onAimClear();
    _updateAim(event.localPosition);
  }

  void _handlePointerMove(PointerMoveEvent event) {
    if (event.pointer != _pointer) return;
    final inside = _isInside(event.localPosition);
    if (!inside && !_leftButtonOnce) {
      _leftButtonOnce = true;
    }
    if (inside && _leftButtonOnce) {
      _cancelAim();
      return;
    }
    _updateAim(event.localPosition);
  }

  void _handlePointerUp(PointerUpEvent event) {
    if (event.pointer != _pointer) return;
    if (!_canceled) {
      widget.onCommit();
    }
    _resetAim();
  }

  void _handlePointerCancel(PointerCancelEvent event) {
    if (event.pointer != _pointer) return;
    _resetAim();
  }

  void _updateAim(Offset localPosition) {
    if (_canceled) return;
    final center = Offset(widget.size / 2, widget.size / 2);
    final dx = localPosition.dx - center.dx;
    final dy = localPosition.dy - center.dy;
    final len = math.sqrt(dx * dx + dy * dy);
    if (len <= widget.deadzoneRadius) {
      widget.onAimClear();
      widget.projectileAimPreview.clearAim();
      return;
    }
    final nx = dx / len;
    final ny = dy / len;
    final qx = AimQuantizer.quantize(nx);
    final qy = AimQuantizer.quantize(ny);
    widget.onAimDir(qx, qy);
    widget.projectileAimPreview.updateAim(qx, qy);
  }

  void _cancelAim() {
    if (_canceled) return;
    _canceled = true;
    widget.onAimClear();
    widget.projectileAimPreview.end();
  }

  void _resetAim() {
    _pointer = null;
    _leftButtonOnce = false;
    _canceled = false;
    widget.onAimClear();
    widget.projectileAimPreview.end();
  }

  bool _isInside(Offset local) {
    final center = Offset(widget.size / 2, widget.size / 2);
    final dx = local.dx - center.dx;
    final dy = local.dy - center.dy;
    final radius = widget.size / 2;
    return (dx * dx + dy * dy) <= radius * radius;
  }

  Color _disabledForeground(Color color) => color.withValues(alpha: 0.35);

  Color _disabledBackground(Color color) =>
      color.withValues(alpha: color.a * 0.6);
}


===== FILE: lib/ui/controls/fixed_joystick.dart =====
import 'package:flutter/widgets.dart';

/// Fixed-position horizontal joystick (V0).
///
/// - Only outputs an X axis in `[-1, 1]`.
/// - Centered at the widget's bounds; drag left/right to set axis.
class FixedJoystick extends StatefulWidget {
  const FixedJoystick({
    super.key,
    required this.onAxisChanged,
    this.size = 120,
    this.knobSize = 56,
    this.baseColor = const Color(0x33000000),
    this.baseBorderColor = const Color(0x55FFFFFF),
    this.baseBorderWidth = 1,
    this.knobColor = const Color(0x66FFFFFF),
    this.knobBorderColor = const Color(0x88FFFFFF),
    this.knobBorderWidth = 1,
  });

  final ValueChanged<double> onAxisChanged;
  final double size;
  final double knobSize;
  final Color baseColor;
  final Color baseBorderColor;
  final double baseBorderWidth;
  final Color knobColor;
  final Color knobBorderColor;
  final double knobBorderWidth;

  @override
  State<FixedJoystick> createState() => _FixedJoystickState();
}

class _FixedJoystickState extends State<FixedJoystick> {
  double _axis = 0;

  @override
  Widget build(BuildContext context) {
    final baseSize = widget.size;
    final knobSize = widget.knobSize;
    final radius = (baseSize - knobSize) / 2;

    return SizedBox(
      width: baseSize,
      height: baseSize,
      child: GestureDetector(
        onPanStart: (d) => _update(d.localPosition, radius),
        onPanUpdate: (d) => _update(d.localPosition, radius),
        onPanEnd: (_) => _setAxis(0),
        onPanCancel: () => _setAxis(0),
        child: Stack(
          children: [
            Positioned.fill(
              child: Center(
                child: Container(
                  width: baseSize,
                  height: baseSize,
                  decoration: BoxDecoration(
                    color: widget.baseColor,
                    shape: BoxShape.circle,
                    border: Border.all(
                      color: widget.baseBorderColor,
                      width: widget.baseBorderWidth,
                    ),
                  ),
                ),
              ),
            ),
            Positioned.fill(
              child: Center(
                child: Transform.translate(
                  offset: Offset(_axis * radius, 0),
                  child: Container(
                    width: knobSize,
                    height: knobSize,
                    decoration: BoxDecoration(
                      color: widget.knobColor,
                      shape: BoxShape.circle,
                      border: Border.all(
                        color: widget.knobBorderColor,
                        width: widget.knobBorderWidth,
                      ),
                    ),
                  ),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  void _update(Offset local, double radius) {
    final center = Offset(widget.size / 2, widget.size / 2);
    final dx = local.dx - center.dx;
    final clamped = dx.clamp(-radius, radius);
    final axis = radius <= 0 ? 0.0 : clamped / radius;
    _setAxis(axis);
  }

  void _setAxis(double axis) {
    final a = axis.clamp(-1.0, 1.0);
    if (a == _axis) return;
    setState(() => _axis = a);
    widget.onAxisChanged(a);
  }
}


===== FILE: lib/ui/controls/floating_joystick.dart =====
import 'package:flutter/widgets.dart';

/// Floating horizontal joystick (V0).
///
/// - Touch anywhere inside the widget bounds to place the base.
/// - Drag left/right to set axis in `[-1, 1]`.
/// - Soft-follow: when dragged past the knob radius, the base eases toward the
///   pointer so the gesture stays comfortable.
/// - Release to snap back to center and hide.
class FloatingJoystick extends StatefulWidget {
  const FloatingJoystick({
    super.key,
    required this.onAxisChanged,
    this.areaSize = 220,
    this.baseSize = 120,
    this.knobSize = 56,
    this.followSmoothing = 0.25,
    this.baseColor = const Color(0x33000000),
    this.baseBorderColor = const Color(0x55FFFFFF),
    this.baseBorderWidth = 1,
    this.knobColor = const Color(0x66FFFFFF),
    this.knobBorderColor = const Color(0x88FFFFFF),
    this.knobBorderWidth = 1,
  });

  final ValueChanged<double> onAxisChanged;

  /// Size of the touch area (square).
  final double areaSize;

  /// Visual size of the joystick base circle.
  final double baseSize;

  /// Visual size of the joystick knob circle.
  final double knobSize;

  /// How strongly the base follows the pointer when stretched past the knob
  /// radius.
  ///
  /// - `0`: no follow (base stays where pressed).
  /// - `1`: hard follow (base snaps to keep the pointer on the edge).
  final double followSmoothing;
  final Color baseColor;
  final Color baseBorderColor;
  final double baseBorderWidth;
  final Color knobColor;
  final Color knobBorderColor;
  final double knobBorderWidth;

  @override
  State<FloatingJoystick> createState() => _FloatingJoystickState();
}

class _FloatingJoystickState extends State<FloatingJoystick> {
  int? _activePointer;
  Offset? _baseCenter;
  double _axis = 0;

  @override
  Widget build(BuildContext context) {
    final areaSize = widget.areaSize;
    final baseSize = widget.baseSize;
    final knobSize = widget.knobSize;
    final radius = (baseSize - knobSize) / 2;

    return SizedBox(
      width: areaSize,
      height: areaSize,
      child: Listener(
        behavior: HitTestBehavior.opaque,
        onPointerDown: (e) => _onPointerDown(e, radius),
        onPointerMove: (e) => _onPointerMove(e, radius),
        onPointerUp: _onPointerUp,
        onPointerCancel: _onPointerCancel,
        child: Stack(
          children: [
            if (_baseCenter case final baseCenter?) ...[
              _JoystickBase(
                center: baseCenter,
                size: baseSize,
                color: widget.baseColor,
                borderColor: widget.baseBorderColor,
                borderWidth: widget.baseBorderWidth,
              ),
              _JoystickKnob(
                center: baseCenter.translate(_axis * radius, 0),
                size: knobSize,
                color: widget.knobColor,
                borderColor: widget.knobBorderColor,
                borderWidth: widget.knobBorderWidth,
              ),
            ],
          ],
        ),
      ),
    );
  }

  void _onPointerDown(PointerDownEvent event, double radius) {
    if (_activePointer != null) return;
    final center = _clampBaseCenter(event.localPosition);
    setState(() {
      _activePointer = event.pointer;
      _baseCenter = center;
      _axis = 0;
    });
    widget.onAxisChanged(0);
  }

  void _onPointerMove(PointerMoveEvent event, double radius) {
    if (event.pointer != _activePointer) return;
    final baseCenter = _baseCenter;
    if (baseCenter == null) return;

    final pointer = event.localPosition;

    var nextBaseCenter = baseCenter;
    if (radius > 0) {
      final delta = pointer - baseCenter;
      final dist = delta.distance;
      if (dist > radius && dist > 0) {
        final targetBaseCenter = pointer - (delta / dist) * radius;
        final t = widget.followSmoothing.clamp(0.0, 1.0).toDouble();
        nextBaseCenter =
            Offset.lerp(baseCenter, targetBaseCenter, t) ?? baseCenter;
        nextBaseCenter = _clampBaseCenter(nextBaseCenter);
      }
    }

    final dx = pointer.dx - nextBaseCenter.dx;
    final clamped = dx.clamp(-radius, radius);
    final axis = radius <= 0 ? 0.0 : clamped / radius;
    _setBaseAndAxis(baseCenter: nextBaseCenter, axis: axis);
  }

  void _onPointerUp(PointerUpEvent event) {
    if (event.pointer != _activePointer) return;
    _reset();
  }

  void _onPointerCancel(PointerCancelEvent event) {
    if (event.pointer != _activePointer) return;
    _reset();
  }

  Offset _clampBaseCenter(Offset local) {
    final areaSize = widget.areaSize;
    final baseSize = widget.baseSize;
    final halfBase = baseSize / 2;

    if (areaSize <= baseSize) {
      return Offset(areaSize / 2, areaSize / 2);
    }

    final clampedX = local.dx.clamp(halfBase, areaSize - halfBase).toDouble();
    final clampedY = local.dy.clamp(halfBase, areaSize - halfBase).toDouble();
    return Offset(clampedX, clampedY);
  }

  void _reset() {
    final shouldNotify = _axis != 0;
    setState(() {
      _activePointer = null;
      _baseCenter = null;
      _axis = 0;
    });
    if (shouldNotify) widget.onAxisChanged(0);
  }

  void _setBaseAndAxis({required Offset baseCenter, required double axis}) {
    final nextAxis = axis.clamp(-1.0, 1.0);
    final axisChanged = nextAxis != _axis;
    final baseChanged = baseCenter != _baseCenter;
    if (!axisChanged && !baseChanged) return;

    setState(() {
      _baseCenter = baseCenter;
      _axis = nextAxis;
    });
    if (axisChanged) widget.onAxisChanged(nextAxis);
  }
}

class _JoystickBase extends StatelessWidget {
  const _JoystickBase({
    required this.center,
    required this.size,
    required this.color,
    required this.borderColor,
    required this.borderWidth,
  });

  final Offset center;
  final double size;
  final Color color;
  final Color borderColor;
  final double borderWidth;

  @override
  Widget build(BuildContext context) {
    return Positioned(
      left: center.dx - size / 2,
      top: center.dy - size / 2,
      width: size,
      height: size,
      child: Container(
        decoration: BoxDecoration(
          color: color,
          shape: BoxShape.circle,
          border: Border.all(color: borderColor, width: borderWidth),
        ),
      ),
    );
  }
}

class _JoystickKnob extends StatelessWidget {
  const _JoystickKnob({
    required this.center,
    required this.size,
    required this.color,
    required this.borderColor,
    required this.borderWidth,
  });

  final Offset center;
  final double size;
  final Color color;
  final Color borderColor;
  final double borderWidth;

  @override
  Widget build(BuildContext context) {
    return Positioned(
      left: center.dx - size / 2,
      top: center.dy - size / 2,
      width: size,
      height: size,
      child: Container(
        decoration: BoxDecoration(
          color: color,
          shape: BoxShape.circle,
          border: Border.all(color: borderColor, width: borderWidth),
        ),
      ),
    );
  }
}


===== FILE: lib/ui/controls/runner_controls_overlay.dart =====
import 'package:flutter/material.dart';

import '../../game/input/aim_preview.dart';
import 'action_button.dart';
import 'controls_tuning.dart';
import 'directional_action_button.dart';
import 'fixed_joystick.dart';
import 'floating_joystick.dart';

class RunnerControlsOverlay extends StatelessWidget {
  const RunnerControlsOverlay({
    super.key,
    required this.onMoveAxis,
    required this.onJumpPressed,
    required this.onDashPressed,
    required this.onCastCommitted,
    required this.onProjectileAimDir,
    required this.onProjectileAimClear,
    required this.projectileAimPreview,
    required this.projectileAffordable,
    required this.projectileCooldownTicksLeft,
    required this.projectileCooldownTicksTotal,
    required this.onMeleeAimDir,
    required this.onMeleeAimClear,
    required this.onMeleeCommitted,
    required this.meleeAimPreview,
    required this.meleeAffordable,
    required this.meleeCooldownTicksLeft,
    required this.meleeCooldownTicksTotal,
    required this.jumpAffordable,
    required this.dashAffordable,
    required this.dashCooldownTicksLeft,
    required this.dashCooldownTicksTotal,
    this.tuning = ControlsTuning.v0Fixed,
  });

  final ValueChanged<double> onMoveAxis;
  final VoidCallback onJumpPressed;
  final VoidCallback onDashPressed;
  final VoidCallback onCastCommitted;
  final void Function(double x, double y) onProjectileAimDir;
  final VoidCallback onProjectileAimClear;
  final AimPreviewModel projectileAimPreview;
  final bool projectileAffordable;
  final int projectileCooldownTicksLeft;
  final int projectileCooldownTicksTotal;
  final void Function(double x, double y) onMeleeAimDir;
  final VoidCallback onMeleeAimClear;
  final VoidCallback onMeleeCommitted;
  final AimPreviewModel meleeAimPreview;
  final bool meleeAffordable;
  final int meleeCooldownTicksLeft;
  final int meleeCooldownTicksTotal;
  final bool jumpAffordable;
  final bool dashAffordable;
  final int dashCooldownTicksLeft;
  final int dashCooldownTicksTotal;
  final ControlsTuning tuning;

  @override
  Widget build(BuildContext context) {
    final t = tuning;
    final action = t.actionButton;
    final directional = t.directionalActionButton;

    return Stack(
      children: [
        Positioned(
          left: t.edgePadding,
          bottom: t.edgePadding,
          child: t.joystickKind == ControlsJoystickKind.floating
              ? FloatingJoystick(
                  onAxisChanged: onMoveAxis,
                  areaSize: t.floatingJoystick.areaSize,
                  baseSize: t.floatingJoystick.baseSize,
                  knobSize: t.floatingJoystick.knobSize,
                  followSmoothing: t.floatingJoystick.followSmoothing,
                  baseColor: t.floatingJoystick.baseColor,
                  baseBorderColor: t.floatingJoystick.baseBorderColor,
                  baseBorderWidth: t.floatingJoystick.baseBorderWidth,
                  knobColor: t.floatingJoystick.knobColor,
                  knobBorderColor: t.floatingJoystick.knobBorderColor,
                  knobBorderWidth: t.floatingJoystick.knobBorderWidth,
                )
              : FixedJoystick(
                  onAxisChanged: onMoveAxis,
                  size: t.fixedJoystick.size,
                  knobSize: t.fixedJoystick.knobSize,
                  baseColor: t.fixedJoystick.baseColor,
                  baseBorderColor: t.fixedJoystick.baseBorderColor,
                  baseBorderWidth: t.fixedJoystick.baseBorderWidth,
                  knobColor: t.fixedJoystick.knobColor,
                  knobBorderColor: t.fixedJoystick.knobBorderColor,
                  knobBorderWidth: t.fixedJoystick.knobBorderWidth,
                ),
        ),
        Positioned(
          right: t.edgePadding,
          bottom: t.edgePadding,
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  DirectionalActionButton(
                    label: 'Spell',
                    icon: Icons.auto_awesome,
                    onAimDir: onProjectileAimDir,
                    onAimClear: onProjectileAimClear,
                    onCommit: onCastCommitted,
                    projectileAimPreview: projectileAimPreview,
                    affordable: projectileAffordable,
                    cooldownTicksLeft: projectileCooldownTicksLeft,
                    cooldownTicksTotal: projectileCooldownTicksTotal,
                    size: directional.size,
                    deadzoneRadius: directional.deadzoneRadius,
                    backgroundColor: directional.backgroundColor,
                    foregroundColor: directional.foregroundColor,
                    labelFontSize: directional.labelFontSize,
                    labelGap: directional.labelGap,
                  ),
                  SizedBox(width: t.buttonGap),
                  ActionButton(
                    label: 'Jump',
                    icon: Icons.arrow_upward,
                    onPressed: onJumpPressed,
                    affordable: jumpAffordable,
                    size: action.size,
                    backgroundColor: action.backgroundColor,
                    foregroundColor: action.foregroundColor,
                    labelFontSize: action.labelFontSize,
                    labelGap: action.labelGap,
                  ),
                ],
              ),
              SizedBox(height: t.rowGap),
              Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  DirectionalActionButton(
                    label: 'Atk',
                    icon: Icons.close,
                    onAimDir: onMeleeAimDir,
                    onAimClear: onMeleeAimClear,
                    onCommit: onMeleeCommitted,
                    projectileAimPreview: meleeAimPreview,
                    affordable: meleeAffordable,
                    cooldownTicksLeft: meleeCooldownTicksLeft,
                    cooldownTicksTotal: meleeCooldownTicksTotal,
                    size: directional.size,
                    deadzoneRadius: directional.deadzoneRadius,
                    backgroundColor: directional.backgroundColor,
                    foregroundColor: directional.foregroundColor,
                    labelFontSize: directional.labelFontSize,
                    labelGap: directional.labelGap,
                  ),
                  SizedBox(width: t.buttonGap),
                  ActionButton(
                    label: 'Dash',
                    icon: Icons.flash_on,
                    onPressed: onDashPressed,
                    affordable: dashAffordable,
                    cooldownTicksLeft: dashCooldownTicksLeft,
                    cooldownTicksTotal: dashCooldownTicksTotal,
                    size: action.size,
                    backgroundColor: action.backgroundColor,
                    foregroundColor: action.foregroundColor,
                    labelFontSize: action.labelFontSize,
                    labelGap: action.labelGap,
                  ),
                ],
              ),
            ],
          ),
        ),
      ],
    );
  }
}


===== FILE: lib/ui/dev_menu_page.dart =====
import 'dart:math';

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import 'runner_game_route.dart';

/// Development-only menu used by the standalone host app (`lib/main.dart`).
///
/// Not part of the embeddable runner API. Host apps should integrate the game
/// via `RunnerGameWidget` / `createRunnerGameRoute` (see `lib/runner.dart`).
class DevMenuPage extends StatelessWidget {
  const DevMenuPage({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text(
          'Walkscape Runner (Dev)',
          style: TextStyle(color: Colors.white),
        ),
        backgroundColor: Color.fromARGB(255, 6, 21, 48),
      ),
      body: Center(
        child: FilledButton(
          onPressed: () {
            final seed = Random().nextInt(1 << 31);
            Navigator.of(context).push(
              createRunnerGameRoute(
                seed: seed,
                restoreOrientations: const [DeviceOrientation.portraitUp],
              ),
            );
          },
          child: const Text('Start'),
        ),
      ),
    );
  }
}


===== FILE: lib/ui/hud/game/exit_button_overlay.dart =====
import 'package:flutter/material.dart';

class ExitButtonOverlay extends StatelessWidget {
  const ExitButtonOverlay({
    super.key,
    required this.onPressed,
    required this.highlight,
  });

  final VoidCallback? onPressed;
  final bool highlight;

  @override
  Widget build(BuildContext context) {
    return Align(
      alignment: Alignment.topRight,
      child: Padding(
        padding: const EdgeInsets.all(8),
        child: IconButton(
          onPressed: onPressed,
          icon: const Icon(Icons.close),
          color: highlight ? Colors.white : null,
        ),
      ),
    );
  }
}


===== FILE: lib/ui/hud/game/game_overlay.dart =====
import 'package:flutter/widgets.dart';

import '../../../game/game_controller.dart';
import '../../../game/input/aim_preview.dart';
import '../../../game/input/runner_input_router.dart';
import '../../controls/runner_controls_overlay.dart';
import '../../runner_game_ui_state.dart';
import 'pause_overlay.dart';
import 'ready_overlay.dart';
import 'top_center_hud_overlay.dart';
import 'top_left_hud_overlay.dart';
import 'top_right_hud_overlay.dart';

class GameOverlay extends StatelessWidget {
  const GameOverlay({
    super.key,
    required this.controller,
    required this.input,
    required this.projectileAimPreview,
    required this.meleeAimPreview,
    required this.uiState,
    required this.onStart,
    required this.onTogglePause,
    required this.showExitButton,
    required this.onExit,
  });

  final GameController controller;
  final RunnerInputRouter input;
  final AimPreviewModel projectileAimPreview;
  final AimPreviewModel meleeAimPreview;
  final RunnerGameUiState uiState;
  final VoidCallback onStart;
  final VoidCallback onTogglePause;
  final bool showExitButton;
  final VoidCallback? onExit;

  @override
  Widget build(BuildContext context) {
    final hud = controller.snapshot.hud;

    return Stack(
      fit: StackFit.expand,
      children: [
        IgnorePointer(
          ignoring: !uiState.isRunning,
          child: RunnerControlsOverlay(
            onMoveAxis: input.setMoveAxis,
            onJumpPressed: input.pressJump,
            onDashPressed: input.pressDash,
            onCastCommitted: () => input.commitCastWithAim(clearAim: true),
            onProjectileAimDir: input.setProjectileAimDir,
            onProjectileAimClear: input.clearProjectileAimDir,
            projectileAimPreview: projectileAimPreview,
            projectileAffordable: hud.canAffordProjectile,
            projectileCooldownTicksLeft: hud.projectileCooldownTicksLeft,
            projectileCooldownTicksTotal: hud.projectileCooldownTicksTotal,
            onMeleeAimDir: input.setMeleeAimDir,
            onMeleeAimClear: input.clearMeleeAimDir,
            onMeleeCommitted: input.commitMeleeAttack,
            meleeAimPreview: meleeAimPreview,
            meleeAffordable: hud.canAffordMelee,
            meleeCooldownTicksLeft: hud.meleeCooldownTicksLeft,
            meleeCooldownTicksTotal: hud.meleeCooldownTicksTotal,
            jumpAffordable: hud.canAffordJump,
            dashAffordable: hud.canAffordDash,
            dashCooldownTicksLeft: hud.dashCooldownTicksLeft,
            dashCooldownTicksTotal: hud.dashCooldownTicksTotal,
          ),
        ),
        PauseOverlay(visible: uiState.showPauseOverlay),
        ReadyOverlay(visible: uiState.showReadyOverlay, onTap: onStart),
        Align(
          alignment: Alignment.topLeft,
          child: Padding(
            padding: const EdgeInsets.all(12),
            child: TopLeftHudOverlay(controller: controller),
          ),
        ),
        TopCenterHudOverlay(
          controller: controller,
          uiState: uiState,
          onStart: onStart,
          onTogglePause: onTogglePause,
        ),
        TopRightHudOverlay(
          controller: controller,
          showExitButton: showExitButton,
          onExit: onExit,
        ),
      ],
    );
  }
}


===== FILE: lib/ui/hud/game/pause_overlay.dart =====
import 'package:flutter/widgets.dart';

class PauseOverlay extends StatelessWidget {
  const PauseOverlay({super.key, required this.visible});

  final bool visible;

  @override
  Widget build(BuildContext context) {
    if (!visible) return const SizedBox.shrink();

    return const IgnorePointer(child: ColoredBox(color: Color(0x66000000)));
  }
}


===== FILE: lib/ui/hud/game/ready_overlay.dart =====
import 'package:flutter/widgets.dart';

class ReadyOverlay extends StatelessWidget {
  const ReadyOverlay({super.key, required this.visible, required this.onTap});

  final bool visible;
  final VoidCallback onTap;

  @override
  Widget build(BuildContext context) {
    if (!visible) return const SizedBox.shrink();

    return GestureDetector(
      behavior: HitTestBehavior.opaque,
      onTap: onTap,
      child: const ColoredBox(
        color: Color(0x88000000),
        child: Center(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Text(
                'Tap to start',
                style: TextStyle(
                  color: Color(0xFFFFFFFF),
                  fontSize: 28,
                  fontWeight: FontWeight.w600,
                ),
              ),
              SizedBox(height: 8),
              Text(
                'Survive as long as possible',
                style: TextStyle(color: Color(0xB3FFFFFF), fontSize: 14),
              ),
            ],
          ),
        ),
      ),
    );
  }
}


===== FILE: lib/ui/hud/game/score_overlay.dart =====
import 'dart:ui' show Color, FontFeature;

import 'package:flutter/widgets.dart';

import '../../../game/game_controller.dart';

class ScoreOverlay extends StatelessWidget {
  const ScoreOverlay({
    super.key,
    required this.controller,
    this.padding = const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
  });

  final GameController controller;
  final EdgeInsets padding;

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: controller,
      builder: (context, _) {
        final distanceMeters =
            (controller.snapshot.distance / 100.0).floor();
        final collectibles = controller.snapshot.hud.collectibles;
        return IgnorePointer(
          child: RepaintBoundary(
            child: Container(
              padding: padding,
              decoration: BoxDecoration(
                color: const Color(0x66000000),
                borderRadius: BorderRadius.circular(10),
              ),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Text(
                    'Distance ${distanceMeters}m',
                    textAlign: TextAlign.center,
                    style: const TextStyle(
                      fontSize: 14,
                      color: Color(0xFFFFFFFF),
                      fontFeatures: [FontFeature.tabularFigures()],
                    ),
                  ),
                  const SizedBox(height: 2),
                  Text(
                    'Collectibles $collectibles',
                    textAlign: TextAlign.center,
                    style: const TextStyle(
                      fontSize: 14,
                      color: Color(0xFFFFFFFF),
                      fontFeatures: [FontFeature.tabularFigures()],
                    ),
                  ),
                ],
              ),
            ),
          ),
        );
      },
    );
  }
}


===== FILE: lib/ui/hud/game/start_pause_button_overlay.dart =====
import 'package:flutter/material.dart';

import '../../runner_game_ui_state.dart';

class StartPauseButtonOverlay extends StatelessWidget {
  const StartPauseButtonOverlay({
    super.key,
    required this.uiState,
    required this.onStart,
    required this.onTogglePause,
  });

  final RunnerGameUiState uiState;
  final VoidCallback onStart;
  final VoidCallback onTogglePause;

  @override
  Widget build(BuildContext context) {
    return IconButton(
      onPressed: uiState.gameOver
          ? null
          : () {
              if (!uiState.started) {
                onStart();
                return;
              }
              onTogglePause();
            },
      icon: Icon(uiState.paused ? Icons.play_arrow : Icons.pause),
      color: Colors.white,
      tooltip: uiState.paused ? 'Play' : 'Pause',
    );
  }
}


===== FILE: lib/ui/hud/game/survival_timer_overlay.dart =====
import 'package:flutter/widgets.dart';

import '../../../game/game_controller.dart';

class SurvivalTimerOverlay extends StatelessWidget {
  const SurvivalTimerOverlay({
    super.key,
    required this.controller,
    this.padding = const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
  });

  final GameController controller;
  final EdgeInsets padding;

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: controller,
      builder: (context, _) {
        final ticks = controller.snapshot.tick;
        final hz = controller.tickHz;

        final totalSeconds = ticks ~/ hz;
        final minutes = totalSeconds ~/ 60;
        final seconds = totalSeconds % 60;

        final text =
            '${minutes.toString().padLeft(2, '0')}:${seconds.toString().padLeft(2, '0')}';

        return IgnorePointer(
          child: RepaintBoundary(
            child: Container(
              padding: padding,
              decoration: BoxDecoration(
                color: const Color(0x66000000),
                borderRadius: BorderRadius.circular(10),
              ),
              child: Text(
                text,
                textAlign: TextAlign.center,
                style: const TextStyle(
                  fontSize: 18,
                  color: Color(0xFFFFFFFF),
                  fontFeatures: [FontFeature.tabularFigures()],
                ),
              ),
            ),
          ),
        );
      },
    );
  }
}


===== FILE: lib/ui/hud/game/top_center_hud_overlay.dart =====
import 'package:flutter/material.dart';

import '../../../game/game_controller.dart';
import 'survival_timer_overlay.dart';
import '../../runner_game_ui_state.dart';
import 'start_pause_button_overlay.dart';

class TopCenterHudOverlay extends StatelessWidget {
  const TopCenterHudOverlay({
    super.key,
    required this.controller,
    required this.uiState,
    required this.onStart,
    required this.onTogglePause,
  });

  final GameController controller;
  final RunnerGameUiState uiState;
  final VoidCallback onStart;
  final VoidCallback onTogglePause;

  @override
  Widget build(BuildContext context) {
    return Align(
      alignment: Alignment.topCenter,
      child: Padding(
        padding: const EdgeInsets.only(top: 8),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            SurvivalTimerOverlay(controller: controller),
            const SizedBox(width: 8),
            StartPauseButtonOverlay(
              uiState: uiState,
              onStart: onStart,
              onTogglePause: onTogglePause,
            ),
          ],
        ),
      ),
    );
  }
}


===== FILE: lib/ui/hud/game/top_left_hud_overlay.dart =====
import 'package:flutter/widgets.dart';

import '../../../game/game_controller.dart';

class TopLeftHudOverlay extends StatelessWidget {
  const TopLeftHudOverlay({required this.controller, super.key});

  final GameController controller;

  static const double _barWidth = 140;
  static const double _barHeight = 6;
  static const double _barGap = 4;

  @override
  Widget build(BuildContext context) {
    final totalHeight = _barHeight * 3 + _barGap * 2;

    return AnimatedBuilder(
      animation: controller,
      builder: (context, _) {
        final hud = controller.snapshot.hud;
        return IgnorePointer(
          child: RepaintBoundary(
            child: SizedBox(
              width: _barWidth,
              height: totalHeight,

              child: CustomPaint(
                painter: _HudBarsPainter(
                  hp: hud.hp,
                  hpMax: hud.hpMax,
                  mana: hud.mana,
                  manaMax: hud.manaMax,
                  stamina: hud.stamina,
                  staminaMax: hud.staminaMax,
                  barWidth: _barWidth,
                  barHeight: _barHeight,
                  barGap: _barGap,
                ),
              ),
            ),
          ),
        );
      },
    );
  }
}

class _HudBarsPainter extends CustomPainter {
  _HudBarsPainter({
    required this.hp,
    required this.hpMax,
    required this.mana,
    required this.manaMax,
    required this.stamina,
    required this.staminaMax,
    required this.barWidth,
    required this.barHeight,
    required this.barGap,
  });

  final double hp;
  final double hpMax;
  final double mana;
  final double manaMax;
  final double stamina;
  final double staminaMax;
  final double barWidth;
  final double barHeight;
  final double barGap;

  static final Paint _back = Paint()..color = const Color(0xAA000000);
  static final Paint _outline = Paint()
    ..color = const Color(0xFFFFFFFF)
    ..style = PaintingStyle.stroke
    ..strokeWidth = 1;
  static final Paint _hp = Paint()..color = const Color(0xFFDC4440);
  static final Paint _mana = Paint()..color = const Color(0xFF2D98DA);
  static final Paint _stamina = Paint()..color = const Color(0xFF4CD137);

  @override
  void paint(Canvas canvas, Size size) {
    _drawBar(
      canvas,
      y: 0,
      value: hp,
      max: hpMax,
      fill: _hp,
    );
    _drawBar(
      canvas,
      y: barHeight + barGap,
      value: mana,
      max: manaMax,
      fill: _mana,
    );
    _drawBar(
      canvas,
      y: (barHeight + barGap) * 2,
      value: stamina,
      max: staminaMax,
      fill: _stamina,
    );
  }

  void _drawBar(
    Canvas canvas, {
    required double y,
    required double value,
    required double max,
    required Paint fill,
  }) {
    final backRect = Rect.fromLTWH(0, y, barWidth, barHeight);
    canvas.drawRect(backRect, _back);
    canvas.drawRect(backRect, _outline);

    if (max <= 0) return;
    final t = (value / max).clamp(0.0, 1.0);
    if (t <= 0) return;
    canvas.drawRect(Rect.fromLTWH(0, y, barWidth * t, barHeight), fill);
  }

  @override
  bool shouldRepaint(covariant _HudBarsPainter oldDelegate) {
    return hp != oldDelegate.hp ||
        hpMax != oldDelegate.hpMax ||
        mana != oldDelegate.mana ||
        manaMax != oldDelegate.manaMax ||
        stamina != oldDelegate.stamina ||
        staminaMax != oldDelegate.staminaMax ||
        barWidth != oldDelegate.barWidth ||
        barHeight != oldDelegate.barHeight ||
        barGap != oldDelegate.barGap;
  }
}


===== FILE: lib/ui/hud/game/top_right_hud_overlay.dart =====
import 'package:flutter/material.dart';

import '../../../game/game_controller.dart';
import 'score_overlay.dart';

class TopRightHudOverlay extends StatelessWidget {
  const TopRightHudOverlay({
    super.key,
    required this.controller,
    required this.showExitButton,
    required this.onExit,
  });

  final GameController controller;
  final bool showExitButton;
  final VoidCallback? onExit;

  @override
  Widget build(BuildContext context) {
    return Align(
      alignment: Alignment.topRight,
      child: Padding(
        padding: const EdgeInsets.all(8),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            ScoreOverlay(controller: controller),
            if (showExitButton) ...[
              const SizedBox(width: 8),
              IconButton(
                onPressed: onExit,
                icon: const Icon(Icons.close),
                color: Colors.white,
                disabledColor: Colors.white,
              ),
            ],
          ],
        ),
      ),
    );
  }
}


===== FILE: lib/ui/hud/gameover/game_over_header.dart =====
import 'package:flutter/material.dart';

class GameOverHeader extends StatelessWidget {
  const GameOverHeader({
    super.key,
    required this.subtitleDeathReason,
    required this.displayScore,
  });

  final String? subtitleDeathReason;
  final int? displayScore;

  @override
  Widget build(BuildContext context) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        const Text(
          'Game Over',
          style: TextStyle(
            color: Color(0xFFFFFFFF),
            fontSize: 28,
            fontWeight: FontWeight.w600,
          ),
        ),
        if (subtitleDeathReason != null) ...[
          const SizedBox(height: 8),
          Text(
            subtitleDeathReason!,
            style: const TextStyle(
              color: Color(0xFFFFFFFF),
              fontSize: 14,
              fontWeight: FontWeight.w500,
            ),
            textAlign: TextAlign.center,
          ),
        ],
        if (displayScore != null) ...[
          const SizedBox(height: 14),
          Text(
            'Score: $displayScore',
            style: const TextStyle(
              color: Color(0xFFFFFFFF),
              fontSize: 16,
              fontWeight: FontWeight.w600,
            ),
            textAlign: TextAlign.center,
          ),
        ],
      ],
    );
  }
}


===== FILE: lib/ui/hud/gameover/game_over_overlay.dart =====
import 'package:flutter/material.dart';
import 'package:flutter/scheduler.dart';

import '../../../core/enemies/enemy_id.dart';
import '../../../core/events/game_event.dart';
import '../../../core/projectiles/projectile_id.dart';
import '../../../core/scoring/run_score_breakdown.dart';
import '../../../core/tuning/score_tuning.dart';
import '../../leaderboard/leaderboard_store.dart';
import 'game_over_header.dart';
import 'leaderboard_panel.dart';
import 'restart_exit_buttons.dart';
import 'score_breakdown_formatter.dart';
import 'score_distribution.dart';
import 'score_feed_controller.dart';
// import '../../../core/spells/spell_id.dart';

class GameOverOverlay extends StatefulWidget {
  const GameOverOverlay({
    super.key,
    required this.visible,
    required this.onRestart,
    required this.onExit,
    required this.showExitButton,
    required this.runEndedEvent,
    required this.scoreTuning,
    required this.tickHz,
    this.leaderboardStore,
  });

  final bool visible;
  final VoidCallback onRestart;
  final VoidCallback? onExit;
  final bool showExitButton;
  final RunEndedEvent? runEndedEvent;
  final ScoreTuning scoreTuning;
  final int tickHz;
  final LeaderboardStore? leaderboardStore;

  @override
  State<GameOverOverlay> createState() => _GameOverOverlayState();
}

class _GameOverOverlayState extends State<GameOverOverlay>
    with SingleTickerProviderStateMixin {
  late final RunScoreBreakdown _breakdown;
  late final ScoreFeedController _feedController;

  Ticker? _ticker;
  Duration _lastElapsed = Duration.zero;

  @override
  void initState() {
    super.initState();
    _breakdown = _buildBreakdown();
    _feedController = ScoreFeedController(
      rows: _breakdown.rows,
      totalPoints: _breakdown.totalPoints,
    );
  }

  RunScoreBreakdown _buildBreakdown() {
    final event = widget.runEndedEvent;
    if (event == null) {
      return const RunScoreBreakdown(rows: <RunScoreRow>[], totalPoints: 0);
    }

    return buildRunScoreBreakdown(
      tick: event.tick,
      distanceUnits: event.distance,
      collectibles: event.stats.collectibles,
      collectibleScore: event.stats.collectibleScore,
      enemyKillCounts: event.stats.enemyKillCounts,
      tuning: widget.scoreTuning,
      tickHz: widget.tickHz,
    );
  }

  void _startFeed() {
    if (_feedController.startFeed()) {
      _startTicker();
      setState(() {});
    }
  }

  void _startTicker() {
    _ticker?.dispose();
    _lastElapsed = Duration.zero;
    _ticker = createTicker(_onTick)..start();
  }

  void _stopTicker() {
    final ticker = _ticker;
    if (ticker == null) return;
    ticker.stop();
    ticker.dispose();
    _ticker = null;
  }

  void _onTick(Duration elapsed) {
    if (_feedController.feedState != ScoreFeedState.feeding) return;

    final dt =
        (elapsed - _lastElapsed).inMicroseconds.toDouble() / 1000000.0;
    _lastElapsed = elapsed;
    if (dt <= 0) return;

    final changed = _feedController.tick(dt);
    if (_feedController.feedState == ScoreFeedState.complete) {
      _stopTicker();
    }
    if (changed && mounted) setState(() {});
  }

  void _completeFeed() {
    _feedController.completeFeed();
    _stopTicker();
  }

  void _onCollectPressed() {
    if (_feedController.feedState == ScoreFeedState.idle) {
      _startFeed();
      return;
    }
    if (_feedController.feedState == ScoreFeedState.feeding) {
      _completeFeed();
      setState(() {});
    }
  }

  void _completeThen(VoidCallback? action) {
    if (_feedController.feedState != ScoreFeedState.complete) {
      _completeFeed();
      setState(() {});
    }
    if (action == null) return;
    WidgetsBinding.instance.addPostFrameCallback((_) => action());
  }

  @override
  void dispose() {
    _stopTicker();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    if (!widget.visible) return const SizedBox.shrink();

    final subtitleDeathReason = _buildSubtitleDeathReason(widget.runEndedEvent);
    final showCollectButton =
        _feedController.totalPoints > 0 &&
        _feedController.feedState != ScoreFeedState.complete;
    final showScoreInHeader =
        _feedController.feedState == ScoreFeedState.complete;
    final collectLabel =
        _feedController.feedState == ScoreFeedState.idle
            ? 'Collect score'
            : 'Skip';
    final rowLabels = [
      for (var i = 0; i < _feedController.rows.length; i += 1)
        formatScoreRow(
          _feedController.rows[i].row,
          _feedController.rows[i].remainingPoints,
          enemyName: _enemyName,
        ),
    ];

    return SizedBox.expand(
      child: ColoredBox(
        color: const Color(0x88000000),
        child: SafeArea(
          minimum: const EdgeInsets.all(18),
          child: Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Expanded(
                flex: 2,
                child: Align(
                  alignment: Alignment.topCenter,
                  child: Column(
                    mainAxisSize: MainAxisSize.max,
                    children: [
                      GameOverHeader(
                        subtitleDeathReason: subtitleDeathReason,
                        displayScore:
                            showScoreInHeader ? _feedController.displayScore : null,
                      ),
                      const SizedBox(height: 14),
                      if (showCollectButton)
                        _OverlayButton(
                          label: collectLabel,
                          onPressed: _onCollectPressed,
                        )
                      else
                        RestartExitButtons(
                          restartButton: _OverlayButton(
                            label: 'Restart',
                            onPressed: () => _completeThen(widget.onRestart),
                          ),
                          exitButton: widget.showExitButton
                              ? _OverlayButton(
                                  label: 'Exit',
                                  onPressed: () => _completeThen(widget.onExit),
                                )
                              : null,
                        ),
                      const SizedBox(height: 16),
                      Flexible(child: ScoreDistribution(rowLabels: rowLabels)),
                    ],
                  ),
                ),
              ),
              Expanded(
                flex: 1,
                child: Align(
                  alignment: Alignment.topCenter,
                  child: LeaderboardPanel(
                    runEndedEvent: widget.runEndedEvent,
                    scoreTuning: widget.scoreTuning,
                    tickHz: widget.tickHz,
                    revealCurrentRunScore:
                        _feedController.feedState == ScoreFeedState.complete,
                    leaderboardStore: widget.leaderboardStore,
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

String? _buildSubtitleDeathReason(RunEndedEvent? event) {
  if (event == null) return null;
  switch (event.reason) {
    case RunEndReason.gaveUp:
      return 'You gave up the run.';
    case RunEndReason.fellBehindCamera:
      return 'You fell behind.';
    case RunEndReason.fellIntoGap:
      return 'You fell into a gap.';
    case RunEndReason.playerDied:
      return _buildDeathSubtitle(event.deathInfo);
  }
}

String _buildDeathSubtitle(DeathInfo? info) {
  if (info == null) return 'You died.';
  switch (info.kind) {
    case DeathSourceKind.projectile:
      return _buildProjectileDeath(info);
    case DeathSourceKind.meleeHitbox:
      return _buildMeleeDeath(info);
    case DeathSourceKind.unknown:
      return 'You died.';
  }
}

String _buildProjectileDeath(DeathInfo info) {
  final projectileId = info.projectileId;
  if (projectileId == null) return 'You died.';
  final projectileName = _projectileName(projectileId);
  /* final spellName =
      info.spellId == null ? null : _spellName(info.spellId!); */
  final enemyName = info.enemyId == null ? null : _enemyName(info.enemyId!);

  final buffer = StringBuffer('Killed by $projectileName');
  /*   if (spellName != null) {
    buffer.write(' ($spellName)');
  } */
  if (enemyName != null) {
    buffer.write(' from $enemyName.');
  } else {
    buffer.write('.');
  }
  return buffer.toString();
}

String _buildMeleeDeath(DeathInfo info) {
  if (info.enemyId == null) return 'You died.';
  return 'Killed by a melee strike from a ${_enemyName(info.enemyId!)}.';
}

String _enemyName(EnemyId id) {
  switch (id) {
    case EnemyId.flyingEnemy:
      return 'Flying enemy';
    case EnemyId.groundEnemy:
      return 'Ground enemy';
  }
}

String _projectileName(ProjectileId id) {
  switch (id) {
    case ProjectileId.iceBolt:
      return 'Ice Bolt';
    case ProjectileId.lightningBolt:
      return 'Lightning Bolt';
  }
}

/* String _spellName(SpellId id) {
  switch (id) {
    case SpellId.iceBolt:
      return 'Ice Bolt';
    case SpellId.lightning:
      return 'Lightning';
  }
} */

class _OverlayButton extends StatelessWidget {
  const _OverlayButton({required this.label, required this.onPressed});

  final String label;
  final VoidCallback? onPressed;

  @override
  Widget build(BuildContext context) {
    return TextButton(
      onPressed: onPressed,
      style: TextButton.styleFrom(
        foregroundColor: const Color(0xFFFFFFFF),
        backgroundColor: const Color(0xAA000000),
        padding: const EdgeInsets.symmetric(horizontal: 18, vertical: 10),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(10),
          side: const BorderSide(color: Color(0xFFFFFFFF)),
        ),
      ),
      child: Text(
        label,
        style: const TextStyle(fontSize: 14, fontWeight: FontWeight.w600),
      ),
    );
  }
}


===== FILE: lib/ui/hud/gameover/leaderboard_panel.dart =====
import 'package:flutter/material.dart';

import '../../../core/events/game_event.dart';
import '../../../core/tuning/score_tuning.dart';
import '../../leaderboard/leaderboard_store.dart';
import '../../leaderboard/run_result.dart';
import '../../leaderboard/shared_prefs_leaderboard_store.dart';

class LeaderboardPanel extends StatefulWidget {
  const LeaderboardPanel({
    super.key,
    required this.runEndedEvent,
    required this.scoreTuning,
    required this.tickHz,
    this.revealCurrentRunScore = true,
    this.leaderboardStore,
  });

  final RunEndedEvent? runEndedEvent;
  final ScoreTuning scoreTuning;
  final int tickHz;
  final bool revealCurrentRunScore;
  final LeaderboardStore? leaderboardStore;

  @override
  State<LeaderboardPanel> createState() => _LeaderboardPanelState();
}

class _LeaderboardPanelState extends State<LeaderboardPanel> {
  late final LeaderboardStore _store;
  List<RunResult> _entries = const <RunResult>[];
  int? _currentRunId;
  bool _loaded = false;

  static const double _rankColWidth = 28;
  static const double _scoreColWidth = 64;
  static const double _distanceColWidth = 56;
  static const double _timeColWidth = 54;

  @override
  void initState() {
    super.initState();
    _store = widget.leaderboardStore ?? SharedPrefsLeaderboardStore();
    _loadLeaderboard();
  }

  Future<void> _loadLeaderboard() async {
    final event = widget.runEndedEvent;
    if (event == null) {
      final entries = await _store.loadTop10();
      if (!mounted) return;
      setState(() {
        _entries = entries;
        _loaded = true;
      });
      return;
    }

    final draft = buildRunResult(
      event: event,
      scoreTuning: widget.scoreTuning,
      tickHz: widget.tickHz,
      endedAtMs: DateTime.now().millisecondsSinceEpoch,
    );
    final snapshot = await _store.addResult(draft);
    if (!mounted) return;
    setState(() {
      _entries = snapshot.entries;
      _currentRunId = snapshot.current.runId;
      _loaded = true;
    });
  }

  Widget _buildRow(int rank, RunResult entry) {
    final isCurrent = _currentRunId != null && entry.runId == _currentRunId;
    final color = isCurrent ? const Color(0xFFFFF59D) : const Color(0xFFFFFFFF);
    final scoreText =
        isCurrent && !widget.revealCurrentRunScore ? '—' : entry.score.toString();

    return DecoratedBox(
      decoration: isCurrent
          ? BoxDecoration(
              color: const Color(0x33FFFFFF),
              borderRadius: BorderRadius.circular(6),
            )
          : const BoxDecoration(),
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 3),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            SizedBox(
              width: _rankColWidth,
              child: Text(
                '#$rank',
                style: TextStyle(color: color),
              ),
            ),
            SizedBox(
              width: _scoreColWidth,
              child: Text(
                scoreText,
                textAlign: TextAlign.right,
                style: TextStyle(color: color),
              ),
            ),
            SizedBox(
              width: _distanceColWidth,
              child: Text(
                '${entry.distanceMeters}m',
                textAlign: TextAlign.right,
                style: TextStyle(color: color),
              ),
            ),
            SizedBox(
              width: _timeColWidth,
              child: Text(
                _formatTime(entry.durationSeconds),
                textAlign: TextAlign.right,
                style: TextStyle(color: color),
              ),
            ),
          ],
        ),
      ),
    );
  }

  String _formatTime(int totalSeconds) {
    final minutes = totalSeconds ~/ 60;
    final seconds = totalSeconds % 60;
    return '${minutes.toString().padLeft(2, '0')}:${seconds.toString().padLeft(2, '0')}';
  }

  @override
  Widget build(BuildContext context) {
    final titleStyle = const TextStyle(
      color: Color(0xFFFFFFFF),
      fontSize: 14,
      fontWeight: FontWeight.w600,
    );
    final textStyle = const TextStyle(
      color: Color(0xFFFFFFFF),
      fontSize: 12,
      fontWeight: FontWeight.w500,
    );

    Widget content;
    if (!_loaded) {
      content = Text('Loading leaderboard...', style: textStyle);
    } else if (_entries.isEmpty) {
      content = Text('No runs yet.', style: textStyle);
    } else {
      content = Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          for (var i = 0; i < _entries.length; i += 1) ...[
            _buildRow(i + 1, _entries[i]),
            if (i < _entries.length - 1) const SizedBox(height: 4),
          ],
        ],
      );
    }

    return ConstrainedBox(
      constraints: const BoxConstraints(maxWidth: 240),
      child: DecoratedBox(
        decoration: BoxDecoration(
          color: const Color(0x66000000),
          borderRadius: BorderRadius.circular(10),
        ),
        child: Padding(
          padding: const EdgeInsets.all(12),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text('Scoreboard', style: titleStyle),
              const SizedBox(height: 8),
              DefaultTextStyle(style: textStyle, child: content),
            ],
          ),
        ),
      ),
    );
  }
}


===== FILE: lib/ui/hud/gameover/restart_exit_buttons.dart =====
import 'package:flutter/material.dart';

class RestartExitButtons extends StatelessWidget {
  const RestartExitButtons({
    super.key,
    required this.restartButton,
    this.exitButton,
    this.trailingButton,
  });

  final Widget restartButton;
  final Widget? exitButton;
  final Widget? trailingButton;

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      width: double.infinity,
      child: Stack(
        alignment: Alignment.center,
        children: [
          Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              restartButton,
              if (exitButton != null) ...[
                const SizedBox(width: 12),
                exitButton!,
              ],
            ],
          ),
          if (trailingButton != null)
            Align(alignment: Alignment.centerRight, child: trailingButton),
        ],
      ),
    );
  }
}


===== FILE: lib/ui/hud/gameover/score_breakdown_formatter.dart =====
import '../../../core/enemies/enemy_id.dart';
import '../../../core/scoring/run_score_breakdown.dart';

String formatScoreRow(
  RunScoreRow row,
  int remainingPoints, {
  required String Function(EnemyId id) enemyName,
}) {
  switch (row.kind) {
    case RunScoreRowKind.distance:
      return 'Distance: ${row.count}m -> $remainingPoints';
    case RunScoreRowKind.time:
      return 'Time: ${_formatTime(row.count)} -> $remainingPoints';
    case RunScoreRowKind.collectibles:
      return 'Collectibles: ${row.count} -> $remainingPoints';
    case RunScoreRowKind.enemyKill:
      final name = row.enemyId == null ? 'Enemy' : enemyName(row.enemyId!);
      return '$name x${row.count} -> $remainingPoints';
  }
}

String _formatTime(int totalSeconds) {
  final minutes = totalSeconds ~/ 60;
  final seconds = totalSeconds % 60;
  return '${minutes.toString().padLeft(2, '0')}:${seconds.toString().padLeft(2, '0')}';
}


===== FILE: lib/ui/hud/gameover/score_distribution.dart =====
import 'package:flutter/material.dart';

class ScoreDistribution extends StatelessWidget {
  const ScoreDistribution({
    super.key,
    required this.rowLabels,
  });

  final List<String> rowLabels;

  @override
  Widget build(BuildContext context) {
    return Scrollbar(
      child: SingleChildScrollView(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            for (var i = 0; i < rowLabels.length; i += 1) ...[
              Text(
                rowLabels[i],
                style: const TextStyle(
                  color: Color(0xFFFFFFFF),
                  fontSize: 14,
                  fontWeight: FontWeight.w500,
                ),
                textAlign: TextAlign.center,
              ),
              if (i < rowLabels.length - 1) const SizedBox(height: 4),
            ],
          ],
        ),
      ),
    );
  }
}


===== FILE: lib/ui/hud/gameover/score_feed_controller.dart =====
import '../../../core/scoring/run_score_breakdown.dart';

enum ScoreFeedState { idle, feeding, complete }

class ScoreFeedRowState {
  ScoreFeedRowState({
    required this.row,
    required this.pointsPerSecond,
  }) : remainingPoints = row.points;

  final RunScoreRow row;
  final double pointsPerSecond;
  int remainingPoints;
  double carry = 0.0;
}

class ScoreFeedController {
  ScoreFeedController({
    required List<RunScoreRow> rows,
    required this.totalPoints,
    double feedDurationSeconds = 0.8,
  }) : _rows = [
          for (final row in rows)
            ScoreFeedRowState(
              row: row,
              pointsPerSecond:
                  row.points <= 0 ? 0.0 : row.points / feedDurationSeconds,
            ),
        ],
        displayScore = 0,
        feedState =
            totalPoints > 0 ? ScoreFeedState.idle : ScoreFeedState.complete;

  final int totalPoints;
  final List<ScoreFeedRowState> _rows;

  int displayScore;
  ScoreFeedState feedState;

  List<ScoreFeedRowState> get rows => _rows;

  bool startFeed() {
    if (feedState != ScoreFeedState.idle || totalPoints <= 0) return false;
    feedState = ScoreFeedState.feeding;
    return true;
  }

  bool tick(double dtSeconds) {
    if (feedState != ScoreFeedState.feeding || dtSeconds <= 0) {
      return false;
    }

    var gained = 0;
    var anyRemaining = false;

    for (final row in _rows) {
      if (row.remainingPoints <= 0 || row.pointsPerSecond <= 0) continue;
      row.carry += dtSeconds * row.pointsPerSecond;
      final raw = row.carry.floor();
      if (raw <= 0) {
        anyRemaining = true;
        continue;
      }
      row.carry -= raw;
      final consume =
          raw > row.remainingPoints ? row.remainingPoints : raw;
      row.remainingPoints -= consume;
      gained += consume;
      if (row.remainingPoints > 0) anyRemaining = true;
    }

    if (gained > 0) {
      displayScore += gained;
      if (displayScore > totalPoints) displayScore = totalPoints;
    }

    if (!anyRemaining) {
      completeFeed();
      return true;
    }

    return gained > 0;
  }

  void completeFeed() {
    displayScore = totalPoints;
    for (final row in _rows) {
      row.remainingPoints = 0;
      row.carry = 0.0;
    }
    feedState = ScoreFeedState.complete;
  }
}


===== FILE: lib/ui/leaderboard/leaderboard_store.dart =====
import 'run_result.dart';

class LeaderboardSnapshot {
  const LeaderboardSnapshot({
    required this.entries,
    required this.current,
  });

  final List<RunResult> entries;
  final RunResult current;
}

abstract class LeaderboardStore {
  Future<LeaderboardSnapshot> addResult(RunResult result);
  Future<List<RunResult>> loadTop10();
}


===== FILE: lib/ui/leaderboard/run_result.dart =====
import '../../core/events/game_event.dart';
import '../../core/scoring/run_score_breakdown.dart';
import '../../core/tuning/score_tuning.dart';

class RunResult {
  const RunResult({
    required this.runId,
    required this.endedAtMs,
    required this.endedReason,
    required this.score,
    required this.distanceMeters,
    required this.durationSeconds,
    required this.tick,
  });

  final int runId;
  final int endedAtMs;
  final RunEndReason endedReason;
  final int score;
  final int distanceMeters;
  final int durationSeconds;
  final int tick;

  RunResult copyWith({
    int? runId,
    int? endedAtMs,
  }) {
    return RunResult(
      runId: runId ?? this.runId,
      endedAtMs: endedAtMs ?? this.endedAtMs,
      endedReason: endedReason,
      score: score,
      distanceMeters: distanceMeters,
      durationSeconds: durationSeconds,
      tick: tick,
    );
  }

  Map<String, dynamic> toJson() => <String, dynamic>{
        'runId': runId,
        'endedAtMs': endedAtMs,
        'endedReason': endedReason.name,
        'score': score,
        'distanceMeters': distanceMeters,
        'durationSeconds': durationSeconds,
        'tick': tick,
      };

  static RunResult fromJson(Map<String, dynamic> json) {
    final reasonName = json['endedReason'] as String?;
    final reason = _reasonFromName(reasonName);
    return RunResult(
      runId: json['runId'] as int? ?? 0,
      endedAtMs: json['endedAtMs'] as int? ?? 0,
      endedReason: reason,
      score: json['score'] as int? ?? 0,
      distanceMeters: json['distanceMeters'] as int? ?? 0,
      durationSeconds: json['durationSeconds'] as int? ?? 0,
      tick: json['tick'] as int? ?? 0,
    );
  }

  static RunEndReason _reasonFromName(String? name) {
    if (name == null) return RunEndReason.playerDied;
    for (final value in RunEndReason.values) {
      if (value.name == name) return value;
    }
    return RunEndReason.playerDied;
  }
}

RunResult buildRunResult({
  required RunEndedEvent event,
  required ScoreTuning scoreTuning,
  required int tickHz,
  required int endedAtMs,
}) {
  final breakdown = buildRunScoreBreakdown(
    tick: event.tick,
    distanceUnits: event.distance,
    collectibles: event.stats.collectibles,
    collectibleScore: event.stats.collectibleScore,
    enemyKillCounts: event.stats.enemyKillCounts,
    tuning: scoreTuning,
    tickHz: tickHz,
  );

  final distanceMeters = (event.distance / 100.0).floor();
  final durationSeconds = tickHz <= 0 ? 0 : event.tick ~/ tickHz;

  return RunResult(
    runId: 0,
    endedAtMs: endedAtMs,
    endedReason: event.reason,
    score: breakdown.totalPoints,
    distanceMeters: distanceMeters,
    durationSeconds: durationSeconds,
    tick: event.tick,
  );
}


===== FILE: lib/ui/leaderboard/shared_prefs_leaderboard_store.dart =====
import 'dart:convert';

import 'package:shared_preferences/shared_preferences.dart';

import 'leaderboard_store.dart';
import 'run_result.dart';

class SharedPrefsLeaderboardStore implements LeaderboardStore {
  static const String _entriesKey = 'leaderboard_v1_entries';
  static const String _nextIdKey = 'leaderboard_v1_next_id';

  @override
  Future<LeaderboardSnapshot> addResult(RunResult result) async {
    final prefs = await SharedPreferences.getInstance();

    final nextId = (prefs.getInt(_nextIdKey) ?? 1);
    final stored = result.copyWith(runId: nextId);
    final entries = _loadEntries(prefs);
    entries.add(stored);
    entries.sort(_compare);

    final top = entries.length > 10 ? entries.sublist(0, 10) : entries;
    await prefs.setString(_entriesKey, _encode(top));
    await prefs.setInt(_nextIdKey, nextId + 1);

    return LeaderboardSnapshot(
      entries: List<RunResult>.unmodifiable(top),
      current: stored,
    );
  }

  @override
  Future<List<RunResult>> loadTop10() async {
    final prefs = await SharedPreferences.getInstance();
    final entries = _loadEntries(prefs);
    entries.sort(_compare);
    if (entries.length > 10) return entries.sublist(0, 10);
    return List<RunResult>.unmodifiable(entries);
  }

  List<RunResult> _loadEntries(SharedPreferences prefs) {
    final raw = prefs.getString(_entriesKey);
    if (raw == null || raw.isEmpty) return <RunResult>[];

    final decoded = jsonDecode(raw);
    if (decoded is! List) return <RunResult>[];

    final entries = <RunResult>[];
    for (final entry in decoded) {
      if (entry is Map<String, dynamic>) {
        entries.add(RunResult.fromJson(entry));
      } else if (entry is Map) {
        entries.add(RunResult.fromJson(Map<String, dynamic>.from(entry)));
      }
    }
    return entries;
  }

  String _encode(List<RunResult> entries) {
    return jsonEncode(entries.map((entry) => entry.toJson()).toList());
  }

  int _compare(RunResult a, RunResult b) {
    if (a.score != b.score) return b.score.compareTo(a.score);
    if (a.endedAtMs != b.endedAtMs) {
      return b.endedAtMs.compareTo(a.endedAtMs);
    }
    return b.runId.compareTo(a.runId);
  }
}


===== FILE: lib/ui/runner_game_route.dart =====
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import 'runner_game_widget.dart';
import 'scoped/scoped_preferred_orientations.dart';
import 'scoped/scoped_system_ui_mode.dart';

/// Embed-friendly route factory for hosting the mini-game in any Flutter app.
///
/// Host apps can `Navigator.push(createRunnerGameRoute(...))` without depending
/// on this package's development host app (`lib/main.dart`).
///
Route<void> createRunnerGameRoute({
  int seed = 1,
  bool lockLandscape = true,
  List<DeviceOrientation>? restoreOrientations,
}) {
  return MaterialPageRoute<void>(
    builder: (context) {
      Widget child = RunnerGameWidget(
        seed: seed,
        onExit: () => Navigator.of(context).maybePop(),
      );

      if (lockLandscape) {
        child = ScopedPreferredOrientations(
          preferredOrientations: const [
            DeviceOrientation.landscapeLeft,
            DeviceOrientation.landscapeRight,
          ],
          restoreOrientations: restoreOrientations,
          child: child,
        );
      }

      // Hide status + nav bars only for this route.
      child = ScopedSystemUiMode(
        mode: SystemUiMode.immersiveSticky,
        restoreMode: SystemUiMode.edgeToEdge,
        child: child,
      );

      return Scaffold(body: child);
    },
  );
}


===== FILE: lib/ui/runner_game_ui_state.dart =====
class RunnerGameUiState {
  const RunnerGameUiState({
    required this.started,
    required this.paused,
    required this.gameOver,
  });

  final bool started;
  final bool paused;
  final bool gameOver;

  bool get canRun => started && !gameOver;

  bool get isRunning => canRun && !paused;

  bool get showReadyOverlay => !started;

  bool get showPauseOverlay => started && paused && !gameOver;
}


===== FILE: lib/ui/runner_game_widget.dart =====
import 'package:flame/game.dart';
import 'package:flutter/material.dart';

import '../core/contracts/render_contract.dart';
import '../core/game_core.dart';
import '../game/game_controller.dart';
import '../game/input/aim_preview.dart';
import '../game/input/runner_input_router.dart';
import '../game/runner_flame_game.dart';
import 'hud/game/game_overlay.dart';
import 'hud/gameover/game_over_overlay.dart';
import 'runner_game_ui_state.dart';
import 'viewport/game_viewport.dart';
import 'viewport/viewport_metrics.dart';

/// Embed-friendly widget that hosts the mini-game.
///
/// Intended to be mounted by a host app. It owns its [GameController] and
/// cleans it up on dispose.
///
/// Viewport scaling is applied by [GameViewport] to keep the fixed virtual
/// resolution fitted to the available screen.
class RunnerGameWidget extends StatefulWidget {
  const RunnerGameWidget({
    super.key,
    this.seed = 1,
    this.onExit,
    this.showExitButton = true,
    this.viewportMode = ViewportScaleMode.pixelPerfectContain,
    this.viewportAlignment = Alignment.center,
  });

  final int seed;

  final VoidCallback? onExit;
  final bool showExitButton;

  /// How the game view is scaled to the available screen.
  final ViewportScaleMode viewportMode;

  /// Where the scaled view is placed within the available screen.
  final Alignment viewportAlignment;

  @override
  State<RunnerGameWidget> createState() => _RunnerGameWidgetState();
}

class _RunnerGameWidgetState extends State<RunnerGameWidget>
    with WidgetsBindingObserver {
  bool _pausedByLifecycle = false;
  bool _started = false;

  late GameController _controller;
  late RunnerInputRouter _input;
  late AimPreviewModel _projectileAimPreview;
  late AimPreviewModel _meleeAimPreview;
  late RunnerFlameGame _game;

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);

    _initGame();

    // Start in "ready" (paused) until the user taps to begin.
    _controller.setPaused(true);
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) =>
      _onLifecycle(state);

  void _onLifecycle(AppLifecycleState state) {
    final uiState = _buildUiState();
    if (state == AppLifecycleState.resumed) {
      if (_pausedByLifecycle && uiState.started && !uiState.gameOver) {
        _pausedByLifecycle = false;
        _controller.setPaused(false);
      }
      return;
    }

    // Only mark lifecycle-paused if we were actually running.
    _pausedByLifecycle = uiState.isRunning;
    _controller.setPaused(true);
    _clearInputs();
  }

  void _clearInputs() {
    _input.setMoveAxis(0);
    _input.clearProjectileAimDir();
    _input.clearMeleeAimDir();
    _projectileAimPreview.end();
    _meleeAimPreview.end();
    _input.pumpHeldInputs();
  }

  RunnerGameUiState _buildUiState() {
    final snapshot = _controller.snapshot;
    return RunnerGameUiState(
      started: _started,
      paused: snapshot.paused,
      gameOver: snapshot.gameOver,
    );
  }

  void _startGame() {
    setState(() => _started = true);
    _clearInputs();
    _controller.setPaused(false);
  }

  void _restartGame() {
    final oldController = _controller;
    final oldProjectilePreview = _projectileAimPreview;
    final oldMeleePreview = _meleeAimPreview;

    setState(() {
      _pausedByLifecycle = false;
      _started = false;
      _initGame();
    });
    _controller.setPaused(true);
    _clearInputs();

    WidgetsBinding.instance.addPostFrameCallback((_) {
      oldController.shutdown();
      oldController.dispose();
      oldProjectilePreview.dispose();
      oldMeleePreview.dispose();
    });
  }

  void _togglePause() {
    final paused = _controller.snapshot.paused;
    if (!paused) _clearInputs();
    _controller.setPaused(!paused);
  }

  void _initGame() {
    _controller = GameController(core: GameCore(seed: widget.seed));
    _input = RunnerInputRouter(controller: _controller);
    _projectileAimPreview = AimPreviewModel();
    _meleeAimPreview = AimPreviewModel();
    _game = RunnerFlameGame(
      controller: _controller,
      input: _input,
      projectileAimPreview: _projectileAimPreview,
      meleeAimPreview: _meleeAimPreview,
    );
  }

  void _disposeGame() {
    _controller.shutdown();
    _controller.dispose();
    _projectileAimPreview.dispose();
    _meleeAimPreview.dispose();
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    _disposeGame();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Stack(
      fit: StackFit.expand,
      children: [
        LayoutBuilder(
          builder: (context, constraints) {
            final devicePixelRatio = MediaQuery.devicePixelRatioOf(context);
            final metrics = computeViewportMetrics(
              constraints,
              devicePixelRatio,
              virtualWidth,
              virtualHeight,
              widget.viewportMode,
              alignment: widget.viewportAlignment,
            );
            Widget gameView = GameViewport(
              metrics: metrics,
              child: GameWidget(
                key: ValueKey(_game),
                game: _game,
                autofocus: false,
              ),
            );

            return gameView;
          },
        ),
        AnimatedBuilder(
          animation: _controller,
          builder: (context, _) {
            final uiState = _buildUiState();
            if (uiState.gameOver) {
              final runEndedEvent = _controller.lastRunEndedEvent;
              final runEndKey = runEndedEvent?.tick ?? _controller.snapshot.tick;
              return GameOverOverlay(
                key: ValueKey('gameOver-$runEndKey-${runEndedEvent?.reason}'),
                visible: true,
                onRestart: _restartGame,
                onExit: widget.onExit,
                showExitButton: widget.showExitButton,
                runEndedEvent: runEndedEvent,
                scoreTuning: _controller.scoreTuning,
                tickHz: _controller.tickHz,
              );
            }
            return GameOverlay(
              controller: _controller,
              input: _input,
              projectileAimPreview: _projectileAimPreview,
              meleeAimPreview: _meleeAimPreview,
              uiState: uiState,
              onStart: _startGame,
              onTogglePause: _togglePause,
              showExitButton: widget.showExitButton,
              onExit: uiState.started && !uiState.gameOver
                  ? _controller.giveUp
                  : widget.onExit,
            );
          },
        ),
      ],
    );
  }
}


===== FILE: lib/ui/scoped/scoped_preferred_orientations.dart =====
import 'package:flutter/foundation.dart';
import 'package:flutter/services.dart';
import 'package:flutter/widgets.dart';

/// Applies `SystemChrome.setPreferredOrientations` while this widget is mounted.
///
/// This is intentionally scoped to a subtree (typically a route) so the runner
/// can be embedded in a host app without enforcing a global orientation policy.
///
/// Notes:
/// - Flutter does not expose the *previous* preferred orientations, so the
///   caller must decide what to restore on dispose.
/// - Platform-level orientation support (Android manifest / iOS Info.plist)
///   still needs to include the requested orientations.
class ScopedPreferredOrientations extends StatefulWidget {
  const ScopedPreferredOrientations({
    super.key,
    required this.preferredOrientations,
    required this.child,
    this.restoreOrientations,
  });

  final List<DeviceOrientation> preferredOrientations;
  final List<DeviceOrientation>? restoreOrientations;
  final Widget child;

  @override
  State<ScopedPreferredOrientations> createState() =>
      _ScopedPreferredOrientationsState();
}

class _ScopedPreferredOrientationsState
    extends State<ScopedPreferredOrientations> {
  @override
  void initState() {
    super.initState();
    SystemChrome.setPreferredOrientations(widget.preferredOrientations);
  }

  @override
  void didUpdateWidget(covariant ScopedPreferredOrientations oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (!listEquals(
      oldWidget.preferredOrientations,
      widget.preferredOrientations,
    )) {
      SystemChrome.setPreferredOrientations(widget.preferredOrientations);
    }
  }

  @override
  void dispose() {
    final restore = widget.restoreOrientations;
    if (restore != null) {
      SystemChrome.setPreferredOrientations(restore);
    }
    super.dispose();
  }

  @override
  Widget build(BuildContext context) => widget.child;
}


===== FILE: lib/ui/scoped/scoped_system_ui_mode.dart =====
import 'package:flutter/services.dart';
import 'package:flutter/widgets.dart';

/// Applies `SystemChrome.setEnabledSystemUIMode` while this widget is mounted.
///
/// Scoped to a subtree (typically a route) so embedding stays clean.
class ScopedSystemUiMode extends StatefulWidget {
  const ScopedSystemUiMode({
    super.key,
    required this.mode,
    required this.child,
    this.overlays,
    this.restoreMode = SystemUiMode.edgeToEdge,
    this.restoreOverlays,
  });

  final SystemUiMode mode;
  final List<SystemUiOverlay>? overlays;

  final SystemUiMode restoreMode;
  final List<SystemUiOverlay>? restoreOverlays;

  final Widget child;

  @override
  State<ScopedSystemUiMode> createState() => _ScopedSystemUiModeState();
}

class _ScopedSystemUiModeState extends State<ScopedSystemUiMode> {
  @override
  void initState() {
    super.initState();
    _apply();
  }

  @override
  void didUpdateWidget(covariant ScopedSystemUiMode oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.mode != widget.mode ||
        oldWidget.overlays != widget.overlays) {
      _apply();
    }
  }

  void _apply() {
    SystemChrome.setEnabledSystemUIMode(widget.mode, overlays: widget.overlays);
  }

  @override
  void dispose() {
    SystemChrome.setEnabledSystemUIMode(
      widget.restoreMode,
      overlays: widget.restoreOverlays,
    );
    super.dispose();
  }

  @override
  Widget build(BuildContext context) => widget.child;
}


===== FILE: lib/ui/viewport/game_viewport.dart =====
import 'package:flutter/widgets.dart';

import 'viewport_metrics.dart';

/// Scales a fixed virtual canvas into the available space.
///
/// Use [computeViewportMetrics] so rendering and input mapping share the same
/// view size + offset.
class GameViewport extends StatelessWidget {
  const GameViewport({
    super.key,
    required this.metrics,
    required this.child,
    this.letterboxColor = const Color(0xFF000000),
  });

  final ViewportMetrics metrics;
  final Widget child;
  final Color letterboxColor;

  @override
  Widget build(BuildContext context) {
    return ColoredBox(
      color: letterboxColor,
      child: ClipRect(
        child: SizedBox.expand(
          child: Stack(
            fit: StackFit.expand,
            children: [
              Positioned(
                left: metrics.offsetX,
                top: metrics.offsetY,
                width: metrics.viewW,
                height: metrics.viewH,
                child: child,
              ),
            ],
          ),
        ),
      ),
    );
  }
}


===== FILE: lib/ui/viewport/viewport_metrics.dart =====
import 'dart:math' as math;

import 'package:flutter/widgets.dart';
/// Viewport scaling modes for fitting a fixed virtual canvas to the screen.
enum ViewportScaleMode {
  /// Integer physical-pixel scale (pixel-perfect, no cropping).
  ///
  /// Fits the entire virtual canvas on-screen, letterboxing the remaining area.
  pixelPerfectContain,

  /// Integer physical-pixel scale (pixel-perfect, with cropping).
  ///
  /// Fully covers the screen by scaling up until both dimensions fit. Any
  /// overflow is cropped by the outer [ClipRect].
  pixelPerfectCover,
}

/// Shared viewport sizing results for rendering and input mapping.
@immutable
class ViewportMetrics {
  const ViewportMetrics({
    required this.viewW,
    required this.viewH,
    required this.offsetX,
    required this.offsetY,
  });

  /// Scaled viewport width in logical pixels.
  final double viewW;

  /// Scaled viewport height in logical pixels.
  final double viewH;

  /// Viewport top-left offset in logical pixels.
  final double offsetX;

  /// Viewport top-left offset in logical pixels.
  final double offsetY;
}

/// Computes shared viewport metrics from the current layout constraints.
ViewportMetrics computeViewportMetrics(
  BoxConstraints constraints,
  double devicePixelRatio,
  int virtualW,
  int virtualH,
  ViewportScaleMode mode, {
  Alignment alignment = Alignment.center,
}) {
  assert(devicePixelRatio > 0);
  assert(virtualW > 0);
  assert(virtualH > 0);

  final screenW = constraints.hasBoundedWidth ? constraints.maxWidth : 0.0;
  final screenH = constraints.hasBoundedHeight ? constraints.maxHeight : 0.0;
  final screenPxW = screenW * devicePixelRatio;
  final screenPxH = screenH * devicePixelRatio;

  final scaleW = screenPxW / virtualW;
  final scaleH = screenPxH / virtualH;

  final scalePx = switch (mode) {
    ViewportScaleMode.pixelPerfectContain =>
      math.max(1.0, math.min(scaleW, scaleH).floorToDouble()),
    ViewportScaleMode.pixelPerfectCover =>
      math.max(1.0, math.max(scaleW, scaleH).ceilToDouble()),
  };

  final viewPxW = virtualW * scalePx;
  final viewPxH = virtualH * scalePx;
  final viewW = viewPxW / devicePixelRatio;
  final viewH = viewPxH / devicePixelRatio;

  final alignX = (alignment.x + 1.0) * 0.5;
  final alignY = (alignment.y + 1.0) * 0.5;
  final offsetX = (screenW - viewW) * alignX;
  final offsetY = (screenH - viewH) * alignY;

  return ViewportMetrics(
    viewW: viewW,
    viewH: viewH,
    offsetX: offsetX,
    offsetY: offsetY,
  );
}

