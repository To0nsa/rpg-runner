REPO: C:\dev\walkscape_runner
COMMIT: 482b3bad2849d98336ece880c5b7cf3714f7fa63
DATE: 2025-12-20 23:41:48


===== FILE: lib/AGENTS.md =====
# AGENTS.md

Instructions for AI coding agents (Codex, ChatGPT, etc.) when working in this repo.

## Project mission

Port an existing **SFML/C++ 2D runner** (tools\output\c++implementation.txt)into **Flutter (Dart) + Flame** while preserving gameplay feel and making the result **production-grade** (mobile performance, clean architecture, future online-ready).

## Working style (how to collaborate)

## Consent before changing code

When the user asks a question (e.g. “how do I…?”, “why…?”, “is it possible…?”) or explicitly says “no code / just answer”:

- **Do not make code changes or run refactors.** Provide an answer with options/tradeoffs only.
- If implementation would help, **ask for confirmation first** (e.g. “Want me to implement option A?”) before editing files.

Only implement changes when the user clearly requests it (e.g. “please implement”, “make the change”, “can you do X in the repo?”).

For any non-trivial task (anything that affects architecture, touches multiple layers/files, introduces a new subsystem, or changes a core contract):

- Brainstorm 1-3 viable approaches (with tradeoffs) before coding.
- Check whether a good solution already exists (repo patterns, Flame APIs, well-maintained packages) and prefer it when it fits the goals.
- Write a short plan (steps + acceptance criteria) and align on it before implementing.
- Ask clarifying questions when requirements are underspecified or multiple designs are plausible.

For trivial/surgical changes (tiny refactors, obvious bug fixes), proceed directly but keep changes minimal and consistent with existing patterns.

## Non-negotiable architecture

This project has **three hard layers**:

1. **Core (pure Dart simulation)**: deterministic gameplay + physics + AI + RNG
2. **Render (Flame)**: visuals only (sprites/animations/camera/parallax/VFX)
3. **UI (Flutter)**: menus, overlays, navigation, settings

Rules:

- **Core must not import Flutter or Flame.**
- Flame must not be authoritative for gameplay/collision.
- UI must not modify gameplay state directly; it sends **Commands** to the controller.
- The game must be embeddable: expose a reusable widget/route entrypoint; keep `lib/main.dart` as a dev host/demo only.

## Prefer existing solutions (when they fit the goals)

Before building something custom, check if a better solution already exists:

- In this repo (search for an existing pattern/component first)
- In Flame APIs (camera, viewport, parallax, input, effects)
- In well-maintained Dart/Flutter packages

Rule of thumb:

- Prefer Flame for *render concerns* (camera components, parallax rendering, effects).
- Prefer UI (Flutter) for *UI/input widgets* (joystick/buttons/menus/overlays).
- Prefer Core for *authoritative gameplay concerns* (movement/physics/collision, ability timing, damage rules), especially when determinism/networking is a goal.

## Determinism contract

- Simulation runs in **fixed ticks** (e.g. 60 Hz). Ticks are the only time authority.
- Inputs are **Commands** queued for a specific tick.
- RNG is seeded and owned by the Core. No wall-clock randomness.
- On app resume, clamp frame dt and **never** try to "catch up" thousands of ticks.

## Core data model

### Entity storage

- Use **SoA + SparseSet** per component type.
- Entity IDs are monotonic and **never reused**.

Iteration rules:

- Systems iterate via queries (no direct sparse/dense fiddling).
- Do not add/remove components or destroy entities mid-iteration. Queue structural changes and apply after system execution.
- Do not keep references to dense arrays across ticks.

### Snapshots & events

Core outputs:

- Immutable `GameStateSnapshot` for render/UI (serializable, renderer-friendly).
- Transient `GameEvent`s (spawn/despawn/hit/sfx/screenshake/reward, etc.).

Renderer/UI must:

- Treat snapshots as read-only.
- Interpolate visuals using (`prevSnapshot`, `currSnapshot`, `alpha`) but **never simulate**.

## World / camera / pixel-art rules

- Pick one **virtual resolution** (world units == virtual pixels).
- Use **integer scaling + letterboxing**. No fractional scaling, no shimmering.
- Snap camera + render positions to integer pixels inside the scaled viewport.

## Asset rules

- Assets are loaded **per scene**, not at boot.
- No asset loading during active gameplay.
- Unload game assets when leaving the mini-game route.

## Implementation sequencing

Follow the V0 plan (small, testable increments):

1. Scaffold + wiring (`lib/core`, `lib/game`, `lib/ui`)
2. Camera/viewport/parallax
3. Core collision + player run/jump
4. Mobile controls
5. Abilities/resources
6. Enemies (simple AI)
7. Deterministic spawning

If you deviate, explain why and keep the same boundaries.

## Code quality rules (Dart/Flutter)

- Keep the codebase modular and scalable:
  - prefer small, cohesive modules with clear boundaries
  - avoid tight coupling across Core/Render/UI; depend on stable contracts instead
  - keep public embedding API stable (`lib/runner.dart`), treat internal folders as refactorable
- Keep responsibilities narrow; avoid "god" classes that mix input/sim/render.
- Prefer explicit data flow: Commands in, snapshots/events out.
- Keep Core allocation-light: avoid per-tick new Lists/Maps in hot loops.
- Prefer `final`, `const`, and value types for small structs (e.g. `Vec2`).
- No `dynamic` in gameplay code (prefer typed payloads; if a temporary map is unavoidable, confine it to UI/debug only).
- Make side effects explicit: Core returns events; render/UI consume them.
- Keep changes consistent with existing style; avoid renames/reformatting unrelated code.
- Add/extend tests when relevant (especially when new behavior is introduced or existing behavior changes):
  - Core behavior: unit tests in `test/core/**` (`dart test`)
  - UI/viewport/widget behavior: widget tests where appropriate
- Keep docs in sync with code: update relevant docs whenever behavior, contracts, milestones, or public APIs change.

## What an agent must do on each task

When asked to implement/fix something:

1. Identify which layer it belongs to (Core vs Render vs UI).
2. Check for an existing solution/pattern that already fits the goal (repo + Flame + packages).
3. Propose a minimal plan (1-3 steps) and acceptance criteria.
4. Implement with deterministic rules intact.
5. Update docs/comments whenever a change affects behavior, contracts, milestones, or usage:
   - update `docs/plan.md` if architecture rules/contracts change
   - update `docs/v0-implementation-plan.md` if milestone checklist changes
   - update top-of-file docs and public API docs (`lib/runner.dart`, route/widget docs) when embedding/API expectations change
6. Add/extend relevant tests when new behavior is introduced or existing behavior changes (especially Core determinism and systems).
7. Provide:
   - files changed + why
   - how to run/verify (build + quick sanity checks)
   - follow-ups (next incremental step)

## What NOT to do

- Don't add Flutter/Flame imports into `lib/core/**`.
- Don't use Flame collision callbacks as gameplay truth.
- Don't introduce wall-clock timing in simulation (no `DateTime.now()`, no frame-dt gameplay).
- Don't "just make it work" by mixing UI/render/core responsibilities.

## Suggested folder layout

- `lib/core/`    - simulation, components, systems, RNG, commands, snapshots
- `lib/game/`    - Flame `Game`, entity view components, camera/parallax, render adapters
- `lib/ui/`      - menus, overlays, UI state, input widgets
- `test/`        - Core unit tests

---
If anything here conflicts with repo docs, treat repo docs as the source of truth.


===== FILE: lib/core/camera/v0_autoscroll_camera.dart =====
import '../util/smoothing.dart';
import '../util/double_math.dart';
import '../tuning/v0_camera_tuning.dart';

class V0CameraState {
  const V0CameraState({
    required this.centerX,
    required this.targetX,
    required this.speedX,
  });

  final double centerX;
  final double targetX;
  final double speedX;

  V0CameraState copyWith({
    double? centerX,
    double? targetX,
    double? speedX,
  }) {
    return V0CameraState(
      centerX: centerX ?? this.centerX,
      targetX: targetX ?? this.targetX,
      speedX: speedX ?? this.speedX,
    );
  }
}

/// Deterministic auto-scroll camera (Core).
///
/// Mirrors the reference behavior:
/// - baseline target speed with ease-in acceleration
/// - camera center eases toward a monotonic target X (never moves backward)
/// - player can pull the target forward only after passing a follow threshold
class V0AutoscrollCamera {
  V0AutoscrollCamera({
    required this.viewWidth,
    required V0CameraTuningDerived tuning,
    required V0CameraState initial,
  })  : _tuning = tuning,
        _state = initial;

  final double viewWidth;
  final V0CameraTuningDerived _tuning;

  V0CameraState get state => _state;
  V0CameraState _state;

  double left() => _state.centerX - viewWidth * 0.5;
  double right() => _state.centerX + viewWidth * 0.5;

  double followThresholdX() => left() + _tuning.followThresholdRatio * viewWidth;

  void updateTick({
    required double dtSeconds,
    required double? playerX,
  }) {
    final t = _tuning;

    var speedX = _state.speedX;
    if (speedX < t.targetSpeedX) {
      speedX = clampDouble(speedX + t.accelX * dtSeconds, 0.0, t.targetSpeedX);
    } else if (speedX > t.targetSpeedX) {
      speedX = clampDouble(speedX - t.accelX * dtSeconds, t.targetSpeedX, speedX);
    }

    var targetX = _state.targetX + speedX * dtSeconds;

    // If the player passes the follow threshold, allow the target to drift toward
    // the player (never decreases).
    if (playerX != null) {
      final threshold = followThresholdX();
      if (playerX > threshold) {
        final alphaT = expSmoothingFactor(t.targetCatchupLerp, dtSeconds);
        final newTarget = targetX + (playerX - targetX) * alphaT;
        targetX = targetX > newTarget ? targetX : newTarget;
      }
    }

    final alpha = expSmoothingFactor(t.catchupLerp, dtSeconds);
    var centerX = _state.centerX + (targetX - _state.centerX) * alpha;

    // Determinism/feel: camera never moves backward.
    if (centerX < _state.centerX) centerX = _state.centerX;
    if (targetX < _state.targetX) targetX = _state.targetX;

    _state = _state.copyWith(centerX: centerX, targetX: targetX, speedX: speedX);
  }
}


===== FILE: lib/core/collision/static_world_geometry.dart =====
/// Static collision geometry owned by the Core simulation.
///
/// V0 starts with a tiny, hand-authored set (ground band + a couple platforms),
/// and later milestones replace/extend this with deterministic chunk spawning.
class StaticGroundPlane {
  const StaticGroundPlane({required this.topY});

  /// World-space Y coordinate of the ground surface (solid top).
  final double topY;
}

class StaticSolid {
  const StaticSolid({
    required this.minX,
    required this.minY,
    required this.maxX,
    required this.maxY,
    this.sides = sideTop,
    this.oneWayTop = true,
    this.chunkIndex = noChunk,
    this.localSolidIndex = -1,
  }) : assert(maxX >= minX),
       assert(maxY >= minY);

  final double minX;
  final double minY;
  final double maxX;
  final double maxY;

  /// Which faces of this solid participate in collision resolution.
  ///
  /// For V0:
  /// - one-way platforms typically use `sideTop` only
  /// - obstacles typically use `sideAll`
  final int sides;

  /// If true, the top surface only collides while falling (platform behavior).
  ///
  /// This only applies when [sides] includes [sideTop].
  final bool oneWayTop;

  /// Chunk index this solid was generated from (streaming), or [noChunk] for
  /// base/static geometry.
  final int chunkIndex;

  /// Stable local index within the chunk pattern authoring list.
  ///
  /// If negative, callers should derive a stable index from the owning list.
  final int localSolidIndex;

  static const int sideNone = 0;
  static const int sideTop = 1 << 0;
  static const int sideBottom = 1 << 1;
  static const int sideLeft = 1 << 2;
  static const int sideRight = 1 << 3;
  static const int sideAll = sideTop | sideBottom | sideLeft | sideRight;

  /// Sentinel for solids not tied to a streamed chunk.
  static const int noChunk = -2;

  /// Reserved chunk index for always-on surfaces (e.g. ground plane).
  static const int groundChunk = -1;
}

/// Immutable bundle of static solids for a run/session.
class StaticWorldGeometry {
  const StaticWorldGeometry({
    this.groundPlane,
    this.solids = const <StaticSolid>[],
  });

  /// Optional infinite ground plane (top surface only).
  final StaticGroundPlane? groundPlane;

  final List<StaticSolid> solids;
}


===== FILE: lib/core/collision/static_world_geometry_index.dart =====
import 'static_world_geometry.dart';

/// Pre-indexed view of static world geometry for faster collision queries.
///
/// This is constructed once (per run/session) and preserves the original solid
/// ordering in each face list to keep behavior deterministic.
class StaticWorldGeometryIndex {
  StaticWorldGeometryIndex._({
    required this.geometry,
    required this.groundPlane,
    required this.tops,
    required this.bottoms,
    required this.leftWalls,
    required this.rightWalls,
  });

  factory StaticWorldGeometryIndex.from(StaticWorldGeometry geometry) {
    final tops = <StaticSolid>[];
    final bottoms = <StaticSolid>[];
    final leftWalls = <StaticSolid>[];
    final rightWalls = <StaticSolid>[];

    for (final solid in geometry.solids) {
      final sides = solid.sides;
      if ((sides & StaticSolid.sideTop) != 0) tops.add(solid);
      if ((sides & StaticSolid.sideBottom) != 0) bottoms.add(solid);
      if ((sides & StaticSolid.sideLeft) != 0) leftWalls.add(solid);
      if ((sides & StaticSolid.sideRight) != 0) rightWalls.add(solid);
    }

    return StaticWorldGeometryIndex._(
      geometry: geometry,
      groundPlane: geometry.groundPlane,
      tops: List<StaticSolid>.unmodifiable(tops),
      bottoms: List<StaticSolid>.unmodifiable(bottoms),
      leftWalls: List<StaticSolid>.unmodifiable(leftWalls),
      rightWalls: List<StaticSolid>.unmodifiable(rightWalls),
    );
  }

  /// Source geometry (unchanged).
  final StaticWorldGeometry geometry;

  /// Optional infinite ground plane.
  final StaticGroundPlane? groundPlane;

  /// Solids with an enabled top face.
  final List<StaticSolid> tops;

  /// Solids with an enabled bottom face (ceilings).
  final List<StaticSolid> bottoms;

  /// Solids with an enabled left face (walls hit when moving right).
  final List<StaticSolid> leftWalls;

  /// Solids with an enabled right face (walls hit when moving left).
  final List<StaticSolid> rightWalls;
}


===== FILE: lib/core/combat/damage.dart =====
import '../ecs/entity_id.dart';

class DamageRequest {
  const DamageRequest({
    required this.target,
    required this.amount,
    this.source,
  });

  final EntityId target;
  final double amount;
  final EntityId? source;
}



===== FILE: lib/core/combat/faction.dart =====
enum Faction { player, enemy }



===== FILE: lib/core/commands/command.dart =====
/// Core input command model.
///
/// Commands are the only way UI can affect the simulation:
/// UI -> `GameController.enqueue(...)` -> Core applies them at a specific `tick`.
///
/// These command types are intentionally minimal placeholders for Milestone 0.
sealed class Command {
  const Command({required this.tick});

  /// Simulation tick at which this command must be applied.
  final int tick;
}

/// Player movement input for the given tick.
///
/// `axis` is typically in `[-1, 1]` (left/right), originating from a joystick.
final class MoveAxisCommand extends Command {
  const MoveAxisCommand({required super.tick, required this.axis});

  /// Horizontal movement axis, usually in `[-1, 1]`.
  final double axis;
}

/// One-shot jump press event for the given tick.
final class JumpPressedCommand extends Command {
  const JumpPressedCommand({required super.tick});
}

/// One-shot dash press event for the given tick.
final class DashPressedCommand extends Command {
  const DashPressedCommand({required super.tick});
}

/// One-shot attack press event for the given tick.
final class AttackPressedCommand extends Command {
  const AttackPressedCommand({required super.tick});
}

/// Continuous aim direction for the given tick.
///
/// The direction should be normalized (or near-normalized). It is expressed in
/// world space and used by casting/abilities.
final class AimDirCommand extends Command {
  const AimDirCommand({required super.tick, required this.x, required this.y});

  final double x;
  final double y;
}

/// Clears any held aim direction for the given tick.
///
/// This exists so input schedulers that pre-buffer future ticks can overwrite
/// previously-scheduled aim commands when the player releases aim input.
final class ClearAimDirCommand extends Command {
  const ClearAimDirCommand({required super.tick});
}

/// One-shot cast press event for the given tick.
final class CastPressedCommand extends Command {
  const CastPressedCommand({required super.tick});
}


===== FILE: lib/core/contracts/v0_render_contract.dart =====
/// V0 render + coordinate contract shared across layers.
///
/// These values are intentionally defined in `lib/core/**` (pure Dart) so Core,
/// Render (Flame), and UI (Flutter) can all agree on the same coordinate system
/// without introducing Flutter/Flame dependencies into the simulation.
///
/// V0 rules:
/// - Virtual resolution is fixed at 480×270 (16:9).
/// - 1 world unit == 1 virtual pixel.
/// - Axes/origin follow Flutter/Flame conventions: (0,0) top-left, +X right,
///   +Y down.
/// - Camera uses a fixed-resolution viewport and integer snapping.
///
/// Ground reference:
/// - The parallax set assets are 512×256.
/// - For `Field Layer 09.png`, the first non-transparent row starts at Y=241
///   within the image (measured from the asset in this repo).
/// - When bottom-aligning the 256px image into a 270px viewport, Y offset is
///   (270 - 256) = 14, therefore `v0GroundTopY = 14 + 241 = 255`.
const int v0VirtualWidth = 480;
const int v0VirtualHeight = 270;

const int v0FieldLayerImageWidth = 512;
const int v0FieldLayerImageHeight = 256;

const int v0FieldLayerBottomAlignedOffsetY =
    v0VirtualHeight - v0FieldLayerImageHeight; // 14

const int v0FieldLayer09OpaqueTopInImageY = 241;
const int v0GroundTopY =
    v0FieldLayerBottomAlignedOffsetY + v0FieldLayer09OpaqueTopInImageY; // 255

const double v0CameraFixedY = v0VirtualHeight / 2; // 135.0



===== FILE: lib/core/ecs/entity_id.dart =====
/// Opaque identifier for entities in the Core simulation.
///
/// Entity IDs are monotonic and never reused within a session.
typedef EntityId = int;


===== FILE: lib/core/ecs/hit/aabb_hit_utils.dart =====
import '../../combat/faction.dart';
import '../entity_id.dart';
import '../world.dart';

// Shared helpers for hit resolution math + filtering.
//
// IMPORTANT:
// - Keep these helpers allocation-free and deterministic.
// - Systems still own iteration/selection rules (e.g. "first hit wins") until
//   Milestone 10 (Hit Resolution Module).

bool isFriendlyFire(Faction a, Faction b) => a == b;

/// Per-tick cache of "damageable collider targets" to reduce repeated sparse
/// lookups in hot loops.
///
/// A target is included iff it has:
/// - `HealthStore` (source list)
/// - `FactionStore` (for friendly-fire filtering)
/// - `TransformStore` + `ColliderAabbStore` (for overlap tests)
///
/// Determinism: preserves `HealthStore.denseEntities` iteration order.
class DamageableTargetCache {
  final List<EntityId> entities = <EntityId>[];
  final List<Faction> factions = <Faction>[];

  // World-space collider center and half extents.
  final List<double> centerX = <double>[];
  final List<double> centerY = <double>[];
  final List<double> halfX = <double>[];
  final List<double> halfY = <double>[];

  int get length => entities.length;
  bool get isEmpty => entities.isEmpty;

  void rebuild(EcsWorld world) {
    entities.clear();
    factions.clear();
    centerX.clear();
    centerY.clear();
    halfX.clear();
    halfY.clear();

    final health = world.health;
    if (health.denseEntities.isEmpty) return;

    for (var i = 0; i < health.denseEntities.length; i += 1) {
      final e = health.denseEntities[i];

      final fi = world.faction.tryIndexOf(e);
      if (fi == null) continue;
      final ti = world.transform.tryIndexOf(e);
      if (ti == null) continue;
      final aabbi = world.colliderAabb.tryIndexOf(e);
      if (aabbi == null) continue;

      final cx = world.transform.posX[ti] + world.colliderAabb.offsetX[aabbi];
      final cy = world.transform.posY[ti] + world.colliderAabb.offsetY[aabbi];

      entities.add(e);
      factions.add(world.faction.faction[fi]);
      centerX.add(cx);
      centerY.add(cy);
      halfX.add(world.colliderAabb.halfX[aabbi]);
      halfY.add(world.colliderAabb.halfY[aabbi]);
    }
  }
}

bool aabbOverlapsMinMax({
  required double aMinX,
  required double aMaxX,
  required double aMinY,
  required double aMaxY,
  required double bMinX,
  required double bMaxX,
  required double bMinY,
  required double bMaxY,
}) {
  return aMinX < bMaxX && aMaxX > bMinX && aMinY < bMaxY && aMaxY > bMinY;
}

bool aabbOverlapsCenters({
  required double aCenterX,
  required double aCenterY,
  required double aHalfX,
  required double aHalfY,
  required double bCenterX,
  required double bCenterY,
  required double bHalfX,
  required double bHalfY,
}) {
  return aabbOverlapsMinMax(
    aMinX: aCenterX - aHalfX,
    aMaxX: aCenterX + aHalfX,
    aMinY: aCenterY - aHalfY,
    aMaxY: aCenterY + aHalfY,
    bMinX: bCenterX - bHalfX,
    bMaxX: bCenterX + bHalfX,
    bMinY: bCenterY - bHalfY,
    bMaxY: bCenterY + bHalfY,
  );
}

/// AABB overlap between two entities whose AABBs are defined by
/// `Transform` + `ColliderAabb`.
bool aabbOverlapsWorldColliders(
  EcsWorld world, {
  required int aTransformIndex,
  required int aAabbIndex,
  required int bTransformIndex,
  required int bAabbIndex,
}) {
  final aCenterX = world.transform.posX[aTransformIndex] +
      world.colliderAabb.offsetX[aAabbIndex];
  final aCenterY = world.transform.posY[aTransformIndex] +
      world.colliderAabb.offsetY[aAabbIndex];
  final aHalfX = world.colliderAabb.halfX[aAabbIndex];
  final aHalfY = world.colliderAabb.halfY[aAabbIndex];

  final bCenterX = world.transform.posX[bTransformIndex] +
      world.colliderAabb.offsetX[bAabbIndex];
  final bCenterY = world.transform.posY[bTransformIndex] +
      world.colliderAabb.offsetY[bAabbIndex];
  final bHalfX = world.colliderAabb.halfX[bAabbIndex];
  final bHalfY = world.colliderAabb.halfY[bAabbIndex];

  return aabbOverlapsCenters(
    aCenterX: aCenterX,
    aCenterY: aCenterY,
    aHalfX: aHalfX,
    aHalfY: aHalfY,
    bCenterX: bCenterX,
    bCenterY: bCenterY,
    bHalfX: bHalfX,
    bHalfY: bHalfY,
  );
}


===== FILE: lib/core/ecs/hit/hit_resolver.dart =====
import '../../combat/faction.dart';
import '../entity_id.dart';
import '../spatial/broadphase_grid.dart';
import 'aabb_hit_utils.dart';

/// Shared narrowphase + deterministic hit candidate ordering.
///
/// Responsibilities:
/// - broadphase query
/// - filtering (owner exclusion + friendly-fire)
/// - AABB overlap test
/// - deterministic ordering (EntityId ascending)
///
/// Non-responsibilities:
/// - world mutation (damage, despawns, HitOnce marking)
class HitResolver {
  final List<int> _candidates = <int>[];

  /// Returns an ordered list of target indices (into `broadphase.targets`) that
  /// overlap the query AABB and pass filtering rules.
  ///
  /// Determinism: targets are always returned in `EntityId` ascending order.
  void collectOrderedOverlapsCenters({
    required BroadphaseGrid broadphase,
    required double centerX,
    required double centerY,
    required double halfX,
    required double halfY,
    required EntityId owner,
    required Faction sourceFaction,
    required List<int> outTargetIndices,
  }) {
    broadphase.queryAabbMinMax(
      minX: centerX - halfX,
      minY: centerY - halfY,
      maxX: centerX + halfX,
      maxY: centerY + halfY,
      outTargetIndices: _candidates,
    );

    outTargetIndices.clear();
    if (_candidates.isEmpty) return;

    _sortCandidatesByEntityId(broadphase);

    for (var i = 0; i < _candidates.length; i += 1) {
      final targetIndex = _candidates[i];
      final target = broadphase.targets.entities[targetIndex];
      if (target == owner) continue;

      if (isFriendlyFire(sourceFaction, broadphase.targets.factions[targetIndex])) {
        continue;
      }

      if (!aabbOverlapsCenters(
        aCenterX: centerX,
        aCenterY: centerY,
        aHalfX: halfX,
        aHalfY: halfY,
        bCenterX: broadphase.targets.centerX[targetIndex],
        bCenterY: broadphase.targets.centerY[targetIndex],
        bHalfX: broadphase.targets.halfX[targetIndex],
        bHalfY: broadphase.targets.halfY[targetIndex],
      )) {
        continue;
      }

      outTargetIndices.add(targetIndex);
    }
  }

  /// Returns the first overlapping target index (into `broadphase.targets`) in
  /// deterministic order, or null if there is no hit.
  int? firstOrderedOverlapCenters({
    required BroadphaseGrid broadphase,
    required double centerX,
    required double centerY,
    required double halfX,
    required double halfY,
    required EntityId owner,
    required Faction sourceFaction,
  }) {
    broadphase.queryAabbMinMax(
      minX: centerX - halfX,
      minY: centerY - halfY,
      maxX: centerX + halfX,
      maxY: centerY + halfY,
      outTargetIndices: _candidates,
    );
    if (_candidates.isEmpty) return null;

    _sortCandidatesByEntityId(broadphase);

    for (var i = 0; i < _candidates.length; i += 1) {
      final targetIndex = _candidates[i];
      final target = broadphase.targets.entities[targetIndex];
      if (target == owner) continue;

      if (isFriendlyFire(sourceFaction, broadphase.targets.factions[targetIndex])) {
        continue;
      }

      if (!aabbOverlapsCenters(
        aCenterX: centerX,
        aCenterY: centerY,
        aHalfX: halfX,
        aHalfY: halfY,
        bCenterX: broadphase.targets.centerX[targetIndex],
        bCenterY: broadphase.targets.centerY[targetIndex],
        bHalfX: broadphase.targets.halfX[targetIndex],
        bHalfY: broadphase.targets.halfY[targetIndex],
      )) {
        continue;
      }

      return targetIndex;
    }

    return null;
  }

  void _sortCandidatesByEntityId(BroadphaseGrid broadphase) {
    _candidates.sort(
      (a, b) => broadphase.targets.entities[a].compareTo(
        broadphase.targets.entities[b],
      ),
    );
  }
}


===== FILE: lib/core/ecs/queries.dart =====
import 'entity_id.dart';
import 'world.dart';

typedef MovementQueryFn =
    void Function(EntityId e, int mi, int ti, int ii, int bi, int ci, int si);

typedef ColliderQueryFn =
    void Function(EntityId e, int ti, int bi, int coli, int aabbi);

class EcsQueries {
  static void forMovementBodies(EcsWorld world, MovementQueryFn fn) {
    final movement = world.movement;
    final entities = movement.denseEntities;

    for (var mi = 0; mi < entities.length; mi += 1) {
      final e = entities[mi];

      final ti = world.transform.tryIndexOf(e);
      if (ti == null) continue;
      final ii = world.playerInput.tryIndexOf(e);
      if (ii == null) continue;
      final bi = world.body.tryIndexOf(e);
      if (bi == null) continue;
      final ci = world.collision.tryIndexOf(e);
      if (ci == null) continue;
      final si = world.stamina.tryIndexOf(e);
      if (si == null) continue;

      fn(e, mi, ti, ii, bi, ci, si);
    }
  }

  static void forColliders(EcsWorld world, ColliderQueryFn fn) {
    final aabb = world.colliderAabb;
    final entities = aabb.denseEntities;

    for (var aabbi = 0; aabbi < entities.length; aabbi += 1) {
      final e = entities[aabbi];

      final ti = world.transform.tryIndexOf(e);
      if (ti == null) continue;
      final bi = world.body.tryIndexOf(e);
      if (bi == null) continue;
      final coli = world.collision.tryIndexOf(e);
      if (coli == null) continue;

      fn(e, ti, bi, coli, aabbi);
    }
  }
}


===== FILE: lib/core/ecs/sparse_set.dart =====
import 'entity_id.dart';

/// Base sparse-set bookkeeping for component stores.
///
/// - `sparse[entity]` stores (denseIndex + 1), or 0 when absent.
/// - `denseEntities[denseIndex]` stores the owning [EntityId].
///
/// This enables:
/// - O(1) contains
/// - O(1) add/remove (swap-remove)
/// - cache-friendly iteration over `denseEntities`
abstract class SparseSet {
  final List<EntityId> denseEntities = <EntityId>[];
  final List<int> _sparse = <int>[];

  bool has(EntityId entity) {
    if (entity < 0) return false;
    if (entity >= _sparse.length) return false;
    return _sparse[entity] != 0;
  }

  int indexOf(EntityId entity) {
    final idxPlus1 = _sparse[entity];
    return idxPlus1 - 1;
  }

  int? tryIndexOf(EntityId entity) {
    if (!has(entity)) return null;
    return indexOf(entity);
  }

  void ensureCapacity(EntityId entity) {
    if (entity < _sparse.length) return;
    final toAdd = entity + 1 - _sparse.length;
    if (toAdd <= 0) return;
    _sparse.addAll(List<int>.filled(toAdd, 0));
  }

  int addEntity(EntityId entity) {
    ensureCapacity(entity);
    final existing = _sparse[entity];
    if (existing != 0) return existing - 1;

    final denseIndex = denseEntities.length;
    denseEntities.add(entity);
    _sparse[entity] = denseIndex + 1;
    onDenseAdded(denseIndex);
    return denseIndex;
  }

  void removeEntity(EntityId entity) {
    if (!has(entity)) return;

    final removeIndex = indexOf(entity);
    final lastIndex = denseEntities.length - 1;

    onSwapRemove(removeIndex, lastIndex);

    final lastEntity = denseEntities[lastIndex];
    denseEntities[removeIndex] = lastEntity;
    denseEntities.removeLast();

    _sparse[entity] = 0;
    if (removeIndex != lastIndex) {
      _sparse[lastEntity] = removeIndex + 1;
    }
  }

  /// Called after a new dense slot has been appended.
  void onDenseAdded(int denseIndex);

  /// Called before dense arrays are swap-removed from [removeIndex] and [lastIndex].
  void onSwapRemove(int removeIndex, int lastIndex);
}


===== FILE: lib/core/ecs/spatial/broadphase_grid.dart =====
import '../hit/aabb_hit_utils.dart';
import '../world.dart';
import 'grid_index_2d.dart';

/// Deterministic broadphase grid rebuilt each tick from dynamic damageable AABBs.
///
/// Buckets store indices into `targets` (not EntityIds) to avoid repeated sparse
/// lookups during hit queries.
class BroadphaseGrid {
  BroadphaseGrid({required GridIndex2D index}) : _index = index;

  final GridIndex2D _index;
  final DamageableTargetCache targets = DamageableTargetCache();

  // cellKey -> list of target indices into `targets`.
  final Map<int, List<int>> _buckets = <int, List<int>>{};
  final List<int> _activeKeys = <int>[];
  final List<List<int>> _bucketPool = <List<int>>[];

  // Per-query dedup for targets that span multiple cells.
  final List<int> _seenStampByTargetIndex = <int>[];
  int _stamp = 0;

  void rebuild(EcsWorld world) {
    targets.rebuild(world);

    // Keep the map bounded to "active" cells (avoid unbounded growth as the
    // world scrolls). Reuse lists via a small pool to reduce allocations.
    for (var i = 0; i < _activeKeys.length; i += 1) {
      final key = _activeKeys[i];
      final bucket = _buckets.remove(key);
      if (bucket == null) continue;
      bucket.clear();
      _bucketPool.add(bucket);
    }
    _activeKeys.clear();

    if (targets.isEmpty) return;

    for (var ti = 0; ti < targets.length; ti += 1) {
      final cx = targets.centerX[ti];
      final cy = targets.centerY[ti];
      final hx = targets.halfX[ti];
      final hy = targets.halfY[ti];

      final minX = cx - hx;
      final maxX = cx + hx;
      final minY = cy - hy;
      final maxY = cy + hy;

      final minCx = _index.worldToCellX(minX);
      final maxCx = _index.worldToCellX(maxX);
      final minCy = _index.worldToCellY(minY);
      final maxCy = _index.worldToCellY(maxY);

      for (var cellY = minCy; cellY <= maxCy; cellY += 1) {
        for (var cellX = minCx; cellX <= maxCx; cellX += 1) {
          final key = _index.cellKey(cellX, cellY);
          var bucket = _buckets[key];
          if (bucket == null) {
            bucket = _bucketPool.isNotEmpty ? _bucketPool.removeLast() : <int>[];
            _buckets[key] = bucket;
            _activeKeys.add(key);
          }
          bucket.add(ti);
        }
      }
    }
  }

  /// Fills [outTargetIndices] with unique target indices whose AABBs may overlap
  /// the query AABB.
  ///
  /// IMPORTANT (determinism):
  /// - Cell scan order is stable (y then x, increasing).
  /// - Callers must sort by `targets.entities[targetIndex]` if they need a stable
  ///   per-query hit selection order.
  void queryAabbMinMax({
    required double minX,
    required double minY,
    required double maxX,
    required double maxY,
    required List<int> outTargetIndices,
  }) {
    outTargetIndices.clear();
    if (targets.isEmpty) return;

    _stamp += 1;

    // Avoid stamp overflow affecting correctness.
    if (_stamp == 0x7FFFFFFF) {
      for (var i = 0; i < _seenStampByTargetIndex.length; i += 1) {
        _seenStampByTargetIndex[i] = 0;
      }
      _stamp = 1;
    }

    final minCx = _index.worldToCellX(minX);
    final maxCx = _index.worldToCellX(maxX);
    final minCy = _index.worldToCellY(minY);
    final maxCy = _index.worldToCellY(maxY);

    if (_seenStampByTargetIndex.length < targets.length) {
      final missing = targets.length - _seenStampByTargetIndex.length;
      for (var i = 0; i < missing; i += 1) {
        _seenStampByTargetIndex.add(0);
      }
    }

    for (var cellY = minCy; cellY <= maxCy; cellY += 1) {
      for (var cellX = minCx; cellX <= maxCx; cellX += 1) {
        final key = _index.cellKey(cellX, cellY);
        final bucket = _buckets[key];
        if (bucket == null || bucket.isEmpty) continue;

        for (var bi = 0; bi < bucket.length; bi += 1) {
          final targetIndex = bucket[bi];
          if (_seenStampByTargetIndex[targetIndex] == _stamp) continue;
          _seenStampByTargetIndex[targetIndex] = _stamp;
          outTargetIndices.add(targetIndex);
        }
      }
    }
  }
}


===== FILE: lib/core/ecs/spatial/grid_index_2d.dart =====
import '../../math/vec2.dart';

class CellAabb {
  const CellAabb({
    required this.minX,
    required this.minY,
    required this.maxX,
    required this.maxY,
  });

  final double minX;
  final double minY;
  final double maxX;
  final double maxY;
}

/// Generic 2D grid math + hashing utility.
///
/// This is intentionally reusable for both:
/// - dynamic broadphase buckets (Milestone 9), and
/// - future nav/cost grids (later milestone).
///
/// IMPORTANT (determinism):
/// - `cellKey(cx, cy)` must be stable and must not use Dart `hashCode`.
class GridIndex2D {
  GridIndex2D({required this.cellSize}) : invCellSize = 1.0 / cellSize;

  final double cellSize;
  final double invCellSize;

  int worldToCellX(double x) => (x * invCellSize).floor();
  int worldToCellY(double y) => (y * invCellSize).floor();

  Vec2 cellToWorldMin(int cx, int cy) => Vec2(cx * cellSize, cy * cellSize);

  CellAabb cellAabb(int cx, int cy) {
    final minX = cx * cellSize;
    final minY = cy * cellSize;
    return CellAabb(
      minX: minX,
      minY: minY,
      maxX: minX + cellSize,
      maxY: minY + cellSize,
    );
  }

  /// Packs signed (cx, cy) into a single int key (two 32-bit lanes).
  int cellKey(int cx, int cy) {
    final ux = (cx ^ 0x80000000) & 0xFFFFFFFF;
    final uy = (cy ^ 0x80000000) & 0xFFFFFFFF;
    return (uy << 32) | ux;
  }

  void forNeighbors(
    int cx,
    int cy, {
    bool diagonal = false,
    required void Function(int nx, int ny) visit,
  }) {
    // Stable order (N, W, E, S), then diagonals (NW, NE, SW, SE).
    visit(cx, cy - 1);
    visit(cx - 1, cy);
    visit(cx + 1, cy);
    visit(cx, cy + 1);

    if (!diagonal) return;
    visit(cx - 1, cy - 1);
    visit(cx + 1, cy - 1);
    visit(cx - 1, cy + 1);
    visit(cx + 1, cy + 1);
  }
}



===== FILE: lib/core/ecs/stores/body_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

/// Configuration for how an entity participates in physics.
///
/// This is intentionally "config-like" and reusable across players/enemies:
/// - `Transform` holds state (pos/vel)
/// - `Movement` holds controller-specific timers/state (coyote, dash, etc.)
/// - `Body` holds physics participation and constraints (gravity, clamps, kinematic)
class BodyDef {
  const BodyDef({
    this.enabled = true,
    this.isKinematic = false,
    this.useGravity = true,
    this.ignoreCeilings = false,
    this.topOnlyGround = true,
    this.gravityScale = 1.0,
    this.maxVelX = 3000,
    this.maxVelY = 3000,
    this.sideMask = sideLeft | sideRight,
  });

  /// Master on/off switch for physics on this entity.
  final bool enabled;

  /// If true, physics does not integrate position/velocity (gameplay code drives it).
  final bool isKinematic;

  /// Whether gravity affects this body.
  final bool useGravity;

  /// If true, upward motion ignores bottom faces (ceilings).
  final bool ignoreCeilings;

  /// If true, collision should resolve only top contacts (platformer-style).
  /// Used by `CollisionSystem` (later milestone).
  final bool topOnlyGround;

  /// Scale applied to global/tuning gravity (1.0 = normal gravity).
  final double gravityScale;

  /// Per-axis velocity clamps (safety caps).
  final double maxVelX;
  final double maxVelY;

  /// Horizontal collision sides bitmask (used by `CollisionSystem` later).
  final int sideMask;

  static const int sideNone = 0;
  static const int sideLeft = 1 << 0;
  static const int sideRight = 1 << 1;
}

/// SoA store for `Body` configuration.
class BodyStore extends SparseSet {
  final List<bool> enabled = <bool>[];
  final List<bool> isKinematic = <bool>[];
  final List<bool> useGravity = <bool>[];
  final List<bool> ignoreCeilings = <bool>[];
  final List<bool> topOnlyGround = <bool>[];

  final List<double> gravityScale = <double>[];
  final List<double> maxVelX = <double>[];
  final List<double> maxVelY = <double>[];

  final List<int> sideMask = <int>[];

  void add(EntityId entity, BodyDef def) {
    final i = addEntity(entity);
    enabled[i] = def.enabled;
    isKinematic[i] = def.isKinematic;
    useGravity[i] = def.useGravity;
    ignoreCeilings[i] = def.ignoreCeilings;
    topOnlyGround[i] = def.topOnlyGround;
    gravityScale[i] = def.gravityScale;
    maxVelX[i] = def.maxVelX;
    maxVelY[i] = def.maxVelY;
    sideMask[i] = def.sideMask;
  }

  @override
  void onDenseAdded(int denseIndex) {
    enabled.add(true);
    isKinematic.add(false);
    useGravity.add(true);
    ignoreCeilings.add(false);
    topOnlyGround.add(true);
    gravityScale.add(1);
    maxVelX.add(3000);
    maxVelY.add(3000);
    sideMask.add(BodyDef.sideNone);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    enabled[removeIndex] = enabled[lastIndex];
    isKinematic[removeIndex] = isKinematic[lastIndex];
    useGravity[removeIndex] = useGravity[lastIndex];
    ignoreCeilings[removeIndex] = ignoreCeilings[lastIndex];
    topOnlyGround[removeIndex] = topOnlyGround[lastIndex];
    gravityScale[removeIndex] = gravityScale[lastIndex];
    maxVelX[removeIndex] = maxVelX[lastIndex];
    maxVelY[removeIndex] = maxVelY[lastIndex];
    sideMask[removeIndex] = sideMask[lastIndex];

    enabled.removeLast();
    isKinematic.removeLast();
    useGravity.removeLast();
    ignoreCeilings.removeLast();
    topOnlyGround.removeLast();
    gravityScale.removeLast();
    maxVelX.removeLast();
    maxVelY.removeLast();
    sideMask.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/cast_intent_store.dart =====
import '../../spells/spell_id.dart';
import '../entity_id.dart';
import '../sparse_set.dart';

class CastIntentDef {
  const CastIntentDef({
    required this.spellId,
    required this.dirX,
    required this.dirY,
    required this.fallbackDirX,
    required this.fallbackDirY,
    required this.originOffset,
    required this.cooldownTicks,
    required this.tick,
  });

  final SpellId spellId;
  final double dirX;
  final double dirY;
  final double fallbackDirX;
  final double fallbackDirY;
  final double originOffset;
  final int cooldownTicks;

  /// Tick stamp for this intent.
  ///
  /// Use `-1` for "no intent". An intent is valid only when `tick == currentTick`.
  final int tick;
}

/// Per-entity "cast a spell this tick" intent.
///
/// This is written by player/enemy intent writers and consumed by `SpellCastSystem`.
class CastIntentStore extends SparseSet {
  final List<SpellId> spellId = <SpellId>[];
  final List<double> dirX = <double>[];
  final List<double> dirY = <double>[];
  final List<double> fallbackDirX = <double>[];
  final List<double> fallbackDirY = <double>[];
  final List<double> originOffset = <double>[];
  final List<int> cooldownTicks = <int>[];
  final List<int> tick = <int>[];

  void add(EntityId entity) {
    addEntity(entity);
  }

  void set(EntityId entity, CastIntentDef def) {
    assert(
      has(entity),
      'CastIntentStore.set called for entity without CastIntentStore; add the component at spawn time.',
    );
    final i = indexOf(entity);
    spellId[i] = def.spellId;
    dirX[i] = def.dirX;
    dirY[i] = def.dirY;
    fallbackDirX[i] = def.fallbackDirX;
    fallbackDirY[i] = def.fallbackDirY;
    originOffset[i] = def.originOffset;
    cooldownTicks[i] = def.cooldownTicks;
    tick[i] = def.tick;
  }

  @override
  void onDenseAdded(int denseIndex) {
    spellId.add(SpellId.iceBolt);
    dirX.add(0.0);
    dirY.add(0.0);
    fallbackDirX.add(1.0);
    fallbackDirY.add(0.0);
    originOffset.add(0.0);
    cooldownTicks.add(0);
    tick.add(-1);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    spellId[removeIndex] = spellId[lastIndex];
    dirX[removeIndex] = dirX[lastIndex];
    dirY[removeIndex] = dirY[lastIndex];
    fallbackDirX[removeIndex] = fallbackDirX[lastIndex];
    fallbackDirY[removeIndex] = fallbackDirY[lastIndex];
    originOffset[removeIndex] = originOffset[lastIndex];
    cooldownTicks[removeIndex] = cooldownTicks[lastIndex];
    tick[removeIndex] = tick[lastIndex];

    spellId.removeLast();
    dirX.removeLast();
    dirY.removeLast();
    fallbackDirX.removeLast();
    fallbackDirY.removeLast();
    originOffset.removeLast();
    cooldownTicks.removeLast();
    tick.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/collider_aabb_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

/// AABB collider configuration for an entity.
///
/// Representation is center-based for stability:
/// - `Transform.pos` is treated as the entity center
/// - collider center is `pos + offset`
/// - extents are half-sizes in world units (virtual pixels)
class ColliderAabbDef {
  const ColliderAabbDef({
    required this.halfX,
    required this.halfY,
    this.offsetX = 0,
    this.offsetY = 0,
  });

  final double halfX;
  final double halfY;
  final double offsetX;
  final double offsetY;
}

/// SoA store for AABB collider config (half extents + offset).
class ColliderAabbStore extends SparseSet {
  final List<double> halfX = <double>[];
  final List<double> halfY = <double>[];
  final List<double> offsetX = <double>[];
  final List<double> offsetY = <double>[];

  void add(EntityId entity, ColliderAabbDef def) {
    final i = addEntity(entity);
    halfX[i] = def.halfX;
    halfY[i] = def.halfY;
    offsetX[i] = def.offsetX;
    offsetY[i] = def.offsetY;
  }

  @override
  void onDenseAdded(int denseIndex) {
    halfX.add(0);
    halfY.add(0);
    offsetX.add(0);
    offsetY.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    halfX[removeIndex] = halfX[lastIndex];
    halfY[removeIndex] = halfY[lastIndex];
    offsetX[removeIndex] = offsetX[lastIndex];
    offsetY[removeIndex] = offsetY[lastIndex];

    halfX.removeLast();
    halfY.removeLast();
    offsetX.removeLast();
    offsetY.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/collision_state_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

/// Per-tick collision results for an entity.
///
/// This is reset each tick by the CollisionSystem.
class CollisionStateStore extends SparseSet {
  final List<bool> grounded = <bool>[];
  final List<bool> hitCeiling = <bool>[];
  final List<bool> hitLeft = <bool>[];
  final List<bool> hitRight = <bool>[];

  void add(EntityId entity) {
    addEntity(entity);
  }

  void resetTick(EntityId entity) {
    final i = indexOf(entity);
    grounded[i] = false;
    hitCeiling[i] = false;
    hitLeft[i] = false;
    hitRight[i] = false;
  }

  @override
  void onDenseAdded(int denseIndex) {
    grounded.add(false);
    hitCeiling.add(false);
    hitLeft.add(false);
    hitRight.add(false);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    grounded[removeIndex] = grounded[lastIndex];
    hitCeiling[removeIndex] = hitCeiling[lastIndex];
    hitLeft[removeIndex] = hitLeft[lastIndex];
    hitRight[removeIndex] = hitRight[lastIndex];

    grounded.removeLast();
    hitCeiling.removeLast();
    hitLeft.removeLast();
    hitRight.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/cooldown_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

class CooldownDef {
  const CooldownDef({
    this.castCooldownTicksLeft = 0,
    this.meleeCooldownTicksLeft = 0,
  });

  final int castCooldownTicksLeft;
  final int meleeCooldownTicksLeft;
}

class CooldownStore extends SparseSet {
  final List<int> castCooldownTicksLeft = <int>[];
  final List<int> meleeCooldownTicksLeft = <int>[];

  void add(EntityId entity, [CooldownDef def = const CooldownDef()]) {
    final i = addEntity(entity);
    castCooldownTicksLeft[i] = def.castCooldownTicksLeft;
    meleeCooldownTicksLeft[i] = def.meleeCooldownTicksLeft;
  }

  @override
  void onDenseAdded(int denseIndex) {
    castCooldownTicksLeft.add(0);
    meleeCooldownTicksLeft.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    castCooldownTicksLeft[removeIndex] = castCooldownTicksLeft[lastIndex];
    meleeCooldownTicksLeft[removeIndex] = meleeCooldownTicksLeft[lastIndex];
    castCooldownTicksLeft.removeLast();
    meleeCooldownTicksLeft.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/enemy_store.dart =====
import '../../enemies/enemy_id.dart';
import '../../snapshots/enums.dart';
import '../entity_id.dart';
import '../sparse_set.dart';

class EnemyDef {
  const EnemyDef({
    required this.enemyId,
    this.facing = Facing.left,
  });

  final EnemyId enemyId;
  final Facing facing;
}

/// Minimal enemy marker + per-enemy state (expanded in Milestone 7).
class EnemyStore extends SparseSet {
  final List<EnemyId> enemyId = <EnemyId>[];
  final List<Facing> facing = <Facing>[];

  void add(EntityId entity, EnemyDef def) {
    final i = addEntity(entity);
    enemyId[i] = def.enemyId;
    facing[i] = def.facing;
  }

  @override
  void onDenseAdded(int denseIndex) {
    enemyId.add(EnemyId.flyingEnemy);
    facing.add(Facing.left);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    enemyId[removeIndex] = enemyId[lastIndex];
    facing[removeIndex] = facing[lastIndex];

    enemyId.removeLast();
    facing.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/faction_store.dart =====
import '../../combat/faction.dart';
import '../entity_id.dart';
import '../sparse_set.dart';

class FactionDef {
  const FactionDef({required this.faction});

  final Faction faction;
}

class FactionStore extends SparseSet {
  final List<Faction> faction = <Faction>[];

  void add(EntityId entity, FactionDef def) {
    final i = addEntity(entity);
    faction[i] = def.faction;
  }

  @override
  void onDenseAdded(int denseIndex) {
    faction.add(Faction.player);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    faction[removeIndex] = faction[lastIndex];
    faction.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/flying_enemy_steering_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

class FlyingEnemySteeringDef {
  const FlyingEnemySteeringDef({
    required this.rngState,
  });

  final int rngState;
}

/// Per flying enemy steering state for deterministic hover behavior.
class FlyingEnemySteeringStore extends SparseSet {
  final List<int> rngState = <int>[];
  final List<bool> initialized = <bool>[];
  final List<double> desiredRange = <double>[];
  final List<double> desiredRangeHoldLeftS = <double>[];
  final List<double> flightTargetAboveGround = <double>[];
  final List<double> flightTargetHoldLeftS = <double>[];

  void add(EntityId entity, FlyingEnemySteeringDef def) {
    final i = addEntity(entity);
    rngState[i] = def.rngState;
    initialized[i] = false;
    desiredRange[i] = 0.0;
    desiredRangeHoldLeftS[i] = 0.0;
    flightTargetAboveGround[i] = 0.0;
    flightTargetHoldLeftS[i] = 0.0;
  }

  @override
  void onDenseAdded(int denseIndex) {
    rngState.add(1);
    initialized.add(false);
    desiredRange.add(0.0);
    desiredRangeHoldLeftS.add(0.0);
    flightTargetAboveGround.add(0.0);
    flightTargetHoldLeftS.add(0.0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    rngState[removeIndex] = rngState[lastIndex];
    initialized[removeIndex] = initialized[lastIndex];
    desiredRange[removeIndex] = desiredRange[lastIndex];
    desiredRangeHoldLeftS[removeIndex] = desiredRangeHoldLeftS[lastIndex];
    flightTargetAboveGround[removeIndex] = flightTargetAboveGround[lastIndex];
    flightTargetHoldLeftS[removeIndex] = flightTargetHoldLeftS[lastIndex];

    rngState.removeLast();
    initialized.removeLast();
    desiredRange.removeLast();
    desiredRangeHoldLeftS.removeLast();
    flightTargetAboveGround.removeLast();
    flightTargetHoldLeftS.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/gravity_control_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

class GravityControlStore extends SparseSet {
  final List<int> suppressGravityTicksLeft = <int>[];

  void setSuppressForTicks(EntityId entity, int ticks) {
    if (ticks <= 0) {
      removeEntity(entity);
      return;
    }

    final i = addEntity(entity);
    suppressGravityTicksLeft[i] = ticks;
  }

  @override
  void onDenseAdded(int denseIndex) {
    suppressGravityTicksLeft.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    suppressGravityTicksLeft[removeIndex] = suppressGravityTicksLeft[lastIndex];
    suppressGravityTicksLeft.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/health_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

class HealthDef {
  const HealthDef({
    required this.hp,
    required this.hpMax,
    required this.regenPerSecond,
  });

  final double hp;
  final double hpMax;
  final double regenPerSecond;
}

class HealthStore extends SparseSet {
  final List<double> hp = <double>[];
  final List<double> hpMax = <double>[];
  final List<double> regenPerSecond = <double>[];

  void add(EntityId entity, HealthDef def) {
    final i = addEntity(entity);
    hp[i] = def.hp;
    hpMax[i] = def.hpMax;
    regenPerSecond[i] = def.regenPerSecond;
  }

  @override
  void onDenseAdded(int denseIndex) {
    hp.add(0);
    hpMax.add(0);
    regenPerSecond.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    hp[removeIndex] = hp[lastIndex];
    hpMax[removeIndex] = hpMax[lastIndex];
    regenPerSecond[removeIndex] = regenPerSecond[lastIndex];

    hp.removeLast();
    hpMax.removeLast();
    regenPerSecond.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/hit_once_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

class HitOnceStore extends SparseSet {
  final List<int> count = <int>[];
  final List<EntityId> hit0 = <EntityId>[];
  final List<EntityId> hit1 = <EntityId>[];
  final List<EntityId> hit2 = <EntityId>[];
  final List<EntityId> hit3 = <EntityId>[];

  void add(EntityId entity) {
    addEntity(entity);
  }

  bool hasHit(EntityId entity, EntityId target) {
    final i = indexOf(entity);
    final c = count[i];
    if (c > 4) return true; // saturated: treat as "already hit everything"
    if (c <= 0) return false;
    if (hit0[i] == target) return true;
    if (c <= 1) return false;
    if (hit1[i] == target) return true;
    if (c <= 2) return false;
    if (hit2[i] == target) return true;
    if (c <= 3) return false;
    return hit3[i] == target;
  }

  void markHit(EntityId entity, EntityId target) {
    final i = indexOf(entity);
    var c = count[i];
    if (c > 4) return; // already saturated
    if (c <= 0) {
      hit0[i] = target;
      count[i] = 1;
      return;
    }
    if (c == 1) {
      hit1[i] = target;
      count[i] = 2;
      return;
    }
    if (c == 2) {
      hit2[i] = target;
      count[i] = 3;
      return;
    }
    if (c == 3) {
      hit3[i] = target;
      count[i] = 4;
      return;
    }
    // Saturate: in V0 we don't expect more than a few hits per swing.
    //
    // IMPORTANT (determinism + safety): once saturated, treat as "already hit"
    // for any target so a single swing cannot multi-hit due to overflow.
    count[i] = 5;
  }

  @override
  void onDenseAdded(int denseIndex) {
    count.add(0);
    hit0.add(0);
    hit1.add(0);
    hit2.add(0);
    hit3.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    count[removeIndex] = count[lastIndex];
    hit0[removeIndex] = hit0[lastIndex];
    hit1[removeIndex] = hit1[lastIndex];
    hit2[removeIndex] = hit2[lastIndex];
    hit3[removeIndex] = hit3[lastIndex];

    count.removeLast();
    hit0.removeLast();
    hit1.removeLast();
    hit2.removeLast();
    hit3.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/hitbox_store.dart =====
import '../../combat/faction.dart';
import '../entity_id.dart';
import '../sparse_set.dart';

class HitboxDef {
  const HitboxDef({
    required this.owner,
    required this.faction,
    required this.damage,
    required this.halfX,
    required this.halfY,
    required this.offsetX,
    required this.offsetY,
  });

  final EntityId owner;
  final Faction faction;
  final double damage;
  final double halfX;
  final double halfY;
  final double offsetX;
  final double offsetY;
}

/// Short-lived damage hitbox used by melee attacks and area effects.
class HitboxStore extends SparseSet {
  final List<EntityId> owner = <EntityId>[];
  final List<Faction> faction = <Faction>[];
  final List<double> damage = <double>[];
  final List<double> halfX = <double>[];
  final List<double> halfY = <double>[];
  final List<double> offsetX = <double>[];
  final List<double> offsetY = <double>[];

  void add(EntityId entity, HitboxDef def) {
    final i = addEntity(entity);
    owner[i] = def.owner;
    faction[i] = def.faction;
    damage[i] = def.damage;
    halfX[i] = def.halfX;
    halfY[i] = def.halfY;
    offsetX[i] = def.offsetX;
    offsetY[i] = def.offsetY;
  }

  @override
  void onDenseAdded(int denseIndex) {
    owner.add(0);
    faction.add(Faction.player);
    damage.add(0);
    halfX.add(0);
    halfY.add(0);
    offsetX.add(0);
    offsetY.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    owner[removeIndex] = owner[lastIndex];
    faction[removeIndex] = faction[lastIndex];
    damage[removeIndex] = damage[lastIndex];
    halfX[removeIndex] = halfX[lastIndex];
    halfY[removeIndex] = halfY[lastIndex];
    offsetX[removeIndex] = offsetX[lastIndex];
    offsetY[removeIndex] = offsetY[lastIndex];

    owner.removeLast();
    faction.removeLast();
    damage.removeLast();
    halfX.removeLast();
    halfY.removeLast();
    offsetX.removeLast();
    offsetY.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/invulnerability_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

class InvulnerabilityDef {
  const InvulnerabilityDef({this.ticksLeft = 0});

  final int ticksLeft;
}

/// Per-entity invulnerability window after taking damage.
///
/// IMPORTANT: In V0 this store is only attached to the player (no enemy i-frames).
class InvulnerabilityStore extends SparseSet {
  final List<int> ticksLeft = <int>[];

  void add(EntityId entity, [InvulnerabilityDef def = const InvulnerabilityDef()]) {
    final i = addEntity(entity);
    ticksLeft[i] = def.ticksLeft;
  }

  @override
  void onDenseAdded(int denseIndex) {
    ticksLeft.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    ticksLeft[removeIndex] = ticksLeft[lastIndex];
    ticksLeft.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/lifetime_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

class LifetimeDef {
  const LifetimeDef({required this.ticksLeft});

  final int ticksLeft;
}

class LifetimeStore extends SparseSet {
  final List<int> ticksLeft = <int>[];

  void add(EntityId entity, LifetimeDef def) {
    final i = addEntity(entity);
    ticksLeft[i] = def.ticksLeft;
  }

  @override
  void onDenseAdded(int denseIndex) {
    ticksLeft.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    ticksLeft[removeIndex] = ticksLeft[lastIndex];
    ticksLeft.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/mana_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

class ManaDef {
  const ManaDef({
    required this.mana,
    required this.manaMax,
    required this.regenPerSecond,
  });

  final double mana;
  final double manaMax;
  final double regenPerSecond;
}

class ManaStore extends SparseSet {
  final List<double> mana = <double>[];
  final List<double> manaMax = <double>[];
  final List<double> regenPerSecond = <double>[];

  void add(EntityId entity, ManaDef def) {
    final i = addEntity(entity);
    mana[i] = def.mana;
    manaMax[i] = def.manaMax;
    regenPerSecond[i] = def.regenPerSecond;
  }

  @override
  void onDenseAdded(int denseIndex) {
    mana.add(0);
    manaMax.add(0);
    regenPerSecond.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    mana[removeIndex] = mana[lastIndex];
    manaMax[removeIndex] = manaMax[lastIndex];
    regenPerSecond[removeIndex] = regenPerSecond[lastIndex];

    mana.removeLast();
    manaMax.removeLast();
    regenPerSecond.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/melee_intent_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

class MeleeIntentDef {
  const MeleeIntentDef({
    required this.damage,
    required this.halfX,
    required this.halfY,
    required this.offsetX,
    required this.offsetY,
    required this.activeTicks,
    required this.cooldownTicks,
    required this.staminaCost,
    required this.tick,
  });

  final double damage;
  final double halfX;
  final double halfY;
  final double offsetX;
  final double offsetY;
  final int activeTicks;
  final int cooldownTicks;
  final double staminaCost;

  /// Tick stamp for this intent.
  ///
  /// Use `-1` for "no intent". An intent is valid only when `tick == currentTick`.
  final int tick;
}

/// Per-entity "perform a melee attack this tick" intent.
///
/// This is written by player/enemy intent writers and consumed by `MeleeAttackSystem`.
class MeleeIntentStore extends SparseSet {
  final List<double> damage = <double>[];
  final List<double> halfX = <double>[];
  final List<double> halfY = <double>[];
  final List<double> offsetX = <double>[];
  final List<double> offsetY = <double>[];
  final List<int> activeTicks = <int>[];
  final List<int> cooldownTicks = <int>[];
  final List<double> staminaCost = <double>[];
  final List<int> tick = <int>[];

  void add(EntityId entity) {
    addEntity(entity);
  }

  void set(EntityId entity, MeleeIntentDef def) {
    assert(
      has(entity),
      'MeleeIntentStore.set called for entity without MeleeIntentStore; add the component at spawn time.',
    );
    final i = indexOf(entity);
    damage[i] = def.damage;
    halfX[i] = def.halfX;
    halfY[i] = def.halfY;
    offsetX[i] = def.offsetX;
    offsetY[i] = def.offsetY;
    activeTicks[i] = def.activeTicks;
    cooldownTicks[i] = def.cooldownTicks;
    staminaCost[i] = def.staminaCost;
    tick[i] = def.tick;
  }

  @override
  void onDenseAdded(int denseIndex) {
    damage.add(0.0);
    halfX.add(0.0);
    halfY.add(0.0);
    offsetX.add(0.0);
    offsetY.add(0.0);
    activeTicks.add(0);
    cooldownTicks.add(0);
    staminaCost.add(0.0);
    tick.add(-1);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    damage[removeIndex] = damage[lastIndex];
    halfX[removeIndex] = halfX[lastIndex];
    halfY[removeIndex] = halfY[lastIndex];
    offsetX[removeIndex] = offsetX[lastIndex];
    offsetY[removeIndex] = offsetY[lastIndex];
    activeTicks[removeIndex] = activeTicks[lastIndex];
    cooldownTicks[removeIndex] = cooldownTicks[lastIndex];
    staminaCost[removeIndex] = staminaCost[lastIndex];
    tick[removeIndex] = tick[lastIndex];

    damage.removeLast();
    halfX.removeLast();
    halfY.removeLast();
    offsetX.removeLast();
    offsetY.removeLast();
    activeTicks.removeLast();
    cooldownTicks.removeLast();
    staminaCost.removeLast();
    tick.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/movement_store.dart =====
import '../../snapshots/enums.dart';
import '../entity_id.dart';
import '../sparse_set.dart';

/// Movement state for platformer-style motion (timers + grounded + facing).
class MovementStore extends SparseSet {
  final List<int> coyoteTicksLeft = <int>[];
  final List<int> jumpBufferTicksLeft = <int>[];

  final List<int> dashTicksLeft = <int>[];
  final List<int> dashCooldownTicksLeft = <int>[];
  final List<double> dashDirX = <double>[];

  final List<Facing> facing = <Facing>[];

  void add(EntityId entity, {required Facing facing}) {
    final i = addEntity(entity);
    this.facing[i] = facing;
  }

  bool isDashing(EntityId entity) => dashTicksLeft[indexOf(entity)] > 0;

  @override
  void onDenseAdded(int denseIndex) {
    coyoteTicksLeft.add(0);
    jumpBufferTicksLeft.add(0);
    dashTicksLeft.add(0);
    dashCooldownTicksLeft.add(0);
    dashDirX.add(1);
    facing.add(Facing.right);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    coyoteTicksLeft[removeIndex] = coyoteTicksLeft[lastIndex];
    jumpBufferTicksLeft[removeIndex] = jumpBufferTicksLeft[lastIndex];
    dashTicksLeft[removeIndex] = dashTicksLeft[lastIndex];
    dashCooldownTicksLeft[removeIndex] = dashCooldownTicksLeft[lastIndex];
    dashDirX[removeIndex] = dashDirX[lastIndex];
    facing[removeIndex] = facing[lastIndex];

    coyoteTicksLeft.removeLast();
    jumpBufferTicksLeft.removeLast();
    dashTicksLeft.removeLast();
    dashCooldownTicksLeft.removeLast();
    dashDirX.removeLast();
    facing.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/player_input_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

/// Per-tick player input (authoritative commands decoded by the core).
///
/// This is reset/overwritten each tick by `GameCore.applyCommands`.
class PlayerInputStore extends SparseSet {
  final List<double> moveAxis = <double>[];
  final List<bool> jumpPressed = <bool>[];
  final List<bool> dashPressed = <bool>[];
  final List<bool> attackPressed = <bool>[];
  final List<double> aimDirX = <double>[];
  final List<double> aimDirY = <double>[];
  final List<bool> castPressed = <bool>[];

  void add(EntityId entity) {
    addEntity(entity);
  }

  void resetTickInputs(EntityId entity) {
    final i = indexOf(entity);
    moveAxis[i] = 0;
    jumpPressed[i] = false;
    dashPressed[i] = false;
    attackPressed[i] = false;
    aimDirX[i] = 0;
    aimDirY[i] = 0;
    castPressed[i] = false;
  }

  @override
  void onDenseAdded(int denseIndex) {
    moveAxis.add(0);
    jumpPressed.add(false);
    dashPressed.add(false);
    attackPressed.add(false);
    aimDirX.add(0);
    aimDirY.add(0);
    castPressed.add(false);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    moveAxis[removeIndex] = moveAxis[lastIndex];
    jumpPressed[removeIndex] = jumpPressed[lastIndex];
    dashPressed[removeIndex] = dashPressed[lastIndex];
    attackPressed[removeIndex] = attackPressed[lastIndex];
    aimDirX[removeIndex] = aimDirX[lastIndex];
    aimDirY[removeIndex] = aimDirY[lastIndex];
    castPressed[removeIndex] = castPressed[lastIndex];

    moveAxis.removeLast();
    jumpPressed.removeLast();
    dashPressed.removeLast();
    attackPressed.removeLast();
    aimDirX.removeLast();
    aimDirY.removeLast();
    castPressed.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/projectile_store.dart =====
import '../../combat/faction.dart';
import '../../projectiles/projectile_id.dart';
import '../entity_id.dart';
import '../sparse_set.dart';

class ProjectileDef {
  const ProjectileDef({
    required this.projectileId,
    required this.faction,
    required this.owner,
    required this.dirX,
    required this.dirY,
    required this.speedUnitsPerSecond,
    required this.damage,
  });

  final ProjectileId projectileId;
  final Faction faction;
  final EntityId owner;
  final double dirX;
  final double dirY;
  final double speedUnitsPerSecond;
  final double damage;
}

class ProjectileStore extends SparseSet {
  final List<ProjectileId> projectileId = <ProjectileId>[];
  final List<Faction> faction = <Faction>[];
  final List<EntityId> owner = <EntityId>[];
  final List<double> dirX = <double>[];
  final List<double> dirY = <double>[];
  final List<double> speedUnitsPerSecond = <double>[];
  final List<double> damage = <double>[];

  void add(EntityId entity, ProjectileDef def) {
    final i = addEntity(entity);
    projectileId[i] = def.projectileId;
    faction[i] = def.faction;
    owner[i] = def.owner;
    dirX[i] = def.dirX;
    dirY[i] = def.dirY;
    speedUnitsPerSecond[i] = def.speedUnitsPerSecond;
    damage[i] = def.damage;
  }

  @override
  void onDenseAdded(int denseIndex) {
    projectileId.add(ProjectileId.iceBolt);
    faction.add(Faction.player);
    owner.add(0);
    dirX.add(1.0);
    dirY.add(0.0);
    speedUnitsPerSecond.add(0.0);
    damage.add(0.0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    projectileId[removeIndex] = projectileId[lastIndex];
    faction[removeIndex] = faction[lastIndex];
    owner[removeIndex] = owner[lastIndex];
    dirX[removeIndex] = dirX[lastIndex];
    dirY[removeIndex] = dirY[lastIndex];
    speedUnitsPerSecond[removeIndex] = speedUnitsPerSecond[lastIndex];
    damage[removeIndex] = damage[lastIndex];

    projectileId.removeLast();
    faction.removeLast();
    owner.removeLast();
    dirX.removeLast();
    dirY.removeLast();
    speedUnitsPerSecond.removeLast();
    damage.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/spell_origin_store.dart =====
import '../../spells/spell_id.dart';
import '../entity_id.dart';
import '../sparse_set.dart';

class SpellOriginDef {
  const SpellOriginDef({required this.spellId});

  final SpellId spellId;
}

class SpellOriginStore extends SparseSet {
  final List<SpellId> spellId = <SpellId>[];

  void add(EntityId entity, SpellOriginDef def) {
    final i = addEntity(entity);
    spellId[i] = def.spellId;
  }

  @override
  void onDenseAdded(int denseIndex) {
    spellId.add(SpellId.iceBolt);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    spellId[removeIndex] = spellId[lastIndex];
    spellId.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/stamina_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

class StaminaDef {
  const StaminaDef({
    required this.stamina,
    required this.staminaMax,
    required this.regenPerSecond,
  });

  final double stamina;
  final double staminaMax;
  final double regenPerSecond;
}

class StaminaStore extends SparseSet {
  final List<double> stamina = <double>[];
  final List<double> staminaMax = <double>[];
  final List<double> regenPerSecond = <double>[];

  void add(EntityId entity, StaminaDef def) {
    final i = addEntity(entity);
    stamina[i] = def.stamina;
    staminaMax[i] = def.staminaMax;
    regenPerSecond[i] = def.regenPerSecond;
  }

  @override
  void onDenseAdded(int denseIndex) {
    stamina.add(0);
    staminaMax.add(0);
    regenPerSecond.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    stamina[removeIndex] = stamina[lastIndex];
    staminaMax[removeIndex] = staminaMax[lastIndex];
    regenPerSecond[removeIndex] = regenPerSecond[lastIndex];

    stamina.removeLast();
    staminaMax.removeLast();
    regenPerSecond.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/transform_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

/// SoA store for `Transform` (position + velocity).
class TransformStore extends SparseSet {
  final List<double> posX = <double>[];
  final List<double> posY = <double>[];
  final List<double> velX = <double>[];
  final List<double> velY = <double>[];

  void add(
    EntityId entity, {
    required double posX,
    required double posY,
    required double velX,
    required double velY,
  }) {
    final i = addEntity(entity);
    this.posX[i] = posX;
    this.posY[i] = posY;
    this.velX[i] = velX;
    this.velY[i] = velY;
  }

  void setPosXY(EntityId entity, double x, double y) {
    final i = indexOf(entity);
    posX[i] = x;
    posY[i] = y;
  }

  void setVelXY(EntityId entity, double x, double y) {
    final i = indexOf(entity);
    velX[i] = x;
    velY[i] = y;
  }

  @override
  void onDenseAdded(int denseIndex) {
    posX.add(0);
    posY.add(0);
    velX.add(0);
    velY.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    posX[removeIndex] = posX[lastIndex];
    posY[removeIndex] = posY[lastIndex];
    velX[removeIndex] = velX[lastIndex];
    velY[removeIndex] = velY[lastIndex];

    posX.removeLast();
    posY.removeLast();
    velX.removeLast();
    velY.removeLast();
  }
}


===== FILE: lib/core/ecs/systems/collision_system.dart =====
import '../../collision/static_world_geometry_index.dart';
import '../../tuning/v0_movement_tuning.dart';
import '../queries.dart';
import '../stores/body_store.dart';
import '../world.dart';

/// Integrates positions and resolves collisions (V0: ground band only).
///
/// Order within a tick:
/// - PlayerMovementSystem computes control velocities (jump/dash/horizontal).
/// - GravitySystem applies vertical gravity acceleration.
/// - CollisionSystem integrates `pos += vel * dt`, resolves collisions, and
///   finalizes grounded/contact state for the tick.
class CollisionSystem {
  void step(
    EcsWorld world,
    V0MovementTuningDerived tuning, {
    required StaticWorldGeometryIndex staticWorld,
  }) {
    final dt = tuning.dtSeconds;
    const eps = 1e-3;

    EcsQueries.forColliders(world, (e, ti, bi, coli, aabbi) {
      if (!world.body.enabled[bi]) return;

      // Reset per-tick collision results.
      world.collision.resetTick(e);

      // Kinematic bodies are excluded from physics integration/resolution.
      if (world.body.isKinematic[bi]) {
        return;
      }

      final prevPosX = world.transform.posX[ti];
      final prevPosY = world.transform.posY[ti];

      // Integrate position from the current velocity.
      world.transform.posX[ti] += world.transform.velX[ti] * dt;
      world.transform.posY[ti] += world.transform.velY[ti] * dt;

      final halfX = world.colliderAabb.halfX[aabbi];
      final halfY = world.colliderAabb.halfY[aabbi];
      final offsetX = world.colliderAabb.offsetX[aabbi];
      final offsetY = world.colliderAabb.offsetY[aabbi];

      final prevCenterX = prevPosX + offsetX;
      final prevCenterY = prevPosY + offsetY;
      final prevBottom = prevCenterY + halfY;

      final centerX = world.transform.posX[ti] + offsetX;
      final centerY = world.transform.posY[ti] + offsetY;
      final minX = centerX - halfX;
      final maxX = centerX + halfX;
      final bottom = centerY + halfY;
      final top = centerY - halfY;

      // Vertical top resolution (one-way platforms): only while moving downward.
      double? bestTopY;
      if (world.transform.velY[ti] > 0) {
        for (final solid in staticWorld.tops) {
          final overlapX = maxX > solid.minX + eps && minX < solid.maxX - eps;
          if (!overlapX) continue;

          final topY = solid.minY;
          final crossesTop =
              prevBottom <= topY + eps && bottom >= topY - eps;
          if (!crossesTop) continue;

          if (solid.oneWayTop == false) {
            // Fully solid top surface; same resolution as one-way, just without
            // any additional gating.
          }

          if (bestTopY == null || topY < bestTopY) {
            bestTopY = topY;
          }
        }
      }

      // Vertical bottom resolution (ceilings): only while moving upward.
      double? bestBottomY;
      if (world.transform.velY[ti] < 0 && !world.body.ignoreCeilings[bi]) {
        final prevTop = prevCenterY - halfY;
        for (final solid in staticWorld.bottoms) {
          final overlapX = maxX > solid.minX + eps && minX < solid.maxX - eps;
          if (!overlapX) continue;

          final bottomY = solid.maxY;
          final crossesBottom =
              prevTop >= bottomY - eps && top <= bottomY + eps;
          if (!crossesBottom) continue;

          if (bestBottomY == null || bottomY > bestBottomY) {
            bestBottomY = bottomY;
          }
        }
      }

      // Ground is treated as an infinite solid with a top at `v0GroundTopY`.
      // It competes with platforms: if a platform is higher (smaller Y), it
      // should win.
      final groundPlane = staticWorld.groundPlane;
      if (groundPlane != null) {
        final groundTopY = groundPlane.topY;
        if (world.transform.velY[ti] > 0 &&
            prevBottom <= groundTopY + eps &&
            bottom >= groundTopY - eps) {
          if (bestTopY == null || groundTopY < bestTopY) {
            bestTopY = groundTopY;
          }
        }
      }

      if (bestTopY != null) {
        world.transform.posY[ti] = bestTopY - offsetY - halfY;
        if (world.transform.velY[ti] > 0) {
          world.transform.velY[ti] = 0;
        }
        world.collision.grounded[coli] = true;
      } else if (bestBottomY != null) {
        world.transform.posY[ti] = bestBottomY - offsetY + halfY;
        if (world.transform.velY[ti] < 0) {
          world.transform.velY[ti] = 0;
        }
        world.collision.hitCeiling[coli] = true;
      }

      // Recompute AABB after vertical resolution for stable side overlap tests.
      final resolvedCenterX = world.transform.posX[ti] + offsetX;
      final resolvedCenterY = world.transform.posY[ti] + offsetY;
      //final resolvedMinX = resolvedCenterX - halfX;
      //final resolvedMaxX = resolvedCenterX + halfX;
      final resolvedMinY = resolvedCenterY - halfY;
      final resolvedMaxY = resolvedCenterY + halfY;

      // Horizontal resolution against static solids (V0: obstacles/walls only).
      final sideMask = world.body.sideMask[bi];
      final velX = world.transform.velX[ti];

      if (velX > 0 && (sideMask &  BodyDef.sideRight) != 0) {
        final prevRight = prevCenterX + halfX;
        final right = resolvedCenterX + halfX;
        double? bestWallX;

        for (final solid in staticWorld.leftWalls) {
          final overlapY =
              resolvedMaxY > solid.minY + eps && resolvedMinY < solid.maxY - eps;
          if (!overlapY) continue;

          final wallX = solid.minX;
          final crossesWall = prevRight <= wallX + eps && right >= wallX - eps;
          if (!crossesWall) continue;

          if (bestWallX == null || wallX < bestWallX) {
            bestWallX = wallX;
          }
        }

        if (bestWallX != null) {
          world.transform.posX[ti] = bestWallX - offsetX - halfX;
          world.transform.velX[ti] = 0;
          world.collision.hitRight[coli] = true;
        }
      } else if (velX < 0 && (sideMask & BodyDef.sideLeft) != 0) {
        final prevLeft = prevCenterX - halfX;
        final left = resolvedCenterX - halfX;
        double? bestWallX;

        for (final solid in staticWorld.rightWalls) {
          final overlapY =
              resolvedMaxY > solid.minY + eps && resolvedMinY < solid.maxY - eps;
          if (!overlapY) continue;

          final wallX = solid.maxX;
          final crossesWall = prevLeft >= wallX - eps && left <= wallX + eps;
          if (!crossesWall) continue;

          if (bestWallX == null || wallX > bestWallX) {
            bestWallX = wallX;
          }
        }

        if (bestWallX != null) {
          world.transform.posX[ti] = bestWallX - offsetX + halfX;
          world.transform.velX[ti] = 0;
          world.collision.hitLeft[coli] = true;
        }
      }
    });
  }
}


===== FILE: lib/core/ecs/systems/cooldown_system.dart =====
import '../world.dart';

class CooldownSystem {
  void step(EcsWorld world) {
    final store = world.cooldown;
    for (var i = 0; i < store.denseEntities.length; i += 1) {
      if (store.castCooldownTicksLeft[i] > 0) {
        store.castCooldownTicksLeft[i] -= 1;
      }
      if (store.meleeCooldownTicksLeft[i] > 0) {
        store.meleeCooldownTicksLeft[i] -= 1;
      }
    }
  }
}


===== FILE: lib/core/ecs/systems/damage_system.dart =====
import '../../combat/damage.dart';
import '../../util/double_math.dart';
import '../world.dart';

class DamageSystem {
  DamageSystem({required this.invulnerabilityTicksOnHit});

  final int invulnerabilityTicksOnHit;
  final List<DamageRequest> _pending = <DamageRequest>[];

  void queue(DamageRequest request) {
    if (request.amount <= 0) return;
    _pending.add(request);
  }

  void step(EcsWorld world) {
    if (_pending.isEmpty) return;

    final health = world.health;
    final invuln = world.invulnerability;
    for (final req in _pending) {
      if (!health.has(req.target)) continue;
      final hi = health.indexOf(req.target);

      // Invulnerability applies only to entities that have `InvulnerabilityStore`
      // attached (currently player-only in V0).
      if (invuln.has(req.target)) {
        final ii = invuln.indexOf(req.target);
        if (invuln.ticksLeft[ii] > 0) continue;
      }

      health.hp[hi] = clampDouble(
        health.hp[hi] - req.amount,
        0.0,
        health.hpMax[hi],
      );

      if (invulnerabilityTicksOnHit > 0 && invuln.has(req.target)) {
        invuln.ticksLeft[invuln.indexOf(req.target)] = invulnerabilityTicksOnHit;
      }
    }
    _pending.clear();
  }
}


===== FILE: lib/core/ecs/systems/enemy_system.dart =====
import '../../enemies/enemy_id.dart';
import '../../snapshots/enums.dart';
import '../../spells/spell_id.dart';
import '../../tuning/v0_flying_enemy_tuning.dart';
import '../../tuning/v0_ground_enemy_tuning.dart';
import '../../util/deterministic_rng.dart';
import '../../util/double_math.dart';
import '../../util/velocity_math.dart';
import '../../navigation/surface_graph.dart';
import '../../navigation/surface_navigator.dart';
import '../../navigation/surface_spatial_index.dart';
import '../entity_id.dart';
import '../stores/cast_intent_store.dart';
import '../stores/melee_intent_store.dart';
import '../world.dart';

class EnemySystem {
  EnemySystem({
    required this.flyingEnemyTuning,
    required this.groundEnemyTuning,
    required this.surfaceNavigator,
  });

  final V0FlyingEnemyTuningDerived flyingEnemyTuning;
  final V0GroundEnemyTuningDerived groundEnemyTuning;
  final SurfaceNavigator surfaceNavigator;

  SurfaceGraph? _surfaceGraph;
  SurfaceSpatialIndex? _surfaceIndex;
  int _surfaceGraphVersion = 0;

  void setSurfaceGraph({
    required SurfaceGraph graph,
    required SurfaceSpatialIndex spatialIndex,
    required int graphVersion,
  }) {
    _surfaceGraph = graph;
    _surfaceIndex = spatialIndex;
    _surfaceGraphVersion = graphVersion;
  }

  void stepSteering(
    EcsWorld world, {
    required EntityId player,
    required double groundTopY,
    required double dtSeconds,
  }) {
    if (!world.transform.has(player)) return;

    final playerTi = world.transform.indexOf(player);
    final playerX = world.transform.posX[playerTi];
    final playerY = world.transform.posY[playerTi];
    final playerGrounded = world.collision.has(player)
        ? world.collision.grounded[world.collision.indexOf(player)]
        : false;
    var playerHalfX = 0.0;
    var playerBottomY = playerY;
    if (world.colliderAabb.has(player)) {
      final ai = world.colliderAabb.indexOf(player);
      playerHalfX = world.colliderAabb.halfX[ai];
      final offsetY = world.colliderAabb.offsetY[ai];
      playerBottomY = playerY + offsetY + world.colliderAabb.halfY[ai];
    }

    final enemies = world.enemy;
    for (var ei = 0; ei < enemies.denseEntities.length; ei += 1) {
      final e = enemies.denseEntities[ei];
      if (!world.transform.has(e)) continue;

      final ti = world.transform.indexOf(e);
      final ex = world.transform.posX[ti];
      final ey = world.transform.posY[ti];

      switch (enemies.enemyId[ei]) {
        case EnemyId.flyingEnemy:
          _steerFlyingEnemy(
            world,
            enemyIndex: ei,
            enemy: e,
            enemyTi: ti,
            playerX: playerX,
            playerY: playerY,
            ex: ex,
            ey: ey,
            groundTopY: groundTopY,
            dtSeconds: dtSeconds,
          );
        case EnemyId.groundEnemy:
          _steerGroundEnemy(
            world,
            enemyIndex: ei,
            enemy: e,
            enemyTi: ti,
            playerX: playerX,
            playerBottomY: playerBottomY,
            playerHalfX: playerHalfX,
            playerGrounded: playerGrounded,
            ex: ex,
            dtSeconds: dtSeconds,
          );
      }
    }
  }

  void stepAttacks(EcsWorld world, {required EntityId player, required int currentTick}) {
    if (!world.transform.has(player)) return;
    final playerTi = world.transform.indexOf(player);
    final playerX = world.transform.posX[playerTi];
    final playerY = world.transform.posY[playerTi];

    final enemies = world.enemy;
    for (var ei = 0; ei < enemies.denseEntities.length; ei += 1) {
      final e = enemies.denseEntities[ei];
      if (!world.transform.has(e)) continue;
      if (!world.cooldown.has(e)) continue;

      final ti = world.transform.indexOf(e);
      final ex = world.transform.posX[ti];
      final ey = world.transform.posY[ti];

      switch (enemies.enemyId[ei]) {
        case EnemyId.flyingEnemy:
          _writeFlyingEnemyCastIntent(
            world,
            enemy: e,
            ex: ex,
            ey: ey,
            playerX: playerX,
            playerY: playerY,
            currentTick: currentTick,
          );
        case EnemyId.groundEnemy:
          _writeGroundEnemyMeleeIntent(
            world,
            enemy: e,
            enemyIndex: ei,
            ex: ex,
            ey: ey,
            playerX: playerX,
            currentTick: currentTick,
          );
      }
    }
  }

  void _steerFlyingEnemy(
    EcsWorld world, {
    required int enemyIndex,
    required EntityId enemy,
    required int enemyTi,
    required double playerX,
    required double playerY,
    required double ex,
    required double ey,
    required double groundTopY,
    required double dtSeconds,
  }) {
    if (dtSeconds <= 0.0) return;
    final tuning = flyingEnemyTuning;
    if (!world.flyingEnemySteering.has(enemy)) {
      assert(
        false,
        'EnemySystem requires FlyingEnemySteeringStore on flying enemies; add it at spawn time.',
      );
      return;
    }

    final steering = world.flyingEnemySteering;
    final si = steering.indexOf(enemy);

    var rngState = steering.rngState[si];
    double nextRange(double min, double max) {
      rngState = nextUint32(rngState);
      return rangeDouble(rngState, min, max);
    }

    if (!steering.initialized[si]) {
      steering.initialized[si] = true;
      steering.desiredRangeHoldLeftS[si] = nextRange(
        tuning.base.flyingEnemyDesiredRangeHoldMinSeconds,
        tuning.base.flyingEnemyDesiredRangeHoldMaxSeconds,
      );
      steering.desiredRange[si] = nextRange(
        tuning.base.flyingEnemyDesiredRangeMin,
        tuning.base.flyingEnemyDesiredRangeMax,
      );
      steering.flightTargetHoldLeftS[si] = 0.0;
      steering.flightTargetAboveGround[si] = nextRange(
        tuning.base.flyingEnemyMinHeightAboveGround,
        tuning.base.flyingEnemyMaxHeightAboveGround,
      );
    }

    var desiredRangeHoldLeftS = steering.desiredRangeHoldLeftS[si];
    var desiredRange = steering.desiredRange[si];

    // Hold desired range target.
    if (desiredRangeHoldLeftS > 0.0) {
      desiredRangeHoldLeftS -= dtSeconds;
    } else {
      desiredRangeHoldLeftS = nextRange(
        tuning.base.flyingEnemyDesiredRangeHoldMinSeconds,
        tuning.base.flyingEnemyDesiredRangeHoldMaxSeconds,
      );
      desiredRange = nextRange(
        tuning.base.flyingEnemyDesiredRangeMin,
        tuning.base.flyingEnemyDesiredRangeMax,
      );
    }

    final dx = playerX - ex;
    final distX = dx.abs();
    if (distX > 1e-6) {
      world.enemy.facing[enemyIndex] = dx >= 0 ? Facing.right : Facing.left;
    }

    final slack = tuning.base.flyingEnemyHoldSlack;
    double desiredVelX = 0.0;
    if (distX > 1e-6) {
      final dirToPlayerX = dx >= 0 ? 1.0 : -1.0;
      final error = distX - desiredRange;

      if (error.abs() > slack) {
        final slowRadiusX = tuning.base.flyingEnemySlowRadiusX;
        final t = slowRadiusX > 0.0
            ? clampDouble((error.abs() - slack) / slowRadiusX, 0.0, 1.0)
            : 1.0;
        final speed = t * tuning.base.flyingEnemyMaxSpeedX;
        desiredVelX = (error > 0.0 ? dirToPlayerX : -dirToPlayerX) * speed;
      }
    }

    var flightTargetHoldLeftS = steering.flightTargetHoldLeftS[si];
    var flightTargetAboveGround = steering.flightTargetAboveGround[si];
    if (flightTargetHoldLeftS > 0.0) {
      flightTargetHoldLeftS -= dtSeconds;
    } else {
      flightTargetHoldLeftS = nextRange(
        tuning.base.flyingEnemyFlightTargetHoldMinSeconds,
        tuning.base.flyingEnemyFlightTargetHoldMaxSeconds,
      );
      flightTargetAboveGround = nextRange(
        tuning.base.flyingEnemyMinHeightAboveGround,
        tuning.base.flyingEnemyMaxHeightAboveGround,
      );
    }

    final targetY = groundTopY - flightTargetAboveGround;
    final deltaY = targetY - ey;
    double desiredVelY = clampDouble(
      deltaY * tuning.base.flyingEnemyVerticalKp,
      -tuning.base.flyingEnemyMaxSpeedY,
      tuning.base.flyingEnemyMaxSpeedY,
    );
    if (deltaY.abs() <= tuning.base.flyingEnemyVerticalDeadzone) {
      desiredVelY = 0.0;
    }

    final currentVelX = world.transform.velX[enemyTi];
    world.transform.velX[enemyTi] = applyAccelDecel(
      current: currentVelX,
      desired: desiredVelX,
      dtSeconds: dtSeconds,
      accelPerSecond: tuning.base.flyingEnemyAccelX,
      decelPerSecond: tuning.base.flyingEnemyDecelX,
    );
    world.transform.velY[enemyTi] = desiredVelY;

    steering.desiredRangeHoldLeftS[si] = desiredRangeHoldLeftS;
    steering.desiredRange[si] = desiredRange;
    steering.flightTargetHoldLeftS[si] = flightTargetHoldLeftS;
    steering.flightTargetAboveGround[si] = flightTargetAboveGround;
    steering.rngState[si] = rngState;
  }

  void _steerGroundEnemy(
    EcsWorld world, {
    required int enemyIndex,
    required EntityId enemy,
    required int enemyTi,
    required double playerX,
    required double playerBottomY,
    required double playerHalfX,
    required bool playerGrounded,
    required double ex,
    required double dtSeconds,
  }) {
    if (dtSeconds <= 0.0) return;
    final tuning = groundEnemyTuning;

    final navIndex = world.surfaceNav.tryIndexOf(enemy);
    if (navIndex == null) {
      assert(
        false,
        'EnemySystem requires SurfaceNavStateStore on nav-enabled enemies; add it at spawn time.',
      );
      return;
    }

    final graph = _surfaceGraph;
    final spatialIndex = _surfaceIndex;
    SurfaceNavIntent intent;
    if (graph == null || spatialIndex == null || !world.colliderAabb.has(enemy)) {
      intent = SurfaceNavIntent(
        desiredX: playerX,
        jumpNow: false,
        hasPlan: false,
      );
    } else {
      final ai = world.colliderAabb.indexOf(enemy);
      final enemyHalfX = world.colliderAabb.halfX[ai];
      final enemyHalfY = world.colliderAabb.halfY[ai];
      final offsetY = world.colliderAabb.offsetY[ai];
      final enemyBottomY = world.transform.posY[enemyTi] + offsetY + enemyHalfY;
      final grounded = world.collision.has(enemy) &&
          world.collision.grounded[world.collision.indexOf(enemy)];

      intent = surfaceNavigator.update(
        navStore: world.surfaceNav,
        navIndex: navIndex,
        graph: graph,
        spatialIndex: spatialIndex,
        graphVersion: _surfaceGraphVersion,
        entityX: ex,
        entityBottomY: enemyBottomY,
        entityHalfWidth: enemyHalfX,
        entityGrounded: grounded,
        targetX: playerX,
        targetBottomY: playerBottomY,
        targetHalfWidth: playerHalfX,
        targetGrounded: playerGrounded,
        jumpCooldownTicks: tuning.groundEnemyJumpCooldownTicks,
      );
    }

    final dx = intent.desiredX - ex;
    double desiredVelX = 0.0;
    if (intent.commitMoveDirX != 0) {
      final dirX = intent.commitMoveDirX.toDouble();
      world.enemy.facing[enemyIndex] = dirX > 0 ? Facing.right : Facing.left;
      desiredVelX = dirX * tuning.base.groundEnemySpeedX;
    } else if (dx.abs() > tuning.base.groundEnemyStopDistanceX) {
      final dirX = dx >= 0 ? 1.0 : -1.0;
      world.enemy.facing[enemyIndex] = dirX > 0 ? Facing.right : Facing.left;
      desiredVelX = dirX * tuning.base.groundEnemySpeedX;
    }

    if (intent.jumpNow) {
      world.transform.velY[enemyTi] = -tuning.base.groundEnemyJumpSpeed;
    }

    final currentVelX = world.transform.velX[enemyTi];
    world.transform.velX[enemyTi] = applyAccelDecel(
      current: currentVelX,
      desired: desiredVelX,
      dtSeconds: dtSeconds,
      accelPerSecond: tuning.base.groundEnemyAccelX,
      decelPerSecond: tuning.base.groundEnemyDecelX,
    );

  }

  void _writeFlyingEnemyCastIntent(
    EcsWorld world, {
      required EntityId enemy,
      required double ex,
      required double ey,
      required double playerX,
      required double playerY,
      required int currentTick,
    }) {
    final tuning = flyingEnemyTuning;
    if (!world.castIntent.has(enemy)) {
      assert(
        false,
        'EnemySystem requires CastIntentStore on enemies; add it at spawn time.',
      );
      return;
    }

    const spellId = SpellId.lightning;

    // IMPORTANT: EnemySystem writes intent only; execution happens in
    // `SpellCastSystem` which owns mana/cooldown rules and projectile spawning.
    world.castIntent.set(
      enemy,
      CastIntentDef(
        spellId: spellId,
        dirX: playerX - ex,
        dirY: playerY - ey,
        fallbackDirX: 1.0,
        fallbackDirY: 0.0,
        originOffset: tuning.base.flyingEnemyCastOriginOffset,
        cooldownTicks: tuning.flyingEnemyCastCooldownTicks,
        tick: currentTick,
      ),
    );
  }

  void _writeGroundEnemyMeleeIntent(
    EcsWorld world, {
      required EntityId enemy,
      required int enemyIndex,
      required double ex,
      required double ey,
      required double playerX,
      required int currentTick,
    }) {
    final tuning = groundEnemyTuning;
    if (!world.meleeIntent.has(enemy)) {
      assert(
        false,
        'EnemySystem requires MeleeIntentStore on enemies; add it at spawn time.',
      );
      return;
    }
    if (!world.colliderAabb.has(enemy)) {
      assert(
        false,
        'GroundEnemy melee requires ColliderAabbStore on the enemy to compute hitbox offset.',
      );
      return;
    }
    final dx = (playerX - ex).abs();
    if (dx > tuning.base.groundEnemyMeleeRangeX) return;

    final facing = world.enemy.facing[enemyIndex];
    final dirX = facing == Facing.right ? 1.0 : -1.0;

    final halfX = tuning.base.groundEnemyMeleeHitboxSizeX * 0.5;
    final halfY = tuning.base.groundEnemyMeleeHitboxSizeY * 0.5;

    final ownerHalfX = world.colliderAabb.halfX[world.colliderAabb.indexOf(enemy)];
    final offsetX = dirX * (ownerHalfX * 0.5 + halfX);
    const offsetY = 0.0;

    world.meleeIntent.set(
      enemy,
      MeleeIntentDef(
        damage: tuning.base.groundEnemyMeleeDamage,
        halfX: halfX,
        halfY: halfY,
        offsetX: offsetX,
        offsetY: offsetY,
        activeTicks: tuning.groundEnemyMeleeActiveTicks,
        cooldownTicks: tuning.groundEnemyMeleeCooldownTicks,
        staminaCost: 0.0,
        tick: currentTick,
      ),
    );
  }
}


===== FILE: lib/core/ecs/systems/gravity_system.dart =====
import '../../tuning/v0_movement_tuning.dart';
import '../../tuning/v0_physics_tuning.dart';
import '../world.dart';

/// Applies gravity to all enabled, non-kinematic bodies that opt into gravity.
///
/// Gravity is applied before collision integration/resolution each tick.
class GravitySystem {
  void step(
    EcsWorld world,
    V0MovementTuningDerived movement, {
    required V0PhysicsTuning physics,
  }) {
    final dt = movement.dtSeconds;
    if (dt <= 0.0) return;

    final gravityY = physics.gravityY;
    final bodies = world.body;

    for (var bi = 0; bi < bodies.denseEntities.length; bi += 1) {
      final e = bodies.denseEntities[bi];

      final ti = world.transform.tryIndexOf(e);
      if (ti == null) continue;

      if (!bodies.enabled[bi]) continue;
      if (bodies.isKinematic[bi]) continue;
      if (!bodies.useGravity[bi]) continue;

      final gci = world.gravityControl.tryIndexOf(e);
      if (gci != null) {
        final left = world.gravityControl.suppressGravityTicksLeft[gci];
        if (left > 0) {
          final nextLeft = left - 1;
          if (nextLeft <= 0) {
            world.gravityControl.removeEntity(e);
          } else {
            world.gravityControl.suppressGravityTicksLeft[gci] = nextLeft;
          }
          continue;
        } else {
          world.gravityControl.removeEntity(e);
        }
      }

      final scaledGravityY = gravityY * bodies.gravityScale[bi];
      world.transform.velY[ti] += scaledGravityY * dt;

      final maxVelY = bodies.maxVelY[bi];
      world.transform.velY[ti] = world.transform.velY[ti]
          .clamp(-maxVelY, maxVelY)
          .toDouble();
    }
  }
}


===== FILE: lib/core/ecs/systems/health_despawn_system.dart =====
import '../entity_id.dart';
import '../world.dart';

/// Despawns any non-player entity with `HealthStore` and `hp <= 0`.
///
/// IMPORTANT: The player is intentionally exempt because player "death" is a
/// different gameplay flow (game over / respawn / end-run) than despawning an
/// entity in-place.
class HealthDespawnSystem {
  final List<EntityId> _toDespawn = <EntityId>[];

  void step(EcsWorld world, {required EntityId player}) {
    final health = world.health;
    if (health.denseEntities.isEmpty) return;

    _toDespawn.clear();

    for (var i = 0; i < health.denseEntities.length; i += 1) {
      final e = health.denseEntities[i];
      if (e == player) continue;
      if (health.hp[i] <= 0.0) {
        _toDespawn.add(e);
      }
    }

    for (final e in _toDespawn) {
      world.destroyEntity(e);
    }
  }
}


===== FILE: lib/core/ecs/systems/hitbox_damage_system.dart =====
import '../../combat/damage.dart';
import '../hit/hit_resolver.dart';
import '../spatial/broadphase_grid.dart';
import '../world.dart';

class HitboxDamageSystem {
  final HitResolver _resolver = HitResolver();
  final List<int> _overlaps = <int>[];

  void step(
    EcsWorld world,
    void Function(DamageRequest request) queueDamage,
    BroadphaseGrid broadphase,
  ) {
    final hitboxes = world.hitbox;
    if (hitboxes.denseEntities.isEmpty) return;

    if (broadphase.targets.isEmpty) return;

    for (var hi = 0; hi < hitboxes.denseEntities.length; hi += 1) {
      final hb = hitboxes.denseEntities[hi];
      if (!world.transform.has(hb)) continue;
      if (!world.hitOnce.has(hb)) continue;

      final hbTi = world.transform.indexOf(hb);
      final hbCx = world.transform.posX[hbTi];
      final hbCy = world.transform.posY[hbTi];
      final hbHalfX = hitboxes.halfX[hi];
      final hbHalfY = hitboxes.halfY[hi];

      final owner = hitboxes.owner[hi];
      final sourceFaction = hitboxes.faction[hi];

      _resolver.collectOrderedOverlapsCenters(
        broadphase: broadphase,
        centerX: hbCx,
        centerY: hbCy,
        halfX: hbHalfX,
        halfY: hbHalfY,
        owner: owner,
        sourceFaction: sourceFaction,
        outTargetIndices: _overlaps,
      );
      if (_overlaps.isEmpty) continue;

      for (var i = 0; i < _overlaps.length; i += 1) {
        final ti = _overlaps[i];
        final target = broadphase.targets.entities[ti];
        if (world.hitOnce.hasHit(hb, target)) continue;
        world.hitOnce.markHit(hb, target);

        queueDamage(DamageRequest(target: target, amount: hitboxes.damage[hi]));
      }
    }
  }
}


===== FILE: lib/core/ecs/systems/hitbox_follow_owner_system.dart =====
import '../world.dart';

/// Keeps hitbox entities attached to their owner by applying `HitboxStore` offsets.
///
/// IMPORTANT:
/// - The hitbox position is derived from `owner Transform + Hitbox.offset` every tick.
/// - Spawners should avoid manually computing hitbox world positions to prevent drift.
class HitboxFollowOwnerSystem {
  void step(EcsWorld world) {
    final hitboxes = world.hitbox;
    if (hitboxes.denseEntities.isEmpty) return;

    for (var hi = 0; hi < hitboxes.denseEntities.length; hi += 1) {
      final hitbox = hitboxes.denseEntities[hi];
      if (!world.transform.has(hitbox)) continue;

      final owner = hitboxes.owner[hi];
      if (!world.transform.has(owner)) continue;

      final ownerTi = world.transform.indexOf(owner);
      final x = world.transform.posX[ownerTi] + hitboxes.offsetX[hi];
      final y = world.transform.posY[ownerTi] + hitboxes.offsetY[hi];

      world.transform.setPosXY(hitbox, x, y);
    }
  }
}



===== FILE: lib/core/ecs/systems/invulnerability_system.dart =====
import '../world.dart';

class InvulnerabilitySystem {
  void step(EcsWorld world) {
    final store = world.invulnerability;
    for (var i = 0; i < store.denseEntities.length; i += 1) {
      final left = store.ticksLeft[i];
      if (left > 0) store.ticksLeft[i] = left - 1;
    }
  }
}



===== FILE: lib/core/ecs/systems/lifetime_system.dart =====
import '../entity_id.dart';
import '../world.dart';

/// Decrements `LifetimeStore.ticksLeft` and despawns entities when it reaches 0.
///
/// This is intentionally generic so any timed entity type can reuse it
/// (projectiles, pickups, hazards, VFX, etc.).
class LifetimeSystem {
  final List<EntityId> _toDespawn = <EntityId>[];

  void step(EcsWorld world) {
    final lifetimes = world.lifetime;
    if (lifetimes.denseEntities.isEmpty) return;

    _toDespawn.clear();

    for (var li = 0; li < lifetimes.denseEntities.length; li += 1) {
      final e = lifetimes.denseEntities[li];
      final ticksLeft = lifetimes.ticksLeft[li];
      if (ticksLeft <= 0) {
        _toDespawn.add(e);
        continue;
      }

      final next = ticksLeft - 1;
      lifetimes.ticksLeft[li] = next;
      if (next <= 0) {
        _toDespawn.add(e);
      }
    }

    for (final e in _toDespawn) {
      world.destroyEntity(e);
    }
  }
}



===== FILE: lib/core/ecs/systems/melee_attack_system.dart =====
import '../stores/hitbox_store.dart';
import '../stores/lifetime_store.dart';
import '../world.dart';

/// Executes `MeleeIntentStore` intents by applying costs/cooldowns and spawning
/// melee hitboxes.
///
/// IMPORTANT:
/// - Only intents with `intent.tick == currentTick` are considered valid.
/// - Hitbox `faction` is derived from the attacker entity's `FactionStore`.
/// - Intents are invalidated after processing by setting `intent.tick = -1`.
class MeleeAttackSystem {
  void step(EcsWorld world, {required int currentTick}) {
    final intents = world.meleeIntent;
    if (intents.denseEntities.isEmpty) return;

    for (var ii = 0; ii < intents.denseEntities.length; ii += 1) {
      if (intents.tick[ii] != currentTick) continue;

      final attacker = intents.denseEntities[ii];

      // Invalidate now so accidental multi-pass execution in the same tick cannot
      // double-attack. (Intent is still ignored next tick due to stamp mismatch.)
      intents.tick[ii] = -1;

      if (!world.transform.has(attacker)) continue;
      if (!world.cooldown.has(attacker)) continue;

      final ci = world.cooldown.indexOf(attacker);
      if (world.cooldown.meleeCooldownTicksLeft[ci] > 0) continue;

      final fi = world.faction.tryIndexOf(attacker);
      if (fi == null) continue;
      final faction = world.faction.faction[fi];

      final staminaCost = intents.staminaCost[ii];
      int? si;
      double? nextStamina;
      if (staminaCost > 0) {
        if (!world.stamina.has(attacker)) continue;
        si = world.stamina.indexOf(attacker);
        final stamina = world.stamina.stamina[si];
        if (stamina < staminaCost) continue;
        nextStamina = stamina - staminaCost;
      }

      final attackerTi = world.transform.indexOf(attacker);
      final hitbox = world.createEntity();
      world.transform.add(
        hitbox,
        // HitboxFollowOwnerSystem will position from `owner + offset`.
        posX: world.transform.posX[attackerTi],
        posY: world.transform.posY[attackerTi],
        velX: 0.0,
        velY: 0.0,
      );
      world.hitbox.add(
        hitbox,
        HitboxDef(
          owner: attacker,
          faction: faction,
          damage: intents.damage[ii],
          halfX: intents.halfX[ii],
          halfY: intents.halfY[ii],
          offsetX: intents.offsetX[ii],
          offsetY: intents.offsetY[ii],
        ),
      );
      world.hitOnce.add(hitbox);
      world.lifetime.add(
        hitbox,
        LifetimeDef(ticksLeft: intents.activeTicks[ii]),
      );

      if (si != null) {
        world.stamina.stamina[si] = nextStamina!;
      }
      world.cooldown.meleeCooldownTicksLeft[ci] = intents.cooldownTicks[ii];
    }
  }
}


===== FILE: lib/core/ecs/systems/player_cast_system.dart =====
import '../../snapshots/enums.dart';
import '../../spells/spell_id.dart';
import '../../tuning/v0_ability_tuning.dart';
import '../../tuning/v0_movement_tuning.dart';
import '../entity_id.dart';
import '../stores/cast_intent_store.dart';
import '../world.dart';

class PlayerCastSystem {
  const PlayerCastSystem({
    required this.abilities,
    required this.movement,
  });

  final V0AbilityTuningDerived abilities;
  final V0MovementTuningDerived movement;

  void step(EcsWorld world, {required EntityId player, required int currentTick}) {
    if (!world.playerInput.has(player) ||
        !world.transform.has(player) ||
        !world.movement.has(player)) {
      return;
    }
    if (!world.castIntent.has(player)) {
      assert(
        false,
        'PlayerCastSystem requires CastIntentStore on the player; add it at spawn time.',
      );
      return;
    }

    final ii = world.playerInput.indexOf(player);
    if (!world.playerInput.castPressed[ii]) return;

    const spellId = SpellId.iceBolt;

    // final ti = world.transform.indexOf(player);
    final facing = world.movement.facing[world.movement.indexOf(player)];

    final rawAimX = world.playerInput.aimDirX[ii];
    final rawAimY = world.playerInput.aimDirY[ii];

    final spawnOffset = movement.base.playerRadius * 0.5;
    final fallbackDirX = facing == Facing.right ? 1.0 : -1.0;

    // IMPORTANT: PlayerCastSystem writes intent only; execution happens in
    // `SpellCastSystem` which owns mana/cooldown rules and projectile spawning.
    world.castIntent.set(
      player,
      CastIntentDef(
        spellId: spellId,
        dirX: rawAimX,
        dirY: rawAimY,
        fallbackDirX: fallbackDirX,
        fallbackDirY: 0.0,
        originOffset: spawnOffset,
        cooldownTicks: abilities.castCooldownTicks,
        tick: currentTick,
      ),
    );
  }
}


===== FILE: lib/core/ecs/systems/player_melee_system.dart =====
import '../../snapshots/enums.dart';
import '../../tuning/v0_ability_tuning.dart';
import '../../tuning/v0_movement_tuning.dart';
import '../entity_id.dart';
import '../stores/melee_intent_store.dart';
import '../world.dart';

class PlayerMeleeSystem {
  const PlayerMeleeSystem({
    required this.abilities,
    required this.movement,
  });

  final V0AbilityTuningDerived abilities;
  final V0MovementTuningDerived movement;

  void step(EcsWorld world, {required EntityId player, required int currentTick}) {
    _trySpawnPlayerMelee(world, player: player, currentTick: currentTick);
  }

  void _trySpawnPlayerMelee(
    EcsWorld world, {
    required EntityId player,
    required int currentTick,
  }) {
    if (!world.playerInput.has(player)) return;
    if (!world.transform.has(player)) return;
    if (!world.movement.has(player)) return;
    if (!world.meleeIntent.has(player)) {
      assert(
        false,
        'PlayerMeleeSystem requires MeleeIntentStore on the player; add it at spawn time.',
      );
      return;
    }

    final ii = world.playerInput.indexOf(player);
    if (!world.playerInput.attackPressed[ii]) return;

    final mi = world.movement.indexOf(player);
    final facing = world.movement.facing[mi];
    final dirX = (facing == Facing.right) ? 1.0 : -1.0;

    final halfX = abilities.base.meleeHitboxSizeX * 0.5;
    final halfY = abilities.base.meleeHitboxSizeY * 0.5;

    // origin = playerPos + aimDir * (playerRadius * 0.5) for casts
    // melee uses facing-only:
    // center = playerPos + dirX * (playerRadius * 0.5 + halfX)
    final forward = movement.base.playerRadius * 0.5 + halfX;
    final offsetX = dirX * forward;
    const offsetY = 0.0;

    // IMPORTANT: PlayerMeleeSystem writes intent only; execution happens in
    // `MeleeAttackSystem` which owns stamina/cooldown rules and hitbox spawning.
    world.meleeIntent.set(
      player,
      MeleeIntentDef(
        damage: abilities.base.meleeDamage,
        halfX: halfX,
        halfY: halfY,
        offsetX: offsetX,
        offsetY: offsetY,
        activeTicks: abilities.meleeActiveTicks,
        cooldownTicks: abilities.meleeCooldownTicks,
        staminaCost: abilities.base.meleeStaminaCost,
        tick: currentTick,
      ),
    );
  }
}


===== FILE: lib/core/ecs/systems/player_movement_system.dart =====
import '../../snapshots/enums.dart';
import '../../tuning/v0_movement_tuning.dart';
import '../../tuning/v0_resource_tuning.dart';
import '../../util/velocity_math.dart';
import '../entity_id.dart';
import '../queries.dart';
import '../world.dart';

/// Applies platformer-style movement for entities with:
/// - Transform
/// - PlayerInput
/// - Movement
/// - Body
///
/// PlayerMovementSystem writes velocities only (input/jump/dash/gravity/clamps).
/// Position integration and collision resolution are handled by CollisionSystem.
class PlayerMovementSystem {
  void step(
    EcsWorld world,
    V0MovementTuningDerived tuning, {
    required V0ResourceTuning resources,
  }) {
    final dt = tuning.dtSeconds;
    final t = tuning.base;

    EcsQueries.forMovementBodies(world, (e, mi, ti, ii, bi, ci, si) {
      if (!world.body.enabled[bi]) return;
      if (world.body.isKinematic[bi]) {
        return;
      }

      // Timers.
      if (world.movement.dashCooldownTicksLeft[mi] > 0) {
        world.movement.dashCooldownTicksLeft[mi] -= 1;
      }
      if (world.movement.dashTicksLeft[mi] > 0) {
        world.movement.dashTicksLeft[mi] -= 1;
      }
      if (world.movement.jumpBufferTicksLeft[mi] > 0) {
        world.movement.jumpBufferTicksLeft[mi] -= 1;
      }

      final wasGrounded = world.collision.grounded[ci];
      if (wasGrounded) {
        world.movement.coyoteTicksLeft[mi] = tuning.coyoteTicks;
      } else if (world.movement.coyoteTicksLeft[mi] > 0) {
        world.movement.coyoteTicksLeft[mi] -= 1;
      }

      // Buffer jump on edge-triggered press.
      if (world.playerInput.jumpPressed[ii]) {
        world.movement.jumpBufferTicksLeft[mi] = tuning.jumpBufferTicks;
      }

      // Dash request.
      if (world.playerInput.dashPressed[ii]) {
        _tryStartDash(
          world,
          entity: e,
          mi: mi,
          ti: ti,
          ii: ii,
          si: si,
          tuning: tuning,
          staminaCost: resources.dashStaminaCost,
        );
      }

      final dashing = world.movement.dashTicksLeft[mi] > 0;

      if (dashing) {
        world.transform.velX[ti] = world.movement.dashDirX[mi] * t.dashSpeedX;
        world.transform.velY[ti] = 0;
      } else {
        world.transform.velX[ti] = _applyHorizontalMove(
          world.transform.velX[ti],
          world.playerInput.moveAxis[ii],
          dt,
          tuning,
        );

        // Jump attempt before gravity (to match the previous behavior).
        if (world.movement.jumpBufferTicksLeft[mi] > 0 &&
            (wasGrounded || world.movement.coyoteTicksLeft[mi] > 0)) {
          if (world.stamina.stamina[si] >= resources.jumpStaminaCost) {
            world.stamina.stamina[si] -= resources.jumpStaminaCost;

            world.transform.velY[ti] = -t.jumpSpeed;
            world.movement.jumpBufferTicksLeft[mi] = 0;
            world.movement.coyoteTicksLeft[mi] = 0;
          }
        }

      }

      // Clamp speeds.
      world.transform.velX[ti] = world.transform.velX[ti]
          .clamp(-world.body.maxVelX[bi], world.body.maxVelX[bi])
          .toDouble();
    });
  }

  double _applyHorizontalMove(
    double velocityX,
    double axis,
    double dt,
    V0MovementTuningDerived tuning,
  ) {
    final t = tuning.base;
    final desiredX = axis == 0.0 ? 0.0 : axis * t.maxSpeedX;
    return applyAccelDecel(
      current: velocityX,
      desired: desiredX,
      dtSeconds: dt,
      accelPerSecond: t.accelerationX,
      decelPerSecond: t.decelerationX,
      minStopSpeed: t.minMoveSpeed,
    );
  }

  void _tryStartDash(
    EcsWorld world, {
    required EntityId entity,
    required int mi,
    required int ti,
    required int ii,
    required int si,
    required V0MovementTuningDerived tuning,
    required double staminaCost,
  }) {
    if (world.movement.dashTicksLeft[mi] > 0) return;
    if (world.movement.dashCooldownTicksLeft[mi] > 0) return;
    if (world.stamina.stamina[si] < staminaCost) return;

    final axis = world.playerInput.moveAxis[ii];
    final dirX = axis != 0
        ? (axis > 0 ? 1.0 : -1.0)
        : (world.movement.facing[mi] == Facing.right ? 1.0 : -1.0);

    world.movement.dashDirX[mi] = dirX;
    world.movement.facing[mi] = dirX > 0 ? Facing.right : Facing.left;

    world.movement.dashTicksLeft[mi] = tuning.dashDurationTicks;
    world.movement.dashCooldownTicksLeft[mi] = tuning.dashCooldownTicks;

    // Cancel vertical motion so dash doesn't inherit jump/fall.
    world.transform.velY[ti] = 0;
    world.gravityControl.setSuppressForTicks(entity, tuning.dashDurationTicks);

    world.stamina.stamina[si] -= staminaCost;
  }
}


===== FILE: lib/core/ecs/systems/projectile_hit_system.dart =====
import '../../combat/damage.dart';
import '../entity_id.dart';
import '../hit/hit_resolver.dart';
import '../spatial/broadphase_grid.dart';
import '../world.dart';

class ProjectileHitSystem {
  final List<EntityId> _toDespawn = <EntityId>[];
  final HitResolver _resolver = HitResolver();

  void step(
    EcsWorld world,
    void Function(DamageRequest request) queueDamage,
    BroadphaseGrid broadphase,
  ) {
    final projectiles = world.projectile;
    if (projectiles.denseEntities.isEmpty) return;

    if (broadphase.targets.isEmpty) return;

    _toDespawn.clear();

    for (var pi = 0; pi < projectiles.denseEntities.length; pi += 1) {
      final p = projectiles.denseEntities[pi];
      if (!world.transform.has(p)) continue;
      if (!world.colliderAabb.has(p)) continue;

      final pti = world.transform.indexOf(p);
      final pa = world.colliderAabb.indexOf(p);
      final pcx = world.transform.posX[pti] + world.colliderAabb.offsetX[pa];
      final pcy = world.transform.posY[pti] + world.colliderAabb.offsetY[pa];
      final phx = world.colliderAabb.halfX[pa];
      final phy = world.colliderAabb.halfY[pa];

      final owner = projectiles.owner[pi];
      final sourceFaction = projectiles.faction[pi];

      final targetIndex = _resolver.firstOrderedOverlapCenters(
        broadphase: broadphase,
        centerX: pcx,
        centerY: pcy,
        halfX: phx,
        halfY: phy,
        owner: owner,
        sourceFaction: sourceFaction,
      );
      if (targetIndex == null) continue;

      final target = broadphase.targets.entities[targetIndex];
      queueDamage(
        DamageRequest(target: target, amount: projectiles.damage[pi]),
      );
      _toDespawn.add(p);
    }

    for (final e in _toDespawn) {
      world.destroyEntity(e);
    }
  }
}


===== FILE: lib/core/ecs/systems/projectile_system.dart =====
import '../../tuning/v0_movement_tuning.dart';
import '../world.dart';

class ProjectileSystem {
  void step(EcsWorld world, V0MovementTuningDerived movement) {
    final dt = movement.dtSeconds;
    final projectiles = world.projectile;

    for (var pi = 0; pi < projectiles.denseEntities.length; pi += 1) {
      final e = projectiles.denseEntities[pi];
      if (!world.transform.has(e)) {
        continue;
      }

      final ti = world.transform.indexOf(e);

      final vx = projectiles.dirX[pi] * projectiles.speedUnitsPerSecond[pi];
      final vy = projectiles.dirY[pi] * projectiles.speedUnitsPerSecond[pi];

      world.transform.velX[ti] = vx;
      world.transform.velY[ti] = vy;

      world.transform.posX[ti] += vx * dt;
      world.transform.posY[ti] += vy * dt;
    }
  }
}


===== FILE: lib/core/ecs/systems/resource_regen_system.dart =====
import '../../util/double_math.dart';
import '../world.dart';

class ResourceRegenSystem {
  void step(EcsWorld world, {required double dtSeconds}) {
    _regenHealth(world, dtSeconds);
    _regenMana(world, dtSeconds);
    _regenStamina(world, dtSeconds);
  }

  void _regenHealth(EcsWorld world, double dtSeconds) {
    final store = world.health;
    for (var i = 0; i < store.denseEntities.length; i += 1) {
      final max = store.hpMax[i];
      if (max <= 0) continue;
      final current = store.hp[i];
      if (current >= max) continue;
      final regen = store.regenPerSecond[i];
      if (regen <= 0) continue;
      store.hp[i] = clampDouble(current + regen * dtSeconds, 0.0, max);
    }
  }

  void _regenMana(EcsWorld world, double dtSeconds) {
    final store = world.mana;
    for (var i = 0; i < store.denseEntities.length; i += 1) {
      final max = store.manaMax[i];
      if (max <= 0) continue;
      final current = store.mana[i];
      if (current >= max) continue;
      final regen = store.regenPerSecond[i];
      if (regen <= 0) continue;
      store.mana[i] = clampDouble(current + regen * dtSeconds, 0.0, max);
    }
  }

  void _regenStamina(EcsWorld world, double dtSeconds) {
    final store = world.stamina;
    for (var i = 0; i < store.denseEntities.length; i += 1) {
      final max = store.staminaMax[i];
      if (max <= 0) continue;
      final current = store.stamina[i];
      if (current >= max) continue;
      final regen = store.regenPerSecond[i];
      if (regen <= 0) continue;
      store.stamina[i] = clampDouble(current + regen * dtSeconds, 0.0, max);
    }
  }
}


===== FILE: lib/core/ecs/systems/spell_cast_system.dart =====
import '../../spells/spawn_spell_projectile.dart';
import '../../spells/spell_catalog.dart';
import '../../util/double_math.dart';
import '../world.dart';
import '../../projectiles/projectile_catalog.dart';

/// Executes `CastIntentStore` intents by applying costs/cooldowns and spawning
/// spell projectiles.
///
/// IMPORTANT:
/// - Only intents with `intent.tick == currentTick` are considered valid.
/// - Mana spending + cooldown start happen only if a projectile was spawned.
/// - Intents are invalidated after processing by setting `intent.tick = -1`.
class SpellCastSystem {
  SpellCastSystem({
    required this.spells,
    required this.projectiles,
  });

  final SpellCatalog spells;
  final ProjectileCatalogDerived projectiles;

  void step(EcsWorld world, {required int currentTick}) {
    final intents = world.castIntent;
    if (intents.denseEntities.isEmpty) return;

    for (var ii = 0; ii < intents.denseEntities.length; ii += 1) {
      if (intents.tick[ii] != currentTick) continue;

      final caster = intents.denseEntities[ii];

      // Invalidate now so accidental multi-pass execution in the same tick cannot
      // double-cast. (Intent is still ignored next tick due to stamp mismatch.)
      intents.tick[ii] = -1;

      if (!world.transform.has(caster)) continue;
      if (!world.cooldown.has(caster)) continue;
      if (!world.mana.has(caster)) continue;

      final ci = world.cooldown.indexOf(caster);
      if (world.cooldown.castCooldownTicksLeft[ci] > 0) continue;

      final spellId = intents.spellId[ii];
      final def = spells.get(spellId);

      final mi = world.mana.indexOf(caster);
      final mana = world.mana.mana[mi];
      if (mana < def.stats.manaCost) continue;

      final fi = world.faction.tryIndexOf(caster);
      if (fi == null) continue;
      final faction = world.faction.faction[fi];

      final ti = world.transform.indexOf(caster);
      final spawned = spawnSpellProjectileFromCaster(
        world,
        spells: spells,
        projectiles: projectiles,
        spellId: spellId,
        faction: faction,
        owner: caster,
        casterX: world.transform.posX[ti],
        casterY: world.transform.posY[ti],
        originOffset: intents.originOffset[ii],
        dirX: intents.dirX[ii],
        dirY: intents.dirY[ii],
        fallbackDirX: intents.fallbackDirX[ii],
        fallbackDirY: intents.fallbackDirY[ii],
      );
      if (spawned == null) continue;

      world.mana.mana[mi] = clampDouble(
        mana - def.stats.manaCost,
        0.0,
        world.mana.manaMax[mi],
      );
      world.cooldown.castCooldownTicksLeft[ci] = intents.cooldownTicks[ii];
    }
  }
}


===== FILE: lib/core/ecs/world.dart =====
import '../snapshots/enums.dart';
import '../combat/faction.dart';
import 'entity_id.dart';
import 'stores/body_store.dart';
import 'stores/collider_aabb_store.dart';
import 'stores/collision_state_store.dart';
import 'stores/cooldown_store.dart';
import 'stores/cast_intent_store.dart';
import 'stores/gravity_control_store.dart';
import 'stores/flying_enemy_steering_store.dart';
import 'stores/faction_store.dart';
import 'stores/enemy_store.dart';
import 'stores/health_store.dart';
import 'stores/hit_once_store.dart';
import 'stores/hitbox_store.dart';
import 'stores/invulnerability_store.dart';
import 'stores/lifetime_store.dart';
import 'stores/mana_store.dart';
import 'stores/melee_intent_store.dart';
import 'stores/movement_store.dart';
import 'stores/player_input_store.dart';
import 'stores/projectile_store.dart';
import 'stores/spell_origin_store.dart';
import 'stores/stamina_store.dart';
import 'stores/surface_nav_state_store.dart';
import 'stores/transform_store.dart';
import '../enemies/enemy_id.dart';
import '../util/deterministic_rng.dart';

/// Minimal ECS world container (V0).
///
/// Entity IDs are monotonic and never reused.
class EcsWorld {
  EcsWorld({int seed = 0}) : seed = seed;

  /// Seed used for deterministic RNG in the core.
  final int seed;

  EntityId _nextEntityId = 1;

  final TransformStore transform = TransformStore();
  final PlayerInputStore playerInput = PlayerInputStore();
  final MovementStore movement = MovementStore();
  final BodyStore body = BodyStore();
  final ColliderAabbStore colliderAabb = ColliderAabbStore();
  final CollisionStateStore collision = CollisionStateStore();
  final CooldownStore cooldown = CooldownStore();
  final CastIntentStore castIntent = CastIntentStore();
  final GravityControlStore gravityControl = GravityControlStore();
  final FactionStore faction = FactionStore();
  final HealthStore health = HealthStore();
  final InvulnerabilityStore invulnerability = InvulnerabilityStore();
  final ManaStore mana = ManaStore();
  final MeleeIntentStore meleeIntent = MeleeIntentStore();
  final StaminaStore stamina = StaminaStore();
  final ProjectileStore projectile = ProjectileStore();
  final HitboxStore hitbox = HitboxStore();
  final HitOnceStore hitOnce = HitOnceStore();
  final LifetimeStore lifetime = LifetimeStore();
  final SpellOriginStore spellOrigin = SpellOriginStore();
  final SurfaceNavStateStore surfaceNav = SurfaceNavStateStore();
  final EnemyStore enemy = EnemyStore();
  final FlyingEnemySteeringStore flyingEnemySteering = FlyingEnemySteeringStore();

  EntityId createEntity() {
    final id = _nextEntityId;
    _nextEntityId += 1;
    return id;
  }

  EntityId createPlayer({
    required double posX,
    required double posY,
    required double velX,
    required double velY,
    required Facing facing,
    required bool grounded,
    required BodyDef body,
    required ColliderAabbDef collider,
    required HealthDef health,
    required ManaDef mana,
    required StaminaDef stamina,
  }) {
    final id = createEntity();
    transform.add(id, posX: posX, posY: posY, velX: velX, velY: velY);
    playerInput.add(id);
    movement.add(id, facing: facing);
    this.body.add(id, body);
    colliderAabb.add(id, collider);
    collision.add(id);
    cooldown.add(id);
    castIntent.add(id);
    faction.add(id, const FactionDef(faction: Faction.player));
    this.health.add(id, health);
    // Player-only invulnerability window (i-frames) after taking damage.
    invulnerability.add(id);
    this.mana.add(id, mana);
    meleeIntent.add(id);
    this.stamina.add(id, stamina);
    collision.grounded[collision.indexOf(id)] = grounded;
    return id;
  }

  EntityId createEnemy({
    required EnemyId enemyId,
    required double posX,
    required double posY,
    required double velX,
    required double velY,
    required Facing facing,
    required BodyDef body,
    required ColliderAabbDef collider,
    required HealthDef health,
    required ManaDef mana,
    required StaminaDef stamina,
  }) {
    final id = createEntity();
    transform.add(id, posX: posX, posY: posY, velX: velX, velY: velY);
    this.body.add(id, body);
    colliderAabb.add(id, collider);
    collision.add(id);
    cooldown.add(id);
    castIntent.add(id);
    faction.add(id, const FactionDef(faction: Faction.enemy));
    this.health.add(id, health);
    // Intentionally no `InvulnerabilityStore`: invulnerability is player-only in V0.
    this.mana.add(id, mana);
    meleeIntent.add(id);
    this.stamina.add(id, stamina);
    enemy.add(id, EnemyDef(enemyId: enemyId, facing: facing));
    if (enemyId == EnemyId.flyingEnemy) {
      flyingEnemySteering.add(
        id,
        FlyingEnemySteeringDef(rngState: seedFrom(seed, id)),
      );
    }
    if (enemyId == EnemyId.groundEnemy) {
      surfaceNav.add(id);
    }
    return id;
  }

  void destroyEntity(EntityId entity) {
    transform.removeEntity(entity);
    playerInput.removeEntity(entity);
    movement.removeEntity(entity);
    body.removeEntity(entity);
    colliderAabb.removeEntity(entity);
    collision.removeEntity(entity);
    cooldown.removeEntity(entity);
    castIntent.removeEntity(entity);
    gravityControl.removeEntity(entity);
    faction.removeEntity(entity);
    health.removeEntity(entity);
    invulnerability.removeEntity(entity);
    mana.removeEntity(entity);
    meleeIntent.removeEntity(entity);
    stamina.removeEntity(entity);
    projectile.removeEntity(entity);
    hitbox.removeEntity(entity);
    hitOnce.removeEntity(entity);
    lifetime.removeEntity(entity);
    spellOrigin.removeEntity(entity);
    surfaceNav.removeEntity(entity);
    enemy.removeEntity(entity);
    flyingEnemySteering.removeEntity(entity);
  }
}


===== FILE: lib/core/enemies/enemy_catalog.dart =====
import '../ecs/stores/body_store.dart';
import '../ecs/stores/collider_aabb_store.dart';
import '../ecs/stores/health_store.dart';
import '../ecs/stores/mana_store.dart';
import '../ecs/stores/stamina_store.dart';
import 'enemy_id.dart';

/// Static archetype data for enemies (V0).
///
/// IMPORTANT:
/// - Keeps per-enemy stats in one place to avoid divergence between spawn code,
///   tests, and future deterministic spawning.
/// - AI behavior tuning (cooldowns/speeds/ranges) lives in
///   `V0FlyingEnemyTuning` and `V0GroundEnemyTuning`.
class EnemyArchetype {
  const EnemyArchetype({
    required this.body,
    required this.collider,
    required this.health,
    required this.mana,
    required this.stamina,
  });

  final BodyDef body;
  final ColliderAabbDef collider;
  final HealthDef health;
  final ManaDef mana;
  final StaminaDef stamina;
}

class EnemyCatalog {
  const EnemyCatalog();

  EnemyArchetype get(EnemyId id) {
    switch (id) {
      case EnemyId.flyingEnemy:
        return const EnemyArchetype(
          body: BodyDef(
            isKinematic: false,
            useGravity: false,
            gravityScale: 0.0,
            sideMask: BodyDef.sideNone,
            maxVelX: 800.0,
            maxVelY: 800.0,
          ),
          collider: ColliderAabbDef(halfX: 12.0, halfY: 12.0),
          health: HealthDef(hp: 50.0, hpMax: 50.0, regenPerSecond: 0.0),
          mana: ManaDef(mana: 80.0, manaMax: 80.0, regenPerSecond: 5.0),
          stamina: StaminaDef(stamina: 0.0, staminaMax: 0.0, regenPerSecond: 0.0),
        );
      case EnemyId.groundEnemy:
        return const EnemyArchetype(
          body: BodyDef(
            isKinematic: false,
            useGravity: true,
            ignoreCeilings: true,
            gravityScale: 1.0,
            sideMask: BodyDef.sideLeft | BodyDef.sideRight,
          ),
          collider: ColliderAabbDef(halfX: 12.0, halfY: 12.0),
          health: HealthDef(hp: 50.0, hpMax: 50.0, regenPerSecond: 0.0),
          mana: ManaDef(mana: 0.0, manaMax: 0.0, regenPerSecond: 0.0),
          stamina: StaminaDef(stamina: 0.0, staminaMax: 0.0, regenPerSecond: 0.0),
        );
    }
  }
}



===== FILE: lib/core/enemies/enemy_id.dart =====
/// Enemy archetype identifiers (protocol-stable for snapshots/networking).
enum EnemyId { flyingEnemy, groundEnemy }



===== FILE: lib/core/events/game_event.dart =====
/// Core -> Render/UI event model.
///
/// Events are transient side effects emitted by the simulation (SFX triggers,
/// screen shake, spawn/despawn notifications, etc.). Render/UI may consume them
/// once; gameplay truth still comes from snapshots.
part 'run_events.dart';

sealed class GameEvent {
  const GameEvent();
}


===== FILE: lib/core/events/run_events.dart =====
part of 'game_event.dart';

enum RunEndReason {
  fellBehindCamera,
}

class RunEndedEvent extends GameEvent {
  const RunEndedEvent({
    required this.tick,
    required this.distance,
    required this.reason,
  });

  final int tick;
  final double distance;
  final RunEndReason reason;
}


===== FILE: lib/core/game_core.dart =====
// Authoritative, deterministic simulation layer (pure Dart).
//
// This is the "truth" of the game: it applies tick-stamped commands, advances
// the simulation by fixed ticks, and produces snapshots/events for the
// renderer/UI. It must not import Flutter or Flame.
import 'dart:math';

import 'commands/command.dart';
import 'camera/v0_autoscroll_camera.dart';
import 'collision/static_world_geometry.dart';
import 'collision/static_world_geometry_index.dart';
import 'contracts/v0_render_contract.dart';
import 'ecs/entity_id.dart';
import 'ecs/stores/collider_aabb_store.dart';
import 'ecs/spatial/broadphase_grid.dart';
import 'ecs/spatial/grid_index_2d.dart';
import 'ecs/systems/collision_system.dart';
import 'ecs/systems/cooldown_system.dart';
import 'ecs/systems/gravity_system.dart';
import 'ecs/systems/player_cast_system.dart';
import 'ecs/systems/spell_cast_system.dart';
import 'ecs/systems/damage_system.dart';
import 'ecs/systems/health_despawn_system.dart';
import 'ecs/systems/enemy_system.dart';
import 'ecs/systems/hitbox_damage_system.dart';
import 'ecs/systems/hitbox_follow_owner_system.dart';
import 'ecs/systems/invulnerability_system.dart';
import 'ecs/systems/lifetime_system.dart';
import 'ecs/systems/player_melee_system.dart';
import 'ecs/systems/melee_attack_system.dart';
import 'ecs/systems/player_movement_system.dart';
import 'ecs/systems/projectile_system.dart';
import 'ecs/systems/projectile_hit_system.dart';
import 'ecs/systems/resource_regen_system.dart';
import 'ecs/stores/body_store.dart';
import 'ecs/stores/health_store.dart';
import 'ecs/stores/mana_store.dart';
import 'ecs/stores/stamina_store.dart';
import 'ecs/world.dart';
import 'enemies/enemy_catalog.dart';
import 'enemies/enemy_id.dart';
import 'events/game_event.dart';
import 'math/vec2.dart';
import 'navigation/jump_template.dart';
import 'navigation/surface_graph_builder.dart';
import 'navigation/surface_navigator.dart';
import 'navigation/surface_pathfinder.dart';
import 'snapshots/enums.dart';
import 'snapshots/entity_render_snapshot.dart';
import 'snapshots/game_state_snapshot.dart';
import 'snapshots/player_hud_snapshot.dart';
import 'snapshots/static_solid_snapshot.dart';
import 'projectiles/projectile_catalog.dart';
import 'spells/spell_catalog.dart';
import 'track/v0_track_streamer.dart';
import 'tuning/v0_ability_tuning.dart';
import 'tuning/v0_combat_tuning.dart';
import 'tuning/v0_flying_enemy_tuning.dart';
import 'tuning/v0_ground_enemy_tuning.dart';
import 'tuning/v0_movement_tuning.dart';
import 'tuning/v0_navigation_tuning.dart';
import 'tuning/v0_physics_tuning.dart';
import 'tuning/v0_resource_tuning.dart';
import 'tuning/v0_camera_tuning.dart';
import 'tuning/v0_spatial_grid_tuning.dart';
import 'tuning/v0_track_tuning.dart';
import 'util/tick_math.dart';

const StaticWorldGeometry v0DefaultStaticWorldGeometry = StaticWorldGeometry(
  groundPlane: StaticGroundPlane(topY: v0GroundTopY * 1.0),
  // Chunk streaming (Milestone 12) supplies platforms/obstacles deterministically.
  solids: <StaticSolid>[],
);

/// Minimal placeholder `GameCore` used to validate architecture wiring.
///
/// This will be replaced by the full ECS/systems implementation in later
/// milestones. The core invariants remain: fixed ticks, command-driven input,
/// deterministic state updates, snapshot output.
class GameCore {
  GameCore({
    required this.seed,
    this.tickHz = v0DefaultTickHz,
    V0PhysicsTuning physicsTuning = const V0PhysicsTuning(),
    V0MovementTuning movementTuning = const V0MovementTuning(),
    V0ResourceTuning resourceTuning = const V0ResourceTuning(),
    V0AbilityTuning abilityTuning = const V0AbilityTuning(),
    V0CombatTuning combatTuning = const V0CombatTuning(),
    V0FlyingEnemyTuning flyingEnemyTuning = const V0FlyingEnemyTuning(),
    V0GroundEnemyTuning groundEnemyTuning = const V0GroundEnemyTuning(),
    V0NavigationTuning navigationTuning = const V0NavigationTuning(),
    V0SpatialGridTuning spatialGridTuning = const V0SpatialGridTuning(),
    V0CameraTuning cameraTuning = const V0CameraTuning(),
    V0TrackTuning trackTuning = const V0TrackTuning(),
    SpellCatalog spellCatalog = const SpellCatalog(),
    ProjectileCatalog projectileCatalog = const ProjectileCatalog(),
    EnemyCatalog enemyCatalog = const EnemyCatalog(),
    BodyDef? playerBody,
    StaticWorldGeometry? staticWorldGeometry,
  }) : _movement = V0MovementTuningDerived.from(
          movementTuning,
          tickHz: tickHz,
       ),
       _physicsTuning = physicsTuning,
       _resourceTuning = resourceTuning,
       _abilities = V0AbilityTuningDerived.from(abilityTuning, tickHz: tickHz),
       _combat = V0CombatTuningDerived.from(combatTuning, tickHz: tickHz),
       _flyingEnemyTuning = V0FlyingEnemyTuningDerived.from(
         flyingEnemyTuning,
         tickHz: tickHz,
       ),
       _groundEnemyTuning = V0GroundEnemyTuningDerived.from(
         groundEnemyTuning,
         tickHz: tickHz,
       ),
       _navigationTuning = navigationTuning,
        _spatialGridTuning = spatialGridTuning,
        _spells = spellCatalog,
        _projectiles = ProjectileCatalogDerived.from(
          projectileCatalog,
          tickHz: tickHz,
        ),
        _enemyCatalog = enemyCatalog,
        _baseStaticWorldGeometry =
            staticWorldGeometry ?? v0DefaultStaticWorldGeometry,
        _trackTuning = trackTuning {
    _world = EcsWorld(seed: seed);
    _movementSystem = PlayerMovementSystem();
    _collisionSystem = CollisionSystem();
    _cooldownSystem = CooldownSystem();
    _gravitySystem = GravitySystem();
    _projectileSystem = ProjectileSystem();
    _projectileHitSystem = ProjectileHitSystem();
    _broadphaseGrid = BroadphaseGrid(
      index: GridIndex2D(cellSize: _spatialGridTuning.broadphaseCellSize),
    );
    _hitboxFollowOwnerSystem = HitboxFollowOwnerSystem();
    _lifetimeSystem = LifetimeSystem();
    _invulnerabilitySystem = InvulnerabilitySystem();
    _damageSystem = DamageSystem(invulnerabilityTicksOnHit: _combat.invulnerabilityTicks);
    _healthDespawnSystem = HealthDespawnSystem();
    _meleeSystem = PlayerMeleeSystem(abilities: _abilities, movement: _movement);
    _hitboxDamageSystem = HitboxDamageSystem();
    _resourceRegenSystem = ResourceRegenSystem();
    _castSystem = PlayerCastSystem(abilities: _abilities, movement: _movement);
    _spellCastSystem = SpellCastSystem(spells: _spells, projectiles: _projectiles);
    _meleeAttackSystem = MeleeAttackSystem();
    _surfaceGraphBuilder = SurfaceGraphBuilder(
      surfaceGrid: GridIndex2D(cellSize: _spatialGridTuning.broadphaseCellSize),
      takeoffSampleMaxStep: _navigationTuning.takeoffSampleMaxStep,
    );
    _groundEnemyJumpTemplate = JumpReachabilityTemplate.build(
      JumpProfile(
        jumpSpeed: _groundEnemyTuning.base.groundEnemyJumpSpeed,
        gravityY: _physicsTuning.gravityY,
        maxAirTicks: _groundEnemyMaxAirTicks(),
        airSpeedX: _groundEnemyTuning.base.groundEnemySpeedX,
        dtSeconds: _movement.dtSeconds,
        agentHalfWidth: _enemyCatalog.get(EnemyId.groundEnemy).collider.halfX,
      ),
    );
    _surfacePathfinder = SurfacePathfinder(
      maxExpandedNodes: _navigationTuning.maxExpandedNodes,
      runSpeedX: _groundEnemyTuning.base.groundEnemySpeedX,
      edgePenaltySeconds: _navigationTuning.edgePenaltySeconds,
    );
    _surfaceNavigator = SurfaceNavigator(
      pathfinder: _surfacePathfinder,
      repathCooldownTicks: _navigationTuning.repathCooldownTicks,
      surfaceEps: _navigationTuning.surfaceEps,
      takeoffEps: max(
        _navigationTuning.takeoffEpsMin,
        _groundEnemyTuning.base.groundEnemyStopDistanceX,
      ),
    );
    _enemySystem = EnemySystem(
      flyingEnemyTuning: _flyingEnemyTuning,
      groundEnemyTuning: _groundEnemyTuning,
      surfaceNavigator: _surfaceNavigator,
    );
    _cameraTuning = V0CameraTuningDerived.from(cameraTuning, movement: _movement);
    _camera = V0AutoscrollCamera(
      viewWidth: v0VirtualWidth.toDouble(),
      tuning: _cameraTuning,
      initial: V0CameraState(
        centerX: v0VirtualWidth * 0.5,
        targetX: v0VirtualWidth * 0.5,
        speedX: 0.0,
      ),
    );

    _setStaticWorldGeometry(_baseStaticWorldGeometry);

    final spawnX = 400.0;
    final spawnY =
        (_staticWorldGeometry.groundPlane?.topY ?? v0GroundTopY.toDouble()) -
        _movement.base.playerRadius;
    final defaultBody = BodyDef(
      enabled: true,
      isKinematic: false,
      useGravity: true,
      topOnlyGround: true,
      gravityScale: 1.0,
      maxVelX: _movement.base.maxVelX,
      maxVelY: _movement.base.maxVelY,
      sideMask: BodyDef.sideLeft | BodyDef.sideRight,
    );
    _player = _world.createPlayer(
      posX: spawnX,
      posY: spawnY,
      velX: 0.0,
      velY: 0.0,
      facing: Facing.right,
      grounded: true,
      body: playerBody ?? defaultBody,
      collider: ColliderAabbDef(
        halfX: _movement.base.playerRadius,
        halfY: _movement.base.playerRadius,
      ),
      health: HealthDef(
        hp: _resourceTuning.playerHpStart ?? _resourceTuning.playerHpMax,
        hpMax: _resourceTuning.playerHpMax,
        regenPerSecond: _resourceTuning.playerHpRegenPerSecond,
      ),
      mana: ManaDef(
        mana: _resourceTuning.playerManaStart ?? _resourceTuning.playerManaMax,
        manaMax: _resourceTuning.playerManaMax,
        regenPerSecond: _resourceTuning.playerManaRegenPerSecond,
      ),
      stamina: StaminaDef(
        stamina:
            _resourceTuning.playerStaminaStart ?? _resourceTuning.playerStaminaMax,
        staminaMax: _resourceTuning.playerStaminaMax,
        regenPerSecond: _resourceTuning.playerStaminaRegenPerSecond,
      ),
    );

    // Milestone 12: stream deterministic chunks (static solids + enemy spawns).
    //
    // If a custom [staticWorldGeometry] was provided (typically tests), keep the
    // geometry fixed and skip track streaming unless explicitly enabled later.
    if (staticWorldGeometry == null && _trackTuning.enabled) {
      final groundTopY = _staticWorldGeometry.groundPlane?.topY ??
          v0GroundTopY.toDouble();
      _trackStreamer = V0TrackStreamer(
        seed: seed,
        tuning: _trackTuning,
        groundTopY: groundTopY,
      );
      _trackStreamerStep();
    }
  }

  EntityId _spawnFlyingEnemy({required double spawnX, required double groundTopY}) {
    // Enemy spawn stats come from a centralized catalog so these hardcoded spawns
    // don't diverge from future deterministic spawning rules.
    final archetype = _enemyCatalog.get(EnemyId.flyingEnemy);
    final flyingEnemy = _world.createEnemy(
      enemyId: EnemyId.flyingEnemy,
      posX: spawnX,
      posY: groundTopY - _flyingEnemyTuning.base.flyingEnemyHoverOffsetY,
      velX: 0.0,
      velY: 0.0,
      facing: Facing.left,
      body: archetype.body,
      collider: archetype.collider,
      health: archetype.health,
      mana: archetype.mana,
      stamina: archetype.stamina,
    );

    // Avoid immediate spawn-tick casting (keeps early-game tests stable).
    _world.cooldown.castCooldownTicksLeft[
        _world.cooldown.indexOf(flyingEnemy)] =
        _flyingEnemyTuning.flyingEnemyCastCooldownTicks;

    return flyingEnemy;
  }

  EntityId _spawnGroundEnemy({required double spawnX, required double groundTopY}) {
    final archetype = _enemyCatalog.get(EnemyId.groundEnemy);

    // GroundEnemy uses the archetype, but clamps should stay aligned with the
    // current movement tuning.
    return _world.createEnemy(
      enemyId: EnemyId.groundEnemy,
      posX: spawnX,
      posY: groundTopY - archetype.collider.halfY,
      velX: 0.0,
      velY: 0.0,
      facing: Facing.left,
      body: BodyDef(
        enabled: archetype.body.enabled,
        isKinematic: archetype.body.isKinematic,
        useGravity: archetype.body.useGravity,
        ignoreCeilings: archetype.body.ignoreCeilings,
        topOnlyGround: archetype.body.topOnlyGround,
        gravityScale: archetype.body.gravityScale,
        maxVelX: _movement.base.maxVelX,
        maxVelY: _movement.base.maxVelY,
        sideMask: archetype.body.sideMask,
      ),
      collider: archetype.collider,
      health: archetype.health,
      mana: archetype.mana,
      stamina: archetype.stamina,
    );
  }

  /// Seed used for deterministic generation/RNG.
  final int seed;

  /// Fixed simulation tick frequency.
  final int tickHz;

  /// Base static world geometry for this run/session (hand-authored seed state).
  final StaticWorldGeometry _baseStaticWorldGeometry;

  /// Current static world geometry (base + any streamed chunk solids).
  StaticWorldGeometry get staticWorldGeometry => _staticWorldGeometry;
  late StaticWorldGeometry _staticWorldGeometry;
  late StaticWorldGeometryIndex _staticWorldIndex;
  late List<StaticSolidSnapshot> _staticSolidsSnapshot;

  final V0MovementTuningDerived _movement;
  final V0PhysicsTuning _physicsTuning;
  final V0ResourceTuning _resourceTuning;
  final V0AbilityTuningDerived _abilities;
  final V0CombatTuningDerived _combat;
  final V0FlyingEnemyTuningDerived _flyingEnemyTuning;
  final V0GroundEnemyTuningDerived _groundEnemyTuning;
  final V0NavigationTuning _navigationTuning;
  final V0SpatialGridTuning _spatialGridTuning;
  late final V0CameraTuningDerived _cameraTuning;
  final V0TrackTuning _trackTuning;
  final SpellCatalog _spells;
  final ProjectileCatalogDerived _projectiles;
  final EnemyCatalog _enemyCatalog;
  late final SurfaceGraphBuilder _surfaceGraphBuilder;
  late final JumpReachabilityTemplate _groundEnemyJumpTemplate;
  int _surfaceGraphVersion = 0;

  V0TrackStreamer? _trackStreamer;

  late final EcsWorld _world;
  late final PlayerMovementSystem _movementSystem;
  late final CollisionSystem _collisionSystem;
  late final CooldownSystem _cooldownSystem;
  late final GravitySystem _gravitySystem;
  late final ProjectileSystem _projectileSystem;
  late final ProjectileHitSystem _projectileHitSystem;
  late final BroadphaseGrid _broadphaseGrid;
  late final HitboxFollowOwnerSystem _hitboxFollowOwnerSystem;
  late final LifetimeSystem _lifetimeSystem;
  late final InvulnerabilitySystem _invulnerabilitySystem;
  late final DamageSystem _damageSystem;
  late final HealthDespawnSystem _healthDespawnSystem;
  late final EnemySystem _enemySystem;
  late final SurfacePathfinder _surfacePathfinder;
  late final SurfaceNavigator _surfaceNavigator;
  late final PlayerMeleeSystem _meleeSystem;
  late final MeleeAttackSystem _meleeAttackSystem;
  late final HitboxDamageSystem _hitboxDamageSystem;
  late final ResourceRegenSystem _resourceRegenSystem;
  late final PlayerCastSystem _castSystem;
  late final SpellCastSystem _spellCastSystem;
  late final EntityId _player;
  late final V0AutoscrollCamera _camera;

  final List<GameEvent> _events = <GameEvent>[];

  /// Current simulation tick.
  int tick = 0;

  /// Whether simulation should advance.
  bool paused = false;

  /// Whether the run has ended (simulation is frozen).
  bool gameOver = false;

  /// Run progression metric (placeholder).
  double distance = 0;

  double get playerPosX =>
      _world.transform.posX[_world.transform.indexOf(_player)];
  double get playerPosY =>
      _world.transform.posY[_world.transform.indexOf(_player)];

  void setPlayerPosXY(double x, double y) =>
      _world.transform.setPosXY(_player, x, y);

  double get playerVelX =>
      _world.transform.velX[_world.transform.indexOf(_player)];
  double get playerVelY =>
      _world.transform.velY[_world.transform.indexOf(_player)];

  void setPlayerVelXY(double x, double y) =>
      _world.transform.setVelXY(_player, x, y);

  bool get playerGrounded =>
      _world.collision.grounded[_world.collision.indexOf(_player)];

  Facing get playerFacing =>
      _world.movement.facing[_world.movement.indexOf(_player)];
  set playerFacing(Facing value) {
    _world.movement.facing[_world.movement.indexOf(_player)] = value;
  }

  int get playerCastCooldownTicksLeft =>
      _world.cooldown.castCooldownTicksLeft[_world.cooldown.indexOf(_player)];

  int get playerMeleeCooldownTicksLeft =>
      _world.cooldown.meleeCooldownTicksLeft[_world.cooldown.indexOf(_player)];

  /// Applies all commands scheduled for the current tick.
  ///
  /// In the final architecture, commands are the only mechanism for the UI to
  /// influence the simulation.
  void applyCommands(List<Command> commands) {
    _world.playerInput.resetTickInputs(_player);
    final inputIndex = _world.playerInput.indexOf(_player);
    final movementIndex = _world.movement.indexOf(_player);

    for (final command in commands) {
      switch (command) {
        case MoveAxisCommand(:final axis):
          final clamped = axis.clamp(-1.0, 1.0);
          _world.playerInput.moveAxis[inputIndex] = clamped;

          if (_world.movement.dashTicksLeft[movementIndex] == 0) {
            if (clamped < 0) {
              playerFacing = Facing.left;
            } else if (clamped > 0) {
              playerFacing = Facing.right;
            }
          }
        case JumpPressedCommand():
          _world.playerInput.jumpPressed[inputIndex] = true;
        case DashPressedCommand():
          _world.playerInput.dashPressed[inputIndex] = true;
        case AttackPressedCommand():
          _world.playerInput.attackPressed[inputIndex] = true;
          break;
        case AimDirCommand(:final x, :final y):
          _world.playerInput.aimDirX[inputIndex] = x;
          _world.playerInput.aimDirY[inputIndex] = y;
        case ClearAimDirCommand():
          _world.playerInput.aimDirX[inputIndex] = 0;
          _world.playerInput.aimDirY[inputIndex] = 0;
        case CastPressedCommand():
          _world.playerInput.castPressed[inputIndex] = true;
      }
    }
  }

  /// Advances the simulation by exactly one fixed tick.
  void stepOneTick() {
    if (paused || gameOver) return;

    tick += 1;

    _trackStreamerStep();

    _cooldownSystem.step(_world);
    _invulnerabilitySystem.step(_world);

    final groundTopY =
        staticWorldGeometry.groundPlane?.topY ?? v0GroundTopY.toDouble();
    _enemySystem.stepSteering(
      _world,
      player: _player,
      groundTopY: groundTopY,
      dtSeconds: _movement.dtSeconds,
    );

    _movementSystem.step(_world, _movement, resources: _resourceTuning);
    _gravitySystem.step(_world, _movement, physics: _physicsTuning);
    _collisionSystem.step(
      _world,
      _movement,
      staticWorld: _staticWorldIndex,
    );

    distance += max(0.0, playerVelX) * _movement.dtSeconds;

    _camera.updateTick(
      dtSeconds: _movement.dtSeconds,
      playerX: playerPosX,
    );
    if (_checkFellBehindCamera()) {
      gameOver = true;
      paused = true;
      _events.add(
        RunEndedEvent(
          tick: tick,
          distance: distance,
          reason: RunEndReason.fellBehindCamera,
        ),
      );
      return;
    }

    // Rebuild broadphase after movement/collision so damageable target positions
    // are final for the tick before any hit queries run.
    _broadphaseGrid.rebuild(_world);

    // Move already-existing projectiles before spawning new ones so newly spawned
    // projectiles remain at their spawn positions until the next tick.
    _projectileSystem.step(_world, _movement);

    // IMPORTANT (determinism): intent writers run in a fixed order (enemy first,
    // then player), and shared execution consumes only intents stamped for this tick.
    _enemySystem.stepAttacks(_world, player: _player, currentTick: tick);
    _castSystem.step(_world, player: _player, currentTick: tick);
    _meleeSystem.step(_world, player: _player, currentTick: tick);

    // Execute intents after all writers have run.
    _spellCastSystem.step(_world, currentTick: tick);
    _meleeAttackSystem.step(_world, currentTick: tick);

    // Position hitboxes from their owner + offset so spawn-time positions are
    // consistent and don't drift (single source of truth is `HitboxStore.offset`).
    _hitboxFollowOwnerSystem.step(_world);

    // Resolve hits after all attacks have been spawned so both newly spawned
    // projectiles and hitboxes can hit on their spawn tick.
    _projectileHitSystem.step(_world, _damageSystem.queue, _broadphaseGrid);
    _hitboxDamageSystem.step(_world, _damageSystem.queue, _broadphaseGrid);
    _damageSystem.step(_world);
    _healthDespawnSystem.step(_world, player: _player);
    _resourceRegenSystem.step(_world, dtSeconds: _movement.dtSeconds);

    // Cleanup last so effect entities get their full last tick to act.
    _lifetimeSystem.step(_world);

  }

  bool _checkFellBehindCamera() {
    if (!(_world.transform.has(_player) && _world.colliderAabb.has(_player))) {
      return false;
    }

    final ti = _world.transform.indexOf(_player);
    final ai = _world.colliderAabb.indexOf(_player);
    final centerX = _world.transform.posX[ti] + _world.colliderAabb.offsetX[ai];
    final right = centerX + _world.colliderAabb.halfX[ai];
    return right < _camera.left();
  }

  void _trackStreamerStep() {
    final streamer = _trackStreamer;
    if (streamer == null) return;

    final changed = streamer.step(
      cameraLeft: _camera.left(),
      cameraRight: _camera.right(),
      spawnEnemy: (enemyId, x) {
        final groundTopY = _staticWorldGeometry.groundPlane?.topY ??
            v0GroundTopY.toDouble();
        switch (enemyId) {
          case EnemyId.flyingEnemy:
            _spawnFlyingEnemy(spawnX: x, groundTopY: groundTopY);
          case EnemyId.groundEnemy:
            _spawnGroundEnemy(spawnX: x, groundTopY: groundTopY);
        }
      },
    );

    if (!changed) return;

    // Rebuild collision index only when geometry changes (spawn/cull).
    final combinedSolids = <StaticSolid>[
      ..._baseStaticWorldGeometry.solids,
      ...streamer.dynamicSolids,
    ];
    _setStaticWorldGeometry(
      StaticWorldGeometry(
        groundPlane: _baseStaticWorldGeometry.groundPlane,
        solids: List<StaticSolid>.unmodifiable(combinedSolids),
      ),
    );
  }

  void _setStaticWorldGeometry(StaticWorldGeometry geometry) {
    _staticWorldGeometry = geometry;
    _staticWorldIndex = StaticWorldGeometryIndex.from(geometry);
    _staticSolidsSnapshot = _buildStaticSolidsSnapshot(geometry);
    _rebuildSurfaceGraph();
  }

  void _rebuildSurfaceGraph() {
    _surfaceGraphVersion += 1;
    final result = _surfaceGraphBuilder.build(
      geometry: _staticWorldGeometry,
      jumpTemplate: _groundEnemyJumpTemplate,
    );
    _enemySystem.setSurfaceGraph(
      graph: result.graph,
      spatialIndex: result.spatialIndex,
      graphVersion: _surfaceGraphVersion,
    );
  }

  int _groundEnemyMaxAirTicks() {
    final gravity = _physicsTuning.gravityY;
    if (gravity <= 0) {
      return ticksFromSecondsCeil(1.0, tickHz);
    }
    final jumpSpeed = _groundEnemyTuning.base.groundEnemyJumpSpeed.abs();
    final baseAirSeconds = (2.0 * jumpSpeed) / gravity;
    return ticksFromSecondsCeil(baseAirSeconds * 1.5, tickHz);
  }

  static List<StaticSolidSnapshot> _buildStaticSolidsSnapshot(
    StaticWorldGeometry geometry,
  ) {
    return List<StaticSolidSnapshot>.unmodifiable(
      geometry.solids.map(
        (s) => StaticSolidSnapshot(
          minX: s.minX,
          minY: s.minY,
          maxX: s.maxX,
          maxY: s.maxY,
          sides: s.sides,
          oneWayTop: s.oneWayTop,
        ),
      ),
    );
  }

  List<GameEvent> drainEvents() {
    if (_events.isEmpty) return const <GameEvent>[];
    final drained = List<GameEvent>.unmodifiable(_events);
    _events.clear();
    return drained;
  }

  /// Builds an immutable snapshot for render/UI consumption.
  GameStateSnapshot buildSnapshot() {
    final tuning = _movement.base;
    final mi = _world.movement.indexOf(_player);
    final dashing = _world.movement.dashTicksLeft[mi] > 0;
    final onGround = _world.collision.grounded[_world.collision.indexOf(_player)];
    final hi = _world.health.indexOf(_player);
    final mai = _world.mana.indexOf(_player);
    final si = _world.stamina.indexOf(_player);

    final AnimKey anim;
    if (dashing) {
      anim = AnimKey.run;
    } else if (!onGround) {
      anim = playerVelY < 0 ? AnimKey.jump : AnimKey.fall;
    } else if (playerVelX.abs() > tuning.minMoveSpeed) {
      anim = AnimKey.run;
    } else {
      anim = AnimKey.idle;
    }

    final playerPos = Vec2(playerPosX, playerPosY);
    final playerVel = Vec2(playerVelX, playerVelY);

    final entities = <EntityRenderSnapshot>[
      EntityRenderSnapshot(
        id: _player,
        kind: EntityKind.player,
        pos: playerPos,
        vel: playerVel,
        size: Vec2(tuning.playerRadius * 2, tuning.playerRadius * 2),
        facing: playerFacing,
        anim: anim,
        grounded: onGround,
      ),
    ];

    final projectileStore = _world.projectile;
    for (var pi = 0; pi < projectileStore.denseEntities.length; pi += 1) {
      final e = projectileStore.denseEntities[pi];
      if (!(_world.transform.has(e))) continue;
      final ti = _world.transform.indexOf(e);

      final projectileId = projectileStore.projectileId[pi];
      final proj = _projectiles.base.get(projectileId);
      final colliderSize = Vec2(proj.colliderSizeX, proj.colliderSizeY);

      final dx = projectileStore.dirX[pi];
      final facing = dx >= 0 ? Facing.right : Facing.left;

      entities.add(
        EntityRenderSnapshot(
          id: e,
          kind: EntityKind.projectile,
          pos: Vec2(_world.transform.posX[ti], _world.transform.posY[ti]),
          vel: Vec2(_world.transform.velX[ti], _world.transform.velY[ti]),
          size: colliderSize,
          projectileId: projectileId,
          facing: facing,
          anim: AnimKey.idle,
          grounded: false,
        ),
      );
    }

    final hitboxes = _world.hitbox;
    for (var hi = 0; hi < hitboxes.denseEntities.length; hi += 1) {
      final e = hitboxes.denseEntities[hi];
      if (!(_world.transform.has(e))) continue;
      final ti = _world.transform.indexOf(e);

      final size = Vec2(hitboxes.halfX[hi] * 2, hitboxes.halfY[hi] * 2);
      final facing = hitboxes.offsetX[hi] >= 0 ? Facing.right : Facing.left;

      entities.add(
        EntityRenderSnapshot(
          id: e,
          kind: EntityKind.trigger,
          pos: Vec2(_world.transform.posX[ti], _world.transform.posY[ti]),
          size: size,
          facing: facing,
          anim: AnimKey.hit,
          grounded: false,
        ),
      );
    }

    final enemies = _world.enemy;
    for (var ei = 0; ei < enemies.denseEntities.length; ei += 1) {
      final e = enemies.denseEntities[ei];
      if (!(_world.transform.has(e))) continue;
      final ti = _world.transform.indexOf(e);

      Vec2? size;
      if (_world.colliderAabb.has(e)) {
        final aabbi = _world.colliderAabb.indexOf(e);
        size = Vec2(
          _world.colliderAabb.halfX[aabbi] * 2,
          _world.colliderAabb.halfY[aabbi] * 2,
        );
      }

      entities.add(
        EntityRenderSnapshot(
          id: e,
          kind: EntityKind.enemy,
          pos: Vec2(_world.transform.posX[ti], _world.transform.posY[ti]),
          vel: Vec2(_world.transform.velX[ti], _world.transform.velY[ti]),
          size: size,
          facing: enemies.facing[ei],
          anim: AnimKey.idle,
          grounded: _world.collision.has(e)
              ? _world.collision.grounded[_world.collision.indexOf(e)]
              : false,
        ),
      );
    }

    return GameStateSnapshot(
      tick: tick,
      seed: seed,
      distance: distance,
      paused: paused,
      gameOver: gameOver,
      cameraCenterX: _camera.state.centerX,
      cameraCenterY: v0CameraFixedY,
      hud: PlayerHudSnapshot(
        hp: _world.health.hp[hi],
        hpMax: _world.health.hpMax[hi],
        mana: _world.mana.mana[mai],
        manaMax: _world.mana.manaMax[mai],
        stamina: _world.stamina.stamina[si],
        staminaMax: _world.stamina.staminaMax[si],
        score: 0,
        coins: 0,
      ),
      entities: entities,
      staticSolids: _staticSolidsSnapshot,
    );
  }
}


===== FILE: lib/core/math/vec2.dart =====
/// Minimal 2D vector type used by the Core simulation.
///
/// This is intentionally kept small and dependency-free so `lib/core/**` can
/// stay pure Dart (no Flutter/Flame imports) and deterministic.
class Vec2 {
  const Vec2(this.x, this.y);

  /// X coordinate, in world units (virtual pixels).
  final double x;

  /// Y coordinate, in world units (virtual pixels).
  final double y;

  /// Returns a copy with a different X value.
  Vec2 withX(double value) => Vec2(value, y);

  /// Returns a copy with a different Y value.
  Vec2 withY(double value) => Vec2(x, value);

  /// Vector addition.
  Vec2 operator +(Vec2 other) => Vec2(x + other.x, y + other.y);

  /// Vector subtraction.
  Vec2 operator -(Vec2 other) => Vec2(x - other.x, y - other.y);

  /// Scalar multiplication.
  Vec2 scale(double factor) => Vec2(x * factor, y * factor);
}


===== FILE: lib/core/projectiles/projectile_catalog.dart =====
import '../util/tick_math.dart';

import 'projectile_id.dart';

class ProjectileArchetype {
  const ProjectileArchetype({
    required this.speedUnitsPerSecond,
    required this.lifetimeSeconds,
    required this.colliderSizeX,
    required this.colliderSizeY,
  });

  final double speedUnitsPerSecond;
  final double lifetimeSeconds;

  /// Full extents, in world units (virtual pixels).
  final double colliderSizeX;
  final double colliderSizeY;
}

class ProjectileCatalog {
  const ProjectileCatalog();

  ProjectileArchetype get(ProjectileId id) {
    switch (id) {
      case ProjectileId.iceBolt:
        return const ProjectileArchetype(
          speedUnitsPerSecond: 1600.0,
          lifetimeSeconds: 1.0,
          colliderSizeX: 18.0,
          colliderSizeY: 8.0,
        );
      case ProjectileId.lightningBolt:
        return const ProjectileArchetype(
          speedUnitsPerSecond: 900.0,
          lifetimeSeconds: 1.2,
          colliderSizeX: 16.0,
          colliderSizeY: 8.0,
        );
    }
  }
}

class ProjectileCatalogDerived {
  const ProjectileCatalogDerived._({required this.tickHz, required this.base});

  factory ProjectileCatalogDerived.from(
    ProjectileCatalog base, {
    required int tickHz,
  }) {
    if (tickHz <= 0) {
      throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
    }
    return ProjectileCatalogDerived._(tickHz: tickHz, base: base);
  }

  final int tickHz;
  final ProjectileCatalog base;

  int lifetimeTicks(ProjectileId id) {
    return ticksFromSecondsCeil(base.get(id).lifetimeSeconds, tickHz);
  }
}


===== FILE: lib/core/projectiles/projectile_id.dart =====
enum ProjectileId { iceBolt, lightningBolt }



===== FILE: lib/core/README.md =====
# Core (Pure Dart)

Authoritative, deterministic simulation code only.

- No Flutter imports
- No Flame imports
- Commands in, snapshots/events out



===== FILE: lib/core/snapshots/entity_render_snapshot.dart =====
// Renderer-facing entity data extracted from the Core at the end of a tick.
//
// This is a read-only, serializable view of entity state for rendering only.
// It must not leak internal core storage details.
import '../math/vec2.dart';
import '../projectiles/projectile_id.dart';
import 'enums.dart';

/// Render-only view of an entity.
class EntityRenderSnapshot {
  const EntityRenderSnapshot({
    required this.id,
    required this.kind,
    required this.pos,
    required this.facing,
    required this.anim,
    required this.grounded,
    this.vel,
    this.size,
    this.projectileId,
    this.z,
    this.animFrame,
  });

  /// Stable entity identifier (protocol-stable).
  final int id;

  /// Broad entity classification for choosing visuals/behavior.
  final EntityKind kind;

  /// World position in virtual pixels.
  final Vec2 pos;

  /// Optional world velocity (useful for facing/animation).
  final Vec2? vel;

  /// Optional full extents in world units (virtual pixels).
  ///
  /// Render-only hint for placeholder shapes (e.g. projectile rectangles).
  final Vec2? size;

  /// Optional projectile archetype id (set when [kind] is [EntityKind.projectile]).
  final ProjectileId? projectileId;

  /// Optional sort key for render ordering.
  final double? z;

  /// Facing direction for choosing sprites/poses.
  final Facing facing;

  /// Whether the entity is grounded at the end of the tick.
  ///
  /// This is authoritative collision state from Core (do not infer from anim).
  final bool grounded;

  /// Logical animation selection (renderer maps to assets).
  final AnimKey anim;

  /// Optional frame hint for deterministic animation in replays/networking.
  final int? animFrame;
}


===== FILE: lib/core/snapshots/enums.dart =====
// Protocol-stable enums used by snapshots (and later networking).
//
// Keep these enums stable over time because they are part of the render
// contract and may become part of the network protocol.
//
// These enums are "logical" (game meaning), not asset/texture names.

/// Logical animation state (not tied to any specific texture or asset).
enum AnimKey {
  idle,
  run,
  jump,
  fall,
  hit,
  cast,
  death,
  spawn,
}

/// Broad entity classification used by the renderer and (later) networking.
enum EntityKind {
  player,
  enemy,
  projectile,
  obstacle,
  pickup,
  hazard,
  trigger,
}

/// Horizontal facing direction for animation/aiming.
enum Facing {
  left,
  right,
}


===== FILE: lib/core/snapshots/game_state_snapshot.dart =====
// Immutable snapshot of the full game state needed by Render/UI.
//
// Built by the Core after each fixed simulation tick and treated as read-only
// by Flame/Flutter. This is the primary contract between Core and the rest of
// the app.
import 'entity_render_snapshot.dart';
import 'player_hud_snapshot.dart';
import 'static_solid_snapshot.dart';

/// Snapshot of the current game state at a specific simulation tick.
class GameStateSnapshot {
  const GameStateSnapshot({
    required this.tick,
    required this.seed,
    required this.distance,
    required this.paused,
    required this.gameOver,
    required this.cameraCenterX,
    required this.cameraCenterY,
    required this.hud,
    required this.entities,
    required this.staticSolids,
  });

  /// Current simulation tick.
  final int tick;

  /// Seed used for deterministic generation/RNG.
  final int seed;

  /// Distance progressed in the run (placeholder for V0).
  final double distance;

  /// Whether the simulation is currently paused.
  final bool paused;

  /// Whether the run has ended (simulation is frozen).
  final bool gameOver;

  /// Camera center used for rendering this snapshot.
  final double cameraCenterX;
  final double cameraCenterY;

  /// HUD-only player stats.
  final PlayerHudSnapshot hud;

  /// Render-only entity list for the current tick.
  final List<EntityRenderSnapshot> entities;

  /// Render-only static collision geometry (platforms/obstacles) for this run.
  final List<StaticSolidSnapshot> staticSolids;
}


===== FILE: lib/core/snapshots/player_hud_snapshot.dart =====
/// HUD-only data extracted from the Core.
///
/// Split from entity snapshots so the UI can render player stats without
/// scanning all entities every frame.
class PlayerHudSnapshot {
  const PlayerHudSnapshot({
    required this.hp,
    required this.hpMax,
    required this.mana,
    required this.manaMax,
    required this.stamina,
    required this.staminaMax,
    required this.score,
    required this.coins,
  });

  /// Current health.
  final double hp;

  /// Maximum health.
  final double hpMax;

  /// Current mana (resource for spells).
  final double mana;

  /// Maximum mana.
  final double manaMax;

  /// Current stamina (resource for physical actions like jump/dash).
  final double stamina;

  /// Maximum stamina.
  final double staminaMax;

  /// Run score (placeholder for V0).
  final int score;

  /// Collected coins (placeholder for V0).
  final int coins;
}


===== FILE: lib/core/snapshots/static_solid_snapshot.dart =====
/// Renderer-facing snapshot for one piece of static collision geometry.
///
/// This is a read-only view for rendering/debug overlays. Authoritative
/// collision still lives in Core using `StaticWorldGeometry`.
class StaticSolidSnapshot {
  const StaticSolidSnapshot({
    required this.minX,
    required this.minY,
    required this.maxX,
    required this.maxY,
    required this.sides,
    required this.oneWayTop,
  });

  final double minX;
  final double minY;
  final double maxX;
  final double maxY;

  /// Bitmask of enabled faces.
  final int sides;

  /// Whether the top face behaves as one-way (platform).
  final bool oneWayTop;
}



===== FILE: lib/core/spells/spawn_spell_projectile.dart =====
import 'dart:math';

import '../combat/faction.dart';
import '../ecs/entity_id.dart';
import '../ecs/stores/collider_aabb_store.dart';
import '../ecs/stores/lifetime_store.dart';
import '../ecs/stores/projectile_store.dart';
import '../ecs/stores/spell_origin_store.dart';
import '../ecs/world.dart';
import '../projectiles/projectile_catalog.dart';
import '../projectiles/projectile_id.dart';
import 'spell_catalog.dart';
import 'spell_id.dart';

// Centralize spell->projectile checks and direction normalization here so
// player/enemy casting cannot drift over time.
const _dirEps2 = 1e-12;

({double x, double y}) _normalizeDirOrFallback(
  double x,
  double y, {
  required double fallbackX,
  required double fallbackY,
}) {
  final len2 = x * x + y * y;
  if (len2 <= _dirEps2) {
    final fbLen2 = fallbackX * fallbackX + fallbackY * fallbackY;
    if (fbLen2 <= _dirEps2) {
      return (x: 1.0, y: 0.0);
    }
    final invLen = 1.0 / sqrt(fbLen2);
    return (x: fallbackX * invLen, y: fallbackY * invLen);
  }

  final invLen = 1.0 / sqrt(len2);
  return (x: x * invLen, y: y * invLen);
}

EntityId _spawnResolvedSpellProjectile(
  EcsWorld world, {
  required ProjectileCatalogDerived projectiles,
  required SpellId spellId,
  required ProjectileId projectileId,
  required Faction faction,
  required EntityId owner,
  required double originX,
  required double originY,
  required double dirX,
  required double dirY,
  required double speedUnitsPerSecond,
  required double damage,
}) {
  final proj = projectiles.base.get(projectileId);
  final halfX = proj.colliderSizeX * 0.5;
  final halfY = proj.colliderSizeY * 0.5;

  final entity = world.createEntity();
  world.transform.add(
    entity,
    posX: originX,
    posY: originY,
    velX: 0.0,
    velY: 0.0,
  );
  world.projectile.add(
    entity,
    ProjectileDef(
      projectileId: projectileId,
      faction: faction,
      owner: owner,
      dirX: dirX,
      dirY: dirY,
      speedUnitsPerSecond: speedUnitsPerSecond,
      damage: damage,
    ),
  );
  world.spellOrigin.add(entity, SpellOriginDef(spellId: spellId));
  world.lifetime.add(
    entity,
    LifetimeDef(ticksLeft: projectiles.lifetimeTicks(projectileId)),
  );

  // Projectiles participate in hit resolution using the same AABB model as actors.
  world.colliderAabb.add(entity, ColliderAabbDef(halfX: halfX, halfY: halfY));

  return entity;
}

/// Spawns a spell projectile from a caster position with a consistent origin
/// offset along the cast direction.
///
/// Call sites should pass the raw direction (e.g. aim vector, target delta) and
/// a normalized fallback (e.g. facing direction). This function normalizes once
/// and guarantees consistent behavior across player/enemy casting.
EntityId? spawnSpellProjectileFromCaster(
  EcsWorld world, {
  required SpellCatalog spells,
  required ProjectileCatalogDerived projectiles,
  required SpellId spellId,
  required Faction faction,
  required EntityId owner,
  required double casterX,
  required double casterY,
  required double originOffset,
  required double dirX,
  required double dirY,
  required double fallbackDirX,
  required double fallbackDirY,
}) {
  final spell = spells.get(spellId);
  final projectileId = spell.projectileId;
  if (projectileId == null) return null;

  final dir = _normalizeDirOrFallback(
    dirX,
    dirY,
    fallbackX: fallbackDirX,
    fallbackY: fallbackDirY,
  );

  final originX = casterX + dir.x * originOffset;
  final originY = casterY + dir.y * originOffset;

  return _spawnResolvedSpellProjectile(
    world,
    projectiles: projectiles,
    spellId: spellId,
    projectileId: projectileId,
    faction: faction,
    owner: owner,
    originX: originX,
    originY: originY,
    dirX: dir.x,
    dirY: dir.y,
    speedUnitsPerSecond: projectiles.base.get(projectileId).speedUnitsPerSecond,
    damage: spell.stats.damage,
  );
}

EntityId? spawnSpellProjectile(
  EcsWorld world, {
  required SpellCatalog spells,
  required ProjectileCatalogDerived projectiles,
  required SpellId spellId,
  required Faction faction,
  required EntityId owner,
  required double originX,
  required double originY,
  required double dirX,
  required double dirY,
}) {
  final spell = spells.get(spellId);
  final projectileId = spell.projectileId;
  if (projectileId == null) return null;

  final dir = _normalizeDirOrFallback(
    dirX,
    dirY,
    fallbackX: 1.0,
    fallbackY: 0.0,
  );

  return _spawnResolvedSpellProjectile(
    world,
    projectiles: projectiles,
    spellId: spellId,
    projectileId: projectileId,
    faction: faction,
    owner: owner,
    originX: originX,
    originY: originY,
    dirX: dir.x,
    dirY: dir.y,
    speedUnitsPerSecond: projectiles.base.get(projectileId).speedUnitsPerSecond,
    damage: spell.stats.damage,
  );
}


===== FILE: lib/core/spells/spell_catalog.dart =====
import '../projectiles/projectile_id.dart';
import 'spell_id.dart';

class ProjectileSpellStats {
  const ProjectileSpellStats({
    required this.manaCost,
    required this.damage,
  });

  final double manaCost;
  final double damage;
}

class SpellDef {
  const SpellDef({
    required this.stats,
    required this.projectileId,
  });

  /// Spell-specific gameplay stats (resource cost, damage, etc).
  final ProjectileSpellStats stats;

  /// Optional projectile mapping. Non-projectile spells have `null`.
  final ProjectileId? projectileId;
}

class SpellCatalog {
  const SpellCatalog();

  SpellDef get(SpellId id) {
    switch (id) {
      case SpellId.iceBolt:
        return const SpellDef(
          stats: ProjectileSpellStats(manaCost: 10.0, damage: 25.0),
          projectileId: ProjectileId.iceBolt,
        );
      case SpellId.lightning:
        return const SpellDef(
          stats: ProjectileSpellStats(manaCost: 10.0, damage: 10.0),
          projectileId: ProjectileId.lightningBolt,
        );
    }
  }
}


===== FILE: lib/core/spells/spell_id.dart =====
enum SpellId { iceBolt, lightning }



===== FILE: lib/core/track/v0_track_streamer.dart =====
import '../collision/static_world_geometry.dart';
import '../enemies/enemy_id.dart';
import '../tuning/v0_track_tuning.dart';

typedef SpawnEnemy = void Function(EnemyId enemyId, double x);

class V0ChunkPattern {
  const V0ChunkPattern({
    required this.name,
    this.platforms = const <_PlatformRel>[],
    this.obstacles = const <_ObstacleRel>[],
    this.spawnMarkers = const <_SpawnMarker>[],
  });

  final String name;
  final List<_PlatformRel> platforms;
  final List<_ObstacleRel> obstacles;
  final List<_SpawnMarker> spawnMarkers;
}

class V0TrackStreamer {
  V0TrackStreamer({
    required this.seed,
    required this.tuning,
    required this.groundTopY,
  }) : _nextChunkIndex = 0,
       _nextChunkStartX = 0.0;

  final int seed;
  final V0TrackTuning tuning;
  final double groundTopY;

  int _nextChunkIndex;
  double _nextChunkStartX;

  final List<_ActiveChunk> _active = <_ActiveChunk>[];
  List<StaticSolid> _dynamicSolids = const <StaticSolid>[];

  /// Current streamed solids (excluding any caller-provided base solids).
  List<StaticSolid> get dynamicSolids => _dynamicSolids;

  /// Advances chunk streaming based on the current camera bounds.
  ///
  /// Returns true if the streamed geometry changed (spawn/cull occurred).
  bool step({
    required double cameraLeft,
    required double cameraRight,
    required SpawnEnemy spawnEnemy,
  }) {
    if (!tuning.enabled) return false;

    var changed = false;

    // Spawn new chunks ahead of the camera.
    final spawnLimitX = cameraRight + tuning.spawnAheadMargin;
    while (_nextChunkStartX <= spawnLimitX) {
      final chunkIndex = _nextChunkIndex;
      final startX = _nextChunkStartX;
      final endX = startX + tuning.chunkWidth;

      final pattern = _patternFor(seed, chunkIndex);
      final solids = _buildSolids(
        pattern,
        chunkStartX: startX,
        chunkIndex: chunkIndex,
      );
      _active.add(
        _ActiveChunk(
          index: chunkIndex,
          startX: startX,
          endX: endX,
          solids: solids,
        ),
      );

      _spawnEnemiesForChunk(pattern, chunkIndex, chunkStartX: startX, spawnEnemy: spawnEnemy);

      _nextChunkIndex += 1;
      _nextChunkStartX += tuning.chunkWidth;
      changed = true;
    }

    // Cull old chunks behind the camera.
    final cullLimitX = cameraLeft - tuning.cullBehindMargin;
    while (_active.isNotEmpty && _active.first.endX < cullLimitX) {
      _active.removeAt(0);
      changed = true;
    }

    if (changed) {
      final rebuilt = <StaticSolid>[];
      for (final c in _active) {
        rebuilt.addAll(c.solids);
      }
      _dynamicSolids = List<StaticSolid>.unmodifiable(rebuilt);
    }

    return changed;
  }

  void _spawnEnemiesForChunk(
    V0ChunkPattern pattern,
    int chunkIndex, {
    required double chunkStartX,
    required SpawnEnemy spawnEnemy,
  }) {
    // Safety: keep the early run empty so the player isn't immediately swarmed.
    if (chunkIndex < 6) return;

    for (var i = 0; i < pattern.spawnMarkers.length; i += 1) {
      final m = pattern.spawnMarkers[i];
      assert(_withinChunk(m.x, 0.0), 'Spawn marker out of chunk bounds: ${pattern.name}');
      assert(_snapped(m.x), 'Spawn marker not snapped to grid: ${pattern.name}');
      final roll = _mix32(seed ^ (chunkIndex * 0x9e3779b9) ^ (i * 0x85ebca6b) ^ m.salt);
      if ((roll % 100) >= m.chancePercent) continue;

      final x = chunkStartX + m.x;
      spawnEnemy(m.enemyId, x);
    }
  }

  List<StaticSolid> _buildSolids(
    V0ChunkPattern pattern, {
    required double chunkStartX,
    required int chunkIndex,
  }) {
    // Preserve author ordering for determinism (pattern order, then chunk order).
    final solids = <StaticSolid>[];
    var localSolidIndex = 0;

    for (final p in pattern.platforms) {
      assert(_withinChunk(p.x, p.width), 'Platform out of chunk bounds: ${pattern.name}');
      assert(_snapped(p.x) && _snapped(p.width) && _snapped(p.aboveGroundTop),
          'Platform not snapped to grid: ${pattern.name}');
      final topY = groundTopY - p.aboveGroundTop;
      solids.add(
        StaticSolid(
          minX: chunkStartX + p.x,
          minY: topY,
          maxX: chunkStartX + p.x + p.width,
          maxY: topY + p.thickness,
          sides: StaticSolid.sideTop,
          oneWayTop: true,
          chunkIndex: chunkIndex,
          localSolidIndex: localSolidIndex,
        ),
      );
      localSolidIndex += 1;
    }

    for (final o in pattern.obstacles) {
      assert(_withinChunk(o.x, o.width), 'Obstacle out of chunk bounds: ${pattern.name}');
      assert(_snapped(o.x) && _snapped(o.width) && _snapped(o.height),
          'Obstacle not snapped to grid: ${pattern.name}');
      solids.add(
        StaticSolid(
          minX: chunkStartX + o.x,
          minY: groundTopY - o.height,
          maxX: chunkStartX + o.x + o.width,
          maxY: groundTopY,
          sides: StaticSolid.sideAll,
          oneWayTop: false,
          chunkIndex: chunkIndex,
          localSolidIndex: localSolidIndex,
        ),
      );
      localSolidIndex += 1;
    }

    return solids;
  }

  V0ChunkPattern _patternFor(int seed, int chunkIndex) {
    // Mild early-game safety: pick from easier patterns for the first few chunks.
    final isEarly = chunkIndex < 3;
    final pool = isEarly ? _easyPatterns : _allPatterns;
    final h = _mix32(seed ^ (chunkIndex * 0x9e3779b9) ^ 0x27d4eb2d);
    final idx = h % pool.length;
    return pool[idx];
  }

  // === Pattern library (authoring-layer) ===
  //
  // Notes:
  // - All coordinates are relative to the chunk start (x in [0, chunkWidth)).
  // - Y is expressed as "above ground top" (so 48 means 48 units above ground).
  // - Values are authored on a 16-unit grid for stability.

  static const double _t = 16.0; // platform thickness

  static const List<V0ChunkPattern> _easyPatterns = <V0ChunkPattern>[
    V0ChunkPattern(
      name: 'recovery-flat',
      platforms: <_PlatformRel>[],
      obstacles: <_ObstacleRel>[],
      spawnMarkers: <_SpawnMarker>[],
    ),
    V0ChunkPattern(
      name: 'single-low-platform',
      platforms: <_PlatformRel>[
        _PlatformRel(x: 160, width: 160, aboveGroundTop: 48, thickness: _t),
      ],
      obstacles: <_ObstacleRel>[],
      spawnMarkers: <_SpawnMarker>[],
    ),
    V0ChunkPattern(
      name: 'two-low-platforms',
      platforms: <_PlatformRel>[
        _PlatformRel(x: 64, width: 144, aboveGroundTop: 48, thickness: _t),
        _PlatformRel(x: 272, width: 144, aboveGroundTop: 64, thickness: _t),
      ],
      obstacles: <_ObstacleRel>[],
      spawnMarkers: <_SpawnMarker>[],
    ),
  ];

  static const List<V0ChunkPattern> _allPatterns = <V0ChunkPattern>[
    // Recovery / breathers.
    ..._easyPatterns,

    // Platforming (optional; ground is always safe in V0).
    V0ChunkPattern(
      name: 'staggered-mid-platforms',
      platforms: <_PlatformRel>[
        _PlatformRel(x: 48, width: 160, aboveGroundTop: 64, thickness: _t),
        _PlatformRel(x: 256, width: 160, aboveGroundTop: 96, thickness: _t),
      ],
      spawnMarkers: <_SpawnMarker>[
        _SpawnMarker(enemyId: EnemyId.flyingEnemy, x: 352, chancePercent: 35, salt: 0x01),
      ],
    ),
    V0ChunkPattern(
      name: 'triple-runner-platforms',
      platforms: <_PlatformRel>[
        _PlatformRel(x: 32, width: 128, aboveGroundTop: 48, thickness: _t),
        _PlatformRel(x: 192, width: 128, aboveGroundTop: 80, thickness: _t),
        _PlatformRel(x: 352, width: 96, aboveGroundTop: 64, thickness: _t),
      ],
      spawnMarkers: <_SpawnMarker>[
        _SpawnMarker(enemyId: EnemyId.flyingEnemy, x: 288, chancePercent: 30, salt: 0x02),
      ],
    ),
    V0ChunkPattern(
      name: 'high-platform-over-obstacle',
      platforms: <_PlatformRel>[
        _PlatformRel(x: 224, width: 192, aboveGroundTop: 112, thickness: _t),
      ],
      obstacles: <_ObstacleRel>[
        _ObstacleRel(x: 128, width: 48, height: 64),
      ],
      spawnMarkers: <_SpawnMarker>[
        _SpawnMarker(enemyId: EnemyId.groundEnemy, x: 320, chancePercent: 45, salt: 0x03),
      ],
    ),

    // Obstacles (ground blocks that force a jump/dash).
    V0ChunkPattern(
      name: 'single-block',
      obstacles: <_ObstacleRel>[
        _ObstacleRel(x: 224, width: 48, height: 64),
      ],
      spawnMarkers: <_SpawnMarker>[
        _SpawnMarker(enemyId: EnemyId.groundEnemy, x: 320, chancePercent: 35, salt: 0x04),
      ],
    ),
    V0ChunkPattern(
      name: 'double-blocks',
      obstacles: <_ObstacleRel>[
        _ObstacleRel(x: 160, width: 32, height: 48),
        _ObstacleRel(x: 288, width: 48, height: 64),
      ],
      spawnMarkers: <_SpawnMarker>[
        _SpawnMarker(enemyId: EnemyId.flyingEnemy, x: 96, chancePercent: 25, salt: 0x05),
        _SpawnMarker(enemyId: EnemyId.groundEnemy, x: 352, chancePercent: 30, salt: 0x06),
      ],
    ),
  ];

  bool _withinChunk(double x, double width) {
    return x >= 0.0 && (x + width) <= tuning.chunkWidth;
  }

  bool _snapped(double v) {
    final s = tuning.gridSnap;
    final snapped = (v / s).roundToDouble() * s;
    return (v - snapped).abs() < 1e-9;
  }
}

class _ActiveChunk {
  const _ActiveChunk({
    required this.index,
    required this.startX,
    required this.endX,
    required this.solids,
  });

  final int index;
  final double startX;
  final double endX;
  final List<StaticSolid> solids;
}

class _PlatformRel {
  const _PlatformRel({
    required this.x,
    required this.width,
    required this.aboveGroundTop,
    required this.thickness,
  }) : assert(width > 0),
       assert(thickness > 0),
       assert(aboveGroundTop > 0);

  final double x;
  final double width;
  final double aboveGroundTop;
  final double thickness;
}

class _ObstacleRel {
  const _ObstacleRel({
    required this.x,
    required this.width,
    required this.height,
  }) : assert(width > 0),
       assert(height > 0);

  final double x;
  final double width;
  final double height;
}

class _SpawnMarker {
  const _SpawnMarker({
    required this.enemyId,
    required this.x,
    required this.chancePercent,
    required this.salt,
  }) : assert(chancePercent >= 0),
       assert(chancePercent <= 100);

  final EnemyId enemyId;
  final double x;
  final int chancePercent;
  final int salt;
}

int _mix32(int x) {
  // MurmurHash3 finalizer-like mix. Keep it explicitly 32-bit.
  var v = x & 0xffffffff;
  v ^= (v >> 16);
  v = (v * 0x7feb352d) & 0xffffffff;
  v ^= (v >> 15);
  v = (v * 0x846ca68b) & 0xffffffff;
  v ^= (v >> 16);
  return v & 0xffffffff;
}


===== FILE: lib/core/tuning/v0_ability_tuning.dart =====
import '../util/tick_math.dart';

class V0AbilityTuning {
  const V0AbilityTuning({
    this.castCooldownSeconds = 0.25,
    this.meleeCooldownSeconds = 0.30,
    this.meleeActiveSeconds = 0.10,
    this.meleeStaminaCost = 15.0,
    this.meleeDamage = 25.0,
    this.meleeHitboxSizeX = 32.0,
    this.meleeHitboxSizeY = 16.0,
  });

  final double castCooldownSeconds;

  final double meleeCooldownSeconds;
  final double meleeActiveSeconds;
  final double meleeStaminaCost;
  final double meleeDamage;

  /// Full extents in world units (virtual pixels).
  final double meleeHitboxSizeX;
  final double meleeHitboxSizeY;
}

class V0AbilityTuningDerived {
  const V0AbilityTuningDerived._({
    required this.tickHz,
    required this.base,
    required this.castCooldownTicks,
    required this.meleeCooldownTicks,
    required this.meleeActiveTicks,
  });

  factory V0AbilityTuningDerived.from(
    V0AbilityTuning base, {
    required int tickHz,
  }) {
    if (tickHz <= 0) {
      throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
    }

    return V0AbilityTuningDerived._(
      tickHz: tickHz,
      base: base,
      castCooldownTicks: ticksFromSecondsCeil(base.castCooldownSeconds, tickHz),
      meleeCooldownTicks: ticksFromSecondsCeil(base.meleeCooldownSeconds, tickHz),
      meleeActiveTicks: ticksFromSecondsCeil(base.meleeActiveSeconds, tickHz),
    );
  }

  final int tickHz;
  final V0AbilityTuning base;

  final int castCooldownTicks;
  final int meleeCooldownTicks;
  final int meleeActiveTicks;
}


===== FILE: lib/core/tuning/v0_camera_tuning.dart =====
import 'dart:math';

import 'v0_movement_tuning.dart';

class V0CameraTuning {
  const V0CameraTuning({
    this.speedLagMulX = 0.4,
    this.accelX = 1200.0,
    this.followThresholdRatio = 0.60,
    this.catchupLerp = 8.0,
    this.targetCatchupLerp = 2.5,
  });

  /// Baseline auto-scroll lags behind `V0MovementTuning.maxSpeedX` by this multiplier.
  final double speedLagMulX;

  /// Acceleration used to ease camera speed toward its target speed.
  final double accelX;

  /// Threshold ratio (from left edge) after which the player can pull the camera forward.
  final double followThresholdRatio;

  /// Smoothing for camera center toward its target (per-second).
  final double catchupLerp;

  /// Smoothing for camera target toward player (per-second).
  final double targetCatchupLerp;
}

class V0CameraTuningDerived {
  const V0CameraTuningDerived({
    required this.targetSpeedX,
    required this.accelX,
    required this.followThresholdRatio,
    required this.catchupLerp,
    required this.targetCatchupLerp,
  });

  factory V0CameraTuningDerived.from(
    V0CameraTuning tuning, {
    required V0MovementTuningDerived movement,
  }) {
    final targetSpeedX = max(0.0, movement.base.maxSpeedX * tuning.speedLagMulX);
    return V0CameraTuningDerived(
      targetSpeedX: targetSpeedX,
      accelX: tuning.accelX,
      followThresholdRatio: tuning.followThresholdRatio,
      catchupLerp: tuning.catchupLerp,
      targetCatchupLerp: tuning.targetCatchupLerp,
    );
  }

  final double targetSpeedX;
  final double accelX;
  final double followThresholdRatio;
  final double catchupLerp;
  final double targetCatchupLerp;
}


===== FILE: lib/core/tuning/v0_combat_tuning.dart =====
import '../util/tick_math.dart';

class V0CombatTuning {
  const V0CombatTuning({this.invulnerabilitySeconds = 0.25});

  final double invulnerabilitySeconds;
}

class V0CombatTuningDerived {
  const V0CombatTuningDerived._({
    required this.tickHz,
    required this.base,
    required this.invulnerabilityTicks,
  });

  factory V0CombatTuningDerived.from(
    V0CombatTuning base, {
    required int tickHz,
  }) {
    if (tickHz <= 0) {
      throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
    }

    return V0CombatTuningDerived._(
      tickHz: tickHz,
      base: base,
      invulnerabilityTicks: ticksFromSecondsCeil(
        base.invulnerabilitySeconds,
        tickHz,
      ),
    );
  }

  final int tickHz;
  final V0CombatTuning base;

  final int invulnerabilityTicks;
}



===== FILE: lib/core/tuning/v0_flying_enemy_tuning.dart =====
import '../util/tick_math.dart';

class V0FlyingEnemyTuning {
  const V0FlyingEnemyTuning({
    this.flyingEnemyHoverOffsetY = 150.0,
    this.flyingEnemyDesiredRangeMin = 50.0,
    this.flyingEnemyDesiredRangeMax = 90.0,
    this.flyingEnemyDesiredRangeHoldMinSeconds = 0.60,
    this.flyingEnemyDesiredRangeHoldMaxSeconds = 1.40,
    this.flyingEnemyHoldSlack = 20.0,
    this.flyingEnemyMaxSpeedX = 300.0,
    this.flyingEnemySlowRadiusX = 80.0,
    this.flyingEnemyAccelX = 600.0,
    this.flyingEnemyDecelX = 400.0,
    this.flyingEnemyMinHeightAboveGround = 100.0,
    this.flyingEnemyMaxHeightAboveGround = 240.0,
    this.flyingEnemyFlightTargetHoldMinSeconds = 1.5,
    this.flyingEnemyFlightTargetHoldMaxSeconds = 3.0,
    this.flyingEnemyMaxSpeedY = 300.0,
    this.flyingEnemyVerticalKp = 4.0,
    this.flyingEnemyVerticalDeadzone = 20.0,
    this.flyingEnemyCastCooldownSeconds = 2.0,
    this.flyingEnemyCastOriginOffset = 20.0,
  });

  // Flying enemy steering.
  final double flyingEnemyHoverOffsetY;
  final double flyingEnemyDesiredRangeMin;
  final double flyingEnemyDesiredRangeMax;
  final double flyingEnemyDesiredRangeHoldMinSeconds;
  final double flyingEnemyDesiredRangeHoldMaxSeconds;
  final double flyingEnemyHoldSlack;
  final double flyingEnemyMaxSpeedX;
  final double flyingEnemySlowRadiusX;
  final double flyingEnemyAccelX;
  final double flyingEnemyDecelX;
  final double flyingEnemyMinHeightAboveGround;
  final double flyingEnemyMaxHeightAboveGround;
  final double flyingEnemyFlightTargetHoldMinSeconds;
  final double flyingEnemyFlightTargetHoldMaxSeconds;
  final double flyingEnemyMaxSpeedY;
  final double flyingEnemyVerticalKp;
  final double flyingEnemyVerticalDeadzone;

  // Flying enemy attacks.
  final double flyingEnemyCastCooldownSeconds;
  final double flyingEnemyCastOriginOffset;
}

class V0FlyingEnemyTuningDerived {
  const V0FlyingEnemyTuningDerived._({
    required this.tickHz,
    required this.base,
    required this.flyingEnemyCastCooldownTicks,
  });

  factory V0FlyingEnemyTuningDerived.from(
    V0FlyingEnemyTuning base, {
    required int tickHz,
  }) {
    if (tickHz <= 0) {
      throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
    }

    return V0FlyingEnemyTuningDerived._(
      tickHz: tickHz,
      base: base,
      flyingEnemyCastCooldownTicks: ticksFromSecondsCeil(
        base.flyingEnemyCastCooldownSeconds,
        tickHz,
      ),
    );
  }

  final int tickHz;
  final V0FlyingEnemyTuning base;

  final int flyingEnemyCastCooldownTicks;
}


===== FILE: lib/core/tuning/v0_ground_enemy_tuning.dart =====
import '../util/tick_math.dart';

class V0GroundEnemyTuning {
  const V0GroundEnemyTuning({
    this.groundEnemySpeedX = 300.0,
    this.groundEnemyStopDistanceX = 6.0,
    this.groundEnemyAccelX = 600.0,
    this.groundEnemyDecelX = 400.0,
    this.groundEnemyJumpSpeed = 600.0,
    this.groundEnemyJumpCooldownSeconds = 0.5,
    this.groundEnemyMeleeRangeX = 26.0,
    this.groundEnemyMeleeCooldownSeconds = 1.0,
    this.groundEnemyMeleeActiveSeconds = 0.10,
    this.groundEnemyMeleeDamage = 15.0,
    this.groundEnemyMeleeHitboxSizeX = 28.0,
    this.groundEnemyMeleeHitboxSizeY = 16.0,
  });

  // Ground enemy steering.
  final double groundEnemySpeedX;
  final double groundEnemyStopDistanceX;
  final double groundEnemyAccelX;
  final double groundEnemyDecelX;

  /// Instantaneous jump vertical speed (negative is upward).
  final double groundEnemyJumpSpeed;

  /// Cooldown between jump attempts (seconds, ceil to ticks).
  final double groundEnemyJumpCooldownSeconds;

  // Ground enemy melee.
  final double groundEnemyMeleeRangeX;
  final double groundEnemyMeleeCooldownSeconds;
  final double groundEnemyMeleeActiveSeconds;
  final double groundEnemyMeleeDamage;
  final double groundEnemyMeleeHitboxSizeX;
  final double groundEnemyMeleeHitboxSizeY;
}

class V0GroundEnemyTuningDerived {
  const V0GroundEnemyTuningDerived._({
    required this.tickHz,
    required this.base,
    required this.groundEnemyJumpCooldownTicks,
    required this.groundEnemyMeleeCooldownTicks,
    required this.groundEnemyMeleeActiveTicks,
  });

  factory V0GroundEnemyTuningDerived.from(
    V0GroundEnemyTuning base, {
    required int tickHz,
  }) {
    if (tickHz <= 0) {
      throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
    }

    return V0GroundEnemyTuningDerived._(
      tickHz: tickHz,
      base: base,
      groundEnemyJumpCooldownTicks: ticksFromSecondsCeil(
        base.groundEnemyJumpCooldownSeconds,
        tickHz,
      ),
      groundEnemyMeleeCooldownTicks: ticksFromSecondsCeil(
        base.groundEnemyMeleeCooldownSeconds,
        tickHz,
      ),
      groundEnemyMeleeActiveTicks: ticksFromSecondsCeil(
        base.groundEnemyMeleeActiveSeconds,
        tickHz,
      ),
    );
  }

  final int tickHz;
  final V0GroundEnemyTuning base;

  final int groundEnemyJumpCooldownTicks;
  final int groundEnemyMeleeCooldownTicks;
  final int groundEnemyMeleeActiveTicks;
}


===== FILE: lib/core/tuning/v0_movement_tuning.dart =====
import '../util/tick_math.dart';

/// V0 movement/physics tuning for the Core simulation.
///
/// All units are expressed in world units ("virtual pixels") and seconds:
/// - speeds: world units / second
/// - acceleration: world units / second^2
/// - times: seconds (converted to fixed-tick counts at runtime)
///
/// The derived values are computed once per [tickHz] and then used in the hot
/// per-tick loop to keep the core allocation-light.
const int v0DefaultTickHz = 60;

/// Authoritative movement constants (expressed in seconds-based units).
class V0MovementTuning {
  const V0MovementTuning({
    this.playerRadius = 8,
    this.maxSpeedX = 250,
    this.accelerationX = 600,
    this.decelerationX = 400,
    this.minMoveSpeed = 5,
    this.maxVelX = 1500,
    this.maxVelY = 1500,
    this.jumpSpeed = 600,
    this.coyoteTimeSeconds = 0.10,
    this.jumpBufferSeconds = 0.12,
    this.dashSpeedX = 550,
    this.dashDurationSeconds = 0.20,
    this.dashCooldownSeconds = 2.0,
  });

  /// Player "collision" radius in world units (used for ground contact in V0).
  final double playerRadius;

  /// Target max horizontal speed when holding move input.
  final double maxSpeedX;
  final double accelerationX;
  final double decelerationX;
  final double minMoveSpeed;

  /// Speed clamps (safety caps).
  final double maxVelX;
  final double maxVelY;

  /// Instantaneous jump vertical speed (negative is upward).
  final double jumpSpeed;

  /// Jump forgiveness windows (platformer-style).
  final double coyoteTimeSeconds;
  final double jumpBufferSeconds;

  /// Dash parameters.
  final double dashSpeedX;
  final double dashDurationSeconds;
  final double dashCooldownSeconds;
}

/// Derived, tick-based tuning computed for a specific [tickHz].
class V0MovementTuningDerived {
  const V0MovementTuningDerived._({
    required this.tickHz,
    required this.dtSeconds,
    required this.base,
    required this.coyoteTicks,
    required this.jumpBufferTicks,
    required this.dashDurationTicks,
    required this.dashCooldownTicks,
  });

  factory V0MovementTuningDerived.from(
    V0MovementTuning base, {
    required int tickHz,
  }) {
    if (tickHz <= 0) {
      throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
    }
    return V0MovementTuningDerived._(
      tickHz: tickHz,
      dtSeconds: 1.0 / tickHz,
      base: base,
      coyoteTicks: ticksFromSecondsCeil(base.coyoteTimeSeconds, tickHz),
      jumpBufferTicks: ticksFromSecondsCeil(base.jumpBufferSeconds, tickHz),
      dashDurationTicks: ticksFromSecondsCeil(base.dashDurationSeconds, tickHz),
      dashCooldownTicks: ticksFromSecondsCeil(base.dashCooldownSeconds, tickHz),
    );
  }

  final int tickHz;
  final double dtSeconds;
  final V0MovementTuning base;

  final int coyoteTicks;
  final int jumpBufferTicks;
  final int dashDurationTicks;
  final int dashCooldownTicks;
}


===== FILE: lib/core/tuning/v0_physics_tuning.dart =====
/// V0 global physics tuning for the Core simulation.
///
/// This is intentionally separate from movement/ability/combat tunings so it can
/// evolve into per-level/biome physics profiles later (e.g. low-gravity zones).
class V0PhysicsTuning {
  const V0PhysicsTuning({
    this.gravityY = 1200,
  });

  /// Gravity acceleration (positive is downward), in world units / second^2.
  final double gravityY;
}



===== FILE: lib/core/tuning/v0_resource_tuning.dart =====
/// Resource tuning for V0 (author in seconds, applied per fixed tick).
///
/// Values are based on the C++ reference (`tools/output/c++implementation.txt`).
class V0ResourceTuning {
  const V0ResourceTuning({
    this.playerHpMax = 100,
    this.playerHpRegenPerSecond = 1,
    this.playerManaMax = 100,
    this.playerManaRegenPerSecond = 3,
    this.playerStaminaMax = 100,
    this.playerStaminaRegenPerSecond = 1,
    this.playerHpStart,
    this.playerManaStart,
    this.playerStaminaStart,
    this.jumpStaminaCost = 2,
    this.dashStaminaCost = 2,
  });

  final double playerHpMax;
  final double playerHpRegenPerSecond;

  final double playerManaMax;
  final double playerManaRegenPerSecond;

  final double playerStaminaMax;
  final double playerStaminaRegenPerSecond;

  /// Optional starting values. When null, the corresponding `*Max` is used.
  final double? playerHpStart;
  final double? playerManaStart;
  final double? playerStaminaStart;

  /// Action costs (C++ reference: 2 stamina each for jump + dash).
  final double jumpStaminaCost;
  final double dashStaminaCost;
}


===== FILE: lib/core/tuning/v0_spatial_grid_tuning.dart =====
/// Simulation tuning/config for grid-based spatial indexing (broadphase now,
/// navigation later).
///
/// Keep this separate from combat tuning: broadphase is a physics/simulation
/// concern, not a combat rule.
class V0SpatialGridTuning {
  const V0SpatialGridTuning({
    this.broadphaseCellSize = v0BroadphaseCellSize,
  });

  /// Default broadphase cell size for dynamic AABB queries.
  ///
  /// With current V0 collider sizes (player ~16x16, enemies ~24x24), `32.0`
  /// keeps candidate sets small while keeping grid math cheap.
  static const double v0BroadphaseCellSize = 32.0;

  final double broadphaseCellSize;
}



===== FILE: lib/core/tuning/v0_track_tuning.dart =====
/// V0 track streaming / deterministic chunk spawning configuration.
///
/// This is simulation config (Core), not combat/ability tuning.
class V0TrackTuning {
  const V0TrackTuning({
    this.enabled = true,
    this.chunkWidth = 480.0,
    this.spawnAheadMargin = 960.0,
    this.cullBehindMargin = 480.0,
    this.gridSnap = 16.0,
  }) : assert(chunkWidth > 0),
       assert(spawnAheadMargin >= 0),
       assert(cullBehindMargin >= 0),
       assert(gridSnap > 0);

  /// If false, no chunk streaming is performed (static world only).
  final bool enabled;

  /// Width of a chunk in world units.
  final double chunkWidth;

  /// Spawn chunks while `cameraRight + spawnAheadMargin >= nextChunkStartX`.
  final double spawnAheadMargin;

  /// Cull chunks while `chunkEndX < cameraLeft - cullBehindMargin`.
  final double cullBehindMargin;

  /// Authoring grid snap for chunk patterns (world units).
  final double gridSnap;
}



===== FILE: lib/core/util/deterministic_rng.dart =====
const int _mask32 = 0xffffffff;
const int _nonZeroSeed = 0x6d2b79f5;

/// 32-bit mixing helper for deterministic seeds.
int mix32(int x) {
  var v = x & _mask32;
  v ^= (v >> 16);
  v = (v * 0x7feb352d) & _mask32;
  v ^= (v >> 15);
  v = (v * 0x846ca68b) & _mask32;
  v ^= (v >> 16);
  return v & _mask32;
}

/// Builds a non-zero 32-bit RNG state from a base seed and salt.
int seedFrom(int seed, int salt) {
  final mixed = mix32(seed ^ salt);
  return mixed == 0 ? _nonZeroSeed : mixed;
}

/// Xorshift32 step. Returns the next 32-bit state.
int nextUint32(int state) {
  var x = state & _mask32;
  if (x == 0) x = _nonZeroSeed;
  x ^= (x << 13) & _mask32;
  x ^= (x >> 17);
  x ^= (x << 5) & _mask32;
  return x & _mask32;
}

/// Converts a 32-bit state to a [0, 1] double (inclusive).
double uint32ToUnitDouble(int value) {
  return (value & _mask32) / _mask32;
}

/// Maps a 32-bit state to a [min, max] double range.
double rangeDouble(int value, double min, double max) {
  final lo = min <= max ? min : max;
  final hi = min <= max ? max : min;
  return lo + (hi - lo) * uint32ToUnitDouble(value);
}


===== FILE: lib/core/util/double_math.dart =====
import 'dart:math';

double clampDouble(double v, double lo, double hi) => max(lo, min(hi, v));



===== FILE: lib/core/util/smoothing.dart =====
import 'dart:math';

/// Returns a stable exponential smoothing factor in [0, 1] for the given
/// responsiveness `k` (per-second) and fixed tick dt.
///
/// Matches the common pattern: `alpha = 1 - exp(-k * dt)`.
double expSmoothingFactor(double k, double dtSeconds) {
  if (k <= 0) return 0.0;
  if (dtSeconds <= 0) return 0.0;
  return 1.0 - exp(-k * dtSeconds);
}



===== FILE: lib/core/util/tick_math.dart =====
import 'dart:math';

/// Converts a duration in seconds to a positive tick count for a fixed tick rate.
///
/// Rules:
/// - `seconds <= 0` => `0` ticks
/// - otherwise `max(1, ceil(seconds * tickHz))`
int ticksFromSecondsCeil(double seconds, int tickHz) {
  if (tickHz <= 0) {
    throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
  }
  if (seconds <= 0) return 0;
  return max(1, (seconds * tickHz).ceil());
}



===== FILE: lib/core/util/velocity_math.dart =====
double applyAccelDecel({
  required double current,
  required double desired,
  required double dtSeconds,
  required double accelPerSecond,
  required double decelPerSecond,
  double minStopSpeed = 0.0,
}) {
  if (dtSeconds <= 0.0) return current;
  if (desired == 0.0 && current.abs() <= minStopSpeed) return 0.0;

  final accel = desired == 0.0 ? decelPerSecond : accelPerSecond;
  final maxDelta = accel * dtSeconds;
  final delta = desired - current;
  if (delta.abs() > maxDelta) {
    return current + (delta > 0.0 ? maxDelta : -maxDelta);
  }
  return desired;
}


===== FILE: lib/game/components/hud_bars_component.dart =====
import 'dart:ui';

import 'package:flame/components.dart';

import '../game_controller.dart';

class HudBarsComponent extends PositionComponent {
  HudBarsComponent({
    required GameController controller,
    this.barWidth = 140,
    this.barHeight = 6,
    this.barGap = 4,
    super.position,
    super.anchor,
  }) : _controller = controller;

  final GameController _controller;

  final double barWidth;
  final double barHeight;
  final double barGap;

  final Paint _back = Paint()..color = const Color(0xAA000000);
  final Paint _outline = Paint()
    ..color = const Color(0xFFFFFFFF)
    ..style = PaintingStyle.stroke
    ..strokeWidth = 1;

  final Paint _hp = Paint()..color = const Color(0xFFDC4440);
  final Paint _mana = Paint()..color = const Color(0xFF2D98DA);
  final Paint _stamina = Paint()..color = const Color(0xFF4CD137);

  @override
  void render(Canvas canvas) {
    super.render(canvas);

    final hud = _controller.snapshot.hud;

    _drawBar(
      canvas,
      y: 0,
      value: hud.hp,
      max: hud.hpMax,
      fill: _hp,
    );
    _drawBar(
      canvas,
      y: barHeight + barGap,
      value: hud.mana,
      max: hud.manaMax,
      fill: _mana,
    );
    _drawBar(
      canvas,
      y: (barHeight + barGap) * 2,
      value: hud.stamina,
      max: hud.staminaMax,
      fill: _stamina,
    );
  }

  void _drawBar(
    Canvas canvas, {
    required double y,
    required double value,
    required double max,
    required Paint fill,
  }) {
    final x = 0.0;
    final w = barWidth;
    final h = barHeight;

    final backRect = Rect.fromLTWH(x, y, w, h);
    canvas.drawRect(backRect, _back);
    canvas.drawRect(backRect, _outline);

    if (max <= 0) return;
    final t = (value / max).clamp(0.0, 1.0);
    if (t <= 0) return;
    canvas.drawRect(Rect.fromLTWH(x, y, w * t, h), fill);
  }
}


===== FILE: lib/game/components/pixel_parallax_backdrop_component.dart =====
import 'dart:ui' as ui;

import 'package:flame/components.dart';
import 'package:flame/game.dart';
import 'package:flutter/painting.dart';

import '../util/math_util.dart';

/// A pixel-art friendly parallax backdrop that enforces integer-pixel motion.
///
/// This component is intended to be mounted under `game.camera.backdrop`, so it
/// renders *behind* the world and is not affected by camera movement (we apply
/// parallax offsets manually based on the camera viewfinder).
///
/// Each layer:
/// - draws at 1:1 (world units == virtual pixels)
/// - uses `FilterQuality.none` (no blur)
/// - can optionally snap scroll offsets to integer pixels (reduces shimmer but
///   produces "steppy" motion on slow layers)
class PixelParallaxBackdropComponent extends Component
    with HasGameReference<FlameGame> {
  PixelParallaxBackdropComponent({
    required this.virtualWidth,
    required this.virtualHeight,
    required this.layers,
    this.snapScrollToPixels = true,
  });

  final int virtualWidth;
  final int virtualHeight;
  final List<PixelParallaxLayerSpec> layers;

  /// When true, each layer's scroll offset is snapped to integer pixels.
  ///
  /// When false, sub-pixel scrolling is allowed (smoother motion) but will
  /// introduce shimmer on pixel art. This is a deliberate tradeoff.
  final bool snapScrollToPixels;

  late final List<ui.Image> _images;
  int? _prevCameraLeftX;
  late final List<double> _scroll;

  final Paint _paint = Paint()..filterQuality = FilterQuality.none;

  @override
  Future<void> onLoad() async {
    await super.onLoad();
    _images = await Future.wait(
      layers.map((layer) => game.images.load(layer.assetPath)),
    );
    _scroll = List<double>.filled(layers.length, 0);
  }

  @override
  void update(double dt) {
    super.update(dt);

    final viewWidth = virtualWidth;
    final cameraLeftX =
        (game.camera.viewfinder.position.x - viewWidth / 2).round();

    final prev = _prevCameraLeftX;
    _prevCameraLeftX = cameraLeftX;
    if (prev == null) return;

    final delta = cameraLeftX - prev;
    if (delta == 0) return;

    for (var i = 0; i < layers.length; i++) {
      _scroll[i] += delta * layers[i].parallaxFactor;
      _scroll[i] = positiveModDouble(_scroll[i], _images[i].width.toDouble());
    }
  }

  @override
  void render(ui.Canvas canvas) {
    super.render(canvas);

    final viewWidth = virtualWidth;
    final viewHeight = virtualHeight;

    canvas.save();
    canvas.clipRect(
      ui.Rect.fromLTWH(0, 0, viewWidth.toDouble(), viewHeight.toDouble()),
    );

    for (var i = 0; i < layers.length; i++) {
      final image = _images[i];

      final imageW = image.width;
      final imageH = image.height;
      final y = (viewHeight - imageH).toDouble(); // bottom-aligned

      final scroll = snapScrollToPixels ? _scroll[i].roundToDouble() : _scroll[i];
      final offsetPx = -scroll;
      final startX = positiveModDouble(offsetPx, imageW.toDouble());

      for (var x = startX - imageW; x < viewWidth; x += imageW) {
        canvas.drawImage(image, ui.Offset(x, y), _paint);
      }
    }

    canvas.restore();
  }
}

/// One parallax layer spec.
class PixelParallaxLayerSpec {
  const PixelParallaxLayerSpec({
    required this.assetPath,
    required this.parallaxFactor,
  });

  final String assetPath;

  /// `0.0` means static background, `1.0` moves with the camera.
  ///
  /// Values are snapped to integer pixels after multiplication.
  final double parallaxFactor;
}


===== FILE: lib/game/components/tiled_ground_band_component.dart =====
import 'dart:ui' as ui;

import 'package:flame/components.dart';
import 'package:flame/game.dart';
import 'package:flutter/painting.dart';

import '../util/math_util.dart';

/// World-space ground band placeholder (visual reference for Milestone 1).
///
/// This draws `Field Layer 09.png` as a horizontally tiled strip in *world
/// coordinates* so it naturally moves 1.0× with the camera.
///
/// Collision is handled later in Core (Milestone 2). For now, this provides a
/// stable visual ground reference for camera + pixel-perfect sanity checks.
class TiledGroundBandComponent extends Component
    with HasGameReference<FlameGame> {
  TiledGroundBandComponent({
    required this.assetPath,
    this.virtualWidth,
    required this.virtualHeight,
    this.renderInBackdrop = false,
  }) {
    if (renderInBackdrop && virtualWidth == null) {
      throw ArgumentError(
        'virtualWidth is required when renderInBackdrop is true',
      );
    }
  }

  final String assetPath;
  final int? virtualWidth;
  final int virtualHeight;
  final bool renderInBackdrop;

  late final ui.Image _image;
  final Paint _paint = Paint()..filterQuality = FilterQuality.none;

  @override
  Future<void> onLoad() async {
    await super.onLoad();
    _image = await game.images.load(assetPath);
  }

  @override
  void render(ui.Canvas canvas) {
    super.render(canvas);

    if (renderInBackdrop) {
      final viewWidth = virtualWidth!;

      final tileW = _image.width;
      final tileH = _image.height;
      final y = (virtualHeight - tileH).toDouble(); // bottom aligned

      final cameraLeftX =
          (game.camera.viewfinder.position.x - viewWidth / 2);
      final offsetPx = -cameraLeftX;
      final startX = positiveModDouble(offsetPx, tileW.toDouble());

      canvas.save();
      canvas.clipRect(
        ui.Rect.fromLTWH(0, 0, viewWidth.toDouble(), virtualHeight.toDouble()),
      );

      for (var x = startX - tileW; x < viewWidth; x += tileW) {
        canvas.drawImage(_image, ui.Offset(x, y), _paint);
      }

      canvas.restore();
      return;
    }

    final visible = game.camera.visibleWorldRect;

    final tileW = _image.width;
    final tileH = _image.height;
    final y = (virtualHeight - tileH).toDouble(); // bottom aligned to viewport

    final left = visible.left.floor();
    final right = visible.right.ceil();

    final startTile = _floorDiv(left, tileW) - 1;
    final endTile = _floorDiv(right, tileW) + 1;

    for (var tile = startTile; tile <= endTile; tile++) {
      final x = (tile * tileW).toDouble();
      canvas.drawImage(_image, ui.Offset(x, y), _paint);
    }
  }

  int _floorDiv(int a, int b) {
    if (b <= 0) throw ArgumentError.value(b, 'b', 'must be > 0');
    if (a >= 0) return a ~/ b;
    return -(((-a) + b - 1) ~/ b);
  }
}


===== FILE: lib/game/game_controller.dart =====
// Bridge between Core simulation and the Flutter/Flame runtime.
//
// Responsibilities:
// - Owns the `GameCore` instance
// - Queues tick-stamped input commands
// - Runs a fixed-tick simulation loop using an accumulator
// - Exposes (`prevSnapshot`, `snapshot`, `alpha`) for render interpolation
// - Buffers transient `GameEvent`s for Render/UI to consume
import 'dart:math';

import '../core/commands/command.dart';
import '../core/events/game_event.dart';
import '../core/game_core.dart';
import '../core/snapshots/game_state_snapshot.dart';
import 'tick_input_frame.dart';

/// Owns the simulation clock and provides a stable interface to UI/renderer.
class GameController {
  GameController({required GameCore core, this.tickHz = 60, this.inputLead = 1})
    : _core = core {
    if (tickHz <= 0) {
      throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
    }
    if (inputLead < 1) {
      throw ArgumentError.value(inputLead, 'inputLead', 'must be >= 1');
    }
    if (tickHz != _core.tickHz) {
      throw ArgumentError(
        'GameController.tickHz ($tickHz) must match GameCore.tickHz (${_core.tickHz}).',
      );
    }
    _curr = _core.buildSnapshot();
    _prev = _curr;
  }

  final GameCore _core;

  /// Fixed simulation tick frequency.
  final int tickHz;

  /// How many ticks ahead local input is scheduled by default.
  ///
  /// `1` means "next tick".
  final int inputLead;

  /// Buffered commands keyed by their target tick.
  final Map<int, TickInputFrame> _inputsByTick = <int, TickInputFrame>{};

  final List<Command> _commandScratch = <Command>[];
  final TickInputFrame _frameScratch = TickInputFrame();

  /// Buffered transient events produced by the core.
  final List<GameEvent> _events = <GameEvent>[];

  late GameStateSnapshot _prev;
  late GameStateSnapshot _curr;

  /// Accumulated time for fixed-tick simulation.
  double _accumulatorSeconds = 0;

  /// Current simulation tick (authoritative).
  int get tick => _core.tick;

  /// Latest snapshot produced by the core.
  GameStateSnapshot get snapshot => _curr;

  /// Previous snapshot (used for render interpolation).
  GameStateSnapshot get prevSnapshot => _prev;

  /// Interpolation factor between `prevSnapshot` and `snapshot` for rendering.
  double get alpha {
    final dtTick = 1.0 / tickHz;
    return (_accumulatorSeconds / dtTick).clamp(0, 1);
  }

  /// Enqueues a command to be applied at its declared tick.
  void enqueue(Command command) {
    final frame = _inputsByTick.putIfAbsent(command.tick, () => TickInputFrame());
    frame.apply(command);
  }

  /// Helper to schedule a command for the next tick (plus `inputLead`).
  void enqueueForNextTick(Command Function(int tick) factory) {
    enqueue(factory(tick + inputLead));
  }

  /// Drains and clears all buffered transient events.
  List<GameEvent> drainEvents() {
    if (_events.isEmpty) return const <GameEvent>[];
    final drained = List<GameEvent>.unmodifiable(_events);
    _events.clear();
    return drained;
  }

  /// Pauses/unpauses the simulation.
  void setPaused(bool value) {
    if (_core.paused == value) return;
    _core.paused = value;
    _accumulatorSeconds = 0;
    _prev = _core.buildSnapshot();
    _curr = _prev;
  }

  /// Permanently stops this controller for the current session.
  ///
  /// Use this when leaving the mini-game route (dispose), NOT for backgrounding
  /// (that's what [setPaused] is for).
  ///
  /// What it does:
  /// - pauses the core
  /// - clears queued commands (prevents "stuck input" on next mount)
  /// - clears buffered transient events
  /// - resets interpolation state (accumulator + snapshots)
  void shutdown() {
    // Pause regardless of current state (do NOT early-return like setPaused()).
    _core.paused = true;

    // Drop any in-flight fixed-tick accumulation.
    _accumulatorSeconds = 0;

    // Kill transient buffers so nothing leaks across sessions.
    _inputsByTick.clear();
    _events.clear();

    // Make snapshots consistent with the paused state.
    _curr = _core.buildSnapshot();
    _prev = _curr;
  }

  /// Advances the simulation clock based on a variable frame delta.
  ///
  /// This uses an accumulator to execute a fixed number of simulation ticks.
  /// `dtSeconds` is clamped to avoid "spiral of death" after app resumes.
  void advanceFrame(double dtSeconds, {double dtFrameMaxSeconds = 0.1}) {
    if (dtSeconds.isNaN || dtSeconds.isInfinite) return;
    if (_core.paused) {
      _accumulatorSeconds = 0;
      return;
    }

    final clamped = max(0.0, min(dtSeconds, dtFrameMaxSeconds));
    _accumulatorSeconds += clamped;

    final dtTick = 1.0 / tickHz;

    while (_accumulatorSeconds >= dtTick) {
      if (_core.paused) {
        _accumulatorSeconds = 0;
        break;
      }
      final nextTick = _core.tick + 1;
      final input = _inputsByTick.remove(nextTick) ?? _frameScratch;
      _applyTickInput(nextTick, input);
      _core.stepOneTick();
      _events.addAll(_core.drainEvents());

      _prev = _curr;
      _curr = _core.buildSnapshot();
      _accumulatorSeconds -= dtTick;

      // If the core became paused during the tick (e.g. game over), stop consuming
      // accumulator to avoid an infinite loop.
      if (_core.paused) {
        _accumulatorSeconds = 0;
        break;
      }
    }
  }

  void _applyTickInput(int tick, TickInputFrame input) {
    _commandScratch.clear();

    final axis = input.moveAxis;
    if (axis != 0) {
      _commandScratch.add(MoveAxisCommand(tick: tick, axis: axis));
    }

    if (input.aimDirSet) {
      _commandScratch.add(
        AimDirCommand(
          tick: tick,
          x: input.aimDirX,
          y: input.aimDirY,
        ),
      );
    }
    if (input.jumpPressed) {
      _commandScratch.add(JumpPressedCommand(tick: tick));
    }
    if (input.dashPressed) {
      _commandScratch.add(DashPressedCommand(tick: tick));
    }
    if (input.attackPressed) {
      _commandScratch.add(AttackPressedCommand(tick: tick));
    }
    if (input.castPressed) {
      _commandScratch.add(CastPressedCommand(tick: tick));
    }

    _core.applyCommands(_commandScratch);

    // If this is a scratch fallback, it will be reset by the next use anyway.
    // For frames stored in the map we drop the instance after remove().
    input.reset();
  }
}


===== FILE: lib/game/input/runner_input_router.dart =====
import 'dart:math';

import '../../core/commands/command.dart';
import '../game_controller.dart';

/// Shared input scheduler for multiple input sources (touch + keyboard + mouse).
///
/// - Holds the current continuous inputs (move axis, aim direction).
/// - Schedules them into the GameController for upcoming ticks so Core receives
///   tick-stamped Commands.
/// - Schedules edge-triggered presses (jump/dash/attack/cast) for the next tick.
class RunnerInputRouter {
  RunnerInputRouter({required this.controller});

  final GameController controller;

  static const double _aimQuantizeScale = 256.0;

  double _moveAxis = 0;
  double _lastScheduledAxis = 0;
  int _axisScheduledThroughTick = 0;

  bool _aimSet = false;
  bool _lastScheduledAimSet = false;
  double _aimX = 0;
  double _aimY = 0;
  double _lastScheduledAimX = 0;
  double _lastScheduledAimY = 0;
  int _aimScheduledThroughTick = 0;

  static double _quantizeAim(double value) {
    if (value == 0) return 0;
    return (value * _aimQuantizeScale).roundToDouble() / _aimQuantizeScale;
  }

  void setMoveAxis(double axis) {
    _moveAxis = axis.clamp(-1.0, 1.0);
  }

  /// Sets the aim direction (should be normalized or near-normalized).
  void setAimDir(double x, double y) {
    final qx = _quantizeAim(x);
    final qy = _quantizeAim(y);

    if (_aimSet && qx == _aimX && qy == _aimY) {
      return;
    }

    _aimSet = true;
    _aimX = qx;
    _aimY = qy;
  }

  void clearAimDir() {
    _aimSet = false;
    _aimX = 0;
    _aimY = 0;
  }

  void pressJump() => controller.enqueueForNextTick(
        (tick) => JumpPressedCommand(tick: tick),
      );

  void pressDash() => controller.enqueueForNextTick(
        (tick) => DashPressedCommand(tick: tick),
      );

  void pressAttack() => controller.enqueueForNextTick(
        (tick) => AttackPressedCommand(tick: tick),
      );

  void pressCast() => controller.enqueueForNextTick(
        (tick) => CastPressedCommand(tick: tick),
      );

  /// Presses cast on the next tick and ensures the aim direction is set for the same tick.
  void pressCastWithAim() {
    final tick = controller.tick + controller.inputLead;
    if (_aimSet) {
      controller.enqueue(AimDirCommand(tick: tick, x: _aimX, y: _aimY));
    }
    controller.enqueue(CastPressedCommand(tick: tick));
  }

  /// Schedules the current held inputs across upcoming ticks.
  ///
  /// Call once per frame before `controller.advanceFrame(dt)`.
  void pumpHeldInputs() {
    _scheduleHeldMoveAxis();
    _scheduleHeldAimDir();
  }

  void _scheduleHeldMoveAxis() {
    final axis = _moveAxis;

    if (axis == 0 && _lastScheduledAxis == 0) {
      // No held axis and nothing to override.
      _axisScheduledThroughTick = controller.tick;
      return;
    }

    if (axis != _lastScheduledAxis) {
      // Axis changed (including to 0); reschedule to overwrite any already
      // buffered ticks.
      _axisScheduledThroughTick = controller.tick;
      _lastScheduledAxis = axis;
    }

    final maxTicksPerFrame = (controller.tickHz * 0.1).ceil();
    final targetMaxTick =
        controller.tick + controller.inputLead + maxTicksPerFrame;

    final startTick = max(controller.tick + 1, _axisScheduledThroughTick + 1);
    for (var t = startTick; t <= targetMaxTick; t += 1) {
      controller.enqueue(MoveAxisCommand(tick: t, axis: axis));
    }
    _axisScheduledThroughTick = targetMaxTick;
  }

  void _scheduleHeldAimDir() {
    if (!_aimSet && !_lastScheduledAimSet) {
      // No held aim and nothing to override.
      _aimScheduledThroughTick = controller.tick;
      return;
    }

    if (_aimSet != _lastScheduledAimSet) {
      _aimScheduledThroughTick = controller.tick;
      _lastScheduledAimSet = _aimSet;
      _lastScheduledAimX = _aimX;
      _lastScheduledAimY = _aimY;
    }

    if (_aimSet && (_aimX != _lastScheduledAimX || _aimY != _lastScheduledAimY)) {
      // Reschedule ahead when the aim vector changes.
      _aimScheduledThroughTick = controller.tick;
      _lastScheduledAimX = _aimX;
      _lastScheduledAimY = _aimY;
    }

    final maxTicksPerFrame = (controller.tickHz * 0.1).ceil();
    final targetMaxTick =
        controller.tick + controller.inputLead + maxTicksPerFrame;

    final startTick = max(controller.tick + 1, _aimScheduledThroughTick + 1);
    for (var t = startTick; t <= targetMaxTick; t += 1) {
      if (_aimSet) {
        controller.enqueue(AimDirCommand(tick: t, x: _aimX, y: _aimY));
      } else {
        controller.enqueue(ClearAimDirCommand(tick: t));
      }
    }
    _aimScheduledThroughTick = targetMaxTick;
  }
}


===== FILE: lib/game/README.md =====
# Game (Flame)

Flame rendering layer.

- Renders from core snapshots (read-only)
- Handles camera/parallax/VFX/audio
- Must not own authoritative gameplay state



===== FILE: lib/game/runner_flame_game.dart =====
// Flame rendering layer for the runner (Milestone 0 placeholder).
//
// Reads the latest `GameStateSnapshot` from `GameController` each frame and
// renders a minimal representation (a player dot + debug text). This file is
// intentionally tiny and non-authoritative: gameplay truth lives in Core.
import 'package:flame/components.dart';
import 'package:flame/game.dart';
import 'package:flutter/widgets.dart';

import '../core/contracts/v0_render_contract.dart';
import '../core/snapshots/entity_render_snapshot.dart';
import '../core/snapshots/enums.dart';
import '../core/snapshots/static_solid_snapshot.dart';
import 'input/runner_input_router.dart';
import 'components/pixel_parallax_backdrop_component.dart';
import 'components/tiled_ground_band_component.dart';
import 'components/hud_bars_component.dart';
import 'game_controller.dart';

/// Minimal Flame `Game` that renders from snapshots.
class RunnerFlameGame extends FlameGame {
  RunnerFlameGame({required this.controller, required this.input})
    : super(
        camera: CameraComponent.withFixedResolution(
          width: v0VirtualWidth.toDouble(),
          height: v0VirtualHeight.toDouble(),
        ),
      );

  /// Bridge/controller that owns the simulation and produces snapshots.
  final GameController controller;

  /// Input scheduler/aggregator (touch + keyboard + mouse).
  final RunnerInputRouter input;

  late final CircleComponent _player;
  //late final TextComponent _debugText;
  final List<RectangleComponent> _staticSolids = <RectangleComponent>[];
  List<StaticSolidSnapshot>? _lastStaticSolidsSnapshot;
  final Map<int, RectangleComponent> _projectiles = <int, RectangleComponent>{};
  final Paint _projectilePaint = Paint()..color = const Color(0xFF60A5FA);
  final Map<int, CircleComponent> _enemies = <int, CircleComponent>{};
  final List<Paint> _enemyPaints = <Paint>[
    Paint()..color = const Color(0xFFA855F7), // purple
    Paint()..color = const Color(0xFFF97316), // orange
  ];
  final Map<int, RectangleComponent> _hitboxes = <int, RectangleComponent>{};
  final Paint _hitboxPaint = Paint()..color = const Color(0x66EF4444);

  @override
  Future<void> onLoad() async {
    await super.onLoad();

    camera.backdrop.add(
      PixelParallaxBackdropComponent(
        virtualWidth: v0VirtualWidth,
        virtualHeight: v0VirtualHeight,
        snapScrollToPixels: false,
        layers: const [
          PixelParallaxLayerSpec(
            assetPath: 'parallax/field/Field Layer 01.png',
            parallaxFactor: 0.10,
          ),
          PixelParallaxLayerSpec(
            assetPath: 'parallax/field/Field Layer 02.png',
            parallaxFactor: 0.15,
          ),
          PixelParallaxLayerSpec(
            assetPath: 'parallax/field/Field Layer 03.png',
            parallaxFactor: 0.20,
          ),
          PixelParallaxLayerSpec(
            assetPath: 'parallax/field/Field Layer 04.png',
            parallaxFactor: 0.30,
          ),
          PixelParallaxLayerSpec(
            assetPath: 'parallax/field/Field Layer 05.png',
            parallaxFactor: 0.40,
          ),
          PixelParallaxLayerSpec(
            assetPath: 'parallax/field/Field Layer 06.png',
            parallaxFactor: 0.50,
          ),
          PixelParallaxLayerSpec(
            assetPath: 'parallax/field/Field Layer 07.png',
            parallaxFactor: 0.60,
          ),
          PixelParallaxLayerSpec(
            assetPath: 'parallax/field/Field Layer 08.png',
            parallaxFactor: 0.70,
          ),
        ],
      )..priority = -30,
    );

    camera.backdrop.add(
      TiledGroundBandComponent(
        assetPath: 'parallax/field/Field Layer 09.png',
        virtualWidth: v0VirtualWidth,
        virtualHeight: v0VirtualHeight,
        renderInBackdrop: true,
      )..priority = -20,
    );

    camera.backdrop.add(
      PixelParallaxBackdropComponent(
        virtualWidth: v0VirtualWidth,
        virtualHeight: v0VirtualHeight,
        snapScrollToPixels: false,
        layers: const [
          PixelParallaxLayerSpec(
            assetPath: 'parallax/field/Field Layer 10.png',
            parallaxFactor: 1.0,
          ),
        ],
      )..priority = -10,
    );

    _player = CircleComponent(
      radius: 8,
      paint: Paint()..color = const Color(0xFF4ADE80),
      anchor: Anchor.center,
    );
    world.add(_player);

    _mountStaticSolids(controller.snapshot.staticSolids);
    _lastStaticSolidsSnapshot = controller.snapshot.staticSolids;

/*     _debugText = TextComponent(
      text: '',
      position: Vector2(8, 8),
      anchor: Anchor.topLeft,
      textRenderer: TextPaint(
        style: const TextStyle(
          fontSize: 14,
          color: Color.fromARGB(255, 255, 0, 0),
        ),
      ),
    );
    camera.viewport.add(_debugText); */

    camera.viewport.add(
      HudBarsComponent(
        controller: controller,
        position: Vector2(8, 8),
        anchor: Anchor.topLeft,
      )..priority = 100,
    );
  }

  @override
  void update(double dt) {
    input.pumpHeldInputs();

    super.update(dt);

    // Step the deterministic core using the frame delta, then render the
    // newest snapshot.
    controller.advanceFrame(dt);
    final snapshot = controller.snapshot;
    _syncStaticSolids(snapshot.staticSolids);

    final player = _findPlayer(snapshot.entities);
    if (player != null) {
      final snappedX = player.pos.x.roundToDouble();
      final snappedY = player.pos.y.roundToDouble();
      _player.position.setValues(snappedX, snappedY);
    }
    camera.viewfinder.position = Vector2(
      snapshot.cameraCenterX.roundToDouble(),
      snapshot.cameraCenterY.roundToDouble(),
    );

    _syncEnemies(snapshot.entities);
    _syncProjectiles(snapshot.entities);
    _syncHitboxes(snapshot.entities);

/*     assert(() {
      _debugText.text =
          'tick=${snapshot.tick} seed=${snapshot.seed} x=${player?.pos.x.toStringAsFixed(1) ?? '-'} y=${player?.pos.y.toStringAsFixed(1) ?? '-'} anim=${player?.anim.name ?? '-'}';
      return true;
    }()); */
  }

  void _mountStaticSolids(List<StaticSolidSnapshot> solids) {
    if (solids.isEmpty) return;

    for (final solid in solids) {
      final color = solid.oneWayTop
          ? const Color(0x6648BB78) // green-ish translucent
          : const Color(0x668B5CF6); // purple translucent

      final rect = RectangleComponent(
        position: Vector2(solid.minX, solid.minY),
        size: Vector2(solid.maxX - solid.minX, solid.maxY - solid.minY),
        paint: Paint()..color = color,
      );
      rect.priority = -5;
      _staticSolids.add(rect);
      world.add(rect);
    }
  }

  /// Finds the player entity in the snapshot.
  EntityRenderSnapshot? _findPlayer(List<EntityRenderSnapshot> entities) {
    for (final e in entities) {
      if (e.kind == EntityKind.player) return e;
    }
    return null;
  }

  void _syncEnemies(List<EntityRenderSnapshot> entities) {
    final seen = <int>{};

    for (final e in entities) {
      if (e.kind != EntityKind.enemy) continue;
      seen.add(e.id);

      var view = _enemies[e.id];
      if (view == null) {
        final size = e.size;
        final radius =
            ((size != null) ? (size.x < size.y ? size.x : size.y) : 16.0) * 0.5;
        final paint = _enemyPaints[e.id % _enemyPaints.length];
        view = CircleComponent(
          radius: radius,
          anchor: Anchor.center,
          paint: paint,
        );
        view.priority = -2;
        _enemies[e.id] = view;
        world.add(view);
      } else {
        final size = e.size;
        if (size != null) {
          final radius = (size.x < size.y ? size.x : size.y) * 0.5;
          view.radius = radius;
        }
      }

      view.position.setValues(
        e.pos.x.roundToDouble(),
        e.pos.y.roundToDouble(),
      );
    }

    if (_enemies.isEmpty) return;
    final toRemove = <int>[];
    for (final id in _enemies.keys) {
      if (!seen.contains(id)) toRemove.add(id);
    }
    for (final id in toRemove) {
      _enemies.remove(id)?.removeFromParent();
    }
  }

  void _syncProjectiles(List<EntityRenderSnapshot> entities) {
    final seen = <int>{};

    for (final e in entities) {
      if (e.kind != EntityKind.projectile) continue;
      seen.add(e.id);

      var view = _projectiles[e.id];
      if (view == null) {
        final size = e.size;
        view = RectangleComponent(
          size: Vector2(size?.x ?? 8.0, size?.y ?? 8.0),
          anchor: Anchor.center,
          paint: _projectilePaint,
        );
        view.priority = -1;
        _projectiles[e.id] = view;
        world.add(view);
      } else {
        final size = e.size;
        if (size != null) {
          view.size.setValues(size.x, size.y);
        }
      }

      view.position.setValues(
        e.pos.x.roundToDouble(),
        e.pos.y.roundToDouble(),
      );
    }

    if (_projectiles.isEmpty) return;
    final toRemove = <int>[];
    for (final id in _projectiles.keys) {
      if (!seen.contains(id)) toRemove.add(id);
    }
    for (final id in toRemove) {
      _projectiles.remove(id)?.removeFromParent();
    }
  }

  void _syncHitboxes(List<EntityRenderSnapshot> entities) {
    final seen = <int>{};

    for (final e in entities) {
      if (e.kind != EntityKind.trigger) continue;
      seen.add(e.id);

      var view = _hitboxes[e.id];
      if (view == null) {
        final size = e.size;
        view = RectangleComponent(
          size: Vector2(size?.x ?? 8.0, size?.y ?? 8.0),
          anchor: Anchor.center,
          paint: _hitboxPaint,
        );
        view.priority = 1;
        _hitboxes[e.id] = view;
        world.add(view);
      } else {
        final size = e.size;
        if (size != null) {
          view.size.setValues(size.x, size.y);
        }
      }

      view.position.setValues(
        e.pos.x.roundToDouble(),
        e.pos.y.roundToDouble(),
      );
    }

    if (_hitboxes.isEmpty) return;
    final toRemove = <int>[];
    for (final id in _hitboxes.keys) {
      if (!seen.contains(id)) toRemove.add(id);
    }
    for (final id in toRemove) {
      _hitboxes.remove(id)?.removeFromParent();
    }
  }

  void _syncStaticSolids(List<StaticSolidSnapshot> solids) {
    // Core rebuilds the list only when geometry changes (spawn/cull),
    // so identity check is a cheap "version" check.
    if (identical(solids, _lastStaticSolidsSnapshot)) return;
    _lastStaticSolidsSnapshot = solids;

    for (final c in _staticSolids) {
      c.removeFromParent();
    }
    _staticSolids.clear();

    _mountStaticSolids(solids);
  }

  @override
  void onRemove() {
    images.clearCache();
    super.onRemove();
  }
}


===== FILE: lib/game/tick_input_frame.dart =====
import '../core/commands/command.dart';

/// Aggregated per-tick input for the simulation.
///
/// This replaces `List<Command>` buffering for a given tick to avoid duplicate
/// commands (e.g. multiple MoveAxis updates for the same tick).
class TickInputFrame {
  double moveAxis = 0;
  bool jumpPressed = false;
  bool dashPressed = false;
  bool attackPressed = false;
  bool aimDirSet = false;
  double aimDirX = 0;
  double aimDirY = 0;
  bool castPressed = false;

  void apply(Command command) {
    switch (command) {
      case MoveAxisCommand(:final axis):
        moveAxis = axis.clamp(-1.0, 1.0);
      case JumpPressedCommand():
        jumpPressed = true;
      case DashPressedCommand():
        dashPressed = true;
      case AttackPressedCommand():
        attackPressed = true;
      case AimDirCommand(:final x, :final y):
        aimDirSet = true;
        aimDirX = x;
        aimDirY = y;
      case ClearAimDirCommand():
        aimDirSet = false;
        aimDirX = 0;
        aimDirY = 0;
      case CastPressedCommand():
        castPressed = true;
    }
  }

  void reset() {
    moveAxis = 0;
    jumpPressed = false;
    dashPressed = false;
    attackPressed = false;
    aimDirSet = false;
    aimDirX = 0;
    aimDirY = 0;
    castPressed = false;
  }
}


===== FILE: lib/game/util/math_util.dart =====
double positiveModDouble(double value, double mod) {
  if (mod <= 0) throw ArgumentError.value(mod, 'mod', 'must be > 0');
  final r = value % mod;
  return r < 0 ? r + mod : r;
}



===== FILE: lib/main.dart =====
import 'package:flutter/material.dart';

import 'ui/dev_menu_page.dart';

/// Development-only host app for running the mini-game standalone.
///
/// The runner is intended to be embedded in another Flutter app via
/// `RunnerGameWidget` / `createRunnerGameRoute` (see `lib/runner.dart`).
/// Keep `main.dart` free of assumptions that would prevent embedding.
void main() {
  runApp(const _DevApp());
}

class _DevApp extends StatelessWidget {
  const _DevApp();

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Walkscape Runner (Dev)',
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(
          seedColor: const Color.fromARGB(255, 6, 21, 48),
        ),
        useMaterial3: true,
      ),
      home: const DevMenuPage(),
    );
  }
}


===== FILE: lib/runner.dart =====
// Public entrypoint ("barrel file") for embedding the runner in a host app.
//
// Host apps should import only this file:
// `import 'package:walkscape_runner/runner.dart';`
//
// This keeps the public API stable while allowing internal folders/files to
// evolve without breaking downstream imports.
export 'ui/runner_game_route.dart';
export 'ui/runner_game_widget.dart';


===== FILE: lib/ui/controls/fixed_joystick.dart =====
import 'package:flutter/widgets.dart';

/// Fixed-position horizontal joystick (V0).
///
/// - Only outputs an X axis in `[-1, 1]`.
/// - Centered at the widget's bounds; drag left/right to set axis.
class FixedJoystick extends StatefulWidget {
  const FixedJoystick({
    super.key,
    required this.onAxisChanged,
    this.size = 120,
    this.knobSize = 56,
  });

  final ValueChanged<double> onAxisChanged;
  final double size;
  final double knobSize;

  @override
  State<FixedJoystick> createState() => _FixedJoystickState();
}

class _FixedJoystickState extends State<FixedJoystick> {
  double _axis = 0;

  @override
  Widget build(BuildContext context) {
    final baseSize = widget.size;
    final knobSize = widget.knobSize;
    final radius = (baseSize - knobSize) / 2;

    return SizedBox(
      width: baseSize,
      height: baseSize,
      child: GestureDetector(
        onPanStart: (d) => _update(d.localPosition, radius),
        onPanUpdate: (d) => _update(d.localPosition, radius),
        onPanEnd: (_) => _setAxis(0),
        onPanCancel: () => _setAxis(0),
        child: CustomPaint(
          painter: _JoystickPainter(axis: _axis),
          child: Stack(
            children: [
              Positioned.fill(
                child: Center(
                  child: Container(
                    width: baseSize,
                    height: baseSize,
                    decoration: BoxDecoration(
                      color: const Color(0x33000000),
                      shape: BoxShape.circle,
                      border: Border.all(color: const Color(0x55FFFFFF)),
                    ),
                  ),
                ),
              ),
              Positioned.fill(
                child: Center(
                  child: Transform.translate(
                    offset: Offset(_axis * radius, 0),
                    child: Container(
                      width: knobSize,
                      height: knobSize,
                      decoration: BoxDecoration(
                        color: const Color(0x66FFFFFF),
                        shape: BoxShape.circle,
                        border: Border.all(color: const Color(0x88FFFFFF)),
                      ),
                    ),
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  void _update(Offset local, double radius) {
    final center = Offset(widget.size / 2, widget.size / 2);
    final dx = local.dx - center.dx;
    final clamped = dx.clamp(-radius, radius);
    final axis = radius <= 0 ? 0.0 : clamped / radius;
    _setAxis(axis);
  }

  void _setAxis(double axis) {
    final a = axis.clamp(-1.0, 1.0);
    if (a == _axis) return;
    setState(() => _axis = a);
    widget.onAxisChanged(a);
  }
}

class _JoystickPainter extends CustomPainter {
  const _JoystickPainter({required this.axis});

  final double axis;

  @override
  void paint(Canvas canvas, Size size) {
    // No-op; visuals are via Containers. Keep painter for future extensions.
  }

  @override
  bool shouldRepaint(covariant _JoystickPainter oldDelegate) =>
      oldDelegate.axis != axis;
}


===== FILE: lib/ui/controls/runner_controls_overlay.dart =====
import 'package:flutter/material.dart';

import 'fixed_joystick.dart';

class RunnerControlsOverlay extends StatelessWidget {
  const RunnerControlsOverlay({
    super.key,
    required this.onMoveAxis,
    required this.onJumpPressed,
    required this.onDashPressed,
    required this.onAttackPressed,
  });

  final ValueChanged<double> onMoveAxis;
  final VoidCallback onJumpPressed;
  final VoidCallback onDashPressed;
  final VoidCallback onAttackPressed;

  @override
  Widget build(BuildContext context) {
    return SafeArea(
      child: Stack(
        children: [
          Positioned(
            left: 16,
            bottom: 16,
            child: FixedJoystick(onAxisChanged: onMoveAxis),
          ),
          Positioned(
            right: 16,
            bottom: 16,
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                _ActionButton(
                  label: 'Jump',
                  icon: Icons.arrow_upward,
                  onPressed: onJumpPressed,
                ),
                const SizedBox(height: 12),
                _ActionButton(
                  label: 'Dash',
                  icon: Icons.flash_on,
                  onPressed: onDashPressed,
                ),
                const SizedBox(height: 12),
                _ActionButton(
                  label: 'Atk',
                  icon: Icons.close,
                  onPressed: onAttackPressed,
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}

class _ActionButton extends StatelessWidget {
  const _ActionButton({
    required this.label,
    required this.icon,
    required this.onPressed,
  });

  final String label;
  final IconData icon;
  final VoidCallback onPressed;

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      width: 72,
      height: 72,
      child: Material(
        color: const Color(0x33000000),
        shape: const CircleBorder(),
        child: InkWell(
          customBorder: const CircleBorder(),
          onTap: onPressed,
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(icon, color: Colors.white),
              const SizedBox(height: 2),
              Text(
                label,
                style: const TextStyle(fontSize: 12, color: Colors.white),
              ),
            ],
          ),
        ),
      ),
    );
  }
}



===== FILE: lib/ui/dev_menu_page.dart =====
import 'dart:math';

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import 'runner_game_route.dart';

/// Development-only menu used by the standalone host app (`lib/main.dart`).
///
/// Not part of the embeddable runner API. Host apps should integrate the game
/// via `RunnerGameWidget` / `createRunnerGameRoute` (see `lib/runner.dart`).
class DevMenuPage extends StatelessWidget {
  const DevMenuPage({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text(
          'Walkscape Runner (Dev)',
          style: TextStyle(color: Colors.white),
        ),
        backgroundColor: Color.fromARGB(255, 6, 21, 48),
      ),
      body: Center(
        child: FilledButton(
          onPressed: () {
            final seed = Random().nextInt(1 << 31);
            Navigator.of(context).push(
              createRunnerGameRoute(
                seed: seed,
                restoreOrientations: const [DeviceOrientation.portraitUp],
              ),
            );
          },
          child: const Text('Start'),
        ),
      ),
    );
  }
}


===== FILE: lib/ui/input/debug_keyboard_adapter.dart =====
import 'package:flutter/foundation.dart';
import 'package:flutter/services.dart';
import 'package:flutter/widgets.dart';

import '../../game/input/runner_input_router.dart';

/// Debug-only keyboard adapter (not part of V0 mobile input).
///
/// Supports BOTH:
/// - physical positions (WASD scan codes) for layout-agnostic behavior
/// - logical letters (ZQSD / WASD) for layout-friendly behavior (esp. Web/emulator quirks)
class DebugKeyboardAdapter extends StatefulWidget {
  const DebugKeyboardAdapter({
    super.key,
    required this.input,
    required this.child,
    this.enabled = kDebugMode,
  });

  final RunnerInputRouter input;
  final Widget child;
  final bool enabled;

  @override
  State<DebugKeyboardAdapter> createState() => _DebugKeyboardAdapterState();
}

class _DebugKeyboardAdapterState extends State<DebugKeyboardAdapter> {
  final FocusNode _focusNode = FocusNode(debugLabel: 'DebugKeyboardAdapter');

  final Set<PhysicalKeyboardKey> _physDown = <PhysicalKeyboardKey>{};
  final Set<LogicalKeyboardKey> _logDown = <LogicalKeyboardKey>{};

  @override
  void dispose() {
    _focusNode.dispose();
    super.dispose();
  }

  bool _isDown({
    PhysicalKeyboardKey? physical,
    LogicalKeyboardKey? logical,
    Iterable<PhysicalKeyboardKey> physicalAny = const [],
    Iterable<LogicalKeyboardKey> logicalAny = const [],
  }) {
    if (physical != null && _physDown.contains(physical)) return true;
    if (logical != null && _logDown.contains(logical)) return true;
    for (final k in physicalAny) {
      if (_physDown.contains(k)) return true;
    }
    for (final k in logicalAny) {
      if (_logDown.contains(k)) return true;
    }
    return false;
  }

  KeyEventResult _onKeyEvent(FocusNode node, KeyEvent event) {
    if (!widget.enabled) return KeyEventResult.ignored;

    if (event is KeyDownEvent) {
      _physDown.add(event.physicalKey);
      _logDown.add(event.logicalKey);

      final jumpPressed = _isDown(
        physicalAny: const [
          PhysicalKeyboardKey.space,
          PhysicalKeyboardKey.arrowUp,
          PhysicalKeyboardKey.keyW, // WASD physical position
        ],
        logicalAny: const [
          LogicalKeyboardKey.space,
          LogicalKeyboardKey.arrowUp,
          LogicalKeyboardKey.keyW, // QWERTY letter
          LogicalKeyboardKey.keyZ, // AZERTY letter
        ],
      );

      // Only fire jump on the actual KeyDown event (not every frame)
      // but ignore repeats by checking event.repeat if you want.
      if (jumpPressed) {
        widget.input.pressJump();
      }
    } else if (event is KeyUpEvent) {
      _physDown.remove(event.physicalKey);
      _logDown.remove(event.logicalKey);
    }

    final heldLeft = _isDown(
      physicalAny: const [PhysicalKeyboardKey.arrowLeft, PhysicalKeyboardKey.keyA],
      logicalAny: const [LogicalKeyboardKey.arrowLeft, LogicalKeyboardKey.keyA, LogicalKeyboardKey.keyQ],
    );

    final heldRight = _isDown(
      physicalAny: const [PhysicalKeyboardKey.arrowRight, PhysicalKeyboardKey.keyD],
      logicalAny: const [LogicalKeyboardKey.arrowRight, LogicalKeyboardKey.keyD],
    );

    if (heldLeft && !heldRight) {
      widget.input.setMoveAxis(-1);
    } else if (heldRight && !heldLeft) {
      widget.input.setMoveAxis(1);
    } else {
      widget.input.setMoveAxis(0);
    }

    return KeyEventResult.handled;
  }

  @override
  Widget build(BuildContext context) {
    if (!widget.enabled) return widget.child;

    // Crucial: clicking the game view should re-grab focus, otherwise KeyUp
    // can be missed and input feels “not continuous”.
    return Focus(
      autofocus: true,
      focusNode: _focusNode,
      onKeyEvent: _onKeyEvent,
      child: Listener(
        behavior: HitTestBehavior.translucent,
        onPointerDown: (_) => FocusScope.of(context).requestFocus(_focusNode),
        child: widget.child,
      ),
    );
  }
}


===== FILE: lib/ui/input/debug_mouse_adapter.dart =====
import 'package:flutter/foundation.dart';
import 'package:flutter/gestures.dart';
import 'package:flutter/widgets.dart';

import '../../game/game_controller.dart';
import '../../game/input/runner_input_router.dart';
import 'v0_viewport_mapper.dart';

/// Debug-only mouse adapter (not part of V0 mobile input).
///
/// - Move: updates AimDir.
/// - Left click: Attack.
/// - Middle click (or tertiary): Dash.
/// - Right click: Cast with aim.
class DebugMouseAdapter extends StatelessWidget {
  const DebugMouseAdapter({
    super.key,
    required this.controller,
    required this.input,
    required this.mapper,
    required this.child,
    this.enabled = kDebugMode,
  });

  final GameController controller;
  final RunnerInputRouter input;
  final V0ViewportMapper mapper;
  final Widget child;
  final bool enabled;

  @override
  Widget build(BuildContext context) {
    if (!enabled) return child;

    return Listener(
      behavior: HitTestBehavior.translucent,
      onPointerHover: (e) {
        if (e.kind != PointerDeviceKind.mouse) return;
        final dir = mapper.aimDirFromLocal(e.localPosition, controller.snapshot);
        if (dir == null) return;
        input.setAimDir(dir.x, dir.y);
      },
      onPointerMove: (e) {
        if (e.kind != PointerDeviceKind.mouse) return;
        final dir = mapper.aimDirFromLocal(e.localPosition, controller.snapshot);
        if (dir == null) return;
        input.setAimDir(dir.x, dir.y);
      },
      onPointerDown: (e) {
        if (e.kind != PointerDeviceKind.mouse) return;

        final dir = mapper.aimDirFromLocal(e.localPosition, controller.snapshot);
        if (dir != null) {
          input.setAimDir(dir.x, dir.y);
        }

        final b = e.buttons;

        final isDash = (b & kMiddleMouseButton) != 0 || (b & kTertiaryButton) != 0;
        final isAttack = (b & kPrimaryButton) != 0;
        final isCast = (b & kSecondaryButton) != 0;

        if (isDash) input.pressDash();
        if (isAttack) input.pressAttack();
        if (isCast) input.pressCastWithAim();
      },
      child: child,
    );
  }
}


===== FILE: lib/ui/input/touch_game_view_adapter.dart =====
import 'package:flutter/gestures.dart';
import 'package:flutter/widgets.dart';

import '../../game/game_controller.dart';
import '../../game/input/runner_input_router.dart';
import 'v0_viewport_mapper.dart';

/// Handles touch interactions on the game view (V0).
///
/// - Tap on the game view: sets aim dir (from tap position) and triggers cast.
class TouchGameViewAdapter extends StatelessWidget {
  const TouchGameViewAdapter({
    super.key,
    required this.controller,
    required this.input,
    required this.mapper,
    required this.child,
  });

  final GameController controller;
  final RunnerInputRouter input;
  final V0ViewportMapper mapper;
  final Widget child;

  @override
  Widget build(BuildContext context) {
    return Listener(
      onPointerDown: (e) {
        if (e.kind == PointerDeviceKind.mouse) return;
        final dir = mapper.aimDirFromLocal(e.localPosition, controller.snapshot);
        if (dir != null) {
          input.setAimDir(dir.x, dir.y);
          input.pressCastWithAim();
        } else {
          input.pressCast();
        }
      },
      child: child,
    );
  }
}



===== FILE: lib/ui/input/v0_viewport_mapper.dart =====
import 'dart:math' as math;

import 'package:flutter/widgets.dart';

import '../../core/contracts/v0_render_contract.dart';
import '../../core/math/vec2.dart';
import '../../core/snapshots/game_state_snapshot.dart';

/// Helper for mapping local pointer positions into V0 world-space aim direction.
///
/// This follows the pixel-perfect viewport rules (integer physical-pixel scale
/// + letterbox) so aim lines up with what the player sees.
class V0ViewportMapper {
  V0ViewportMapper._({
    required this.viewW,
    required this.viewH,
    required this.offsetX,
    required this.offsetY,
  });

  factory V0ViewportMapper.fromConstraints(
    BoxConstraints constraints, {
    required double devicePixelRatio,
  }) {
    final screenPxW = constraints.maxWidth * devicePixelRatio;
    final screenPxH = constraints.maxHeight * devicePixelRatio;
    final scaleW = (screenPxW / v0VirtualWidth).floor();
    final scaleH = (screenPxH / v0VirtualHeight).floor();
    final scale = math.max(1, math.min(scaleW, scaleH));

    final viewW = (v0VirtualWidth * scale) / devicePixelRatio;
    final viewH = (v0VirtualHeight * scale) / devicePixelRatio;
    final offsetX = (constraints.maxWidth - viewW) / 2;
    final offsetY = (constraints.maxHeight - viewH) / 2;

    return V0ViewportMapper._(
      viewW: viewW,
      viewH: viewH,
      offsetX: offsetX,
      offsetY: offsetY,
    );
  }

  final double viewW;
  final double viewH;
  final double offsetX;
  final double offsetY;

  Vec2? aimDirFromLocal(Offset localPos, GameStateSnapshot snapshot) {
    final inViewportX = localPos.dx - offsetX;
    final inViewportY = localPos.dy - offsetY;
    if (inViewportX < 0 ||
        inViewportY < 0 ||
        inViewportX > viewW ||
        inViewportY > viewH) {
      return null;
    }

    if (snapshot.entities.isEmpty) return null;
    final player = snapshot.entities.first;

    final vx = (inViewportX / viewW) * v0VirtualWidth;
    final vy = (inViewportY / viewH) * v0VirtualHeight;

    final camCenterX = player.pos.x.roundToDouble();
    final camCenterY = v0CameraFixedY.roundToDouble();

    final worldX = camCenterX - (v0VirtualWidth / 2) + vx;
    final worldY = camCenterY - (v0VirtualHeight / 2) + vy;

    final dx = worldX - player.pos.x;
    final dy = worldY - player.pos.y;
    final len = math.sqrt(dx * dx + dy * dy);
    if (len <= 1e-9) return const Vec2(0, 0);
    return Vec2(dx / len, dy / len);
  }
}



===== FILE: lib/ui/pixel_perfect_viewport.dart =====
import 'dart:math';

import 'package:flutter/widgets.dart';

/// Renders a child at an integer *physical pixel* scale of a fixed virtual size,
/// with deterministic letterboxing.
///
/// This is the Flutter-side implementation of the "pixel-perfect" viewport
/// rules from `docs/plan.md`:
/// - virtual size is fixed (e.g., 480×270)
/// - scale is an integer in physical pixels (never fractional)
/// - remaining space is letterboxed with a solid color
///
/// Use [alignment] to control where letterboxing appears (e.g.
/// `Alignment.center` for centered letterbox, `Alignment.bottomLeft` to keep
/// the bottom-left edge pinned).
///
/// Note: this only guarantees correct sizing/letterboxing. The Flame side
/// still needs a fixed-resolution viewport/camera setup to ensure world units
/// map to virtual pixels (handled in later milestones).
class PixelPerfectViewport extends StatelessWidget {
  const PixelPerfectViewport({
    super.key,
    required this.virtualWidth,
    required this.virtualHeight,
    required this.child,
    this.letterboxColor = const Color(0xFF000000),
    this.alignment = Alignment.center,
  });

  final int virtualWidth;
  final int virtualHeight;
  final Widget child;
  final Color letterboxColor;
  final AlignmentGeometry alignment;

  @override
  Widget build(BuildContext context) {
    final devicePixelRatio = MediaQuery.devicePixelRatioOf(context);

    return LayoutBuilder(
      builder: (context, constraints) {
        if (!constraints.hasBoundedWidth || !constraints.hasBoundedHeight) {
          return child;
        }

        final screenPxW = constraints.maxWidth * devicePixelRatio;
        final screenPxH = constraints.maxHeight * devicePixelRatio;

        final scale = max(1, _computeLetterboxScale(screenPxW, screenPxH));

        final renderLogicalW = (virtualWidth * scale) / devicePixelRatio;
        final renderLogicalH = (virtualHeight * scale) / devicePixelRatio;

        final sizedChild = SizedBox(
          width: renderLogicalW,
          height: renderLogicalH,
          child: child,
        );

        return ColoredBox(
          color: letterboxColor,
          child: ClipRect(
            child: SizedBox.expand(
              child: Align(alignment: alignment, child: sizedChild),
            ),
          ),
        );
      },
    );
  }

  int _computeLetterboxScale(double screenPxW, double screenPxH) {
    final scaleW = screenPxW / virtualWidth;
    final scaleH = screenPxH / virtualHeight;
    return min(scaleW.floor(), scaleH.floor());
  }
}


===== FILE: lib/ui/README.md =====
# UI (Flutter)

Flutter UI layer (menus, overlays, input widgets).

- Sends high-level commands to the `GameController`
- Must not mutate core gameplay state directly



===== FILE: lib/ui/runner_game_route.dart =====
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import 'runner_game_widget.dart';
import 'scoped_preferred_orientations.dart';

/// Embed-friendly route factory for hosting the mini-game in any Flutter app.
///
/// Host apps can `Navigator.push(createRunnerGameRoute(...))` without depending
/// on this package's development host app (`lib/main.dart`).
///
Route<void> createRunnerGameRoute({
  int seed = 1,
  bool lockLandscape = true,
  List<DeviceOrientation>? restoreOrientations,
}) {
  return MaterialPageRoute<void>(
    builder: (context) {
      Widget child = RunnerGameWidget(
        seed: seed,
        onExit: () => Navigator.of(context).maybePop(),
        enableDebugInput: true,
      );

      if (lockLandscape) {
        child = ScopedPreferredOrientations(
          preferredOrientations: const [
            DeviceOrientation.landscapeLeft,
            DeviceOrientation.landscapeRight,
          ],
          restoreOrientations: restoreOrientations,
          child: child,
        );
      }

      return Scaffold(body: child);
    },
  );
}


===== FILE: lib/ui/runner_game_widget.dart =====
import 'package:flame/game.dart';
import 'package:flutter/material.dart';

import '../core/contracts/v0_render_contract.dart';
import '../core/game_core.dart';
import '../game/game_controller.dart';
import '../game/input/runner_input_router.dart';
import '../game/runner_flame_game.dart';
import 'controls/runner_controls_overlay.dart';
import 'input/debug_keyboard_adapter.dart';
import 'input/debug_mouse_adapter.dart';
import 'pixel_perfect_viewport.dart';
import 'input/touch_game_view_adapter.dart';
import 'input/v0_viewport_mapper.dart';

/// Embed-friendly widget that hosts the mini-game.
///
/// Intended to be mounted by a host app. It owns its [GameController] and
/// cleans it up on dispose.
///
/// Pixel scaling is applied by [PixelPerfectViewport] to keep the fixed virtual
/// resolution letterboxed to the available screen.
class RunnerGameWidget extends StatefulWidget {
  const RunnerGameWidget({
    super.key,
    this.seed = 1,
    this.onExit,
    this.showExitButton = true,
    this.enableDebugInput = false,
  });

  final int seed;

  final VoidCallback? onExit;
  final bool showExitButton;
  final bool enableDebugInput;

  @override
  State<RunnerGameWidget> createState() => _RunnerGameWidgetState();
}

class _RunnerGameWidgetState extends State<RunnerGameWidget>
    with WidgetsBindingObserver {
  bool _pausedByLifecycle = false;

  late final GameController _controller = GameController(
    core: GameCore(seed: widget.seed),
  );
  late final RunnerInputRouter _input =
      RunnerInputRouter(controller: _controller);
  late final RunnerFlameGame _game = RunnerFlameGame(
    controller: _controller,
    input: _input,
  );

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) =>
      _onLifecycle(state);

  void _onLifecycle(AppLifecycleState state) {
    if (state == AppLifecycleState.resumed) {
      if (_pausedByLifecycle) {
        _pausedByLifecycle = false;
        _controller.setPaused(false);
      }
      return;
    }
    _pausedByLifecycle = true;
    _controller.setPaused(true);
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    _controller.shutdown();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Stack(
      fit: StackFit.expand,
      children: [
        LayoutBuilder(
          builder: (context, constraints) {
            final mapper = V0ViewportMapper.fromConstraints(
              constraints,
              devicePixelRatio: MediaQuery.devicePixelRatioOf(context),
            );

            Widget gameView = PixelPerfectViewport(
              virtualWidth: v0VirtualWidth,
              virtualHeight: v0VirtualHeight,
              child: GameWidget(game: _game, autofocus: false),
            );

            gameView = TouchGameViewAdapter(
              controller: _controller,
              input: _input,
              mapper: mapper,
              child: gameView,
            );

            if (widget.enableDebugInput) {
              gameView = DebugMouseAdapter(
                controller: _controller,
                input: _input,
                mapper: mapper,
                child: gameView,
              );
              gameView = DebugKeyboardAdapter(input: _input, child: gameView);
            }

            return gameView;
          },
        ),
        RunnerControlsOverlay(
          onMoveAxis: _input.setMoveAxis,
          onJumpPressed: _input.pressJump,
          onDashPressed: _input.pressDash,
          onAttackPressed: _input.pressAttack,
        ),
        if (widget.showExitButton)
          Positioned(
            top: 8,
            left: 8,
            child: SafeArea(
              child: IconButton(
                onPressed: widget.onExit,
                icon: const Icon(Icons.close),
              ),
            ),
          ),
      ],
    );
  }
}


===== FILE: lib/ui/scoped_preferred_orientations.dart =====
import 'package:flutter/foundation.dart';
import 'package:flutter/services.dart';
import 'package:flutter/widgets.dart';

/// Applies `SystemChrome.setPreferredOrientations` while this widget is mounted.
///
/// This is intentionally scoped to a subtree (typically a route) so the runner
/// can be embedded in a host app without enforcing a global orientation policy.
///
/// Notes:
/// - Flutter does not expose the *previous* preferred orientations, so the
///   caller must decide what to restore on dispose.
/// - Platform-level orientation support (Android manifest / iOS Info.plist)
///   still needs to include the requested orientations.
class ScopedPreferredOrientations extends StatefulWidget {
  const ScopedPreferredOrientations({
    super.key,
    required this.preferredOrientations,
    required this.child,
    this.restoreOrientations,
  });

  final List<DeviceOrientation> preferredOrientations;
  final List<DeviceOrientation>? restoreOrientations;
  final Widget child;

  @override
  State<ScopedPreferredOrientations> createState() =>
      _ScopedPreferredOrientationsState();
}

class _ScopedPreferredOrientationsState
    extends State<ScopedPreferredOrientations> {
  @override
  void initState() {
    super.initState();
    SystemChrome.setPreferredOrientations(widget.preferredOrientations);
  }

  @override
  void didUpdateWidget(covariant ScopedPreferredOrientations oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (!listEquals(
      oldWidget.preferredOrientations,
      widget.preferredOrientations,
    )) {
      SystemChrome.setPreferredOrientations(widget.preferredOrientations);
    }
  }

  @override
  void dispose() {
    final restore = widget.restoreOrientations;
    if (restore != null) {
      SystemChrome.setPreferredOrientations(restore);
    }
    super.dispose();
  }

  @override
  Widget build(BuildContext context) => widget.child;
}

