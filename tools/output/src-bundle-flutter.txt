REPO: C:\dev\walkscape_runner
COMMIT: 68b9b3938bdf2620a6ae080a3a010e80c31a08ce
DATE: 2026-01-11 17:44:39


===== FILE: lib/AGENTS.md =====
# AGENTS.md

Instructions for AI coding agents (Codex, ChatGPT, etc.) when working in this repo.

## Project mission

Build and evolve this **Flutter (Dart) + Flame** runner into a **production-grade** game (mobile performance, clean architecture, deterministic Core, future online-ready), with a **scalable level system** that supports at least **two distinct playable levels** and makes adding more levels straightforward and low-risk.

## Working style (how to collaborate)

## Consent before changing code

When the user asks a question (e.g. “how do I…?”, “why…?”, “is it possible…?”) or explicitly says “no code / just answer”:

- **Do not make code changes or run refactors.** Provide an answer with options/tradeoffs only.
- If implementation would help, **ask for confirmation first** (e.g. “Want me to implement option A?”) before editing files.

Only implement changes when the user clearly requests it (e.g. “please implement”, “make the change”, “can you do X in the repo?”).

For any non-trivial task (anything that affects architecture, touches multiple layers/files, introduces a new subsystem, or changes a core contract):

- Brainstorm 1-3 viable approaches (with tradeoffs) before coding.
- Check whether a good solution already exists (repo patterns, Flame APIs, well-maintained packages) and prefer it when it fits the goals.
- Write a short plan (steps + acceptance criteria) and align on it before implementing.
- Ask clarifying questions when requirements are underspecified or multiple designs are plausible.

For trivial/surgical changes (tiny refactors, obvious bug fixes), proceed directly but keep changes minimal and consistent with existing patterns.

## Non-negotiable architecture

This project has **three hard layers**:

1. **Core (pure Dart simulation)**: deterministic gameplay + physics + AI + RNG
2. **Render (Flame)**: visuals only (sprites/animations/camera/parallax/VFX)
3. **UI (Flutter)**: menus, overlays, navigation, settings

Rules:

- **Core must not import Flutter or Flame.**
- Flame must not be authoritative for gameplay/collision.
- UI must not modify gameplay state directly; it sends **Commands** to the controller.
- The game must be embeddable: expose a reusable widget/route entrypoint; keep `lib/main.dart` as a dev host/demo only.

## Level system (content scaling)

Goal: support multiple distinct levels without forking gameplay code or entangling assets/UI.

Rules:

- Levels are **data-first**: define a `LevelId` + `LevelDefinition` (and optional level-specific systems) behind stable Core contracts.
- Level switching resets Core deterministically (seeded RNG, tick counter, entity world) and is driven by a **Command** from UI.
- Spawning/layout rules live in **Core** (authoritative). Render/UI only visualize and present selection/progress.
- Assets are organized and loaded **per level/scene**; avoid global “load everything at boot”.

## Prefer existing solutions (when they fit the goals)

Before building something custom, check if a better solution already exists:

- In this repo (search for an existing pattern/component first)
- In Flame APIs (camera, viewport, parallax, input, effects)
- In well-maintained Dart/Flutter packages

Rule of thumb:

- Prefer Flame for *render concerns* (camera components, parallax rendering, effects).
- Prefer UI (Flutter) for *UI/input widgets* (joystick/buttons/menus/overlays).
- Prefer Core for *authoritative gameplay concerns* (movement/physics/collision, ability timing, damage rules), especially when determinism/networking is a goal.

## Determinism contract

- Simulation runs in **fixed ticks** (e.g. 60 Hz). Ticks are the only time authority.
- Inputs are **Commands** queued for a specific tick.
- RNG is seeded and owned by the Core. No wall-clock randomness.
- On app resume, clamp frame dt and **never** try to "catch up" thousands of ticks.

## Core data model

### Entity storage

- Use **SoA + SparseSet** per component type.
- Entity IDs are monotonic and **never reused**.

Iteration rules:

- Systems iterate via queries (no direct sparse/dense fiddling).
- Do not add/remove components or destroy entities mid-iteration. Queue structural changes and apply after system execution.
- Do not keep references to dense arrays across ticks.

### Snapshots & events

Core outputs:

- Immutable `GameStateSnapshot` for render/UI (serializable, renderer-friendly).
- Transient `GameEvent`s (spawn/despawn/hit/sfx/screenshake/reward, etc.).

Renderer/UI must:

- Treat snapshots as read-only.
- Interpolate visuals using (`prevSnapshot`, `currSnapshot`, `alpha`) but **never simulate**.

## World / camera / pixel-art rules

- Pick one **virtual resolution** (world units == virtual pixels).
- Use **integer scaling + letterboxing**. No fractional scaling, no shimmering.
- Snap camera + render positions to integer pixels inside the scaled viewport.

## Asset rules

- Assets are loaded **per scene**, not at boot.
- No asset loading during active gameplay.
- Unload game assets when leaving the mini-game route.

## Implementation sequencing

Prefer small, testable increments that move toward “multiple levels”:

1. Define the Core level contracts (`LevelId`/`LevelDefinition`, load/reset flow).
2. Add level selection entry points (UI + dev menu) that send Commands only.
3. Make level-specific spawning/layout data-driven and deterministic.
4. Ship a second level that differs meaningfully (layout/spawns/tempo) without special-casing.
5. Add/extend Core tests to lock determinism per level (same seed ⇒ same snapshots/events).

## Code quality rules (Dart/Flutter)

- Keep the codebase modular and scalable:
  - prefer small, cohesive modules with clear boundaries
  - avoid tight coupling across Core/Render/UI; depend on stable contracts instead
  - keep public embedding API stable (`lib/runner.dart`), treat internal folders as refactorable
- Keep responsibilities narrow; avoid "god" classes that mix input/sim/render.
- Prefer explicit data flow: Commands in, snapshots/events out.
- Keep Core allocation-light: avoid per-tick new Lists/Maps in hot loops.
- Prefer `final`, `const`, and value types for small structs (e.g. `Vec2`).
- No `dynamic` in gameplay code (prefer typed payloads; if a temporary map is unavoidable, confine it to UI/debug only).
- Make side effects explicit: Core returns events; render/UI consume them.
- Keep changes consistent with existing style; avoid renames/reformatting unrelated code.
- Add/extend tests when relevant (especially when new behavior is introduced or existing behavior changes):
  - Core behavior: unit tests in `test/core/**` (`dart test`)
  - UI/viewport/widget behavior: widget tests where appropriate
- Keep docs in sync with code: update relevant docs whenever behavior, contracts, milestones, or public APIs change.

## What an agent must do on each task

When asked to implement/fix something:

1. Identify which layer it belongs to (Core vs Render vs UI).
2. Check for an existing solution/pattern that already fits the goal (repo + Flame + packages).
3. Propose a minimal plan (1-3 steps) and acceptance criteria.
4. Implement with deterministic rules intact.
5. Update docs/comments whenever a change affects behavior, contracts, milestones, or usage:
   - update `docs/building/plan.md` if architecture rules/contracts change
   - if no existing doc fits, add a short doc under `docs/building/` and link it from `docs/building/plan.md`
   - update `docs/building/TODO.md` if milestone checklist/follow-ups change
   - treat `docs/building/v0-implementation-plan.md` as historical unless asked to revise it
   - update top-of-file docs and public API docs (`lib/runner.dart`, route/widget docs) when embedding/API expectations change
6. Add/extend relevant tests when new behavior is introduced or existing behavior changes (especially Core determinism and systems).
7. Provide:
   - files changed + why
   - how to run/verify (build + quick sanity checks)
   - follow-ups (next incremental step)

## What NOT to do

- Don't add Flutter/Flame imports into `lib/core/**`.
- Don't use Flame collision callbacks as gameplay truth.
- Don't introduce wall-clock timing in simulation (no `DateTime.now()`, no frame-dt gameplay).
- Don't "just make it work" by mixing UI/render/core responsibilities.

## Suggested folder layout

- `lib/core/`    - simulation, components, systems, RNG, commands, snapshots
- `lib/game/`    - Flame `Game`, entity view components, camera/parallax, render adapters
- `lib/ui/`      - menus, overlays, UI state, input widgets
- `test/`        - Core unit tests

---
If anything here conflicts with repo docs, treat repo docs as the source of truth.


===== FILE: lib/core/camera/autoscroll_camera.dart =====
import '../util/smoothing.dart';
import '../util/double_math.dart';
import '../tuning/camera_tuning.dart';

class CameraState {
  const CameraState({
    required this.centerX,
    required this.targetX,
    required this.speedX,
  });

  /// Current visual center X of the camera view.
  final double centerX;

  /// The "ideal" center position the camera is trying to reach.
  /// This leads [centerX] and pulls it forward via smoothing.
  final double targetX;

  /// Current scroll speed (pixels/second).
  final double speedX;

  /// Creates a copy with updated fields.
  CameraState copyWith({
    double? centerX,
    double? targetX,
    double? speedX,
  }) {
    return CameraState(
      centerX: centerX ?? this.centerX,
      targetX: targetX ?? this.targetX,
      speedX: speedX ?? this.speedX,
    );
  }
}

/// Deterministic auto-scroll camera (Core).
///
/// Mirrors the reference behavior:
/// - baseline target speed with ease-in acceleration
/// - camera center eases toward a monotonic target X (never moves backward)
/// - player can pull the target forward only after passing a follow threshold
class AutoscrollCamera {
  AutoscrollCamera({
    required this.viewWidth,
    required CameraTuningDerived tuning,
    required CameraState initial,
  })  : _tuning = tuning,
        _state = initial;

  final double viewWidth;
  final CameraTuningDerived _tuning;

  CameraState get state => _state;
  CameraState _state;

  double left() => _state.centerX - viewWidth * 0.5;
  double right() => _state.centerX + viewWidth * 0.5;

  /// The X coordinate where the player starts pushing the camera forward.
  ///
  /// Calculated as a ratio of the viewport width from the left edge.
  double followThresholdX() => left() + _tuning.followThresholdRatio * viewWidth;

  /// Advances camera simulation by [dtSeconds].
  ///
  /// [playerX] is nullable to handle cases where the player is dead or despawned.
  void updateTick({
    required double dtSeconds,
    required double? playerX,
  }) {
    final t = _tuning;

    // 1. Update base scroll speed (accelerate/decelerate towards target speed).
    var speedX = _state.speedX;
    if (speedX < t.targetSpeedX) {
      speedX = clampDouble(speedX + t.accelX * dtSeconds, 0.0, t.targetSpeedX);
    } else if (speedX > t.targetSpeedX) {
      speedX = clampDouble(speedX - t.accelX * dtSeconds, t.targetSpeedX, speedX);
    }

    // 2. Integrate target position based on speed.
    var targetX = _state.targetX + speedX * dtSeconds;

    // 3. Player catch-up logic.
    // If the player pushes past the threshold, the target point is pulled forward.
    // This allows the player to run faster than the scroll speed without staying
    // pinned to the edge (camera speeds up to catch them).
    if (playerX != null) {
      final threshold = followThresholdX();
      if (playerX > threshold) {
        final alphaT = expSmoothingFactor(t.targetCatchupLerp, dtSeconds);
        final newTarget = targetX + (playerX - targetX) * alphaT;
        targetX = targetX > newTarget ? targetX : newTarget;
      }
    }

    // 4. Smooth the actual camera center towards the target.
    final alpha = expSmoothingFactor(t.catchupLerp, dtSeconds);
    var centerX = _state.centerX + (targetX - _state.centerX) * alpha;

    // 5. Monotonicity clamp: the camera is an auto-scroller, it never goes left.
    if (centerX < _state.centerX) centerX = _state.centerX;
    if (targetX < _state.targetX) targetX = _state.targetX;

    _state = _state.copyWith(centerX: centerX, targetX: targetX, speedX: speedX);
  }
}


===== FILE: lib/core/collision/static_world_geometry.dart =====
/// Static collision geometry owned by the Core simulation.
///
/// Starts with a set of base geometry (ground band), and extended with
/// deterministic chunk spawning.
class StaticGroundPlane {
  const StaticGroundPlane({required this.topY});

  /// World-space Y coordinate of the ground surface (solid top).
  final double topY;
}

/// A "hole" in the infinite ground plane where the player can fall through.
///
/// Use this to create pits or interruptions in the otherwise continuous ground.
class StaticGroundGap {
  const StaticGroundGap({required this.minX, required this.maxX})
    : assert(maxX >= minX);

  /// Start X coordinate of the gap (inclusive start of hole).
  final double minX;

  /// End X coordinate of the gap (inclusive end of hole).
  final double maxX;
}

/// A pre-computed walkable 1D segment for faster collision and navigation.
///
/// These are typically generated from the [StaticGroundPlane] minus any
/// [StaticGroundGap]s.
class StaticGroundSegment {
  const StaticGroundSegment({
    required this.minX,
    required this.maxX,
    required this.topY,
    this.chunkIndex = StaticSolid.groundChunk,
    this.localSegmentIndex = -1,
  }) : assert(maxX >= minX);

  /// Start X coordinate of the walkable surface.
  final double minX;

  /// End X coordinate of the walkable surface.
  final double maxX;

  /// Y coordinate of the surface (constant height).
  final double topY;

  /// Chunk index this segment was generated from, or [StaticSolid.groundChunk].
  final int chunkIndex;

  /// Stable local index within the chunk pattern authoring list.
  final int localSegmentIndex;
}

/// A generic AABB obstacle or platform in the world.
///
/// Can represent solid blocks, walls, floating platforms (one-way), or ceilings.
class StaticSolid {
  const StaticSolid({
    required this.minX,
    required this.minY,
    required this.maxX,
    required this.maxY,
    this.sides = sideTop,
    this.oneWayTop = true,
    this.chunkIndex = noChunk,
    this.localSolidIndex = -1,
  }) : assert(maxX >= minX),
       assert(maxY >= minY);

  /// Left edge world coordinate.
  final double minX;

  /// Bottom edge world coordinate.
  final double minY;

  /// Right edge world coordinate.
  final double maxX;

  /// Top edge world coordinate.
  final double maxY;

  /// Which faces of this solid participate in collision resolution.
  ///
  /// - one-way platforms typically use `sideTop` only
  /// - obstacles typically use `sideAll`
  final int sides;

  /// If true, the top surface only collides while falling (platform behavior).
  ///
  /// This only applies when [sides] includes [sideTop].
  final bool oneWayTop;

  /// Chunk index this solid was generated from (streaming), or [noChunk] for
  /// base/static geometry.
  final int chunkIndex;

  /// Stable local index within the chunk pattern authoring list.
  ///
  /// If negative, callers should derive a stable index from the owning list.
  final int localSolidIndex;

  /// Collision side flags.
  static const int sideNone = 0;
  static const int sideTop = 1 << 0;
  static const int sideBottom = 1 << 1;
  static const int sideLeft = 1 << 2;
  static const int sideRight = 1 << 3;
  static const int sideAll = sideTop | sideBottom | sideLeft | sideRight;

  /// Sentinel for solids not tied to a streamed chunk.
  static const int noChunk = -2;

  /// Reserved chunk index for always-on surfaces (e.g. ground plane).
  static const int groundChunk = -1;
}

/// Immutable bundle of static solids for a run/session.
class StaticWorldGeometry {
  const StaticWorldGeometry({
    this.groundPlane,
    this.groundSegments = const <StaticGroundSegment>[],
    this.solids = const <StaticSolid>[],
    this.groundGaps = const <StaticGroundGap>[],
  });

  /// Optional infinite ground plane (top surface only).
  final StaticGroundPlane? groundPlane;

  /// Walkable ground segments (used for collision + navigation).
  final List<StaticGroundSegment> groundSegments;

  /// Arbitrary static solids (platforms, walls, blocks).
  final List<StaticSolid> solids;

  /// Holes in the ground plane (world-space X ranges).
  final List<StaticGroundGap> groundGaps;
}


===== FILE: lib/core/collision/static_world_geometry_index.dart =====
import 'static_world_geometry.dart';
export 'static_world_geometry.dart';

/// Pre-indexed view of static world geometry for faster collision queries.
///
/// This is constructed once (per run/session) and preserves the original solid
/// ordering in each face list to keep behavior deterministic.
class StaticWorldGeometryIndex {
  StaticWorldGeometryIndex._({
    required this.geometry,
    required this.groundPlane,
    required this.groundSegments,
    required this.groundGaps,
    required List<StaticSolid> tops,
    required List<StaticSolid> bottoms,
    required List<StaticSolid> leftWalls,
    required List<StaticSolid> rightWalls,
    required double maxTopWidth,
    required double maxBottomWidth,
    required double maxLeftWidth,
    required double maxRightWidth,
  })  : _tops = tops,
        _bottoms = bottoms,
        _leftWalls = leftWalls,
        _rightWalls = rightWalls,
        _maxTopWidth = maxTopWidth,
        _maxBottomWidth = maxBottomWidth,
        _maxLeftWidth = maxLeftWidth,
        _maxRightWidth = maxRightWidth;

  /// Creates a spatial index from the raw static geometry.
  ///
  /// This process involves:
  /// 1. Categorizing solids by their active sides (top, bottom, left, right).
  /// 2. Sorting each list by [minX] to enable binary search.
  /// 3. Computing max widths for each list to optimize overlap queries.
  /// 4. Merging the ground plane and gaps into a unified list of walkable segments.
  factory StaticWorldGeometryIndex.from(StaticWorldGeometry geometry) {
    final tops = <StaticSolid>[];
    final bottoms = <StaticSolid>[];
    final leftWalls = <StaticSolid>[];
    final rightWalls = <StaticSolid>[];

    for (final solid in geometry.solids) {
      final sides = solid.sides;
      if ((sides & StaticSolid.sideTop) != 0) tops.add(solid);
      if ((sides & StaticSolid.sideBottom) != 0) bottoms.add(solid);
      if ((sides & StaticSolid.sideLeft) != 0) leftWalls.add(solid);
      if ((sides & StaticSolid.sideRight) != 0) rightWalls.add(solid);
    }

    // Sort for binary search.
    _sortByMinX(tops);
    _sortByMinX(bottoms);
    _sortByMinX(leftWalls);
    _sortByMinX(rightWalls);

    final groundSegments = _buildGroundSegments(geometry);
    // Ground segments are already sorted by _buildGroundSegments.

    final groundGaps = geometry.groundGaps.isEmpty
        ? const <StaticGroundGap>[]
        : List<StaticGroundGap>.unmodifiable(
            List<StaticGroundGap>.from(geometry.groundGaps),
          );

    return StaticWorldGeometryIndex._(
      geometry: geometry,
      groundPlane: geometry.groundPlane,
      groundSegments: groundSegments,
      groundGaps: groundGaps,
      tops: List<StaticSolid>.unmodifiable(tops),
      bottoms: List<StaticSolid>.unmodifiable(bottoms),
      leftWalls: List<StaticSolid>.unmodifiable(leftWalls),
      rightWalls: List<StaticSolid>.unmodifiable(rightWalls),
      maxTopWidth: _computeMaxWidth(tops),
      maxBottomWidth: _computeMaxWidth(bottoms),
      maxLeftWidth: _computeMaxWidth(leftWalls),
      maxRightWidth: _computeMaxWidth(rightWalls),
    );
  }

  /// Source geometry (unchanged).
  final StaticWorldGeometry geometry;

  /// Optional infinite ground plane.
  final StaticGroundPlane? groundPlane;

  /// Walkable ground segments (used for collision + navigation).
  final List<StaticGroundSegment> groundSegments;

  /// Ground gaps (holes in the ground plane).
  final List<StaticGroundGap> groundGaps;

  /// Solids with an enabled top face.
  final List<StaticSolid> _tops;

  /// Solids with an enabled bottom face (ceilings).
  final List<StaticSolid> _bottoms;

  /// Solids with an enabled left face (walls hit when moving right).
  final List<StaticSolid> _leftWalls;

  /// Solids with an enabled right face (walls hit when moving left).
  final List<StaticSolid> _rightWalls;

  final double _maxTopWidth;
  final double _maxBottomWidth;
  final double _maxLeftWidth;
  final double _maxRightWidth;

  /// Fills [out] with solids overlapping the range [minX, maxX].
  ///
  /// Uses binary search to find potential candidates in O(log N) time.
  void queryTops(double minX, double maxX, List<StaticSolid> out) {
    _query(_tops, minX, maxX, _maxTopWidth, out);
  }

  /// Fills [out] with solids overlapping the range [minX, maxX].
  ///
  /// Uses binary search to find potential candidates in O(log N) time.
  void queryBottoms(double minX, double maxX, List<StaticSolid> out) {
    _query(_bottoms, minX, maxX, _maxBottomWidth, out);
  }

  /// Fills [out] with solids overlapping the range [minX, maxX].
  ///
  /// Uses binary search to find potential candidates in O(log N) time.
  void queryLeftWalls(double minX, double maxX, List<StaticSolid> out) {
    _query(_leftWalls, minX, maxX, _maxLeftWidth, out);
  }

  /// Fills [out] with solids overlapping the range [minX, maxX].
  ///
  /// Uses binary search to find potential candidates in O(log N) time.
  void queryRightWalls(double minX, double maxX, List<StaticSolid> out) {
    _query(_rightWalls, minX, maxX, _maxRightWidth, out);
  }

  /// Fills [out] with ground segments overlapping the range [minX, maxX].
  ///
  /// Ground segments are guaranteed to be sorted and disjoint, allowing efficient
  /// traversal.
  void queryGroundSegments(double minX, double maxX, List<StaticGroundSegment> out) {
    final start = _lowerBoundSegments(groundSegments, minX);
    for (var i = start; i < groundSegments.length; i += 1) {
      final seg = groundSegments[i];
      if (seg.minX >= maxX) break;
      if (seg.maxX > minX) {
        out.add(seg);
      }
    }
  }

  /// Internal helper to query a sorted list of solids.
  ///
  /// [maxWidth] is used to determine the search window. Since the list is sorted
  /// by [minX], a solid can only overlap if its [minX] is within [maxWidth] of
  /// the query's [minX].
  static void _query(
    List<StaticSolid> list,
    double minX,
    double maxX,
    double maxWidth,
    List<StaticSolid> out,
  ) {
    final lowerBoundX = minX - maxWidth;
    final start = _lowerBound(list, lowerBoundX);

    for (var i = start; i < list.length; i += 1) {
      final s = list[i];
      if (s.minX >= maxX) break;
      if (s.maxX > minX) {
        out.add(s);
      }
    }
  }
}

void _sortByMinX(List<StaticSolid> list) {
  list.sort((a, b) => a.minX.compareTo(b.minX));
}

double _computeMaxWidth(List<StaticSolid> list) {
  var maxW = 0.0;
  for (final s in list) {
    final w = s.maxX - s.minX;
    if (w > maxW) maxW = w;
  }
  return maxW;
}

/// Standard binary search (lower bound) for `List<StaticSolid>`.
/// Returns the first index where `list[i].minX >= xValue`.
int _lowerBound(List<StaticSolid> list, double xValue) {
  var min = 0;
  var max = list.length;
  while (min < max) {
    final mid = min + ((max - min) >> 1);
    final element = list[mid];
    if (element.minX < xValue) {
      min = mid + 1;
    } else {
      max = mid;
    }
  }
  return min;
}

/// Specialized search for ground segments.
/// Returns the first index where `list[i].maxX > xValue`.
/// Since ground segments are disjoint, finding where they end relative to the
/// query start is a good entry point.
int _lowerBoundSegments(List<StaticGroundSegment> list, double xValue) {
  var min = 0;
  var max = list.length;
  while (min < max) {
    final mid = min + ((max - min) >> 1);
    if (list[mid].maxX <= xValue) {
      min = mid + 1;
    } else {
      max = mid;
    }
  }
  return min;
}

/// Helper to unify the ground plane and gaps into a single sorted list of
/// walkable segments.
List<StaticGroundSegment> _buildGroundSegments(StaticWorldGeometry geometry) {
  // If segments are already provided (e.g. from a chunk generator), use them.
  if (geometry.groundSegments.isNotEmpty) {
    return List<StaticGroundSegment>.unmodifiable(geometry.groundSegments);
  }

  // If no ground plane exists, there are no segments (void world).
  final groundPlane = geometry.groundPlane;
  if (groundPlane == null) {
    return const <StaticGroundSegment>[];
  }

  // If there are no gaps, the ground is a single infinite plane.
  if (geometry.groundGaps.isEmpty) {
    return List<StaticGroundSegment>.unmodifiable(<StaticGroundSegment>[
      StaticGroundSegment(
        minX: double.negativeInfinity,
        maxX: double.infinity,
        topY: groundPlane.topY,
        chunkIndex: StaticSolid.groundChunk,
        localSegmentIndex: 0,
      ),
    ]);
  }

  // 1. Sort gaps by minX to process them in order.
  final gaps = List<StaticGroundGap>.from(geometry.groundGaps)
    ..sort((a, b) => a.minX.compareTo(b.minX));

  // 2. Merge overlapping or adjacent gaps into fewer, larger gaps.
  final merged = <StaticGroundGap>[];
  for (final gap in gaps) {
    if (merged.isEmpty) {
      merged.add(gap);
      continue;
    }
    final last = merged.last;
    if (gap.minX <= last.maxX) {
      // Overlapping or touching gap. Extend the last gap if needed.
      if (gap.maxX > last.maxX) {
        merged[merged.length - 1] =
            StaticGroundGap(minX: last.minX, maxX: gap.maxX);
      }
    } else {
      // Disjoint gap.
      merged.add(gap);
    }
  }

  // 3. Create segments strictly *between* the merged gaps.
  final segments = <StaticGroundSegment>[];
  var cursor = double.negativeInfinity;
  var localIndex = 0;
  for (final gap in merged) {
    // If there is space between the current cursor (end of last gap) and
    // the start of this gap, create a segment.
    if (gap.minX > cursor) {
      segments.add(
        StaticGroundSegment(
          minX: cursor,
          maxX: gap.minX,
          topY: groundPlane.topY,
          chunkIndex: StaticSolid.groundChunk,
          localSegmentIndex: localIndex,
        ),
      );
      localIndex += 1;
    }
    // Move cursor to the end of this gap.
    cursor = gap.maxX > cursor ? gap.maxX : cursor;
  }

  // 4. Create the final segment from the last gap to infinity.
  if (cursor < double.infinity) {
    segments.add(
      StaticGroundSegment(
        minX: cursor,
        maxX: double.infinity,
        topY: groundPlane.topY,
        chunkIndex: StaticSolid.groundChunk,
        localSegmentIndex: localIndex,
      ),
    );
  }

  return List<StaticGroundSegment>.unmodifiable(segments);
}


===== FILE: lib/core/combat/creature_tag.dart =====
/// Broad classification tags shared across enemies and player variants.
enum CreatureTag {
  humanoid,
  demon,
  flying,
  undead,
}

/// Bitmask constants for [CreatureTag].
class CreatureTagMask {
  const CreatureTagMask._();

  static const int humanoid = 1 << 0;
  static const int demon = 1 << 1;
  static const int flying = 1 << 2;
  static const int undead = 1 << 3;

  static int forTag(CreatureTag tag) {
    switch (tag) {
      case CreatureTag.humanoid:
        return humanoid;
      case CreatureTag.demon:
        return demon;
      case CreatureTag.flying:
        return flying;
      case CreatureTag.undead:
        return undead;
    }
  }
}



===== FILE: lib/core/combat/damage.dart =====
import '../ecs/entity_id.dart';
import '../enemies/enemy_id.dart';
import '../events/game_event.dart';
import '../projectiles/projectile_id.dart';
import '../spells/spell_id.dart';
import 'damage_type.dart';
import 'status/status.dart';

/// Represents a request to apply damage to an entity.
///
/// This structure captures the target, the amount of damage, and comprehensive
/// metadata about the source of the damage (entity, enemy type, projectile, spell)
/// to be used for combat logic, death events, and statistics.
class DamageRequest {
  const DamageRequest({
    required this.target,
    required this.amount,
    this.damageType = DamageType.physical,
    this.statusProfileId = StatusProfileId.none,
    this.source,
    this.sourceKind = DeathSourceKind.unknown,
    this.sourceEnemyId,
    this.sourceProjectileId,
    this.sourceSpellId,
  });

  /// The entity receiving the damage.
  final EntityId target;

  /// The amount of health points to deduct.
  final double amount;

  /// Category used for resistance/vulnerability lookup.
  final DamageType damageType;

  /// Optional status profile to apply on hit.
  final StatusProfileId statusProfileId;

  /// The optional entity responsible for dealing the damage (e.g. the shooter).
  final EntityId? source;

  /// Categorization of the damage source for death messages or analytics.
  final DeathSourceKind sourceKind;

  /// If the dissolved source was an enemy, its static ID.
  final EnemyId? sourceEnemyId;

  /// If the damage came from a projectile, its static ID.
  final ProjectileId? sourceProjectileId;

  /// If the damage came from a spell, its static ID.
  final SpellId? sourceSpellId;
}


===== FILE: lib/core/combat/damage_type.dart =====
/// High-level damage categories for resistance/vulnerability rules.
enum DamageType {
  physical,
  fire,
  ice,
  lightning,
  bleed,
}



===== FILE: lib/core/combat/faction.dart =====
/// Defines the side an entity belongs to in combat.
///
/// Factions determine friend-or-foe relationships for targeting and collision.
enum Faction {
  /// The player and their allies/summons.
  player,

  /// Hostile entities that attack the player.
  enemy
}



===== FILE: lib/core/combat/status/status.dart =====
import '../../ecs/entity_id.dart';
import '../damage_type.dart';

/// Runtime status effect categories.
enum StatusEffectType {
  burn,
  slow,
  bleed,
}

/// Stable identifiers for status application profiles.
enum StatusProfileId {
  none,
  iceBolt,
  meleeBleed,
}

/// A single status application inside a profile.
class StatusApplication {
  const StatusApplication({
    required this.type,
    required this.magnitude,
    required this.durationSeconds,
    this.periodSeconds = 0.0,
    this.scaleByDamageType = false,
  });

  final StatusEffectType type;

  /// Effect strength (percent for slow, damage-per-second for DoT).
  final double magnitude;

  /// Total duration (seconds).
  final double durationSeconds;

  /// Tick period for DoT effects (seconds). Ignored for non-DoTs.
  final double periodSeconds;

  /// Whether to scale magnitude by damage resistance/vulnerability.
  final bool scaleByDamageType;
}

/// A bundle of status applications applied on hit.
class StatusProfile {
  const StatusProfile(this.applications);

  final List<StatusApplication> applications;
}

/// Lookup table for status profiles.
class StatusProfileCatalog {
  const StatusProfileCatalog();

  StatusProfile get(StatusProfileId id) {
    switch (id) {
      case StatusProfileId.none:
        return const StatusProfile(<StatusApplication>[]);
      case StatusProfileId.iceBolt:
        return const StatusProfile(
          <StatusApplication>[
            StatusApplication(
              type: StatusEffectType.slow,
              magnitude: 0.25,
              durationSeconds: 3.0,
              scaleByDamageType: true,
            ),
          ],
        );
      case StatusProfileId.meleeBleed:
        return const StatusProfile(
          <StatusApplication>[
            StatusApplication(
              type: StatusEffectType.bleed,
              magnitude: 3.0,
              durationSeconds: 4.0,
              periodSeconds: 1.0,
            ),
          ],
        );
    }
  }
}

/// Runtime request for applying a status profile to a target.
class StatusRequest {
  const StatusRequest({
    required this.target,
    required this.profileId,
    this.damageType = DamageType.physical,
  });

  final EntityId target;
  final StatusProfileId profileId;
  final DamageType damageType;
}



===== FILE: lib/core/commands/command.dart =====
/// Core input command model for the deterministic simulation.
///
/// Commands represent discrete user inputs scheduled for a specific simulation tick.
/// To ensure determinism, the UI must schedule commands in advance (via `GameController.enqueue`),
/// and the Core processes them only when the simulation clock reaches the specified [tick].
sealed class Command {
  const Command({required this.tick});

  /// Simulation tick at which this command must be applied.
  final int tick;
}

/// Player movement input for the given tick.
///
/// `axis` is typically in `[-1, 1]` (left/right), originating from a joystick.
final class MoveAxisCommand extends Command {
  const MoveAxisCommand({required super.tick, required this.axis});

  /// Horizontal movement axis, usually in `[-1, 1]`.
  final double axis;
}

/// One-shot jump press event for the given tick.
final class JumpPressedCommand extends Command {
  const JumpPressedCommand({required super.tick});
}

/// One-shot dash press event for the given tick.
final class DashPressedCommand extends Command {
  const DashPressedCommand({required super.tick});
}

/// One-shot attack press event for the given tick.
final class AttackPressedCommand extends Command {
  const AttackPressedCommand({required super.tick});
}

/// Continuous projectile aim direction for the given tick.
///
/// The direction should be normalized (or near-normalized). It is expressed in
/// world space and used by casting/abilities.
final class ProjectileAimDirCommand extends Command {
  const ProjectileAimDirCommand({required super.tick, required this.x, required this.y});

  final double x;
  final double y;
}

/// Continuous melee aim direction for the given tick.
///
/// The direction should be normalized (or near-normalized). It is expressed in
/// world space and used by melee attacks.
final class MeleeAimDirCommand extends Command {
  const MeleeAimDirCommand({
    required super.tick,
    required this.x,
    required this.y,
  });

  final double x;
  final double y;
}

/// Clears any held projectile aim direction for the given tick.
///
/// This exists so input schedulers that pre-buffer future ticks can overwrite
/// previously-scheduled aim commands when the player releases aim input.
final class ClearProjectileAimDirCommand extends Command {
  const ClearProjectileAimDirCommand({required super.tick});
}

/// Clears any held melee aim direction for the given tick.
final class ClearMeleeAimDirCommand extends Command {
  const ClearMeleeAimDirCommand({required super.tick});
}

/// Continuous ranged-weapon aim direction for the given tick.
///
/// Used by thrown weapons / bows, and consumed by the ranged weapon intent
/// system (not spells).
final class RangedAimDirCommand extends Command {
  const RangedAimDirCommand({required super.tick, required this.x, required this.y});

  final double x;
  final double y;
}

/// Clears any held ranged-weapon aim direction for the given tick.
final class ClearRangedAimDirCommand extends Command {
  const ClearRangedAimDirCommand({required super.tick});
}

/// One-shot cast press event for the given tick.
final class CastPressedCommand extends Command {
  const CastPressedCommand({required super.tick});
}

/// One-shot ranged weapon press event for the given tick.
final class RangedPressedCommand extends Command {
  const RangedPressedCommand({required super.tick});
}


===== FILE: lib/core/contracts/render_contract.dart =====
/// Defines the virtual resolution and coordinate system constants for the valid
/// gameplay area.
///
/// These values are the "truth" for the simulation and the renderer.
/// The renderer scales this virtual viewport to fit the actual screen.
library;

/// The fixed virtual width of the gameplay view in logic units (pixels).
const int virtualWidth = 600;

/// The fixed virtual height of the gameplay view in logic units (pixels).
const int virtualHeight = 270;

// -- Asset / Layer dimensions --

/// Width of the background/field layer images.
const int fieldLayerImageWidth = 512;

/// Height of the background/field layer images.
const int fieldLayerImageHeight = 256;

/// Vertical offset to align the bottom of the field layer image with the
/// bottom of the virtual viewport.
///
/// `virtualHeight (270) - fieldLayerImageHeight (256) = 14`.
const int fieldLayerBottomAlignedOffsetY =
    virtualHeight - fieldLayerImageHeight; // 14

/// The Y-coordinate within the field layer image where the ground visual
/// starts (opaque top). Based on asset analysis.
/// used to calculate [groundTopY].
const int fieldLayer09OpaqueTopInImageY = 241;

/// The world-space Y coordinate of the ground surface.
///
/// Calculated as `fieldLayerBottomAlignedOffsetY + fieldLayer09OpaqueTopInImageY`.
/// Entities standing on the ground will have their `maxY` at this value.
const int groundTopY =
    fieldLayerBottomAlignedOffsetY + fieldLayer09OpaqueTopInImageY; // 255

/// The fixed Y coordinate for the camera center.
///
/// The camera only scrolls horizontally.
const double cameraFixedY = virtualHeight / 2; // 135.0

// -- Gameplay Constants --

/// Length of the ray cast for projectile aiming.
const double projectileAimRayLength = virtualWidth * 0.5;

/// Length of the ray cast for melee aiming.
const double meleeAimRayLength = virtualWidth * 0.20;


===== FILE: lib/core/ecs/entity_factory.dart =====
import '../combat/faction.dart';
import '../enemies/enemy_id.dart';
import '../snapshots/enums.dart';
import '../util/deterministic_rng.dart';
import 'entity_id.dart';
import 'stores/body_store.dart';
import 'stores/collider_aabb_store.dart';
import 'stores/combat/ammo_store.dart';
import 'stores/combat/creature_tag_store.dart';
import 'stores/combat/damage_resistance_store.dart';
import 'stores/combat/equipped_weapon_store.dart';
import 'stores/combat/equipped_ranged_weapon_store.dart';
import 'stores/combat/stat_modifier_store.dart';
import 'stores/combat/status_immunity_store.dart';
import 'stores/enemies/enemy_store.dart';
import 'stores/faction_store.dart';
import 'stores/enemies/flying_enemy_steering_store.dart';
import 'stores/enemies/ground_enemy_chase_offset_store.dart';
import 'stores/health_store.dart';
import 'stores/mana_store.dart';
import 'stores/stamina_store.dart';
import 'stores/player/action_anim_store.dart';
import 'world.dart';

/// Factory for creating complex entities composed of multiple components.
///
/// This class encapsulates the logic for assembling entities from their constituent
/// components. It ensures that all necessary components are added and initialized
/// correctly for each entity type (e.g., Player, Enemy).
class EntityFactory {
  /// Creates a factory bound to the given [world].
  EntityFactory(this.world);

  /// The [EcsWorld] into which entities will be created.
  final EcsWorld world;

  /// Creates a fully assembled Player entity.
  ///
  /// Adds the following components:
  /// - [TransformStore]: Position and velocity.
  /// - [PlayerInputStore]: Marks this entity as controllable by player input.
  /// - [ActionAnimStore]: Tracks action intent ticks for rendering.
  /// - [MovementStore]: Handles movement logic and facing direction.
  /// - [BodyStore]: Physics body properties (mass, friction, etc.).
  /// - [ColliderAabbStore]: Axis-aligned bounding box for collision detection.
  /// - [CollisionStateStore]: Tracks current collision state.
  /// - [CooldownStore]: Manages ability cooldowns.
  /// - [CastIntentStore]: Tracks intent to cast spells.
  /// - [CreatureTagStore]: Broad combat classification tags.
  /// - [FactionStore]: Sets the faction to [Faction.player].
  /// - [HealthStore]: Health points and max health.
  /// - [DamageResistanceStore]: Damage modifiers per type.
  /// - [InvulnerabilityStore]: Grants temporary invulnerability after damage.
  /// - [LastDamageStore]: Tracks the last source of damage for UI/effects.
  /// - [StatusImmunityStore]: Status effect immunities.
  /// - [ManaStore]: Mana points and max mana.
  /// - [MeleeIntentStore]: Tracks intent to perform melee attacks.
  /// - [StatModifierStore]: Runtime stat modifiers from statuses.
  /// - [StaminaStore]: Stamina points and max stamina.
  ///
  /// The [grounded] parameter sets the initial ground state in the collision store.
  EntityId createPlayer({
    required double posX,
    required double posY,
    required double velX,
    required double velY,
    required Facing facing,
    required bool grounded,
    required BodyDef body,
    required ColliderAabbDef collider,
    required HealthDef health,
    required ManaDef mana,
    required StaminaDef stamina,
    CreatureTagDef tags = const CreatureTagDef(),
    DamageResistanceDef resistance = const DamageResistanceDef(),
    StatusImmunityDef statusImmunity = const StatusImmunityDef(),
    EquippedWeaponDef equippedWeapon = const EquippedWeaponDef(),
    EquippedRangedWeaponDef equippedRangedWeapon =
        const EquippedRangedWeaponDef(),
    AmmoDef ammo = const AmmoDef(),
  }) {
    final id = world.createEntity();
    world.transform.add(id, posX: posX, posY: posY, velX: velX, velY: velY);
    world.playerInput.add(id);
    world.actionAnim.add(id);
    world.movement.add(id, facing: facing);
    world.body.add(id, body);
    world.colliderAabb.add(id, collider);
    world.collision.add(id);
    world.cooldown.add(id);
    world.castIntent.add(id);
    world.creatureTag.add(id, tags);
    world.faction.add(id, const FactionDef(faction: Faction.player));
    world.health.add(id, health);
    world.damageResistance.add(id, resistance);
    world.invulnerability.add(id);
    world.lastDamage.add(id);
    world.statusImmunity.add(id, statusImmunity);
    world.mana.add(id, mana);
    world.meleeIntent.add(id);
    world.rangedWeaponIntent.add(id);
    world.ammo.add(id, ammo);
    world.equippedWeapon.add(id, equippedWeapon);
    world.equippedRangedWeapon.add(id, equippedRangedWeapon);
    world.statModifier.add(id);
    world.stamina.add(id, stamina);
    world.collision.grounded[world.collision.indexOf(id)] = grounded;
    return id;
  }

  /// Creates an Enemy entity based on the provided [enemyId].
  ///
  /// Adds common components for all enemies:
  /// - [TransformStore]: Position and velocity.
  /// - [BodyStore]: Physics properties.
  /// - [ColliderAabbStore]: Collision boounding box.
  /// - [CollisionStateStore]: Collision state tracking.
  /// - [CooldownStore]: Ability cooldowns.
  /// - [CastIntentStore]: Spell casting intent.
  /// - [CreatureTagStore]: Broad combat classification tags.
  /// - [FactionStore]: Sets faction to [Faction.enemy].
  /// - [HealthStore], [ManaStore], [StaminaStore]: Vital stats.
  /// - [MeleeIntentStore]: Melee attack intent.
  /// - [DamageResistanceStore]: Damage modifiers per type.
  /// - [StatusImmunityStore]: Status effect immunities.
  /// - [StatModifierStore]: Runtime stat modifiers from statuses.
  /// - [EnemyStore]: Identifies the entity as an enemy and stores its type.
  ///
  /// Adds specific components based on [enemyId]:
  /// - [EnemyId.unocoDemon]: Adds [FlyingEnemySteeringStore] for air movement.
  /// - [EnemyId.groundEnemy]: Adds [SurfaceNavStateStore] and [GroundEnemyChaseOffsetStore]
  ///   for ground-based navigation and chasing behavior.
  EntityId createEnemy({
    required EnemyId enemyId,
    required double posX,
    required double posY,
    required double velX,
    required double velY,
    required Facing facing,
    required BodyDef body,
    required ColliderAabbDef collider,
    required HealthDef health,
    required ManaDef mana,
    required StaminaDef stamina,
    CreatureTagDef tags = const CreatureTagDef(),
    DamageResistanceDef resistance = const DamageResistanceDef(),
    StatusImmunityDef statusImmunity = const StatusImmunityDef(),
  }) {
    final id = world.createEntity();
    world.transform.add(id, posX: posX, posY: posY, velX: velX, velY: velY);
    world.body.add(id, body);
    world.colliderAabb.add(id, collider);
    world.collision.add(id);
    world.cooldown.add(id);
    world.castIntent.add(id);
    world.creatureTag.add(id, tags);
    world.faction.add(id, const FactionDef(faction: Faction.enemy));
    world.health.add(id, health);
    world.damageResistance.add(id, resistance);
    world.mana.add(id, mana);
    world.meleeIntent.add(id);
    world.statModifier.add(id);
    world.stamina.add(id, stamina);
    world.enemy.add(id, EnemyDef(enemyId: enemyId, facing: facing));
    world.statusImmunity.add(id, statusImmunity);
    if (enemyId == EnemyId.unocoDemon) {
      world.flyingEnemySteering.add(
        id,
        FlyingEnemySteeringDef(rngState: seedFrom(world.seed, id)),
      );
    }
    if (enemyId == EnemyId.groundEnemy) {
      world.surfaceNav.add(id);
      world.groundEnemyChaseOffset.add(
        id,
        GroundEnemyChaseOffsetDef(rngState: seedFrom(world.seed, id)),
      );
    }
    return id;
  }
}


===== FILE: lib/core/ecs/entity_id.dart =====
/// Opaque identifier for entities in the Core simulation.
///
/// An [EntityId] is a simple integer that uniquely identifies an entity within
/// the [EcsWorld]. It serves as a key to access components associated with
/// the entity across different [SparseSet] stores.
///
/// Entity IDs are managed by the [EcsWorld]. When an entity is destroyed, its
/// ID is recycled and may be assigned to a new entity in the future to keep the
/// range of active IDs compact, which benefits the performance of sparse sets.
typedef EntityId = int;


===== FILE: lib/core/ecs/hit/aabb_hit_utils.dart =====
import '../../combat/faction.dart';
import '../entity_id.dart';
import '../world.dart';

/// Shared helpers for hit resolution math + filtering.
///
/// IMPORTANT:
/// - Keep these helpers allocation-free and deterministic.
/// - Systems still own iteration/selection rules (e.g. "first hit wins") until
///   Hit Resolution Module is fully unified.

/// Checks if two factions are allied.
///
/// Used for friendly-fire logic (skipping hits on allies).
bool areAllies(Faction a, Faction b) => a == b;

/// Per-tick cache of "damageable collider targets" to reduce repeated sparse
/// lookups in hot loops.
///
/// A target is included if it has:
/// - `HealthStore` (source list)
/// - `FactionStore` (for friendly-fire filtering)
/// - `TransformStore` + `ColliderAabbStore` (for overlap tests)
///
/// Determinism: preserves `HealthStore.denseEntities` iteration order.
class DamageableTargetCache {
  /// The [EntityId] of the target.
  final List<EntityId> entities = <EntityId>[];
  /// The [Faction] of the target.
  final List<Faction> factions = <Faction>[];

  // World-space collider center and half extents (Parallel arrays).
  final List<double> centerX = <double>[];
  final List<double> centerY = <double>[];
  final List<double> halfX = <double>[];
  final List<double> halfY = <double>[];

  int get length => entities.length;
  bool get isEmpty => entities.isEmpty;

  /// Rebuilds the cache by iterating directly over all entities with Health.
  ///
  /// This is an O(N) operation where N is the number of entities with Health,
  /// but it avoids O(log N) or hashing costs during the hot hit-check loop.
  void rebuild(EcsWorld world) {
    // 1. Reset state.
    entities.clear();
    factions.clear();
    centerX.clear();
    centerY.clear();
    halfX.clear();
    halfY.clear();

    final health = world.health;
    if (health.denseEntities.isEmpty) return;

    // 2. Iterate source (HealthStore) to find potential targets.
    for (var i = 0; i < health.denseEntities.length; i += 1) {
      final e = health.denseEntities[i];

      // 3. Filter: Must have Faction, Transform, and Collider.
      // (Using tryIndexOf avoids exception overhead for missing components)
      final fi = world.faction.tryIndexOf(e);
      if (fi == null) continue;
      final ti = world.transform.tryIndexOf(e);
      if (ti == null) continue;
      final aabbi = world.colliderAabb.tryIndexOf(e);
      if (aabbi == null) continue;

      // 4. Pre-calculate world-space AABB to save work during hit tests.
      // (Transform Pos + Collider Offset)
      final cx = world.transform.posX[ti] + world.colliderAabb.offsetX[aabbi];
      final cy = world.transform.posY[ti] + world.colliderAabb.offsetY[aabbi];

      // 5. Commit valid target to cache.
      entities.add(e);
      factions.add(world.faction.faction[fi]);
      centerX.add(cx);
      centerY.add(cy);
      halfX.add(world.colliderAabb.halfX[aabbi]);
      halfY.add(world.colliderAabb.halfY[aabbi]);
    }
  }
}

/// Checks strict overlap between two AABBs defined by Min/Max coordinates.
///
/// Returns true if they overlap. Touching edges does NOT count as overlap.
bool aabbOverlapsMinMax({
  required double aMinX,
  required double aMaxX,
  required double aMinY,
  required double aMaxY,
  required double bMinX,
  required double bMaxX,
  required double bMinY,
  required double bMaxY,
}) {
  // Classic Separating Axis Theorem (SAT):
  // Overlap exists if and only if ranges overlap on BOTH X and Y axes.
  // (Start of A < End of B) AND (End of A > Start of B)
  return aMinX < bMaxX && aMaxX > bMinX && aMinY < bMaxY && aMaxY > bMinY;
}

/// Checks strict overlap between two AABBs defined by Center/Half-Extents.
bool aabbOverlapsCenters({
  required double aCenterX,
  required double aCenterY,
  required double aHalfX,
  required double aHalfY,
  required double bCenterX,
  required double bCenterY,
  required double bHalfX,
  required double bHalfY,
}) {
  return aabbOverlapsMinMax(
    aMinX: aCenterX - aHalfX,
    aMaxX: aCenterX + aHalfX,
    aMinY: aCenterY - aHalfY,
    aMaxY: aCenterY + aHalfY,
    bMinX: bCenterX - bHalfX,
    bMaxX: bCenterX + bHalfX,
    bMinY: bCenterY - bHalfY,
    bMaxY: bCenterY + bHalfY,
  );
}

/// Helper that resolves entity indices to world components and checks overlap.
bool aabbOverlapsWorldColliders(
  EcsWorld world, {
  required int aTransformIndex,
  required int aAabbIndex,
  required int bTransformIndex,
  required int bAabbIndex,
}) {
  // 1. Resolve world-space AABB for Entity A.
  final aCenterX = world.transform.posX[aTransformIndex] +
      world.colliderAabb.offsetX[aAabbIndex];
  final aCenterY = world.transform.posY[aTransformIndex] +
      world.colliderAabb.offsetY[aAabbIndex];
  final aHalfX = world.colliderAabb.halfX[aAabbIndex];
  final aHalfY = world.colliderAabb.halfY[aAabbIndex];

  // 2. Resolve world-space AABB for Entity B.
  final bCenterX = world.transform.posX[bTransformIndex] +
      world.colliderAabb.offsetX[bAabbIndex];
  final bCenterY = world.transform.posY[bTransformIndex] +
      world.colliderAabb.offsetY[bAabbIndex];
  final bHalfX = world.colliderAabb.halfX[bAabbIndex];
  final bHalfY = world.colliderAabb.halfY[bAabbIndex];

  // 3. Check overlap.
  return aabbOverlapsCenters(
    aCenterX: aCenterX,
    aCenterY: aCenterY,
    aHalfX: aHalfX,
    aHalfY: aHalfY,
    bCenterX: bCenterX,
    bCenterY: bCenterY,
    bHalfX: bHalfX,
    bHalfY: bHalfY,
  );
}


===== FILE: lib/core/ecs/hit/capsule_hit_utils.dart =====
import 'dart:math' as math;

const double _segmentEps = 1e-12;

/// Checks if a capsule (line segment + radius) intersects an Axis-Aligned Bounding Box (AABB).
///
/// The capsule is defined by start point ([ax], [ay]), end point ([bx], [by]),
/// and [radius]. The AABB is defined by min/max coordinates.
///
/// This works by padding the AABB by the capsule radius and performing a segment-to-box
/// intersection test.
bool capsuleIntersectsAabb({
  required double ax,
  required double ay,
  required double bx,
  required double by,
  required double radius,
  required double minX,
  required double minY,
  required double maxX,
  required double maxY,
}) {
  final r = radius < 0 ? 0.0 : radius;
  // Expanding the AABB by the radius allows us to treat the capsule as a simple
  // line segment against the larger box.
  return _segmentIntersectsAabb(
    ax: ax,
    ay: ay,
    bx: bx,
    by: by,
    minX: minX - r,
    minY: minY - r,
    maxX: maxX + r,
    maxY: maxY + r,
  );
}

/// Core segment-AABB intersection test using slab method logic.
///
/// Checks if the line segment from A to B intersects the given AABB.
bool _segmentIntersectsAabb({
  required double ax,
  required double ay,
  required double bx,
  required double by,
  required double minX,
  required double minY,
  required double maxX,
  required double maxY,
}) {
  final dx = bx - ax;
  final dy = by - ay;
  var t0 = 0.0;
  var t1 = 1.0;

  // --- X-axis slab test ---
  if (dx.abs() < _segmentEps) {
    // Segment is parallel to Y-axis. If X is outside, no intersection.
    if (ax < minX || ax > maxX) return false;
  } else {
    // Compute intersection times (t) with X-planes.
    final inv = 1.0 / dx;
    var tNear = (minX - ax) * inv;
    var tFar = (maxX - ax) * inv;
    if (tNear > tFar) {
      final tmp = tNear;
      tNear = tFar;
      tFar = tmp;
    }
    // Narrow the valid segment range [t0, t1].
    t0 = math.max(t0, tNear);
    t1 = math.min(t1, tFar);
    // If range becomes invalid, segment missed.
    if (t0 > t1) return false;
  }

  // --- Y-axis slab test ---
  if (dy.abs() < _segmentEps) {
    // Segment is parallel to X-axis. If Y is outside, no intersection.
    if (ay < minY || ay > maxY) return false;
  } else {
    // Compute intersection times (t) with Y-planes.
    final inv = 1.0 / dy;
    var tNear = (minY - ay) * inv;
    var tFar = (maxY - ay) * inv;
    if (tNear > tFar) {
      final tmp = tNear;
      tNear = tFar;
      tFar = tmp;
    }
    // Further narrow the valid segment range.
    t0 = math.max(t0, tNear);
    t1 = math.min(t1, tFar);
    // If range becomes invalid, segment missed.
    if (t0 > t1) return false;
  }

  // Intersection confirmed if we survived both slab tests.
  return true;
}


===== FILE: lib/core/ecs/hit/hit_resolver.dart =====
import 'dart:math' as math;

import '../../combat/faction.dart';
import '../entity_id.dart';
import '../spatial/broadphase_grid.dart';
import 'aabb_hit_utils.dart';
import 'capsule_hit_utils.dart';

/// Shared narrowphase + deterministic hit candidate ordering.
///
/// Responsibilities:
/// - broadphase query
/// - filtering (owner exclusion + friendly-fire)
/// - AABB overlap test
/// - deterministic ordering (EntityId ascending)
///
/// Non-responsibilities:
/// - world mutation (damage, despawns, HitOnce marking)
class HitResolver {
  // Temporary list to hold candidates from the broadphase before processing.
  final List<int> _candidates = <int>[];

  /// Collects ALL entities intersecting the given AABB into [outTargetIndices].
  ///
  /// The results are filtered strictly (overlaps only) and loosely (owner/friendly fire),
  /// and are guaranteed to be sorted by [EntityId].
  void collectOrderedOverlapsCenters({
    required BroadphaseGrid broadphase,
    required double centerX,
    required double centerY,
    required double halfX,
    required double halfY,
    required EntityId owner,
    required Faction sourceFaction,
    required List<int> outTargetIndices,
  }) {
    outTargetIndices.clear();

    // 1. Broadphase Query + deterministic sort.
    final hasCandidates = _prepareCandidates(
      broadphase: broadphase,
      minX: centerX - halfX,
      minY: centerY - halfY,
      maxX: centerX + halfX,
      maxY: centerY + halfY,
    );
    if (!hasCandidates) return;

    // 2. Narrowphase Check on processed candidates.
    for (var i = 0; i < _candidates.length; i += 1) {
      final targetIndex = _candidates[i];

      // 2a. Filter logic (Owner + Faction).
      if (!_isValidTarget(targetIndex, broadphase, owner, sourceFaction)) {
        continue;
      }

      // 2b. Exact AABB overlap test.
      if (!aabbOverlapsCenters(
        aCenterX: centerX,
        aCenterY: centerY,
        aHalfX: halfX,
        aHalfY: halfY,
        bCenterX: broadphase.targets.centerX[targetIndex],
        bCenterY: broadphase.targets.centerY[targetIndex],
        bHalfX: broadphase.targets.halfX[targetIndex],
        bHalfY: broadphase.targets.halfY[targetIndex],
      )) {
        continue;
      }

      // 3. Collect valid hit.
      outTargetIndices.add(targetIndex);
    }
  }

  /// Returns the FIRST entity intersecting the given AABB (lowest EntityId).
  int? firstOrderedOverlapCenters({
    required BroadphaseGrid broadphase,
    required double centerX,
    required double centerY,
    required double halfX,
    required double halfY,
    required EntityId owner,
    required Faction sourceFaction,
  }) {
    // 1. Broadphase Query.
    final hasCandidates = _prepareCandidates(
      broadphase: broadphase,
      minX: centerX - halfX,
      minY: centerY - halfY,
      maxX: centerX + halfX,
      maxY: centerY + halfY,
    );
    if (!hasCandidates) return null;

    // 2. Determine the first valid hit.
    for (var i = 0; i < _candidates.length; i += 1) {
      final targetIndex = _candidates[i];

      // 2a. Filter logic.
      if (!_isValidTarget(targetIndex, broadphase, owner, sourceFaction)) {
        continue;
      }

      // 2b. Exact AABB overlap test.
      if (!aabbOverlapsCenters(
        aCenterX: centerX,
        aCenterY: centerY,
        aHalfX: halfX,
        aHalfY: halfY,
        bCenterX: broadphase.targets.centerX[targetIndex],
        bCenterY: broadphase.targets.centerY[targetIndex],
        bHalfX: broadphase.targets.halfX[targetIndex],
        bHalfY: broadphase.targets.halfY[targetIndex],
      )) {
        continue;
      }

      // 3. Return immediately on first hit (Sorted by EntityId).
      return targetIndex;
    }

    return null;
  }

  /// Collects ALL entities intersecting the given capsule into [outTargetIndices].
  void collectOrderedOverlapsCapsule({
    required BroadphaseGrid broadphase,
    required double ax,
    required double ay,
    required double bx,
    required double by,
    required double radius,
    required EntityId owner,
    required Faction sourceFaction,
    required List<int> outTargetIndices,
  }) {
    outTargetIndices.clear();

    // 1. Broadphase Query using capsule AABB bounds.
    final hasCandidates = _prepareCandidates(
      broadphase: broadphase,
      minX: math.min(ax, bx) - radius,
      minY: math.min(ay, by) - radius,
      maxX: math.max(ax, bx) + radius,
      maxY: math.max(ay, by) + radius,
    );
    if (!hasCandidates) return;

    // 2. Narrowphase Check.
    for (var i = 0; i < _candidates.length; i += 1) {
      final targetIndex = _candidates[i];

      // 2a. Filter logic.
      if (!_isValidTarget(targetIndex, broadphase, owner, sourceFaction)) {
        continue;
      }

      final targetCenterX = broadphase.targets.centerX[targetIndex];
      final targetCenterY = broadphase.targets.centerY[targetIndex];
      final targetHalfX = broadphase.targets.halfX[targetIndex];
      final targetHalfY = broadphase.targets.halfY[targetIndex];

      // 2b. Capsule vs AABB intersection test.
      if (!capsuleIntersectsAabb(
        ax: ax,
        ay: ay,
        bx: bx,
        by: by,
        radius: radius,
        minX: targetCenterX - targetHalfX,
        minY: targetCenterY - targetHalfY,
        maxX: targetCenterX + targetHalfX,
        maxY: targetCenterY + targetHalfY,
      )) {
        continue;
      }

      // 3. Collect valid hit.
      outTargetIndices.add(targetIndex);
    }
  }

  /// Returns the FIRST entity intersecting the given capsule (lowest EntityId).
  int? firstOrderedOverlapCapsule({
    required BroadphaseGrid broadphase,
    required double ax,
    required double ay,
    required double bx,
    required double by,
    required double radius,
    required EntityId owner,
    required Faction sourceFaction,
  }) {
    // 1. Broadphase Query.
    final hasCandidates = _prepareCandidates(
      broadphase: broadphase,
      minX: math.min(ax, bx) - radius,
      minY: math.min(ay, by) - radius,
      maxX: math.max(ax, bx) + radius,
      maxY: math.max(ay, by) + radius,
    );
    if (!hasCandidates) return null;

    // 2. Determine the first valid hit.
    for (var i = 0; i < _candidates.length; i += 1) {
      final targetIndex = _candidates[i];

      // 2a. Filter logic.
      if (!_isValidTarget(targetIndex, broadphase, owner, sourceFaction)) {
        continue;
      }

      final targetCenterX = broadphase.targets.centerX[targetIndex];
      final targetCenterY = broadphase.targets.centerY[targetIndex];
      final targetHalfX = broadphase.targets.halfX[targetIndex];
      final targetHalfY = broadphase.targets.halfY[targetIndex];

      // 2b. Capsule vs AABB intersection test.
      if (!capsuleIntersectsAabb(
        ax: ax,
        ay: ay,
        bx: bx,
        by: by,
        radius: radius,
        minX: targetCenterX - targetHalfX,
        minY: targetCenterY - targetHalfY,
        maxX: targetCenterX + targetHalfX,
        maxY: targetCenterY + targetHalfY,
      )) {
        continue;
      }

      // 3. Return immediately on first hit.
      return targetIndex;
    }

    return null;
  }

  /// Helper: Runs broadphase query and sorts results by EntityId.
  ///
  /// Returns `false` if no candidates were found.
  bool _prepareCandidates({
    required BroadphaseGrid broadphase,
    required double minX,
    required double minY,
    required double maxX,
    required double maxY,
  }) {
    // 1. Get raw cell-based candidates (contains duplicates if spanning cells).
    broadphase.queryAabbMinMax(
      minX: minX,
      minY: minY,
      maxX: maxX,
      maxY: maxY,
      outTargetIndices: _candidates,
    );
    if (_candidates.isEmpty) return false;

    // 2. Sort by EntityId to ensure deterministic order (1, 2, 3...)
    // regardless of cell iteration order.
    _sortCandidatesByEntityId(broadphase);
    return true;
  }

  /// Helper: Checks non-geometric filtering rules.
  ///
  /// - Excludes [owner] (can't hit self).
  /// - Excludes allies of [sourceFaction] (friendly fire).
  bool _isValidTarget(
    int targetIndex,
    BroadphaseGrid broadphase,
    EntityId owner,
    Faction sourceFaction,
  ) {
    final target = broadphase.targets.entities[targetIndex];
    if (target == owner) return false;

    return !areAllies(
      sourceFaction,
      broadphase.targets.factions[targetIndex],
    );
  }

  void _sortCandidatesByEntityId(BroadphaseGrid broadphase) {
    _candidates.sort(
      (a, b) => broadphase.targets.entities[a].compareTo(
        broadphase.targets.entities[b],
      ),
    );
  }
}


===== FILE: lib/core/ecs/queries.dart =====
import 'entity_id.dart';
import 'world.dart';

/// Callback signature for iterating over entities with movement-related components.
///
/// [e] is the Entity ID.
/// [mi], [ti], [ii], [bi], [ci], [si] are the **dense indices** for:
/// - [mi]: MovementStore
/// - [ti]: TransformStore
/// - [ii]: PlayerInputStore
/// - [bi]: BodyStore
/// - [ci]: CollisionStateStore
/// - [si]: StaminaStore
typedef MovementQueryFn =
    void Function(EntityId e, int mi, int ti, int ii, int bi, int ci, int si);

/// Callback signature for iterating over entities with collision-related components.
///
/// [e] is the Entity ID.
/// [ti], [bi], [coli], [aabbi] are the **dense indices** for:
/// - [ti]: TransformStore
/// - [bi]: BodyStore
/// - [coli]: CollisionStateStore
/// - [aabbi]: ColliderAabbStore
typedef ColliderQueryFn =
    void Function(EntityId e, int ti, int bi, int coli, int aabbi);

/// Provides optimized iteration methods for groups of components used in common systems.
///
/// These static methods perform "joins" across multiple component stores. They iterate
/// efficiently by driving the loop with the "primary" store (usually the one expected
/// to have the fewest entities or the one we want to iterate linearly) and checking
/// for the presence of other required components.
class EcsQueries {
  /// Iterates over all entities that have [MovementStore], [TransformStore],
  /// [PlayerInputStore], [BodyStore], [CollisionStateStore], and [StaminaStore].
  ///
  /// This query is typically used by the [MovementSystem] to process player movement.
  /// It effectively filters for "controllable physics bodies".
  static void forMovementBodies(EcsWorld world, MovementQueryFn fn) {
    // We drive iteration with the MovementStore.
    final movement = world.movement;
    final entities = movement.denseEntities;

    for (var mi = 0; mi < entities.length; mi += 1) {
      final e = entities[mi];

      // Check existence and get indices for all other required components.
      final ti = world.transform.tryIndexOf(e);
      if (ti == null) continue;
      final ii = world.playerInput.tryIndexOf(e);
      if (ii == null) continue;
      final bi = world.body.tryIndexOf(e);
      if (bi == null) continue;
      final ci = world.collision.tryIndexOf(e);
      if (ci == null) continue;
      final si = world.stamina.tryIndexOf(e);
      if (si == null) continue;

      fn(e, mi, ti, ii, bi, ci, si);
    }
  }

  /// Iterates over all entities that have [ColliderAabbStore], [TransformStore],
  /// [BodyStore], and [CollisionStateStore].
  ///
  /// This query finds all physical objects that can collide. It is used by the
  /// [CollisionSystem] to resolve physics interactions.
  static void forColliders(EcsWorld world, ColliderQueryFn fn) {
    // Drive iteration with the ColliderAabbStore.
    final aabb = world.colliderAabb;
    final entities = aabb.denseEntities;

    for (var aabbi = 0; aabbi < entities.length; aabbi += 1) {
      final e = entities[aabbi];

      final ti = world.transform.tryIndexOf(e);
      if (ti == null) continue;
      final bi = world.body.tryIndexOf(e);
      if (bi == null) continue;
      final coli = world.collision.tryIndexOf(e);
      if (coli == null) continue;

      fn(e, ti, bi, coli, aabbi);
    }
  }
}


===== FILE: lib/core/ecs/sparse_set.dart =====
import 'entity_id.dart';

/// Base sparse-set bookkeeping for component stores.
///
/// A sparse set is a data structure that efficiently maps a potentially sparse range
/// of integers (the entity IDs) to a dense, contiguous array of data.
///
/// Internally, it maintains two lists:
/// - `_sparse`: An array indexed by [EntityId]. `_sparse[entity]` stores the
///   index into `denseEntities` plus 1 (0 indicates the entity is not present).
/// - `denseEntities`: A list of [EntityId]s packed contiguously. This allows for
///   fast iteration over all entities that possess this component.
///
/// Subclasses (Component Stores) will maintain their own component data in parallel
/// arrays, also indexed by the values stored in `_sparse` (the "dense index").
///
/// Capabilities:
/// - O(1) membership check (`has`).
/// - O(1) lookup of component data index (`indexOf`).
/// - O(1) insertion (`addEntity`).
/// - O(1) removal (`removeEntity`) using the "swap-and-pop" technique.
/// - Cache-friendly iteration over `denseEntities`.
abstract class SparseSet {
  /// The list of entities that have this component, packed densely.
  /// Iterating this list is the standard way to process all components of this type.
  final List<EntityId> denseEntities = <EntityId>[];

  /// The sparse array mapping EntityId to (denseIndex + 1).
  /// A value of 0 means the entity does not have this component.
  final List<int> _sparse = <int>[];

  /// Returns true if [entity] has this component.
  bool has(EntityId entity) {
    if (entity < 0) return false;
    if (entity >= _sparse.length) return false;
    return _sparse[entity] != 0;
  }

  /// Returns the dense index for [entity].
  ///
  /// Throws if the entity does not have this component. Use [has] or [tryIndexOf] to check.
  int indexOf(EntityId entity) {
    final idxPlus1 = _sparse[entity];
    return idxPlus1 - 1;
  }

  /// Returns the dense index for [entity], or null if it doesn't have this component.
  int? tryIndexOf(EntityId entity) {
    if (entity < 0 || entity >= _sparse.length) return null;
    final idxPlus1 = _sparse[entity];
    if (idxPlus1 == 0) return null;
    return idxPlus1 - 1;
  }

  /// Ensures the internal sparse array is large enough to hold [entity].
  void ensureCapacity(EntityId entity) {
    if (entity < _sparse.length) return;
    final toAdd = entity + 1 - _sparse.length;
    if (toAdd <= 0) return;
    _sparse.addAll(List<int>.filled(toAdd, 0));
  }

  /// Registers [entity] with this store.
  ///
  /// Returns the new stable dense index for this entity's component data.
  /// If the entity is already present, returns its existing dense index.
  ///
  /// Subclasses should call this first, then add their data to their parallel arrays.
  int addEntity(EntityId entity) {
    ensureCapacity(entity);
    final existing = _sparse[entity];
    if (existing != 0) return existing - 1;

    final denseIndex = denseEntities.length;
    denseEntities.add(entity);
    _sparse[entity] = denseIndex + 1;
    onDenseAdded(denseIndex);
    return denseIndex;
  }

  /// Removes [entity] from this store.
  ///
  /// Uses "swap-and-pop" to remove in O(1):
  /// 1. The component data for the entity to be removed is swapped with the
  ///    last component in the dense arrays.
  /// 2. The mapping in `_sparse` for the swapped entity is updated.
  /// 3. The last element is removed (popped).
  ///
  /// This operation changes the dense index of the entity that was at the end.
  void removeEntity(EntityId entity) {
    if (!has(entity)) return;

    final removeIndex = indexOf(entity);
    final lastIndex = denseEntities.length - 1;

    // Hook for subclasses to swap their data arrays before we modify indices.
    onSwapRemove(removeIndex, lastIndex);

    final lastEntity = denseEntities[lastIndex];
    denseEntities[removeIndex] = lastEntity;
    denseEntities.removeLast();

    _sparse[entity] = 0;
    if (removeIndex != lastIndex) {
      // Update the sparse map for the entity that was moved into the empty slot.
      _sparse[lastEntity] = removeIndex + 1;
    }
  }

  /// Called after a new dense slot has been appended.
  /// Subclasses should rely on this to know when a valid index has been established,
  /// though usually they just push data to their lists.
  void onDenseAdded(int denseIndex);

  /// Called before dense arrays are swap-removed from [removeIndex] and [lastIndex].
  ///
  /// Subclasses MUST perform the swap on their parallel data lists inside this method:
  /// `dataList[removeIndex] = dataList[lastIndex]; dataList.removeLast();`
  void onSwapRemove(int removeIndex, int lastIndex);
}


===== FILE: lib/core/ecs/spatial/broadphase_grid.dart =====
import '../hit/aabb_hit_utils.dart';
import '../world.dart';
import 'grid_index_2d.dart';

/// Deterministic broadphase grid rebuilt each tick from dynamic damageable AABBs.
///
/// This grid implementation uses spatial hashing to bucket entities into cells.
/// AABBs that overlap multiple cells are added to all corresponding buckets.
///
/// **Memory Strategy**:
/// - [targets]: Rebuilt every frame to store flat arrays of AABB components.
/// - [_buckets]: Map of cell keys to lists of target indices. Keys are removed
///   when buckets become empty to keep the map size bounded to the visible/active
///   world (vital for infinite runners).
/// - [_bucketPool]: Reuses `List<int>` instances to avoid allocation churn.
/// - [_seenStampByTargetIndex]: Used for O(1) deduplication during queries (avoiding `Set`).
///
/// **Determinism**:
/// - The grid structure itself is order-independent for population.
/// - [queryAabbMinMax] iterates cells in a strict (Y then X) order.
/// - Note: The order of indices *within* a bucket is insertion order (index order in [targets]).
///   Since [targets] is rebuilt by iterating the [EcsWorld], this order depends on
///   Entity ID iteration order.
class BroadphaseGrid {
  BroadphaseGrid({required GridIndex2D index}) : _index = index;

  /// Helper for grid math (coordinate conversion, key packing).
  final GridIndex2D _index;

  /// Stores component data for all damageable entities in the current frame.
  /// Rebuilt at the start of `rebuild()`.
  final DamageableTargetCache targets = DamageableTargetCache();

  // cellKey -> list of target indices into `targets`.
  final Map<int, List<int>> _buckets = <int, List<int>>{};
  // Tracks keys currently in `_buckets` to allow fast iteration/clearing without
  // scanning the whole map (if it were sparse/large).
  final List<int> _activeKeys = <int>[];
  // Pool of lists to avoid allocating new Lists every frame.
  final List<List<int>> _bucketPool = <List<int>>[];

  // Per-query dedup for targets that span multiple cells.
  // We use a "timestamp" strategy: each query increments `_stamp`.
  // If `seen[target] == _stamp`, we've already added it this query.
  final List<int> _seenStampByTargetIndex = <int>[];
  int _stamp = 0;

  /// Rebuilds the spatial grid from the current state of [world].
  ///
  /// This must be called once per tick before any queries are performed.
  void rebuild(EcsWorld world) {
    targets.rebuild(world);

    // clear() old buckets and return lists to the pool.
    // We remove keys from the map to keep the map size small (only active cells).
    for (var i = 0; i < _activeKeys.length; i += 1) {
      final key = _activeKeys[i];
      final bucket = _buckets.remove(key);
      if (bucket == null) continue;
      bucket.clear();
      _bucketPool.add(bucket);
    }
    _activeKeys.clear();

    if (targets.isEmpty) return;

    // Populate buckets.
    for (var ti = 0; ti < targets.length; ti += 1) {
      final cx = targets.centerX[ti];
      final cy = targets.centerY[ti];
      final hx = targets.halfX[ti];
      final hy = targets.halfY[ti];

      // Calculate AABB min/max in world space.
      final minX = cx - hx;
      final maxX = cx + hx;
      final minY = cy - hy;
      final maxY = cy + hy;

      // Convert world AABB to cell index range (inclusive).
      final minCx = _index.worldToCellX(minX);
      final maxCx = _index.worldToCellX(maxX);
      final minCy = _index.worldToCellY(minY);
      final maxCy = _index.worldToCellY(maxY);

      // Add target to every cell its AABB overlaps.
      // This handles "large" entities that span multiple grid cells.
      for (var cellY = minCy; cellY <= maxCy; cellY += 1) {
        for (var cellX = minCx; cellX <= maxCx; cellX += 1) {
          final key = _index.cellKey(cellX, cellY);
          var bucket = _buckets[key];
          if (bucket == null) {
            // Get a list from the pool or allocate new.
            bucket = _bucketPool.isNotEmpty ? _bucketPool.removeLast() : <int>[];
            _buckets[key] = bucket;
            _activeKeys.add(key);
          }
          // Store the target index (not EntityId) for fast lookups.
          bucket.add(ti);
        }
      }
    }
  }

  /// Fills [outTargetIndices] with unique target indices whose AABBs may overlap
  /// the query AABB.
  ///
  /// This involves a broadphase lookup (finding grid cells) and deduplication.
  ///
  /// IMPORTANT (determinism):
  /// - Cell scan order is stable (y then x, increasing).
  /// - The output order depends on bucket insertion order (which depends on entity order).
  /// - Callers must sort by `targets.entities[targetIndex]` if they need a stable
  ///   per-query hit selection order.
  void queryAabbMinMax({
    required double minX,
    required double minY,
    required double maxX,
    required double maxY,
    required List<int> outTargetIndices,
  }) {
    outTargetIndices.clear();
    if (targets.isEmpty) return;

    _stamp += 1;

    // Handle stamp overflow (wrap around)
    if (_stamp == 0x7FFFFFFF) {
      // Reset all seen stamps to 0 so we can safely start over at 1
      for (var i = 0; i < _seenStampByTargetIndex.length; i += 1) {
        _seenStampByTargetIndex[i] = 0;
      }
      _stamp = 1;
    }

    final minCx = _index.worldToCellX(minX);
    final maxCx = _index.worldToCellX(maxX);
    final minCy = _index.worldToCellY(minY);
    final maxCy = _index.worldToCellY(maxY);

    // Ensure strict capacity for the seen array to match current targets.
    // This handles the case where new targets were added in `rebuild`.
    if (_seenStampByTargetIndex.length < targets.length) {
      final missing = targets.length - _seenStampByTargetIndex.length;
      for (var i = 0; i < missing; i += 1) {
        _seenStampByTargetIndex.add(0);
      }
    }

    // Iterate over all cells touched by the query AABB.
    // Order: Row by row (Y), then column by column (X).
    for (var cellY = minCy; cellY <= maxCy; cellY += 1) {
      for (var cellX = minCx; cellX <= maxCx; cellX += 1) {
        final key = _index.cellKey(cellX, cellY);
        final bucket = _buckets[key];
        
        // Skip empty cells.
        if (bucket == null || bucket.isEmpty) continue;

        // Iterate contents of the bucket.
        // Elements are roughly sorted by insertion order (EntityId order).
        for (var bi = 0; bi < bucket.length; bi += 1) {
          final targetIndex = bucket[bi];
          
          // Use stamp to check if already visited this query.
          // This avoids adding the same entity multiple times if it spans multiple cells.
          if (_seenStampByTargetIndex[targetIndex] == _stamp) continue;
          _seenStampByTargetIndex[targetIndex] = _stamp;
          outTargetIndices.add(targetIndex);
        }
      }
    }
  }
}


===== FILE: lib/core/ecs/spatial/grid_index_2d.dart =====
import '../../util/vec2.dart';

class CellAabb {
  const CellAabb({
    required this.minX,
    required this.minY,
    required this.maxX,
    required this.maxY,
  });

  /// World space minimum X coordinate of the cell.
  final double minX;

  /// World space minimum Y coordinate of the cell.
  final double minY;

  /// World space maximum X coordinate of the cell.
  final double maxX;

  /// World space maximum Y coordinate of the cell.
  final double maxY;
}

/// Generic 2D grid math + hashing utility.
///
/// This is intentionally reusable for both:
/// - dynamic broadphase buckets (Milestone 9), and
/// - future nav/cost grids (later milestone).
///
/// IMPORTANT (determinism):
/// - `cellKey(cx, cy)` must be stable and must not use Dart `hashCode`.
class GridIndex2D {
  GridIndex2D({required this.cellSize}) : invCellSize = 1.0 / cellSize;

  /// The width/height of a single square grid cell in world units.
  final double cellSize;

  /// Precomputed `1.0 / cellSize` to avoid divisions in tight loops.
  final double invCellSize;

  /// Converts world X coordinate to grid cell X index.
  /// Uses floor() to handle negative coordinates correctly.
  int worldToCellX(double x) => (x * invCellSize).floor();

  /// Converts world Y coordinate to grid cell Y index.
  int worldToCellY(double y) => (y * invCellSize).floor();

  /// returns the top-left (min) world position of the cell at [cx], [cy].
  Vec2 cellToWorldMin(int cx, int cy) => Vec2(cx * cellSize, cy * cellSize);

  CellAabb cellAabb(int cx, int cy) {
    final minX = cx * cellSize;
    final minY = cy * cellSize;
    return CellAabb(
      minX: minX,
      minY: minY,
      maxX: minX + cellSize,
      maxY: minY + cellSize,
    );
  }

  /// Packs signed (cx, cy) into a single int key (two 32-bit lanes).
  ///
  /// The key is constructed by placing `cy` in the upper 32 bits and `cx` in the
  /// lower 32 bits.
  ///
  /// **Platform Note**: This logic relies on Dart's 64-bit integers (VM/Native).
  /// On the web, where `int` is a double and bitwise operations are 32-bit,
  /// this will lose data (collisions) for keys requiring >32 bits.
  /// For cross-platform safety use a String key or customized class, or ensure
  /// coordinates fit in 16 bits (packed to 32).
  int cellKey(int cx, int cy) {
    // Mask to 32 bits to treat as unsigned for packing, then shift.
    return ((cy & 0xFFFFFFFF) << 32) | (cx & 0xFFFFFFFF);
  }

  /// Iterates 4 neighbors (or 8 if [diagonal] is true) around [cx], [cy].
  ///
  /// Order is guaranteed for determinism:
  /// 1. Cardinals: N, W, E, S
  /// 2. Diagonals (if enabled): NW, NE, SW, SE
  void forNeighbors(
    int cx,
    int cy, {
    bool diagonal = false,
    required void Function(int nx, int ny) visit,
  }) {
    // Stable order (N, W, E, S), then diagonals (NW, NE, SW, SE).
    visit(cx, cy - 1); // North
    visit(cx - 1, cy); // West
    visit(cx + 1, cy); // East
    visit(cx, cy + 1); // South

    if (!diagonal) return;
    
    visit(cx - 1, cy - 1); // NW
    visit(cx + 1, cy - 1); // NE
    visit(cx - 1, cy + 1); // SW
    visit(cx + 1, cy + 1); // SE
  }
}



===== FILE: lib/core/ecs/stores/body_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

/// Configuration for how an entity participates in physics.
///
/// This is intentionally "config-like" and reusable across players/enemies:
/// - `Transform` holds state (pos/vel)
/// - `Movement` holds controller-specific timers/state (coyote, dash, etc.)
/// - `Body` holds physics participation and constraints (gravity, clamps, kinematic)
class BodyDef {
  const BodyDef({
    this.enabled = true,
    this.isKinematic = false,
    this.useGravity = true,
    this.ignoreCeilings = false,
    this.topOnlyGround = true,
    this.gravityScale = 1.0,
    this.maxVelX = defaultMaxVelX,
    this.maxVelY = defaultMaxVelY,
    this.sideMask = sideLeft | sideRight,
  });

  /// Default velocity cap (safety limit).
  static const double defaultMaxVelX = 3000.0;
  static const double defaultMaxVelY = 3000.0;

  /// Master on/off switch for physics on this entity.
  final bool enabled;

  /// If true, physics does not integrate position/velocity (gameplay code drives it).
  final bool isKinematic;

  /// Whether gravity affects this body.
  final bool useGravity;

  /// If true, upward motion ignores bottom faces (ceilings).
  final bool ignoreCeilings;

  /// If true, collision should resolve only top contacts (platformer-style).
  /// Used by `CollisionSystem` (later milestone).
  final bool topOnlyGround;

  /// Scale applied to global/tuning gravity (1.0 = normal gravity).
  final double gravityScale;

  /// Per-axis velocity clamps (safety caps).
  final double maxVelX;
  final double maxVelY;

  /// Horizontal collision sides bitmask (used by `CollisionSystem` later).
  final int sideMask;

  static const int sideNone = 0;
  static const int sideLeft = 1 << 0;
  static const int sideRight = 1 << 1;
}

/// SoA store for `Body` configuration.
class BodyStore extends SparseSet {
  final List<bool> enabled = <bool>[];
  final List<bool> isKinematic = <bool>[];
  final List<bool> useGravity = <bool>[];
  final List<bool> ignoreCeilings = <bool>[];
  final List<bool> topOnlyGround = <bool>[];

  final List<double> gravityScale = <double>[];
  final List<double> maxVelX = <double>[];
  final List<double> maxVelY = <double>[];

  final List<int> sideMask = <int>[];

  void add(EntityId entity, BodyDef def) {
    final i = addEntity(entity);
    enabled[i] = def.enabled;
    isKinematic[i] = def.isKinematic;
    useGravity[i] = def.useGravity;
    ignoreCeilings[i] = def.ignoreCeilings;
    topOnlyGround[i] = def.topOnlyGround;
    gravityScale[i] = def.gravityScale;
    maxVelX[i] = def.maxVelX;
    maxVelY[i] = def.maxVelY;
    sideMask[i] = def.sideMask;
  }

  @override
  void onDenseAdded(int denseIndex) {
    enabled.add(true);
    isKinematic.add(false);
    useGravity.add(true);
    ignoreCeilings.add(false);
    topOnlyGround.add(true);
    gravityScale.add(1);
    maxVelX.add(BodyDef.defaultMaxVelX);
    maxVelY.add(BodyDef.defaultMaxVelY);
    sideMask.add(BodyDef.sideLeft | BodyDef.sideRight);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    enabled[removeIndex] = enabled[lastIndex];
    isKinematic[removeIndex] = isKinematic[lastIndex];
    useGravity[removeIndex] = useGravity[lastIndex];
    ignoreCeilings[removeIndex] = ignoreCeilings[lastIndex];
    topOnlyGround[removeIndex] = topOnlyGround[lastIndex];
    gravityScale[removeIndex] = gravityScale[lastIndex];
    maxVelX[removeIndex] = maxVelX[lastIndex];
    maxVelY[removeIndex] = maxVelY[lastIndex];
    sideMask[removeIndex] = sideMask[lastIndex];

    enabled.removeLast();
    isKinematic.removeLast();
    useGravity.removeLast();
    ignoreCeilings.removeLast();
    topOnlyGround.removeLast();
    gravityScale.removeLast();
    maxVelX.removeLast();
    maxVelY.removeLast();
    sideMask.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/cast_intent_store.dart =====
import '../../spells/spell_id.dart';
import '../entity_id.dart';
import '../sparse_set.dart';

class CastIntentDef {
  const CastIntentDef({
    required this.spellId,
    required this.dirX,
    required this.dirY,
    required this.fallbackDirX,
    required this.fallbackDirY,
    required this.originOffset,
    required this.cooldownTicks,
    required this.tick,
  });

  final SpellId spellId;
  final double dirX;
  final double dirY;
  final double fallbackDirX;
  final double fallbackDirY;
  final double originOffset;
  final int cooldownTicks;

  /// Tick stamp for this intent.
  ///
  /// Use `-1` for "no intent". An intent is valid only when `tick == currentTick`.
  final int tick;
}

/// Per-entity "cast a spell this tick" intent.
///
/// This is written by player/enemy intent writers and consumed by `SpellCastSystem`.
///
/// **Usage**: Persistent component. Intents are set via `set()` with a `tick` stamp.
/// Old intents are ignored if `tick` matches current game tick.
/// This avoids the overhead of adding/removing components every frame.
class CastIntentStore extends SparseSet {
  final List<SpellId> spellId = <SpellId>[];
  final List<double> dirX = <double>[];
  final List<double> dirY = <double>[];
  final List<double> fallbackDirX = <double>[];
  final List<double> fallbackDirY = <double>[];
  final List<double> originOffset = <double>[];
  final List<int> cooldownTicks = <int>[];
  final List<int> tick = <int>[];

  void add(EntityId entity) {
    addEntity(entity);
  }

  void set(EntityId entity, CastIntentDef def) {
    assert(
      has(entity),
      'CastIntentStore.set called for entity without CastIntentStore; add the component at spawn time.',
    );
    final i = indexOf(entity);
    spellId[i] = def.spellId;
    dirX[i] = def.dirX;
    dirY[i] = def.dirY;
    fallbackDirX[i] = def.fallbackDirX;
    fallbackDirY[i] = def.fallbackDirY;
    originOffset[i] = def.originOffset;
    cooldownTicks[i] = def.cooldownTicks;
    tick[i] = def.tick;
  }

  @override
  void onDenseAdded(int denseIndex) {
    spellId.add(SpellId.iceBolt);
    dirX.add(0.0);
    dirY.add(0.0);
    fallbackDirX.add(1.0);
    fallbackDirY.add(0.0);
    originOffset.add(0.0);
    cooldownTicks.add(0);
    tick.add(-1);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    spellId[removeIndex] = spellId[lastIndex];
    dirX[removeIndex] = dirX[lastIndex];
    dirY[removeIndex] = dirY[lastIndex];
    fallbackDirX[removeIndex] = fallbackDirX[lastIndex];
    fallbackDirY[removeIndex] = fallbackDirY[lastIndex];
    originOffset[removeIndex] = originOffset[lastIndex];
    cooldownTicks[removeIndex] = cooldownTicks[lastIndex];
    tick[removeIndex] = tick[lastIndex];

    spellId.removeLast();
    dirX.removeLast();
    dirY.removeLast();
    fallbackDirX.removeLast();
    fallbackDirY.removeLast();
    originOffset.removeLast();
    cooldownTicks.removeLast();
    tick.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/collectible_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

class CollectibleDef {
  const CollectibleDef({required this.value});

  final int value;
}

/// SoA store for collectible metadata.
///
/// Holds the value/score of the collectible.
class CollectibleStore extends SparseSet {
  final List<int> value = <int>[];

  void add(EntityId entity, CollectibleDef def) {
    final i = addEntity(entity);
    value[i] = def.value;
  }

  @override
  void onDenseAdded(int denseIndex) {
    value.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    value[removeIndex] = value[lastIndex];
    value.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/collider_aabb_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

/// AABB collider configuration for an entity.
///
/// Representation is center-based for stability:
/// - `Transform.pos` is treated as the entity center
/// - collider center is `pos + offset`
/// - extents are half-sizes in world units (virtual pixels)
class ColliderAabbDef {
  const ColliderAabbDef({
    required this.halfX,
    required this.halfY,
    this.offsetX = 0,
    this.offsetY = 0,
  });

  final double halfX;
  final double halfY;
  final double offsetX;
  final double offsetY;
}

/// SoA store for AABB collider config (half extents + offset).
///
/// Collision bounds are distinct from render bounds or hitbox bounds (which are temporary).
class ColliderAabbStore extends SparseSet {
  final List<double> halfX = <double>[];
  final List<double> halfY = <double>[];
  final List<double> offsetX = <double>[];
  final List<double> offsetY = <double>[];

  void add(EntityId entity, ColliderAabbDef def) {
    final i = addEntity(entity);
    halfX[i] = def.halfX;
    halfY[i] = def.halfY;
    offsetX[i] = def.offsetX;
    offsetY[i] = def.offsetY;
  }

  @override
  void onDenseAdded(int denseIndex) {
    halfX.add(0);
    halfY.add(0);
    offsetX.add(0);
    offsetY.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    halfX[removeIndex] = halfX[lastIndex];
    halfY[removeIndex] = halfY[lastIndex];
    offsetX[removeIndex] = offsetX[lastIndex];
    offsetY[removeIndex] = offsetY[lastIndex];

    halfX.removeLast();
    halfY.removeLast();
    offsetX.removeLast();
    offsetY.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/collision_state_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

/// Per-tick collision results for an entity.
///
/// This is reset each tick by the CollisionSystem.
/// These flags track *physical* collision (blocking), not combat hits.
class CollisionStateStore extends SparseSet {
  final List<bool> grounded = <bool>[];
  final List<bool> hitCeiling = <bool>[];
  final List<bool> hitLeft = <bool>[];
  final List<bool> hitRight = <bool>[];

  void add(EntityId entity) {
    addEntity(entity);
  }

  void resetTick(EntityId entity) {
    final i = indexOf(entity);
    grounded[i] = false;
    hitCeiling[i] = false;
    hitLeft[i] = false;
    hitRight[i] = false;
  }

  @override
  void onDenseAdded(int denseIndex) {
    grounded.add(false);
    hitCeiling.add(false);
    hitLeft.add(false);
    hitRight.add(false);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    grounded[removeIndex] = grounded[lastIndex];
    hitCeiling[removeIndex] = hitCeiling[lastIndex];
    hitLeft[removeIndex] = hitLeft[lastIndex];
    hitRight[removeIndex] = hitRight[lastIndex];

    grounded.removeLast();
    hitCeiling.removeLast();
    hitLeft.removeLast();
    hitRight.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/combat/ammo_store.dart =====
import '../../../weapons/ammo_type.dart';
import '../../entity_id.dart';
import '../../sparse_set.dart';

class AmmoDef {
  const AmmoDef({this.arrows = 0, this.throwingAxes = 0});

  final int arrows;
  final int throwingAxes;

  int countFor(AmmoType type) {
    switch (type) {
      case AmmoType.arrow:
        return arrows;
      case AmmoType.throwingAxe:
        return throwingAxes;
    }
  }
}

/// Per-entity ammo pools for ranged weapons.
class AmmoStore extends SparseSet {
  final List<int> arrows = <int>[];
  final List<int> throwingAxes = <int>[];

  void add(EntityId entity, [AmmoDef def = const AmmoDef()]) {
    final i = addEntity(entity);
    arrows[i] = def.arrows;
    throwingAxes[i] = def.throwingAxes;
  }

  int countForIndex(int index, AmmoType type) {
    switch (type) {
      case AmmoType.arrow:
        return arrows[index];
      case AmmoType.throwingAxe:
        return throwingAxes[index];
    }
  }

  void setCountForIndex(int index, AmmoType type, int value) {
    final clamped = value < 0 ? 0 : value;
    switch (type) {
      case AmmoType.arrow:
        arrows[index] = clamped;
      case AmmoType.throwingAxe:
        throwingAxes[index] = clamped;
    }
  }

  @override
  void onDenseAdded(int denseIndex) {
    arrows.add(0);
    throwingAxes.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    arrows[removeIndex] = arrows[lastIndex];
    throwingAxes[removeIndex] = throwingAxes[lastIndex];

    arrows.removeLast();
    throwingAxes.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/combat/creature_tag_store.dart =====
import '../../../combat/creature_tag.dart';
import '../../entity_id.dart';
import '../../sparse_set.dart';

class CreatureTagDef {
  const CreatureTagDef({this.mask = 0});

  final int mask;
}

/// Broad tag classifications for creatures (enemies + player variants).
class CreatureTagStore extends SparseSet {
  final List<int> tagsMask = <int>[];

  void add(EntityId entity, [CreatureTagDef def = const CreatureTagDef()]) {
    final i = addEntity(entity);
    tagsMask[i] = def.mask;
  }

  bool hasTag(EntityId entity, CreatureTag tag) {
    final i = tryIndexOf(entity);
    if (i == null) return false;
    return (tagsMask[i] & CreatureTagMask.forTag(tag)) != 0;
  }

  void addTag(EntityId entity, CreatureTag tag) {
    final i = tryIndexOf(entity);
    if (i == null) return;
    tagsMask[i] |= CreatureTagMask.forTag(tag);
  }

  @override
  void onDenseAdded(int denseIndex) {
    tagsMask.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    tagsMask[removeIndex] = tagsMask[lastIndex];
    tagsMask.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/combat/damage_resistance_store.dart =====
import '../../../combat/damage_type.dart';
import '../../entity_id.dart';
import '../../sparse_set.dart';

class DamageResistanceDef {
  const DamageResistanceDef({
    this.physical = 0.0,
    this.fire = 0.0,
    this.ice = 0.0,
    this.lightning = 0.0,
    this.bleed = 0.0,
  });

  final double physical;
  final double fire;
  final double ice;
  final double lightning;
  final double bleed;

  double modFor(DamageType type) {
    switch (type) {
      case DamageType.physical:
        return physical;
      case DamageType.fire:
        return fire;
      case DamageType.ice:
        return ice;
      case DamageType.lightning:
        return lightning;
      case DamageType.bleed:
        return bleed;
    }
  }
}

/// Per-entity resistance/vulnerability modifiers by [DamageType].
class DamageResistanceStore extends SparseSet {
  final List<double> physical = <double>[];
  final List<double> fire = <double>[];
  final List<double> ice = <double>[];
  final List<double> lightning = <double>[];
  final List<double> bleed = <double>[];

  void add(EntityId entity, [DamageResistanceDef def = const DamageResistanceDef()]) {
    final i = addEntity(entity);
    physical[i] = def.physical;
    fire[i] = def.fire;
    ice[i] = def.ice;
    lightning[i] = def.lightning;
    bleed[i] = def.bleed;
  }

  double modForEntity(EntityId entity, DamageType type) {
    final i = tryIndexOf(entity);
    if (i == null) return 0.0;
    return modForIndex(i, type);
  }

  double modForIndex(int index, DamageType type) {
    switch (type) {
      case DamageType.physical:
        return physical[index];
      case DamageType.fire:
        return fire[index];
      case DamageType.ice:
        return ice[index];
      case DamageType.lightning:
        return lightning[index];
      case DamageType.bleed:
        return bleed[index];
    }
  }

  @override
  void onDenseAdded(int denseIndex) {
    physical.add(0.0);
    fire.add(0.0);
    ice.add(0.0);
    lightning.add(0.0);
    bleed.add(0.0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    physical[removeIndex] = physical[lastIndex];
    fire[removeIndex] = fire[lastIndex];
    ice[removeIndex] = ice[lastIndex];
    lightning[removeIndex] = lightning[lastIndex];
    bleed[removeIndex] = bleed[lastIndex];

    physical.removeLast();
    fire.removeLast();
    ice.removeLast();
    lightning.removeLast();
    bleed.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/combat/equipped_ranged_weapon_store.dart =====
import '../../../weapons/ranged_weapon_id.dart';
import '../../entity_id.dart';
import '../../sparse_set.dart';

class EquippedRangedWeaponDef {
  const EquippedRangedWeaponDef({this.weaponId = RangedWeaponId.bow});

  final RangedWeaponId weaponId;
}

/// Per-entity equipped ranged weapon (bow, throwing axe, ...).
class EquippedRangedWeaponStore extends SparseSet {
  final List<RangedWeaponId> weaponId = <RangedWeaponId>[];

  void add(
    EntityId entity, [
    EquippedRangedWeaponDef def = const EquippedRangedWeaponDef(),
  ]) {
    final i = addEntity(entity);
    weaponId[i] = def.weaponId;
  }

  @override
  void onDenseAdded(int denseIndex) {
    weaponId.add(RangedWeaponId.bow);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    weaponId[removeIndex] = weaponId[lastIndex];
    weaponId.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/combat/equipped_weapon_store.dart =====
import '../../../weapons/weapon_id.dart';
import '../../entity_id.dart';
import '../../sparse_set.dart';

class EquippedWeaponDef {
  const EquippedWeaponDef({this.weaponId = WeaponId.basicSword});

  final WeaponId weaponId;
}

/// Per-entity equipped weapon (for melee intent writers).
class EquippedWeaponStore extends SparseSet {
  final List<WeaponId> weaponId = <WeaponId>[];

  void add(EntityId entity, [EquippedWeaponDef def = const EquippedWeaponDef()]) {
    final i = addEntity(entity);
    weaponId[i] = def.weaponId;
  }

  @override
  void onDenseAdded(int denseIndex) {
    weaponId.add(WeaponId.basicSword);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    weaponId[removeIndex] = weaponId[lastIndex];
    weaponId.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/combat/stat_modifier_store.dart =====
import '../../entity_id.dart';
import '../../sparse_set.dart';

class StatModifierDef {
  const StatModifierDef({this.moveSpeedMul = 1.0});

  final double moveSpeedMul;
}

/// Runtime modifiers derived from status effects and buffs.
class StatModifierStore extends SparseSet {
  final List<double> moveSpeedMul = <double>[];

  void add(EntityId entity, [StatModifierDef def = const StatModifierDef()]) {
    final i = addEntity(entity);
    moveSpeedMul[i] = def.moveSpeedMul;
  }

  @override
  void onDenseAdded(int denseIndex) {
    moveSpeedMul.add(1.0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    moveSpeedMul[removeIndex] = moveSpeedMul[lastIndex];
    moveSpeedMul.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/combat/status_immunity_store.dart =====
import '../../../combat/status/status.dart';
import '../../entity_id.dart';
import '../../sparse_set.dart';

class StatusImmunityMask {
  const StatusImmunityMask._();

  static const int burn = 1 << 0;
  static const int slow = 1 << 1;
  static const int bleed = 1 << 2;

  static int forType(StatusEffectType type) {
    switch (type) {
      case StatusEffectType.burn:
        return burn;
      case StatusEffectType.slow:
        return slow;
      case StatusEffectType.bleed:
        return bleed;
    }
  }
}

class StatusImmunityDef {
  const StatusImmunityDef({this.mask = 0});

  final int mask;
}

/// Per-entity status immunities (bitmask of [StatusEffectType]).
class StatusImmunityStore extends SparseSet {
  final List<int> mask = <int>[];

  void add(EntityId entity, [StatusImmunityDef def = const StatusImmunityDef()]) {
    final i = addEntity(entity);
    mask[i] = def.mask;
  }

  bool isImmune(EntityId entity, StatusEffectType type) {
    final i = tryIndexOf(entity);
    if (i == null) return false;
    return (mask[i] & StatusImmunityMask.forType(type)) != 0;
  }

  @override
  void onDenseAdded(int denseIndex) {
    mask.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    mask[removeIndex] = mask[lastIndex];
    mask.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/cooldown_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

class CooldownDef {
  const CooldownDef({
    this.castCooldownTicksLeft = 0,
    this.meleeCooldownTicksLeft = 0,
    this.rangedWeaponCooldownTicksLeft = 0,
  });

  final int castCooldownTicksLeft;
  final int meleeCooldownTicksLeft;
  final int rangedWeaponCooldownTicksLeft;
}

/// Tracks ability cooldowns (ticks remaining).
class CooldownStore extends SparseSet {
  final List<int> castCooldownTicksLeft = <int>[];
  final List<int> meleeCooldownTicksLeft = <int>[];
  final List<int> rangedWeaponCooldownTicksLeft = <int>[];

  void add(EntityId entity, [CooldownDef def = const CooldownDef()]) {
    final i = addEntity(entity);
    castCooldownTicksLeft[i] = def.castCooldownTicksLeft;
    meleeCooldownTicksLeft[i] = def.meleeCooldownTicksLeft;
    rangedWeaponCooldownTicksLeft[i] = def.rangedWeaponCooldownTicksLeft;
  }

  @override
  void onDenseAdded(int denseIndex) {
    castCooldownTicksLeft.add(0);
    meleeCooldownTicksLeft.add(0);
    rangedWeaponCooldownTicksLeft.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    castCooldownTicksLeft[removeIndex] = castCooldownTicksLeft[lastIndex];
    meleeCooldownTicksLeft[removeIndex] = meleeCooldownTicksLeft[lastIndex];
    rangedWeaponCooldownTicksLeft[removeIndex] =
        rangedWeaponCooldownTicksLeft[lastIndex];
    castCooldownTicksLeft.removeLast();
    meleeCooldownTicksLeft.removeLast();
    rangedWeaponCooldownTicksLeft.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/enemies/enemy_store.dart =====
import '../../../enemies/enemy_id.dart';
import '../../../snapshots/enums.dart';
import '../../entity_id.dart';
import '../../sparse_set.dart';

class EnemyDef {
  const EnemyDef({
    required this.enemyId,
    this.facing = Facing.left,
  });

  final EnemyId enemyId;
  final Facing facing;
}

/// Minimal enemy marker + per-enemy state.
///
/// Indicates this entity is an enemy and which type it is.
/// Also holds facing direction.
class EnemyStore extends SparseSet {
  final List<EnemyId> enemyId = <EnemyId>[];
  final List<Facing> facing = <Facing>[];

  void add(EntityId entity, EnemyDef def) {
    final i = addEntity(entity);
    enemyId[i] = def.enemyId;
    facing[i] = def.facing;
  }

  @override
  void onDenseAdded(int denseIndex) {
    enemyId.add(EnemyId.unocoDemon);
    facing.add(Facing.left);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    enemyId[removeIndex] = enemyId[lastIndex];
    facing[removeIndex] = facing[lastIndex];

    enemyId.removeLast();
    facing.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/enemies/flying_enemy_steering_store.dart =====
import '../../entity_id.dart';
import '../../sparse_set.dart';

class FlyingEnemySteeringDef {
  const FlyingEnemySteeringDef({
    required this.rngState,
  });

  final int rngState;
}

/// Per flying enemy steering state for deterministic hover behavior.
///
/// Holds RNG state and smoothed target ranges to make enemies wobble nicely.
class FlyingEnemySteeringStore extends SparseSet {
  final List<int> rngState = <int>[];
  final List<bool> initialized = <bool>[];
  final List<double> desiredRange = <double>[];
  final List<double> desiredRangeHoldLeftS = <double>[];
  final List<double> flightTargetAboveGround = <double>[];
  final List<double> flightTargetHoldLeftS = <double>[];

  void add(EntityId entity, FlyingEnemySteeringDef def) {
    final i = addEntity(entity);
    rngState[i] = def.rngState;
    initialized[i] = false;
    desiredRange[i] = 0.0;
    desiredRangeHoldLeftS[i] = 0.0;
    flightTargetAboveGround[i] = 0.0;
    flightTargetHoldLeftS[i] = 0.0;
  }

  @override
  void onDenseAdded(int denseIndex) {
    rngState.add(1);
    initialized.add(false);
    desiredRange.add(0.0);
    desiredRangeHoldLeftS.add(0.0);
    flightTargetAboveGround.add(0.0);
    flightTargetHoldLeftS.add(0.0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    rngState[removeIndex] = rngState[lastIndex];
    initialized[removeIndex] = initialized[lastIndex];
    desiredRange[removeIndex] = desiredRange[lastIndex];
    desiredRangeHoldLeftS[removeIndex] = desiredRangeHoldLeftS[lastIndex];
    flightTargetAboveGround[removeIndex] = flightTargetAboveGround[lastIndex];
    flightTargetHoldLeftS[removeIndex] = flightTargetHoldLeftS[lastIndex];

    rngState.removeLast();
    initialized.removeLast();
    desiredRange.removeLast();
    desiredRangeHoldLeftS.removeLast();
    flightTargetAboveGround.removeLast();
    flightTargetHoldLeftS.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/enemies/ground_enemy_chase_offset_store.dart =====
import '../../entity_id.dart';
import '../../sparse_set.dart';

class GroundEnemyChaseOffsetDef {
  const GroundEnemyChaseOffsetDef({
    required this.rngState,
  });

  final int rngState;
}

/// Per ground enemy chase offset state for deterministic path separation.
///
/// Ensures multiple enemies don't stack perfectly on top of one another while chasing.
class GroundEnemyChaseOffsetStore extends SparseSet {
  final List<int> rngState = <int>[];
  final List<double> chaseOffsetX = <double>[];
  final List<double> chaseSpeedScale = <double>[];
  final List<bool> initialized = <bool>[];

  void add(EntityId entity, GroundEnemyChaseOffsetDef def) {
    final i = addEntity(entity);
    rngState[i] = def.rngState;
    chaseOffsetX[i] = 0.0;
    chaseSpeedScale[i] = 1.0;
    initialized[i] = false;
  }

  @override
  void onDenseAdded(int denseIndex) {
    rngState.add(1);
    chaseOffsetX.add(0.0);
    chaseSpeedScale.add(1.0);
    initialized.add(false);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    rngState[removeIndex] = rngState[lastIndex];
    chaseOffsetX[removeIndex] = chaseOffsetX[lastIndex];
    chaseSpeedScale[removeIndex] = chaseSpeedScale[lastIndex];
    initialized[removeIndex] = initialized[lastIndex];

    rngState.removeLast();
    chaseOffsetX.removeLast();
    chaseSpeedScale.removeLast();
    initialized.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/enemies/surface_nav_state_store.dart =====
import '../../../navigation/types/surface_id.dart';
import '../../entity_id.dart';
import '../../sparse_set.dart';

/// Per-entity pathfinding state.
///
/// Tracks the current surface segment, the target segment, and the calculated path edges.
/// Used by `SurfaceNavigationSystem` to move ground enemies.
class SurfaceNavStateStore extends SparseSet {
  final List<int> graphVersion = <int>[];
  final List<int> repathTicksLeft = <int>[];
  final List<int> currentSurfaceId = <int>[];
  final List<int> targetSurfaceId = <int>[];
  final List<int> activeEdgeIndex = <int>[];
  final List<int> pathCursor = <int>[];
  final List<List<int>> pathEdges = <List<int>>[];

  void add(EntityId entity) {
    addEntity(entity);
  }

  @override
  void onDenseAdded(int denseIndex) {
    graphVersion.add(-1);
    repathTicksLeft.add(0);
    currentSurfaceId.add(surfaceIdUnknown);
    targetSurfaceId.add(surfaceIdUnknown);
    activeEdgeIndex.add(-1);
    pathCursor.add(0);
    pathEdges.add(<int>[]);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    graphVersion[removeIndex] = graphVersion[lastIndex];
    repathTicksLeft[removeIndex] = repathTicksLeft[lastIndex];
    currentSurfaceId[removeIndex] = currentSurfaceId[lastIndex];
    targetSurfaceId[removeIndex] = targetSurfaceId[lastIndex];
    activeEdgeIndex[removeIndex] = activeEdgeIndex[lastIndex];
    pathCursor[removeIndex] = pathCursor[lastIndex];
    pathEdges[removeIndex] = pathEdges[lastIndex];

    graphVersion.removeLast();
    repathTicksLeft.removeLast();
    currentSurfaceId.removeLast();
    targetSurfaceId.removeLast();
    activeEdgeIndex.removeLast();
    pathCursor.removeLast();
    pathEdges.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/faction_store.dart =====
import '../../combat/faction.dart';
import '../entity_id.dart';
import '../sparse_set.dart';

class FactionDef {
  const FactionDef({required this.faction});

  final Faction faction;
}

class FactionStore extends SparseSet {
  final List<Faction> faction = <Faction>[];

  void add(EntityId entity, FactionDef def) {
    final i = addEntity(entity);
    faction[i] = def.faction;
  }

  @override
  void onDenseAdded(int denseIndex) {
    // Default to player if not specified.
    faction.add(Faction.player);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    faction[removeIndex] = faction[lastIndex];
    faction.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/health_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

class HealthDef {
  const HealthDef({
    required this.hp,
    required this.hpMax,
    required this.regenPerSecond,
  });

  final double hp;
  final double hpMax;
  final double regenPerSecond;
}

/// Tracks current and max hit points for damageable entities.
class HealthStore extends SparseSet {
  final List<double> hp = <double>[];
  final List<double> hpMax = <double>[];
  final List<double> regenPerSecond = <double>[];

  void add(EntityId entity, HealthDef def) {
    final i = addEntity(entity);
    hp[i] = def.hp;
    hpMax[i] = def.hpMax;
    regenPerSecond[i] = def.regenPerSecond;
  }

  @override
  void onDenseAdded(int denseIndex) {
    hp.add(0);
    hpMax.add(0);
    regenPerSecond.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    hp[removeIndex] = hp[lastIndex];
    hpMax[removeIndex] = hpMax[lastIndex];
    regenPerSecond[removeIndex] = regenPerSecond[lastIndex];

    hp.removeLast();
    hpMax.removeLast();
    regenPerSecond.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/hit_once_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

/// Tracks unique hit targets for a single attack instance (e.g. one swing).
///
/// **Optimization**: Uses inline fields (`hit0`...`hit3`) instead of a `List`
/// to avoid allocation per entity per frame. Saturation limit is 4 targets.
class HitOnceStore extends SparseSet {
  final List<int> count = <int>[];
  final List<EntityId> hit0 = <EntityId>[];
  final List<EntityId> hit1 = <EntityId>[];
  final List<EntityId> hit2 = <EntityId>[];
  final List<EntityId> hit3 = <EntityId>[];

  void add(EntityId entity) {
    addEntity(entity);
  }

  bool hasHit(EntityId entity, EntityId target) {
    final i = indexOf(entity);
    final c = count[i];
    if (c > 4) return true; // saturated: treat as "already hit everything"
    if (c <= 0) return false;
    if (hit0[i] == target) return true;
    if (c <= 1) return false;
    if (hit1[i] == target) return true;
    if (c <= 2) return false;
    if (hit2[i] == target) return true;
    if (c <= 3) return false;
    return hit3[i] == target;
  }

  void markHit(EntityId entity, EntityId target) {
    final i = indexOf(entity);
    var c = count[i];
    if (c > 4) return; // already saturated
    if (c <= 0) {
      hit0[i] = target;
      count[i] = 1;
      return;
    }
    if (c == 1) {
      hit1[i] = target;
      count[i] = 2;
      return;
    }
    if (c == 2) {
      hit2[i] = target;
      count[i] = 3;
      return;
    }
    if (c == 3) {
      hit3[i] = target;
      count[i] = 4;
      return;
    }
    // We don't expect more than 4 hits per swing.
    //
    // IMPORTANT (determinism + safety): once saturated, treat as "already hit"
    // for any target so a single swing cannot multi-hit due to overflow.
    count[i] = 5;
  }

  @override
  void onDenseAdded(int denseIndex) {
    count.add(0);
    hit0.add(0);
    hit1.add(0);
    hit2.add(0);
    hit3.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    count[removeIndex] = count[lastIndex];
    hit0[removeIndex] = hit0[lastIndex];
    hit1[removeIndex] = hit1[lastIndex];
    hit2[removeIndex] = hit2[lastIndex];
    hit3[removeIndex] = hit3[lastIndex];

    count.removeLast();
    hit0.removeLast();
    hit1.removeLast();
    hit2.removeLast();
    hit3.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/hitbox_store.dart =====
import '../../combat/damage_type.dart';
import '../../combat/faction.dart';
import '../../combat/status/status.dart';
import '../entity_id.dart';
import '../sparse_set.dart';

class HitboxDef {
  const HitboxDef({
    required this.owner,
    required this.faction,
    required this.damage,
    required this.damageType,
    required this.statusProfileId,
    required this.halfX,
    required this.halfY,
    required this.offsetX,
    required this.offsetY,
    required this.dirX,
    required this.dirY,
  });

  final EntityId owner;
  final Faction faction;
  final double damage;
  final DamageType damageType;
  final StatusProfileId statusProfileId;
  final double halfX;
  final double halfY;
  final double offsetX;
  final double offsetY;
  final double dirX;
  final double dirY;
}

/// Short-lived damage hitbox used by melee attacks and area effects.
///
/// These entities usually exist for only a few frames (attack windows).
/// They are queried by `HitboxDamageSystem`.
class HitboxStore extends SparseSet {
  final List<EntityId> owner = <EntityId>[];
  final List<Faction> faction = <Faction>[];
  final List<double> damage = <double>[];
  final List<DamageType> damageType = <DamageType>[];
  final List<StatusProfileId> statusProfileId = <StatusProfileId>[];
  final List<double> halfX = <double>[];
  final List<double> halfY = <double>[];
  final List<double> offsetX = <double>[];
  final List<double> offsetY = <double>[];
  final List<double> dirX = <double>[];
  final List<double> dirY = <double>[];

  void add(EntityId entity, HitboxDef def) {
    final i = addEntity(entity);
    owner[i] = def.owner;
    faction[i] = def.faction;
    damage[i] = def.damage;
    damageType[i] = def.damageType;
    statusProfileId[i] = def.statusProfileId;
    halfX[i] = def.halfX;
    halfY[i] = def.halfY;
    offsetX[i] = def.offsetX;
    offsetY[i] = def.offsetY;
    dirX[i] = def.dirX;
    dirY[i] = def.dirY;
  }

  @override
  void onDenseAdded(int denseIndex) {
    owner.add(0);
    faction.add(Faction.player);
    damage.add(0);
    damageType.add(DamageType.physical);
    statusProfileId.add(StatusProfileId.none);
    halfX.add(0);
    halfY.add(0);
    offsetX.add(0);
    offsetY.add(0);
    dirX.add(1.0);
    dirY.add(0.0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    owner[removeIndex] = owner[lastIndex];
    faction[removeIndex] = faction[lastIndex];
    damage[removeIndex] = damage[lastIndex];
    damageType[removeIndex] = damageType[lastIndex];
    statusProfileId[removeIndex] = statusProfileId[lastIndex];
    halfX[removeIndex] = halfX[lastIndex];
    halfY[removeIndex] = halfY[lastIndex];
    offsetX[removeIndex] = offsetX[lastIndex];
    offsetY[removeIndex] = offsetY[lastIndex];
    dirX[removeIndex] = dirX[lastIndex];
    dirY[removeIndex] = dirY[lastIndex];

    owner.removeLast();
    faction.removeLast();
    damage.removeLast();
    damageType.removeLast();
    statusProfileId.removeLast();
    halfX.removeLast();
    halfY.removeLast();
    offsetX.removeLast();
    offsetY.removeLast();
    dirX.removeLast();
    dirY.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/lifetime_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

class LifetimeDef {
  const LifetimeDef({required this.ticksLeft});

  final int ticksLeft;
}

/// Tracks entity lifetime in ticks. Entity is despawned when `ticksLeft <= 0`.
class LifetimeStore extends SparseSet {
  final List<int> ticksLeft = <int>[];

  void add(EntityId entity, LifetimeDef def) {
    final i = addEntity(entity);
    ticksLeft[i] = def.ticksLeft;
  }

  @override
  void onDenseAdded(int denseIndex) {
    ticksLeft.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    ticksLeft[removeIndex] = ticksLeft[lastIndex];
    ticksLeft.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/mana_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

class ManaDef {
  const ManaDef({
    required this.mana,
    required this.manaMax,
    required this.regenPerSecond,
  });

  final double mana;
  final double manaMax;
  final double regenPerSecond;
}

/// Tracks current and max mana for spellcasters (Player).
class ManaStore extends SparseSet {
  final List<double> mana = <double>[];
  final List<double> manaMax = <double>[];
  final List<double> regenPerSecond = <double>[];

  void add(EntityId entity, ManaDef def) {
    final i = addEntity(entity);
    mana[i] = def.mana;
    manaMax[i] = def.manaMax;
    regenPerSecond[i] = def.regenPerSecond;
  }

  @override
  void onDenseAdded(int denseIndex) {
    mana.add(0);
    manaMax.add(0);
    regenPerSecond.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    mana[removeIndex] = mana[lastIndex];
    manaMax[removeIndex] = manaMax[lastIndex];
    regenPerSecond[removeIndex] = regenPerSecond[lastIndex];

    mana.removeLast();
    manaMax.removeLast();
    regenPerSecond.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/melee_intent_store.dart =====
import '../../combat/damage_type.dart';
import '../../combat/status/status.dart';
import '../entity_id.dart';
import '../sparse_set.dart';

class MeleeIntentDef {
  const MeleeIntentDef({
    required this.damage,
    required this.damageType,
    required this.statusProfileId,
    required this.halfX,
    required this.halfY,
    required this.offsetX,
    required this.offsetY,
    required this.dirX,
    required this.dirY,
    required this.activeTicks,
    required this.cooldownTicks,
    required this.staminaCost,
    required this.tick,
  });

  final double damage;
  final DamageType damageType;
  final StatusProfileId statusProfileId;
  final double halfX;
  final double halfY;
  final double offsetX;
  final double offsetY;
  final double dirX;
  final double dirY;
  final int activeTicks;
  final int cooldownTicks;
  final double staminaCost;

  /// Tick stamp for this intent.
  ///
  /// Use `-1` for "no intent". An intent is valid only when `tick == currentTick`.
  final int tick;
}

/// Per-entity "perform a melee attack this tick" intent.
///
/// This is written by player/enemy intent writers and consumed by `MeleeAttackSystem`.
///
/// **Usage**: Persistent component. Intents are set via `set()` with a `tick` stamp.
/// Old intents are ignored if `tick` matches current game tick.
class MeleeIntentStore extends SparseSet {
  final List<double> damage = <double>[];
  final List<DamageType> damageType = <DamageType>[];
  final List<StatusProfileId> statusProfileId = <StatusProfileId>[];
  final List<double> halfX = <double>[];
  final List<double> halfY = <double>[];
  final List<double> offsetX = <double>[];
  final List<double> offsetY = <double>[];
  final List<double> dirX = <double>[];
  final List<double> dirY = <double>[];
  final List<int> activeTicks = <int>[];
  final List<int> cooldownTicks = <int>[];
  final List<double> staminaCost = <double>[];
  final List<int> tick = <int>[];

  void add(EntityId entity) {
    addEntity(entity);
  }

  void set(EntityId entity, MeleeIntentDef def) {
    assert(
      has(entity),
      'MeleeIntentStore.set called for entity without MeleeIntentStore; add the component at spawn time.',
    );
    final i = indexOf(entity);
    damage[i] = def.damage;
    damageType[i] = def.damageType;
    statusProfileId[i] = def.statusProfileId;
    halfX[i] = def.halfX;
    halfY[i] = def.halfY;
    offsetX[i] = def.offsetX;
    offsetY[i] = def.offsetY;
    dirX[i] = def.dirX;
    dirY[i] = def.dirY;
    activeTicks[i] = def.activeTicks;
    cooldownTicks[i] = def.cooldownTicks;
    staminaCost[i] = def.staminaCost;
    tick[i] = def.tick;
  }

  @override
  void onDenseAdded(int denseIndex) {
    damage.add(0.0);
    damageType.add(DamageType.physical);
    statusProfileId.add(StatusProfileId.none);
    halfX.add(0.0);
    halfY.add(0.0);
    offsetX.add(0.0);
    offsetY.add(0.0);
    dirX.add(1.0);
    dirY.add(0.0);
    activeTicks.add(0);
    cooldownTicks.add(0);
    staminaCost.add(0.0);
    tick.add(-1);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    damage[removeIndex] = damage[lastIndex];
    damageType[removeIndex] = damageType[lastIndex];
    statusProfileId[removeIndex] = statusProfileId[lastIndex];
    halfX[removeIndex] = halfX[lastIndex];
    halfY[removeIndex] = halfY[lastIndex];
    offsetX[removeIndex] = offsetX[lastIndex];
    offsetY[removeIndex] = offsetY[lastIndex];
    dirX[removeIndex] = dirX[lastIndex];
    dirY[removeIndex] = dirY[lastIndex];
    activeTicks[removeIndex] = activeTicks[lastIndex];
    cooldownTicks[removeIndex] = cooldownTicks[lastIndex];
    staminaCost[removeIndex] = staminaCost[lastIndex];
    tick[removeIndex] = tick[lastIndex];

    damage.removeLast();
    damageType.removeLast();
    statusProfileId.removeLast();
    halfX.removeLast();
    halfY.removeLast();
    offsetX.removeLast();
    offsetY.removeLast();
    dirX.removeLast();
    dirY.removeLast();
    activeTicks.removeLast();
    cooldownTicks.removeLast();
    staminaCost.removeLast();
    tick.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/player/action_anim_store.dart =====
import '../../entity_id.dart';
import '../../sparse_set.dart';

/// Tracks the last action intent ticks for animation selection.
class ActionAnimStore extends SparseSet {
  final List<int> lastMeleeTick = <int>[];
  final List<int> lastCastTick = <int>[];

  void add(EntityId entity) {
    addEntity(entity);
  }

  @override
  void onDenseAdded(int denseIndex) {
    lastMeleeTick.add(-1);
    lastCastTick.add(-1);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    lastMeleeTick[removeIndex] = lastMeleeTick[lastIndex];
    lastCastTick[removeIndex] = lastCastTick[lastIndex];

    lastMeleeTick.removeLast();
    lastCastTick.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/player/gravity_control_store.dart =====
import '../../entity_id.dart';
import '../../sparse_set.dart';

/// Tracks entities that are temporarily ignoring global gravity.
///
/// Used by movement skills (e.g. Dash) to keep the player straight.
/// Entities are removed from this store when `suppressGravityTicksLeft` hits 0.
class GravityControlStore extends SparseSet {
  final List<int> suppressGravityTicksLeft = <int>[];

  void setSuppressForTicks(EntityId entity, int ticks) {
    if (ticks <= 0) {
      removeEntity(entity);
      return;
    }

    final i = addEntity(entity);
    suppressGravityTicksLeft[i] = ticks;
  }

  @override
  void onDenseAdded(int denseIndex) {
    suppressGravityTicksLeft.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    suppressGravityTicksLeft[removeIndex] = suppressGravityTicksLeft[lastIndex];
    suppressGravityTicksLeft.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/player/invulnerability_store.dart =====
import '../../entity_id.dart';
import '../../sparse_set.dart';

class InvulnerabilityDef {
  const InvulnerabilityDef({this.ticksLeft = 0});

  final int ticksLeft;
}

/// Per-entity invulnerability window after taking damage.
///
/// This store is only attached to the player (no enemy i-frames).
class InvulnerabilityStore extends SparseSet {
  final List<int> ticksLeft = <int>[];

  void add(EntityId entity, [InvulnerabilityDef def = const InvulnerabilityDef()]) {
    final i = addEntity(entity);
    ticksLeft[i] = def.ticksLeft;
  }

  @override
  void onDenseAdded(int denseIndex) {
    ticksLeft.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    ticksLeft[removeIndex] = ticksLeft[lastIndex];
    ticksLeft.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/player/last_damage_store.dart =====
import '../../../enemies/enemy_id.dart';
import '../../../events/game_event.dart';
import '../../../projectiles/projectile_id.dart';
import '../../../spells/spell_id.dart';
import '../../entity_id.dart';
import '../../sparse_set.dart';

/// Per-entity record of the last applied damage metadata.
///
/// Used to populate the "Game Over" screen with cause of death.
class LastDamageStore extends SparseSet {
  final List<DeathSourceKind> kind = <DeathSourceKind>[];
  final List<EnemyId> enemyId = <EnemyId>[];
  final List<bool> hasEnemyId = <bool>[];
  final List<ProjectileId> projectileId = <ProjectileId>[];
  final List<bool> hasProjectileId = <bool>[];
  final List<SpellId> spellId = <SpellId>[];
  final List<bool> hasSpellId = <bool>[];
  final List<double> amount = <double>[];
  final List<int> tick = <int>[];

  void add(EntityId entity) {
    addEntity(entity);
  }

  @override
  void onDenseAdded(int denseIndex) {
    kind.add(DeathSourceKind.unknown);
    enemyId.add(EnemyId.unocoDemon);
    hasEnemyId.add(false);
    projectileId.add(ProjectileId.iceBolt);
    hasProjectileId.add(false);
    spellId.add(SpellId.iceBolt);
    hasSpellId.add(false);
    amount.add(0.0);
    tick.add(-1);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    kind[removeIndex] = kind[lastIndex];
    enemyId[removeIndex] = enemyId[lastIndex];
    hasEnemyId[removeIndex] = hasEnemyId[lastIndex];
    projectileId[removeIndex] = projectileId[lastIndex];
    hasProjectileId[removeIndex] = hasProjectileId[lastIndex];
    spellId[removeIndex] = spellId[lastIndex];
    hasSpellId[removeIndex] = hasSpellId[lastIndex];
    amount[removeIndex] = amount[lastIndex];
    tick[removeIndex] = tick[lastIndex];

    kind.removeLast();
    enemyId.removeLast();
    hasEnemyId.removeLast();
    projectileId.removeLast();
    hasProjectileId.removeLast();
    spellId.removeLast();
    hasSpellId.removeLast();
    amount.removeLast();
    tick.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/player/movement_store.dart =====
import '../../../snapshots/enums.dart';
import '../../entity_id.dart';
import '../../sparse_set.dart';

/// Movement state for platformer-style motion (timers + grounded + facing).
///
/// Contains transient state counters for precise movement tech:
/// - Coyote time (jump after leaving ledge)
/// - Jump buffer (press before landing)
/// - Dash state
class MovementStore extends SparseSet {
  final List<int> coyoteTicksLeft = <int>[];
  final List<int> jumpBufferTicksLeft = <int>[];

  final List<int> dashTicksLeft = <int>[];
  final List<int> dashCooldownTicksLeft = <int>[];
  final List<double> dashDirX = <double>[];

  final List<Facing> facing = <Facing>[];

  void add(EntityId entity, {required Facing facing}) {
    final i = addEntity(entity);
    this.facing[i] = facing;
  }

  bool isDashing(EntityId entity) => dashTicksLeft[indexOf(entity)] > 0;

  @override
  void onDenseAdded(int denseIndex) {
    coyoteTicksLeft.add(0);
    jumpBufferTicksLeft.add(0);
    dashTicksLeft.add(0);
    dashCooldownTicksLeft.add(0);
    dashDirX.add(1);
    facing.add(Facing.right);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    coyoteTicksLeft[removeIndex] = coyoteTicksLeft[lastIndex];
    jumpBufferTicksLeft[removeIndex] = jumpBufferTicksLeft[lastIndex];
    dashTicksLeft[removeIndex] = dashTicksLeft[lastIndex];
    dashCooldownTicksLeft[removeIndex] = dashCooldownTicksLeft[lastIndex];
    dashDirX[removeIndex] = dashDirX[lastIndex];
    facing[removeIndex] = facing[lastIndex];

    coyoteTicksLeft.removeLast();
    jumpBufferTicksLeft.removeLast();
    dashTicksLeft.removeLast();
    dashCooldownTicksLeft.removeLast();
    dashDirX.removeLast();
    facing.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/player/player_input_store.dart =====
import '../../entity_id.dart';
import '../../sparse_set.dart';

/// Per-tick player input (authoritative commands decoded by the core).
///
/// This is reset/overwritten each tick by `GameCore.applyCommands`.
/// All actions are boolean or axis values used by `MovementSystem` and decision systems.
class PlayerInputStore extends SparseSet {
  final List<double> moveAxis = <double>[];
  final List<bool> jumpPressed = <bool>[];
  final List<bool> dashPressed = <bool>[];
  final List<bool> attackPressed = <bool>[];
  final List<double> projectileAimDirX = <double>[];
  final List<double> projectileAimDirY = <double>[];
  final List<double> meleeAimDirX = <double>[];
  final List<double> meleeAimDirY = <double>[];
  final List<bool> castPressed = <bool>[];
  final List<bool> rangedPressed = <bool>[];
  final List<double> rangedAimDirX = <double>[];
  final List<double> rangedAimDirY = <double>[];

  void add(EntityId entity) {
    addEntity(entity);
  }

  void resetTickInputs(EntityId entity) {
    final i = indexOf(entity);
    moveAxis[i] = 0;
    jumpPressed[i] = false;
    dashPressed[i] = false;
    attackPressed[i] = false;
    projectileAimDirX[i] = 0;
    projectileAimDirY[i] = 0;
    meleeAimDirX[i] = 0;
    meleeAimDirY[i] = 0;
    castPressed[i] = false;
    rangedPressed[i] = false;
    rangedAimDirX[i] = 0;
    rangedAimDirY[i] = 0;
  }

  @override
  void onDenseAdded(int denseIndex) {
    moveAxis.add(0);
    jumpPressed.add(false);
    dashPressed.add(false);
    attackPressed.add(false);
    projectileAimDirX.add(0);
    projectileAimDirY.add(0);
    meleeAimDirX.add(0);
    meleeAimDirY.add(0);
    castPressed.add(false);
    rangedPressed.add(false);
    rangedAimDirX.add(0);
    rangedAimDirY.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    moveAxis[removeIndex] = moveAxis[lastIndex];
    jumpPressed[removeIndex] = jumpPressed[lastIndex];
    dashPressed[removeIndex] = dashPressed[lastIndex];
    attackPressed[removeIndex] = attackPressed[lastIndex];
    projectileAimDirX[removeIndex] = projectileAimDirX[lastIndex];
    projectileAimDirY[removeIndex] = projectileAimDirY[lastIndex];
    meleeAimDirX[removeIndex] = meleeAimDirX[lastIndex];
    meleeAimDirY[removeIndex] = meleeAimDirY[lastIndex];
    castPressed[removeIndex] = castPressed[lastIndex];
    rangedPressed[removeIndex] = rangedPressed[lastIndex];
    rangedAimDirX[removeIndex] = rangedAimDirX[lastIndex];
    rangedAimDirY[removeIndex] = rangedAimDirY[lastIndex];

    moveAxis.removeLast();
    jumpPressed.removeLast();
    dashPressed.removeLast();
    attackPressed.removeLast();
    projectileAimDirX.removeLast();
    projectileAimDirY.removeLast();
    meleeAimDirX.removeLast();
    meleeAimDirY.removeLast();
    castPressed.removeLast();
    rangedPressed.removeLast();
    rangedAimDirX.removeLast();
    rangedAimDirY.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/projectile_store.dart =====
import '../../combat/damage_type.dart';
import '../../combat/faction.dart';
import '../../combat/status/status.dart';
import '../../projectiles/projectile_id.dart';
import '../entity_id.dart';
import '../sparse_set.dart';

class ProjectileDef {
  const ProjectileDef({
    required this.projectileId,
    required this.faction,
    required this.owner,
    required this.dirX,
    required this.dirY,
    required this.speedUnitsPerSecond,
    required this.damage,
    required this.damageType,
    required this.statusProfileId,
    this.usePhysics = false,
  });

  final ProjectileId projectileId;
  final Faction faction;
  final EntityId owner;
  final double dirX;
  final double dirY;
  final double speedUnitsPerSecond;
  final double damage;
  final DamageType damageType;
  final StatusProfileId statusProfileId;

  /// If true, this projectile is moved by core physics (GravitySystem +
  /// CollisionSystem) rather than [ProjectileSystem].
  final bool usePhysics;
}

/// Immutable metadata for active projectiles.
///
/// Combines with `Transform` (for position) and `ColliderAabb` (for hit detection).
class ProjectileStore extends SparseSet {
  final List<ProjectileId> projectileId = <ProjectileId>[];
  final List<Faction> faction = <Faction>[];
  final List<EntityId> owner = <EntityId>[];
  final List<double> dirX = <double>[];
  final List<double> dirY = <double>[];
  final List<double> speedUnitsPerSecond = <double>[];
  final List<double> damage = <double>[];
  final List<DamageType> damageType = <DamageType>[];
  final List<StatusProfileId> statusProfileId = <StatusProfileId>[];
  final List<bool> usePhysics = <bool>[];

  void add(EntityId entity, ProjectileDef def) {
    final i = addEntity(entity);
    projectileId[i] = def.projectileId;
    faction[i] = def.faction;
    owner[i] = def.owner;
    dirX[i] = def.dirX;
    dirY[i] = def.dirY;
    speedUnitsPerSecond[i] = def.speedUnitsPerSecond;
    damage[i] = def.damage;
    damageType[i] = def.damageType;
    statusProfileId[i] = def.statusProfileId;
    usePhysics[i] = def.usePhysics;
  }

  @override
  void onDenseAdded(int denseIndex) {
    projectileId.add(ProjectileId.iceBolt);
    faction.add(Faction.player);
    owner.add(0);
    dirX.add(1.0);
    dirY.add(0.0);
    speedUnitsPerSecond.add(0.0);
    damage.add(0.0);
    damageType.add(DamageType.physical);
    statusProfileId.add(StatusProfileId.none);
    usePhysics.add(false);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    projectileId[removeIndex] = projectileId[lastIndex];
    faction[removeIndex] = faction[lastIndex];
    owner[removeIndex] = owner[lastIndex];
    dirX[removeIndex] = dirX[lastIndex];
    dirY[removeIndex] = dirY[lastIndex];
    speedUnitsPerSecond[removeIndex] = speedUnitsPerSecond[lastIndex];
    damage[removeIndex] = damage[lastIndex];
    damageType[removeIndex] = damageType[lastIndex];
    statusProfileId[removeIndex] = statusProfileId[lastIndex];
    usePhysics[removeIndex] = usePhysics[lastIndex];

    projectileId.removeLast();
    faction.removeLast();
    owner.removeLast();
    dirX.removeLast();
    dirY.removeLast();
    speedUnitsPerSecond.removeLast();
    damage.removeLast();
    damageType.removeLast();
    statusProfileId.removeLast();
    usePhysics.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/ranged_weapon_intent_store.dart =====
import '../../weapons/ranged_weapon_id.dart';
import '../entity_id.dart';
import '../sparse_set.dart';

class RangedWeaponIntentDef {
  const RangedWeaponIntentDef({
    required this.weaponId,
    required this.dirX,
    required this.dirY,
    required this.fallbackDirX,
    required this.fallbackDirY,
    required this.originOffset,
    required this.tick,
  });

  final RangedWeaponId weaponId;
  final double dirX;
  final double dirY;
  final double fallbackDirX;
  final double fallbackDirY;
  final double originOffset;

  /// Tick stamp for this intent.
  ///
  /// Use `-1` for "no intent". An intent is valid only when `tick == currentTick`.
  final int tick;
}

/// Per-entity "fire a ranged weapon this tick" intent.
///
/// Written by player input and consumed by `RangedWeaponAttackSystem`.
class RangedWeaponIntentStore extends SparseSet {
  final List<RangedWeaponId> weaponId = <RangedWeaponId>[];
  final List<double> dirX = <double>[];
  final List<double> dirY = <double>[];
  final List<double> fallbackDirX = <double>[];
  final List<double> fallbackDirY = <double>[];
  final List<double> originOffset = <double>[];
  final List<int> tick = <int>[];

  void add(EntityId entity) {
    addEntity(entity);
  }

  void set(EntityId entity, RangedWeaponIntentDef def) {
    assert(
      has(entity),
      'RangedWeaponIntentStore.set called for entity without RangedWeaponIntentStore; add the component at spawn time.',
    );
    final i = indexOf(entity);
    weaponId[i] = def.weaponId;
    dirX[i] = def.dirX;
    dirY[i] = def.dirY;
    fallbackDirX[i] = def.fallbackDirX;
    fallbackDirY[i] = def.fallbackDirY;
    originOffset[i] = def.originOffset;
    tick[i] = def.tick;
  }

  @override
  void onDenseAdded(int denseIndex) {
    weaponId.add(RangedWeaponId.bow);
    dirX.add(0.0);
    dirY.add(0.0);
    fallbackDirX.add(1.0);
    fallbackDirY.add(0.0);
    originOffset.add(0.0);
    tick.add(-1);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    weaponId[removeIndex] = weaponId[lastIndex];
    dirX[removeIndex] = dirX[lastIndex];
    dirY[removeIndex] = dirY[lastIndex];
    fallbackDirX[removeIndex] = fallbackDirX[lastIndex];
    fallbackDirY[removeIndex] = fallbackDirY[lastIndex];
    originOffset[removeIndex] = originOffset[lastIndex];
    tick[removeIndex] = tick[lastIndex];

    weaponId.removeLast();
    dirX.removeLast();
    dirY.removeLast();
    fallbackDirX.removeLast();
    fallbackDirY.removeLast();
    originOffset.removeLast();
    tick.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/restoration_item_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

enum RestorationStat {
  health,
  mana,
  stamina,
}

class RestorationItemDef {
  const RestorationItemDef({required this.stat});

  final RestorationStat stat;
}

/// SoA store for restoration item metadata (health/mana/stamina).
class RestorationItemStore extends SparseSet {
  final List<RestorationStat> stat = <RestorationStat>[];

  void add(EntityId entity, RestorationItemDef def) {
    final i = addEntity(entity);
    stat[i] = def.stat;
  }

  @override
  void onDenseAdded(int denseIndex) {
    stat.add(RestorationStat.health);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    stat[removeIndex] = stat[lastIndex];
    stat.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/spell_origin_store.dart =====
import '../../spells/spell_id.dart';
import '../entity_id.dart';
import '../sparse_set.dart';

class SpellOriginDef {
  const SpellOriginDef({required this.spellId});

  final SpellId spellId;
}

/// Metadata for spell projectile entities (spawned by CastIntent).
class SpellOriginStore extends SparseSet {
  final List<SpellId> spellId = <SpellId>[];

  void add(EntityId entity, SpellOriginDef def) {
    final i = addEntity(entity);
    spellId[i] = def.spellId;
  }

  @override
  void onDenseAdded(int denseIndex) {
    spellId.add(SpellId.iceBolt);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    spellId[removeIndex] = spellId[lastIndex];
    spellId.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/stamina_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

class StaminaDef {
  const StaminaDef({
    required this.stamina,
    required this.staminaMax,
    required this.regenPerSecond,
  });

  final double stamina;
  final double staminaMax;
  final double regenPerSecond;
}

/// Tracks stamina for dashing and melee attacks.
class StaminaStore extends SparseSet {
  final List<double> stamina = <double>[];
  final List<double> staminaMax = <double>[];
  final List<double> regenPerSecond = <double>[];

  void add(EntityId entity, StaminaDef def) {
    final i = addEntity(entity);
    stamina[i] = def.stamina;
    staminaMax[i] = def.staminaMax;
    regenPerSecond[i] = def.regenPerSecond;
  }

  @override
  void onDenseAdded(int denseIndex) {
    stamina.add(0);
    staminaMax.add(0);
    regenPerSecond.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    stamina[removeIndex] = stamina[lastIndex];
    staminaMax[removeIndex] = staminaMax[lastIndex];
    regenPerSecond[removeIndex] = regenPerSecond[lastIndex];

    stamina.removeLast();
    staminaMax.removeLast();
    regenPerSecond.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/status/bleed_store.dart =====
import '../../entity_id.dart';
import '../../sparse_set.dart';

class BleedDef {
  const BleedDef({
    required this.ticksLeft,
    required this.periodTicks,
    required this.damagePerTick,
  }) : periodTicksLeft = periodTicks;

  final int ticksLeft;
  final int periodTicks;
  final int periodTicksLeft;
  final double damagePerTick;
}

/// Active bleed (damage-over-time) status.
class BleedStore extends SparseSet {
  final List<int> ticksLeft = <int>[];
  final List<int> periodTicks = <int>[];
  final List<int> periodTicksLeft = <int>[];
  final List<double> damagePerTick = <double>[];

  void add(EntityId entity, BleedDef def) {
    final i = addEntity(entity);
    ticksLeft[i] = def.ticksLeft;
    periodTicks[i] = def.periodTicks;
    periodTicksLeft[i] = def.periodTicksLeft;
    damagePerTick[i] = def.damagePerTick;
  }

  @override
  void onDenseAdded(int denseIndex) {
    ticksLeft.add(0);
    periodTicks.add(1);
    periodTicksLeft.add(1);
    damagePerTick.add(0.0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    ticksLeft[removeIndex] = ticksLeft[lastIndex];
    periodTicks[removeIndex] = periodTicks[lastIndex];
    periodTicksLeft[removeIndex] = periodTicksLeft[lastIndex];
    damagePerTick[removeIndex] = damagePerTick[lastIndex];

    ticksLeft.removeLast();
    periodTicks.removeLast();
    periodTicksLeft.removeLast();
    damagePerTick.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/status/burn_store.dart =====
import '../../entity_id.dart';
import '../../sparse_set.dart';

class BurnDef {
  const BurnDef({
    required this.ticksLeft,
    required this.periodTicks,
    required this.damagePerTick,
  }) : periodTicksLeft = periodTicks;

  final int ticksLeft;
  final int periodTicks;
  final int periodTicksLeft;
  final double damagePerTick;
}

/// Active burn (damage-over-time) status.
class BurnStore extends SparseSet {
  final List<int> ticksLeft = <int>[];
  final List<int> periodTicks = <int>[];
  final List<int> periodTicksLeft = <int>[];
  final List<double> damagePerTick = <double>[];

  void add(EntityId entity, BurnDef def) {
    final i = addEntity(entity);
    ticksLeft[i] = def.ticksLeft;
    periodTicks[i] = def.periodTicks;
    periodTicksLeft[i] = def.periodTicksLeft;
    damagePerTick[i] = def.damagePerTick;
  }

  @override
  void onDenseAdded(int denseIndex) {
    ticksLeft.add(0);
    periodTicks.add(1);
    periodTicksLeft.add(1);
    damagePerTick.add(0.0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    ticksLeft[removeIndex] = ticksLeft[lastIndex];
    periodTicks[removeIndex] = periodTicks[lastIndex];
    periodTicksLeft[removeIndex] = periodTicksLeft[lastIndex];
    damagePerTick[removeIndex] = damagePerTick[lastIndex];

    ticksLeft.removeLast();
    periodTicks.removeLast();
    periodTicksLeft.removeLast();
    damagePerTick.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/status/slow_store.dart =====
import '../../entity_id.dart';
import '../../sparse_set.dart';

class SlowDef {
  const SlowDef({required this.ticksLeft, required this.magnitude});

  final int ticksLeft;
  final double magnitude;
}

/// Active slow status (movement speed multiplier).
class SlowStore extends SparseSet {
  final List<int> ticksLeft = <int>[];
  final List<double> magnitude = <double>[];

  void add(EntityId entity, SlowDef def) {
    final i = addEntity(entity);
    ticksLeft[i] = def.ticksLeft;
    magnitude[i] = def.magnitude;
  }

  @override
  void onDenseAdded(int denseIndex) {
    ticksLeft.add(0);
    magnitude.add(0.0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    ticksLeft[removeIndex] = ticksLeft[lastIndex];
    magnitude[removeIndex] = magnitude[lastIndex];
    ticksLeft.removeLast();
    magnitude.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/transform_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

/// SoA store for `Transform` (position + velocity).
///
/// This is the "hot" store accessed by almost every system.
class TransformStore extends SparseSet {
  final List<double> posX = <double>[];
  final List<double> posY = <double>[];
  final List<double> velX = <double>[];
  final List<double> velY = <double>[];

  void add(
    EntityId entity, {
    required double posX,
    required double posY,
    required double velX,
    required double velY,
  }) {
    final i = addEntity(entity);
    this.posX[i] = posX;
    this.posY[i] = posY;
    this.velX[i] = velX;
    this.velY[i] = velY;
  }

  void setPosXY(EntityId entity, double x, double y) {
    final i = indexOf(entity);
    posX[i] = x;
    posY[i] = y;
  }

  void setVelXY(EntityId entity, double x, double y) {
    final i = indexOf(entity);
    velX[i] = x;
    velY[i] = y;
  }

  @override
  void onDenseAdded(int denseIndex) {
    posX.add(0);
    posY.add(0);
    velX.add(0);
    velY.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    posX[removeIndex] = posX[lastIndex];
    posY[removeIndex] = posY[lastIndex];
    velX[removeIndex] = velX[lastIndex];
    velY[removeIndex] = velY[lastIndex];

    posX.removeLast();
    posY.removeLast();
    velX.removeLast();
    velY.removeLast();
  }
}


===== FILE: lib/core/ecs/systems/collectible_system.dart =====
import '../hit/aabb_hit_utils.dart';
import '../entity_id.dart';
import '../world.dart';
import '../../tuning/collectible_tuning.dart';

/// System responsible for updating collectible entities (e.g. coins).
///
/// It handles:
/// 1. Despawning collectibles that have fallen behind the camera.
/// 2. Detecting collisions between the player and collectibles.
/// 3. Triggering collection callbacks and destroying collected entities.
class CollectibleSystem {
  // Recycled list to avoid per-frame allocations for destruction.
  final List<EntityId> _toDespawn = <EntityId>[];

  /// Updates all collectibles.
  ///
  /// [cameraLeft] is the world-space X coordinate of the left edge of the camera,
  /// used for culling entities that are no longer visible.
  void step(
    EcsWorld world, {
    required EntityId player,
    required double cameraLeft,
    required CollectibleTuning tuning,
    required void Function(int value) onCollected,
  }) {
    final collectibles = world.collectible;
    if (collectibles.denseEntities.isEmpty) return;

    // Pre-resolve player components to avoid looking them up for every collectible.
    final playerTi = world.transform.tryIndexOf(player);
    final playerAi = world.colliderAabb.tryIndexOf(player);
    final canCollect = playerTi != null && playerAi != null;

    _toDespawn.clear();

    final despawnLimit = cameraLeft - tuning.despawnBehindCameraMargin;
    for (var ci = 0; ci < collectibles.denseEntities.length; ci += 1) {
      final e = collectibles.denseEntities[ci];
      final ti = world.transform.tryIndexOf(e);
      final ai = world.colliderAabb.tryIndexOf(e);
      // Skip if entity is missing required components (malformed entity).
      if (ti == null || ai == null) continue;

      final centerX = world.transform.posX[ti] + world.colliderAabb.offsetX[ai];
      
      // 1. Culling: Despawn if far behind the camera.
      if (centerX < despawnLimit) {
        _toDespawn.add(e);
        continue;
      }

      // 2. Collection: Check AABB overlap with player.
      if (canCollect) {
        final overlaps = aabbOverlapsWorldColliders(
          world,
          aTransformIndex: ti,
          aAabbIndex: ai,
          bTransformIndex: playerTi,
          bAabbIndex: playerAi,
        );
        if (overlaps) {
          onCollected(collectibles.value[ci]);
          _toDespawn.add(e);
        }
      }
    }

    // Apply deferred destruction.
    for (final e in _toDespawn) {
      world.destroyEntity(e);
    }
  }
}


===== FILE: lib/core/ecs/systems/collision_system.dart =====
import '../../collision/static_world_geometry_index.dart';
import '../../tuning/movement_tuning.dart';
import '../queries.dart';
import '../stores/body_store.dart';
import '../world.dart';

/// Handles physics integration and collision resolution for dynamic entities.
///
/// This system operates in three main steps:
/// 1.  **Integration**: Updates position based on velocity (`pos += vel * dt`).
/// 2.  **Vertical Resolution**:
///     -   Checks floors (ground segments and one-way platforms).
///     -   Checks ceilings (if not ignored).
///     -   Snaps position to the contact surface and zeroes vertical velocity.
/// 3.  **Horizontal Resolution**:
///     -   Checks walls in the direction of movement.
///     -   Stops horizontal movement upon collision.
///
/// Order within a tick:
/// - PlayerMovementSystem computes control velocities (jump/dash/horizontal).
/// - GravitySystem applies vertical gravity acceleration.
/// - CollisionSystem integrates `pos += vel * dt`, resolves collisions, and
///   finalizes grounded/contact state for the tick.
class CollisionSystem {
  // Reusable buffers to avoid allocations during collision queries.
  final List<StaticSolid> _queryBuffer = <StaticSolid>[];
  final List<StaticGroundSegment> _groundSegBuffer = <StaticGroundSegment>[];

  /// Runs the physics update for one tick.
  ///
  /// [tuning] provides the delta time [dtSeconds].
  /// [staticWorld] is the spatial index for static geometry (floors, walls).
  void step(
    EcsWorld world,
    MovementTuningDerived tuning, {
    required StaticWorldGeometryIndex staticWorld,
  }) {
    final dt = tuning.dtSeconds;
    // Epsilon for floating point comparisons and overlap tolerance.
    const eps = 1e-3;

    EcsQueries.forColliders(world, (e, ti, bi, coli, aabbi) {
      if (!world.body.enabled[bi]) return;

      // Reset per-tick collision flags (grounded, hitCeiling, etc.).
      world.collision.resetTick(e);

      // Kinematic bodies are excluded from physics integration/resolution.
      // They are moved manually by other systems.
      if (world.body.isKinematic[bi]) {
        return;
      }


      final prevPosX = world.transform.posX[ti];
      final prevPosY = world.transform.posY[ti];

      // Integrate position from the current velocity.
      world.transform.posX[ti] += world.transform.velX[ti] * dt;
      world.transform.posY[ti] += world.transform.velY[ti] * dt;

      final halfX = world.colliderAabb.halfX[aabbi];
      final halfY = world.colliderAabb.halfY[aabbi];
      final offsetX = world.colliderAabb.offsetX[aabbi];
      final offsetY = world.colliderAabb.offsetY[aabbi];

      final prevCenterX = prevPosX + offsetX;
      final prevCenterY = prevPosY + offsetY;
      final prevBottom = prevCenterY + halfY;

      final centerX = world.transform.posX[ti] + offsetX;
      final centerY = world.transform.posY[ti] + offsetY;
      final minX = centerX - halfX;
      final maxX = centerX + halfX;
      final bottom = centerY + halfY;
      final top = centerY - halfY;

      // Vertical top resolution (one-way platforms): only while moving downward.
      double? bestTopY;
      if (world.transform.velY[ti] > 0) {
        _queryBuffer.clear();
        staticWorld.queryTops(minX + eps, maxX - eps, _queryBuffer);
        for (final solid in _queryBuffer) {
          final topY = solid.minY;
          final crossesTop =
              prevBottom <= topY + eps && bottom >= topY - eps;
          if (!crossesTop) continue;

          if (bestTopY == null || topY < bestTopY) {
            bestTopY = topY;
          }
        }
      }

      // Check ceilings.
      // Only resolve if moving upward and the body collides with ceilings.
      double? bestBottomY;
      if (world.transform.velY[ti] < 0 && !world.body.ignoreCeilings[bi]) {
        final prevTop = prevCenterY - halfY;
        _queryBuffer.clear();
        staticWorld.queryBottoms(minX + eps, maxX - eps, _queryBuffer);
        for (final solid in _queryBuffer) {
          final bottomY = solid.maxY;
          // Check if we crossed the surface from below to above.
          final crossesBottom =
              prevTop >= bottomY - eps && top <= bottomY + eps;
          if (!crossesBottom) continue;

          // Keep the lowest ceiling (maximum Y) encountered.
          if (bestBottomY == null || bottomY > bestBottomY) {
            bestBottomY = bottomY;
          }
        }
      }

      // Check Ground Segments (optimized horizontal strips for ground).
      // Treated same as one-way platforms.
      if (world.transform.velY[ti] > 0) {
        _groundSegBuffer.clear();
        staticWorld.queryGroundSegments(minX + eps, maxX - eps, _groundSegBuffer);
        for (final seg in _groundSegBuffer) {
          final groundTopY = seg.topY;
          final crossesTop =
              prevBottom <= groundTopY + eps && bottom >= groundTopY - eps;
          if (!crossesTop) continue;
          
          if (bestTopY == null || groundTopY < bestTopY) {
            bestTopY = groundTopY;
          }
        }
      }

      // Apply vertical resolution.
      if (bestTopY != null) {
        // Landed on floor.
        world.transform.posY[ti] = bestTopY - offsetY - halfY;
        if (world.transform.velY[ti] > 0) {
          world.transform.velY[ti] = 0;
        }
        world.collision.grounded[coli] = true;
      } else if (bestBottomY != null) {
        // Hit ceiling.
        world.transform.posY[ti] = bestBottomY - offsetY + halfY;
        if (world.transform.velY[ti] < 0) {
          world.transform.velY[ti] = 0;
        }
        world.collision.hitCeiling[coli] = true;
      }

      // Horizontal Resolution
      // Recompute AABB after vertical resolution for stable side overlap tests.
      // This prevents "snagging" on walls due to slight vertical overlap that should have been resolved.
      final resolvedCenterX = world.transform.posX[ti] + offsetX;
      final resolvedCenterY = world.transform.posY[ti] + offsetY;
      final resolvedMinY = resolvedCenterY - halfY;
      final resolvedMaxY = resolvedCenterY + halfY;

      // Resolve against static walls.
      final sideMask = world.body.sideMask[bi];
      final velX = world.transform.velX[ti];

      if (velX > 0 && (sideMask &  BodyDef.sideRight) != 0) {
        // Moving Right.
        final prevRight = prevCenterX + halfX;
        final right = resolvedCenterX + halfX;
        double? bestWallX;

        _queryBuffer.clear();
        staticWorld.queryLeftWalls(prevRight - eps, right + eps, _queryBuffer);

        for (final solid in _queryBuffer) {
          // Filter by vertical overlap (y-axis).
          final overlapY =
              resolvedMaxY > solid.minY + eps && resolvedMinY < solid.maxY - eps;
          if (!overlapY) continue;

          final wallX = solid.minX;
          // Check if we crossed the wall line.
          final crossesWall = prevRight <= wallX + eps && right >= wallX - eps;
          if (!crossesWall) continue;

          if (bestWallX == null || wallX < bestWallX) {
            bestWallX = wallX;
          }
        }

        if (bestWallX != null) {
          // Hit right wall.
          world.transform.posX[ti] = bestWallX - offsetX - halfX;
          world.transform.velX[ti] = 0;
          world.collision.hitRight[coli] = true;
        }
      } else if (velX < 0 && (sideMask & BodyDef.sideLeft) != 0) {
        // Moving Left.
        final prevLeft = prevCenterX - halfX;
        final left = resolvedCenterX - halfX;
        double? bestWallX;

        _queryBuffer.clear();
        staticWorld.queryRightWalls(left - eps, prevLeft + eps, _queryBuffer);

        for (final solid in _queryBuffer) {
          // Filter by vertical overlap (y-axis).
          final overlapY =
              resolvedMaxY > solid.minY + eps && resolvedMinY < solid.maxY - eps;
          if (!overlapY) continue;

          final wallX = solid.maxX;
          // Check if we crossed the wall line from right to left.
          final crossesWall = prevLeft >= wallX - eps && left <= wallX + eps;
          if (!crossesWall) continue;

          // Keep the rightmost wall (maximum X) encountered.
          if (bestWallX == null || wallX > bestWallX) {
            bestWallX = wallX;
          }
        }

        if (bestWallX != null) {
          // Hit left wall.
          world.transform.posX[ti] = bestWallX - offsetX + halfX;
          world.transform.velX[ti] = 0;
          world.collision.hitLeft[coli] = true;
        }
      }
    });
  }
}


===== FILE: lib/core/ecs/systems/cooldown_system.dart =====
import '../world.dart';

/// Decrements active action cooldowns (melee, cast) for all entities each tick.
class CooldownSystem {
  /// Runs the cooldown logic.
  ///
  /// Iterates over all entities with a [CooldownStore] and reduces their
  /// remaining tick counts by 1, clamping at 0.
  void step(EcsWorld world) {
    final store = world.cooldown;
    // Iterate over dense arrays for cache efficiency.
    for (var i = 0; i < store.denseEntities.length; i += 1) {
      if (store.castCooldownTicksLeft[i] > 0) {
        store.castCooldownTicksLeft[i] -= 1;
      }
      if (store.meleeCooldownTicksLeft[i] > 0) {
        store.meleeCooldownTicksLeft[i] -= 1;
      }
      if (store.rangedWeaponCooldownTicksLeft[i] > 0) {
        store.rangedWeaponCooldownTicksLeft[i] -= 1;
      }
    }
  }
}


===== FILE: lib/core/ecs/systems/damage_system.dart =====
import '../../combat/damage.dart';
import '../../combat/status/status.dart';
import '../../util/double_math.dart';
import '../world.dart';

/// Central system for validating and applying damage to entities.
///
/// Handles:
/// 1.  Processing queued [DamageRequest]s.
/// 2.  Checking invulnerability frames (i-frames).
/// 3.  Reducing [HealthStore] HP.
/// 4.  Recording [LastDamageStore] details (source, amount) for UI/logic.
/// 5.  Applying post-hit invulnerability.
class DamageSystem {
  DamageSystem({required this.invulnerabilityTicksOnHit});

  /// Number of ticks an entity is invulnerable after taking damage.
  final int invulnerabilityTicksOnHit;
  
  // Buffer for damage requests to be processed in `step`.
  final List<DamageRequest> _pending = <DamageRequest>[];

  /// Queues a damage request for the next frame.
  ///
  /// Requests with `amount <= 0` are ignored immediately.
  void queue(DamageRequest request) {
    if (request.amount <= 0 && request.statusProfileId == StatusProfileId.none) {
      return;
    }
    _pending.add(request);
  }

  /// Processes all pending damage requests.
  void step(
    EcsWorld world, {
    required int currentTick,
    void Function(StatusRequest request)? queueStatus,
  }) {
    if (_pending.isEmpty) return;

    final health = world.health;
    final invuln = world.invulnerability;
    final lastDamage = world.lastDamage;
    final resistance = world.damageResistance;
    
    for (final req in _pending) {
      // 1. Resolve Health component.
      // Use tryIndexOf (returns int?) to combine "has check" and "get index"
      // into a single lookup for performance.
      final hi = health.tryIndexOf(req.target);
      if (hi == null) continue;

      // 2. Resolve Invulnerability component (optional).
      final ii = invuln.tryIndexOf(req.target);

      // Invulnerability applies only to entities that have `InvulnerabilityStore`
      // attached.
      if (ii != null && invuln.ticksLeft[ii] > 0) {
        continue; // Damage negated.
      }

      // 3. Apply resistance/vulnerability modifier.
      final ri = resistance.tryIndexOf(req.target);
      final mod = ri == null ? 0.0 : resistance.modForIndex(ri, req.damageType);
      var appliedAmount = req.amount * (1.0 + mod);
      if (appliedAmount < 0.0) appliedAmount = 0.0;

      final prevHp = health.hp[hi];
      final nextHp = clampDouble(
        prevHp - appliedAmount,
        0.0,
        health.hpMax[hi],
      );
      health.hp[hi] = nextHp;

      // 4. Record Last Damage details (if store exists).
      // Only useful if damage was actually taken.
      if (nextHp < prevHp) {
        final li = lastDamage.tryIndexOf(req.target);
        if (li != null) {
          lastDamage.kind[li] = req.sourceKind;
          lastDamage.amount[li] = appliedAmount;
          lastDamage.tick[li] = currentTick;

          if (req.sourceEnemyId != null) {
            lastDamage.enemyId[li] = req.sourceEnemyId!;
            lastDamage.hasEnemyId[li] = true;
          } else {
            lastDamage.hasEnemyId[li] = false;
          }

          if (req.sourceProjectileId != null) {
            lastDamage.projectileId[li] = req.sourceProjectileId!;
            lastDamage.hasProjectileId[li] = true;
          } else {
            lastDamage.hasProjectileId[li] = false;
          }

          if (req.sourceSpellId != null) {
            lastDamage.spellId[li] = req.sourceSpellId!;
            lastDamage.hasSpellId[li] = true;
          } else {
            lastDamage.hasSpellId[li] = false;
          }
        }
      }

      // 5. Queue status effects (independent of HP loss).
      if (queueStatus != null && req.statusProfileId != StatusProfileId.none) {
        queueStatus(
          StatusRequest(
            target: req.target,
            profileId: req.statusProfileId,
            damageType: req.damageType,
          ),
        );
      }

      // 6. Apply new Invulnerability frames.
      if (invulnerabilityTicksOnHit > 0 && ii != null) {
        invuln.ticksLeft[ii] = invulnerabilityTicksOnHit;
      }
    }
    _pending.clear();
  }
}


===== FILE: lib/core/ecs/systems/enemy_cull_system.dart =====
import '../../tuning/track_tuning.dart';
import '../entity_id.dart';
import '../world.dart';

/// Despawns enemies that are behind the camera or below the ground.
///
/// Rules:
/// - Behind: enemy maxX < cameraLeft - tuning.cullBehindMargin
/// - Below:  enemy bottomY > groundTopY + tuning.enemyCullBelowGroundOffsetY
class EnemyCullSystem {
  final List<EntityId> _toDespawn = <EntityId>[];

  void step(
    EcsWorld world, {
    required double cameraLeft,
    required double groundTopY,
    required TrackTuning tuning,
  }) {
    final enemies = world.enemy;
    if (enemies.denseEntities.isEmpty) return;

    _toDespawn.clear();

    final despawnX = cameraLeft - tuning.cullBehindMargin;
    final despawnY = groundTopY + tuning.enemyCullBelowGroundOffsetY;

    // 1. identify enemies to despawn
    for (var i = 0; i < enemies.denseEntities.length; i += 1) {
      final e = enemies.denseEntities[i];

      final ti = world.transform.tryIndexOf(e);
      if (ti == null) {
        // Orphan enemy, kill it.
        _toDespawn.add(e);
        continue;
      }

      // Compute bounds using ColliderAabb when present.
      var cx = world.transform.posX[ti];
      var cy = world.transform.posY[ti];
      var maxX = cx;
      var bottomY = cy;

      final ci = world.colliderAabb.tryIndexOf(e);
      if (ci != null) {
        cx += world.colliderAabb.offsetX[ci];
        cy += world.colliderAabb.offsetY[ci];
        maxX = cx + world.colliderAabb.halfX[ci];
        bottomY = cy + world.colliderAabb.halfY[ci];
      }

      if (maxX < despawnX || bottomY > despawnY) {
        _toDespawn.add(e);
      }
    }

    if (_toDespawn.isEmpty) return;

    // 2. destroy
    for (final e in _toDespawn) {
      world.destroyEntity(e);
    }
  }
}


===== FILE: lib/core/ecs/systems/enemy_system.dart =====
import 'dart:math';

import 'package:walkscape_runner/core/ecs/entity_id.dart';

import '../../enemies/enemy_catalog.dart';
import '../../enemies/enemy_id.dart';
import '../../combat/damage_type.dart';
import '../../combat/status/status.dart';
import '../../snapshots/enums.dart';
import '../../projectiles/projectile_catalog.dart';
import '../../spells/spell_catalog.dart';
import '../../tuning/flying_enemy_tuning.dart';
import '../../tuning/ground_enemy_tuning.dart';
import '../../util/deterministic_rng.dart';
import '../../util/double_math.dart';
import '../../util/velocity_math.dart';
import '../../navigation/types/surface_graph.dart';
import '../../navigation/types/surface_id.dart';
import '../../navigation/surface_navigator.dart';
import '../../navigation/utils/surface_spatial_index.dart';
import '../../navigation/utils/trajectory_predictor.dart';
import '../stores/cast_intent_store.dart';
import '../stores/melee_intent_store.dart';
import '../world.dart';

/// Handles AI logic for enemies (steering and attacks).
///
/// Responsibilities:
/// 1.  **Steering**: Computes velocities to move enemies toward their targets
///     (Player) or patrol points. Supports both flying (direct/boid-like) and
///     ground (pathfinding over surface graph) locomotion.
/// 2.  **Attacks**: Decisions on when to attack. Writes intent to [CastIntentStore]
///     (ranged) or [MeleeIntentStore] (melee), which are executed by downstream
///     systems like `SpellCastSystem` or `MeleeSystem`.
class EnemySystem {
  EnemySystem({
    required this.unocoDemonTuning,
    required this.groundEnemyTuning,
    required this.surfaceNavigator,
    required this.enemyCatalog,
    required this.spells,
    required this.projectiles,
    this.trajectoryPredictor,
  });

  final UnocoDemonTuningDerived unocoDemonTuning;
  final GroundEnemyTuningDerived groundEnemyTuning;
  final SurfaceNavigator surfaceNavigator;
  final EnemyCatalog enemyCatalog;
  final SpellCatalog spells;
  final ProjectileCatalogDerived projectiles;

  /// Optional predictor for anticipating where an airborne player will land.
  ///
  /// When provided, ground enemies will pathfind toward the predicted landing
  /// spot instead of the player's current (airborne) position.
  final TrajectoryPredictor? trajectoryPredictor;

  /// The navigation graph for ground enemies. Can be null if the level has no surface data.
  SurfaceGraph? _surfaceGraph;
  /// Spatial index for quick lookup of surfaces/edges near an entity.
  SurfaceSpatialIndex? _surfaceIndex;
  /// Version tracker to detect graph updates and invalidate cached paths if necessary.
  int _surfaceGraphVersion = 0;

  /// Updates the navigation graph used by ground enemies.
  ///
  /// This should be called whenever the level geometry changes or is loaded.
  void setSurfaceGraph({
    required SurfaceGraph graph,
    required SurfaceSpatialIndex spatialIndex,
    required int graphVersion,
  }) {
    _surfaceGraph = graph;
    _surfaceIndex = spatialIndex;
    _surfaceGraphVersion = graphVersion;
  }

  /// Calculates and applies steering velocities for all active enemies.
  ///
  /// This traverses the enemy list, determines the player's position, and delegates
  /// to specific steering implementations ([_steerFlyingEnemy] or [_steerGroundEnemy]).
  void stepSteering(
    EcsWorld world, {
    required EntityId player,
    required double groundTopY,
    required double dtSeconds,
  }) {
    // If the player doesn't exist (e.g. dead or not spawned), enemies have no target.
    if (!world.transform.has(player)) return;

    // Cache player position/physics data once to avoid repeated lookups inside the loop.
    final playerTi = world.transform.indexOf(player);
    final playerX = world.transform.posX[playerTi];
    final playerY = world.transform.posY[playerTi];

    // Determine if player is grounded (relevant for ground enemies tracking).
    final playerGrounded = world.collision.has(player)
        ? world.collision.grounded[world.collision.indexOf(player)]
        : false;
    
    // Calculate player bounds for accurate targeting (e.g., aiming at center/bottom).
    var playerHalfX = 0.0;
    var playerBottomY = playerY;
    if (world.colliderAabb.has(player)) {
      final ai = world.colliderAabb.indexOf(player);
      playerHalfX = world.colliderAabb.halfX[ai];
      final offsetY = world.colliderAabb.offsetY[ai];
      playerBottomY = playerY + offsetY + world.colliderAabb.halfY[ai];
    }

    // Cache player velocity for trajectory prediction (ground enemies).
    final playerVelX = world.transform.velX[playerTi];
    final playerVelY = world.transform.velY[playerTi];

    final enemies = world.enemy;
    // Iterate over all entities tagged as enemies.
    for (var ei = 0; ei < enemies.denseEntities.length; ei += 1) {
      final e = enemies.denseEntities[ei];
      final ti = world.transform.tryIndexOf(e);
      if (ti == null) continue; // Should not happen if data integrity is maintained.

      final ex = world.transform.posX[ti];
      final ey = world.transform.posY[ti];
      
      /// TODO(Optimization): If enemy types grow significantly, consider separating
      /// entities into specialized systems queries or sorting component arrays by
      /// EnemyId to minimize branch mispredictions and improve cache locality.
      switch (enemies.enemyId[ei]) {
        case EnemyId.unocoDemon:
          _steerFlyingEnemy(
            world,
            enemyIndex: ei,
            enemy: e,
            enemyTi: ti,
            playerX: playerX,
            playerY: playerY,
            ex: ex,
            ey: ey,
            groundTopY: groundTopY,
            dtSeconds: dtSeconds,
          );
        case EnemyId.groundEnemy:
          _steerGroundEnemy(
            world,
            enemyIndex: ei,
            enemy: e,
            enemyTi: ti,
            playerX: playerX,
            playerBottomY: playerBottomY,
            playerHalfX: playerHalfX,
            playerVelX: playerVelX,
            playerVelY: playerVelY,
            playerGrounded: playerGrounded,
            ex: ex,
            dtSeconds: dtSeconds,
          );
      }
    }
  }

  /// Evaluates attack opportunities for all enemies.
  ///
  /// This checks distance/line-of-sight (implicitly or explicitly) and cooldowns.
  /// If an attack is viable, it writes an intent to the respective intent store.
  void stepAttacks(
    EcsWorld world, {
    required EntityId player,
    required int currentTick,
  }) {
    if (!world.transform.has(player)) return;
    
    // Pre-calculate player center for aiming.
    final playerTi = world.transform.indexOf(player);
    final playerX = world.transform.posX[playerTi];
    final playerY = world.transform.posY[playerTi];
    final playerVelX = world.transform.velX[playerTi];
    final playerVelY = world.transform.velY[playerTi];
    var playerCenterX = playerX;
    var playerCenterY = playerY;
    if (world.colliderAabb.has(player)) {
      final ai = world.colliderAabb.indexOf(player);
      playerCenterX += world.colliderAabb.offsetX[ai];
      playerCenterY += world.colliderAabb.offsetY[ai];
    }

    final enemies = world.enemy;
    for (var ei = 0; ei < enemies.denseEntities.length; ei += 1) {
      final e = enemies.denseEntities[ei];
      final ti = world.transform.tryIndexOf(e);
      if (ti == null) continue;
      
      // Cooldown check is cheap, but requires the store.
      // Assuming all enemies have cooldowns, but safer to check.
      if (!world.cooldown.has(e)) continue;

      final ex = world.transform.posX[ti];
      final ey = world.transform.posY[ti];

      switch (enemies.enemyId[ei]) {
        case EnemyId.unocoDemon:
          var enemyCenterX = ex;
          var enemyCenterY = ey;
          if (world.colliderAabb.has(e)) {
            final ai = world.colliderAabb.indexOf(e);
            enemyCenterX += world.colliderAabb.offsetX[ai];
            enemyCenterY += world.colliderAabb.offsetY[ai];
          }
          _writeUnocoDemonCastIntent(
            world,
            enemy: e,
            enemyIndex: ei,
            enemyCenterX: enemyCenterX,
            enemyCenterY: enemyCenterY,
            playerCenterX: playerCenterX,
            playerCenterY: playerCenterY,
            playerVelX: playerVelX,
            playerVelY: playerVelY,
            currentTick: currentTick,
          );
        case EnemyId.groundEnemy:
          _writeGroundEnemyMeleeIntent(
            world,
            enemy: e,
            enemyIndex: ei,
            ex: ex,
            ey: ey,
            playerX: playerX,
            currentTick: currentTick,
          );
      }
    }
  }

  /// Implements "Boids-like" or direct steering for flying enemies.
  ///
  /// Behavior:
  /// - Maintains a specific horizontal distance heavily (hovering left/right of player).
  /// - Maintains a specific height above ground (bobbing).
  /// - Randomizes target parameters periodically to add organic noise.
  void _steerFlyingEnemy(
    EcsWorld world, {
    required int enemyIndex,
    required EntityId enemy,
    required int enemyTi,
    required double playerX,
    required double playerY,
    required double ex,
    required double ey,
    required double groundTopY,
    required double dtSeconds,
  }) {
    if (dtSeconds <= 0.0) return;
    final tuning = unocoDemonTuning;
    
    // Ensure steering state exists. Contains RNG state and current target timers.
    if (!world.flyingEnemySteering.has(enemy)) {
      assert(
        false,
        'EnemySystem requires FlyingEnemySteeringStore on flying enemies; add it at spawn time.',
      );
      return;
    }

    final steering = world.flyingEnemySteering;
    final si = steering.indexOf(enemy);
    final modIndex = world.statModifier.tryIndexOf(enemy);
    final moveSpeedMul =
        modIndex == null ? 1.0 : world.statModifier.moveSpeedMul[modIndex];

    var rngState = steering.rngState[si];
    // Helper to advance RNG and get a range.
    double nextRange(double min, double max) {
      rngState = nextUint32(rngState);
      return rangeDouble(rngState, min, max);
    }

    // -- Initialization --
    // If first frame, randomize initial targets (range to hold, height to fly at).
    if (!steering.initialized[si]) {
      steering.initialized[si] = true;
      steering.desiredRangeHoldLeftS[si] = nextRange(
        tuning.base.unocoDemonDesiredRangeHoldMinSeconds,
        tuning.base.unocoDemonDesiredRangeHoldMaxSeconds,
      );
      steering.desiredRange[si] = nextRange(
        tuning.base.unocoDemonDesiredRangeMin,
        tuning.base.unocoDemonDesiredRangeMax,
      );
      steering.flightTargetHoldLeftS[si] = 0.0;
      steering.flightTargetAboveGround[si] = nextRange(
        tuning.base.unocoDemonMinHeightAboveGround,
        tuning.base.unocoDemonMaxHeightAboveGround,
      );
    }

    // -- Horizontal Logic --
    // Decay timer for holding the current desired range.
    var desiredRangeHoldLeftS = steering.desiredRangeHoldLeftS[si];
    var desiredRange = steering.desiredRange[si];

    if (desiredRangeHoldLeftS > 0.0) {
      desiredRangeHoldLeftS -= dtSeconds;
    } else {
      // Pick new range target when timer expires.
      desiredRangeHoldLeftS = nextRange(
        tuning.base.unocoDemonDesiredRangeHoldMinSeconds,
        tuning.base.unocoDemonDesiredRangeHoldMaxSeconds,
      );
      desiredRange = nextRange(
        tuning.base.unocoDemonDesiredRangeMin,
        tuning.base.unocoDemonDesiredRangeMax,
      );
    }

    final dx = playerX - ex;
    final distX = dx.abs();
    // Face the player.
    if (distX > 1e-6) {
      world.enemy.facing[enemyIndex] = dx >= 0 ? Facing.right : Facing.left;
    }

    // Calculate desired horizontal velocity to maintain `desiredRange`.
    final slack = tuning.base.unocoDemonHoldSlack;
    double desiredVelX = 0.0;
    if (distX > 1e-6) {
      final dirToPlayerX = dx >= 0 ? 1.0 : -1.0;
      final error = distX - desiredRange;

      // Only move if outside the slack (hysteresis) zone to prevent jitter.
      if (error.abs() > slack) {
        final slowRadiusX = tuning.base.unocoDemonSlowRadiusX;
        // Dampen speed as we approach the target range (arrival behavior).
        final t = slowRadiusX > 0.0
            ? clampDouble((error.abs() - slack) / slowRadiusX, 0.0, 1.0)
            : 1.0;
        final speed = t * tuning.base.unocoDemonMaxSpeedX;
        // If error > 0, we are too far -> move towards player.
        // If error < 0, we are too close -> move away from player.
        desiredVelX = (error > 0.0 ? dirToPlayerX : -dirToPlayerX) * speed;
      }
    }

    // -- Vertical Logic --
    // Decay timer for vertical target hold.
    var flightTargetHoldLeftS = steering.flightTargetHoldLeftS[si];
    var flightTargetAboveGround = steering.flightTargetAboveGround[si];
    if (flightTargetHoldLeftS > 0.0) {
      flightTargetHoldLeftS -= dtSeconds;
    } else {
      flightTargetHoldLeftS = nextRange(
        tuning.base.unocoDemonFlightTargetHoldMinSeconds,
        tuning.base.unocoDemonFlightTargetHoldMaxSeconds,
      );
      flightTargetAboveGround = nextRange(
        tuning.base.unocoDemonMinHeightAboveGround,
        tuning.base.unocoDemonMaxHeightAboveGround,
      );
    }

    // Simple P-controller for height.
    final targetY = groundTopY - flightTargetAboveGround;
    final deltaY = targetY - ey;
    double desiredVelY = clampDouble(
      deltaY * tuning.base.unocoDemonVerticalKp,
      -tuning.base.unocoDemonMaxSpeedY,
      tuning.base.unocoDemonMaxSpeedY,
    );
    if (deltaY.abs() <= tuning.base.unocoDemonVerticalDeadzone) {
      desiredVelY = 0.0;
    }

    // -- Physics Integration --
    desiredVelX *= moveSpeedMul;
    desiredVelY *= moveSpeedMul;
    final currentVelX = world.transform.velX[enemyTi];
    world.transform.velX[enemyTi] = applyAccelDecel(
      current: currentVelX,
      desired: desiredVelX,
      dtSeconds: dtSeconds,
      accelPerSecond: tuning.base.unocoDemonAccelX,
      decelPerSecond: tuning.base.unocoDemonDecelX,
    );
    world.transform.velY[enemyTi] = desiredVelY;

    // Write back state.
    steering.desiredRangeHoldLeftS[si] = desiredRangeHoldLeftS;
    steering.desiredRange[si] = desiredRange;
    steering.flightTargetHoldLeftS[si] = flightTargetHoldLeftS;
    steering.flightTargetAboveGround[si] = flightTargetAboveGround;
    steering.rngState[si] = rngState;
  }

  /// Implements pathfinding and steering for ground enemies.
  ///
  /// This uses [SurfaceNavigator] to compute the next immediate move (jump/walk)
  /// towards the player. It also handles "chase offsets" to prevent enemies from
  /// stacking perfectly on top of each other.
  void _steerGroundEnemy(
    EcsWorld world, {
    required int enemyIndex,
    required EntityId enemy,
    required int enemyTi,
    required double playerX,
    required double playerBottomY,
    required double playerHalfX,
    required double playerVelX,
    required double playerVelY,
    required bool playerGrounded,
    required double ex,
    required double dtSeconds,
  }) {
    if (dtSeconds <= 0.0) return;
    final tuning = groundEnemyTuning;

    final navIndex = world.surfaceNav.tryIndexOf(enemy);
    if (navIndex == null) return;

    // Optimized: Resolve chase offset store once and pass index to avoid re-lookup.
    final chaseIndex = world.groundEnemyChaseOffset.tryIndexOf(enemy);
    if (chaseIndex == null) return;

    // Lazy initialization of random chase parameters.
    _ensureChaseOffsetInitialized(world, chaseIndex, enemy);

    final chaseOffset = world.groundEnemyChaseOffset;
    final chaseOffsetX = chaseOffset.chaseOffsetX[chaseIndex];
    final chaseSpeedScale = chaseOffset.chaseSpeedScale[chaseIndex];

    // -- Target Selection --
    // "Collapse" behavior: when very close to player, ignore chase offset and
    // move directly to player (to attack). Otherwise, maintain offset.
    final collapseDistX = tuning.base.groundEnemyMeleeRangeX +
        tuning.base.groundEnemyStopDistanceX;
    final distToPlayerX = (playerX - ex).abs();
    
    // Calculate melee offset (which side of the player to stand on).
    final meleeOffsetMaxX = tuning.base.groundEnemyChaseOffsetMeleeX.abs();
    final meleeOffsetAbs = min(meleeOffsetMaxX, chaseOffsetX.abs());
    final meleeOffsetX = meleeOffsetAbs == 0.0
        ? 0.0
        : (chaseOffsetX >= 0.0 ? meleeOffsetAbs : -meleeOffsetAbs);
    
    final effectiveTargetX = distToPlayerX <= collapseDistX
        ? playerX + meleeOffsetX
        : playerX + chaseOffsetX;

    // -- Pathfinding Query --
    final graph = _surfaceGraph;
    final spatialIndex = _surfaceIndex;

    // -- Landing Prediction --
    // When player is airborne, predict where they'll land and navigate there.
    var navTargetX = playerX;
    var navTargetBottomY = playerBottomY;
    var navTargetGrounded = playerGrounded;

    if (!playerGrounded &&
        trajectoryPredictor != null &&
        graph != null &&
        spatialIndex != null) {
      final prediction = trajectoryPredictor!.predictLanding(
        startX: playerX,
        startBottomY: playerBottomY,
        velX: playerVelX,
        velY: playerVelY,
        graph: graph,
        spatialIndex: spatialIndex,
        entityHalfWidth: playerHalfX,
      );

      if (prediction != null) {
        navTargetX = prediction.x;
        navTargetBottomY = prediction.bottomY;
        navTargetGrounded = true; // Treat predicted landing as grounded.
      }
    }

    double? noPlanSurfaceMinX;
    double? noPlanSurfaceMaxX;
    SurfaceNavIntent intent;
    
    // If graph is missing or navigation not possible, fallback to no-op/dumb chase.
    if (graph == null ||
        spatialIndex == null ||
        !world.colliderAabb.has(enemy)) {
      intent = SurfaceNavIntent(
        desiredX: effectiveTargetX,
        jumpNow: false,
        hasPlan: false,
      );
    } else {
      final ai = world.colliderAabb.indexOf(enemy);
      final enemyHalfX = world.colliderAabb.halfX[ai];
      final enemyHalfY = world.colliderAabb.halfY[ai];
      final offsetY = world.colliderAabb.offsetY[ai];
      final enemyBottomY = world.transform.posY[enemyTi] + offsetY + enemyHalfY;
      final grounded =
          world.collision.has(enemy) &&
          world.collision.grounded[world.collision.indexOf(enemy)];

      // Query the navigator for what to do this frame.
      intent = surfaceNavigator.update(
        navStore: world.surfaceNav,
        navIndex: navIndex,
        graph: graph,
        spatialIndex: spatialIndex,
        graphVersion: _surfaceGraphVersion,
        entityX: ex,
        entityBottomY: enemyBottomY,
        entityHalfWidth: enemyHalfX,
        entityGrounded: grounded,
        targetX: navTargetX,
        targetBottomY: navTargetBottomY,
        targetHalfWidth: playerHalfX,
        targetGrounded: navTargetGrounded,
      );

      // -- Fallback Logic --
      // If the navigator defines no plan (e.g. lost track or arrived), we still
      // want to move towards `desiredX` (chase behavior), BUT we must be careful
      // not to walk off a ledge blindly.
      if (!intent.hasPlan) {
        var desiredX = effectiveTargetX;
        // Clamp desiredX to the current surface's bounds to stop at edges.
        final currentSurfaceId = world.surfaceNav.currentSurfaceId[navIndex];
        if (currentSurfaceId != surfaceIdUnknown) {
          final currentIndex = graph.indexOfSurfaceId(currentSurfaceId);
          if (currentIndex != null) {
            final surface = graph.surfaces[currentIndex];
            final minX = surface.xMin + enemyHalfX;
            final maxX = surface.xMax - enemyHalfX;
            if (minX <= maxX) {
              desiredX = clampDouble(desiredX, minX, maxX);
              noPlanSurfaceMinX = minX;
              noPlanSurfaceMaxX = maxX;
            }
          }
        }

        intent = SurfaceNavIntent(
          desiredX: desiredX,
          jumpNow: false,
          hasPlan: false,
        );
      }
    }

    // Speed scale is intended to break symmetric chasing overlaps.
    // However, when executing a precise plan (like a Jump edge), we used standard
    // speed to ensure the physics align with the pre-calculated jump arc.
    final effectiveSpeedScale = intent.hasPlan ? 1.0 : chaseSpeedScale;

    _applyGroundEnemyPhysics(
      world,
      enemyIndex: enemyIndex,
      enemyTi: enemyTi,
      ex: ex,
      intent: intent,
      effectiveSpeedScale: effectiveSpeedScale,
      dtSeconds: dtSeconds,
      safeSurfaceMinX: noPlanSurfaceMinX,
      safeSurfaceMaxX: noPlanSurfaceMaxX,
      navIndex: navIndex,
      graph: graph,
    );
  }

  /// Calculates aim and registers a spell cast intent for flying enemies.
  void _writeUnocoDemonCastIntent(
    EcsWorld world, {
    required EntityId enemy,
    required int enemyIndex,
    required double enemyCenterX,
    required double enemyCenterY,
    required double playerCenterX,
    required double playerCenterY,
    required double playerVelX,
    required double playerVelY,
    required int currentTick,
  }) {
    final tuning = unocoDemonTuning;
    if (!world.castIntent.has(enemy)) {
      assert(
        false,
        'EnemySystem requires CastIntentStore on enemies; add it at spawn time.',
      );
      return;
    }

    // Determine projectile properties for aiming.
    final enemyId = world.enemy.enemyId[enemyIndex];
    final spellId = enemyCatalog.get(enemyId).primarySpellId;
    if (spellId == null) return;
    final projectileId = spells.get(spellId).projectileId;
    final projectileSpeed = projectileId == null
        ? null
        : projectiles.base.get(projectileId).speedUnitsPerSecond;
    
    // -- Aim Leading --
    var targetX = playerCenterX;
    var targetY = playerCenterY;
    if (projectileSpeed != null && projectileSpeed > 0.0) {
      final dx = playerCenterX - enemyCenterX;
      final dy = playerCenterY - enemyCenterY;
      final distance = sqrt(dx * dx + dy * dy);
      // Rough estimation of time-to-impact to predict player position.
      final leadSeconds = clampDouble(
        distance / projectileSpeed,
        tuning.base.unocoDemonAimLeadMinSeconds,
        tuning.base.unocoDemonAimLeadMaxSeconds,
      );
      targetX = playerCenterX + playerVelX * leadSeconds;
      targetY = playerCenterY + playerVelY * leadSeconds;
    }

    // Write intent. Actual spawning handles cooldown/mana checks.
    world.castIntent.set(
      enemy,
      CastIntentDef(
        spellId: spellId,
        dirX: targetX - enemyCenterX,
        dirY: targetY - enemyCenterY,
        fallbackDirX: 1.0,
        fallbackDirY: 0.0,
        originOffset: tuning.base.unocoDemonCastOriginOffset,
        cooldownTicks: tuning.unocoDemonCastCooldownTicks,
        tick: currentTick,
      ),
    );
  }

  /// Checks range and registers a melee attack intent for ground enemies.
  void _writeGroundEnemyMeleeIntent(
    EcsWorld world, {
    required EntityId enemy,
    required int enemyIndex,
    required double ex,
    required double ey,
    required double playerX,
    required int currentTick,
  }) {
    final tuning = groundEnemyTuning;
    if (!world.meleeIntent.has(enemy)) {
      assert(
        false,
        'EnemySystem requires MeleeIntentStore on enemies; add it at spawn time.',
      );
      return;
    }
    if (!world.colliderAabb.has(enemy)) {
      assert(
        false,
        'GroundEnemy melee requires ColliderAabbStore on the enemy to compute hitbox offset.',
      );
      return;
    }
    
    // Simple range check.
    final dx = (playerX - ex).abs();
    if (dx > tuning.base.groundEnemyMeleeRangeX) return;

    // Determine hitbox position based on facing direction.
    final facing = world.enemy.facing[enemyIndex];
    final dirX = facing == Facing.right ? 1.0 : -1.0;

    final halfX = tuning.base.groundEnemyMeleeHitboxSizeX * 0.5;
    final halfY = tuning.base.groundEnemyMeleeHitboxSizeY * 0.5;

    final ownerHalfX =
        world.colliderAabb.halfX[world.colliderAabb.indexOf(enemy)];
    final offsetX = dirX * (ownerHalfX * 0.5 + halfX);
    const offsetY = 0.0;

    // Write intent.
    world.meleeIntent.set(
      enemy,
      MeleeIntentDef(
        damage: tuning.base.groundEnemyMeleeDamage,
        damageType: DamageType.physical,
        statusProfileId: StatusProfileId.none,
        halfX: halfX,
        halfY: halfY,
        offsetX: offsetX,
        offsetY: offsetY,
        dirX: dirX,
        dirY: 0.0,
        activeTicks: tuning.groundEnemyMeleeActiveTicks,
        cooldownTicks: tuning.groundEnemyMeleeCooldownTicks,
        staminaCost: 0.0,
        tick: currentTick,
      ),
    );
  }

  /// Ensures that the ground enemy has valid initialized chase offsets.
  ///
  /// Adds randomness to tracking so multiple enemies don't overlap perfectly.
  void _ensureChaseOffsetInitialized(
    EcsWorld world,
    int chaseIndex,
    EntityId enemy,
  ) {
    // world.groundEnemyChaseOffset.has(enemy) is guaranteed primarily by caller.
    final chaseOffset = world.groundEnemyChaseOffset;
    if (chaseOffset.initialized[chaseIndex]) return;

    final tuning = groundEnemyTuning;
    var rngState = chaseOffset.rngState[chaseIndex];
    if (rngState == 0) {
      rngState = enemy; // Seed with entity ID for determinism.
    }
    
    // Choose a random horizontal offset relative to the player.
    final maxAbs = tuning.base.groundEnemyChaseOffsetMaxX.abs();
    var offsetX = 0.0;
    if (maxAbs > 0.0) {
      rngState = nextUint32(rngState);
      offsetX = rangeDouble(rngState, -maxAbs, maxAbs);
      final minAbs = clampDouble(
        tuning.base.groundEnemyChaseOffsetMinAbsX,
        0.0,
        maxAbs,
      );
      final absOffset = offsetX.abs();
      // Ensure the offset isn't too small (which would defeat the purpose).
      if (absOffset < minAbs) {
        offsetX = offsetX >= 0.0 ? minAbs : -minAbs;
        if (absOffset == 0.0) {
          offsetX = minAbs;
        }
      }
    }

    // Choose a slight variation in speed.
    rngState = nextUint32(rngState);
    final speedScale = rangeDouble(
      rngState,
      tuning.base.groundEnemyChaseSpeedScaleMin,
      tuning.base.groundEnemyChaseSpeedScaleMax,
    );
    chaseOffset.initialized[chaseIndex] = true;
    chaseOffset.chaseOffsetX[chaseIndex] = offsetX;
    chaseOffset.chaseSpeedScale[chaseIndex] = speedScale;
    chaseOffset.rngState[chaseIndex] = rngState;
  }

  /// Low-level physics application for ground enemies based on [SurfaceNavIntent].
  void _applyGroundEnemyPhysics(
    EcsWorld world, {
    required int enemyIndex,
    required int enemyTi,
    required double ex,
    required SurfaceNavIntent intent,
    required double effectiveSpeedScale,
    required double dtSeconds,
    required double? safeSurfaceMinX,
    required double? safeSurfaceMaxX,
    required int navIndex,
    required SurfaceGraph? graph,
  }) {
    final tuning = groundEnemyTuning;
    final enemy = world.enemy.denseEntities[enemyIndex];
    final modIndex = world.statModifier.tryIndexOf(enemy);
    final moveSpeedMul =
        modIndex == null ? 1.0 : world.statModifier.moveSpeedMul[modIndex];
    final dx = intent.desiredX - ex;
    double desiredVelX = 0.0;

    // -- Horizontal Movement --
    if (intent.commitMoveDirX != 0) {
      // If navigation explicitly requests a direction (e.g., preparing for jump).
      final dirX = intent.commitMoveDirX.toDouble();
      world.enemy.facing[enemyIndex] = dirX > 0 ? Facing.right : Facing.left;
      desiredVelX = dirX * tuning.base.groundEnemySpeedX * effectiveSpeedScale;
    } else if (dx.abs() > tuning.base.groundEnemyStopDistanceX) {
      // Standard seek behavior logic.
      final dirX = dx >= 0 ? 1.0 : -1.0;
      world.enemy.facing[enemyIndex] = dirX > 0 ? Facing.right : Facing.left;
      desiredVelX = dirX * tuning.base.groundEnemySpeedX * effectiveSpeedScale;
    }

    desiredVelX *= moveSpeedMul;

    // -- Jumping --
    if (intent.jumpNow) {
      world.transform.velY[enemyTi] = -tuning.base.groundEnemyJumpSpeed;
    }

    // -- Physics Update --
    final currentVelX = world.transform.velX[enemyTi];
    final nextVelX = applyAccelDecel(
      current: currentVelX,
      desired: desiredVelX,
      dtSeconds: dtSeconds,
      accelPerSecond: tuning.base.groundEnemyAccelX,
      decelPerSecond: tuning.base.groundEnemyDecelX,
    );

    // -- Jump Velocity Snapping --
    // If we are executing a jump edge, we might need to "snap" velocity to exactly
    // what is required to make the gap, overriding acceleration/deceleration.
    // This fixes issues where enemies undershoot/overshoot jumps due to frame variances.
    double? jumpSnapVelX;
    if (intent.hasPlan && intent.jumpNow && graph != null) {
      final activeEdgeIndex = world.surfaceNav.activeEdgeIndex[navIndex];
      if (activeEdgeIndex >= 0 && activeEdgeIndex < graph.edges.length) {
        final edge = graph.edges[activeEdgeIndex];
        if (edge.kind == SurfaceEdgeKind.jump && edge.travelTicks > 0) {
          final travelSeconds = edge.travelTicks * dtSeconds;
          if (travelSeconds > 0.0) {
            final dxAbs = (edge.landingX - ex).abs();
            final requiredAbs = dxAbs / travelSeconds;
            // Only snap if it's reasonable (bounded by current/desired speeds).
            final desiredAbs = desiredVelX.abs();
            final currentAbs = currentVelX.abs();
            final snapAbs = min(desiredAbs, max(currentAbs, requiredAbs));
            // Apply if the snap velocity is actually faster (avoid getting stuck).
            if (snapAbs > nextVelX.abs()) {
              final sign = desiredVelX >= 0.0 ? 1.0 : -1.0;
              jumpSnapVelX = sign * snapAbs;
            }
          }
        }
      }
    }

    world.transform.velX[enemyTi] = jumpSnapVelX ?? nextVelX;

    // -- Ledge Safety --
    // If we have no plan (wandering/chasing blindly), hard stop at surface edges.
    if (!intent.hasPlan && safeSurfaceMinX != null && safeSurfaceMaxX != null) {
      final stopDist = tuning.base.groundEnemyStopDistanceX;
      final nextVelX = world.transform.velX[enemyTi];
      if (nextVelX > 0.0 && ex >= safeSurfaceMaxX - stopDist) {
        world.transform.velX[enemyTi] = 0.0;
      } else if (nextVelX < 0.0 && ex <= safeSurfaceMinX + stopDist) {
        world.transform.velX[enemyTi] = 0.0;
      }
    }
  }
}


===== FILE: lib/core/ecs/systems/gravity_system.dart =====
import '../../tuning/movement_tuning.dart';
import '../../tuning/physics_tuning.dart';
import '../world.dart';

/// Applies gravity to all enabled, non-kinematic bodies that opt into gravity.
///
/// Gravity is applied before collision integration/resolution each tick.
class GravitySystem {
  void step(
    EcsWorld world,
    MovementTuningDerived movement, {
    required PhysicsTuning physics,
  }) {
    final dt = movement.dtSeconds;
    if (dt <= 0.0) return;

    final gravityY = physics.gravityY;
    final bodies = world.body;

    for (var bi = 0; bi < bodies.denseEntities.length; bi += 1) {
      final e = bodies.denseEntities[bi];

      final ti = world.transform.tryIndexOf(e);
      if (ti == null) continue;

      if (!bodies.enabled[bi]) continue;
      if (bodies.isKinematic[bi]) continue;
      if (!bodies.useGravity[bi]) continue;

      // -- Gravity Suppression Logic --
      // Check if gravity is temporarily suppressed for this entity (e.g. during a dash).
      final gci = world.gravityControl.tryIndexOf(e);
      if (gci != null) {
        final ticksLeft = world.gravityControl.suppressGravityTicksLeft[gci];
        
        if (ticksLeft > 0) {
          // Decrement timer.
          final nextTicks = ticksLeft - 1;
          world.gravityControl.suppressGravityTicksLeft[gci] = nextTicks;
          
          // If timer just expired, remove the component so gravity resumes NEXT tick.
          if (nextTicks <= 0) {
            world.gravityControl.removeEntity(e);
          }
          // Skip gravity application for this frame.
          continue;
        } else {
          // Component exists but is stale (0 or negative ticks), remove it and apply gravity immediately.
          world.gravityControl.removeEntity(e);
        }
      }

      // -- Apply Gravity --
      final scaledGravityY = gravityY * bodies.gravityScale[bi];
      world.transform.velY[ti] += scaledGravityY * dt;

      // -- Terminal Velocity --
      final maxVelY = bodies.maxVelY[bi];
      world.transform.velY[ti] = world.transform.velY[ti]
          .clamp(-maxVelY, maxVelY);
    }
  }
}


===== FILE: lib/core/ecs/systems/health_despawn_system.dart =====
import '../../enemies/enemy_id.dart';
import '../entity_id.dart';
import '../world.dart';

/// Despawns any non-player entity with `HealthStore` and `hp <= 0`.
///
/// **Responsibilities**:
/// *   Scans all entities with health.
/// *   Identifies those with zero or negative health points.
/// *   reports enemy deaths (for score/quests) via [outEnemiesKilled].
/// *   Removes the dead entities from the ECS world.
///
/// **IMPORTANT**: The player is intentionally exempt because player "death" is a
/// different gameplay flow (game over / respawn / end-run) than despawning an
/// entity in-place.
class HealthDespawnSystem {
  /// Internal buffer to hold entities scheduled for destruction this frame.
  /// Used to avoid modifying the entity collection while iterating over it.
  final List<EntityId> _toDespawn = <EntityId>[];

  /// Runs the system logic.
  ///
  /// [outEnemiesKilled] is an optional list that, if provided, will be populated
  /// with the [EnemyId]s of any enemies destroyed this frame.
  void step(
    EcsWorld world, {
    required EntityId player,
    List<EnemyId>? outEnemiesKilled,
  }) {
    final health = world.health;
    // Optimization: If no entities have health components, there's nothing to check.
    if (health.denseEntities.isEmpty) return;

    // Reset buffer for this frame.
    _toDespawn.clear();

    // -- Pass 1: Identification --
    // Iterate over all entities participating in the health system.
    for (var i = 0; i < health.denseEntities.length; i += 1) {
      final e = health.denseEntities[i];
      
      // Safety check: The player should never be despawned by this system.
      if (e == player) continue;
      
      // If health is depleted, mark for destruction.
      if (health.hp[i] <= 0.0) {
        _toDespawn.add(e);
      }
    }

    // -- Pass 2: Reporting & Destruction --
    // Process the list of doomed entities.
    for (final e in _toDespawn) {
      // If the caller wants to know about enemy kills (e.g. for scoring)...
      if (outEnemiesKilled != null) {
        // ...check if the dying entity was actually an enemy.
        final enemyIndex = world.enemy.tryIndexOf(e);
        if (enemyIndex != null) {
          outEnemiesKilled.add(world.enemy.enemyId[enemyIndex]);
        }
      }
      
      // Permanently remove the entity and all its components from the world.
      world.destroyEntity(e);
    }
  }
}


===== FILE: lib/core/ecs/systems/hitbox_damage_system.dart =====
import '../../combat/damage.dart';
import '../../events/game_event.dart';
import '../hit/hit_resolver.dart';
import '../spatial/broadphase_grid.dart';
import '../world.dart';

/// Detects collisions between active hitboxes (melee attacks) and vulnerable targets.
///
/// **Responsibilities**:
/// *   Iterate over all active hitboxes (entities with `HitboxStore`).
/// *   Perform broadphase/narrowphase collision checks against potential targets.
/// *   Filter hits based on faction (Friendly fire prevention).
/// *   Enforce "Hit Once" logic to prevent a single frame of attack from dealing damage every tick.
/// *   Queue [DamageRequest]s for resolved hits.
class HitboxDamageSystem {
  /// Helper for spatial queries and overlap sorting.
  final HitResolver _resolver = HitResolver();
  
  /// Reused buffer to store indices of overlapping entities each frame.
  final List<int> _overlaps = <int>[];

  /// Executes the system logic.
  ///
  /// [queueDamage] is a callback to the central event system to register damage.
  /// [broadphase] provides the spatial index of all damageable entities this frame.
  void step(
    EcsWorld world,
    void Function(DamageRequest request) queueDamage,
    BroadphaseGrid broadphase,
  ) {
    final hitboxes = world.hitbox;
    // Early exit if no active attacks exist.
    if (hitboxes.denseEntities.isEmpty) return;

    // Early exit if there are no targets to hit.
    if (broadphase.targets.isEmpty) return;

    // Process each active hitbox.
    for (var hi = 0; hi < hitboxes.denseEntities.length; hi += 1) {
      final hb = hitboxes.denseEntities[hi];
      
      // Hitboxes must have a position (Transform) to overlap anything.
      if (!world.transform.has(hb)) continue;
      
      // Hitboxes must have a HitOnce state to track who they've already damaged.
      // This prevents "machine gun" damage from a lingering sword swing.
      if (!world.hitOnce.has(hb)) continue;

      final hbTi = world.transform.indexOf(hb);
      final hbCx = world.transform.posX[hbTi];
      final hbCy = world.transform.posY[hbTi];
      final hbHalfX = hitboxes.halfX[hi];
      final hbHalfY = hitboxes.halfY[hi];
      final hbDirX = hitboxes.dirX[hi];
      final hbDirY = hitboxes.dirY[hi];

      // Calculate capsule segment endpoints.
      // We interpret `halfX` as the half-length along the direction vector,
      // and `halfY` as the capsule radius (thickness).
      // This effectively creates a capsule centered at (hbCx, hbCy) oriented along (hbDirX, hbDirY).
      final ax = hbCx - hbDirX * hbHalfX;
      final ay = hbCy - hbDirY * hbHalfX;
      final bx = hbCx + hbDirX * hbHalfX;
      final by = hbCy + hbDirY * hbHalfX;

      final owner = hitboxes.owner[hi];
      final sourceFaction = hitboxes.faction[hi];
      
      // Resolve enemy ID efficiently if the owner is an enemy.
      // This is used for kill credit/stats.
      final enemyIndex = world.enemy.tryIndexOf(owner);
      final enemyId = enemyIndex != null
          ? world.enemy.enemyId[enemyIndex]
          : null;

      // Ensure buffer is clear before collection (safety measure).
      _overlaps.clear();
      
      // Query the spatial grid for potential overlaps.
      // This handles the geometric check (Capsule vs Target Bounds) and Faction check.
      _resolver.collectOrderedOverlapsCapsule(
        broadphase: broadphase,
        ax: ax,
        ay: ay,
        bx: bx,
        by: by,
        radius: hbHalfY,
        owner: owner,
        sourceFaction: sourceFaction,
        outTargetIndices: _overlaps,
      );
      if (_overlaps.isEmpty) continue;

      // Register hits for verified overlaps.
      for (var i = 0; i < _overlaps.length; i += 1) {
        final ti = _overlaps[i];
        final target = broadphase.targets.entities[ti];
        
        // "Hit Once" Check: Has this specific hitbox entity already struck this specific target entity?
        if (world.hitOnce.hasHit(hb, target)) continue;
        
        // Mark as hit so we don't damage them again this swing.
        world.hitOnce.markHit(hb, target);

        // Send the damage request.
        queueDamage(
          DamageRequest(
            target: target,
            amount: hitboxes.damage[hi],
            damageType: hitboxes.damageType[hi],
            statusProfileId: hitboxes.statusProfileId[hi],
            source: owner,
            sourceKind: DeathSourceKind.meleeHitbox,
            sourceEnemyId: enemyId,
          ),
        );
      }
    }
  }
}


===== FILE: lib/core/ecs/systems/hitbox_follow_owner_system.dart =====
import '../entity_id.dart';
import '../world.dart';

/// Synchronizes the position of hitbox entities with their owners.
///
/// **Responsibilities**:
/// *   Iterate over all active hitboxes (entities with `HitboxStore`).
/// *   Retrieve the owner's current position.
/// *   Apply the hitbox's local offset (defined at spawn).
/// *   Update the hitbox's `Transform` component to match the calculated world position.
///
/// **Usage Note**:
/// This system ensures that a sword swing or projectile hitbox moves *with* the
/// character/projectile effectively. It runs every tick to prevent "hitbox drift".
class HitboxFollowOwnerSystem {
  final List<EntityId> _toDespawn = <EntityId>[];

  /// Executes the synchronization logic.
  void step(EcsWorld world) {
    final hitboxes = world.hitbox;
    // Early exit if no hitboxes exist.
    if (hitboxes.denseEntities.isEmpty) return;

    _toDespawn.clear();

    for (var hi = 0; hi < hitboxes.denseEntities.length; hi += 1) {
      final hitbox = hitboxes.denseEntities[hi];
      
      // Safety: The hitbox entity itself must have a Transform component to be positioned.
      if (!world.transform.has(hitbox)) {
        _toDespawn.add(hitbox);
        continue;
      }

      final owner = hitboxes.owner[hi];
      
      // If the owner has been destroyed or lacks a transform,
      // we cannot position the hitbox relative to it.
      final ownerTi = world.transform.tryIndexOf(owner);
      if (ownerTi == null) {
        _toDespawn.add(hitbox);
        continue;
      }

      // Calculate world position: Owner Position + Local Offset.
      final x = world.transform.posX[ownerTi] + hitboxes.offsetX[hi];
      final y = world.transform.posY[ownerTi] + hitboxes.offsetY[hi];

      // specific Snap behavior: We overwrite the position completely.
      // Physics forces are not applied here; it's a hard attachment.
      world.transform.setPosXY(hitbox, x, y);
    }

    for (final e in _toDespawn) {
      world.destroyEntity(e);
    }
  }
}


===== FILE: lib/core/ecs/systems/invulnerability_system.dart =====
import '../world.dart';

/// Manages temporary invulnerability frames (i-frames).
///
/// **Responsibilities**:
/// *   Decrements invulnerability timers each tick.
/// *   Removes the `InvulnerabilityStore` component when the timer expires.
class InvulnerabilitySystem {
  void step(EcsWorld world) {
    final store = world.invulnerability;
    // Iterate backwards to allow safe removal of entities (Swap-Remove safe).
    for (var i = store.denseEntities.length - 1; i >= 0; i--) {
      // Decrement.
      if (store.ticksLeft[i] > 0) {
        store.ticksLeft[i] -= 1;
      }

      // Cleanup logic: If expired, remove the component so other systems
      // (collision/damage) know the entity is vulnerable again.
      if (store.ticksLeft[i] <= 0) {
        final e = store.denseEntities[i];
        store.removeEntity(e);
      }
    }
  }
}



===== FILE: lib/core/ecs/systems/lifetime_system.dart =====
import '../entity_id.dart';
import '../world.dart';

/// Determines when temporary entities should expire.
///
/// **Responsibilities**:
/// *   Decrements the life timer (`LifetimeStore.ticksLeft`) for all participating entities every tick.
/// *   Despawns entities when their timer reaches zero.
///
/// **Usage**:
/// Generic system used for particles, projectiles, transient UI markers, or timed buffs
/// that need to clean themselves up automatically.
class LifetimeSystem {
  /// Buffer for entities to destroy.
  /// Used to avoid `ConcurrentModificationException` when modifying the ECS state during iteration.
  final List<EntityId> _toDespawn = <EntityId>[];

  /// Executes the system logic.
  void step(EcsWorld world) {
    final lifetimes = world.lifetime;
    // Optimization: Skip processing if no timed entities exist.
    if (lifetimes.denseEntities.isEmpty) return;

    // Reset the buffer for this frame.
    _toDespawn.clear();

    // Iterate over all entities with a lifetime component.
    for (var li = 0; li < lifetimes.denseEntities.length; li += 1) {
      final e = lifetimes.denseEntities[li];
      
      // Decrement the timer (Tick down).
      lifetimes.ticksLeft[li]--;
      
      // If time has run out (or was force-set to <= 0), mark for destruction.
      if (lifetimes.ticksLeft[li] <= 0) {
        _toDespawn.add(e);
      }
    }

    // Process the destruction queue.
    for (final e in _toDespawn) {
      world.destroyEntity(e);
    }
  }
}



===== FILE: lib/core/ecs/systems/melee_attack_system.dart =====
import '../stores/hitbox_store.dart';
import '../stores/lifetime_store.dart';
import '../world.dart';

/// Processes requests to perform melee attacks.
///
/// **Responsibilities**:
/// *   Consumes [MeleeIntentStore] intents created by input or enemy AI.
/// *   Validates attack requirements (Cooldown, Stamina availability).
/// *   Deducts resource costs (Stamina, Cooldown Reset).
/// *   Spawns the actual "Hitbox" entity that performs collision checks.
///
/// **Workflow**:
/// 1.  Filter intents that match the [currentTick] (synchronization).
/// 2.  Validate Attacker State (Must exist, have cooldown component, etc.).
/// 3.  Check Costs (Is cooldown ready? Is there enough stamina?).
/// 4.  **Execute**:
///     *   Deduct Stamina.
///     *   Set Cooldown.
///     *   Create Hitbox entity with [HitboxDef], [HitOnce], and [LifetimeDef].
class MeleeAttackSystem {
  /// Runs the system logic.
  ///
  /// [currentTick] is required to ensure we only process intents generated for THIS frame,
  /// preserving determinism.
  void step(EcsWorld world, {required int currentTick}) {
    final intents = world.meleeIntent;
    if (intents.denseEntities.isEmpty) return;
    
    // Iterate through all intents.
    for (var ii = 0; ii < intents.denseEntities.length; ii += 1) {
      if (intents.tick[ii] != currentTick) continue;

      final attacker = intents.denseEntities[ii];

      // Invalidate now so accidental multi-pass execution in the same tick cannot
      // double-attack. (Intent is still ignored next tick due to stamp mismatch.)
      intents.tick[ii] = -1;

      // -- Validation & Resource Checks --

      // Attacker must exist physically.
      final attackerTi = world.transform.tryIndexOf(attacker);
      if (attackerTi == null) continue;

      // Attacker must respond to cooldowns.
      final ci = world.cooldown.tryIndexOf(attacker);
      if (ci == null) continue;
      if (world.cooldown.meleeCooldownTicksLeft[ci] > 0) continue;

      // Attacker must have a faction to determine who they hit.
      final fi = world.faction.tryIndexOf(attacker);
      if (fi == null) continue;
      final faction = world.faction.faction[fi];

      // Stamina check.
      final staminaCost = intents.staminaCost[ii];
      int? si;
      double? nextStamina;
      
      if (staminaCost > 0) {
        // Optimization: Resolve index directly.
        si = world.stamina.tryIndexOf(attacker);
        if (si == null) continue; // No stamina component = cannot attack if cost > 0.
        
        final currentStamina = world.stamina.stamina[si];
        if (currentStamina < staminaCost) continue; // Not enough stamina.
        nextStamina = currentStamina - staminaCost;
      }

      // -- Execution --

      // Spawn the hitbox.
      final hitbox = world.createEntity();
      world.transform.add(
        hitbox,
        // HitboxFollowOwnerSystem will position from `owner + offset`.
        // Initialize at owner's position to prevent 1-frame visual glitch.
        posX: world.transform.posX[attackerTi],
        posY: world.transform.posY[attackerTi],
        velX: 0.0,
        velY: 0.0,
      );
      world.hitbox.add(
        hitbox,
        HitboxDef(
          owner: attacker,
          faction: faction,
          damage: intents.damage[ii],
          damageType: intents.damageType[ii],
          statusProfileId: intents.statusProfileId[ii],
          halfX: intents.halfX[ii],
          halfY: intents.halfY[ii],
          offsetX: intents.offsetX[ii],
          offsetY: intents.offsetY[ii],
          dirX: intents.dirX[ii],
          dirY: intents.dirY[ii],
        ),
      );
      // Ensure hitbox only hits things once.
      world.hitOnce.add(hitbox);
      // Hitbox is ephemeral.
      world.lifetime.add(
        hitbox,
        LifetimeDef(ticksLeft: intents.activeTicks[ii]),
      );

      // Apply costs.
      if (si != null) {
        world.stamina.stamina[si] = nextStamina!;
      }
      // Set cooldown.
      world.cooldown.meleeCooldownTicksLeft[ci] = intents.cooldownTicks[ii];
    }
  }
}


===== FILE: lib/core/ecs/systems/player_cast_system.dart =====
import '../../snapshots/enums.dart';
import '../../spells/spell_id.dart';
import '../../tuning/ability_tuning.dart';
import '../../tuning/movement_tuning.dart';
import '../entity_id.dart';
import '../stores/cast_intent_store.dart';
import '../world.dart';

/// Translates player input into a [CastIntentDef] for the [SpellCastSystem].
///
/// **Responsibilities**:
/// *   Checks if the cast button is pressed.
/// *   Determines aiming direction based on input or facing direction.
/// *   Registers a cast intent to be processed (cooldown/mana checks happen downstream).
class PlayerCastSystem {
  const PlayerCastSystem({
    required this.abilities,
    required this.movement,
  });

  final AbilityTuningDerived abilities;
  final MovementTuningDerived movement;

  void step(EcsWorld world, {required EntityId player, required int currentTick}) {
    // -- 1. Component Checks --
    
    // We need input to know if casting.
    final inputIndex = world.playerInput.tryIndexOf(player);
    if (inputIndex == null) return;

    // We need movement data for facing direction (fallback aim).
    final movementIndex = world.movement.tryIndexOf(player);
    if (movementIndex == null) return;
    
    // Check if the store exists (should be added at spawn).
    if (!world.castIntent.has(player)) {
      assert(
        false,
        'PlayerCastSystem requires CastIntentStore on the player; add it at spawn time.',
      );
      return;
    }

    final actionAnimIndex = world.actionAnim.tryIndexOf(player);
    if (actionAnimIndex == null) {
      assert(
        false,
        'PlayerCastSystem requires ActionAnimStore on the player; add it at spawn time.',
      );
      return;
    }

    // -- 2. Input Logic --

    // If button not pressed, do nothing.
    if (!world.playerInput.castPressed[inputIndex]) return;

    // TODO: Look up equipped spell instead of hardcoding.
    const spellId = SpellId.iceBolt;

    final facing = world.movement.facing[movementIndex];

    final rawAimX = world.playerInput.projectileAimDirX[inputIndex];
    final rawAimY = world.playerInput.projectileAimDirY[inputIndex];

    // Determine aim direction.
    // If rawAim is essentially zero/unbiased (e.g. controller neutral), use facing.
    // However, currently we pass fallbackDirX to the intent store separately.
    final fallbackDirX = facing == Facing.right ? 1.0 : -1.0;
    
    // Offset from the player's center where the spell appears.
    final spawnOffset = movement.base.playerRadius * 0.5;

    // -- 3. Write Intent --

    // IMPORTANT: PlayerCastSystem writes intent only; execution happens in
    // `SpellCastSystem` which owns mana/cooldown rules and projectile spawning.
    world.castIntent.set(
      player,
      CastIntentDef(
        spellId: spellId,
        dirX: rawAimX,
        dirY: rawAimY,
        fallbackDirX: fallbackDirX,
        fallbackDirY: 0.0,
        originOffset: spawnOffset,
        cooldownTicks: abilities.castCooldownTicks,
        tick: currentTick,
      ),
    );
    world.actionAnim.lastCastTick[actionAnimIndex] = currentTick;
  }
}


===== FILE: lib/core/ecs/systems/player_melee_system.dart =====
import 'dart:math';

import '../../snapshots/enums.dart';
import '../../tuning/ability_tuning.dart';
import '../../tuning/movement_tuning.dart';
import '../../weapons/weapon_catalog.dart';
import '../entity_id.dart';
import '../stores/melee_intent_store.dart';
import '../world.dart';

/// Translates player input into a [MeleeIntentDef] for the [MeleeAttackSystem].
///
/// **Responsibilities**:
/// *   Checks input state (Attack button).
/// *   Calculates attack direction (Analog aim or Facing fallback).
/// *   Calculates hitbox offsets based on attack reach.
/// *   Registers intent (Costs/Cooldowns checked downstream).
class PlayerMeleeSystem {
  const PlayerMeleeSystem({
    required this.abilities,
    required this.movement,
    required this.weapons,
  });

  final AbilityTuningDerived abilities;
  final MovementTuningDerived movement;
  final WeaponCatalog weapons;

  void step(
    EcsWorld world, {
    required EntityId player,
    required int currentTick,
  }) {
    // -- 1. Component Checks --
    
    // Check if the store exists (should be added at spawn).
    if (!world.meleeIntent.has(player)) {
      assert(
        false,
        'PlayerMeleeSystem requires MeleeIntentStore on the player; add it at spawn time.',
      );
      return;
    }

    // Input is required to know if attacking.
    final inputIndex = world.playerInput.tryIndexOf(player);
    if (inputIndex == null) return;
    
    // Movement is required for facing direction fallback.
    final movementIndex = world.movement.tryIndexOf(player);
    if (movementIndex == null) return;

    // Equipped weapon determines status profile, etc.
    final weaponIndex = world.equippedWeapon.tryIndexOf(player);
    if (weaponIndex == null) {
      assert(
        false,
        'PlayerMeleeSystem requires EquippedWeaponStore on the player; add it at spawn time.',
      );
      return;
    }

    // -- 2. Input Logic --

    // If button not pressed, early exit.
    if (!world.playerInput.attackPressed[inputIndex]) return;

    final actionAnimIndex = world.actionAnim.tryIndexOf(player);
    if (actionAnimIndex == null) {
      assert(
        false,
        'PlayerMeleeSystem requires ActionAnimStore on the player; add it at spawn time.',
      );
      return;
    }

    final facing = world.movement.facing[movementIndex];
    final aimX = world.playerInput.meleeAimDirX[inputIndex];
    final aimY = world.playerInput.meleeAimDirY[inputIndex];
    final len2 = aimX * aimX + aimY * aimY;

    // Normalize aim direction if valid, otherwise fallback to facing direction.
    final double dirX;
    final double dirY;
    if (len2 > 1e-12) {
      final invLen = 1.0 / sqrt(len2);
      dirX = aimX * invLen;
      dirY = aimY * invLen;
    } else {
      dirX = (facing == Facing.right) ? 1.0 : -1.0;
      dirY = 0.0;
    }

    // -- 3. Intent Calculation --

    final halfX = abilities.base.meleeHitboxSizeX * 0.5;
    final halfY = abilities.base.meleeHitboxSizeY * 0.5;

    // Calculate how far in front of the player the hitbox should appear.
    // origin = playerPos + aimDir * (playerRadius * 0.5 + maxDimension)
    final forward = movement.base.playerRadius * 0.5 + max(halfX, halfY);
    final offsetX = dirX * forward;
    final offsetY = dirY * forward;

    // IMPORTANT: PlayerMeleeSystem writes intent only; execution happens in
    // `MeleeAttackSystem` which owns stamina/cooldown rules and hitbox spawning.
    final weaponId = world.equippedWeapon.weaponId[weaponIndex];
    final weapon = weapons.get(weaponId);
    world.meleeIntent.set(
      player,
      MeleeIntentDef(
        damage: abilities.base.meleeDamage,
        damageType: weapon.damageType,
        statusProfileId: weapon.statusProfileId,
        halfX: halfX,
        halfY: halfY,
        offsetX: offsetX,
        offsetY: offsetY,
        dirX: dirX,
        dirY: dirY,
        activeTicks: abilities.meleeActiveTicks,
        cooldownTicks: abilities.meleeCooldownTicks,
        staminaCost: abilities.base.meleeStaminaCost,
        tick: currentTick,
      ),
    );
    world.actionAnim.lastMeleeTick[actionAnimIndex] = currentTick;
  }
}


===== FILE: lib/core/ecs/systems/player_movement_system.dart =====
import '../../snapshots/enums.dart';
import '../../tuning/movement_tuning.dart';
import '../../tuning/resource_tuning.dart';
import '../../util/velocity_math.dart';
import '../entity_id.dart';
import '../queries.dart';
import '../world.dart';

/// Applies platformer-style movement for entities with:
/// - Transform
/// - PlayerInput
/// - Movement
/// - Body
///
/// PlayerMovementSystem writes velocities only (input/jump/dash/gravity/clamps).
/// Position integration and collision resolution are handled by CollisionSystem.
///
/// **Responsibilities**:
/// *   Update movement state timers (Dash cooldown, Coyote time, Jump buffer).
/// *   Process Input (Dash request, Jump request, Horizontal move).
/// *   Apply velocities based on state.
class PlayerMovementSystem {
  void step(
    EcsWorld world,
    MovementTuningDerived tuning, {
    required ResourceTuning resources,
  }) {
    final dt = tuning.dtSeconds;
    final t = tuning.base;

    // Iterate over all controllable entities (Join: Movement + Input + Body +...).
    // Uses EcsQueries to efficiently fetch entities with all required components.
    EcsQueries.forMovementBodies(world, (e, mi, ti, ii, bi, ci, si) {
      if (!world.body.enabled[bi]) return;
      
      // Kinematic bodies are moved by scripts/physics directly, not by player input.
      if (world.body.isKinematic[bi]) {
        return;
      }

      // -- Timers --
      // Decrement state timers. These track cooldowns and temporary states (dash, buffers).
      if (world.movement.dashCooldownTicksLeft[mi] > 0) {
        world.movement.dashCooldownTicksLeft[mi] -= 1;
      }
      if (world.movement.dashTicksLeft[mi] > 0) {
        world.movement.dashTicksLeft[mi] -= 1;
      }
      if (world.movement.jumpBufferTicksLeft[mi] > 0) {
        world.movement.jumpBufferTicksLeft[mi] -= 1;
      }

      // -- Coyote Time --
      // "Coyote Time" allows the player to jump for a few frames after walking off a ledge.
      // - If currently grounded (from CollisionSystem last frame), reset the timer to full.
      // - If in air, decrement the timer.
      final wasGrounded = world.collision.grounded[ci];
      if (wasGrounded) {
        world.movement.coyoteTicksLeft[mi] = tuning.coyoteTicks;
      } else if (world.movement.coyoteTicksLeft[mi] > 0) {
        world.movement.coyoteTicksLeft[mi] -= 1;
      }

      // -- Input Buffering --
      // Buffer a jump request if pressed this frame.
      // This allows a jump input slightly BEFORE landing to still register as a jump upon landing.
      if (world.playerInput.jumpPressed[ii]) {
        world.movement.jumpBufferTicksLeft[mi] = tuning.jumpBufferTicks;
      }

      // -- Dash Logic --
      // Attempt to start a dash if requested.
      // Dash is an atomic action that overrides normal movement.
      if (world.playerInput.dashPressed[ii]) {
        _tryStartDash(
          world,
          entity: e,
          mi: mi,
          ti: ti,
          ii: ii,
          si: si,
          tuning: tuning,
          staminaCost: resources.dashStaminaCost,
        );
      }

      final dashing = world.movement.dashTicksLeft[mi] > 0;
      final modifierIndex = world.statModifier.tryIndexOf(e);
      final moveSpeedMul =
          modifierIndex == null ? 1.0 : world.statModifier.moveSpeedMul[modifierIndex];

      // -- Horizontal Movement --
      if (dashing) {
        // [State: Dashing]
        // Lock velocity to the dash direction and speed.
        // Zero out Y velocity to prevent gravity from affecting the dash arc (linear dash).
        world.transform.velX[ti] =
            world.movement.dashDirX[mi] * t.dashSpeedX * moveSpeedMul;
        world.transform.velY[ti] = 0;
      } else {
        // [State: Normal Control]
        final axis = world.playerInput.moveAxis[ii];
        
        // Visuals: Update facing direction based on input.
        // This is decoupled from velocity to allow "turning" animations before velocity flips.
        if (axis != 0) {
          world.movement.facing[mi] = axis > 0 ? Facing.right : Facing.left;
        }

        // Apply horizontal acceleration/deceleration.
        world.transform.velX[ti] = _applyHorizontalMove(
          world.transform.velX[ti],
          axis,
          dt,
          tuning,
          moveSpeedMul,
        );

        // -- Jumping --
        // Execute Jump if:
        // 1. Jump is buffered (Pressed recently).
        // 2. Player can jump (Grounded OR Coyote Time active).
        // 3. Sufficient Stamina.
        if (world.movement.jumpBufferTicksLeft[mi] > 0 &&
            (wasGrounded || world.movement.coyoteTicksLeft[mi] > 0)) {
          if (world.stamina.stamina[si] >= resources.jumpStaminaCost) {
            world.stamina.stamina[si] -= resources.jumpStaminaCost;

            // Apply instantaneous upward velocity.
            world.transform.velY[ti] = -t.jumpSpeed;
            
            // Consume the buffer and coyote time immediately to prevent double-jumping
            // in the same window.
            world.movement.jumpBufferTicksLeft[mi] = 0;
            world.movement.coyoteTicksLeft[mi] = 0;
          }
        }
      }

      // -- Limits --
      // Soft cap on horizontal velocity to prevent runaway speeds from external forces.
      world.transform.velX[ti] = world.transform.velX[ti]
          .clamp(-world.body.maxVelX[bi], world.body.maxVelX[bi]);
    });
  }

  /// Calculates the new horizontal velocity using linear acceleration/deceleration.
  ///
  /// Note:
  /// - Uses [t.decelerationX] when `axis == 0` (Stopping).
  /// - Uses [t.accelerationX] for both Speeding Up and Turning (changing direction).
  /// - Snaps to 0 if speed is below [t.minMoveSpeed] and input is 0.
  double _applyHorizontalMove(
    double velocityX,
    double axis,
    double dt,
    MovementTuningDerived tuning,
    double moveSpeedMul,
  ) {
    final t = tuning.base;
    final desiredX = axis == 0.0 ? 0.0 : axis * t.maxSpeedX * moveSpeedMul;
    return applyAccelDecel(
      current: velocityX,
      desired: desiredX,
      dtSeconds: dt,
      accelPerSecond: t.accelerationX * moveSpeedMul,
      decelPerSecond: t.decelerationX * moveSpeedMul,
      minStopSpeed: t.minMoveSpeed,
    );
  }

  /// Attempts to initiate a dash action.
  ///
  /// **Logic**:
  /// 1.  **Checks**: Must not be Dashing, Cooldown active, or Insufficient Stamina.
  /// 2.  **Direction**: Prioritizes raw input [axis]. If neutral, uses current [facing].
  /// 3.  **Physics**: Cancels vertical velocity and suppresses gravity for duration.
  /// 4.  **State**: Sets cooldowns and consumes stamina.
  void _tryStartDash(
    EcsWorld world, {
    required EntityId entity,
    required int mi,
    required int ti,
    required int ii,
    required int si,
    required MovementTuningDerived tuning,
    required double staminaCost,
  }) {
    if (world.movement.dashTicksLeft[mi] > 0) return;
    if (world.movement.dashCooldownTicksLeft[mi] > 0) return;
    if (world.stamina.stamina[si] < staminaCost) return;

    // Determine Dash Direction:
    // - If holding direction: Dash that way.
    // - If neutral: Dash forward (current facing).
    final axis = world.playerInput.moveAxis[ii];
    final dirX = axis != 0
        ? (axis > 0 ? 1.0 : -1.0)
        : (world.movement.facing[mi] == Facing.right ? 1.0 : -1.0);

    world.movement.dashDirX[mi] = dirX;
    world.movement.facing[mi] = dirX > 0 ? Facing.right : Facing.left;

    world.movement.dashTicksLeft[mi] = tuning.dashDurationTicks;
    world.movement.dashCooldownTicksLeft[mi] = tuning.dashCooldownTicks;

    // Cancel vertical motion so dash doesn't inherit jump/fall.
    // Suppress gravity to ensure linear horizontal movement.
    world.transform.velY[ti] = 0;
    world.gravityControl.setSuppressForTicks(entity, tuning.dashDurationTicks);

    world.stamina.stamina[si] -= staminaCost;
  }
}


===== FILE: lib/core/ecs/systems/player_ranged_weapon_system.dart =====
import '../../snapshots/enums.dart';
import '../../weapons/ranged_weapon_catalog.dart';
import '../entity_id.dart';
import '../stores/ranged_weapon_intent_store.dart';
import '../world.dart';

/// Translates player input into a [RangedWeaponIntentDef] for the
/// [RangedWeaponAttackSystem].
class PlayerRangedWeaponSystem {
  const PlayerRangedWeaponSystem({required this.weapons});

  final RangedWeaponCatalog weapons;

  void step(
    EcsWorld world, {
    required EntityId player,
    required int currentTick,
  }) {
    // We need input to know if firing.
    final inputIndex = world.playerInput.tryIndexOf(player);
    if (inputIndex == null) return;

    // Facing direction is used as fallback aim.
    final movementIndex = world.movement.tryIndexOf(player);
    if (movementIndex == null) return;

    if (!world.rangedWeaponIntent.has(player)) {
      assert(
        false,
        'PlayerRangedWeaponSystem requires RangedWeaponIntentStore on the player; add it at spawn time.',
      );
      return;
    }

    final equippedIndex = world.equippedRangedWeapon.tryIndexOf(player);
    if (equippedIndex == null) {
      assert(
        false,
        'PlayerRangedWeaponSystem requires EquippedRangedWeaponStore on the player; add it at spawn time.',
      );
      return;
    }

    if (!world.playerInput.rangedPressed[inputIndex]) return;

    final weaponId = world.equippedRangedWeapon.weaponId[equippedIndex];
    final weapon = weapons.get(weaponId);

    final facing = world.movement.facing[movementIndex];
    final fallbackDirX = facing == Facing.right ? 1.0 : -1.0;

    world.rangedWeaponIntent.set(
      player,
      RangedWeaponIntentDef(
        weaponId: weaponId,
        dirX: world.playerInput.rangedAimDirX[inputIndex],
        dirY: world.playerInput.rangedAimDirY[inputIndex],
        fallbackDirX: fallbackDirX,
        fallbackDirY: 0.0,
        originOffset: weapon.originOffset,
        tick: currentTick,
      ),
    );
  }
}



===== FILE: lib/core/ecs/systems/projectile_hit_system.dart =====
import '../../combat/damage.dart';
import '../../events/game_event.dart';
import '../entity_id.dart';
import '../hit/hit_resolver.dart';
import '../spatial/broadphase_grid.dart';
import '../world.dart';

/// Handles collision detection for projectiles against potentially damageable targets.
///
/// **Responsibilities**:
/// - Iterates all active projectiles.
/// - Calculates a swept capsule shape for the projectile based on its velocity/direction.
/// - Queries the [BroadphaseGrid] for collisions.
/// - Queues [DamageRequest] and despawns the projectile on impact.
class ProjectileHitSystem {
  final List<EntityId> _toDespawn = <EntityId>[];
  final HitResolver _resolver = HitResolver();

  /// Runs the system logic for a single tick.
  ///
  /// [queueDamage] is a callback to the central `DamageSystem` or event queue.
  /// [broadphase] provides spatial acceleration for finding targets efficiently.
  void step(
    EcsWorld world,
    void Function(DamageRequest request) queueDamage,
    BroadphaseGrid broadphase,
  ) {
    // Optimization: If there are no targets to hit, projectiles just fly.
    if (broadphase.targets.isEmpty) return;
    
    final projectiles = world.projectile;
    if (projectiles.denseEntities.isEmpty) return;

    _toDespawn.clear();

    // Cache store references for efficient lookup (Hoisting).
    final transforms = world.transform;
    final colliders = world.colliderAabb;
    final enemies = world.enemy;
    final spellOrigins = world.spellOrigin;

    final count = projectiles.denseEntities.length;
    for (var pi = 0; pi < count; pi += 1) {
      final p = projectiles.denseEntities[pi];
      
      // Validation: Projectiles must have physical presence.
      final ti = transforms.tryIndexOf(p);
      if (ti == null) continue;

      final ci = colliders.tryIndexOf(p);
      if (ci == null) continue;

      // -- Geometry Construction --
      // Projectiles are modeled as capsules (swept circles) oriented along their velocity vector.
      // - [offsetX/Y]: Center offset relative to transform.
      // - [halfX]: Interpreted as half-length of the capsule shaft.
      // - [halfY]: Interpreted as the radius (thickness) of the projectile.
      final pcx = transforms.posX[ti] + colliders.offsetX[ci];
      final pcy = transforms.posY[ti] + colliders.offsetY[ci];
      
      final halfLength = colliders.halfX[ci];
      final radius = colliders.halfY[ci];
      
      final dirX = projectiles.dirX[pi];
      final dirY = projectiles.dirY[pi];

      // Calculate the start (A) and end (B) points of the capsule segment.
      // The segment is centered at (pcx, pcy) and extends halfLength in both directions along (dirX, dirY).
      final ax = pcx - dirX * halfLength;
      final ay = pcy - dirY * halfLength;
      final bx = pcx + dirX * halfLength;
      final by = pcy + dirY * halfLength;

      // -- Hit Resolution --
      final owner = projectiles.owner[pi];
      final sourceFaction = projectiles.faction[pi];

      // Query the broadphase for the first valid intersection.
      // This respects "Friendly Fire" rules via [sourceFaction].
      final targetIndex = _resolver.firstOrderedOverlapCapsule(
        broadphase: broadphase,
        ax: ax,
        ay: ay,
        bx: bx,
        by: by,
        radius: radius,
        owner: owner,
        sourceFaction: sourceFaction,
      );

      // -- Impact Handling --
      if (targetIndex != null) {
        // Optimization: Resolve heavy metadata (EnemyId, SpellId) ONLY when a hit actually occurs.
        // Doing this before the hit check would waste cycles for the 99% of frames a projectile is just flying.
        final ei = enemies.tryIndexOf(owner);
        final enemyId = ei != null ? enemies.enemyId[ei] : null;
        
        final si = spellOrigins.tryIndexOf(p);
        final spellId = si != null ? spellOrigins.spellId[si] : null;

        // Dispatch damage event.
        queueDamage(
          DamageRequest(
            target: broadphase.targets.entities[targetIndex],
            amount: projectiles.damage[pi],
            damageType: projectiles.damageType[pi],
            statusProfileId: projectiles.statusProfileId[pi],
            source: owner,
            sourceKind: DeathSourceKind.projectile,
            sourceEnemyId: enemyId,
            sourceProjectileId: projectiles.projectileId[pi],
            sourceSpellId: spellId,
          ),
        );
        
        // Mark projectile for removal.
        // We defer removal until after the loop or use a list to avoid modifying the collection while iterating
        // (though we are iterating by index here, deferred removal is safer/cleaner pattern).
        _toDespawn.add(p);
      }
    }

    // Process despawns.
    for (final e in _toDespawn) {
      world.destroyEntity(e);
    }
  }
}


===== FILE: lib/core/ecs/systems/projectile_system.dart =====
import 'dart:math';

import '../../tuning/movement_tuning.dart';
import '../world.dart';

/// Moves active projectiles based on their linear velocity.
///
/// **Responsibilities**:
/// - Updates `velX` and `velY` (for use by renderers/interpolation).
/// - Explicitly integrates position: `pos += vel * dt`.
///
/// Note: Projectiles are typically simple kinematic objects that do not participate
/// in the full physics/collision resolution loop (no `Body` component), hence the
/// manual position integration here.
class ProjectileSystem {
  void step(EcsWorld world, MovementTuningDerived movement) {
    final dt = movement.dtSeconds;
    final projectiles = world.projectile;
    final transforms = world.transform;

    // Iterate efficiently over dense projectile arrays.
    final count = projectiles.denseEntities.length;
    for (var pi = 0; pi < count; pi += 1) {
      final e = projectiles.denseEntities[pi];
      
      final ti = transforms.tryIndexOf(e);
      if (ti == null) continue;

      // Physics-driven projectiles (ballistic) are moved by the main physics
      // pipeline (GravitySystem + CollisionSystem). We only keep direction
      // in sync with velocity for hitbox orientation / rendering.
      if (projectiles.usePhysics[pi]) {
        final vx = transforms.velX[ti];
        final vy = transforms.velY[ti];
        final len2 = vx * vx + vy * vy;
        if (len2 > 1e-12) {
          final invLen = 1.0 / sqrt(len2);
          projectiles.dirX[pi] = vx * invLen;
          projectiles.dirY[pi] = vy * invLen;
        }
        continue;
      }

      // Calculate velocity from direction and speed.
      final vx = projectiles.dirX[pi] * projectiles.speedUnitsPerSecond[pi];
      final vy = projectiles.dirY[pi] * projectiles.speedUnitsPerSecond[pi];

      // Update Transform velocity (useful for other systems/debug).
      transforms.velX[ti] = vx;
      transforms.velY[ti] = vy;

      // Explicit Euler integration: pos += vel * dt
      // We do this here because projectiles lack a 'Body' component for simplicity
      // and thus aren't moved by the main physics solver.
      transforms.posX[ti] += vx * dt;
      transforms.posY[ti] += vy * dt;
    }
  }
}


===== FILE: lib/core/ecs/systems/projectile_world_collision_system.dart =====
import '../entity_id.dart';
import '../world.dart';

/// Despawns physics-driven projectiles that collided with the static world.
///
/// This is intended for ballistic projectiles (arrows, thrown axes) that use
/// [BodyStore] + [CollisionSystem] for ground/wall collision. When a collision
/// occurs, the projectile is removed immediately (same tick).
class ProjectileWorldCollisionSystem {
  final List<EntityId> _toDespawn = <EntityId>[];

  void step(EcsWorld world) {
    final projectiles = world.projectile;
    if (projectiles.denseEntities.isEmpty) return;

    final collisions = world.collision;
    if (collisions.denseEntities.isEmpty) return;

    _toDespawn.clear();
    for (var pi = 0; pi < projectiles.denseEntities.length; pi += 1) {
      if (!projectiles.usePhysics[pi]) continue;

      final p = projectiles.denseEntities[pi];
      final ci = collisions.tryIndexOf(p);
      if (ci == null) continue;

      if (collisions.grounded[ci] ||
          collisions.hitCeiling[ci] ||
          collisions.hitLeft[ci] ||
          collisions.hitRight[ci]) {
        _toDespawn.add(p);
      }
    }

    for (final p in _toDespawn) {
      world.destroyEntity(p);
    }
  }
}



===== FILE: lib/core/ecs/systems/ranged_weapon_attack_system.dart =====
import '../../util/double_math.dart';
import '../../weapons/ranged_weapon_catalog.dart';
import '../../weapons/spawn_ranged_weapon_projectile.dart';
import '../world.dart';
import '../../projectiles/projectile_catalog.dart';

/// Executes [RangedWeaponIntentStore] intents by spawning weapon projectiles and
/// managing costs (stamina + ammo + cooldowns).
class RangedWeaponAttackSystem {
  RangedWeaponAttackSystem({
    required this.weapons,
    required this.projectiles,
  });

  final RangedWeaponCatalogDerived weapons;
  final ProjectileCatalogDerived projectiles;

  void step(EcsWorld world, {required int currentTick}) {
    final intents = world.rangedWeaponIntent;
    if (intents.denseEntities.isEmpty) return;

    final transforms = world.transform;
    final cooldowns = world.cooldown;
    final staminas = world.stamina;
    final ammos = world.ammo;
    final factions = world.faction;

    final count = intents.denseEntities.length;
    for (var ii = 0; ii < count; ii += 1) {
      if (intents.tick[ii] != currentTick) continue;

      final caster = intents.denseEntities[ii];

      // Invalidate intent immediately.
      intents.tick[ii] = -1;

      final ti = transforms.tryIndexOf(caster);
      if (ti == null) continue;

      final ci = cooldowns.tryIndexOf(caster);
      if (ci == null) continue;
      if (cooldowns.rangedWeaponCooldownTicksLeft[ci] > 0) continue;

      final fi = factions.tryIndexOf(caster);
      if (fi == null) continue;
      final faction = factions.faction[fi];

      final weaponId = intents.weaponId[ii];
      final weapon = weapons.base.get(weaponId);

      // Stamina check.
      final staminaCost = weapon.staminaCost;
      int? si;
      double? nextStamina;
      if (staminaCost > 0.0) {
        si = staminas.tryIndexOf(caster);
        if (si == null) continue;
        final currentStamina = staminas.stamina[si];
        if (currentStamina < staminaCost) continue;
        nextStamina = currentStamina - staminaCost;
      }

      // Ammo check.
      final ammoCost = weapon.ammoCost;
      int? ai;
      int? nextAmmo;
      if (ammoCost > 0) {
        ai = ammos.tryIndexOf(caster);
        if (ai == null) continue;
        final currentAmmo = ammos.countForIndex(ai, weapon.ammoType);
        if (currentAmmo < ammoCost) continue;
        nextAmmo = currentAmmo - ammoCost;
      }

      spawnRangedWeaponProjectileFromCaster(
        world,
        projectiles: projectiles,
        projectileId: weapon.projectileId,
        faction: faction,
        owner: caster,
        casterX: transforms.posX[ti],
        casterY: transforms.posY[ti],
        originOffset: intents.originOffset[ii],
        dirX: intents.dirX[ii],
        dirY: intents.dirY[ii],
        fallbackDirX: intents.fallbackDirX[ii],
        fallbackDirY: intents.fallbackDirY[ii],
        damage: weapon.damage,
        damageType: weapon.damageType,
        statusProfileId: weapon.statusProfileId,
        ballistic: weapon.ballistic,
        gravityScale: weapon.gravityScale,
      );

      // Apply costs.
      if (si != null) {
        staminas.stamina[si] =
            clampDouble(nextStamina!, 0.0, staminas.staminaMax[si]);
      }
      if (ai != null) {
        ammos.setCountForIndex(ai, weapon.ammoType, nextAmmo!);
      }
      cooldowns.rangedWeaponCooldownTicksLeft[ci] =
          weapons.cooldownTicks(weaponId);
    }
  }
}



===== FILE: lib/core/ecs/systems/resource_regen_system.dart =====
import '../../util/double_math.dart';
import '../world.dart';

/// Periodically regenerates Health, Mana, and Stamina for all entities.
///
/// **Responsibilities**:
/// - Iterates over all entities with [Health], [Mana], or [Stamina].
/// - Applies regeneration rates (`regenPerSecond`) scaled by `dtSeconds`.
/// - Clamps values to `[0, Max]`.
///
/// **Performance**:
/// - Uses direct dense array iteration (Structure of Arrays) for cache efficiency.
/// - Skips full resources and zero-regen entities early.
class ResourceRegenSystem {
  void step(EcsWorld world, {required double dtSeconds}) {
    _regenHealth(world, dtSeconds);
    _regenMana(world, dtSeconds);
    _regenStamina(world, dtSeconds);
  }

  void _regenHealth(EcsWorld world, double dtSeconds) {
    final store = world.health;
    final count = store.denseEntities.length;
    // Iterate contiguous arrays directly (SoA pattern).
    for (var i = 0; i < count; i += 1) {
      final max = store.hpMax[i];
      if (max <= 0) continue;
      
      final current = store.hp[i];
      if (current >= max) continue;
      
      final regen = store.regenPerSecond[i];
      if (regen <= 0) continue;
      
      store.hp[i] = clampDouble(current + regen * dtSeconds, 0.0, max);
    }
  }

  void _regenMana(EcsWorld world, double dtSeconds) {
    final store = world.mana;
    final count = store.denseEntities.length;
    for (var i = 0; i < count; i += 1) {
      final max = store.manaMax[i];
      if (max <= 0) continue;
      
      final current = store.mana[i];
      if (current >= max) continue;
      
      final regen = store.regenPerSecond[i];
      if (regen <= 0) continue;
      
      store.mana[i] = clampDouble(current + regen * dtSeconds, 0.0, max);
    }
  }

  void _regenStamina(EcsWorld world, double dtSeconds) {
    final store = world.stamina;
    final count = store.denseEntities.length;
    for (var i = 0; i < count; i += 1) {
      final max = store.staminaMax[i];
      if (max <= 0) continue;
      
      final current = store.stamina[i];
      if (current >= max) continue;
      
      final regen = store.regenPerSecond[i];
      if (regen <= 0) continue;
      
      store.stamina[i] = clampDouble(current + regen * dtSeconds, 0.0, max);
    }
  }
}


===== FILE: lib/core/ecs/systems/restoration_item_system.dart =====
import 'dart:math' as math;
import '../entity_id.dart';
import '../world.dart';
import '../stores/restoration_item_store.dart';
import '../../tuning/restoration_item_tuning.dart';

/// Handles the lifecycle and collision of restoration pickups (Health/Mana/Stamina potions).
///
/// **Responsibilities**:
/// - Despawns items that fall too far behind the camera.
/// - Checks for collision with the Player.
/// - Applies restoration effects and despawns on pickup.
class RestorationItemSystem {
  final List<EntityId> _toDespawn = <EntityId>[];

  /// Executes the system logic for a single frame.
  ///
  /// - [player]: The valid [EntityId] of the local player character.
  /// - [cameraLeft]: The X coordinate of the camera's left edge (used for culling).
  /// - [tuning]: Configuration values for pickup ranges and restore amounts.
  void step(
    EcsWorld world, {
    required EntityId player,
    required double cameraLeft,
    required RestorationItemTuning tuning,
  }) {
    final items = world.restorationItem;
    // Early exit if no items exist to process.
    if (items.denseEntities.isEmpty) return;
    
    _toDespawn.clear();
    final despawnLimit = cameraLeft - tuning.despawnBehindCameraMargin;

    // -- Resolve Player AABB (Optimization) --
    // We cache the player's world-space bounds once per frame.
    final transforms = world.transform;
    final colliders = world.colliderAabb;

    final pTi = transforms.tryIndexOf(player);
    final pCi = colliders.tryIndexOf(player);
    
    // Bounds: Min/Max X/Y
    double pMinX = 0, pMaxX = 0, pMinY = 0, pMaxY = 0;
    bool playerActive = false;

    if (pTi != null && pCi != null) {
      playerActive = true;
      final cx = transforms.posX[pTi] + colliders.offsetX[pCi];
      final cy = transforms.posY[pTi] + colliders.offsetY[pCi];
      final hx = colliders.halfX[pCi];
      final hy = colliders.halfY[pCi];
      pMinX = cx - hx;
      pMaxX = cx + hx;
      pMinY = cy - hy;
      pMaxY = cy + hy;
    }

    // -- Iterate Items --
    final count = items.denseEntities.length;
    for (var ii = 0; ii < count; ii += 1) {
      final e = items.denseEntities[ii];
      
      final ti = transforms.tryIndexOf(e);
      // Skip items that are missing spatial components (malformed entities).
      if (ti == null) continue;
      
      final ci = colliders.tryIndexOf(e);
      if (ci == null) continue;

      final cx = transforms.posX[ti] + colliders.offsetX[ci];
      
      // 1. Despawn Logic (Garbage Collection)
      if (cx < despawnLimit) {
        _toDespawn.add(e);
        continue;
      }

      // 2. Collision Check (Pickup)
      if (playerActive) {
        final cy = transforms.posY[ti] + colliders.offsetY[ci];
        final hx = colliders.halfX[ci];
        final hy = colliders.halfY[ci];

        // AABB Overlap Logic:
        final overlaps = (cx - hx) < pMaxX && 
                         (cx + hx) > pMinX && 
                         (cy - hy) < pMaxY && 
                         (cy + hy) > pMinY;

        if (overlaps) {
          _applyRestore(
            world,
            player: player,
            stat: items.stat[ii],
            percent: tuning.restorePercent,
          );
          _toDespawn.add(e);
        }
      }
    }

    // Process all despawns in batch at the end of the frame.
    for (final e in _toDespawn) {
      world.destroyEntity(e);
    }
  }

  /// RESTORES a specific stat on the target [player].
  ///
  /// - [percent]: Percentage of MAX value to restore (0.0 to 1.0).
  /// - Scales based on the player's Max HP/Mana/Stamina.
  /// - Clamps to Max value (prevents overhealing).
  void _applyRestore(
    EcsWorld world, {
    required EntityId player,
    required RestorationStat stat,
    required double percent,
  }) {
    // Note: We use min/max checks to ensure we don't overheal or divide by zero.
    switch (stat) {
      case RestorationStat.health:
        final index = world.health.tryIndexOf(player);
        if (index != null) {
          final max = world.health.hpMax[index];
          if (max > 0) {
            world.health.hp[index] = math.min(max, world.health.hp[index] + max * percent);
          }
        }
      case RestorationStat.mana:
        final index = world.mana.tryIndexOf(player);
        if (index != null) {
          final max = world.mana.manaMax[index];
          if (max > 0) {
            world.mana.mana[index] = math.min(max, world.mana.mana[index] + max * percent);
          }
        }
      case RestorationStat.stamina:
        final index = world.stamina.tryIndexOf(player);
        if (index != null) {
          final max = world.stamina.staminaMax[index];
          if (max > 0) {
            world.stamina.stamina[index] = math.min(max, world.stamina.stamina[index] + max * percent);
          }
        }
    }
  }
}


===== FILE: lib/core/ecs/systems/spell_cast_system.dart =====
import '../../spells/spawn_spell_projectile.dart';
import '../../spells/spell_catalog.dart';
import '../../util/double_math.dart';
import '../world.dart';
import '../../projectiles/projectile_catalog.dart';

/// Executes [CastIntentStore] intents by spawning projectiles and managing resources.
///
/// **Responsibilities**:
/// - Consumes [CastIntent] stamped with the `currentTick`.
/// - Checks validation (Cooldowns, Mana cost, Entity existence).
/// - Spawns Spell Projectiles via [spawnSpellProjectileFromCaster].
/// - Deducts Mana and applies Cooldown IF spawn succeeds.
///
/// **Logic**:
/// - Intents are processed only once per tick.
/// - Invalidated immediately (`tick = -1`) to prevent double-execution.
class SpellCastSystem {
  SpellCastSystem({
    required this.spells,
    required this.projectiles,
  });

  final SpellCatalog spells;
  final ProjectileCatalogDerived projectiles;

  void step(EcsWorld world, {required int currentTick}) {
    final intents = world.castIntent;
    if (intents.denseEntities.isEmpty) return;

    // Cache stores for efficient access
    final transforms = world.transform;
    final cooldowns = world.cooldown;
    final manas = world.mana;
    final factions = world.faction;

    final count = intents.denseEntities.length;
    for (var ii = 0; ii < count; ii += 1) {
      if (intents.tick[ii] != currentTick) continue;

      final caster = intents.denseEntities[ii];

      // Safe-guard: Invalidate intent immediately to prevent re-entry within the same tick.
      intents.tick[ii] = -1;

      // -- Validation Checks --
      // Must have position, cooldowns, and mana components.
      final ti = transforms.tryIndexOf(caster);
      if (ti == null) continue;

      final ci = cooldowns.tryIndexOf(caster);
      if (ci == null) continue;
      
      // Check cooldown (must be ready).
      if (cooldowns.castCooldownTicksLeft[ci] > 0) continue;

      final mi = manas.tryIndexOf(caster);
      if (mi == null) continue;

      // Check Mana Cost.
      final spellId = intents.spellId[ii];
      final def = spells.get(spellId);
      final currentMana = manas.mana[mi];
      
      if (currentMana < def.stats.manaCost) continue;

      // Faction is optional generally, but required for projectile ownership usually.
      final fi = factions.tryIndexOf(caster);
      if (fi == null) continue;
      final faction = factions.faction[fi];

      // -- Execution --
      final spawned = spawnSpellProjectileFromCaster(
        world,
        spells: spells,
        projectiles: projectiles,
        spellId: spellId,
        faction: faction,
        owner: caster,
        casterX: transforms.posX[ti],
        casterY: transforms.posY[ti],
        originOffset: intents.originOffset[ii],
        dirX: intents.dirX[ii],
        dirY: intents.dirY[ii],
        fallbackDirX: intents.fallbackDirX[ii],
        fallbackDirY: intents.fallbackDirY[ii],
      );

      // Only apply costs if the spell actually did something (spawned).
      if (spawned == null) continue;

      manas.mana[mi] = clampDouble(
        currentMana - def.stats.manaCost,
        0.0,
        manas.manaMax[mi],
      );
      
      cooldowns.castCooldownTicksLeft[ci] = intents.cooldownTicks[ii];
    }
  }
}


===== FILE: lib/core/ecs/systems/status_system.dart =====
import '../../combat/damage.dart';
import '../../combat/damage_type.dart';
import '../../combat/status/status.dart';
import '../../events/game_event.dart';
import '../../util/double_math.dart';
import '../../util/tick_math.dart';
import '../entity_id.dart';
import '../stores/status/bleed_store.dart';
import '../stores/status/burn_store.dart';
import '../stores/status/slow_store.dart';
import '../world.dart';

/// Applies status effects and ticks active statuses.
class StatusSystem {
  StatusSystem({
    required int tickHz,
    StatusProfileCatalog profiles = const StatusProfileCatalog(),
  }) : _tickHz = tickHz,
       _profiles = profiles;

  final int _tickHz;
  final StatusProfileCatalog _profiles;

  final List<StatusRequest> _pending = <StatusRequest>[];
  final List<EntityId> _removeScratch = <EntityId>[];

  /// Queues a status profile to apply.
  void queue(StatusRequest request) {
    if (request.profileId == StatusProfileId.none) return;
    _pending.add(request);
  }

  /// Ticks existing statuses and queues DoT damage.
  void tickExisting(
    EcsWorld world,
    void Function(DamageRequest request) queueDamage,
  ) {
    _tickBurn(world, queueDamage);
    _tickBleed(world, queueDamage);
    _tickSlow(world);
  }

  /// Applies queued statuses and refreshes derived modifiers.
  void applyQueued(EcsWorld world) {
    if (_pending.isNotEmpty) {
      _applyPending(world);
      _pending.clear();
    }
    _refreshMoveSpeed(world);
  }

  void _tickBurn(
    EcsWorld world,
    void Function(DamageRequest request) queueDamage,
  ) {
    final burn = world.burn;
    if (burn.denseEntities.isEmpty) return;

    _removeScratch.clear();
    for (var i = 0; i < burn.denseEntities.length; i += 1) {
      final target = burn.denseEntities[i];
      burn.ticksLeft[i] -= 1;
      if (burn.ticksLeft[i] <= 0) {
        _removeScratch.add(target);
        continue;
      }

      burn.periodTicksLeft[i] -= 1;
      if (burn.periodTicksLeft[i] <= 0) {
        burn.periodTicksLeft[i] = burn.periodTicks[i];
        queueDamage(
          DamageRequest(
            target: target,
            amount: burn.damagePerTick[i],
            damageType: DamageType.fire,
            sourceKind: DeathSourceKind.statusEffect,
          ),
        );
      }
    }
    for (final target in _removeScratch) {
      burn.removeEntity(target);
    }
  }

  void _tickBleed(
    EcsWorld world,
    void Function(DamageRequest request) queueDamage,
  ) {
    final bleed = world.bleed;
    if (bleed.denseEntities.isEmpty) return;

    _removeScratch.clear();
    for (var i = 0; i < bleed.denseEntities.length; i += 1) {
      final target = bleed.denseEntities[i];
      bleed.ticksLeft[i] -= 1;
      if (bleed.ticksLeft[i] <= 0) {
        _removeScratch.add(target);
        continue;
      }

      bleed.periodTicksLeft[i] -= 1;
      if (bleed.periodTicksLeft[i] <= 0) {
        bleed.periodTicksLeft[i] = bleed.periodTicks[i];
        queueDamage(
          DamageRequest(
            target: target,
            amount: bleed.damagePerTick[i],
            damageType: DamageType.bleed,
            sourceKind: DeathSourceKind.statusEffect,
          ),
        );
      }
    }
    for (final target in _removeScratch) {
      bleed.removeEntity(target);
    }
  }

  void _tickSlow(EcsWorld world) {
    final slow = world.slow;
    if (slow.denseEntities.isEmpty) return;

    _removeScratch.clear();
    for (var i = 0; i < slow.denseEntities.length; i += 1) {
      final target = slow.denseEntities[i];
      slow.ticksLeft[i] -= 1;
      if (slow.ticksLeft[i] <= 0) {
        _removeScratch.add(target);
      }
    }
    for (final target in _removeScratch) {
      slow.removeEntity(target);
    }
  }

  void _applyPending(EcsWorld world) {
    final resistance = world.damageResistance;
    final immunity = world.statusImmunity;
    final invuln = world.invulnerability;

    for (final req in _pending) {
      if (!world.health.has(req.target)) continue;

      final ii = invuln.tryIndexOf(req.target);
      if (ii != null && invuln.ticksLeft[ii] > 0) continue;

      final profile = _profiles.get(req.profileId);
      if (profile.applications.isEmpty) continue;

      for (final app in profile.applications) {
        if (immunity.isImmune(req.target, app.type)) continue;

        var magnitude = app.magnitude;
        if (app.scaleByDamageType) {
          final mod = resistance.modForEntity(req.target, req.damageType);
          if (mod > 0.0) {
            magnitude *= 1.0 + mod;
          }
        }
        if (magnitude <= 0.0) continue;

        switch (app.type) {
          case StatusEffectType.slow:
            _applySlow(world, req.target, magnitude, app.durationSeconds);
          case StatusEffectType.burn:
            _applyDot(
              world,
              target: req.target,
              magnitude: magnitude,
              durationSeconds: app.durationSeconds,
              periodSeconds: app.periodSeconds,
              useBurn: true,
            );
          case StatusEffectType.bleed:
            _applyDot(
              world,
              target: req.target,
              magnitude: magnitude,
              durationSeconds: app.durationSeconds,
              periodSeconds: app.periodSeconds,
              useBurn: false,
            );
        }
      }
    }
  }

  void _applySlow(
    EcsWorld world,
    EntityId target,
    double magnitude,
    double durationSeconds,
  ) {
    if (!world.statModifier.has(target)) return;
    final ticksLeft = ticksFromSecondsCeil(durationSeconds, _tickHz);
    if (ticksLeft <= 0) return;

    final slow = world.slow;
    final clamped = clampDouble(magnitude, 0.0, 0.9);
    final index = slow.tryIndexOf(target);
    if (index == null) {
      slow.add(
        target,
        SlowDef(ticksLeft: ticksLeft, magnitude: clamped),
      );
    } else {
      slow.ticksLeft[index] = slow.ticksLeft[index] > ticksLeft
          ? slow.ticksLeft[index]
          : ticksLeft;
      if (clamped > slow.magnitude[index]) {
        slow.magnitude[index] = clamped;
      }
    }
  }

  void _applyDot(
    EcsWorld world, {
    required EntityId target,
    required double magnitude,
    required double durationSeconds,
    required double periodSeconds,
    required bool useBurn,
  }) {
    final ticksLeft = ticksFromSecondsCeil(durationSeconds, _tickHz);
    if (ticksLeft <= 0) return;

    final periodTicks = periodSeconds <= 0.0
        ? 1
        : ticksFromSecondsCeil(periodSeconds, _tickHz);
    final periodSecondsResolved = periodTicks / _tickHz;
    final damagePerTick = magnitude * periodSecondsResolved;

    if (useBurn) {
      final burn = world.burn;
      final index = burn.tryIndexOf(target);
      if (index == null) {
        burn.add(
          target,
          BurnDef(
            ticksLeft: ticksLeft,
            periodTicks: periodTicks,
            damagePerTick: damagePerTick,
          ),
        );
      } else {
        burn.ticksLeft[index] =
            burn.ticksLeft[index] > ticksLeft ? burn.ticksLeft[index] : ticksLeft;
        if (damagePerTick > burn.damagePerTick[index]) {
          burn.damagePerTick[index] = damagePerTick;
        }
        burn.periodTicks[index] = periodTicks;
        burn.periodTicksLeft[index] = periodTicks;
      }
      return;
    }

    final bleed = world.bleed;
    final index = bleed.tryIndexOf(target);
    if (index == null) {
      bleed.add(
        target,
        BleedDef(
          ticksLeft: ticksLeft,
          periodTicks: periodTicks,
          damagePerTick: damagePerTick,
        ),
      );
    } else {
      bleed.ticksLeft[index] =
          bleed.ticksLeft[index] > ticksLeft ? bleed.ticksLeft[index] : ticksLeft;
      if (damagePerTick > bleed.damagePerTick[index]) {
        bleed.damagePerTick[index] = damagePerTick;
      }
      bleed.periodTicks[index] = periodTicks;
      bleed.periodTicksLeft[index] = periodTicks;
    }
  }

  void _refreshMoveSpeed(EcsWorld world) {
    final mods = world.statModifier;
    if (mods.denseEntities.isEmpty) return;

    for (var i = 0; i < mods.denseEntities.length; i += 1) {
      mods.moveSpeedMul[i] = 1.0;
    }

    final slow = world.slow;
    if (slow.denseEntities.isEmpty) return;

    for (var i = 0; i < slow.denseEntities.length; i += 1) {
      final target = slow.denseEntities[i];
      final mi = mods.tryIndexOf(target);
      if (mi == null) continue;
      final multiplier = clampDouble(1.0 - slow.magnitude[i], 0.1, 1.0);
      mods.moveSpeedMul[mi] = multiplier;
    }
  }
}


===== FILE: lib/core/ecs/world.dart =====
import 'entity_id.dart';
import 'sparse_set.dart';
import 'stores/body_store.dart';
import 'stores/collider_aabb_store.dart';
import 'stores/collision_state_store.dart';
import 'stores/cooldown_store.dart';
import 'stores/cast_intent_store.dart';
import 'stores/combat/ammo_store.dart';
import 'stores/combat/creature_tag_store.dart';
import 'stores/combat/damage_resistance_store.dart';
import 'stores/combat/equipped_weapon_store.dart';
import 'stores/combat/equipped_ranged_weapon_store.dart';
import 'stores/combat/stat_modifier_store.dart';
import 'stores/combat/status_immunity_store.dart';
import 'stores/collectible_store.dart';
import 'stores/player/action_anim_store.dart';
import 'stores/player/gravity_control_store.dart';
import 'stores/enemies/flying_enemy_steering_store.dart';
import 'stores/faction_store.dart';
import 'stores/enemies/enemy_store.dart';
import 'stores/enemies/ground_enemy_chase_offset_store.dart';
import 'stores/health_store.dart';
import 'stores/hit_once_store.dart';
import 'stores/hitbox_store.dart';
import 'stores/player/invulnerability_store.dart';
import 'stores/player/last_damage_store.dart';
import 'stores/lifetime_store.dart';
import 'stores/mana_store.dart';
import 'stores/melee_intent_store.dart';
import 'stores/player/movement_store.dart';
import 'stores/player/player_input_store.dart';
import 'stores/projectile_store.dart';
import 'stores/ranged_weapon_intent_store.dart';
import 'stores/restoration_item_store.dart';
import 'stores/status/bleed_store.dart';
import 'stores/status/burn_store.dart';
import 'stores/status/slow_store.dart';
import 'stores/spell_origin_store.dart';
import 'stores/stamina_store.dart';
import 'stores/enemies/surface_nav_state_store.dart';
import 'stores/transform_store.dart';

/// Minimal Entity Component System (ECS) world container.
///
/// The [EcsWorld] is the central hub of the ECS architecture. It manages the
/// creation and destruction of entities ([EntityId]) and acts as a registry
/// for all Component Stores.
///
/// Design philosophy:
/// - **Structure-of-Arrays (SoA):** Data is stored in parallel arrays within each
///   [SparseSet] component store, rather than as objects on the entity.
/// - **Composition over Inheritance:** Game objects are defined by the collection
///   of components they possess.
/// - **Pooling:** Entity IDs are recycled to keep memory usage compact and predictable.
///
/// To add functionality to the game, Systems (logic) query this World for Entities
/// with specific components and operate on them.
class EcsWorld {
  /// Creates a new ECS World with an optional [seed] for deterministic behavior.
  EcsWorld({int seed = 0}) : seed = seed;

  /// Seed used for deterministic RNG in the core, passed to components that need it.
  final int seed;

  /// Counter for generating new unique Entity IDs.
  EntityId _nextEntityId = 1;

  /// Pool of recycled Entity IDs available for reuse.
  final List<EntityId> _freeIds = <EntityId>[];

  /// Fast lookup set for recycled IDs to prevent double-freeing.
  final Set<EntityId> _freeIdsSet = <EntityId>{};

  /// Registry of all registered component stores.
  final List<SparseSet> _stores = <SparseSet>[];

  /// Helper to register a store with the world so it receives lifecycle events (like entity destruction).
  T _register<T extends SparseSet>(T store) {
    _stores.add(store);
    return store;
  }

  // --- Component Stores ---
  // Each store manages a specific type of data for entities.

  /// Stores position (x, y) and velocity (vx, vy).
  late final TransformStore transform = _register(TransformStore());

  /// Helper components for handling user input events.
  late final PlayerInputStore playerInput = _register(PlayerInputStore());

  /// Tracks action intent ticks for animation selection.
  late final ActionAnimStore actionAnim = _register(ActionAnimStore());

  /// Logic and state for movement, including facing direction.
  late final MovementStore movement = _register(MovementStore());

  /// Physics properties like mass, friction, and restitution.
  late final BodyStore body = _register(BodyStore());

  /// Axis-Aligned Bounding Box (AABB) for collision detection.
  late final ColliderAabbStore colliderAabb = _register(ColliderAabbStore());

  /// Runtime state of collisions (e.g., is grounded, wall contact).
  late final CollisionStateStore collision = _register(CollisionStateStore());

  /// Generic cooldown timer for abilities or actions.
  late final CooldownStore cooldown = _register(CooldownStore());

  /// Tracks the player's intent to cast a spell (button presses).
  late final CastIntentStore castIntent = _register(CastIntentStore());

  /// Creature classification tags (humanoid, demon, etc.).
  late final CreatureTagStore creatureTag = _register(CreatureTagStore());

  /// Marks an entity as a collectible item (e.g., coin, power-up).
  late final CollectibleStore collectible = _register(CollectibleStore());

  /// Defines an item that restores stats (health/mana) when collected.
  late final RestorationItemStore restorationItem = _register(RestorationItemStore());

  /// Allows an entity to control or defy gravity.
  late final GravityControlStore gravityControl = _register(GravityControlStore());

  /// Defines which faction (Player, Enemy, Neutral) an entity belongs to.
  late final FactionStore faction = _register(FactionStore());

  /// Manages Health Points (HP) and max HP.
  late final HealthStore health = _register(HealthStore());

  /// Damage resistance/vulnerability modifiers.
  late final DamageResistanceStore damageResistance =
      _register(DamageResistanceStore());

  /// Grants temporary invulnerability (i-frames).
  late final InvulnerabilityStore invulnerability = _register(InvulnerabilityStore());

  /// Records the last entity/source that dealt damage to this entity.
  late final LastDamageStore lastDamage = _register(LastDamageStore());

  /// Status immunities (burn, slow, bleed).
  late final StatusImmunityStore statusImmunity = _register(StatusImmunityStore());

  /// Manages Mana Points (MP) and max MP.
  late final ManaStore mana = _register(ManaStore());

  /// Tracks the player's intent to perform a melee attack.
  late final MeleeIntentStore meleeIntent = _register(MeleeIntentStore());

  /// Tracks the player's intent to fire a ranged weapon.
  late final RangedWeaponIntentStore rangedWeaponIntent =
      _register(RangedWeaponIntentStore());

  /// Per-entity ammo pools for ranged weapons.
  late final AmmoStore ammo = _register(AmmoStore());

  /// Equipped melee weapon (for on-hit profiles like bleed).
  late final EquippedWeaponStore equippedWeapon = _register(EquippedWeaponStore());

  /// Equipped ranged weapon (bow, throwing axe, ...).
  late final EquippedRangedWeaponStore equippedRangedWeapon =
      _register(EquippedRangedWeaponStore());

  /// Derived runtime stat modifiers (e.g., slows).
  late final StatModifierStore statModifier = _register(StatModifierStore());

  /// Manages Stamina Points (SP) and max SP.
  late final StaminaStore stamina = _register(StaminaStore());

  /// Marks an entity as a projectile and defines its properties.
  late final ProjectileStore projectile = _register(ProjectileStore());

  /// Defines an area that deals damage or effects on contact.
  late final HitboxStore hitbox = _register(HitboxStore());

  /// Ensures a hitbox only affects a target once per interaction.
  late final HitOnceStore hitOnce = _register(HitOnceStore());

  /// Despawns entities after a set duration.
  late final LifetimeStore lifetime = _register(LifetimeStore());

  /// Active burn DoT effects.
  late final BurnStore burn = _register(BurnStore());

  /// Active bleed DoT effects.
  late final BleedStore bleed = _register(BleedStore());

  /// Active slow effects.
  late final SlowStore slow = _register(SlowStore());

  /// Links a spell effect back to its caster or origin point.
  late final SpellOriginStore spellOrigin = _register(SpellOriginStore());

  /// State for ground enemies navigating terrain (jumping gaps/walls).
  late final SurfaceNavStateStore surfaceNav = _register(SurfaceNavStateStore());

  /// Identifies an entity as a specific type of enemy.
  late final EnemyStore enemy = _register(EnemyStore());

  /// Steering behaviors for flying enemies.
  late final FlyingEnemySteeringStore flyingEnemySteering = _register(FlyingEnemySteeringStore());

  /// AI state for ground enemies to create offset chasing behaviors.
  late final GroundEnemyChaseOffsetStore groundEnemyChaseOffset =
      _register(GroundEnemyChaseOffsetStore());

  /// Allocates a new [EntityId].
  ///
  /// Prefers reusing ID from the free pool if available; otherwise increments the counter.
  EntityId createEntity() {
    if (_freeIds.isNotEmpty) {
      final id = _freeIds.removeLast();
      _freeIdsSet.remove(id);
      return id;
    }
    final id = _nextEntityId;
    _nextEntityId += 1;
    return id;
  }

  /// Destroys [entity], removing it from all component stores.
  ///
  /// The ID is returned to the free pool for future reuse.
  /// Does nothing if the entity is already destroyed/free.
  void destroyEntity(EntityId entity) {
    if (_freeIdsSet.contains(entity)) {
      return;
    }
    for (final store in _stores) {
      store.removeEntity(entity);
    }
    _freeIds.add(entity);
    _freeIdsSet.add(entity);
  }
}


===== FILE: lib/core/enemies/enemy_catalog.dart =====
import '../ecs/stores/body_store.dart';
import '../ecs/stores/collider_aabb_store.dart';
import '../ecs/stores/combat/creature_tag_store.dart';
import '../ecs/stores/combat/damage_resistance_store.dart';
import '../ecs/stores/combat/status_immunity_store.dart';
import '../ecs/stores/health_store.dart';
import '../ecs/stores/mana_store.dart';
import '../ecs/stores/stamina_store.dart';
import '../combat/creature_tag.dart';
import '../spells/spell_id.dart';
import 'enemy_id.dart';

/// Defines the base stats and physics properties for an enemy type.
///
/// This data is "static" (read-only) configuration used to initialize
/// the ECS components effectively when an enemy spawns.
class EnemyArchetype {
  const EnemyArchetype({
    required this.body,
    required this.collider,
    required this.health,
    required this.mana,
    required this.stamina,
    this.primarySpellId,
    this.tags = const CreatureTagDef(),
    this.resistance = const DamageResistanceDef(),
    this.statusImmunity = const StatusImmunityDef(),
  });

  /// Physics configuration (Gravity, Constraints, Kinematics).
  final BodyDef body;
  
  /// Hitbox size (Collision).
  final ColliderAabbDef collider;
  
  /// Vitals (HP, Mana, Stamina) configuration.
  final HealthDef health;
  final ManaDef mana;
  final StaminaDef stamina;

  /// Optional primary ranged attack spell for this enemy.
  ///
  /// When present, the [EnemySystem] will use this to write cast intents.
  final SpellId? primarySpellId;

  /// Broad tags used by combat rules and content filters.
  final CreatureTagDef tags;

  /// Resistance/vulnerability modifiers by damage type.
  final DamageResistanceDef resistance;

  /// Status effect immunities for this enemy.
  final StatusImmunityDef statusImmunity;
}

/// Central registry for Enemy Definitions.
///
/// **Usage**:
/// - Accessed by `EnemySpawnSystem` (or similar) to hydration entities.
/// - Decouples "What an enemy is" from "How to spawn it".
class EnemyCatalog {
  const EnemyCatalog();

  /// Returns the static archetype definition for a given [EnemyId].
  ///
  /// Note: The returned objects are `const` and allocation-light.
  EnemyArchetype get(EnemyId id) {
    switch (id) {
      case EnemyId.unocoDemon:
        return const EnemyArchetype(
          body: BodyDef(
            isKinematic: false,
            useGravity: false,
            gravityScale: 0.0,
            sideMask: BodyDef.sideNone,
            maxVelX: 800.0,
            maxVelY: 800.0,
          ),
          collider: ColliderAabbDef(halfX: 12.0, halfY: 12.0),
          health: HealthDef(hp: 20.0, hpMax: 20.0, regenPerSecond: 0.5),
          mana: ManaDef(mana: 80.0, manaMax: 80.0, regenPerSecond: 5.0),
          stamina: StaminaDef(stamina: 0.0, staminaMax: 0.0, regenPerSecond: 0.0),
          primarySpellId: SpellId.lightning,
          tags: CreatureTagDef(mask: CreatureTagMask.flying | CreatureTagMask.demon),
          resistance: DamageResistanceDef(fire: -0.5, ice: 0.5),
        );
         
      case EnemyId.groundEnemy:
        return const EnemyArchetype(
          body: BodyDef(
            isKinematic: false,
            useGravity: true,
            ignoreCeilings: true,
            gravityScale: 1.0,
            sideMask: BodyDef.sideLeft | BodyDef.sideRight,
          ),
          collider: ColliderAabbDef(halfX: 12.0, halfY: 12.0),
          health: HealthDef(hp: 20.0, hpMax: 20.0, regenPerSecond: 0.5),
          mana: ManaDef(mana: 0.0, manaMax: 0.0, regenPerSecond: 0.0),
          stamina: StaminaDef(stamina: 0.0, staminaMax: 0.0, regenPerSecond: 0.0),
          tags: CreatureTagDef(mask: CreatureTagMask.humanoid),
        );
    }
  }
}


===== FILE: lib/core/enemies/enemy_id.dart =====
/// Unique identifiers for enemy types.
///
/// **Usage**:
/// - Used for spawning via `SpawnSystem`.
/// - keys for `EnemyCatalog` lookup.
/// - Stable identifiers for networking/snapshots (protocol-stable).
enum EnemyId {
  /// A flying demon enemy that ignores gravity and casts spells.
  unocoDemon,

  /// A basic ground chasing enemy that is affected by gravity.
  groundEnemy,
}



===== FILE: lib/core/events/game_event.dart =====
/// Core -> Render/UI event model.
///
/// **Architecture**:
/// - "Events" in this context are **transient side effects** emitted by the simulation.
/// - Examples: SFX triggers, Particle spawns, Run completion, Screen shake.
/// - They are distinct from "State" (Snapshots). State is continuous; Events are discrete.
///
/// **Usage**:
/// - Systems emit events into a queue.
/// - The GameController or UI layer consumes them (e.g., to play a sound or show a dialog).
/// - Events are fire-and-forget.
library;
import '../enemies/enemy_id.dart';
import '../projectiles/projectile_id.dart';
import '../spells/spell_id.dart';

part 'run_events.dart';

/// Base sealed class for all simulation events.
sealed class GameEvent {
  const GameEvent();
}


===== FILE: lib/core/events/run_events.dart =====
part of 'game_event.dart';

/// The specific cause for a run ending.
enum RunEndReason {
  /// Player was too slow and scrolled off the screen.
  fellBehindCamera,
  
  /// Player fell into a death pit.
  fellIntoGap,
  
  /// HP reached 0 (combat death).
  playerDied,
  
  /// User manually exited the run.
  gaveUp,
}

/// Identifies the category of damage source that caused death.
enum DeathSourceKind {
  projectile,
  meleeHitbox,
  statusEffect,
  unknown,
}

/// Detailed context about what killed the player.
class DeathInfo {
  const DeathInfo({
    required this.kind,
    this.enemyId,
    this.projectileId,
    this.spellId,
  });

  /// Category of the damage source.
  final DeathSourceKind kind;
  
  /// The [EnemyId] responsible (if applicable).
  final EnemyId? enemyId;
  
  /// The [ProjectileId] responsible (if applicable).
  final ProjectileId? projectileId;
  
  /// The [SpellId] responsible (if applicable).
  final SpellId? spellId;
}

/// Aggregate statistics collected during a run.
class RunEndStats {
  const RunEndStats({
    required this.collectibles,
    required this.collectibleScore,
    required this.enemyKillCounts,
  });

  /// Total count of collectibles picked up.
  final int collectibles;
  
  /// Total score value of collectibles.
  final int collectibleScore;

  /// Kill counts per enemy type.
  ///
  /// **Ordering**: Indices strictly align with [EnemyId.values].
  /// `enemyKillCounts[i]` corresponds to the kills for the enemy at `EnemyId.values[i]`.
  final List<int> enemyKillCounts;
}

/// Event emitted when the game session terminates.
///
/// Contains all necessary data to display the "Game Over" screen.
class RunEndedEvent extends GameEvent {
  const RunEndedEvent({
    required this.tick,
    required this.distance,
    required this.reason,
    required this.stats,
    this.deathInfo,
  });

  /// The tick on which the run ended.
  final int tick;
  
  /// Total distance traveled (meters/pixels).
  final double distance;
  
  /// Why the run ended (Death vs GiveUp).
  final RunEndReason reason;
  
  /// Performance stats.
  final RunEndStats stats;
  
  /// Details on the lethal hit (if applicable).
  final DeathInfo? deathInfo;
}


===== FILE: lib/core/game_core.dart =====
/// Authoritative, deterministic simulation layer (pure Dart).
///
/// This is the heart of the game—a pure Dart simulation that processes
/// tick-stamped commands, advances physics and AI, and produces immutable
/// snapshots for the renderer/UI. By keeping this layer Flutter/Flame-free,
/// we gain:
/// - **Testability**: Unit tests can run headless at any tick rate.
/// - **Determinism**: Same seed + commands = identical simulation.
/// - **Portability**: Core logic could run on a server for validation.
///
/// ## Architecture Overview
///
/// ```
/// Commands (from input layer)
///         ↓
///    GameCore.applyCommands()
///         ↓
///    GameCore.stepOneTick()
///         ↓
///    [Track streaming → Physics → AI → Combat → Cleanup]
///         ↓
///    GameStateSnapshot (to render layer)
/// ```
///
/// ## Module Dependencies
///
/// [GameCore] orchestrates three extracted modules:
/// - [TrackManager]: Procedural chunk generation, geometry lifecycle.
/// - [SpawnService]: Deterministic entity spawning (enemies, items).
/// - [SnapshotBuilder]: ECS → render snapshot conversion.
///
/// ## ECS System Execution Order
///
/// Systems run in a carefully ordered pipeline each tick:
/// 1. **Track streaming**: Spawn/cull chunks based on camera.
/// 2. **Cooldowns & invulnerability**: Decrement timers.
/// 3. **Enemy AI steering**: Path planning and movement intent.
/// 4. **Player movement**: Apply input to velocity.
/// 5. **Gravity**: Apply gravity to non-kinematic bodies.
/// 6. **Collision**: Resolve static world collisions.
/// 7. **Pickups**: Collect items overlapping player.
/// 8. **Broadphase rebuild**: Update spatial grid for hit detection.
/// 9. **Projectile movement**: Advance existing projectiles.
/// 10. **Attack intents**: Enemies and player queue attacks.
/// 11. **Attack execution**: Spawn hitboxes and projectiles.
/// 12. **Hitbox positioning**: Follow owner entities.
/// 13. **Hit resolution**: Detect overlaps, queue damage.
/// 14. **Status ticking**: Apply DoT ticks and queue damage.
/// 15. **Damage application**: Apply queued damage, set invulnerability.
/// 16. **Status application**: Apply on-hit status profiles.
/// 17. **Death handling**: Despawn dead entities, record kills.
/// 18. **Resource regen**: Regenerate mana/stamina.
/// 19. **Lifetime cleanup**: Remove expired entities.
///
/// ## Determinism Contract
///
/// Given identical inputs:
/// - Same [seed] parameter
/// - Same sequence of [Command]s with same tick stamps
/// - Same [tickHz]
///
/// The simulation will produce identical results across runs and platforms.
/// This is achieved by:
/// - Using [DeterministicRng] instead of `dart:math Random`
/// - Fixed-point-style tick math (no frame-rate-dependent dt accumulation)
/// - Deterministic iteration order (entity IDs, not hash-based)
library;

import 'dart:math';

import 'camera/autoscroll_camera.dart';
import 'collision/static_world_geometry_index.dart';
import 'commands/command.dart';
import 'contracts/render_contract.dart';
import 'ecs/entity_factory.dart';
import 'ecs/entity_id.dart';
import 'ecs/spatial/broadphase_grid.dart';
import 'ecs/spatial/grid_index_2d.dart';
import 'ecs/stores/restoration_item_store.dart';
import 'ecs/systems/collectible_system.dart';
import 'ecs/systems/collision_system.dart';
import 'ecs/systems/cooldown_system.dart';
import 'ecs/systems/damage_system.dart';
import 'ecs/systems/enemy_system.dart';
import 'ecs/systems/gravity_system.dart';
import 'ecs/systems/health_despawn_system.dart';
import 'ecs/systems/hitbox_damage_system.dart';
import 'ecs/systems/hitbox_follow_owner_system.dart';
import 'ecs/systems/invulnerability_system.dart';
import 'ecs/systems/lifetime_system.dart';
import 'ecs/systems/melee_attack_system.dart';
import 'ecs/systems/player_cast_system.dart';
import 'ecs/systems/player_melee_system.dart';
import 'ecs/systems/player_movement_system.dart';
import 'ecs/systems/player_ranged_weapon_system.dart';
import 'ecs/systems/projectile_hit_system.dart';
import 'ecs/systems/projectile_system.dart';
import 'ecs/systems/projectile_world_collision_system.dart';
import 'ecs/systems/ranged_weapon_attack_system.dart';
import 'ecs/systems/resource_regen_system.dart';
import 'ecs/systems/restoration_item_system.dart';
import 'ecs/systems/status_system.dart';
import 'ecs/systems/spell_cast_system.dart';
import 'ecs/systems/enemy_cull_system.dart';
import 'ecs/world.dart';
import 'enemies/enemy_catalog.dart';
import 'enemies/enemy_id.dart';
import 'events/game_event.dart';
import 'levels/level_definition.dart';
import 'levels/level_id.dart';
import 'levels/level_registry.dart';
import 'navigation/surface_graph_builder.dart';
import 'navigation/surface_navigator.dart';
import 'navigation/surface_pathfinder.dart';
import 'navigation/utils/jump_template.dart';
import 'navigation/utils/trajectory_predictor.dart';
import 'players/player_catalog.dart';
import 'projectiles/projectile_catalog.dart';
import 'snapshots/enums.dart';
import 'snapshots/game_state_snapshot.dart';
import 'snapshot_builder.dart';
import 'spawn_service.dart';
import 'spells/spell_catalog.dart';
import 'track_manager.dart';
import 'weapons/weapon_catalog.dart';
import 'ecs/stores/combat/equipped_weapon_store.dart';
import 'ecs/stores/combat/equipped_ranged_weapon_store.dart';
import 'weapons/ranged_weapon_catalog.dart';
import 'tuning/ability_tuning.dart';
import 'tuning/anim_tuning.dart';
import 'tuning/camera_tuning.dart';
import 'tuning/collectible_tuning.dart';
import 'tuning/combat_tuning.dart';
import 'tuning/core_tuning.dart';
import 'tuning/flying_enemy_tuning.dart';
import 'tuning/ground_enemy_tuning.dart';
import 'tuning/movement_tuning.dart';
import 'tuning/navigation_tuning.dart';
import 'tuning/physics_tuning.dart';
import 'tuning/resource_tuning.dart';
import 'tuning/restoration_item_tuning.dart';
import 'tuning/score_tuning.dart';
import 'tuning/spatial_grid_tuning.dart';
import 'tuning/track_tuning.dart';
import 'util/tick_math.dart';

// ─────────────────────────────────────────────────────────────────────────────
// GameCore - Main simulation coordinator
// ─────────────────────────────────────────────────────────────────────────────

/// Deterministic game simulation core.
///
/// This class is the central coordinator for the game simulation. It:
/// - Owns the [EcsWorld] and all ECS systems.
/// - Processes player [Command]s each tick.
/// - Steps physics, AI, and combat systems in order.
/// - Produces [GameStateSnapshot]s for the render layer.
/// - Emits [GameEvent]s for UI feedback (run ended, etc.).
///
/// ## Usage
///
/// ```dart
/// final core = GameCore(seed: 42);
/// core.applyCommands([JumpPressedCommand()]);
/// core.stepOneTick();
/// final snapshot = core.buildSnapshot();
/// final events = core.drainEvents();
/// ```
///
/// ## Custom Configuration
///
  /// Use [CoreTuning] to customize game parameters:
  /// ```dart
  /// final core = GameCore(
  ///   seed: 123,
  ///   tuning: CoreTuning(
  ///     movement: MovementTuning(jumpSpeed: 600),
  ///     track: TrackTuning(enabled: false),
  ///   ),
  /// );
  /// ```
  ///
  /// Use [LevelDefinition] to select a level configuration:
  /// ```dart
  /// final core = GameCore(
  ///   seed: 123,
  ///   levelDefinition: LevelRegistry.byId(LevelId.defaultLevel),
  /// );
  /// ```
///
/// For backward compatibility, [GameCore.withTunings] accepts individual
/// tuning parameters:
/// ```dart
/// final core = GameCore.withTunings(
///   seed: 123,
///   movementTuning: MovementTuning(jumpSpeed: 600),
///   trackTuning: TrackTuning(enabled: false),
/// );
/// ```
class GameCore {
  static LevelDefinition _resolveLevelDefinition({
    required CoreTuning tuning,
    required StaticWorldGeometry staticWorldGeometry,
    LevelDefinition? levelDefinition,
  }) {
    if (levelDefinition != null) return levelDefinition;
    final base = LevelRegistry.defaultLevel;
    return LevelDefinition(
      id: base.id,
      patternPool: base.patternPool,
      earlyPatternChunks: base.earlyPatternChunks,
      noEnemyChunks: base.noEnemyChunks,
      themeId: base.themeId,
      tuning: tuning,
      staticWorldGeometry: staticWorldGeometry,
    );
  }

  /// Creates a new game simulation with the given configuration.
  ///
  /// Parameters:
  /// - [seed]: Master RNG seed for deterministic generation.
  /// - [tickHz]: Fixed tick rate (default 60). Higher = smoother but more CPU.
  /// - [tuning]: Aggregate tuning configuration (see [CoreTuning]).
  /// - Catalogs: Entity archetype definitions (spells, enemies, etc.).
  /// - [staticWorldGeometry]: Base level geometry (ground, initial platforms).
  /// - [levelDefinition]: Optional level config. When provided, its tuning,
  ///   static geometry, and pattern pools are used (and [tuning] /
  ///   [staticWorldGeometry] are ignored).
  ///
  /// For backward compatibility with existing code that passes individual
  /// tuning parameters, use [GameCore.withTunings] instead.
  GameCore({
    required int seed,
    int tickHz = defaultTickHz,
    CoreTuning tuning = const CoreTuning(),
    SpellCatalog spellCatalog = const SpellCatalog(),
    ProjectileCatalog projectileCatalog = const ProjectileCatalog(),
    EnemyCatalog enemyCatalog = const EnemyCatalog(),
    PlayerCatalog playerCatalog = const PlayerCatalog(),
    WeaponCatalog weaponCatalog = const WeaponCatalog(),
    RangedWeaponCatalog rangedWeaponCatalog = const RangedWeaponCatalog(),
    StaticWorldGeometry staticWorldGeometry = const StaticWorldGeometry(
      groundPlane: StaticGroundPlane(topY: groundTopY * 1.0),
    ),
    LevelDefinition? levelDefinition,
  }) : this._fromLevel(
         seed: seed,
         tickHz: tickHz,
         levelDefinition: _resolveLevelDefinition(
           levelDefinition: levelDefinition,
           tuning: tuning,
           staticWorldGeometry: staticWorldGeometry,
         ),
         spellCatalog: spellCatalog,
         projectileCatalog: projectileCatalog,
         enemyCatalog: enemyCatalog,
         playerCatalog: playerCatalog,
         weaponCatalog: weaponCatalog,
         rangedWeaponCatalog: rangedWeaponCatalog,
       );

  GameCore._fromLevel({
    required this.seed,
    required this.tickHz,
    required LevelDefinition levelDefinition,
    required SpellCatalog spellCatalog,
    required ProjectileCatalog projectileCatalog,
    required EnemyCatalog enemyCatalog,
    required PlayerCatalog playerCatalog,
    required WeaponCatalog weaponCatalog,
    required RangedWeaponCatalog rangedWeaponCatalog,
  }) : _levelDefinition = levelDefinition,
       _movement = MovementTuningDerived.from(
         levelDefinition.tuning.movement,
         tickHz: tickHz,
       ),
       _physicsTuning = levelDefinition.tuning.physics,
       _resourceTuning = levelDefinition.tuning.resource,
       _abilities = AbilityTuningDerived.from(
         levelDefinition.tuning.ability,
         tickHz: tickHz,
       ),
       _animTuning = AnimTuningDerived.from(
         levelDefinition.tuning.anim,
         tickHz: tickHz,
       ),
       _combat = CombatTuningDerived.from(
         levelDefinition.tuning.combat,
         tickHz: tickHz,
       ),
       _unocoDemonTuning = UnocoDemonTuningDerived.from(
         levelDefinition.tuning.unocoDemon,
         tickHz: tickHz,
       ),
       _groundEnemyTuning = GroundEnemyTuningDerived.from(
         levelDefinition.tuning.groundEnemy,
         tickHz: tickHz,
       ),
       _navigationTuning = levelDefinition.tuning.navigation,
       _spatialGridTuning = levelDefinition.tuning.spatialGrid,
       _spells = spellCatalog,
       _projectiles = ProjectileCatalogDerived.from(
         projectileCatalog,
         tickHz: tickHz,
       ),
       _enemyCatalog = enemyCatalog,
       _playerCatalog = playerCatalog,
       _weapons = weaponCatalog,
       _rangedWeapons = RangedWeaponCatalogDerived.from(
         rangedWeaponCatalog,
         tickHz: tickHz,
       ),
       _scoreTuning = levelDefinition.tuning.score,
       _trackTuning = levelDefinition.tuning.track,
       _collectibleTuning = levelDefinition.tuning.collectible,
       _restorationItemTuning = levelDefinition.tuning.restorationItem {
    _initializeWorld(levelDefinition);
  }

  /// Creates a game simulation with individual tuning parameters.
  ///
  /// This factory provides backward compatibility for code that passes
  /// individual tuning objects. Prefer the default constructor with
  /// [CoreTuning] for new code.
  ///
  /// Example:
  /// ```dart
  /// final core = GameCore.withTunings(
  ///   seed: 123,
  ///   movementTuning: MovementTuning(jumpSpeed: 600),
  ///   trackTuning: TrackTuning(enabled: false),
  /// );
  /// ```
  factory GameCore.withTunings({
    required int seed,
    int tickHz = defaultTickHz,
    PhysicsTuning physicsTuning = const PhysicsTuning(),
    MovementTuning movementTuning = const MovementTuning(),
    ResourceTuning resourceTuning = const ResourceTuning(),
    AbilityTuning abilityTuning = const AbilityTuning(),
    AnimTuning animTuning = const AnimTuning(),
    CombatTuning combatTuning = const CombatTuning(),
    UnocoDemonTuning unocoDemonTuning = const UnocoDemonTuning(),
    GroundEnemyTuning groundEnemyTuning = const GroundEnemyTuning(),
    NavigationTuning navigationTuning = const NavigationTuning(),
    SpatialGridTuning spatialGridTuning = const SpatialGridTuning(),
    CameraTuning cameraTuning = const CameraTuning(),
    TrackTuning trackTuning = const TrackTuning(),
    CollectibleTuning collectibleTuning = const CollectibleTuning(),
    RestorationItemTuning restorationItemTuning = const RestorationItemTuning(),
    ScoreTuning scoreTuning = const ScoreTuning(),
    SpellCatalog spellCatalog = const SpellCatalog(),
    ProjectileCatalog projectileCatalog = const ProjectileCatalog(),
    EnemyCatalog enemyCatalog = const EnemyCatalog(),
    PlayerCatalog playerCatalog = const PlayerCatalog(),
    WeaponCatalog weaponCatalog = const WeaponCatalog(),
    RangedWeaponCatalog rangedWeaponCatalog = const RangedWeaponCatalog(),
    StaticWorldGeometry staticWorldGeometry = const StaticWorldGeometry(
      groundPlane: StaticGroundPlane(topY: groundTopY * 1.0),
    ),
  }) {
    return GameCore(
      seed: seed,
      tickHz: tickHz,
      tuning: CoreTuning(
        physics: physicsTuning,
        movement: movementTuning,
        resource: resourceTuning,
        ability: abilityTuning,
        anim: animTuning,
        combat: combatTuning,
        unocoDemon: unocoDemonTuning,
        groundEnemy: groundEnemyTuning,
        navigation: navigationTuning,
        spatialGrid: spatialGridTuning,
        camera: cameraTuning,
        track: trackTuning,
        collectible: collectibleTuning,
        restorationItem: restorationItemTuning,
        score: scoreTuning,
      ),
      spellCatalog: spellCatalog,
      projectileCatalog: projectileCatalog,
      enemyCatalog: enemyCatalog,
      playerCatalog: playerCatalog,
      weaponCatalog: weaponCatalog,
      rangedWeaponCatalog: rangedWeaponCatalog,
      staticWorldGeometry: staticWorldGeometry,
    );
  }

  /// Common initialization shared by all constructors.
  void _initializeWorld(LevelDefinition levelDefinition) {
    final staticWorldGeometry = levelDefinition.staticWorldGeometry;
    final cameraTuning = levelDefinition.tuning.camera;
    // ─── Initialize ECS world and entity factory ───
    _world = EcsWorld(seed: seed);
    _entityFactory = EntityFactory(_world);

    // ─── Initialize all ECS systems ───
    _initializeSystems();

    // ─── Initialize autoscrolling camera ───
    _cameraTuning = CameraTuningDerived.from(cameraTuning, movement: _movement);
    _camera = AutoscrollCamera(
      viewWidth: virtualWidth.toDouble(),
      tuning: _cameraTuning,
      initial: CameraState(
        centerX: virtualWidth * 0.5,
        targetX: virtualWidth * 0.5,
        speedX: 0.0,
      ),
    );

    // ─── Initialize spawn service (needs ECS + catalogs) ───
    _spawnService = SpawnService(
      world: _world,
      entityFactory: _entityFactory,
      enemyCatalog: _enemyCatalog,
      unocoDemonTuning: _unocoDemonTuning,
      movement: _movement,
      collectibleTuning: _collectibleTuning,
      restorationItemTuning: _restorationItemTuning,
      trackTuning: _trackTuning,
      seed: seed,
    );

    // ─── Spawn player entity (must happen before TrackManager) ───
    final effectiveGroundTopY =
        staticWorldGeometry.groundPlane?.topY ?? groundTopY.toDouble();
    _spawnPlayer(effectiveGroundTopY);

    // ─── Initialize track manager (needs player for callbacks) ───
    _trackManager = TrackManager(
      seed: seed,
      trackTuning: _trackTuning,
      collectibleTuning: _collectibleTuning,
      restorationItemTuning: _restorationItemTuning,
      baseGeometry: staticWorldGeometry,
      surfaceGraphBuilder: _surfaceGraphBuilder,
      jumpTemplate: _groundEnemyJumpTemplate,
      enemySystem: _enemySystem,
      spawnService: _spawnService,
      groundTopY: effectiveGroundTopY,
      patternPool: levelDefinition.patternPool,
      earlyPatternChunks: levelDefinition.earlyPatternChunks,
      noEnemyChunks: levelDefinition.noEnemyChunks,
    );

    // ─── Initialize snapshot builder (needs player entity ID) ───
    _snapshotBuilder = SnapshotBuilder(
      world: _world,
      player: _player,
      movement: _movement,
      abilities: _abilities,
      animTuning: _animTuning,
      resources: _resourceTuning,
      spells: _spells,
      projectiles: _projectiles,
      rangedWeapons: _rangedWeapons,
    );
  }

  /// Initializes all ECS systems.
  ///
  /// Systems are stateless processors that operate on component stores.
  /// They're created once at construction and reused every tick.
  void _initializeSystems() {
    // Core movement and physics.
    _movementSystem = PlayerMovementSystem();
    _collisionSystem = CollisionSystem();
    _cooldownSystem = CooldownSystem();
    _gravitySystem = GravitySystem();

    // Projectile lifecycle.
    _projectileSystem = ProjectileSystem();
    _projectileHitSystem = ProjectileHitSystem();
    _projectileWorldCollisionSystem = ProjectileWorldCollisionSystem();

    // Spatial partitioning for hit detection.
    _broadphaseGrid = BroadphaseGrid(
      index: GridIndex2D(cellSize: _spatialGridTuning.broadphaseCellSize),
    );

    // Hitbox management.
    _hitboxFollowOwnerSystem = HitboxFollowOwnerSystem();
    _lifetimeSystem = LifetimeSystem();

    // Damage pipeline.
    _invulnerabilitySystem = InvulnerabilitySystem();
    _damageSystem = DamageSystem(
      invulnerabilityTicksOnHit: _combat.invulnerabilityTicks,
    );
    _statusSystem = StatusSystem(tickHz: tickHz);
    _healthDespawnSystem = HealthDespawnSystem();
    _enemyCullSystem = EnemyCullSystem();

    // Player combat.
    _meleeSystem = PlayerMeleeSystem(
      abilities: _abilities,
      movement: _movement,
      weapons: _weapons,
    );
    _rangedWeaponSystem = PlayerRangedWeaponSystem(weapons: _rangedWeapons.base);
    _hitboxDamageSystem = HitboxDamageSystem();

    // Pickup systems.
    _collectibleSystem = CollectibleSystem();
    _restorationItemSystem = RestorationItemSystem();
    _resourceRegenSystem = ResourceRegenSystem();

    // Spell/cast systems.
    _castSystem = PlayerCastSystem(abilities: _abilities, movement: _movement);
    _spellCastSystem = SpellCastSystem(
      spells: _spells,
      projectiles: _projectiles,
    );
    _meleeAttackSystem = MeleeAttackSystem();
    _rangedWeaponAttackSystem = RangedWeaponAttackSystem(
      weapons: _rangedWeapons,
      projectiles: _projectiles,
    );

    // Navigation infrastructure.
    _surfaceGraphBuilder = SurfaceGraphBuilder(
      surfaceGrid: GridIndex2D(cellSize: _spatialGridTuning.broadphaseCellSize),
      takeoffSampleMaxStep: _navigationTuning.takeoffSampleMaxStep,
    );
    _groundEnemyJumpTemplate = JumpReachabilityTemplate.build(
      JumpProfile(
        jumpSpeed: _groundEnemyTuning.base.groundEnemyJumpSpeed,
        gravityY: _physicsTuning.gravityY,
        maxAirTicks: _groundEnemyMaxAirTicks(),
        airSpeedX: _groundEnemyTuning.base.groundEnemySpeedX,
        dtSeconds: _movement.dtSeconds,
        agentHalfWidth: _enemyCatalog.get(EnemyId.groundEnemy).collider.halfX,
      ),
    );
    _surfacePathfinder = SurfacePathfinder(
      maxExpandedNodes: _navigationTuning.maxExpandedNodes,
      runSpeedX: _groundEnemyTuning.base.groundEnemySpeedX,
      edgePenaltySeconds: _navigationTuning.edgePenaltySeconds,
    );
    _surfaceNavigator = SurfaceNavigator(
      pathfinder: _surfacePathfinder,
      repathCooldownTicks: _navigationTuning.repathCooldownTicks,
      surfaceEps: _navigationTuning.surfaceEps,
      takeoffEps: max(
        _navigationTuning.takeoffEpsMin,
        _groundEnemyTuning.base.groundEnemyStopDistanceX,
      ),
    );

    // Enemy AI system (depends on navigation).
    _enemySystem = EnemySystem(
      unocoDemonTuning: _unocoDemonTuning,
      groundEnemyTuning: _groundEnemyTuning,
      surfaceNavigator: _surfaceNavigator,
      enemyCatalog: _enemyCatalog,
      spells: _spells,
      projectiles: _projectiles,
      trajectoryPredictor: TrajectoryPredictor(
        gravityY: _physicsTuning.gravityY,
        dtSeconds: _movement.dtSeconds,
        maxTicks: 120,
      ),
    );
  }

  /// Spawns the player entity at the start of a run.
  ///
  /// The player is positioned at [TrackTuning.playerStartX], standing on the
  /// ground. This must be called before [TrackManager] is created because
  /// track manager callbacks reference the player entity.
  void _spawnPlayer(double groundTopY) {
    final spawnX = _trackTuning.playerStartX;
    final playerArchetype = PlayerCatalogDerived.from(
      _playerCatalog,
      movement: _movement,
      resources: _resourceTuning,
    ).archetype;
    final playerCollider = playerArchetype.collider;

    // Position so collider bottom touches ground.
    final spawnY = groundTopY - (playerCollider.offsetY + playerCollider.halfY);
    _player = _entityFactory.createPlayer(
      posX: spawnX,
      posY: spawnY,
      velX: 0.0,
      velY: 0.0,
      facing: playerArchetype.facing,
      grounded: true,
      body: playerArchetype.body,
      collider: playerCollider,
      health: playerArchetype.health,
      mana: playerArchetype.mana,
      stamina: playerArchetype.stamina,
      tags: playerArchetype.tags,
      resistance: playerArchetype.resistance,
      statusImmunity: playerArchetype.statusImmunity,
      equippedWeapon: EquippedWeaponDef(weaponId: playerArchetype.weaponId),
      equippedRangedWeapon:
          EquippedRangedWeaponDef(weaponId: playerArchetype.rangedWeaponId),
      ammo: playerArchetype.ammo,
    );
  }

  // ─────────────────────────────────────────────────────────────────────────
  // Fields
  // ─────────────────────────────────────────────────────────────────────────

  /// Master RNG seed for deterministic generation.
  ///
  /// The same seed produces identical track layouts, enemy spawns, and

  /// item placements across runs.
  final int seed;

  /// Fixed simulation tick frequency (ticks per second).
  ///
  /// Higher values = smoother physics but more CPU. Default is 60.
  final int tickHz;

  /// Core level configuration for this run.
  final LevelDefinition _levelDefinition;

  // ─── Derived Tunings ───
  // These are pre-computed from base tunings using tickHz.

  final MovementTuningDerived _movement;
  final PhysicsTuning _physicsTuning;
  final ResourceTuning _resourceTuning;
  final AbilityTuningDerived _abilities;
  final AnimTuningDerived _animTuning;
  final CombatTuningDerived _combat;
  final UnocoDemonTuningDerived _unocoDemonTuning;
  final GroundEnemyTuningDerived _groundEnemyTuning;
  final NavigationTuning _navigationTuning;
  final SpatialGridTuning _spatialGridTuning;
  late final CameraTuningDerived _cameraTuning;
  final ScoreTuning _scoreTuning;
  final TrackTuning _trackTuning;
  final CollectibleTuning _collectibleTuning;
  final RestorationItemTuning _restorationItemTuning;

  // ─── Catalogs ───
  // Archetype definitions for entities.

  final SpellCatalog _spells;
  final ProjectileCatalogDerived _projectiles;
  final EnemyCatalog _enemyCatalog;
  final PlayerCatalog _playerCatalog;
  final WeaponCatalog _weapons;
  final RangedWeaponCatalogDerived _rangedWeapons;

  // ─── ECS Core ───

  /// The ECS world containing all component stores.
  late final EcsWorld _world;

  /// Factory for creating complex entities (player, enemies).
  late final EntityFactory _entityFactory;

  /// The player entity ID.
  late EntityId _player;

  // Pending game over delay for death animation.
  int _deathAnimTicksLeft = 0;
  RunEndReason? _pendingRunEndReason;
  DeathInfo? _pendingDeathInfo;

  // ─── ECS Systems ───
  // Stateless processors that operate on component stores.

  late final PlayerMovementSystem _movementSystem;
  late final CollisionSystem _collisionSystem;
  late final CooldownSystem _cooldownSystem;
  late final GravitySystem _gravitySystem;
  late final ProjectileSystem _projectileSystem;
  late final ProjectileHitSystem _projectileHitSystem;
  late final ProjectileWorldCollisionSystem _projectileWorldCollisionSystem;
  late final BroadphaseGrid _broadphaseGrid;
  late final HitboxFollowOwnerSystem _hitboxFollowOwnerSystem;
  late final CollectibleSystem _collectibleSystem;
  late final RestorationItemSystem _restorationItemSystem;
  late final LifetimeSystem _lifetimeSystem;
  late final InvulnerabilitySystem _invulnerabilitySystem;
  late final DamageSystem _damageSystem;
  late final StatusSystem _statusSystem;
  late final HealthDespawnSystem _healthDespawnSystem;
  late EnemySystem _enemySystem;
  late final SurfaceGraphBuilder _surfaceGraphBuilder;
  late final JumpReachabilityTemplate _groundEnemyJumpTemplate;
  late final SurfacePathfinder _surfacePathfinder;
  late final SurfaceNavigator _surfaceNavigator;
  late final PlayerMeleeSystem _meleeSystem;
  late final PlayerRangedWeaponSystem _rangedWeaponSystem;
  late final MeleeAttackSystem _meleeAttackSystem;
  late final RangedWeaponAttackSystem _rangedWeaponAttackSystem;
  late final HitboxDamageSystem _hitboxDamageSystem;
  late final ResourceRegenSystem _resourceRegenSystem;
  late final PlayerCastSystem _castSystem;
  late final SpellCastSystem _spellCastSystem;
  late final EnemyCullSystem _enemyCullSystem;

  // ─── Modular Services ───
  // Extracted modules for specific responsibilities.

  /// Entity spawning with deterministic placement.
  late final SpawnService _spawnService;

  /// Track streaming, geometry lifecycle, navigation updates.
  late final TrackManager _trackManager;

  /// ECS → render snapshot conversion.
  late SnapshotBuilder _snapshotBuilder;

  // ─── Camera ───

  /// Autoscrolling camera that follows and pushes the player.
  late final AutoscrollCamera _camera;

  // ─── Event Queue ───

  /// Pending events to be consumed by UI (drained each frame).
  final List<GameEvent> _events = <GameEvent>[];

  // ─── Scratch/Tracking State ───

  /// Scratch list for killed enemies (reused to avoid allocation).
  final List<EnemyId> _killedEnemiesScratch = <EnemyId>[];

  /// Kill counts per enemy type (indexed by [EnemyId.index]).
  final List<int> _enemyKillCounts = List<int>.filled(EnemyId.values.length, 0);

  // ─── Simulation State ───

  /// Current simulation tick (increments each [stepOneTick]).
  int tick = 0;

  /// Whether simulation is paused (commands still apply, time doesn't advance).
  bool paused = false;

  /// Whether the run has ended (simulation is frozen permanently).
  bool gameOver = false;

  /// Total distance traveled (world units, not meters).
  double distance = 0;

  /// Number of collectibles picked up this run.
  int collectibles = 0;

  /// Total score from collectibles.
  int collectibleScore = 0;

  // ─────────────────────────────────────────────────────────────────────────
  // Public Accessors
  // ─────────────────────────────────────────────────────────────────────────

  /// Level identifier for this run (stable across sessions).
  LevelId get levelId => _levelDefinition.id;

  /// Optional render theme identifier for this run.
  String? get themeId => _levelDefinition.themeId;

  /// Score tuning for UI display and leaderboard calculation.
  ScoreTuning get scoreTuning => _scoreTuning;

  /// Current static world geometry (base + streamed chunks).
  StaticWorldGeometry get staticWorldGeometry => _trackManager.staticGeometry;

  /// Player X position in world coordinates.
  double get playerPosX =>
      _world.transform.posX[_world.transform.indexOf(_player)];

  /// Player Y position in world coordinates.
  double get playerPosY =>
      _world.transform.posY[_world.transform.indexOf(_player)];

  /// Sets player position (for tests or teleportation).
  void setPlayerPosXY(double x, double y) =>
      _world.transform.setPosXY(_player, x, y);

  /// Player X velocity (positive = moving right).
  double get playerVelX =>
      _world.transform.velX[_world.transform.indexOf(_player)];

  /// Player Y velocity (positive = moving down).
  double get playerVelY =>
      _world.transform.velY[_world.transform.indexOf(_player)];

  /// Sets player velocity (for tests or knockback effects).
  void setPlayerVelXY(double x, double y) =>
      _world.transform.setVelXY(_player, x, y);

  /// Whether the player is currently on the ground.
  bool get playerGrounded =>
      _world.collision.grounded[_world.collision.indexOf(_player)];

  /// Player facing direction (left or right).
  Facing get playerFacing =>
      _world.movement.facing[_world.movement.indexOf(_player)];

  /// Sets player facing direction.
  set playerFacing(Facing value) {
    _world.movement.facing[_world.movement.indexOf(_player)] = value;
  }

  /// Remaining cast (projectile) cooldown ticks.
  int get playerCastCooldownTicksLeft =>
      _world.cooldown.castCooldownTicksLeft[_world.cooldown.indexOf(_player)];

  /// Remaining melee attack cooldown ticks.
  int get playerMeleeCooldownTicksLeft =>
      _world.cooldown.meleeCooldownTicksLeft[_world.cooldown.indexOf(_player)];

  // ─────────────────────────────────────────────────────────────────────────
  // Command Processing
  // ─────────────────────────────────────────────────────────────────────────

  /// Applies all commands scheduled for the current tick.
  ///
  /// Commands are the only way external code can influence the simulation.
  /// Each command type maps to a specific player input flag or value:
  ///
  /// - [MoveAxisCommand]: Sets horizontal movement axis (-1 to 1).
  /// - [JumpPressedCommand]: Triggers a jump attempt.
  /// - [DashPressedCommand]: Triggers a dash attempt.
  /// - [AttackPressedCommand]: Triggers an attack attempt.
  /// - [ProjectileAimDirCommand]: Sets projectile aim direction.
  /// - [MeleeAimDirCommand]: Sets melee attack direction.
  /// - [RangedAimDirCommand]: Sets ranged weapon aim direction.
  /// - [CastPressedCommand]: Triggers a spell cast attempt.
  /// - [RangedPressedCommand]: Triggers a ranged weapon attempt.
  ///
  /// Commands are processed before [stepOneTick] to ensure inputs are
  /// available when systems read them.
  void applyCommands(List<Command> commands) {
    // Reset all input flags to their default state.
    _world.playerInput.resetTickInputs(_player);
    final inputIndex = _world.playerInput.indexOf(_player);
    final movementIndex = _world.movement.indexOf(_player);

    for (final command in commands) {
      switch (command) {
        // Movement axis: -1 (left) to +1 (right).
        case MoveAxisCommand(:final axis):
          final clamped = axis.clamp(-1.0, 1.0);
          _world.playerInput.moveAxis[inputIndex] = clamped;
          // Update facing direction unless dashing (locked during dash).
          if (_world.movement.dashTicksLeft[movementIndex] == 0) {
            if (clamped < 0) {
              playerFacing = Facing.left;
            } else if (clamped > 0) {
              playerFacing = Facing.right;
            }
          }

        // Jump: Consumed by PlayerMovementSystem.
        case JumpPressedCommand():
          _world.playerInput.jumpPressed[inputIndex] = true;

        // Dash: Consumed by PlayerMovementSystem.
        case DashPressedCommand():
          _world.playerInput.dashPressed[inputIndex] = true;

        // Attack: Consumed by PlayerMeleeSystem.
        case AttackPressedCommand():
          _world.playerInput.attackPressed[inputIndex] = true;

        // Projectile aim: Direction vector for ranged attacks.
        case ProjectileAimDirCommand(:final x, :final y):
          _world.playerInput.projectileAimDirX[inputIndex] = x;
          _world.playerInput.projectileAimDirY[inputIndex] = y;

        // Melee aim: Direction vector for melee attacks.
        case MeleeAimDirCommand(:final x, :final y):
          _world.playerInput.meleeAimDirX[inputIndex] = x;
          _world.playerInput.meleeAimDirY[inputIndex] = y;

        // Clear projectile aim: Resets to no-aim state.
        case ClearProjectileAimDirCommand():
          _world.playerInput.projectileAimDirX[inputIndex] = 0;
          _world.playerInput.projectileAimDirY[inputIndex] = 0;

        // Clear melee aim: Resets to no-aim state.
        case ClearMeleeAimDirCommand():
          _world.playerInput.meleeAimDirX[inputIndex] = 0;
          _world.playerInput.meleeAimDirY[inputIndex] = 0;

        // Ranged weapon aim: Direction vector for thrown/bow attacks.
        case RangedAimDirCommand(:final x, :final y):
          _world.playerInput.rangedAimDirX[inputIndex] = x;
          _world.playerInput.rangedAimDirY[inputIndex] = y;

        // Clear ranged aim: Resets to no-aim state.
        case ClearRangedAimDirCommand():
          _world.playerInput.rangedAimDirX[inputIndex] = 0;
          _world.playerInput.rangedAimDirY[inputIndex] = 0;

        // Cast: Consumed by PlayerCastSystem for spell casting.
        case CastPressedCommand():
          _world.playerInput.castPressed[inputIndex] = true;

        // Ranged: Consumed by PlayerRangedWeaponSystem.
        case RangedPressedCommand():
          _world.playerInput.rangedPressed[inputIndex] = true;
      }
    }
  }

  // ─────────────────────────────────────────────────────────────────────────
  // Simulation Tick
  // ─────────────────────────────────────────────────────────────────────────

  /// Advances the simulation by exactly one fixed tick.
  ///
  /// This is the main simulation loop. It executes all ECS systems in a
  /// carefully ordered pipeline to ensure correct behavior:
  ///
  /// 1. **Track streaming**: Generate/cull chunks, spawn enemies.
  /// 2. **Cooldowns**: Decrement ability and invulnerability timers.
  /// 3. **Enemy AI**: Compute paths and movement intentions.
  /// 4. **Player movement**: Apply input to velocity.
  /// 5. **Gravity**: Apply gravitational acceleration.
  /// 6. **Collision**: Resolve against static world geometry.
  /// 7. **Death checks**: Detect fall-into-gap and fell-behind-camera.
  /// 8. **Camera update**: Advance autoscroll position.
  /// 9. **Pickups**: Process collectible and restoration item collection.
  /// 10. **Broadphase**: Rebuild spatial grid for hit detection.
  /// 11. **Projectiles**: Move existing projectiles.
  /// 12. **Attack intents**: Queue enemy and player attacks.
  /// 13. **Attack execution**: Spawn hitboxes and projectiles from intents.
  /// 14. **Hitbox positioning**: Update hitbox positions from owners.
  /// 15. **Hit detection**: Check projectile and hitbox overlaps.
  /// 16. **Status ticking**: Apply DoT ticks and queue damage.
  /// 17. **Damage application**: Apply queued damage events.
  /// 18. **Status application**: Apply on-hit status profiles.
  /// 19. **Death handling**: Despawn dead entities, record kills.
  /// 20. **Resource regen**: Regenerate mana and stamina.
  /// 21. **Cleanup**: Remove entities past their lifetime.
  ///
  /// If the run ends during this tick (player death, fell into gap, etc.),
  /// a [RunEndedEvent] is emitted and the simulation freezes.
  void stepOneTick() {
    // Don't advance if paused or game already over.
    if (paused || gameOver) return;

    if (_deathAnimTicksLeft > 0) {
      tick += 1;
      _deathAnimTicksLeft -= 1;
      if (_deathAnimTicksLeft <= 0) {
        _endRun(
          _pendingRunEndReason ?? RunEndReason.playerDied,
          deathInfo: _pendingDeathInfo,
        );
      }
      return;
    }

    tick += 1;

    // Cache ground Y once per tick (ground plane doesn't change mid-tick).
    final effectiveGroundTopY =
        staticWorldGeometry.groundPlane?.topY ?? groundTopY.toDouble();

    // ─── Phase 1: World generation ───
    _stepTrackManager(effectiveGroundTopY);

    // ─── Phase 2: Timer decrements ───
    _cooldownSystem.step(_world);
    _invulnerabilitySystem.step(_world);

    // ─── Phase 3: AI and movement ───
    _enemySystem.stepSteering(
      _world,
      player: _player,
      groundTopY: effectiveGroundTopY,
      dtSeconds: _movement.dtSeconds,
    );

    _movementSystem.step(_world, _movement, resources: _resourceTuning);
    _gravitySystem.step(_world, _movement, physics: _physicsTuning);
    _collisionSystem.step(
      _world,
      _movement,
      staticWorld: _trackManager.staticIndex,
    );

    // ─── Phase 4: Distance tracking ───
    // Only count forward movement (positive X velocity).
    distance += max(0.0, playerVelX) * _movement.dtSeconds;

    // ─── Phase 5: Death condition checks ───
    if (_checkFellIntoGap(effectiveGroundTopY)) {
      _endRun(RunEndReason.fellIntoGap);
      return;
    }

    _camera.updateTick(dtSeconds: _movement.dtSeconds, playerX: playerPosX);
    if (_checkFellBehindCamera()) {
      _endRun(RunEndReason.fellBehindCamera);
      return;
    }

    // ─── Phase 6: Pickup collection ───
    _collectibleSystem.step(
      _world,
      player: _player,
      cameraLeft: _camera.left(),
      tuning: _collectibleTuning,
      onCollected: (value) {
        collectibles += 1;
        collectibleScore += value;
      },
    );
    _restorationItemSystem.step(
      _world,
      player: _player,
      cameraLeft: _camera.left(),
      tuning: _restorationItemTuning,
    );

    // ─── Phase 7: Spatial grid rebuild ───
    // Must happen before hit detection to ensure accurate overlaps.
    _broadphaseGrid.rebuild(_world);

    // ─── Phase 8: Projectile movement ───
    // Move existing projectiles before spawning new ones.
    _projectileSystem.step(_world, _movement);

    // ─── Phase 9: Attack intent writing ───
    // Enemies first, then player (order matters for fairness).
    _enemySystem.stepAttacks(_world, player: _player, currentTick: tick);
    _castSystem.step(_world, player: _player, currentTick: tick);
    _meleeSystem.step(_world, player: _player, currentTick: tick);
    _rangedWeaponSystem.step(_world, player: _player, currentTick: tick);

    // ─── Phase 10: Attack execution ───
    // Convert intents into actual hitboxes and projectiles.
    _spellCastSystem.step(_world, currentTick: tick);
    _meleeAttackSystem.step(_world, currentTick: tick);
    _rangedWeaponAttackSystem.step(_world, currentTick: tick);

    // ─── Phase 11: Hitbox positioning ───
    // Update hitbox transforms to follow their owner entities.
    _hitboxFollowOwnerSystem.step(_world);

    // ─── Phase 12: Hit resolution ───
    // Detect overlaps and queue damage events.
    _projectileHitSystem.step(_world, _damageSystem.queue, _broadphaseGrid);
    _hitboxDamageSystem.step(_world, _damageSystem.queue, _broadphaseGrid);
    _projectileWorldCollisionSystem.step(_world);
    // ─── Phase 13: Status + damage ───
    _statusSystem.tickExisting(_world, _damageSystem.queue);
    _damageSystem.step(
      _world,
      currentTick: tick,
      queueStatus: _statusSystem.queue,
    );
    _statusSystem.applyQueued(_world);

    // ─── Phase 14: Death handling ───
    _killedEnemiesScratch.clear();
    _enemyCullSystem.step(
      _world,
      cameraLeft: _camera.left(),
      groundTopY: effectiveGroundTopY,
      tuning: _trackTuning,
    );
    _healthDespawnSystem.step(
      _world,
      player: _player,
      outEnemiesKilled: _killedEnemiesScratch,
    );
    if (_killedEnemiesScratch.isNotEmpty) {
      _recordEnemyKills(_killedEnemiesScratch);
    }
    if (_isPlayerDead()) {
      if (_deathAnimTicksLeft <= 0) {
        _pendingRunEndReason = RunEndReason.playerDied;
        _pendingDeathInfo = _buildDeathInfo();
        if (_animTuning.deathAnimTicks <= 0) {
          _endRun(_pendingRunEndReason!, deathInfo: _pendingDeathInfo);
        } else {
          _deathAnimTicksLeft = _animTuning.deathAnimTicks;
        }
      }
      return;
    }

    // ─── Phase 15: Resource regeneration ───
    _resourceRegenSystem.step(_world, dtSeconds: _movement.dtSeconds);

    // ─── Phase 16: Cleanup ───
    _lifetimeSystem.step(_world);
  }

  /// Steps the track manager and handles enemy spawning callbacks.
  ///
  /// This is extracted from [stepOneTick] to keep the main loop readable.
  void _stepTrackManager(double effectiveGroundTopY) {
    _trackManager.step(
      cameraLeft: _camera.left(),
      cameraRight: _camera.right(),
      spawnEnemy: (enemyId, x) {
        // Route spawn requests to the appropriate SpawnService method.
        switch (enemyId) {
          case EnemyId.unocoDemon:
            _spawnService.spawnUnocoDemon(
              spawnX: x,
              groundTopY: effectiveGroundTopY,
            );
          case EnemyId.groundEnemy:
            _spawnService.spawnGroundEnemy(
              spawnX: x,
              groundTopY: effectiveGroundTopY,
            );
        }
      },
      lowestResourceStat: _lowestResourceStat,
    );
  }

  // ─────────────────────────────────────────────────────────────────────────
  // Run End Handling
  // ─────────────────────────────────────────────────────────────────────────

  /// Ends the current run and emits a [RunEndedEvent].
  ///
  /// After this call, [gameOver] is true and [stepOneTick] will no-op.
  void _endRun(RunEndReason reason, {DeathInfo? deathInfo}) {
    gameOver = true;
    paused = true;
    _events.add(
      RunEndedEvent(
        tick: tick,
        distance: distance,
        reason: reason,
        stats: _buildRunEndStats(),
        deathInfo: deathInfo,
      ),
    );
  }

  /// Manually ends the run (e.g., from pause menu).
  ///
  /// Does nothing if the game is already over.
  void giveUp() {
    if (gameOver) return;
    _endRun(RunEndReason.gaveUp);
  }

  /// Records enemy kills for score calculation.
  void _recordEnemyKills(List<EnemyId> killedEnemies) {
    for (final enemyId in killedEnemies) {
      final index = enemyId.index;
      if (index >= 0 && index < _enemyKillCounts.length) {
        _enemyKillCounts[index] += 1;
      }
    }
  }

  /// Builds run statistics for the end-of-run event.
  RunEndStats _buildRunEndStats() => RunEndStats(
    collectibles: collectibles,
    collectibleScore: collectibleScore,
    enemyKillCounts: List<int>.unmodifiable(_enemyKillCounts),
  );

  /// Checks if the player's HP has reached zero.
  bool _isPlayerDead() {
    final hi = _world.health.tryIndexOf(_player);
    if (hi == null) return false;
    return _world.health.hp[hi] <= 0.0;
  }

  /// Builds death info for the run-ended event.
  ///
  /// This provides details about what killed the player (enemy type,
  /// projectile type, etc.) for death screen messaging.
  DeathInfo? _buildDeathInfo() {
    final li = _world.lastDamage.tryIndexOf(_player);
    if (li == null) return null;

    final kind = _world.lastDamage.kind[li];
    if (kind == DeathSourceKind.unknown) return null;

    return DeathInfo(
      kind: kind,
      enemyId: _world.lastDamage.hasEnemyId[li]
          ? _world.lastDamage.enemyId[li]
          : null,
      projectileId: _world.lastDamage.hasProjectileId[li]
          ? _world.lastDamage.projectileId[li]
          : null,
      spellId: _world.lastDamage.hasSpellId[li]
          ? _world.lastDamage.spellId[li]
          : null,
    );
  }

  // ─────────────────────────────────────────────────────────────────────────
  // Death Condition Checks
  // ─────────────────────────────────────────────────────────────────────────

  /// Checks if the player has fallen behind the camera's left edge.
  ///
  /// This is a "soft" death—the player can still be on solid ground but
  /// has failed to keep up with the autoscrolling camera.
  bool _checkFellBehindCamera() {
    if (!(_world.transform.has(_player) && _world.colliderAabb.has(_player))) {
      return false;
    }

    final ti = _world.transform.indexOf(_player);
    final ai = _world.colliderAabb.indexOf(_player);
    final centerX = _world.transform.posX[ti] + _world.colliderAabb.offsetX[ai];
    final right = centerX + _world.colliderAabb.halfX[ai];

    // Player's right edge must stay ahead of camera's left edge.
    return right < _camera.left();
  }

  /// Checks if the player has fallen into a ground gap (pit).
  ///
  /// The kill threshold is set well below ground level to give visual
  /// feedback of falling before the death triggers. Configured via
  /// [TrackTuning.gapKillOffsetY].
  bool _checkFellIntoGap(double groundTopY) {
    if (!(_world.transform.has(_player) && _world.colliderAabb.has(_player))) {
      return false;
    }

    final ti = _world.transform.indexOf(_player);
    final ai = _world.colliderAabb.indexOf(_player);
    final bottomY =
        _world.transform.posY[ti] +
        _world.colliderAabb.offsetY[ai] +
        _world.colliderAabb.halfY[ai];

    return bottomY > groundTopY + _trackTuning.gapKillOffsetY;
  }

  // ─────────────────────────────────────────────────────────────────────────
  // Resource Helpers
  // ─────────────────────────────────────────────────────────────────────────

  /// Returns the player's most depleted resource stat.
  ///
  /// Used by restoration item spawning to bias item type toward what
  /// the player needs most. Compares ratios (current/max) to handle
  /// resources with different maximum values fairly.
  ///
  /// **Tie-breaking priority**: When ratios are equal, the first resource
  /// checked wins: health > mana > stamina. This is intentional—health
  /// is prioritized as the most critical survival resource.
  RestorationStat _lowestResourceStat() {
    final hi = _world.health.tryIndexOf(_player);
    final mi = _world.mana.tryIndexOf(_player);
    final si = _world.stamina.tryIndexOf(_player);
    if (hi == null || mi == null || si == null) {
      return RestorationStat.health;
    }

    // Start with health as baseline.
    var best = RestorationStat.health;
    var bestValue = _world.health.hp[hi];
    var bestMax = _world.health.hpMax[hi];

    // Compare mana ratio.
    final mana = _world.mana.mana[mi];
    final manaMax = _world.mana.manaMax[mi];
    if (_ratioLess(mana, manaMax, bestValue, bestMax)) {
      best = RestorationStat.mana;
      bestValue = mana;
      bestMax = manaMax;
    }

    // Compare stamina ratio.
    final stamina = _world.stamina.stamina[si];
    final staminaMax = _world.stamina.staminaMax[si];
    if (_ratioLess(stamina, staminaMax, bestValue, bestMax)) {
      best = RestorationStat.stamina;
    }

    return best;
  }

  /// Compares two ratios without division: (valueA / maxA) < (valueB / maxB).
  ///
  /// Cross-multiplies to avoid division: valueA * maxB < valueB * maxA.
  bool _ratioLess(double valueA, double maxA, double valueB, double maxB) {
    if (maxA <= 0) return false; // Invalid ratio A, can't be less.
    if (maxB <= 0) return true; // Invalid ratio B, A wins by default.
    return valueA * maxB < valueB * maxA;
  }

  /// Computes the maximum air time (in ticks) for ground enemy jumps.
  ///
  /// Based on projectile motion: time = 2 * jumpSpeed / gravity.
  /// Multiplied by 1.5 for safety margin (accounts for landing tolerance).
  int _groundEnemyMaxAirTicks() {
    final gravity = _physicsTuning.gravityY;
    if (gravity <= 0) {
      // No gravity means infinite air time; cap at 1 second.
      return ticksFromSecondsCeil(1.0, tickHz);
    }
    final jumpSpeed = _groundEnemyTuning.base.groundEnemyJumpSpeed.abs();
    final baseAirSeconds = (2.0 * jumpSpeed) / gravity;
    return ticksFromSecondsCeil(baseAirSeconds * 1.5, tickHz);
  }

  // ─────────────────────────────────────────────────────────────────────────
  // Events & Snapshots
  // ─────────────────────────────────────────────────────────────────────────

  /// Drains and returns all pending game events.
  ///
  /// Events are produced during [stepOneTick] (e.g., [RunEndedEvent]).
  /// The UI layer should call this after each tick to process events.
  ///
  /// Returns an empty list if no events are pending (avoids allocation).
  List<GameEvent> drainEvents() {
    if (_events.isEmpty) return const <GameEvent>[];
    final drained = List<GameEvent>.unmodifiable(_events);
    _events.clear();
    return drained;
  }

  /// Builds an immutable snapshot for render/UI consumption.
  ///
  /// The snapshot contains everything needed to render a single frame:
  /// - Entity positions, velocities, and animations
  /// - Player HUD data (HP, mana, stamina, cooldowns)
  /// - Static geometry (platforms, ground gaps)
  /// - Camera position
  ///
  /// Snapshots are immutable and safe to pass to async render code.
  GameStateSnapshot buildSnapshot() {
    return _snapshotBuilder.build(
      tick: tick,
      seed: seed,
      levelId: levelId,
      themeId: themeId,
      distance: distance,
      paused: paused,
      gameOver: gameOver,
      cameraCenterX: _camera.state.centerX,
      cameraCenterY: cameraFixedY,
      collectibles: collectibles,
      collectibleScore: collectibleScore,
      staticSolids: _trackManager.staticSolidsSnapshot,
      groundGaps: _trackManager.staticGroundGapsSnapshot,
    );
  }
}


===== FILE: lib/core/levels/level_definition.dart =====
/// Data-first definition of a level configuration (Core-only).
library;

import '../collision/static_world_geometry.dart';
import '../contracts/render_contract.dart';
import '../track/chunk_pattern_pool.dart';
import '../tuning/core_tuning.dart';
import 'level_id.dart';

/// Core configuration for a single level.
///
/// This is pure data: no Flutter/Flame imports and no runtime side effects.
class LevelDefinition {
  const LevelDefinition({
    required this.id,
    required this.patternPool,
    this.tuning = const CoreTuning(),
    this.staticWorldGeometry = const StaticWorldGeometry(
      groundPlane: StaticGroundPlane(topY: groundTopY * 1.0),
    ),
    this.earlyPatternChunks = defaultEarlyPatternChunks,
    this.noEnemyChunks = defaultNoEnemyChunks,
    this.themeId,
  }) : assert(earlyPatternChunks >= 0),
       assert(noEnemyChunks >= 0);

  /// Stable identifier for this level.
  final LevelId id;

  /// Core tuning overrides for this level.
  final CoreTuning tuning;

  /// Base collision geometry for the level (ground + fixed platforms).
  final StaticWorldGeometry staticWorldGeometry;

  /// Pattern pool used for procedural chunk generation.
  final ChunkPatternPool patternPool;

  /// Number of early chunks that use [patternPool.easyPatterns].
  final int earlyPatternChunks;

  /// Number of early chunks that suppress enemy spawns.
  final int noEnemyChunks;

  /// Optional render theme identifier (e.g., lookup key for assets).
  final String? themeId;
}


===== FILE: lib/core/levels/level_id.dart =====
/// Stable identifiers for level definitions.
///
/// Avoid renaming or reordering values; treat as protocol-stable.
enum LevelId {
  /// The default runner level.
  defaultLevel,
  forest,
  field,
}


===== FILE: lib/core/levels/level_registry.dart =====
/// Registry for core level definitions.
library;

import '../track/chunk_pattern_pool.dart';
import '../track/chunk_patterns_library.dart';
import 'level_definition.dart';
import 'level_id.dart';

/// Default pattern pool (matches current behavior).
const ChunkPatternPool defaultPatternPool = ChunkPatternPool(
  easyPatterns: easyPatterns,
  allPatterns: allPatterns,
);

/// Default level definition.
const LevelDefinition defaultLevelDefinition = LevelDefinition(
  id: LevelId.defaultLevel,
  patternPool: defaultPatternPool,
  themeId: 'forest',
);

/// Resolves level definitions by stable [LevelId].
class LevelRegistry {
  const LevelRegistry._();

  /// Default level used when no level is specified.
  static const LevelDefinition defaultLevel = defaultLevelDefinition;

  /// Returns the level definition for a given [LevelId].
  static LevelDefinition byId(LevelId id) {
    switch (id) {
      case LevelId.forest:
        return LevelDefinition(
          id: LevelId.forest,
          patternPool: defaultPatternPool,
          themeId: 'forest',
        );
      case LevelId.field:
        return LevelDefinition(
          id: LevelId.field,
          patternPool: defaultPatternPool,
          themeId: 'field',
        );
      case LevelId.defaultLevel:
        return defaultLevelDefinition;
    }
  }
}


===== FILE: lib/core/navigation/surface_extractor.dart =====
import '../collision/static_world_geometry.dart';
import 'types/nav_tolerances.dart';
import 'types/surface_id.dart';
import 'types/walk_surface.dart';

/// Extracts [WalkSurface]s from tile-based world geometry.
///
/// **Pipeline**:
/// 1. Collect top faces of solid tiles as raw segments.
/// 2. Process ground layer (explicit segments or infinite plane).
/// 3. Subtract blockers (solids/gaps) from ground.
/// 4. Sort and merge adjacent coplanar segments.
///
/// **ID Assignment**:
/// Each surface gets a unique ID via [packSurfaceId], encoding chunk and local
/// indices. This enables stable references across graph rebuilds.
class SurfaceExtractor {
  SurfaceExtractor({
    this.mergeEps = navGeomEps,
    this.groundPadding = 1024.0,
  });

  /// Tolerance for merging adjacent segments (pixels).
  final double mergeEps;

  /// Horizontal padding beyond world bounds for ground plane fallback.
  final double groundPadding;

  /// Extracts walkable surfaces from [geometry].
  ///
  /// **Returns**: Unmodifiable list of [WalkSurface]s, sorted and merged.
  List<WalkSurface> extract(StaticWorldGeometry geometry) {
    final segments = <_SurfaceSegment>[];

    // Stride for ground segment IDs to avoid collisions with tile IDs.
    const groundPieceStride = 1000;

    // -------------------------------------------------------------------------
    // Step 1: Collect solid top faces.
    // -------------------------------------------------------------------------
    var minX = double.infinity;
    var maxX = double.negativeInfinity;
    for (var i = 0; i < geometry.solids.length; i += 1) {
      final solid = geometry.solids[i];

      // Track world bounds for ground plane fallback.
      if (solid.minX < minX) minX = solid.minX;
      if (solid.maxX > maxX) maxX = solid.maxX;

      // Only include solids with a walkable top face.
      if ((solid.sides & StaticSolid.sideTop) == 0) continue;

      var localSolidIndex = solid.localSolidIndex;
      if (localSolidIndex < 0) {
        if (solid.chunkIndex != StaticSolid.noChunk) {
          throw StateError(
            'Chunk solid is missing a localSolidIndex; check track streamer.',
          );
        }
        // Non-chunk solid: use array index as fallback.
        localSolidIndex = i;
      }

      final id = packSurfaceId(
        chunkIndex: solid.chunkIndex,
        localSolidIndex: localSolidIndex,
      );
      segments.add(
        _SurfaceSegment(
          id: id,
          xMin: solid.minX,
          xMax: solid.maxX,
          yTop: solid.minY,
        ),
      );
    }

    // -------------------------------------------------------------------------
    // Step 2: Process ground layer.
    // -------------------------------------------------------------------------
    if (geometry.groundSegments.isNotEmpty) {
      // Explicit ground segments (from level data).
      for (var gi = 0; gi < geometry.groundSegments.length; gi += 1) {
        final ground = geometry.groundSegments[gi];
        var localSegmentIndex = ground.localSegmentIndex;
        if (localSegmentIndex < 0) {
          if (ground.chunkIndex != StaticSolid.noChunk) {
            throw StateError(
              'Ground segment is missing a localSegmentIndex; check track streamer.',
            );
          }
          localSegmentIndex = gi;
        }

        // Subtract solids that block the ground at this Y.
        final blockers = _collectGroundBlockers(
          geometry.solids,
          const <StaticGroundGap>[],
          ground.topY,
          mergeEps,
        );
        final groundSegments = _subtractRanges(
          ground.minX,
          ground.maxX,
          blockers,
          mergeEps,
        );

        // Create surface for each unblocked portion.
        for (var i = 0; i < groundSegments.length; i += 1) {
          final seg = groundSegments[i];
          final id = packSurfaceId(
            chunkIndex: ground.chunkIndex,
            localSolidIndex: localSegmentIndex * groundPieceStride + i,
          );
          segments.add(
            _SurfaceSegment(
              id: id,
              xMin: seg.min,
              xMax: seg.max,
              yTop: ground.topY,
            ),
          );
        }
      }
    } else {
      // Infinite ground plane fallback.
      final groundPlane = geometry.groundPlane;
      if (groundPlane != null) {
        final baseMinX = minX.isFinite ? minX : 0.0;
        final baseMaxX = maxX.isFinite ? maxX : 0.0;
        final groundMinX = baseMinX - groundPadding;
        final groundMaxX = baseMaxX + groundPadding;

        final blockers = _collectGroundBlockers(
          geometry.solids,
          geometry.groundGaps,
          groundPlane.topY,
          mergeEps,
        );
        final groundSegments = _subtractRanges(
          groundMinX,
          groundMaxX,
          blockers,
          mergeEps,
        );

        for (var i = 0; i < groundSegments.length; i += 1) {
          final seg = groundSegments[i];
          segments.add(
            _SurfaceSegment(
              id: packSurfaceId(
                chunkIndex: StaticSolid.groundChunk,
                localSolidIndex: i,
              ),
              xMin: seg.min,
              xMax: seg.max,
              yTop: groundPlane.topY,
            ),
          );
        }
      }
    }

    if (segments.isEmpty) {
      return const <WalkSurface>[];
    }

    // -------------------------------------------------------------------------
    // Step 3: Sort and merge adjacent coplanar segments.
    // -------------------------------------------------------------------------
    segments.sort(_compareSegments);

    final merged = <WalkSurface>[];
    var current = segments.first;
    for (var i = 1; i < segments.length; i += 1) {
      final next = segments[i];
      final sameY = (next.yTop - current.yTop).abs() <= mergeEps;
      final touches = next.xMin <= current.xMax + mergeEps;

      if (sameY && touches) {
        // Extend current segment to include next.
        if (next.xMax > current.xMax) {
          current = current.copyWith(xMax: next.xMax);
        }
      } else {
        // Flush current, start new segment.
        merged.add(
          WalkSurface(
            id: current.id,
            xMin: current.xMin,
            xMax: current.xMax,
            yTop: current.yTop,
          ),
        );
        current = next;
      }
    }

    // Flush final segment.
    merged.add(
      WalkSurface(
        id: current.id,
        xMin: current.xMin,
        xMax: current.xMax,
        yTop: current.yTop,
      ),
    );

    return List<WalkSurface>.unmodifiable(merged);
  }
}

// =============================================================================
// Internal types
// =============================================================================

/// Intermediate segment representation before merging.
class _SurfaceSegment {
  const _SurfaceSegment({
    required this.id,
    required this.xMin,
    required this.xMax,
    required this.yTop,
  });

  /// Packed surface ID (see [packSurfaceId]).
  final int id;

  /// Left edge X coordinate.
  final double xMin;

  /// Right edge X coordinate.
  final double xMax;

  /// Top Y coordinate (walking height).
  final double yTop;

  /// Creates a copy with modified [xMax] (used during merge).
  _SurfaceSegment copyWith({double? xMax}) {
    return _SurfaceSegment(
      id: id,
      xMin: xMin,
      xMax: xMax ?? this.xMax,
      yTop: yTop,
    );
  }
}

/// Mutable horizontal range (used for blocker collection).
class _Range {
  _Range(this.min, this.max);

  double min;
  double max;
}

// =============================================================================
// Helper functions
// =============================================================================

/// Collects horizontal ranges that block the ground at [groundTopY].
///
/// Includes:
/// - Solids with left/right walls touching ground Y.
/// - Explicit ground gaps.
///
/// Returns merged, sorted list of blocking ranges.
List<_Range> _collectGroundBlockers(
  List<StaticSolid> solids,
  List<StaticGroundGap> gaps,
  double groundTopY,
  double eps,
) {
  final blockers = <_Range>[];

  // Collect solids that intersect ground level and have vertical walls.
  for (final solid in solids) {
    final hasWalls =
        (solid.sides & (StaticSolid.sideLeft | StaticSolid.sideRight)) != 0;
    if (!hasWalls) continue;

    final touchesGround =
        solid.minY <= groundTopY + eps && solid.maxY >= groundTopY - eps;
    if (!touchesGround) continue;

    blockers.add(_Range(solid.minX, solid.maxX));
  }

  // Add explicit gaps.
  for (final gap in gaps) {
    blockers.add(_Range(gap.minX, gap.maxX));
  }

  if (blockers.isEmpty) return blockers;

  // Sort and merge overlapping blockers.
  blockers.sort((a, b) => a.min.compareTo(b.min));
  final merged = <_Range>[blockers.first];
  for (var i = 1; i < blockers.length; i += 1) {
    final current = blockers[i];
    final last = merged.last;
    if (current.min <= last.max + eps) {
      // Overlapping or adjacent—extend.
      if (current.max > last.max) {
        last.max = current.max;
      }
    } else {
      merged.add(_Range(current.min, current.max));
    }
  }

  return merged;
}

/// Subtracts [blockers] from range [min, max], returning unblocked segments.
///
/// **Algorithm**:
/// Walk left-to-right, emitting segments between blocker gaps.
List<_Range> _subtractRanges(
  double min,
  double max,
  List<_Range> blockers,
  double eps,
) {
  if (blockers.isEmpty) {
    return <_Range>[_Range(min, max)];
  }

  final segments = <_Range>[];
  var cursor = min;

  for (final blocker in blockers) {
    // Skip blockers entirely before our range.
    if (blocker.max <= min + eps) continue;
    // Stop if blocker starts after our range.
    if (blocker.min >= max - eps) break;

    // Clamp blocker to our range.
    final blockMin = blocker.min < min ? min : blocker.min;
    final blockMax = blocker.max > max ? max : blocker.max;

    // Emit segment before blocker (if any).
    if (blockMin > cursor + eps) {
      segments.add(_Range(cursor, blockMin));
    }

    // Advance cursor past blocker.
    if (blockMax > cursor) {
      cursor = blockMax;
    }
  }

  // Emit trailing segment (if any).
  if (cursor < max - eps) {
    segments.add(_Range(cursor, max));
  }

  return segments;
}

/// Comparison function for sorting segments (Y, then X, then ID).
int _compareSegments(_SurfaceSegment a, _SurfaceSegment b) {
  // Primary: Y ascending (lower platforms first in screen coords).
  if (a.yTop < b.yTop) return -1;
  if (a.yTop > b.yTop) return 1;
  // Secondary: X ascending.
  if (a.xMin < b.xMin) return -1;
  if (a.xMin > b.xMin) return 1;
  // Tertiary: Width ascending.
  if (a.xMax < b.xMax) return -1;
  if (a.xMax > b.xMax) return 1;
  // Final: ID for determinism.
  if (a.id < b.id) return -1;
  if (a.id > b.id) return 1;
  return 0;
}


===== FILE: lib/core/navigation/surface_graph_builder.dart =====
import '../collision/static_world_geometry.dart';
import '../ecs/spatial/grid_index_2d.dart';
import 'utils/jump_template.dart';
import 'types/nav_tolerances.dart';
import 'surface_extractor.dart';
import 'types/surface_graph.dart';
import 'utils/surface_spatial_index.dart';
import 'types/walk_surface.dart';

/// Result of [SurfaceGraphBuilder.build].
class SurfaceGraphBuildResult {
  const SurfaceGraphBuildResult({
    required this.graph,
    required this.spatialIndex,
  });

  /// The navigation graph (surfaces + edges in CSR format).
  final SurfaceGraph graph;

  /// Spatial index for fast surface lookups during runtime navigation.
  final SurfaceSpatialIndex spatialIndex;
}

/// Builds a [SurfaceGraph] from world geometry and jump physics.
///
/// **Pipeline**:
/// 1. Extract [WalkSurface]s from tiles via [SurfaceExtractor].
/// 2. Build spatial index for candidate queries.
/// 3. For each surface, generate edges:
///    - **Drop edges**: Walk off ledge, fall to surface below.
///    - **Jump edges**: Sample takeoff points, find reachable surfaces.
/// 4. Pack into CSR (Compressed Sparse Row) format.
///
/// **Configuration**:
/// - [standableEps]: Tolerance for standable range calculations.
/// - [dropSampleOffset]: Nudge takeoff past ledge for drop edges.
/// - [takeoffSampleMaxStep]: Maximum spacing between takeoff samples.
class SurfaceGraphBuilder {
  SurfaceGraphBuilder({
    required GridIndex2D surfaceGrid,
    SurfaceExtractor? extractor,
    this.standableEps = navGeomEps,
    this.dropSampleOffset = navSpatialEps,
    this.takeoffSampleMaxStep = 64.0,
  })  : _surfaceGrid = surfaceGrid,
        _extractor = extractor ?? SurfaceExtractor();

  /// Grid for spatial index bucket allocation.
  final GridIndex2D _surfaceGrid;

  /// Surface extractor (default: standard tile-based extraction).
  final SurfaceExtractor _extractor;

  /// Tolerance for standable range width check.
  final double standableEps;

  /// Offset past ledge for drop takeoff (ensures entity actually falls).
  final double dropSampleOffset;

  /// Maximum step between takeoff sample points.
  final double takeoffSampleMaxStep;

  /// Builds a navigation graph from world geometry.
  ///
  /// **Parameters**:
  /// - [geometry]: Static collision geometry (tile-based).
  /// - [jumpTemplate]: Precomputed jump arc for reachability queries.
  ///
  /// **Returns**: [SurfaceGraphBuildResult] with graph and spatial index.
  SurfaceGraphBuildResult build({
    required StaticWorldGeometry geometry,
    required JumpReachabilityTemplate jumpTemplate,
  }) {
    // -------------------------------------------------------------------------
    // Step 1: Extract surfaces and build spatial index.
    // -------------------------------------------------------------------------
    final surfaces = _extractor.extract(geometry);
    final spatialIndex = SurfaceSpatialIndex(index: _surfaceGrid);
    spatialIndex.rebuild(surfaces);

    // Build surface ID → index lookup.
    final indexById = <int, int>{};
    for (var i = 0; i < surfaces.length; i += 1) {
      indexById[surfaces[i].id] = i;
    }

    // -------------------------------------------------------------------------
    // Step 2: Generate edges for each surface.
    // -------------------------------------------------------------------------
    final edges = <SurfaceEdge>[];
    final edgeOffsets = List<int>.filled(surfaces.length + 1, 0);
    final tempCandidates = <int>[];

    for (var i = 0; i < surfaces.length; i += 1) {
      edgeOffsets[i] = edges.length;
      final from = surfaces[i];

      // Compute standable range (agent center positions that fit on surface).
      final standable = _standableRange(
        from,
        jumpTemplate.profile.agentHalfWidth,
        standableEps,
      );
      if (standable == null) {
        // Surface too narrow for agent.
        edgeOffsets[i + 1] = edges.length;
        continue;
      }

      // -----------------------------------------------------------------------
      // Step 2a: Generate drop edges (walk off ledge).
      // -----------------------------------------------------------------------
      final dropSamples = _dropSamples(standable.min, standable.max);
      final dropMid = (standable.min + standable.max) * 0.5;
      for (final dropX in dropSamples) {
        final landingIndex = _findFirstSurfaceBelow(
          surfaces,
          dropX,
          from.yTop,
          jumpTemplate.profile.agentHalfWidth,
        );
        if (landingIndex == null) continue;

        final landingSurface = surfaces[landingIndex];
        final dy = landingSurface.yTop - from.yTop;
        final fallTicks = estimateFallTicks(
          dy: dy,
          gravityY: jumpTemplate.profile.gravityY,
          dtSeconds: jumpTemplate.profile.dtSeconds,
          maxTicks: jumpTemplate.profile.maxAirTicks,
        );

        // Nudge takeoff past ledge so agent actually walks off.
        final offset = dropX <= dropMid ? -dropSampleOffset : dropSampleOffset;
        final takeoffX = dropX + offset;

        final edge = SurfaceEdge(
          to: landingIndex,
          kind: SurfaceEdgeKind.drop,
          takeoffX: takeoffX,
          landingX: _clamp(
            dropX,
            landingSurface.xMin + jumpTemplate.profile.agentHalfWidth,
            landingSurface.xMax - jumpTemplate.profile.agentHalfWidth,
          ),
          travelTicks: fallTicks,
          cost: fallTicks * jumpTemplate.profile.dtSeconds,
        );
        edges.add(edge);
      }

      // -----------------------------------------------------------------------
      // Step 2b: Generate jump edges (sample takeoff points).
      // -----------------------------------------------------------------------
      final takeoffXs = _takeoffSamples(
        standable.min,
        standable.max,
        jumpTemplate.maxDx,
        takeoffSampleMaxStep,
      );

      for (final takeoffX in takeoffXs) {
        // Query reachable surfaces within jump arc bounding box.
        final minX = takeoffX - jumpTemplate.maxDx;
        final maxX = takeoffX + jumpTemplate.maxDx;
        final minY = from.yTop + jumpTemplate.minDy;
        final maxY = from.yTop + jumpTemplate.maxDy;

        spatialIndex.queryAabb(
          minX: minX,
          minY: minY,
          maxX: maxX,
          maxY: maxY,
          outSurfaceIndices: tempCandidates,
        );

        // Sort for deterministic edge ordering.
        tempCandidates.sort(
          (a, b) => surfaces[a].id.compareTo(surfaces[b].id),
        );

        for (final targetIndex in tempCandidates) {
          if (targetIndex == i) continue; // Skip self.
          final target = surfaces[targetIndex];

          final landing = _standableRange(
            target,
            jumpTemplate.profile.agentHalfWidth,
            standableEps,
          );
          if (landing == null) continue; // Target too narrow.

          // Check if jump arc can reach target surface.
          final dy = target.yTop - from.yTop;
          final dxMin = landing.min - takeoffX;
          final dxMax = landing.max - takeoffX;
          final landingTick = jumpTemplate.findFirstLanding(
            dy: dy,
            dxMin: dxMin,
            dxMax: dxMax,
          );
          if (landingTick == null) continue; // Not reachable.

          // Compute actual landing range (intersection of reach and surface).
          final reachMin = takeoffX - landingTick.maxDx;
          final reachMax = takeoffX + landingTick.maxDx;
          final low = reachMin > landing.min ? reachMin : landing.min;
          final high = reachMax < landing.max ? reachMax : landing.max;
          if (low > high + standableEps) continue; // No overlap.

          final edge = SurfaceEdge(
            to: targetIndex,
            kind: SurfaceEdgeKind.jump,
            takeoffX: takeoffX,
            landingX: (low + high) * 0.5, // Center of landing range.
            travelTicks: landingTick.tick,
            cost: landingTick.tick * jumpTemplate.profile.dtSeconds,
          );
          edges.add(edge);
        }
      }

      edgeOffsets[i + 1] = edges.length;
    }

    // -------------------------------------------------------------------------
    // Step 3: Pack into graph and return.
    // -------------------------------------------------------------------------
    return SurfaceGraphBuildResult(
      graph: SurfaceGraph(
        surfaces: surfaces,
        edgeOffsets: edgeOffsets,
        edges: edges,
        indexById: indexById,
      ),
      spatialIndex: spatialIndex,
    );
  }
}

// =============================================================================
// Helper types and functions
// =============================================================================

/// A horizontal range [min, max].
class _Range {
  const _Range(this.min, this.max);

  final double min;
  final double max;
}

/// Computes the standable X range for an agent on a surface.
///
/// The agent's center must be at least [halfWidth] from each edge.
/// Returns `null` if the surface is too narrow.
_Range? _standableRange(WalkSurface surface, double halfWidth, double eps) {
  final min = surface.xMin + halfWidth;
  final max = surface.xMax - halfWidth;
  if (min > max + eps) return null;
  return _Range(min, max);
}

/// Generates takeoff sample points across a standable range.
///
/// - Returns [min, mid, max] for narrow surfaces.
/// - Returns evenly-spaced samples (at most [maxStep] apart) for wide surfaces.
/// - Deduplicates samples within [navGeomEps].
List<double> _takeoffSamples(
  double min,
  double max,
  double maxDx,
  double maxStep,
) {
  if (max <= min) {
    return <double>[min];
  }

  var step = maxDx;
  if (maxStep > 0 && step > maxStep) {
    step = maxStep;
  }

  // Narrow surface: just sample endpoints and midpoint.
  if (step <= navGeomEps || (max - min) <= step) {
    final mid = (min + max) * 0.5;
    return _dedupeSamples(<double>[min, mid, max]);
  }

  // Wide surface: evenly-spaced samples.
  final samples = <double>[];
  for (var x = min; x <= max; x += step) {
    samples.add(x);
  }
  // Ensure max is included.
  if ((max - samples.last).abs() > navGeomEps) {
    samples.add(max);
  }
  return _dedupeSamples(samples);
}

/// Generates drop sample points (only at ledge endpoints).
List<double> _dropSamples(double min, double max) {
  final samples = <double>[min, max];
  return _dedupeSamples(samples);
}

/// Removes duplicate samples within [eps] tolerance.
List<double> _dedupeSamples(
  List<double> samples, {
  double eps = navGeomEps,
}) {
  samples.sort();
  final deduped = <double>[];
  for (final s in samples) {
    if (deduped.isEmpty || (s - deduped.last).abs() > eps) {
      deduped.add(s);
    }
  }
  return deduped;
}

/// Finds the first (highest) surface directly below a point.
///
/// **Parameters**:
/// - [x]: Horizontal position to check.
/// - [fromY]: Starting Y (surfaces must be below this).
/// - [halfWidth]: Agent half-width for standability check.
///
/// **Returns**: Surface index, or `null` if no surface below.
int? _findFirstSurfaceBelow(
  List<WalkSurface> surfaces,
  double x,
  double fromY,
  double halfWidth,
) {
  int? bestIndex;
  double? bestY;

  for (var i = 0; i < surfaces.length; i += 1) {
    final s = surfaces[i];
    // Must be below starting point.
    if (s.yTop <= fromY) continue;
    // Must be standable at this X.
    final minX = s.xMin + halfWidth;
    final maxX = s.xMax - halfWidth;
    if (minX > maxX) continue;
    if (x < minX || x > maxX) continue;

    // Prefer highest surface (lowest yTop).
    if (bestY == null || s.yTop < bestY) {
      bestY = s.yTop;
      bestIndex = i;
    } else if ((s.yTop - bestY).abs() < navTieEps) {
      // Tie-break by ID for determinism.
      if (s.id < surfaces[bestIndex!].id) {
        bestIndex = i;
      }
    }
  }

  return bestIndex;
}

/// Clamps [v] to the range [min, max].
double _clamp(double v, double min, double max) {
  if (v < min) return min;
  if (v > max) return max;
  return v;
}


===== FILE: lib/core/navigation/surface_navigator.dart =====
import '../ecs/stores/enemies/surface_nav_state_store.dart';
import 'types/nav_tolerances.dart';
import 'types/surface_graph.dart';
import 'types/surface_id.dart';
import 'surface_pathfinder.dart';
import 'utils/surface_spatial_index.dart';

/// Output of [SurfaceNavigator.update] indicating desired movement.
class SurfaceNavIntent {
  const SurfaceNavIntent({
    required this.desiredX,
    required this.jumpNow,
    required this.hasPlan,
    this.commitMoveDirX = 0,
  });

  /// Target X position the locomotion controller should move toward.
  final double desiredX;

  /// If `true`, the entity should jump this frame.
  final bool jumpNow;

  /// If `true`, a valid path exists (even if currently executing an edge).
  final bool hasPlan;

  /// Movement commit direction while approaching/executing an edge.
  ///
  /// When non-zero (-1 or +1), the locomotion controller should keep moving in
  /// this direction even if it would normally stop near `desiredX`, and it
  /// should not reverse direction due to tiny `desiredX` overshoots.
  ///
  /// This is primarily used to ensure drop edges actually leave the takeoff
  /// surface (walk past the ledge) instead of stopping "close enough".
  final int commitMoveDirX;
}

/// Runtime navigation controller for surface-graph-based AI movement.
///
/// **Responsibilities**:
/// 1. Track which surface the entity and target are standing on.
/// 2. Request paths via [SurfacePathfinder] when surfaces change.
/// 3. Execute path edges (walk to takeoff, jump/drop, land on destination).
/// 4. Return [SurfaceNavIntent] each tick for the locomotion controller.
///
/// **State Storage**:
/// Uses [SurfaceNavStateStore] (external SOA store) so multiple entities can
/// share a single [SurfaceNavigator] instance.
///
/// **Usage**:
/// ```dart
/// final intent = navigator.update(
///   navStore: store, navIndex: idx,
///   graph: graph, spatialIndex: index,
///   graphVersion: version,
///   entityX: e.x, entityBottomY: e.bottom, entityHalfWidth: e.hw,
///   entityGrounded: e.grounded,
///   targetX: t.x, targetBottomY: t.bottom, targetHalfWidth: t.hw,
///   targetGrounded: t.grounded,
/// );
/// // Use intent.desiredX, intent.jumpNow, intent.commitMoveDirX
/// ```
class SurfaceNavigator {
  SurfaceNavigator({
    required this.pathfinder,
    this.repathCooldownTicks = 30,
    this.surfaceEps = navSpatialEps,
    this.takeoffEps = 2.0,
  });

  /// Pathfinder used for A* queries.
  final SurfacePathfinder pathfinder;

  /// Minimum ticks between path recalculations (prevents thrashing).
  final int repathCooldownTicks;

  /// Vertical tolerance for surface detection (pixels).
  final double surfaceEps;

  /// Horizontal tolerance for reaching takeoff point (pixels).
  final double takeoffEps;

  /// Reusable buffer for spatial index queries.
  final List<int> _candidateBuffer = <int>[];

  /// Updates navigation state and returns movement intent for one entity.
  ///
  /// **Flow**:
  /// 1. Locate current and target surfaces via spatial index.
  /// 2. Invalidate path if graph version changed.
  /// 3. Repath if cooldown expired and surfaces are known.
  /// 4. If same surface, return direct movement to target.
  /// 5. Otherwise, execute next edge in path (approach → jump/drop → land).
  SurfaceNavIntent update({
    required SurfaceNavStateStore navStore,
    required int navIndex,
    required SurfaceGraph graph,
    required SurfaceSpatialIndex spatialIndex,
    required int graphVersion,
    required double entityX,
    required double entityBottomY,
    required double entityHalfWidth,
    required bool entityGrounded,
    required double targetX,
    required double targetBottomY,
    required double targetHalfWidth,
    required bool targetGrounded,
  }) {
    final prevCurrentId = navStore.currentSurfaceId[navIndex];
    final prevTargetId = navStore.targetSurfaceId[navIndex];

    // -------------------------------------------------------------------------
    // Step 1: Locate surfaces.
    // -------------------------------------------------------------------------
    var currentSurfaceId = prevCurrentId;
    if (entityGrounded) {
      final currentIndex = _locateSurfaceIndex(
        graph,
        spatialIndex,
        _candidateBuffer,
        entityX,
        entityBottomY,
        entityHalfWidth,
        surfaceEps,
      );
      currentSurfaceId = currentIndex == null
          ? surfaceIdUnknown
          : graph.surfaces[currentIndex].id;
    }

    var targetSurfaceId = prevTargetId;
    if (targetGrounded) {
      final targetIndex = _locateSurfaceIndex(
        graph,
        spatialIndex,
        _candidateBuffer,
        targetX,
        targetBottomY,
        targetHalfWidth,
        surfaceEps,
      );
      targetSurfaceId = targetIndex == null
          ? surfaceIdUnknown
          : graph.surfaces[targetIndex].id;
    }

    // -------------------------------------------------------------------------
    // Step 2: Invalidate path on graph rebuild.
    // -------------------------------------------------------------------------
    if (navStore.graphVersion[navIndex] != graphVersion) {
      navStore.graphVersion[navIndex] = graphVersion;
      navStore.pathEdges[navIndex].clear();
      navStore.pathCursor[navIndex] = 0;
      navStore.activeEdgeIndex[navIndex] = -1;
      navStore.repathTicksLeft[navIndex] = 0;
    }

    navStore.currentSurfaceId[navIndex] = currentSurfaceId;
    navStore.targetSurfaceId[navIndex] = targetSurfaceId;

    // Decrement repath cooldown.
    if (navStore.repathTicksLeft[navIndex] > 0) {
      navStore.repathTicksLeft[navIndex] -= 1;
    }

    final plan = navStore.pathEdges[navIndex];
    final surfaceChanged =
        currentSurfaceId != prevCurrentId || targetSurfaceId != prevTargetId;

    // Reset cooldown if either surface changed (allows immediate repath).
    if (surfaceChanged) {
      navStore.repathTicksLeft[navIndex] = 0;
    }

    // -------------------------------------------------------------------------
    // Step 3: Repath if needed.
    // -------------------------------------------------------------------------
    if (entityGrounded &&
        navStore.repathTicksLeft[navIndex] == 0 &&
        currentSurfaceId != surfaceIdUnknown &&
        targetSurfaceId != surfaceIdUnknown) {
      final startIndex = graph.indexOfSurfaceId(currentSurfaceId);
      final goalIndex = graph.indexOfSurfaceId(targetSurfaceId);
      if (startIndex != null && goalIndex != null) {
        final found = pathfinder.findPath(
          graph,
          startIndex: startIndex,
          goalIndex: goalIndex,
          outEdges: plan,
          startX: entityX,
          goalX: targetX,
        );
        navStore.pathCursor[navIndex] = 0;
        navStore.activeEdgeIndex[navIndex] = -1;
        if (!found) {
          plan.clear();
        }
      }
      navStore.repathTicksLeft[navIndex] = repathCooldownTicks;
    }

    // -------------------------------------------------------------------------
    // Step 4: Same-surface shortcut.
    // -------------------------------------------------------------------------
    if (currentSurfaceId != surfaceIdUnknown &&
        currentSurfaceId == targetSurfaceId) {
      plan.clear();
      navStore.pathCursor[navIndex] = 0;
      navStore.activeEdgeIndex[navIndex] = -1;
      return SurfaceNavIntent(
        desiredX: targetX,
        jumpNow: false,
        hasPlan: false,
      );
    }

    // -------------------------------------------------------------------------
    // Step 5: Execute path edges.
    // -------------------------------------------------------------------------
    final cursor = navStore.pathCursor[navIndex];
    if (plan.isEmpty || cursor >= plan.length) {
      navStore.activeEdgeIndex[navIndex] = -1;
      return SurfaceNavIntent(
        desiredX: targetX,
        jumpNow: false,
        hasPlan: false,
      );
    }

    final edgeIndex = plan[cursor];
    final edge = graph.edges[edgeIndex];

    // --- Executing an edge (mid-flight or post-takeoff) ---
    if (navStore.activeEdgeIndex[navIndex] >= 0) {
      // Check if we've landed on the destination surface.
      if (entityGrounded &&
          currentSurfaceId != surfaceIdUnknown &&
          currentSurfaceId == graph.surfaces[edge.to].id) {
        // Edge complete—advance cursor.
        navStore.activeEdgeIndex[navIndex] = -1;
        navStore.pathCursor[navIndex] = cursor + 1;
        return SurfaceNavIntent(
          desiredX: targetX,
          jumpNow: false,
          hasPlan: true,
        );
      }

      // Drop edge: keep walking toward ledge until we fall off.
      if (edge.kind == SurfaceEdgeKind.drop && entityGrounded) {
        return SurfaceNavIntent(
          desiredX: edge.takeoffX,
          jumpNow: false,
          hasPlan: true,
          commitMoveDirX: _edgeCommitDirX(edge),
        );
      }

      // Jump edge in-flight: aim for landing point.
      return SurfaceNavIntent(
        desiredX: edge.landingX,
        jumpNow: false,
        hasPlan: true,
      );
    }

    // --- Approaching takeoff point ---
    // For jump edges with commitMoveDirX, the entity may overshoot the exact
    // takeoff point at high speeds. Check if the entity is at OR past the
    // takeoff point in the direction of travel.
    final dir = _edgeCommitDirX(edge);
    final closeEnough = edge.kind == SurfaceEdgeKind.jump && dir != 0
        ? (dir > 0 ? entityX >= edge.takeoffX - takeoffEps : entityX <= edge.takeoffX + takeoffEps)
        : (entityX - edge.takeoffX).abs() <= takeoffEps;
    if (entityGrounded && closeEnough) {
      // Initiate edge execution.
      navStore.activeEdgeIndex[navIndex] = edgeIndex;

      final jumpNow = edge.kind == SurfaceEdgeKind.jump;
      return SurfaceNavIntent(
        desiredX:
            edge.kind == SurfaceEdgeKind.drop ? edge.takeoffX : edge.landingX,
        jumpNow: jumpNow,
        hasPlan: true,
        commitMoveDirX: _edgeCommitDirX(edge),
      );
    }

    // Walk toward takeoff point.
    // For jump edges, commit direction keeps the entity moving at full speed
    // through the takeoff instead of decelerating as it approaches.
    return SurfaceNavIntent(
      desiredX: edge.takeoffX,
      jumpNow: false,
      hasPlan: true,
      commitMoveDirX:
          edge.kind == SurfaceEdgeKind.jump ? _edgeCommitDirX(edge) : 0,
    );
  }
}

/// Determines commit direction for edge traversal.
///
/// Returns the direction (+1 or -1) the entity should commit to when
/// approaching or executing an edge. This prevents the locomotion controller
/// from decelerating near the takeoff point, enabling smooth running jumps.
int _edgeCommitDirX(SurfaceEdge edge) {
  if (edge.takeoffX < edge.landingX) return 1;
  if (edge.takeoffX > edge.landingX) return -1;
  // Fallback: exact tie (rare), don't commit.
  return 0;
}

/// Finds the best surface index for a given entity footprint.
///
/// **Algorithm**:
/// 1. Query spatial index for candidate surfaces in AABB.
/// 2. Filter by horizontal overlap and vertical proximity.
/// 3. Prefer lowest yTop (highest platform). Tie-break by surface ID.
///
/// **Returns**: Surface index, or `null` if not standing on any surface.
int? _locateSurfaceIndex(
  SurfaceGraph graph,
  SurfaceSpatialIndex spatialIndex,
  List<int> candidates,
  double x,
  double bottomY,
  double halfWidth,
  double eps,
) {
  final minX = x - halfWidth;
  final maxX = x + halfWidth;
  final minY = bottomY - eps;
  final maxY = bottomY + eps;

  spatialIndex.queryAabb(
    minX: minX,
    minY: minY,
    maxX: maxX,
    maxY: maxY,
    outSurfaceIndices: candidates,
  );

  int? bestIndex;
  double? bestY;
  for (final i in candidates) {
    final s = graph.surfaces[i];
    // Skip if no horizontal overlap.
    if (s.xMin > maxX || s.xMax < minX) continue;
    // Skip if too far vertically.
    if ((s.yTop - bottomY).abs() > eps) continue;

    // Prefer higher platform (lower yTop in screen coords).
    if (bestY == null || s.yTop < bestY) {
      bestY = s.yTop;
      bestIndex = i;
    } else if ((s.yTop - bestY).abs() <= eps) {
      // Tie-break by ID for determinism.
      if (s.id < graph.surfaces[bestIndex!].id) {
        bestIndex = i;
      }
    }
  }

  return bestIndex;
}


===== FILE: lib/core/navigation/surface_pathfinder.dart =====
import 'types/surface_graph.dart';
import 'types/nav_tolerances.dart';

/// A* pathfinder for surface-based navigation graphs.
///
/// **Algorithm**: Standard A* with:
/// - Admissible heuristic: straight-line horizontal distance / run speed.
/// - Edge costs: transition cost + run distance to takeoff + landing adjustment.
/// - Tie-breaking: lower g-score, then surface ID for determinism.
///
/// **Optimizations**:
/// - Generation-stamp pattern avoids clearing arrays between searches.
/// - Reusable working lists grow once, persist across queries.
/// - Linear open-list scan (adequate for small graphs; swap to binary heap
///   if graph size grows significantly).
///
/// **Usage**:
/// ```dart
/// final pathfinder = SurfacePathfinder(maxExpandedNodes: 500, runSpeedX: 200);
/// final edges = <int>[];
/// if (pathfinder.findPath(graph, startIndex: s, goalIndex: g, outEdges: edges)) {
///   // edges contains edge indices from start to goal.
/// }
/// ```
class SurfacePathfinder {
  SurfacePathfinder({
    required this.maxExpandedNodes,
    required this.runSpeedX,
    this.edgePenaltySeconds = 0.0,
  })  : assert(maxExpandedNodes > 0),
        assert(runSpeedX > 0),
        assert(edgePenaltySeconds >= 0.0);

  /// Maximum nodes to expand before giving up (prevents runaway searches).
  final int maxExpandedNodes;

  /// Horizontal run speed (pixels/second) for cost calculations.
  final double runSpeedX;

  /// Flat penalty added to every edge (discourages excessive transitions).
  final double edgePenaltySeconds;

  // ---------------------------------------------------------------------------
  // Working arrays (reused across searches via generation stamps).
  // ---------------------------------------------------------------------------

  /// Cost from start to each node (g-score).
  final List<double> _gScore = <double>[];

  /// Estimated total cost through each node (f = g + h).
  final List<double> _fScore = <double>[];

  /// Edge index used to reach each node (-1 = start or unvisited).
  final List<int> _cameFromEdge = <int>[];

  /// Predecessor node index (-1 = start or unvisited).
  final List<int> _cameFromNode = <int>[];

  /// Open set (nodes pending expansion).
  final List<int> _open = <int>[];

  /// 1 if node is in open set this search, 0 otherwise.
  final List<int> _openStamp = <int>[];

  /// Scratch space for path reconstruction.
  final List<int> _reconstruct = <int>[];

  /// Generation stamp per node (matches [_searchGeneration] if valid).
  final List<int> _nodeGenerations = <int>[];

  /// Incremented each search to invalidate stale node data.
  int _searchGeneration = 0;

  /// Finds a path from [startIndex] to [goalIndex] in [graph].
  ///
  /// **Parameters**:
  /// - [startIndex], [goalIndex]: Surface indices in [graph.surfaces].
  /// - [outEdges]: Receives ordered edge indices from start to goal.
  /// - [startX], [goalX]: Optional precise X positions for cost accuracy.
  ///
  /// **Returns**: `true` if a path was found, `false` otherwise.
  bool findPath(
    SurfaceGraph graph, {
    required int startIndex,
    required int goalIndex,
    required List<int> outEdges,
    double? startX,
    double? goalX,
  }) {
    outEdges.clear();
    if (startIndex == goalIndex) return true;

    _ensureSize(graph.surfaces.length);
    _searchGeneration += 1;

    // Initialize start node.
    _touch(startIndex);
    _open.clear();
    _open.add(startIndex);
    _openStamp[startIndex] = 1;
    _gScore[startIndex] = 0.0;
    _fScore[startIndex] = _heuristic(graph, startIndex, goalIndex);

    var expanded = 0;
    while (_open.isNotEmpty && expanded < maxExpandedNodes) {
      final current = _popBest(graph);
      if (current == goalIndex) {
        _reconstructPath(goalIndex, outEdges);
        return true;
      }

      expanded += 1;

      // Iterate outgoing edges (CSR format).
      final start = graph.edgeOffsets[current];
      final end = graph.edgeOffsets[current + 1];
      for (var ei = start; ei < end; ei += 1) {
        final edge = graph.edges[ei];
        final neighbor = edge.to;
        _touch(neighbor);

        // Total edge cost: base + run-to-takeoff + landing adjustment + penalty.
        final edgeCost = edge.cost +
            _runCost(
              graph,
              current,
              edge,
              startIndex: startIndex,
              startX: startX,
            ) +
            _goalLandingCost(
              edge,
              neighbor: neighbor,
              goalIndex: goalIndex,
              goalX: goalX,
            ) +
            edgePenaltySeconds;

        final tentative = _gScore[current] + edgeCost;
        if (tentative >= _gScore[neighbor]) continue;

        // Better path found—update neighbor.
        _cameFromEdge[neighbor] = ei;
        _cameFromNode[neighbor] = current;
        _gScore[neighbor] = tentative;
        _fScore[neighbor] = tentative + _heuristic(graph, neighbor, goalIndex);

        // Add to open set if not already present.
        if (_openStamp[neighbor] != 1) {
          _open.add(neighbor);
          _openStamp[neighbor] = 1;
        }
      }
    }

    return false; // No path found within expansion limit.
  }

  /// Admissible heuristic: horizontal distance / run speed.
  ///
  /// Ignores vertical distance (platforms can be reached by jumps/falls
  /// with minimal time penalty relative to horizontal travel).
  double _heuristic(SurfaceGraph graph, int from, int goal) {
    final dx =
        (graph.surfaces[goal].centerX - graph.surfaces[from].centerX).abs();
    return dx / runSpeedX;
  }

  /// Cost to run from current position to edge takeoff point.
  double _runCost(
    SurfaceGraph graph,
    int fromIndex,
    SurfaceEdge edge, {
    required int startIndex,
    required double? startX,
  }) {
    final fromSurface = graph.surfaces[fromIndex];
    // Use exact position for start node, otherwise surface center.
    final originX =
        (fromIndex == startIndex && startX != null) ? startX : fromSurface.centerX;
    final dx = (edge.takeoffX - originX).abs();
    return dx / runSpeedX;
  }

  /// Additional cost for landing distance to goal (only on final edge).
  double _goalLandingCost(
    SurfaceEdge edge, {
    required int neighbor,
    required int goalIndex,
    required double? goalX,
  }) {
    if (goalX == null) return 0.0;
    if (neighbor != goalIndex) return 0.0;
    final dx = (edge.landingX - goalX).abs();
    return dx / runSpeedX;
  }

  /// Extracts and removes the node with lowest f-score from [_open].
  ///
  /// Uses linear scan (O(n)) which is fine for small open sets.
  /// For larger graphs, consider a binary heap.
  int _popBest(SurfaceGraph graph) {
    var bestIndex = 0;
    var bestNode = _open[0];
    for (var i = 1; i < _open.length; i += 1) {
      final node = _open[i];
      if (_isBetter(graph, node, bestNode)) {
        bestIndex = i;
        bestNode = node;
      }
    }

    // Swap-remove: replace extracted element with last, then pop.
    final last = _open.removeLast();
    if (bestIndex < _open.length) {
      _open[bestIndex] = last;
    }
    _openStamp[bestNode] = 0;
    return bestNode;
  }

  /// Compares two nodes for priority (lower f-score wins).
  ///
  /// Tie-breaking order:
  /// 1. Lower f-score.
  /// 2. Lower g-score (prefer nodes closer to start).
  /// 3. Lower surface ID (determinism).
  bool _isBetter(SurfaceGraph graph, int a, int b) {
    final fa = _fScore[a];
    final fb = _fScore[b];
    if (fa < fb - navTieEps) return true;
    if (fa > fb + navTieEps) return false;
    final ga = _gScore[a];
    final gb = _gScore[b];
    if (ga < gb - navTieEps) return true;
    if (ga > gb + navTieEps) return false;
    return graph.surfaces[a].id < graph.surfaces[b].id;
  }

  /// Reconstructs path by walking [_cameFromEdge] back to start.
  ///
  /// Edges are collected in reverse order, then reversed into [outEdges].
  void _reconstructPath(int goalIndex, List<int> outEdges) {
    _reconstruct.clear();
    var current = goalIndex;
    while (_cameFromEdge[current] != -1) {
      _reconstruct.add(_cameFromEdge[current]);
      current = _cameFromNode[current];
    }
    // Reverse into output.
    for (var i = _reconstruct.length - 1; i >= 0; i -= 1) {
      outEdges.add(_reconstruct[i]);
    }
  }

  /// Grows working arrays to accommodate [count] nodes.
  void _ensureSize(int count) {
    while (_gScore.length < count) {
      _gScore.add(double.infinity);
      _fScore.add(double.infinity);
      _cameFromEdge.add(-1);
      _cameFromNode.add(-1);
      _openStamp.add(0);
      _nodeGenerations.add(0);
    }
  }

  /// Lazily initializes node data for the current search generation.
  ///
  /// Avoids O(n) clearing of all arrays between searches.
  void _touch(int index) {
    if (_nodeGenerations[index] != _searchGeneration) {
      _gScore[index] = double.infinity;
      _fScore[index] = double.infinity;
      _cameFromEdge[index] = -1;
      _cameFromNode[index] = -1;
      _openStamp[index] = 0;
      _nodeGenerations[index] = _searchGeneration;
    }
  }
}


===== FILE: lib/core/navigation/types/nav_tolerances.dart =====
/// Navigation-wide numeric tolerances.
///
/// **Design**:
/// - Currently uses a single epsilon ([navEps]) for simplicity.
/// - Semantic aliases exist to make callsites self-documenting.
/// - If tuning is needed later, individual values can diverge without code changes.
///
/// **Warning**: Changing these values affects pathfinding determinism.
library;

/// Default epsilon used across navigation (1 micron in world units).
const double navEps = 1e-6;

/// Epsilon for geometric equality checks (e.g., "are these two points the same?").
const double navGeomEps = navEps;

/// Epsilon for spatial queries (surface containment, overlap thickness).
const double navSpatialEps = navEps;

/// Epsilon for deterministic tie-breaking in A* (f-cost and g-cost comparisons).
const double navTieEps = navEps;


===== FILE: lib/core/navigation/types/surface_graph.dart =====
import 'walk_surface.dart';

/// The type of transition between two surfaces.
enum SurfaceEdgeKind {
  /// An active jump (requires jump input).
  jump,
  
  /// A passive drop (walking off an edge).
  drop,
}

/// A directed edge in the navigation graph.
///
/// Represents a traversable connection from one [WalkSurface] to another.
class SurfaceEdge {
  const SurfaceEdge({
    required this.to,
    required this.kind,
    required this.takeoffX,
    required this.landingX,
    required this.travelTicks,
    required this.cost,
  });

  /// Index of the destination surface in [SurfaceGraph.surfaces].
  final int to;
  
  /// Type of traversal (Jump or Drop).
  final SurfaceEdgeKind kind;
  
  /// World X coordinate where the entity leaves the source surface.
  final double takeoffX;
  
  /// World X coordinate where the entity lands on the destination surface.
  final double landingX;
  
  /// Estimated travel time in simulation ticks.
  final int travelTicks;
  
  /// Pathfinding cost (typically based on time or distance).
  final double cost;
}

/// An immutable navigation graph built from [WalkSurface]s.
///
/// **Structure**:
/// - **Nodes**: [surfaces] (indexed 0..N-1).
/// - **Edges**: Stored in [edges], with [edgeOffsets] providing CSR-style indexing.
///
/// **CSR (Compressed Sparse Row) Format**:
/// - `edgeOffsets[i]` is the start index in [edges] for surface `i`.
/// - `edgeOffsets[i+1]` is the end index (exclusive).
/// - This allows O(1) lookup of outgoing edges for any surface.
class SurfaceGraph {
  SurfaceGraph({
    required List<WalkSurface> surfaces,
    required List<int> edgeOffsets,
    required List<SurfaceEdge> edges,
    required Map<int, int> indexById,
  })  : surfaces = List<WalkSurface>.unmodifiable(surfaces),
        edgeOffsets = List<int>.unmodifiable(edgeOffsets),
        edges = List<SurfaceEdge>.unmodifiable(edges),
        _indexById = Map<int, int>.unmodifiable(indexById);

  /// All walkable surfaces (graph nodes).
  final List<WalkSurface> surfaces;
  
  /// CSR row pointers into [edges]. Length = surfaces.length + 1.
  final List<int> edgeOffsets;
  
  /// All edges (graph arcs), grouped by source surface.
  final List<SurfaceEdge> edges;
  
  /// Lookup: Surface ID -> index in [surfaces].
  final Map<int, int> _indexById;

  /// Returns the index of a surface by its packed [id], or null if not found.
  int? indexOfSurfaceId(int id) => _indexById[id];

  /// Yields all outgoing edges from [surfaceIndex].
  Iterable<SurfaceEdge> edgesFor(int surfaceIndex) sync* {
    final start = edgeOffsets[surfaceIndex];
    final end = edgeOffsets[surfaceIndex + 1];
    for (var i = start; i < end; i += 1) {
      yield edges[i];
    }
  }
}



===== FILE: lib/core/navigation/types/surface_id.dart =====
/// Surface ID Packing Utilities.
///
/// Surfaces are identified by a 64-bit integer that encodes:
/// - **Chunk Index** (32 bits, high): Which level chunk the surface belongs to.
/// - **Local Solid Index** (30 bits): Index of the solid tile within the chunk.
/// - **Surface Kind** (2 bits, low): Top/Side/etc. (Currently only Top is used).
///
/// This encoding allows:
/// - Stable, deterministic IDs across save/load.
/// - Efficient Map/Set lookups.
/// - Lexicographic ordering by chunk then local index.
library;

/// The "Top" surface kind (entities stand on top of the solid).
const int surfaceKindTop = 0;

/// Sentinel value for "no surface" / invalid.
const int surfaceIdUnknown = -1;

/// Packs a surface identity into a stable, comparable 64-bit key.
///
/// **Bit Layout**:
/// ```
/// [63..32] chunkIndex (XOR'd with 0x80000000 to handle signed comparison)
/// [31..2]  localSolidIndex
/// [1..0]   surfaceKind
/// ```
int packSurfaceId({
  required int chunkIndex,
  required int localSolidIndex,
  int surfaceKind = surfaceKindTop,
}) {
  if (localSolidIndex < 0) {
    throw ArgumentError.value(
      localSolidIndex,
      'localSolidIndex',
      'must be >= 0',
    );
  }
  // XOR with sign bit to make signed chunkIndex sort correctly as unsigned.
  final chunk = (chunkIndex ^ 0x80000000) & 0xFFFFFFFF;
  // Pack localSolidIndex and surfaceKind into lower 32 bits.
  final local = ((localSolidIndex << 2) | (surfaceKind & 0x3)) & 0xFFFFFFFF;
  return (chunk << 32) | local;
}

/// Extracts the chunk index from a packed [surfaceId].
int unpackChunkIndex(int surfaceId) {
  final chunk = (surfaceId >> 32) & 0xFFFFFFFF;
  return (chunk ^ 0x80000000);
}

/// Extracts the local solid index from a packed [surfaceId].
int unpackLocalSolidIndex(int surfaceId) {
  final local = surfaceId & 0xFFFFFFFF;
  return local >> 2;
}

/// Extracts the surface kind (Top/Side) from a packed [surfaceId].
int unpackSurfaceKind(int surfaceId) {
  return surfaceId & 0x3;
}


===== FILE: lib/core/navigation/types/walk_surface.dart =====
/// Represents a horizontal walkable platform segment in world space.
///
/// **Geometry**:
/// - A 1D segment along the X-axis at a fixed Y height ([yTop]).
/// - Defined by [[xMin], [xMax]] (inclusive bounds).
///
/// **Usage**:
/// - Used by the navigation system to represent ground/platforms.
/// - Entities can stand on this surface if their X is within [xMin, xMax].
class WalkSurface {
  const WalkSurface({
    required this.id,
    required this.xMin,
    required this.xMax,
    required this.yTop,
  }) : assert(xMax >= xMin);

  /// Unique identifier (packed via [packSurfaceId]).
  final int id;

  /// Left edge of the walkable segment (inclusive).
  final double xMin;
  
  /// Right edge of the walkable segment (inclusive).
  final double xMax;

  /// World-space Y coordinate of the top surface (where entities stand).
  final double yTop;

  /// Horizontal center of the surface.
  double get centerX => (xMin + xMax) * 0.5;
  
  /// Width of the walkable segment.
  double get width => xMax - xMin;
}



===== FILE: lib/core/navigation/utils/jump_template.dart =====
import '../types/nav_tolerances.dart';

/// Physics parameters for simulating a jump arc.
///
/// Used to precompute reachability templates for AI pathfinding.
class JumpProfile {
  const JumpProfile({
    required this.jumpSpeed,
    required this.gravityY,
    required this.maxAirTicks,
    required this.airSpeedX,
    required this.dtSeconds,
    required this.agentHalfWidth,
  })  : assert(maxAirTicks > 0),
        assert(dtSeconds > 0);

  /// Instantaneous vertical speed at jump start (negative = upward).
  final double jumpSpeed;

  /// Gravity acceleration (positive = downward, e.g., 980 for ~10m/s²).
  final double gravityY;

  /// Fixed timestep in seconds (e.g., 1/60 for 60Hz).
  final double dtSeconds;

  /// Maximum ticks to simulate (limits arc length for performance).
  final int maxAirTicks;

  /// Assumed constant horizontal speed while airborne.
  final double airSpeedX;

  /// Agent's collider half-width (for landing overlap calculations).
  final double agentHalfWidth;
}

/// A single sample point along a precomputed jump arc.
class JumpSample {
  const JumpSample({
    required this.tick,
    required this.prevY,
    required this.y,
    required this.velY,
    required this.maxDx,
  });

  /// Tick number (1-based, 0 = takeoff).
  final int tick;

  /// Y position at the end of the previous tick.
  final double prevY;

  /// Y position at the end of this tick.
  final double y;

  /// Vertical velocity at the end of this tick.
  final double velY;

  /// Maximum horizontal displacement reachable by this tick.
  final double maxDx;
}

/// Result of a successful landing query.
class JumpLanding {
  const JumpLanding({required this.tick, required this.maxDx});

  /// Tick at which landing occurs.
  final int tick;

  /// Maximum horizontal reach at landing time.
  final double maxDx;
}

/// Precomputed jump arc template for reachability queries.
///
/// **Usage**:
/// - Built once from a [JumpProfile] (at startup or when physics change).
/// - Queried during graph construction to find valid jump edges.
///
/// **Physics**:
/// - Uses semi-implicit Euler integration: `vel += g*dt`, then `pos += vel*dt`.
/// - Matches the runtime physics in [GravitySystem].
class JumpReachabilityTemplate {
  JumpReachabilityTemplate._({
    required this.profile,
    required this.samples,
    required this.minDy,
    required this.maxDy,
    required this.maxDx,
  });

  /// The physics profile used to build this template.
  final JumpProfile profile;

  /// Sampled arc positions (tick 1 to maxAirTicks).
  final List<JumpSample> samples;

  /// Lowest Y offset reached (negative = above origin).
  final double minDy;

  /// Highest Y offset reached (positive = below origin, after fall).
  final double maxDy;

  /// Maximum horizontal distance reachable.
  final double maxDx;

  /// Builds a reachability template by simulating [profile.maxAirTicks] of flight.
  factory JumpReachabilityTemplate.build(JumpProfile profile) {
    final samples = <JumpSample>[];

    var y = 0.0;
    var velY = -profile.jumpSpeed; // Negative = upward
    final dt = profile.dtSeconds;
    var minDy = 0.0;
    var maxDy = 0.0;
    var maxDxOverall = 0.0;

    for (var tick = 1; tick <= profile.maxAirTicks; tick += 1) {
      final prevY = y;
      
      // Semi-implicit Euler: update velocity first, then position.
      velY += profile.gravityY * dt;
      y += velY * dt;
      
      // Horizontal reach increases linearly with time.
      final maxDx = profile.airSpeedX * dt * tick;
      
      // Track bounding box.
      if (y < minDy) minDy = y;
      if (y > maxDy) maxDy = y;
      if (maxDx > maxDxOverall) maxDxOverall = maxDx;
      
      samples.add(
        JumpSample(
          tick: tick,
          prevY: prevY,
          y: y,
          velY: velY,
          maxDx: maxDx,
        ),
      );
    }

    return JumpReachabilityTemplate._(
      profile: profile,
      samples: List<JumpSample>.unmodifiable(samples),
      minDy: minDy,
      maxDy: maxDy,
      maxDx: maxDxOverall,
    );
  }

  /// Finds the earliest tick at which a jump can land at vertical offset [dy].
  ///
  /// **Parameters**:
  /// - [dy]: Target vertical offset (positive = below takeoff, negative = above).
  /// - [dxMin], [dxMax]: Required horizontal range for a valid landing.
  ///
  /// **Returns**: [JumpLanding] if reachable, null otherwise.
  ///
  /// **Logic**:
  /// 1. Skip ascending samples (velY < 0).
  /// 2. Check if [dy] is crossed between prevY and y.
  /// 3. Check if horizontal range overlaps [dxMin, dxMax].
  JumpLanding? findFirstLanding({
    required double dy,
    required double dxMin,
    required double dxMax,
    double eps = navGeomEps,
  }) {
    if (dxMin > dxMax) return null;

    for (final sample in samples) {
      // Only consider descending phase.
      if (sample.velY < 0) continue;
      
      // Check vertical crossing: prevY <= dy <= y (with tolerance).
      final crosses = (sample.prevY <= dy + eps) && (sample.y >= dy - eps);
      if (!crosses) continue;

      // Check horizontal reachability.
      final maxDx = sample.maxDx;
      if (dxMin > maxDx + eps) continue;  // Target too far right.
      if (dxMax < -maxDx - eps) continue; // Target too far left.
      
      return JumpLanding(tick: sample.tick, maxDx: maxDx);
    }

    return null;
  }
}

/// Estimates the number of ticks to fall a given vertical distance.
///
/// Used for "drop" edges (walking off a ledge without jumping).
///
/// **Parameters**:
/// - [dy]: Distance to fall (positive = downward).
/// - [gravityY]: Gravity acceleration.
/// - [dtSeconds]: Timestep.
/// - [maxTicks]: Upper bound to prevent infinite loops.
int estimateFallTicks({
  required double dy,
  required double gravityY,
  required double dtSeconds,
  required int maxTicks,
}) {
  if (dy <= 0) return 0;
  
  var y = 0.0;
  var velY = 0.0;
  
  for (var tick = 1; tick <= maxTicks; tick += 1) {
    velY += gravityY * dtSeconds;
    y += velY * dtSeconds;
    if (y >= dy) return tick;
  }
  
  return maxTicks;
}


===== FILE: lib/core/navigation/utils/surface_spatial_index.dart =====
import '../../ecs/spatial/grid_index_2d.dart';
import '../types/nav_tolerances.dart';
import '../types/walk_surface.dart';

/// Spatial hash grid for fast AABB queries against [WalkSurface]s.
///
/// **Purpose**:
/// - Given an AABB (e.g., entity bounds), quickly find all surfaces that might overlap.
/// - Avoids O(N) linear scans over all surfaces.
///
/// **Design**:
/// - Uses a uniform grid (via [GridIndex2D]) to bucket surfaces by cell.
/// - Surfaces spanning multiple cells are inserted into each overlapping cell.
/// - A stamp-based deduplication prevents returning the same surface twice per query.
///
/// **Lifecycle**:
/// - Call [rebuild] when static geometry changes (e.g., new chunk loaded).
/// - Call [queryAabb] during gameplay (e.g., to find surfaces under an entity).
class SurfaceSpatialIndex {
  SurfaceSpatialIndex({
    required GridIndex2D index,
    this.surfaceThickness = navSpatialEps,
  }) : _index = index;

  /// The underlying grid coordinate system.
  final GridIndex2D _index;
  
  /// Vertical thickness added above/below each surface for overlap tests.
  final double surfaceThickness;

  /// Cell key -> list of surface indices in that cell.
  final Map<int, List<int>> _buckets = <int, List<int>>{};
  
  /// Keys of all currently populated buckets (for fast clearing).
  final List<int> _activeKeys = <int>[];
  
  /// Pool of reusable bucket lists (reduces GC pressure).
  final List<List<int>> _bucketPool = <List<int>>[];

  /// Stamp-based deduplication: `_seenStampBySurface[i] == _stamp` means already seen.
  final List<int> _seenStampBySurface = <int>[];
  int _stamp = 0;
  int _surfaceCount = 0;

  /// Rebuilds the spatial index from a new set of surfaces.
  ///
  /// **Performance**: O(S * C) where S = surfaces, C = avg cells per surface.
  void rebuild(List<WalkSurface> surfaces) {
    // Return all active buckets to the pool.
    for (var i = 0; i < _activeKeys.length; i += 1) {
      final key = _activeKeys[i];
      final bucket = _buckets.remove(key);
      if (bucket == null) continue;
      bucket.clear();
      _bucketPool.add(bucket);
    }
    _activeKeys.clear();

    _surfaceCount = surfaces.length;
    if (surfaces.isEmpty) return;

    // Insert each surface into all cells it overlaps.
    for (var si = 0; si < surfaces.length; si += 1) {
      final surface = surfaces[si];
      
      // Surface AABB: horizontal span + thin vertical slab.
      final minX = surface.xMin;
      final maxX = surface.xMax;
      final minY = surface.yTop - surfaceThickness;
      final maxY = surface.yTop + surfaceThickness;

      // Convert to cell coordinates.
      final minCx = _index.worldToCellX(minX);
      final maxCx = _index.worldToCellX(maxX);
      final minCy = _index.worldToCellY(minY);
      final maxCy = _index.worldToCellY(maxY);

      // Insert surface index into each overlapping cell.
      for (var cellY = minCy; cellY <= maxCy; cellY += 1) {
        for (var cellX = minCx; cellX <= maxCx; cellX += 1) {
          final key = _index.cellKey(cellX, cellY);
          var bucket = _buckets[key];
          if (bucket == null) {
            // Reuse pooled bucket or allocate new.
            bucket = _bucketPool.isNotEmpty ? _bucketPool.removeLast() : <int>[];
            _buckets[key] = bucket;
            _activeKeys.add(key);
          }
          bucket.add(si);
        }
      }
    }
  }

  /// Finds all surfaces overlapping the given AABB.
  ///
  /// Results are written to [outSurfaceIndices] (cleared first).
  /// Each surface index appears at most once (deduplicated via stamp).
  ///
  /// **Performance**: O(C * B) where C = cells in query, B = avg bucket size.
  void queryAabb({
    required double minX,
    required double minY,
    required double maxX,
    required double maxY,
    required List<int> outSurfaceIndices,
  }) {
    outSurfaceIndices.clear();
    if (_activeKeys.isEmpty) return;

    // Advance the deduplication stamp.
    _stamp += 1;
    if (_stamp == 0x7FFFFFFF) {
      // Overflow protection: reset all stamps.
      for (var i = 0; i < _seenStampBySurface.length; i += 1) {
        _seenStampBySurface[i] = 0;
      }
      _stamp = 1;
    }

    // Determine cell range for query AABB.
    final minCx = _index.worldToCellX(minX);
    final maxCx = _index.worldToCellX(maxX);
    final minCy = _index.worldToCellY(minY);
    final maxCy = _index.worldToCellY(maxY);

    // Ensure stamp array is large enough.
    if (_seenStampBySurface.length < _surfaceCount) {
      final missing = _surfaceCount - _seenStampBySurface.length;
      for (var i = 0; i < missing; i += 1) {
        _seenStampBySurface.add(0);
      }
    }

    // Iterate all cells in query range.
    for (var cellY = minCy; cellY <= maxCy; cellY += 1) {
      for (var cellX = minCx; cellX <= maxCx; cellX += 1) {
        final key = _index.cellKey(cellX, cellY);
        final bucket = _buckets[key];
        if (bucket == null || bucket.isEmpty) continue;

        // Add each unseen surface to results.
        for (var bi = 0; bi < bucket.length; bi += 1) {
          final surfaceIndex = bucket[bi];
          if (_seenStampBySurface[surfaceIndex] == _stamp) continue;
          _seenStampBySurface[surfaceIndex] = _stamp;
          outSurfaceIndices.add(surfaceIndex);
        }
      }
    }
  }
}


===== FILE: lib/core/navigation/utils/trajectory_predictor.dart =====
import '../types/surface_graph.dart';
import 'surface_spatial_index.dart';

/// Prediction result for where an airborne entity will land.
class LandingPrediction {
  const LandingPrediction({
    required this.x,
    required this.bottomY,
    required this.surfaceIndex,
    required this.ticksToLand,
  });

  /// Predicted X position at landing.
  final double x;

  /// Predicted bottom Y position at landing (on surface).
  final double bottomY;

  /// Index of the surface in [SurfaceGraph.surfaces] where landing occurs.
  final int surfaceIndex;

  /// Number of ticks until landing.
  final int ticksToLand;
}

/// Predicts where an airborne entity will land.
///
/// **Purpose**:
/// Used by ground enemy AI to anticipate where an airborne player will land,
/// enabling pathfinding toward the predicted landing spot instead of the
/// player's current (airborne) position.
///
/// **Algorithm**:
/// Simulates the entity's trajectory tick-by-tick using semi-implicit Euler
/// integration (matching [GravitySystem]), checking for surface intersections
/// at each step.
///
/// **Usage**:
/// ```dart
/// final predictor = TrajectoryPredictor(
///   gravityY: physics.gravityY,
///   dtSeconds: movement.dtSeconds,
///   maxTicks: 120,
/// );
///
/// final prediction = predictor.predictLanding(
///   startX: playerX,
///   startBottomY: playerBottomY,
///   velX: playerVelX,
///   velY: playerVelY,
///   graph: surfaceGraph,
///   spatialIndex: surfaceSpatialIndex,
///   entityHalfWidth: playerHalfX,
/// );
/// ```
class TrajectoryPredictor {
  const TrajectoryPredictor({
    required this.gravityY,
    required this.dtSeconds,
    required this.maxTicks,
  });

  /// Gravity acceleration (positive = downward).
  final double gravityY;

  /// Fixed timestep in seconds.
  final double dtSeconds;

  /// Maximum ticks to simulate before giving up.
  final int maxTicks;

  /// Predicts landing position for an airborne entity.
  ///
  /// **Parameters**:
  /// - [startX], [startBottomY]: Current position (bottom of collider).
  /// - [velX], [velY]: Current velocity.
  /// - [graph]: Surface graph for landing candidates.
  /// - [spatialIndex]: Spatial index for fast surface queries.
  /// - [entityHalfWidth]: Half-width of the entity collider.
  ///
  /// **Returns**: [LandingPrediction] if a valid landing is found, null otherwise.
  ///
  /// **Edge Cases**:
  /// - Returns null if entity is moving upward and never descends (shouldn't happen with gravity).
  /// - Returns null if no surface intersects the trajectory within [maxTicks].
  /// - Returns the FIRST valid landing (earliest tick) if multiple surfaces are crossed.
  LandingPrediction? predictLanding({
    required double startX,
    required double startBottomY,
    required double velX,
    required double velY,
    required SurfaceGraph graph,
    required SurfaceSpatialIndex spatialIndex,
    required double entityHalfWidth,
  }) {
    if (graph.surfaces.isEmpty) return null;

    var x = startX;
    var y = startBottomY;
    var vy = velY;
    final dt = dtSeconds;

    // Reusable buffer for spatial queries.
    final candidates = <int>[];

    for (var tick = 1; tick <= maxTicks; tick += 1) {
      final prevY = y;

      // Semi-implicit Euler (matches GravitySystem).
      vy += gravityY * dt;
      y += vy * dt;
      x += velX * dt;

      // Only check for landing when descending (vy > 0 means moving downward).
      if (vy <= 0) continue;

      // Check if we crossed any surface between prevY and y.
      final landing = _findLandingSurface(
        graph: graph,
        spatialIndex: spatialIndex,
        candidates: candidates,
        x: x,
        prevY: prevY,
        y: y,
        entityHalfWidth: entityHalfWidth,
        tick: tick,
      );

      if (landing != null) {
        return landing;
      }
    }

    return null;
  }

  /// Checks if the trajectory crossed a valid landing surface this tick.
  LandingPrediction? _findLandingSurface({
    required SurfaceGraph graph,
    required SurfaceSpatialIndex spatialIndex,
    required List<int> candidates,
    required double x,
    required double prevY,
    required double y,
    required double entityHalfWidth,
    required int tick,
  }) {
    // Query surfaces in the vertical band we just traversed.
    final minY = prevY < y ? prevY : y;
    final maxY = prevY > y ? prevY : y;

    spatialIndex.queryAabb(
      minX: x - entityHalfWidth,
      minY: minY,
      maxX: x + entityHalfWidth,
      maxY: maxY,
      outSurfaceIndices: candidates,
    );

    if (candidates.isEmpty) return null;

    // Find the highest surface (lowest yTop) that we crossed.
    // This handles cases where trajectory passes through multiple surfaces.
    int? bestIndex;
    double? bestYTop;

    for (final surfaceIndex in candidates) {
      final surface = graph.surfaces[surfaceIndex];

      // Check horizontal overlap: entity must fit on surface.
      final entityMinX = x - entityHalfWidth;
      final entityMaxX = x + entityHalfWidth;
      if (entityMinX > surface.xMax || entityMaxX < surface.xMin) continue;

      // Check vertical crossing: prevY was above (or at) surface, y is at or below.
      // We want surfaces where prevY <= yTop <= y (crossed from above).
      final yTop = surface.yTop;
      if (prevY > yTop) continue; // Started below surface, can't land on it.
      if (y < yTop) continue; // Ended above surface, haven't reached it yet.

      // Valid landing candidate. Prefer highest surface (lowest yTop).
      if (bestYTop == null || yTop < bestYTop) {
        bestYTop = yTop;
        bestIndex = surfaceIndex;
      }
    }

    if (bestIndex == null) return null;

    return LandingPrediction(
      x: x,
      bottomY: bestYTop!,
      surfaceIndex: bestIndex,
      ticksToLand: tick,
    );
  }
}


===== FILE: lib/core/players/player_archetype.dart =====
import '../ecs/stores/body_store.dart';
import '../ecs/stores/collider_aabb_store.dart';
import '../ecs/stores/combat/ammo_store.dart';
import '../ecs/stores/combat/creature_tag_store.dart';
import '../ecs/stores/combat/damage_resistance_store.dart';
import '../ecs/stores/combat/status_immunity_store.dart';
import '../ecs/stores/health_store.dart';
import '../ecs/stores/mana_store.dart';
import '../ecs/stores/stamina_store.dart';
import '../snapshots/enums.dart';
import '../weapons/weapon_id.dart';
import '../weapons/ranged_weapon_id.dart';

/// Fully-resolved player configuration used to spawn the player entity.
///
/// **Purpose**:
/// Contains all the component definitions needed to instantiate a player
/// entity in the ECS world. Unlike [PlayerCatalog], which holds authoring-time
/// templates, this class holds final, tick-rate-independent values ready for
/// entity creation.
///
/// **Lifecycle**:
/// 1. [PlayerCatalog] defines base templates (physics flags, default facing).
/// 2. [PlayerCatalogDerived.from] merges templates with tuning data to produce
///    a [PlayerArchetype].
/// 3. [EntityFactory.createPlayer] uses the archetype to add components..
class PlayerArchetype {
  const PlayerArchetype({
    required this.collider,
    required this.body,
    required this.health,
    required this.mana,
    required this.stamina,
    this.tags = const CreatureTagDef(),
    this.resistance = const DamageResistanceDef(),
    this.statusImmunity = const StatusImmunityDef(),
    this.weaponId = WeaponId.basicSword,
    this.rangedWeaponId = RangedWeaponId.bow,
    this.ammo = const AmmoDef(),
    this.facing = Facing.right,
  });

  /// AABB collider definition (half-extents and offset).
  ///
  /// Determines the player's collision bounds for physics and hit detection.
  /// Typically derived from [MovementTuning.playerRadius].
  final ColliderAabbDef collider;

  /// Physics body configuration (gravity, kinematic flags, velocity clamps).
  ///
  /// Controls how the player interacts with the physics simulation:
  /// - `useGravity`: Whether gravity affects the player.
  /// - `maxVelX/maxVelY`: Velocity clamps from movement tuning.
  /// - `sideMask`: Which collision sides are active.
  final BodyDef body;

  /// Health pool definition (current HP, max HP, regeneration rate).
  ///
  /// Values derived from [ResourceTuning.playerHpMax] and related fields.
  final HealthDef health;

  /// Mana pool definition (current mana, max mana, regeneration rate).
  ///
  /// Used for spell casting. Values from [ResourceTuning.playerManaMax].
  final ManaDef mana;

  /// Stamina pool definition (current stamina, max stamina, regeneration rate).
  ///
  /// Used for abilities like dash. Values from [ResourceTuning.playerStaminaMax].
  final StaminaDef stamina;

  /// Broad tags used by combat rules and content filters.
  final CreatureTagDef tags;

  /// Resistance/vulnerability modifiers by damage type.
  final DamageResistanceDef resistance;

  /// Status effect immunities for the player.
  final StatusImmunityDef statusImmunity;

  /// Equipped weapon used for melee attacks.
  final WeaponId weaponId;

  /// Equipped ranged weapon used for thrown/ballistic projectiles.
  final RangedWeaponId rangedWeaponId;

  /// Ammo pool for ranged weapons.
  final AmmoDef ammo;

  /// Initial facing direction when the player spawns.
  ///
  /// Affects sprite rendering and directional abilities.
  final Facing facing;
}


===== FILE: lib/core/players/player_catalog.dart =====
import '../combat/creature_tag.dart';
import '../ecs/stores/body_store.dart';
import '../ecs/stores/collider_aabb_store.dart';
import '../ecs/stores/combat/ammo_store.dart';
import '../ecs/stores/combat/creature_tag_store.dart';
import '../ecs/stores/combat/damage_resistance_store.dart';
import '../ecs/stores/combat/status_immunity_store.dart';
import '../ecs/stores/health_store.dart';
import '../ecs/stores/mana_store.dart';
import '../ecs/stores/stamina_store.dart';
import '../snapshots/enums.dart';
import '../tuning/movement_tuning.dart';
import '../tuning/resource_tuning.dart';
import '../weapons/weapon_id.dart';
import '../weapons/ranged_weapon_id.dart';
import 'player_archetype.dart';

/// Authoring-time configuration for the player entity.
///
/// **Purpose**:
/// Defines the base template for player physics and spawn behavior. This class
/// holds values that are independent of tick rate or specific tuning numbers,
/// focusing on structural configuration (what physics flags to use, etc.).
///
/// **Relationship to Tuning**:
/// - [PlayerCatalog]: Structural config (physics flags, collision sides).
/// - [MovementTuning]: Numeric movement values (speed, radius, velocity clamps).
/// - [ResourceTuning]: Numeric resource values (HP, mana, stamina).
///
/// The [PlayerCatalogDerived.from] factory merges all three to produce a
/// complete [PlayerArchetype] ready for entity creation.
class PlayerCatalog {
  const PlayerCatalog({
    this.bodyTemplate = const BodyDef(
      isKinematic: false,
      useGravity: true,
      ignoreCeilings: false,
      topOnlyGround: true,
      gravityScale: 1.0,
      sideMask: BodyDef.sideLeft | BodyDef.sideRight,
    ),
    this.tags = const CreatureTagDef(mask: CreatureTagMask.humanoid),
    this.resistance = const DamageResistanceDef(),
    this.statusImmunity = const StatusImmunityDef(),
    this.weaponId = WeaponId.basicSword,
    this.rangedWeaponId = RangedWeaponId.bow,
    this.ammo = const AmmoDef(arrows: 20, throwingAxes: 6),
    this.facing = Facing.right,
  });

  /// Template for how the player participates in physics.
  ///
  /// **Fields used from template**:
  /// - `isKinematic`: False for player (affected by forces).
  /// - `useGravity`: True (player falls).
  /// - `ignoreCeilings`: False (player collides with ceilings).
  /// - `topOnlyGround`: True (only collide with top of ground, not sides).
  /// - `gravityScale`: 1.0 (normal gravity).
  /// - `sideMask`: Left + Right (collide with walls on both sides).
  ///
  /// **Fields filled from [MovementTuning] during derivation**:
  /// - `maxVelX`: Horizontal velocity clamp.
  /// - `maxVelY`: Vertical velocity clamp.
  ///
  /// This split ensures movement tuning remains the single source of truth
  /// for velocity limits.
  final BodyDef bodyTemplate;

  /// Broad tags used by combat rules and content filters.
  final CreatureTagDef tags;

  /// Resistance/vulnerability modifiers by damage type.
  final DamageResistanceDef resistance;

  /// Status effect immunities for the player.
  final StatusImmunityDef statusImmunity;

  /// Default equipped weapon at spawn time.
  final WeaponId weaponId;

  /// Default equipped ranged weapon at spawn time.
  final RangedWeaponId rangedWeaponId;

  /// Default ammo pool at spawn time.
  final AmmoDef ammo;

  /// Default facing direction at spawn time.
  ///
  /// Determines initial sprite orientation and directional ability targeting.
  final Facing facing;
}

/// Derived player configuration with tick-rate-resolved values.
///
/// **Purpose**:
/// Combines [PlayerCatalog] templates with [MovementTuning] and [ResourceTuning]
/// to produce a complete [PlayerArchetype]. This is the "compiled" form of
/// player configuration, ready for entity creation.
///
/// **Why a Separate Class?**:
/// - Tuning values may be tick-rate dependent (e.g., regen per second → per tick).
/// - Collider size comes from movement tuning, not catalog.
/// - Resource pools (HP, mana, stamina) come from resource tuning.
/// - Keeping derivation explicit makes dependencies clear and testable.
///
/// **Lifecycle**:
/// Created once at game initialization, stored in [GameCore], used whenever
/// the player needs to be spawned or respawned.
class PlayerCatalogDerived {
  const PlayerCatalogDerived._({required this.archetype});

  /// Creates a derived catalog by merging base config with tuning data.
  ///
  /// **Parameters**:
  /// - [base]: The authoring-time catalog with physics flags.
  /// - [movement]: Movement tuning for collider size and velocity clamps.
  /// - [resources]: Resource tuning for HP, mana, and stamina pools.
  ///
  /// **Derivation Logic**:
  /// 1. Copy physics flags from [base.bodyTemplate].
  /// 2. Fill `maxVelX`/`maxVelY` from [movement].
  /// 3. Create square collider from [movement.playerRadius].
  /// 4. Create resource pools from [resources].
  /// 5. Bundle everything into a [PlayerArchetype].
  factory PlayerCatalogDerived.from(
    PlayerCatalog base, {
    required MovementTuningDerived movement,
    required ResourceTuning resources,
  }) {
    // Merge body template with velocity clamps from movement tuning.
    final body = BodyDef(
      enabled: base.bodyTemplate.enabled,
      isKinematic: base.bodyTemplate.isKinematic,
      useGravity: base.bodyTemplate.useGravity,
      ignoreCeilings: base.bodyTemplate.ignoreCeilings,
      topOnlyGround: base.bodyTemplate.topOnlyGround,
      gravityScale: base.bodyTemplate.gravityScale,
      maxVelX: movement.base.maxVelX,
      maxVelY: movement.base.maxVelY,
      sideMask: base.bodyTemplate.sideMask,
    );

    // Square collider based on player radius.
    final collider = ColliderAabbDef(
      halfX: movement.base.playerRadius,
      halfY: movement.base.playerRadius,
    );

    // Resource pools from resource tuning.
    final health = HealthDef(
      hp: resources.playerHpMax,
      hpMax: resources.playerHpMax,
      regenPerSecond: resources.playerHpRegenPerSecond,
    );
    final mana = ManaDef(
      mana: resources.playerManaMax,
      manaMax: resources.playerManaMax,
      regenPerSecond: resources.playerManaRegenPerSecond,
    );
    final stamina = StaminaDef(
      stamina: resources.playerStaminaMax,
      staminaMax: resources.playerStaminaMax,
      regenPerSecond: resources.playerStaminaRegenPerSecond,
    );

    return PlayerCatalogDerived._(
      archetype: PlayerArchetype(
        collider: collider,
        body: body,
        health: health,
        mana: mana,
        stamina: stamina,
        tags: base.tags,
        resistance: base.resistance,
        statusImmunity: base.statusImmunity,
        weaponId: base.weaponId,
        rangedWeaponId: base.rangedWeaponId,
        ammo: base.ammo,
        facing: base.facing,
      ),
    );
  }

  /// The fully-resolved player archetype ready for entity creation.
  ///
  /// Use this with [EntityFactory.createPlayer] to spawn the player entity.
  final PlayerArchetype archetype;
}


===== FILE: lib/core/projectiles/projectile_catalog.dart =====
import '../util/tick_math.dart';

import 'projectile_id.dart';

/// Static properties for a projectile type.
///
/// Defines speed, lifetime, and collision bounds. Damage is determined by
/// the spell that spawns the projectile, not the projectile itself.
class ProjectileArchetype {
  const ProjectileArchetype({
    required this.speedUnitsPerSecond,
    required this.lifetimeSeconds,
    required this.colliderSizeX,
    required this.colliderSizeY,
  });

  /// Travel speed in world units per second.
  final double speedUnitsPerSecond;

  /// How long before auto-despawn (seconds).
  final double lifetimeSeconds;

  /// Full width of the collision box (world units).
  final double colliderSizeX;

  /// Full height of the collision box (world units).
  final double colliderSizeY;
}

/// Lookup table for projectile archetypes by [ProjectileId].
///
/// All values are authoring-time constants. For tick-rate-dependent values,
/// use [ProjectileCatalogDerived].
class ProjectileCatalog {
  const ProjectileCatalog();

  /// Returns the archetype for the given projectile type.
  ProjectileArchetype get(ProjectileId id) {
    switch (id) {
      case ProjectileId.iceBolt:
        return const ProjectileArchetype(
          speedUnitsPerSecond: 1000.0,
          lifetimeSeconds: 1.0,
          colliderSizeX: 18.0,
          colliderSizeY: 8.0,
        );
      case ProjectileId.lightningBolt:
        return const ProjectileArchetype(
          speedUnitsPerSecond: 1000.0,
          lifetimeSeconds: 1.2,
          colliderSizeX: 16.0,
          colliderSizeY: 8.0,
        );
      case ProjectileId.arrow:
        return const ProjectileArchetype(
          speedUnitsPerSecond: 1000.0,
          lifetimeSeconds: 1.4,
          colliderSizeX: 18.0,
          colliderSizeY: 6.0,
        );
      case ProjectileId.throwingAxe:
        return const ProjectileArchetype(
          speedUnitsPerSecond: 900.0,
          lifetimeSeconds: 1.6,
          colliderSizeX: 16.0,
          colliderSizeY: 10.0,
        );
    }
  }
}

/// Tick-rate-aware wrapper for [ProjectileCatalog].
///
/// Converts time-based values (seconds) to tick counts for use in systems.
class ProjectileCatalogDerived {
  const ProjectileCatalogDerived._({required this.tickHz, required this.base});

  factory ProjectileCatalogDerived.from(
    ProjectileCatalog base, {
    required int tickHz,
  }) {
    if (tickHz <= 0) {
      throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
    }
    return ProjectileCatalogDerived._(tickHz: tickHz, base: base);
  }

  final int tickHz;
  final ProjectileCatalog base;

  /// Converts [lifetimeSeconds] to ticks (rounded up).
  int lifetimeTicks(ProjectileId id) {
    return ticksFromSecondsCeil(base.get(id).lifetimeSeconds, tickHz);
  }
}


===== FILE: lib/core/projectiles/projectile_id.dart =====
/// Identifies a projectile type for catalog lookup and rendering.
///
/// Each ID maps to a [ProjectileArchetype] in [ProjectileCatalog] and
/// determines visual appearance in the renderer.
enum ProjectileId {
  /// Player's primary ranged attack. Fast, short-lived.
  iceBolt,

  /// Enemy ranged attack. Slower but longer range.
  lightningBolt,

  /// Physical arrow projectile (ballistic).
  arrow,

  /// Physical throwing axe projectile (ballistic).
  throwingAxe,
}


===== FILE: lib/core/scoring/run_score_breakdown.dart =====
import '../enemies/enemy_id.dart';
import '../tuning/score_tuning.dart';

/// Categories of score contributions shown in the end-of-run breakdown.
enum RunScoreRowKind {
  /// Points earned from distance traveled.
  distance,

  /// Points earned from survival time.
  time,

  /// Points earned from collected items.
  collectibles,

  /// Points earned from killing enemies (one row per enemy type).
  enemyKill,
}

/// A single line item in the score breakdown UI.
///
/// Each row shows a category, a count (e.g., meters, seconds, kills),
/// and the points contributed by that category.
class RunScoreRow {
  const RunScoreRow({
    required this.kind,
    required this.count,
    required this.points,
    this.enemyId,
  });

  /// Row category (distance/time/collectibles/enemy kills).
  final RunScoreRowKind kind;

  /// Quantity displayed (meters, seconds, collectible count, or kill count).
  final int count;

  /// Total points contributed by this row.
  final int points;

  /// For [RunScoreRowKind.enemyKill] rows, identifies the enemy type.
  final EnemyId? enemyId;
}

/// Complete score breakdown for a finished run.
///
/// Contains itemized rows and the computed total. Used by the game-over UI
/// to display how the player earned their score.
class RunScoreBreakdown {
  const RunScoreBreakdown({
    required this.rows,
    required this.totalPoints,
  });

  /// Itemized score contributions (distance, time, collectibles, enemy kills).
  final List<RunScoreRow> rows;

  /// Sum of all row points.
  final int totalPoints;
}

/// Computes the score breakdown for a completed run.
///
/// Converts raw game stats (ticks, distance units, kill counts) into
/// player-facing values (meters, seconds) and calculates points using
/// [ScoreTuning] multipliers.
RunScoreBreakdown buildRunScoreBreakdown({
  required int tick,
  required double distanceUnits,
  required int collectibles,
  required int collectibleScore,
  required List<int> enemyKillCounts,
  required ScoreTuning tuning,
  required int tickHz,
  int unitsPerMeter = kWorldUnitsPerMeter,
}) {
  // Convert internal units to player-facing values.
  final meters =
      unitsPerMeter <= 0 ? 0 : (distanceUnits / unitsPerMeter).floor();
  final timeSeconds = tickHz <= 0 ? 0 : tick ~/ tickHz;

  final rows = <RunScoreRow>[
    RunScoreRow(
      kind: RunScoreRowKind.distance,
      count: meters,
      points: meters * tuning.distanceScorePerMeter,
    ),
    RunScoreRow(
      kind: RunScoreRowKind.time,
      count: timeSeconds,
      points: timeSeconds * tuning.timeScorePerSecond,
    ),
    RunScoreRow(
      kind: RunScoreRowKind.collectibles,
      count: collectibles,
      points: collectibleScore,
    ),
  ];

  // Add a row for each enemy type with at least one kill.
  for (final enemyId in EnemyId.values) {
    final index = enemyId.index;
    final kills = index < enemyKillCounts.length ? enemyKillCounts[index] : 0;
    if (kills <= 0) continue;
    rows.add(
      RunScoreRow(
        kind: RunScoreRowKind.enemyKill,
        count: kills,
        points: kills * _enemyKillScore(tuning, enemyId),
        enemyId: enemyId,
      ),
    );
  }

  // Sum all rows for total.
  var totalPoints = 0;
  for (final row in rows) {
    totalPoints += row.points;
  }

  return RunScoreBreakdown(
    rows: List<RunScoreRow>.unmodifiable(rows),
    totalPoints: totalPoints,
  );
}

/// Returns the point value for killing one enemy of [enemyId] type.
int _enemyKillScore(ScoreTuning tuning, EnemyId enemyId) {
  switch (enemyId) {
    case EnemyId.groundEnemy:
      return tuning.groundEnemyKillScore;
    case EnemyId.unocoDemon:
      return tuning.unocoDemonKillScore;
  }
}


===== FILE: lib/core/snapshot_builder.dart =====
/// Builds immutable render snapshots from ECS world state.
///
/// This module decouples snapshot construction from simulation logic,
/// providing a clean separation between the game's internal state (ECS)
/// and the data consumed by the rendering layer.
///
/// All methods are pure readers—no side effects on [EcsWorld].
///
/// ## Architecture
///
/// The render layer never reads ECS directly. Instead, [GameCore] calls
/// [SnapshotBuilder.build] once per tick to produce a [GameStateSnapshot],
/// which is an immutable, self-contained description of everything needed
/// to draw a single frame.
///
/// ## Key Types
///
/// - [SnapshotBuilder] — Stateful builder holding ECS and tuning references.
/// - [GameStateSnapshot] — Complete frame data (entities, HUD, geometry).
/// - [EntityRenderSnapshot] — Per-entity render info (position, animation, etc.).
/// - [PlayerHudSnapshot] — Player resource bars, cooldowns, affordability flags.
library;

import 'dart:math';

import 'ecs/entity_id.dart';
import 'ecs/world.dart';
import 'ecs/stores/restoration_item_store.dart';
import 'levels/level_id.dart';
import 'projectiles/projectile_catalog.dart';
import 'snapshots/enums.dart';
import 'snapshots/entity_render_snapshot.dart';
import 'snapshots/game_state_snapshot.dart';
import 'snapshots/player_hud_snapshot.dart';
import 'snapshots/static_ground_gap_snapshot.dart';
import 'snapshots/static_solid_snapshot.dart';
import 'spells/spell_catalog.dart';
import 'spells/spell_id.dart';
import 'tuning/ability_tuning.dart';
import 'tuning/anim_tuning.dart';
import 'tuning/movement_tuning.dart';
import 'tuning/resource_tuning.dart';
import 'util/vec2.dart';
import 'weapons/ranged_weapon_catalog.dart';

// ─────────────────────────────────────────────────────────────────────────────
// SnapshotBuilder
// ─────────────────────────────────────────────────────────────────────────────

/// Constructs [GameStateSnapshot] instances from ECS world state.
///
/// Holds references to the ECS world and all tuning data needed to compute
/// derived values (e.g., cooldown progress, affordability flags).
///
/// Usage:
/// ```dart
/// final builder = SnapshotBuilder(world: ..., player: ..., ...);
/// final snapshot = builder.build(tick: 42, ...);
/// ```
class SnapshotBuilder {
  /// Creates a snapshot builder with the given dependencies.
  ///
  /// - [world]: The ECS world containing all entity component data.
  /// - [player]: Entity ID of the player (used to query player-specific stores).
  /// - [movement]: Derived movement tuning (dash cooldown ticks, etc.).
  /// - [abilities]: Derived ability tuning (melee/cast cooldown ticks).
  /// - [animTuning]: Derived animation tuning (hit/cast/attack/spawn windows).
  /// - [resources]: Resource costs (jump/dash stamina, etc.).
  /// - [spells]: Spell catalog for querying spell stats (mana costs).
  /// - [projectiles]: Projectile catalog for collider sizes.
  /// - [rangedWeapons]: Ranged weapon catalog (cooldowns/ammo costs).
  SnapshotBuilder({
    required this.world,
    required this.player,
    required this.movement,
    required this.abilities,
    required this.animTuning,
    required this.resources,
    required this.spells,
    required this.projectiles,
    required this.rangedWeapons,
  });

  /// The ECS world containing all game entity data.
  final EcsWorld world;

  /// Entity ID of the player character.
  final EntityId player;

  /// Derived movement tuning (pre-computed tick-based values).
  final MovementTuningDerived movement;

  /// Derived ability tuning (cooldown durations in ticks).
  final AbilityTuningDerived abilities;

  /// Derived animation tuning (one-shot windows in ticks).
  final AnimTuningDerived animTuning;

  /// Resource tuning (stamina/mana costs for actions).
  final ResourceTuning resources;

  /// Spell catalog for looking up spell stats.
  final SpellCatalog spells;

  /// Projectile catalog for collider dimensions.
  final ProjectileCatalogDerived projectiles;

  /// Ranged weapon catalog for cooldown totals and ammo costs.
  final RangedWeaponCatalogDerived rangedWeapons;

  // ───────────────────────────────────────────────────────────────────────────
  // Public API
  // ───────────────────────────────────────────────────────────────────────────

  /// Builds a complete [GameStateSnapshot] for the current tick.
  ///
  /// This method reads from multiple ECS component stores to assemble:
  /// - Player state (position, velocity, animation, facing direction)
  /// - HUD data (HP, mana, stamina, cooldowns, affordability)
  /// - All entity render snapshots (player, enemies, projectiles, pickups)
  /// - Static geometry (platforms, ground gaps)
  ///
  /// Parameters:
  /// - [tick]: Current simulation tick number.
  /// - [seed]: RNG seed for this run (stored for replay/debug).
  /// - [levelId]: Level identifier for this run (stored for replay/debug).
  /// - [themeId]: Optional render theme identifier (stored for debug/UI).
  /// - [distance]: Total distance traveled (world units).
  /// - [paused]: Whether the game is currently paused.
  /// - [gameOver]: Whether the run has ended.
  /// - [cameraCenterX], [cameraCenterY]: Camera focus point (world coords).
  /// - [collectibles]: Number of collectibles picked up this run.
  /// - [collectibleScore]: Total score from collectibles.
  /// - [staticSolids]: Pre-built list of platform snapshots.
  /// - [groundGaps]: Pre-built list of ground gap snapshots.
  GameStateSnapshot build({
    required int tick,
    required int seed,
    required LevelId levelId,
    required String? themeId,
    required double distance,
    required bool paused,
    required bool gameOver,
    required double cameraCenterX,
    required double cameraCenterY,
    required int collectibles,
    required int collectibleScore,
    required List<StaticSolidSnapshot> staticSolids,
    required List<StaticGroundGapSnapshot> groundGaps,
  }) {
    // ─── Query player component indices ───
    final tuning = movement.base;
    final mi = world.movement.indexOf(player);
    final dashTicksLeft = world.movement.dashTicksLeft[mi];
    final dashing = dashTicksLeft > 0;
    final onGround = world.collision.grounded[world.collision.indexOf(player)];
    final hi = world.health.indexOf(player);
    final mai = world.mana.indexOf(player);
    final si = world.stamina.indexOf(player);
    final ci = world.cooldown.indexOf(player);
    final rwi = world.equippedRangedWeapon.indexOf(player);
    final ami = world.ammo.indexOf(player);

    // ─── Read current resource values ───
    final stamina = world.stamina.stamina[si];
    final mana = world.mana.mana[mai];
    final projectileManaCost = spells.get(SpellId.iceBolt).stats.manaCost;
    final rangedWeaponId = world.equippedRangedWeapon.weaponId[rwi];
    final rangedWeaponDef = rangedWeapons.base.get(rangedWeaponId);
    final rangedAmmo =
        world.ammo.countForIndex(ami, rangedWeaponDef.ammoType);

    // ─── Compute affordability flags ───
    // These tell the UI whether action buttons should appear enabled.
    final canAffordJump = stamina >= resources.jumpStaminaCost;
    final canAffordDash = stamina >= resources.dashStaminaCost;
    final canAffordMelee = stamina >= abilities.base.meleeStaminaCost;
    final canAffordProjectile = mana >= projectileManaCost;
    final canAffordRangedWeapon =
        stamina >= rangedWeaponDef.staminaCost &&
        rangedAmmo >= rangedWeaponDef.ammoCost;

    // ─── Read cooldown timers ───
    final dashCooldownTicksLeft = world.movement.dashCooldownTicksLeft[mi];
    final meleeCooldownTicksLeft = world.cooldown.meleeCooldownTicksLeft[ci];
    final projectileCooldownTicksLeft =
        world.cooldown.castCooldownTicksLeft[ci];
    final rangedWeaponCooldownTicksLeft =
        world.cooldown.rangedWeaponCooldownTicksLeft[ci];
    final rangedWeaponCooldownTicksTotal =
        rangedWeapons.cooldownTicks(rangedWeaponId);

    // ─── Read player transform ───
    final ti = world.transform.indexOf(player);
    final playerPosX = world.transform.posX[ti];
    final playerPosY = world.transform.posY[ti];
    final playerVelX = world.transform.velX[ti];
    final playerVelY = world.transform.velY[ti];
    final playerFacing = world.movement.facing[mi];
    final playerHp = world.health.hp[hi];
    final actionAnimIndex = world.actionAnim.tryIndexOf(player);
    final lastMeleeTick = actionAnimIndex == null
        ? -1
        : world.actionAnim.lastMeleeTick[actionAnimIndex];
    final lastCastTick = actionAnimIndex == null
        ? -1
        : world.actionAnim.lastCastTick[actionAnimIndex];

    final lastDamageTick = world.lastDamage.has(player)
        ? world.lastDamage.tick[world.lastDamage.indexOf(player)]
        : -1;

    // ─── Determine player animation ───
    // Priority: death > hit > attack/cast > dash > airborne > moving > idle/spawn
    final AnimKey anim;
    final showHit =
        animTuning.hitAnimTicks > 0 &&
        lastDamageTick >= 0 &&
        (tick - lastDamageTick) < animTuning.hitAnimTicks;
    final showAttack =
        animTuning.attackAnimTicks > 0 &&
        lastMeleeTick >= 0 &&
        (tick - lastMeleeTick) < animTuning.attackAnimTicks;
    final showCast =
        animTuning.castAnimTicks > 0 &&
        lastCastTick >= 0 &&
        (tick - lastCastTick) < animTuning.castAnimTicks;

    if (playerHp <= 0) {
      anim = AnimKey.death;
    } else if (showHit) {
      anim = AnimKey.hit;
    } else if (showAttack) {
      anim = AnimKey.attack;
    } else if (showCast) {
      anim = AnimKey.cast;
    } else if (dashing) {
      anim = AnimKey.dash;
    } else if (!onGround) {
      anim = playerVelY < 0 ? AnimKey.jump : AnimKey.fall;
    } else if (playerVelX.abs() > tuning.minMoveSpeed) {
      anim = AnimKey.run;
    } else if (animTuning.spawnAnimTicks > 0 &&
        tick < animTuning.spawnAnimTicks) {
      anim = AnimKey.spawn;
    } else {
      anim = AnimKey.idle;
    }

    final int playerAnimFrame;
    switch (anim) {
      case AnimKey.attack:
        playerAnimFrame = lastMeleeTick >= 0 ? tick - lastMeleeTick : tick;
      case AnimKey.cast:
        playerAnimFrame = lastCastTick >= 0 ? tick - lastCastTick : tick;
      case AnimKey.hit:
        playerAnimFrame = lastDamageTick >= 0 ? tick - lastDamageTick : tick;
      case AnimKey.death:
        playerAnimFrame = lastDamageTick >= 0 ? tick - lastDamageTick : tick;
      case AnimKey.dash:
        playerAnimFrame = max(0, movement.dashDurationTicks - dashTicksLeft);
      default:
        playerAnimFrame = tick;
    }

    final playerPos = Vec2(playerPosX, playerPosY);
    final playerVel = Vec2(playerVelX, playerVelY);

    // ─── Build entity list (player first) ───
    final entities = <EntityRenderSnapshot>[
      EntityRenderSnapshot(
        id: player,
        kind: EntityKind.player,
        pos: playerPos,
        vel: playerVel,
        size: Vec2(tuning.playerRadius * 2, tuning.playerRadius * 2),
        facing: playerFacing,
        anim: anim,
        grounded: onGround,
        animFrame: playerAnimFrame,
      ),
    ];

    // Append all other renderable entities.
    _addProjectiles(entities, tick: tick);
    _addHitboxes(entities, tick: tick);
    _addCollectibles(entities, tick: tick);
    _addRestorationItems(entities, tick: tick);
    _addEnemies(entities, tick: tick);

    // ─── Assemble final snapshot ───
    return GameStateSnapshot(
      tick: tick,
      seed: seed,
      levelId: levelId,
      themeId: themeId,
      distance: distance,
      paused: paused,
      gameOver: gameOver,
      cameraCenterX: cameraCenterX,
      cameraCenterY: cameraCenterY,
      hud: PlayerHudSnapshot(
        hp: world.health.hp[hi],
        hpMax: world.health.hpMax[hi],
        mana: mana,
        manaMax: world.mana.manaMax[mai],
        stamina: stamina,
        staminaMax: world.stamina.staminaMax[si],
        canAffordJump: canAffordJump,
        canAffordDash: canAffordDash,
        canAffordMelee: canAffordMelee,
        canAffordProjectile: canAffordProjectile,
        canAffordRangedWeapon: canAffordRangedWeapon,
        dashCooldownTicksLeft: dashCooldownTicksLeft,
        dashCooldownTicksTotal: movement.dashCooldownTicks,
        meleeCooldownTicksLeft: meleeCooldownTicksLeft,
        meleeCooldownTicksTotal: abilities.meleeCooldownTicks,
        projectileCooldownTicksLeft: projectileCooldownTicksLeft,
        projectileCooldownTicksTotal: abilities.castCooldownTicks,
        rangedWeaponCooldownTicksLeft: rangedWeaponCooldownTicksLeft,
        rangedWeaponCooldownTicksTotal: rangedWeaponCooldownTicksTotal,
        rangedAmmo: rangedAmmo,
        collectibles: collectibles,
        collectibleScore: collectibleScore,
      ),
      entities: entities,
      staticSolids: staticSolids,
      groundGaps: groundGaps,
    );
  }

  // ───────────────────────────────────────────────────────────────────────────
  // Private Entity Collectors
  // ───────────────────────────────────────────────────────────────────────────

  /// Appends projectile entity snapshots to [entities].
  ///
  /// Iterates the projectile component store and creates render snapshots
  /// with position, velocity, facing direction, and rotation angle.
  void _addProjectiles(List<EntityRenderSnapshot> entities, {required int tick}) {
    final projectileStore = world.projectile;
    for (var pi = 0; pi < projectileStore.denseEntities.length; pi += 1) {
      final e = projectileStore.denseEntities[pi];
      if (!world.transform.has(e)) continue;
      final ti = world.transform.indexOf(e);

      // Look up projectile definition for collider size.
      final projectileId = projectileStore.projectileId[pi];
      final proj = projectiles.base.get(projectileId);
      final colliderSize = Vec2(proj.colliderSizeX, proj.colliderSizeY);

      // Compute facing and rotation from direction vector.
      final dirX = projectileStore.dirX[pi];
      final dirY = projectileStore.dirY[pi];
      final facing = dirX >= 0 ? Facing.right : Facing.left;
      final rotationRad = atan2(dirY, dirX);

      entities.add(
        EntityRenderSnapshot(
          id: e,
          kind: EntityKind.projectile,
          pos: Vec2(world.transform.posX[ti], world.transform.posY[ti]),
          vel: Vec2(world.transform.velX[ti], world.transform.velY[ti]),
          size: colliderSize,
          projectileId: projectileId,
          facing: facing,
          rotationRad: rotationRad,
          anim: AnimKey.idle,
          grounded: false,
          animFrame: tick,
        ),
      );
    }
  }

  /// Appends active hitbox (melee attack) snapshots to [entities].
  ///
  /// Hitboxes are short-lived trigger volumes spawned by melee attacks.
  /// They render as debug overlays or attack effects.
  void _addHitboxes(List<EntityRenderSnapshot> entities, {required int tick}) {
    final hitboxes = world.hitbox;
    for (var hi = 0; hi < hitboxes.denseEntities.length; hi += 1) {
      final e = hitboxes.denseEntities[hi];
      if (!world.transform.has(e)) continue;
      final ti = world.transform.indexOf(e);

      // Hitbox size is stored as half-extents; double for full size.
      final size = Vec2(hitboxes.halfX[hi] * 2, hitboxes.halfY[hi] * 2);
      final dirX = hitboxes.dirX[hi];
      final dirY = hitboxes.dirY[hi];
      final facing = dirX >= 0 ? Facing.right : Facing.left;
      final rotationRad = atan2(dirY, dirX);

      entities.add(
        EntityRenderSnapshot(
          id: e,
          kind: EntityKind.trigger,
          pos: Vec2(world.transform.posX[ti], world.transform.posY[ti]),
          size: size,
          facing: facing,
          rotationRad: rotationRad,
          anim: AnimKey.hit,
          grounded: false,
          animFrame: tick,
        ),
      );
    }
  }

  /// Appends collectible (score pickup) snapshots to [entities].
  ///
  /// Collectibles are small pickups that grant score when collected.
  void _addCollectibles(List<EntityRenderSnapshot> entities, {required int tick}) {
    final collectiblesStore = world.collectible;
    for (var ci = 0; ci < collectiblesStore.denseEntities.length; ci += 1) {
      final e = collectiblesStore.denseEntities[ci];
      if (!world.transform.has(e)) continue;
      final ti = world.transform.indexOf(e);

      // Size comes from AABB collider if present.
      Vec2? size;
      if (world.colliderAabb.has(e)) {
        final aabbi = world.colliderAabb.indexOf(e);
        size = Vec2(
          world.colliderAabb.halfX[aabbi] * 2,
          world.colliderAabb.halfY[aabbi] * 2,
        );
      }

      entities.add(
        EntityRenderSnapshot(
          id: e,
          kind: EntityKind.pickup,
          pos: Vec2(world.transform.posX[ti], world.transform.posY[ti]),
          size: size,
          facing: Facing.right,
          pickupVariant: PickupVariant.collectible,
          rotationRad: pi * 0.25, // 45° tilt for visual interest
          anim: AnimKey.idle,
          grounded: false,
          animFrame: tick,
        ),
      );
    }
  }

  /// Appends restoration item (health/mana/stamina orb) snapshots to [entities].
  ///
  /// Restoration items restore a specific resource when picked up.
  /// The [pickupVariant] field tells the renderer which sprite to use.
  void _addRestorationItems(List<EntityRenderSnapshot> entities, {required int tick}) {
    final restorationStore = world.restorationItem;
    for (var ri = 0; ri < restorationStore.denseEntities.length; ri += 1) {
      final e = restorationStore.denseEntities[ri];
      if (!world.transform.has(e)) continue;
      final ti = world.transform.indexOf(e);

      Vec2? size;
      if (world.colliderAabb.has(e)) {
        final aabbi = world.colliderAabb.indexOf(e);
        size = Vec2(
          world.colliderAabb.halfX[aabbi] * 2,
          world.colliderAabb.halfY[aabbi] * 2,
        );
      }

      // Map restoration stat enum to pickup variant for rendering.
      final stat = restorationStore.stat[ri];
      int variant;
      switch (stat) {
        case RestorationStat.health:
          variant = PickupVariant.restorationHealth;
        case RestorationStat.mana:
          variant = PickupVariant.restorationMana;
        case RestorationStat.stamina:
          variant = PickupVariant.restorationStamina;
      }

      entities.add(
        EntityRenderSnapshot(
          id: e,
          kind: EntityKind.pickup,
          pos: Vec2(world.transform.posX[ti], world.transform.posY[ti]),
          size: size,
          facing: Facing.right,
          pickupVariant: variant,
          rotationRad: pi * 0.25,
          anim: AnimKey.idle,
          grounded: false,
          animFrame: tick,
        ),
      );
    }
  }

  /// Appends enemy entity snapshots to [entities].
  ///
  /// Enemies have position, velocity, facing direction, and grounded state.
  /// The renderer uses this to select appropriate sprites and animations.
  void _addEnemies(List<EntityRenderSnapshot> entities, {required int tick}) {
    final enemies = world.enemy;
    for (var ei = 0; ei < enemies.denseEntities.length; ei += 1) {
      final e = enemies.denseEntities[ei];
      if (!world.transform.has(e)) continue;
      final ti = world.transform.indexOf(e);

      Vec2? size;
      if (world.colliderAabb.has(e)) {
        final aabbi = world.colliderAabb.indexOf(e);
        size = Vec2(
          world.colliderAabb.halfX[aabbi] * 2,
          world.colliderAabb.halfY[aabbi] * 2,
        );
      }

      entities.add(
        EntityRenderSnapshot(
          id: e,
          kind: EntityKind.enemy,
          pos: Vec2(world.transform.posX[ti], world.transform.posY[ti]),
          vel: Vec2(world.transform.velX[ti], world.transform.velY[ti]),
          size: size,
          facing: enemies.facing[ei],
          anim: AnimKey.idle,
          grounded: world.collision.has(e)
              ? world.collision.grounded[world.collision.indexOf(e)]
              : false,
          animFrame: tick,
        ),
      );
    }
  }
}


===== FILE: lib/core/snapshots/entity_render_snapshot.dart =====
/// Renderer-facing entity data extracted from Core at the end of each tick.
///
/// This is a read-only, serializable view of entity state. It intentionally
/// hides internal ECS storage details and provides only what the renderer needs.
library;

import '../util/vec2.dart';
import '../projectiles/projectile_id.dart';
import 'enums.dart';

/// Render-only snapshot of a single entity.
///
/// Created by [GameCore] after each simulation tick. Contains position,
/// animation state, and optional metadata for specialized rendering.
class EntityRenderSnapshot {
  const EntityRenderSnapshot({
    required this.id,
    required this.kind,
    required this.pos,
    required this.facing,
    required this.anim,
    required this.grounded,
    this.vel,
    this.size,
    this.projectileId,
    this.pickupVariant,
    this.z,
    this.rotationRad = 0.0,
    this.animFrame,
  });

  /// Stable entity identifier (protocol-stable).
  final int id;

  /// Broad entity classification for choosing visuals/behavior.
  final EntityKind kind;

  /// World position in virtual pixels.
  final Vec2 pos;

  /// Optional world velocity (useful for facing/animation).
  final Vec2? vel;

  /// Optional full extents in world units (virtual pixels).
  ///
  /// Render-only hint for placeholder shapes (e.g. projectile rectangles).
  final Vec2? size;

  /// Optional projectile archetype id (set when [kind] is [EntityKind.projectile]).
  final ProjectileId? projectileId;

  /// Optional pickup variant for render-only pickup styling.
  final int? pickupVariant;

  /// Optional sort key for render ordering.
  final double? z;

  /// Optional rotation (radians) for rendering orientation.
  final double rotationRad;

  /// Facing direction for choosing sprites/poses.
  final Facing facing;

  /// Whether the entity is grounded at the end of the tick.
  ///
  /// This is authoritative collision state from Core (do not infer from anim).
  final bool grounded;

  /// Logical animation selection (renderer maps to assets).
  final AnimKey anim;

  /// Optional frame hint for deterministic animation in replays/networking.
  final int? animFrame;
}

/// Variant codes for pickup rendering.
///
/// Maps to visual styles (colors, icons) in the renderer.
abstract class PickupVariant {
  static const int collectible = 0;
  static const int restorationHealth = 1;
  static const int restorationMana = 2;
  static const int restorationStamina = 3;
}


===== FILE: lib/core/snapshots/enums.dart =====
/// Protocol-stable enums used by snapshots and the Core→Renderer contract.
///
/// **Stability**: These enums may become part of the network protocol for
/// replays or multiplayer. Avoid renaming or reordering values.
///
/// **Scope**: These are "logical" game concepts, not tied to specific
/// textures or asset names. The renderer maps them to visuals.
library;

/// Logical animation state for entity rendering.
///
/// The renderer maps these to sprite sheets or animation clips.
enum AnimKey {
  idle,
  run,
  jump,
  fall,
  hit,
  cast,
  death,
  spawn,
  attack,
  dash,
}

/// Broad entity classification for rendering and (future) networking.
///
/// Used to select visual style, collision layer, and render order.
enum EntityKind {
  player,
  enemy,
  projectile,
  obstacle,
  pickup,
  hazard,
  trigger,
}

/// Horizontal facing direction for sprites and directional abilities.
enum Facing {
  left,
  right,
}


===== FILE: lib/core/snapshots/game_state_snapshot.dart =====
/// Immutable snapshot of game state for rendering and UI.
///
/// Built by [GameCore] after each fixed simulation tick. This is the primary
/// contract between Core and the Flame/Flutter layer—treat as read-only.
library;

import '../levels/level_id.dart';
import 'entity_render_snapshot.dart';
import 'enums.dart';
import 'player_hud_snapshot.dart';
import 'static_ground_gap_snapshot.dart';
import 'static_solid_snapshot.dart';

/// Complete game state snapshot at a specific simulation tick.
///
/// Contains everything the renderer and UI need: camera position, HUD data,
/// entity list, and static geometry.
class GameStateSnapshot {
  const GameStateSnapshot({
    required this.tick,
    required this.seed,
    required this.levelId,
    required this.themeId,
    required this.distance,
    required this.paused,
    required this.gameOver,
    required this.cameraCenterX,
    required this.cameraCenterY,
    required this.hud,
    required this.entities,
    required this.staticSolids,
    required this.groundGaps,
  });

  /// Current simulation tick.
  final int tick;

  /// Seed used for deterministic generation/RNG.
  final int seed;

  /// Level identifier for this run (stable across sessions).
  final LevelId levelId;

  /// Optional render theme identifier for this run.
  ///
  /// This is Core-owned metadata (pure data) that the renderer can map to
  /// asset paths and visuals without importing any Core gameplay logic.
  final String? themeId;

  /// Distance progressed in the run.
  final double distance;

  /// Whether the simulation is currently paused.
  final bool paused;

  /// Whether the run has ended (simulation is frozen).
  final bool gameOver;

  /// Camera center used for rendering this snapshot.
  final double cameraCenterX;
  final double cameraCenterY;

  /// HUD-only player stats.
  final PlayerHudSnapshot hud;

  /// Render-only entity list for the current tick.
  final List<EntityRenderSnapshot> entities;

  /// Render-only static collision geometry (platforms/obstacles) for this run.
  final List<StaticSolidSnapshot> staticSolids;

  /// Render-only ground gaps (holes in the ground band).
  final List<StaticGroundGapSnapshot> groundGaps;

  /// Returns the player entity snapshot, or `null` if not found.
  ///
  /// Convenience getter to avoid duplicating player-lookup logic across
  /// rendering components.
  EntityRenderSnapshot? get playerEntity {
    for (final e in entities) {
      if (e.kind == EntityKind.player) return e;
    }
    return null;
  }
}


===== FILE: lib/core/snapshots/player_hud_snapshot.dart =====
/// HUD-only player data extracted from Core.
///
/// Separated from entity snapshots so the UI can render player stats
/// (HP bars, cooldowns, etc.) without scanning all entities.
class PlayerHudSnapshot {
  const PlayerHudSnapshot({
    required this.hp,
    required this.hpMax,
    required this.mana,
    required this.manaMax,
    required this.stamina,
    required this.staminaMax,
    required this.canAffordJump,
    required this.canAffordDash,
    required this.canAffordMelee,
    required this.canAffordProjectile,
    required this.canAffordRangedWeapon,
    required this.dashCooldownTicksLeft,
    required this.dashCooldownTicksTotal,
    required this.meleeCooldownTicksLeft,
    required this.meleeCooldownTicksTotal,
    required this.projectileCooldownTicksLeft,
    required this.projectileCooldownTicksTotal,
    required this.rangedWeaponCooldownTicksLeft,
    required this.rangedWeaponCooldownTicksTotal,
    required this.rangedAmmo,
    required this.collectibles,
    required this.collectibleScore,
  });

  /// Current health.
  final double hp;

  /// Maximum health.
  final double hpMax;

  /// Current mana (resource for spells).
  final double mana;

  /// Maximum mana.
  final double manaMax;

  /// Current stamina (resource for physical actions like jump/dash).
  final double stamina;

  /// Maximum stamina.
  final double staminaMax;

  /// Whether stamina is sufficient for jumping.
  final bool canAffordJump;

  /// Whether stamina is sufficient for dashing.
  final bool canAffordDash;

  /// Whether stamina is sufficient for melee.
  final bool canAffordMelee;

  /// Whether mana is sufficient for projectile casting.
  final bool canAffordProjectile;

  /// Whether stamina + ammo are sufficient for the equipped ranged weapon.
  final bool canAffordRangedWeapon;

  /// Remaining dash cooldown ticks.
  final int dashCooldownTicksLeft;

  /// Total dash cooldown ticks.
  final int dashCooldownTicksTotal;

  /// Remaining melee cooldown ticks.
  final int meleeCooldownTicksLeft;

  /// Total melee cooldown ticks.
  final int meleeCooldownTicksTotal;

  /// Remaining projectile cooldown ticks.
  final int projectileCooldownTicksLeft;

  /// Total projectile cooldown ticks.
  final int projectileCooldownTicksTotal;

  /// Remaining ranged weapon cooldown ticks.
  final int rangedWeaponCooldownTicksLeft;

  /// Total ranged weapon cooldown ticks.
  final int rangedWeaponCooldownTicksTotal;

  /// Ammo count for the equipped ranged weapon's ammo type.
  final int rangedAmmo;

  /// Collected collectibles.
  final int collectibles;

  /// Score value earned from collectibles.
  final int collectibleScore;
}


===== FILE: lib/core/snapshots/static_ground_gap_snapshot.dart =====
/// Renderer-facing snapshot for a gap in the ground band.
///
/// This is a read-only view for rendering/debug overlays. Authoritative
/// collision still lives in Core using `StaticWorldGeometry`.
class StaticGroundGapSnapshot {
  const StaticGroundGapSnapshot({
    required this.minX,
    required this.maxX,
  });

  final double minX;
  final double maxX;
}


===== FILE: lib/core/snapshots/static_solid_snapshot.dart =====
/// Renderer-facing snapshot for one piece of static collision geometry.
///
/// This is a read-only view for rendering/debug overlays. Authoritative
/// collision still lives in Core using `StaticWorldGeometry`.
class StaticSolidSnapshot {
  const StaticSolidSnapshot({
    required this.minX,
    required this.minY,
    required this.maxX,
    required this.maxY,
    required this.sides,
    required this.oneWayTop,
  });

  final double minX;
  final double minY;
  final double maxX;
  final double maxY;

  /// Bitmask of enabled faces.
  final int sides;

  /// Whether the top face behaves as one-way (platform).
  final bool oneWayTop;
}



===== FILE: lib/core/spawn_service.dart =====
/// Entity spawning service for GameCore.
///
/// Centralizes all entity creation logic (enemies, collectibles, restoration
/// items) with deterministic placement algorithms. Determinism is critical
/// for replay consistency—given the same seed and chunk index, the same
/// entities spawn at the same positions.
///
/// ## Architecture
///
/// [SpawnService] is owned by [GameCore] and called during:
/// - **Enemy spawning**: When the spawn horizon advances, enemies are placed
///   at fixed X offsets ahead of the camera.
/// - **Chunk generation**: When [TrackManager] streams new chunks,
///   collectibles and restoration items are procedurally scattered.
///
/// ## Determinism Strategy
///
/// All RNG operations use [seedFrom] and [nextUint32] from the deterministic
/// RNG module. Each spawn type uses a unique salt (e.g., `0xC011EC7` for
/// collectibles) XOR'd with the chunk index to ensure:
/// - Same seed + chunk → same spawn pattern
/// - Different chunks → independent sequences
/// - Different spawn types → no correlation
///
/// ## Placement Algorithm
///
/// For collectibles and restoration items:
/// 1. Compute valid X range (chunk bounds minus edge margins).
/// 2. Generate random X, snap to grid.
/// 3. Query the [SurfaceGraph] for the highest platform at that X.
/// 4. Place item above the surface with clearance.
/// 5. Reject if overlapping solids or existing entities.
/// 6. Retry up to `maxAttempts` times.
library;

import 'ecs/entity_id.dart';
import 'ecs/entity_factory.dart';
import 'ecs/hit/aabb_hit_utils.dart';
import 'ecs/stores/body_store.dart';
import 'ecs/stores/collider_aabb_store.dart';
import 'ecs/stores/collectible_store.dart';
import 'ecs/stores/restoration_item_store.dart';
import 'ecs/world.dart';
import 'enemies/enemy_catalog.dart';
import 'enemies/enemy_id.dart';
import 'navigation/types/nav_tolerances.dart';
import 'navigation/types/surface_graph.dart';
import 'navigation/utils/surface_spatial_index.dart';
import 'snapshots/enums.dart';
import 'tuning/collectible_tuning.dart';
import 'tuning/flying_enemy_tuning.dart';
import 'tuning/movement_tuning.dart';
import 'tuning/restoration_item_tuning.dart';
import 'tuning/track_tuning.dart';
import 'util/deterministic_rng.dart';

// ─────────────────────────────────────────────────────────────────────────────
// RNG Salt Constants
// ─────────────────────────────────────────────────────────────────────────────

/// RNG salt for collectible spawn positions ("COLLECT" in hex-speak).
const int _collectibleSalt = 0xC011EC7;

/// RNG salt for restoration item spawn phase offset ("ALTESAT" - alternate stat).
const int _restorationPhaseSalt = 0xA17E5A7;

/// RNG salt for restoration item spawn positions ("ASTALL" - a stall/restore).
const int _restorationSpawnSalt = 0xA57A11;

// ─────────────────────────────────────────────────────────────────────────────
// SpawnService
// ─────────────────────────────────────────────────────────────────────────────

/// Service for spawning game entities with deterministic, seeded placement.
///
/// Handles creation of:
/// - **Flying enemies**: Hover above ground, cast projectiles.
/// - **Ground enemies**: Walk on platforms, chase player.
/// - **Collectibles**: Score pickups scattered across chunks.
/// - **Restoration items**: Health/mana/stamina orbs on periodic chunks.
///
/// Usage:
/// ```dart
/// final spawner = SpawnService(world: ..., seed: 42, ...);
/// spawner.setSurfaceGraph(graph: navGraph, spatialIndex: index);
/// spawner.spawnUnocoDemon(spawnX: 500, groundTopY: 0);
/// spawner.spawnCollectiblesForChunk(chunkIndex: 3, ...);
/// ```
class SpawnService {
  /// Creates a spawn service with the given dependencies.
  ///
  /// - [world]: ECS world for entity creation and component access.
  /// - [entityFactory]: Factory for creating complex entities (enemies).
  /// - [enemyCatalog]: Archetype definitions for enemy types.
  /// - [unocoDemonTuning]: Flying enemy hover offset and cooldowns.
  /// - [movement]: Movement tuning for ground enemy velocity limits.
  /// - [collectibleTuning]: Spawn density, spacing, and margins.
  /// - [restorationItemTuning]: Spawn frequency and item sizing.
  /// - [trackTuning]: Chunk dimensions and grid snap settings.
  /// - [seed]: Master RNG seed for deterministic spawning.
  SpawnService({
    required EcsWorld world,
    required EntityFactory entityFactory,
    required EnemyCatalog enemyCatalog,
    required UnocoDemonTuningDerived unocoDemonTuning,
    required MovementTuningDerived movement,
    required CollectibleTuning collectibleTuning,
    required RestorationItemTuning restorationItemTuning,
    required TrackTuning trackTuning,
    required int seed,
  }) : _world = world,
       _entityFactory = entityFactory,
       _enemyCatalog = enemyCatalog,
       _unocoDemonTuning = unocoDemonTuning,
       _movement = movement,
       _collectibleTuning = collectibleTuning,
       _restorationItemTuning = restorationItemTuning,
       _trackTuning = trackTuning,
       _seed = seed;

  // ─── Dependencies ───
  final EcsWorld _world;
  final EntityFactory _entityFactory;
  final EnemyCatalog _enemyCatalog;
  final UnocoDemonTuningDerived _unocoDemonTuning;
  final MovementTuningDerived _movement;
  final CollectibleTuning _collectibleTuning;
  final RestorationItemTuning _restorationItemTuning;
  final TrackTuning _trackTuning;
  final int _seed;

  // ─── Scratch buffers (reused to avoid allocation) ───

  /// X positions of collectibles spawned in the current chunk (for spacing).
  final List<double> _collectibleSpawnXs = <double>[];

  /// Surface indices returned by spatial queries.
  final List<int> _surfaceQueryCandidates = <int>[];

  // ─── Surface graph state (updated by TrackManager) ───
  SurfaceGraph? _surfaceGraph;
  SurfaceSpatialIndex? _surfaceSpatialIndex;
  double _surfaceMinY = 0.0;
  double _surfaceMaxY = 0.0;

  // ───────────────────────────────────────────────────────────────────────────
  // Surface Graph Management
  // ───────────────────────────────────────────────────────────────────────────

  /// Updates the navigation surface graph for item placement queries.
  ///
  /// Called by [TrackManager] whenever the track geometry changes.
  /// The surface graph provides platform positions for placing items
  /// "on top of" surfaces rather than floating in mid-air.
  ///
  /// Also caches the Y-axis bounds for efficient spatial queries.
  void setSurfaceGraph({
    required SurfaceGraph? graph,
    required SurfaceSpatialIndex? spatialIndex,
  }) {
    _surfaceGraph = graph;
    _surfaceSpatialIndex = spatialIndex;
    _surfaceMinY = 0.0;
    _surfaceMaxY = 0.0;

    // Pre-compute Y bounds to avoid repeated iteration during queries.
    if (graph != null && graph.surfaces.isNotEmpty) {
      var minY = graph.surfaces.first.yTop;
      var maxY = minY;
      for (var i = 1; i < graph.surfaces.length; i += 1) {
        final y = graph.surfaces[i].yTop;
        if (y < minY) minY = y;
        if (y > maxY) maxY = y;
      }
      _surfaceMinY = minY;
      _surfaceMaxY = maxY;
    }
  }

  // ───────────────────────────────────────────────────────────────────────────
  // Enemy Spawning
  // ───────────────────────────────────────────────────────────────────────────

  /// Spawns the Unoco Demon at [spawnX], hovering above [groundTopY].
  ///
  /// Flying enemies are placed at a fixed vertical offset above the ground
  /// (defined by [UnocoDemonTuning.unocoDemonHoverOffsetY]). They don't
  /// use gravity and will begin AI behavior on the next tick.
  ///
  /// The enemy's cast cooldown is pre-set to avoid immediate projectile
  /// spam on the spawn tick—this keeps early-game pacing predictable.
  ///
  /// Returns the [EntityId] of the newly created enemy.
  EntityId spawnUnocoDemon({
    required double spawnX,
    required double groundTopY,
  }) {
    final archetype = _enemyCatalog.get(EnemyId.unocoDemon);
    final unocoDemon = _entityFactory.createEnemy(
      enemyId: EnemyId.unocoDemon,
      posX: spawnX,
      posY: groundTopY - _unocoDemonTuning.base.unocoDemonHoverOffsetY,
      velX: 0.0,
      velY: 0.0,
      facing: Facing.left,
      body: archetype.body,
      collider: archetype.collider,
      health: archetype.health,
      mana: archetype.mana,
      stamina: archetype.stamina,
      tags: archetype.tags,
      resistance: archetype.resistance,
      statusImmunity: archetype.statusImmunity,
    );

    // Pre-set cooldown to prevent immediate casting on spawn tick.
    // This ensures consistent early-game difficulty across runs.
    _world.cooldown.castCooldownTicksLeft[_world.cooldown.indexOf(
          unocoDemon,
        )] =
        _unocoDemonTuning.unocoDemonCastCooldownTicks;

    return unocoDemon;
  }

  /// Spawns a ground enemy at [spawnX], standing on [groundTopY].
  ///
  /// Ground enemies use gravity and collision. Their Y position is
  /// computed so their collider's bottom edge rests on the ground surface.
  ///
  /// The enemy inherits movement velocity limits from [MovementTuning]
  /// to ensure consistent chase behavior relative to player speed.
  ///
  /// Returns the [EntityId] of the newly created enemy.
  EntityId spawnGroundEnemy({
    required double spawnX,
    required double groundTopY,
  }) {
    final archetype = _enemyCatalog.get(EnemyId.groundEnemy);

    // Position so collider bottom touches ground.
    return _entityFactory.createEnemy(
      enemyId: EnemyId.groundEnemy,
      posX: spawnX,
      posY: groundTopY - archetype.collider.halfY,
      velX: 0.0,
      velY: 0.0,
      facing: Facing.left,
      body: BodyDef(
        enabled: archetype.body.enabled,
        isKinematic: archetype.body.isKinematic,
        useGravity: archetype.body.useGravity,
        ignoreCeilings: archetype.body.ignoreCeilings,
        topOnlyGround: archetype.body.topOnlyGround,
        gravityScale: archetype.body.gravityScale,
        maxVelX: _movement.base.maxVelX,
        maxVelY: _movement.base.maxVelY,
        sideMask: archetype.body.sideMask,
      ),
      collider: archetype.collider,
      health: archetype.health,
      mana: archetype.mana,
      stamina: archetype.stamina,
      tags: archetype.tags,
      resistance: archetype.resistance,
      statusImmunity: archetype.statusImmunity,
    );
  }

  // ───────────────────────────────────────────────────────────────────────────
  // Collectible & Restoration Item Spawning
  // ───────────────────────────────────────────────────────────────────────────

  /// Spawns a single collectible at the given world position.
  ///
  /// Collectibles are stationary pickups that grant score when touched.
  /// They have an AABB collider for overlap detection but no physics body.
  ///
  /// Prefer [spawnCollectiblesForChunk] for procedural placement.
  EntityId spawnCollectibleAt(double x, double y) {
    final half = _collectibleTuning.collectibleSize * 0.5;
    final entity = _world.createEntity();
    _world.transform.add(entity, posX: x, posY: y, velX: 0.0, velY: 0.0);
    _world.colliderAabb.add(entity, ColliderAabbDef(halfX: half, halfY: half));
    _world.collectible.add(
      entity,
      CollectibleDef(value: _collectibleTuning.valuePerCollectible),
    );
    return entity;
  }

  /// Spawns a restoration item at the given world position.
  ///
  /// Restoration items restore the specified [stat] (health, mana, or
  /// stamina) when collected. Like collectibles, they're stationary with
  /// an AABB collider.
  ///
  /// Prefer [spawnRestorationItemForChunk] for procedural placement.
  EntityId spawnRestorationItemAt(double x, double y, RestorationStat stat) {
    final half = _restorationItemTuning.itemSize * 0.5;
    final entity = _world.createEntity();
    _world.transform.add(entity, posX: x, posY: y, velX: 0.0, velY: 0.0);
    _world.colliderAabb.add(entity, ColliderAabbDef(halfX: half, halfY: half));
    _world.restorationItem.add(entity, RestorationItemDef(stat: stat));
    return entity;
  }

  /// Spawns collectibles for a track chunk using deterministic placement.
  ///
  /// This method:
  /// 1. Skips if collectibles are disabled or chunk is too early.
  /// 2. Determines spawn count from RNG (between min and max per chunk).
  /// 3. For each collectible, picks a random X within chunk bounds.
  /// 4. Snaps X to grid and enforces minimum spacing between items.
  /// 5. Queries the highest surface at that X for vertical placement.
  /// 6. Rejects positions overlapping platforms or existing items.
  ///
  /// The RNG is seeded with `seed XOR chunkIndex XOR 0xC011EC7` to ensure
  /// deterministic but unique sequences per chunk.
  void spawnCollectiblesForChunk({
    required int chunkIndex,
    required double chunkStartX,
    required List<StaticSolid> solids,
  }) {
    final tuning = _collectibleTuning;

    // ─── Early-out checks ───
    if (!tuning.enabled) return;
    if (chunkIndex < tuning.spawnStartChunkIndex) return;
    if (tuning.maxPerChunk <= 0) return;

    final graph = _surfaceGraph;
    final spatialIndex = _surfaceSpatialIndex;
    if (graph == null || spatialIndex == null || graph.surfaces.isEmpty) {
      return;
    }

    // ─── Compute valid X range ───
    final minX = chunkStartX + tuning.chunkEdgeMarginX;
    final maxX =
        chunkStartX + _trackTuning.chunkWidth - tuning.chunkEdgeMarginX;
    if (maxX <= minX) return;

    // ─── Initialize RNG and determine target count ───
    var rngState = seedFrom(_seed, chunkIndex ^ _collectibleSalt);
    rngState = nextUint32(rngState);
    final countRange = tuning.maxPerChunk - tuning.minPerChunk + 1;
    final targetCount = tuning.minPerChunk + (rngState % countRange);
    if (targetCount <= 0) return;

    // ─── Spawn loop with rejection sampling ───
    _collectibleSpawnXs.clear();
    final halfSize = tuning.collectibleSize * 0.5;
    final maxAttempts = tuning.maxAttemptsPerChunk;

    for (
      var attempt = 0;
      attempt < maxAttempts && _collectibleSpawnXs.length < targetCount;
      attempt += 1
    ) {
      // Generate candidate X position.
      rngState = nextUint32(rngState);
      var x = rangeDouble(rngState, minX, maxX);
      x = _snapToGrid(x, _trackTuning.gridSnap);
      if (x < minX || x > maxX) continue;

      // Enforce minimum spacing from already-spawned collectibles.
      if (tuning.minSpacingX > 0.0) {
        var spaced = true;
        for (final prevX in _collectibleSpawnXs) {
          if ((prevX - x).abs() < tuning.minSpacingX) {
            spaced = false;
            break;
          }
        }
        if (!spaced) continue;
      }

      // Find surface Y and compute item center position.
      final surfaceY = _highestSurfaceYAtX(x);
      if (surfaceY == null) continue;
      final centerY = surfaceY - tuning.surfaceClearanceY - halfSize;

      // Reject if overlapping static geometry.
      if (_overlapsAnySolid(
        centerX: x,
        centerY: centerY,
        halfSize: halfSize,
        margin: tuning.noSpawnMargin,
        solids: solids,
      )) {
        continue;
      }

      // Success—spawn and record position.
      spawnCollectibleAt(x, centerY);
      _collectibleSpawnXs.add(x);
    }
  }

  /// Spawns a restoration item for a chunk if eligible.
  ///
  /// Restoration items spawn on a periodic schedule (e.g., every N chunks)
  /// with a phase offset derived from the seed to avoid predictable timing.
  ///
  /// The item type is determined by [lowestResourceStat], which should
  /// return the player's most depleted resource (health, mana, or stamina).
  ///
  /// Placement follows the same rejection-sampling algorithm as collectibles,
  /// with an additional check to avoid overlapping existing collectibles.
  void spawnRestorationItemForChunk({
    required int chunkIndex,
    required double chunkStartX,
    required List<StaticSolid> solids,
    required RestorationStat Function() lowestResourceStat,
  }) {
    final tuning = _restorationItemTuning;

    // ─── Early-out checks ───
    if (!tuning.enabled) return;
    if (chunkIndex < tuning.spawnStartChunkIndex) return;
    if (tuning.spawnEveryChunks <= 0) return;

    // ─── Periodic spawn check (with seeded phase offset) ───
    final phase =
        seedFrom(_seed, _restorationPhaseSalt) % tuning.spawnEveryChunks;
    if ((chunkIndex - phase) % tuning.spawnEveryChunks != 0) return;

    final graph = _surfaceGraph;
    final spatialIndex = _surfaceSpatialIndex;
    if (graph == null || spatialIndex == null || graph.surfaces.isEmpty) {
      return;
    }

    // ─── Compute valid X range ───
    final minX = chunkStartX + tuning.chunkEdgeMarginX;
    final maxX =
        chunkStartX + _trackTuning.chunkWidth - tuning.chunkEdgeMarginX;
    if (maxX <= minX) return;

    // ─── Determine which stat to restore ───
    final stat = lowestResourceStat();

    // ─── Spawn with rejection sampling ───
    var rngState = seedFrom(_seed, chunkIndex ^ _restorationSpawnSalt);
    final halfSize = tuning.itemSize * 0.5;

    for (var attempt = 0; attempt < tuning.maxAttemptsPerSpawn; attempt += 1) {
      rngState = nextUint32(rngState);
      var x = rangeDouble(rngState, minX, maxX);
      x = _snapToGrid(x, _trackTuning.gridSnap);
      if (x < minX || x > maxX) continue;

      final surfaceY = _highestSurfaceYAtX(x);
      if (surfaceY == null) continue;
      final centerY = surfaceY - tuning.surfaceClearanceY - halfSize;

      // Reject if overlapping static geometry.
      if (_overlapsAnySolid(
        centerX: x,
        centerY: centerY,
        halfSize: halfSize,
        margin: tuning.noSpawnMargin,
        solids: solids,
      )) {
        continue;
      }

      // Reject if overlapping existing collectibles.
      if (_overlapsAnyCollectible(
        centerX: x,
        centerY: centerY,
        halfSize: halfSize,
        margin: tuning.noSpawnMargin,
      )) {
        continue;
      }

      // Success—spawn and exit.
      spawnRestorationItemAt(x, centerY, stat);
      return;
    }
  }

  // ───────────────────────────────────────────────────────────────────────────
  // Private Helpers
  // ───────────────────────────────────────────────────────────────────────────

  /// Snaps [x] to the nearest multiple of [grid].
  ///
  /// Grid snapping ensures items align visually with the track's tile grid,
  /// avoiding sub-pixel positioning artifacts.
  double _snapToGrid(double x, double grid) {
    if (grid <= 0) return x;
    return (x / grid).roundToDouble() * grid;
  }

  /// Returns the Y coordinate of the highest surface at [x], or null if none.
  ///
  /// Uses the [SurfaceSpatialIndex] for efficient lookup, then filters
  /// candidates to find the topmost platform. Ties are broken by surface ID
  /// for determinism.
  double? _highestSurfaceYAtX(double x) {
    final graph = _surfaceGraph;
    final spatialIndex = _surfaceSpatialIndex;
    if (graph == null || spatialIndex == null || graph.surfaces.isEmpty) {
      return null;
    }

    // Query all surfaces that might contain X.
    final minY = _surfaceMinY - navSpatialEps;
    final maxY = _surfaceMaxY + navSpatialEps;
    _surfaceQueryCandidates.clear();
    spatialIndex.queryAabb(
      minX: x - navSpatialEps,
      minY: minY,
      maxX: x + navSpatialEps,
      maxY: maxY,
      outSurfaceIndices: _surfaceQueryCandidates,
    );

    // Find highest (smallest Y in screen coords) surface containing X.
    double? bestY;
    int? bestId;
    for (final i in _surfaceQueryCandidates) {
      final s = graph.surfaces[i];
      if (x < s.xMin - navGeomEps || x > s.xMax + navGeomEps) continue;

      // Prefer lower Y (higher on screen). Break ties by ID for determinism.
      if (bestY == null || s.yTop < bestY - navTieEps) {
        bestY = s.yTop;
        bestId = s.id;
      } else if ((s.yTop - bestY).abs() <= navTieEps && s.id < bestId!) {
        bestY = s.yTop;
        bestId = s.id;
      }
    }

    return bestY;
  }

  /// Checks if an AABB centered at ([centerX], [centerY]) overlaps any solid.
  ///
  /// The AABB is expanded by [margin] to prevent items from spawning too
  /// close to platform edges.
  bool _overlapsAnySolid({
    required double centerX,
    required double centerY,
    required double halfSize,
    required double margin,
    required List<StaticSolid> solids,
  }) {
    if (solids.isEmpty) return false;

    // Expand bounds by half-size and margin.
    final minX = centerX - halfSize - margin;
    final maxX = centerX + halfSize + margin;
    final minY = centerY - halfSize - margin;
    final maxY = centerY + halfSize + margin;

    for (final solid in solids) {
      final overlaps = aabbOverlapsMinMax(
        aMinX: minX,
        aMaxX: maxX,
        aMinY: minY,
        aMaxY: maxY,
        bMinX: solid.minX,
        bMaxX: solid.maxX,
        bMinY: solid.minY,
        bMaxY: solid.maxY,
      );
      if (overlaps) return true;
    }
    return false;
  }

  /// Checks if an AABB overlaps any existing collectible entity.
  ///
  /// Used by restoration item spawning to avoid stacking pickups.
  bool _overlapsAnyCollectible({
    required double centerX,
    required double centerY,
    required double halfSize,
    required double margin,
  }) {
    final collectibles = _world.collectible;
    if (collectibles.denseEntities.isEmpty) return false;

    final minX = centerX - halfSize - margin;
    final maxX = centerX + halfSize + margin;
    final minY = centerY - halfSize - margin;
    final maxY = centerY + halfSize + margin;

    for (var ci = 0; ci < collectibles.denseEntities.length; ci += 1) {
      final e = collectibles.denseEntities[ci];
      if (!(_world.transform.has(e) && _world.colliderAabb.has(e))) continue;

      // Read collectible's world-space AABB.
      final ti = _world.transform.indexOf(e);
      final ai = _world.colliderAabb.indexOf(e);
      final cx = _world.transform.posX[ti] + _world.colliderAabb.offsetX[ai];
      final cy = _world.transform.posY[ti] + _world.colliderAabb.offsetY[ai];

      final overlaps = aabbOverlapsMinMax(
        aMinX: minX,
        aMaxX: maxX,
        aMinY: minY,
        aMaxY: maxY,
        bMinX: cx - _world.colliderAabb.halfX[ai],
        bMaxX: cx + _world.colliderAabb.halfX[ai],
        bMinY: cy - _world.colliderAabb.halfY[ai],
        bMaxY: cy + _world.colliderAabb.halfY[ai],
      );
      if (overlaps) return true;
    }

    return false;
  }
}

// ─────────────────────────────────────────────────────────────────────────────
// Supporting Types
// ─────────────────────────────────────────────────────────────────────────────

/// Axis-aligned bounding box for static world geometry.
///
/// Used by [SpawnService] for overlap rejection during item placement.
/// Re-exported here to avoid circular imports with collision module.
typedef StaticSolid = ({double minX, double maxX, double minY, double maxY});


===== FILE: lib/core/spells/spawn_spell_projectile.dart =====
/// Projectile spawning utilities for spell casting.
///
/// Centralizes direction normalization and projectile entity creation so
/// player and enemy casting behave consistently.
library;

import 'dart:math';

import '../combat/damage_type.dart';
import '../combat/faction.dart';
import '../combat/status/status.dart';
import '../ecs/entity_id.dart';
import '../ecs/stores/collider_aabb_store.dart';
import '../ecs/stores/lifetime_store.dart';
import '../ecs/stores/projectile_store.dart';
import '../ecs/stores/spell_origin_store.dart';
import '../ecs/world.dart';
import '../projectiles/projectile_catalog.dart';
import '../projectiles/projectile_id.dart';
import 'spell_catalog.dart';
import 'spell_id.dart';

/// Epsilon squared for near-zero direction detection.
const _dirEps2 = 1e-12;

/// Normalizes a direction vector, falling back if near-zero.
({double x, double y}) _normalizeDirOrFallback(
  double x,
  double y, {
  required double fallbackX,
  required double fallbackY,
}) {
  final len2 = x * x + y * y;

  // Primary direction too small – try fallback.
  if (len2 <= _dirEps2) {
    final fbLen2 = fallbackX * fallbackX + fallbackY * fallbackY;
    // Fallback also degenerate – default to rightward.
    if (fbLen2 <= _dirEps2) {
      return (x: 1.0, y: 0.0);
    }
    final invLen = 1.0 / sqrt(fbLen2);
    return (x: fallbackX * invLen, y: fallbackY * invLen);
  }

  // Normal case: normalize primary direction.
  final invLen = 1.0 / sqrt(len2);
  return (x: x * invLen, y: y * invLen);
}

/// Internal: creates the projectile entity with all required components.
EntityId _spawnResolvedSpellProjectile(
  EcsWorld world, {
  required ProjectileCatalogDerived projectiles,
  required SpellId spellId,
  required ProjectileId projectileId,
  required Faction faction,
  required EntityId owner,
  required double originX,
  required double originY,
  required double dirX,
  required double dirY,
  required double speedUnitsPerSecond,
  required double damage,
  required DamageType damageType,
  required StatusProfileId statusProfileId,
}) {
  // Lookup base projectile def for collider dimensions.
  final proj = projectiles.base.get(projectileId);
  final halfX = proj.colliderSizeX * 0.5;
  final halfY = proj.colliderSizeY * 0.5;

  // Allocate entity ID.
  final entity = world.createEntity();

  // Position at spawn origin; velocity applied by ProjectileSystem.
  world.transform.add(
    entity,
    posX: originX,
    posY: originY,
    velX: 0.0,
    velY: 0.0,
  );

  // Combat data: direction, speed, faction for hit resolution.
  world.projectile.add(
    entity,
    ProjectileDef(
      projectileId: projectileId,
      faction: faction,
      owner: owner,
      dirX: dirX,
      dirY: dirY,
      speedUnitsPerSecond: speedUnitsPerSecond,
      damage: damage,
      damageType: damageType,
      statusProfileId: statusProfileId,
    ),
  );

  // Track originating spell for FX/scoring.
  world.spellOrigin.add(entity, SpellOriginDef(spellId: spellId));

  // Auto-destroy after catalog-defined lifetime.
  world.lifetime.add(
    entity,
    LifetimeDef(ticksLeft: projectiles.lifetimeTicks(projectileId)),
  );

  // AABB for collision detection against actors.
  world.colliderAabb.add(entity, ColliderAabbDef(halfX: halfX, halfY: halfY));

  return entity;
}

/// Spawns a spell projectile from a caster position with a consistent origin
/// offset along the cast direction.
///
/// Call sites should pass the raw direction (e.g. aim vector, target delta) and
/// a normalized fallback (e.g. facing direction). This function normalizes once
/// and guarantees consistent behavior across player/enemy casting.
EntityId? spawnSpellProjectileFromCaster(
  EcsWorld world, {
  required SpellCatalog spells,
  required ProjectileCatalogDerived projectiles,
  required SpellId spellId,
  required Faction faction,
  required EntityId owner,
  required double casterX,
  required double casterY,
  required double originOffset,
  required double dirX,
  required double dirY,
  required double fallbackDirX,
  required double fallbackDirY,
}) {
  // Bail early if spell doesn't spawn a projectile.
  final spell = spells.get(spellId);
  final projectileId = spell.projectileId;
  if (projectileId == null) return null;

  // Normalize aim; use fallback (e.g. facing) if aim is zero.
  final dir = _normalizeDirOrFallback(
    dirX,
    dirY,
    fallbackX: fallbackDirX,
    fallbackY: fallbackDirY,
  );

  // Offset spawn along direction so projectile starts outside caster.
  final originX = casterX + dir.x * originOffset;
  final originY = casterY + dir.y * originOffset;

  return _spawnResolvedSpellProjectile(
    world,
    projectiles: projectiles,
    spellId: spellId,
    projectileId: projectileId,
    faction: faction,
    owner: owner,
    originX: originX,
    originY: originY,
    dirX: dir.x,
    dirY: dir.y,
    speedUnitsPerSecond: projectiles.base.get(projectileId).speedUnitsPerSecond,
    damage: spell.stats.damage,
    damageType: spell.stats.damageType,
    statusProfileId: spell.stats.statusProfileId,
  );
}

/// Spawns a spell projectile at an explicit origin position.
///
/// Use this when the spawn point is already computed. Direction is normalized
/// internally; falls back to rightward (1, 0) if near-zero.
///
/// Returns `null` if the spell has no associated projectile.
EntityId? spawnSpellProjectile(
  EcsWorld world, {
  required SpellCatalog spells,
  required ProjectileCatalogDerived projectiles,
  required SpellId spellId,
  required Faction faction,
  required EntityId owner,
  required double originX,
  required double originY,
  required double dirX,
  required double dirY,
}) {
  // Bail early if spell doesn't spawn a projectile.
  final spell = spells.get(spellId);
  final projectileId = spell.projectileId;
  if (projectileId == null) return null;

  // Normalize; default rightward if degenerate.
  final dir = _normalizeDirOrFallback(
    dirX,
    dirY,
    fallbackX: 1.0,
    fallbackY: 0.0,
  );

  return _spawnResolvedSpellProjectile(
    world,
    projectiles: projectiles,
    spellId: spellId,
    projectileId: projectileId,
    faction: faction,
    owner: owner,
    originX: originX,
    originY: originY,
    dirX: dir.x,
    dirY: dir.y,
    speedUnitsPerSecond: projectiles.base.get(projectileId).speedUnitsPerSecond,
    damage: spell.stats.damage,
    damageType: spell.stats.damageType,
    statusProfileId: spell.stats.statusProfileId,
  );
}


===== FILE: lib/core/spells/spell_catalog.dart =====
import '../combat/damage_type.dart';
import '../combat/status/status.dart';
import '../projectiles/projectile_id.dart';
import 'spell_id.dart';

/// Combat stats for a projectile-based spell.
class ProjectileSpellStats {
  const ProjectileSpellStats({
    required this.manaCost,
    required this.damage,
    this.damageType = DamageType.physical,
    this.statusProfileId = StatusProfileId.none,
  });

  /// Mana consumed when casting.
  final double manaCost;

  /// Damage dealt on hit.
  final double damage;

  /// Damage type used for resistance/vulnerability rules.
  final DamageType damageType;

  /// Optional status profile applied on hit.
  final StatusProfileId statusProfileId;
}

/// Definition of a spell's properties.
///
/// Separates spell stats (cost, damage) from projectile stats (speed, size)
/// so the same projectile can be used by multiple spells with different values.
class SpellDef {
  const SpellDef({
    required this.stats,
    required this.projectileId,
  });

  /// Combat stats (resource cost, damage).
  final ProjectileSpellStats stats;

  /// Projectile type to spawn, or `null` for non-projectile spells.
  final ProjectileId? projectileId;
}

/// Lookup table for spell definitions by [SpellId].
class SpellCatalog {
  const SpellCatalog();

  /// Returns the definition for the given spell.
  SpellDef get(SpellId id) {
    switch (id) {
      case SpellId.iceBolt:
        return const SpellDef(
          stats: ProjectileSpellStats(
            manaCost: 10.0,
            damage: 15.0,
            damageType: DamageType.ice,
            statusProfileId: StatusProfileId.iceBolt,
          ),
          projectileId: ProjectileId.iceBolt,
        );
      case SpellId.lightning:
        return const SpellDef(
          stats: ProjectileSpellStats(
            manaCost: 10.0,
            damage: 5.0,
            damageType: DamageType.lightning,
          ),
          projectileId: ProjectileId.lightningBolt,
        );
    }
  }
}


===== FILE: lib/core/spells/spell_id.dart =====
/// Identifies a spell type for catalog lookup and casting.
///
/// Each ID maps to a [SpellDef] in [SpellCatalog] defining costs,
/// damage, and the associated projectile (if any).
enum SpellId {
  /// Player's primary ranged attack.
  iceBolt,

  /// Enemy ranged attack.
  lightning,
}



===== FILE: lib/core/track/chunk_builder.dart =====
/// Chunk geometry builder functions for track streaming.
///
/// Converts chunk-relative pattern definitions into world-space collision
/// geometry ([StaticSolid], [StaticGroundSegment], [StaticGroundGap]).
library;

import '../collision/static_world_geometry.dart';
import 'chunk_pattern.dart';

/// Result of building ground geometry from a chunk pattern.
class GroundBuildResult {
  const GroundBuildResult({
    required this.segments,
    required this.gaps,
  });

  /// Walkable ground spans (between gaps).
  final List<StaticGroundSegment> segments;

  /// Pit/gap spans.
  final List<StaticGroundGap> gaps;
}

/// Converts pattern platforms/obstacles into world-space [StaticSolid]s.
///
/// [pattern] - The chunk pattern containing platforms and obstacles.
/// [chunkStartX] - World X where this chunk begins.
/// [chunkIndex] - Sequential chunk number for tagging solids.
/// [groundTopY] - World Y of the ground surface.
/// [chunkWidth] - Width of a chunk (for bounds checking).
/// [gridSnap] - Grid snap value (for alignment checking).
List<StaticSolid> buildSolids(
  ChunkPattern pattern, {
  required double chunkStartX,
  required int chunkIndex,
  required double groundTopY,
  required double chunkWidth,
  required double gridSnap,
}) {
  // Preserve author ordering for determinism.
  final solids = <StaticSolid>[];
  var localSolidIndex = 0;

  // ── Platforms (one-way top) ──
  for (final p in pattern.platforms) {
    assert(
      _withinChunk(p.x, p.width, chunkWidth),
      'Platform out of chunk bounds: ${pattern.name}',
    );
    assert(
      _snapped(p.x, gridSnap) &&
          _snapped(p.width, gridSnap) &&
          _snapped(p.aboveGroundTop, gridSnap),
      'Platform not snapped to grid: ${pattern.name}',
    );
    final topY = groundTopY - p.aboveGroundTop;
    solids.add(
      StaticSolid(
        minX: chunkStartX + p.x,
        minY: topY,
        maxX: chunkStartX + p.x + p.width,
        maxY: topY + p.thickness,
        sides: StaticSolid.sideTop,
        oneWayTop: true,
        chunkIndex: chunkIndex,
        localSolidIndex: localSolidIndex,
      ),
    );
    localSolidIndex += 1;
  }

  // ── Obstacles (solid on all sides) ──
  for (final o in pattern.obstacles) {
    assert(
      _withinChunk(o.x, o.width, chunkWidth),
      'Obstacle out of chunk bounds: ${pattern.name}',
    );
    assert(
      _snapped(o.x, gridSnap) &&
          _snapped(o.width, gridSnap) &&
          _snapped(o.height, gridSnap),
      'Obstacle not snapped to grid: ${pattern.name}',
    );
    solids.add(
      StaticSolid(
        minX: chunkStartX + o.x,
        minY: groundTopY - o.height,
        maxX: chunkStartX + o.x + o.width,
        maxY: groundTopY,
        sides: StaticSolid.sideAll,
        oneWayTop: false,
        chunkIndex: chunkIndex,
        localSolidIndex: localSolidIndex,
      ),
    );
    localSolidIndex += 1;
  }

  return solids;
}

/// Builds ground segments by splitting at gap positions.
///
/// Gaps are sorted by X, then segments fill the remaining spans.
///
/// [pattern] - The chunk pattern containing ground gaps.
/// [chunkStartX] - World X where this chunk begins.
/// [chunkIndex] - Sequential chunk number for tagging segments.
/// [groundTopY] - World Y of the ground surface.
/// [chunkWidth] - Width of a chunk.
/// [gridSnap] - Grid snap value (for alignment checking).
GroundBuildResult buildGroundSegments(
  ChunkPattern pattern, {
  required double chunkStartX,
  required int chunkIndex,
  required double groundTopY,
  required double chunkWidth,
  required double gridSnap,
}) {
  // Sort gaps left-to-right for sequential processing.
  final orderedGaps = List<GapRel>.from(pattern.groundGaps);
  if (orderedGaps.isNotEmpty) {
    orderedGaps.sort((a, b) => a.x.compareTo(b.x));
  }

  final segments = <StaticGroundSegment>[];
  final gaps = <StaticGroundGap>[];
  var cursor = 0.0; // Tracks end of last segment/gap.
  var localSegmentIndex = 0;
  var lastGapEnd = -1.0; // For overlap assertion.

  for (final gap in orderedGaps) {
    assert(
      _withinChunk(gap.x, gap.width, chunkWidth),
      'Ground gap out of chunk bounds: ${pattern.name}',
    );
    assert(
      _snapped(gap.x, gridSnap) && _snapped(gap.width, gridSnap),
      'Ground gap not snapped to grid: ${pattern.name}',
    );
    assert(
      gap.x >= lastGapEnd - 1e-6,
      'Ground gap overlaps previous: ${pattern.name}',
    );

    final gapStart = gap.x;
    final gapEnd = gap.x + gap.width;

    // Emit segment from cursor to gap start (if non-empty).
    if (gapStart > cursor + 1e-6) {
      segments.add(
        StaticGroundSegment(
          minX: chunkStartX + cursor,
          maxX: chunkStartX + gapStart,
          topY: groundTopY,
          chunkIndex: chunkIndex,
          localSegmentIndex: localSegmentIndex,
        ),
      );
      localSegmentIndex += 1;
    }

    // Record gap for collision/rendering.
    gaps.add(
      StaticGroundGap(
        minX: chunkStartX + gapStart,
        maxX: chunkStartX + gapEnd,
      ),
    );

    // Advance cursor past gap.
    cursor = gapEnd > cursor ? gapEnd : cursor;
    lastGapEnd = gapEnd;
  }

  // Emit trailing segment from last gap to chunk end.
  if (cursor < chunkWidth - 1e-6) {
    segments.add(
      StaticGroundSegment(
        minX: chunkStartX + cursor,
        maxX: chunkStartX + chunkWidth,
        topY: groundTopY,
        chunkIndex: chunkIndex,
        localSegmentIndex: localSegmentIndex,
      ),
    );
  }

  return GroundBuildResult(segments: segments, gaps: gaps);
}

/// Checks if a span [x, x+width] fits within [0, chunkWidth].
bool _withinChunk(double x, double width, double chunkWidth) {
  return x >= 0.0 && (x + width) <= chunkWidth;
}

/// Checks if a value is snapped to the grid.
bool _snapped(double v, double gridSnap) {
  final snapped = (v / gridSnap).roundToDouble() * gridSnap;
  return (v - snapped).abs() < 1e-9;
}


===== FILE: lib/core/track/chunk_pattern.dart =====
/// Chunk pattern data structures for track streaming.
///
/// Defines the authored building blocks (platforms, obstacles, gaps, spawns)
/// used to compose procedural track chunks.
library;

import '../enemies/enemy_id.dart';

/// Authored chunk template defining platforms, obstacles, gaps, and spawns.
///
/// All coordinates are chunk-relative (x in `[0, chunkWidth)`).
/// Heights are expressed as "above ground top" so patterns are ground-agnostic.
class ChunkPattern {
  const ChunkPattern({
    required this.name,
    this.platforms = const <PlatformRel>[],
    this.obstacles = const <ObstacleRel>[],
    this.groundGaps = const <GapRel>[],
    this.spawnMarkers = const <SpawnMarker>[],
  });

  /// Human-readable identifier for debugging/logging.
  final String name;

  /// One-way platforms the player can jump through.
  final List<PlatformRel> platforms;

  /// Solid obstacles the player must jump over.
  final List<ObstacleRel> obstacles;

  /// Holes in the ground (pit hazards or visual breaks).
  final List<GapRel> groundGaps;

  /// Probabilistic enemy spawn points.
  final List<SpawnMarker> spawnMarkers;
}

/// Chunk-relative platform definition (one-way top surface).
class PlatformRel {
  const PlatformRel({
    required this.x,
    required this.width,
    required this.aboveGroundTop,
    required this.thickness,
  }) : assert(width > 0),
       assert(thickness > 0),
       assert(aboveGroundTop > 0);

  /// Left edge offset from chunk start.
  final double x;

  /// Horizontal extent.
  final double width;

  /// Vertical offset above ground (positive = higher).
  final double aboveGroundTop;

  /// Platform thickness (visual/collision depth).
  final double thickness;
}

/// Chunk-relative obstacle definition (solid on all sides).
class ObstacleRel {
  const ObstacleRel({
    required this.x,
    required this.width,
    required this.height,
  }) : assert(width > 0),
       assert(height > 0);

  /// Left edge offset from chunk start.
  final double x;

  /// Horizontal extent.
  final double width;

  /// Vertical extent (sits on ground, extends upward).
  final double height;
}

/// Chunk-relative ground gap (pit hazard).
class GapRel {
  const GapRel({
    required this.x,
    required this.width,
  }) : assert(width > 0);

  /// Left edge offset from chunk start.
  final double x;

  /// Horizontal extent of the gap.
  final double width;
}

/// Chunk-relative enemy spawn marker with probabilistic activation.
class SpawnMarker {
  const SpawnMarker({
    required this.enemyId,
    required this.x,
    required this.chancePercent,
    required this.salt,
  }) : assert(chancePercent >= 0),
       assert(chancePercent <= 100);

  /// Enemy type to spawn.
  final EnemyId enemyId;

  /// Spawn X offset from chunk start.
  final double x;

  /// Probability [0–100] that this marker activates.
  final int chancePercent;

  /// Extra entropy to differentiate markers with same position.
  final int salt;
}


===== FILE: lib/core/track/chunk_pattern_pool.dart =====
/// Groups pattern pools used for procedural track generation.
library;

import 'chunk_pattern.dart';

/// Default count of early chunks that draw from the "easy" pool.
const int defaultEarlyPatternChunks = 3;

/// Default count of early chunks that suppress enemy spawns.
const int defaultNoEnemyChunks = 3;

/// Pattern pools for early vs full difficulty.
class ChunkPatternPool {
  const ChunkPatternPool({
    required this.easyPatterns,
    required this.allPatterns,
  });

  /// Simpler patterns for early chunks.
  final List<ChunkPattern> easyPatterns;

  /// Full pattern pool used after early chunks.
  final List<ChunkPattern> allPatterns;
}


===== FILE: lib/core/track/chunk_patterns_library.dart =====
/// Pre-authored chunk pattern library for track streaming.
///
/// Notes:
/// - All coordinates are relative to the chunk start (x in [0, chunkWidth)).
/// - Y is expressed as "above ground top" (so 48 means 48 units above ground).
/// - Values are authored on a 16-unit grid for stability.
library;

import '../enemies/enemy_id.dart';
import 'chunk_pattern.dart';

/// Standard platform thickness (visual/collision depth).
const double kPlatformThickness = 16.0;

/// Shorthand for [kPlatformThickness] in pattern definitions.
const double _t = kPlatformThickness;

/// Simpler patterns for early-game chunks (default early window).
///
/// These give the player breathing room before harder patterns appear.
const List<ChunkPattern> easyPatterns = <ChunkPattern>[
  ChunkPattern(
    name: 'recovery-flat',
    platforms: <PlatformRel>[],
    obstacles: <ObstacleRel>[],
    groundGaps: <GapRel>[],
    spawnMarkers: <SpawnMarker>[],
  ),
  ChunkPattern(
    name: 'single-low-platform',
    platforms: <PlatformRel>[
      PlatformRel(x: 160, width: 160, aboveGroundTop: 48, thickness: _t),
    ],
    obstacles: <ObstacleRel>[],
    groundGaps: <GapRel>[
      GapRel(x: 64, width: 96),
    ],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
          enemyId: EnemyId.unocoDemon, x: 240, chancePercent: 10, salt: 0x11),
    ],
  ),
  ChunkPattern(
    name: 'two-low-platforms',
    platforms: <PlatformRel>[
      PlatformRel(x: 64, width: 144, aboveGroundTop: 48, thickness: _t),
      PlatformRel(x: 272, width: 144, aboveGroundTop: 64, thickness: _t),
    ],
    obstacles: <ObstacleRel>[],
    groundGaps: <GapRel>[],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
          enemyId: EnemyId.groundEnemy, x: 448, chancePercent: 10, salt: 0x12),
    ],
  ),
];

/// Full pattern pool for later chunks (index >= 3).
///
/// Includes [easyPatterns] plus more challenging layouts.
const List<ChunkPattern> allPatterns = <ChunkPattern>[
  // ── Recovery / breathers ──
  ...easyPatterns,

  // ── Platforming ──
  ChunkPattern(
    name: 'staggered-mid-platforms',
    platforms: <PlatformRel>[
      PlatformRel(x: 48, width: 160, aboveGroundTop: 64, thickness: _t),
      PlatformRel(x: 256, width: 160, aboveGroundTop: 96, thickness: _t),
    ],
    groundGaps: <GapRel>[
      GapRel(x: 240, width: 128),
    ],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
          enemyId: EnemyId.unocoDemon, x: 352, chancePercent: 17, salt: 0x01),
    ],
  ),
  ChunkPattern(
    name: 'triple-runner-platforms',
    platforms: <PlatformRel>[
      PlatformRel(x: 32, width: 128, aboveGroundTop: 48, thickness: _t),
      PlatformRel(x: 192, width: 128, aboveGroundTop: 80, thickness: _t),
      PlatformRel(x: 352, width: 96, aboveGroundTop: 64, thickness: _t),
    ],
    groundGaps: <GapRel>[],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
          enemyId: EnemyId.unocoDemon, x: 288, chancePercent: 15, salt: 0x02),
    ],
  ),
  ChunkPattern(
    name: 'high-platform-over-obstacle',
    platforms: <PlatformRel>[
      PlatformRel(x: 224, width: 192, aboveGroundTop: 112, thickness: _t),
    ],
    obstacles: <ObstacleRel>[
      ObstacleRel(x: 128, width: 48, height: 64),
    ],
    groundGaps: <GapRel>[
      GapRel(x: 176, width: 96),
    ],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
          enemyId: EnemyId.groundEnemy, x: 320, chancePercent: 22, salt: 0x03),
    ],
  ),

  // ── Obstacles (ground blocks that force a jump/dash) ──
  ChunkPattern(
    name: 'single-block',
    obstacles: <ObstacleRel>[
      ObstacleRel(x: 224, width: 48, height: 64),
    ],
    groundGaps: <GapRel>[
      GapRel(x: 128, width: 96),
    ],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
          enemyId: EnemyId.groundEnemy, x: 320, chancePercent: 17, salt: 0x04),
    ],
  ),
  ChunkPattern(
    name: 'double-blocks',
    obstacles: <ObstacleRel>[
      ObstacleRel(x: 160, width: 32, height: 48),
      ObstacleRel(x: 288, width: 48, height: 64),
    ],
    groundGaps: <GapRel>[],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
          enemyId: EnemyId.unocoDemon, x: 96, chancePercent: 12, salt: 0x05),
      SpawnMarker(
          enemyId: EnemyId.groundEnemy, x: 352, chancePercent: 15, salt: 0x06),
    ],
  ),
  ChunkPattern(
    name: 'low-staircase-platforms',
    platforms: <PlatformRel>[
      PlatformRel(x: 48, width: 128, aboveGroundTop: 48, thickness: _t),
      PlatformRel(x: 208, width: 128, aboveGroundTop: 64, thickness: _t),
      PlatformRel(x: 368, width: 128, aboveGroundTop: 80, thickness: _t),
    ],
    groundGaps: <GapRel>[
      GapRel(x: 304, width: 96),
    ],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
          enemyId: EnemyId.groundEnemy, x: 112, chancePercent: 15, salt: 0x07),
      SpawnMarker(
          enemyId: EnemyId.unocoDemon, x: 320, chancePercent: 15, salt: 0x08),
    ],
  ),
  ChunkPattern(
    name: 'wide-platform-gap',
    platforms: <PlatformRel>[
      PlatformRel(x: 32, width: 192, aboveGroundTop: 64, thickness: _t),
      PlatformRel(x: 288, width: 192, aboveGroundTop: 64, thickness: _t),
    ],
    groundGaps: <GapRel>[],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
          enemyId: EnemyId.unocoDemon, x: 192, chancePercent: 17, salt: 0x09),
      SpawnMarker(
          enemyId: EnemyId.groundEnemy, x: 448, chancePercent: 15, salt: 0x0A),
    ],
  ),
  ChunkPattern(
    name: 'double-obstacle-lane',
    obstacles: <ObstacleRel>[
      ObstacleRel(x: 144, width: 48, height: 64),
      ObstacleRel(x: 336, width: 48, height: 64),
    ],
    groundGaps: <GapRel>[],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
          enemyId: EnemyId.groundEnemy, x: 256, chancePercent: 17, salt: 0x0B),
      SpawnMarker(
          enemyId: EnemyId.unocoDemon, x: 80, chancePercent: 12, salt: 0x0C),
    ],
  ),
  ChunkPattern(
    name: 'mid-platform-overhang',
    platforms: <PlatformRel>[
      PlatformRel(x: 96, width: 160, aboveGroundTop: 96, thickness: _t),
      PlatformRel(x: 384, width: 128, aboveGroundTop: 64, thickness: _t),
    ],
    obstacles: <ObstacleRel>[
      ObstacleRel(x: 320, width: 64, height: 80),
    ],
    groundGaps: <GapRel>[],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
          enemyId: EnemyId.unocoDemon, x: 176, chancePercent: 15, salt: 0x0D),
      SpawnMarker(
          enemyId: EnemyId.groundEnemy, x: 448, chancePercent: 15, salt: 0x0E),
    ],
  ),
  ChunkPattern(
    name: 'tight-platforms',
    platforms: <PlatformRel>[
      PlatformRel(x: 32, width: 96, aboveGroundTop: 80, thickness: _t),
      PlatformRel(x: 160, width: 96, aboveGroundTop: 96, thickness: _t),
      PlatformRel(x: 288, width: 96, aboveGroundTop: 80, thickness: _t),
    ],
    obstacles: <ObstacleRel>[
      ObstacleRel(x: 448, width: 48, height: 64),
    ],
    groundGaps: <GapRel>[
      GapRel(x: 112, width: 128),
    ],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
          enemyId: EnemyId.unocoDemon, x: 240, chancePercent: 15, salt: 0x0F),
      SpawnMarker(
          enemyId: EnemyId.groundEnemy, x: 480, chancePercent: 12, salt: 0x10),
    ],
  ),

  // ── Ground gaps ──
  ChunkPattern(
    name: 'ground-gap-small',
    groundGaps: <GapRel>[
      GapRel(x: 256, width: 64),
    ],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
          enemyId: EnemyId.groundEnemy, x: 160, chancePercent: 12, salt: 0x21),
      SpawnMarker(
          enemyId: EnemyId.unocoDemon, x: 416, chancePercent: 12, salt: 0x22),
    ],
  ),
  ChunkPattern(
    name: 'ground-gap-wide',
    groundGaps: <GapRel>[
      GapRel(x: 224, width: 128),
    ],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
          enemyId: EnemyId.unocoDemon, x: 96, chancePercent: 12, salt: 0x23),
      SpawnMarker(
          enemyId: EnemyId.groundEnemy, x: 480, chancePercent: 12, salt: 0x24),
    ],
  ),
];


===== FILE: lib/core/track/track_streamer.dart =====
/// Infinite-runner track streaming system.
///
/// Procedurally generates level geometry (platforms, obstacles, ground gaps)
/// and enemy spawn points by selecting from a pool of pre-authored chunk
/// patterns. Uses deterministic RNG so runs are reproducible given the same
/// seed.
library;

import '../collision/static_world_geometry.dart';
import '../enemies/enemy_id.dart';
import '../tuning/track_tuning.dart';
import '../util/deterministic_rng.dart' show mix32;
import 'chunk_builder.dart';
import 'chunk_pattern.dart';
import 'chunk_pattern_pool.dart';

/// Callback to spawn an enemy at a world X position.
typedef SpawnEnemy = void Function(EnemyId enemyId, double x);

/// Metadata for a newly spawned chunk, returned by [TrackStreamer.step].
class TrackSpawnedChunk {
  const TrackSpawnedChunk({
    required this.index,
    required this.startX,
  });

  /// Sequential chunk number (0 = first chunk).
  final int index;

  /// World X coordinate where this chunk begins.
  final double startX;
}

/// Result of a single [TrackStreamer.step] call.
class TrackStreamStepResult {
  const TrackStreamStepResult({
    required this.changed,
    required this.spawnedChunks,
  });

  /// True if geometry lists were rebuilt (chunk spawned or culled).
  final bool changed;

  /// Chunks created this step (empty on steady-state frames).
  final List<TrackSpawnedChunk> spawnedChunks;
}

/// Streams procedural track chunks based on camera position.
///
/// Call [step] each frame with the current camera bounds. The streamer:
/// 1. Spawns new chunks ahead of the camera (within [TrackTuning.spawnAheadMargin]).
/// 2. Culls old chunks behind the camera (beyond [TrackTuning.cullBehindMargin]).
/// 3. Rebuilds [dynamicSolids], [dynamicGroundSegments], [dynamicGroundGaps].
///
/// Pattern selection is deterministic given [seed] and chunk index.
class TrackStreamer {
  /// Creates a streamer seeded for deterministic generation.
  TrackStreamer({
    required this.seed,
    required this.tuning,
    required this.groundTopY,
    required this.patterns,
    required this.earlyPatternChunks,
    required this.noEnemyChunks,
  }) : _nextChunkIndex = 0,
       _nextChunkStartX = 0.0;

  /// RNG seed for pattern selection and spawn rolls.
  final int seed;

  /// Tuning parameters (chunk width, margins, grid snap).
  final TrackTuning tuning;

  /// World Y of the ground surface (platforms offset from this).
  final double groundTopY;

  /// Pattern pools for early vs full difficulty.
  final ChunkPatternPool patterns;

  /// Number of early chunks that use [patterns.easyPatterns].
  final int earlyPatternChunks;

  /// Number of early chunks that suppress enemy spawns.
  final int noEnemyChunks;

  int _nextChunkIndex;
  double _nextChunkStartX;

  final List<_ActiveChunk> _active = <_ActiveChunk>[];
  List<StaticSolid> _dynamicSolids = const <StaticSolid>[];
  List<StaticGroundSegment> _dynamicGroundSegments =
      const <StaticGroundSegment>[];
  List<StaticGroundGap> _dynamicGroundGaps = const <StaticGroundGap>[];

  /// Current streamed solids (excluding any caller-provided base solids).
  List<StaticSolid> get dynamicSolids => _dynamicSolids;

  /// Current streamed ground segments (excluding any base segments).
  List<StaticGroundSegment> get dynamicGroundSegments => _dynamicGroundSegments;

  /// Current streamed ground gaps (excluding any base gaps).
  List<StaticGroundGap> get dynamicGroundGaps => _dynamicGroundGaps;

  /// Advances chunk streaming based on the current camera bounds.
  ///
  /// Returns a step result (spawned chunks + whether geometry changed).
  TrackStreamStepResult step({
    required double cameraLeft,
    required double cameraRight,
    required SpawnEnemy spawnEnemy,
  }) {
    // Streaming disabled – return no-op.
    if (!tuning.enabled) {
      return const TrackStreamStepResult(
        changed: false,
        spawnedChunks: <TrackSpawnedChunk>[],
      );
    }

    var changed = false;
    final spawnedChunks = <TrackSpawnedChunk>[];

    // ── Spawn new chunks ahead of the camera ──
    final spawnLimitX = cameraRight + tuning.spawnAheadMargin;
    while (_nextChunkStartX <= spawnLimitX) {
      final chunkIndex = _nextChunkIndex;
      final startX = _nextChunkStartX;
      final endX = startX + tuning.chunkWidth;

      // Select pattern deterministically from seed + index.
      final pattern = _patternFor(seed, chunkIndex);

      // Build geometry from pattern.
      final solids = buildSolids(
        pattern,
        chunkStartX: startX,
        chunkIndex: chunkIndex,
        groundTopY: groundTopY,
        chunkWidth: tuning.chunkWidth,
        gridSnap: tuning.gridSnap,
      );
      final ground = buildGroundSegments(
        pattern,
        chunkStartX: startX,
        chunkIndex: chunkIndex,
        groundTopY: groundTopY,
        chunkWidth: tuning.chunkWidth,
        gridSnap: tuning.gridSnap,
      );

      // Track active chunk.
      _active.add(
        _ActiveChunk(
          index: chunkIndex,
          startX: startX,
          endX: endX,
          solids: solids,
          groundSegments: ground.segments,
          groundGaps: ground.gaps,
        ),
      );
      spawnedChunks.add(
        TrackSpawnedChunk(index: chunkIndex, startX: startX),
      );

      // Roll for enemy spawns.
      _spawnEnemiesForChunk(
        pattern,
        chunkIndex,
        chunkStartX: startX,
        spawnEnemy: spawnEnemy,
      );

      _nextChunkIndex += 1;
      _nextChunkStartX += tuning.chunkWidth;
      changed = true;
    }

    // ── Cull old chunks behind the camera ──
    final cullLimitX = cameraLeft - tuning.cullBehindMargin;
    while (_active.isNotEmpty && _active.first.endX < cullLimitX) {
      _active.removeAt(0); // O(n) but chunk count is small (~3-5).
      changed = true;
    }

    // ── Rebuild flattened geometry lists if anything changed ──
    if (changed) {
      final rebuilt = <StaticSolid>[];
      final rebuiltGroundSegments = <StaticGroundSegment>[];
      final rebuiltGroundGaps = <StaticGroundGap>[];
      for (final c in _active) {
        rebuilt.addAll(c.solids);
        rebuiltGroundSegments.addAll(c.groundSegments);
        rebuiltGroundGaps.addAll(c.groundGaps);
      }
      _dynamicSolids = List<StaticSolid>.unmodifiable(rebuilt);
      _dynamicGroundSegments =
          List<StaticGroundSegment>.unmodifiable(rebuiltGroundSegments);
      _dynamicGroundGaps =
          List<StaticGroundGap>.unmodifiable(rebuiltGroundGaps);
    }

    return TrackStreamStepResult(
      changed: changed,
      spawnedChunks: List<TrackSpawnedChunk>.unmodifiable(spawnedChunks),
    );
  }

  /// Rolls for enemy spawns defined in [pattern].
  ///
  /// Uses deterministic RNG keyed by seed, chunk index, and marker salt.
  void _spawnEnemiesForChunk(
    ChunkPattern pattern,
    int chunkIndex, {
    required double chunkStartX,
    required SpawnEnemy spawnEnemy,
  }) {
    // Early-game safety: keep first few chunks enemy-free.
    if (chunkIndex < noEnemyChunks) return;

    for (var i = 0; i < pattern.spawnMarkers.length; i += 1) {
      final m = pattern.spawnMarkers[i];

      // Deterministic roll: hash(seed, chunkIndex, markerIndex, salt).
      final roll = mix32(
        seed ^ (chunkIndex * 0x9e3779b9) ^ (i * 0x85ebca6b) ^ m.salt,
      );
      if ((roll % 100) >= m.chancePercent) continue;

      final x = chunkStartX + m.x;
      spawnEnemy(m.enemyId, x);
    }
  }

  /// Selects a chunk pattern deterministically from [seed] and [chunkIndex].
  ///
  /// Early chunks draw from [patterns.easyPatterns]; later chunks use full pool.
  ChunkPattern _patternFor(int seed, int chunkIndex) {
    final isEarly = chunkIndex < earlyPatternChunks;
    final pool = isEarly ? patterns.easyPatterns : patterns.allPatterns;
    // MurmurHash-style mix for uniform distribution.
    final h = mix32(seed ^ (chunkIndex * 0x9e3779b9) ^ 0x27d4eb2d);
    final idx = h % pool.length;
    return pool[idx];
  }
}

/// Tracks a spawned chunk's geometry while it's within camera culling bounds.
class _ActiveChunk {
  const _ActiveChunk({
    required this.index,
    required this.startX,
    required this.endX,
    required this.solids,
    required this.groundSegments,
    required this.groundGaps,
  });

  /// Sequential chunk number.
  final int index;

  /// World X where chunk begins.
  final double startX;

  /// World X where chunk ends (startX + chunkWidth).
  final double endX;

  /// Platforms and obstacles in this chunk.
  final List<StaticSolid> solids;

  /// Walkable ground spans.
  final List<StaticGroundSegment> groundSegments;

  /// Holes in the ground.
  final List<StaticGroundGap> groundGaps;
}


===== FILE: lib/core/track_manager.dart =====
/// Track streaming and geometry lifecycle management.
///
/// This module handles the procedural generation of track chunks as the
/// player progresses, maintaining both collision geometry and navigation
/// data for enemy AI.
///
/// ## Architecture
///
/// [TrackManager] is owned by [GameCore] and orchestrates:
/// - **Track streaming**: [TrackStreamer] spawns/culls chunks based on camera.
/// - **Collision geometry**: Merges base geometry with streamed chunks.
/// - **Surface graph**: Rebuilds navigation data when geometry changes.
/// - **Item spawning**: Delegates to [SpawnService] for new chunks.
///
/// ## Geometry Lifecycle
///
/// ```
/// Camera moves right
///        ↓
/// TrackStreamer.step() detects chunk spawn/cull needed
///        ↓
/// TrackManager merges base + dynamic geometry
///        ↓
/// StaticWorldGeometryIndex rebuilt (collision)
///        ↓
/// SurfaceGraphBuilder.build() (navigation)
///        ↓
/// SpawnService + EnemySystem receive new graphs
/// ```
///
/// ## Chunk Spawning Flow
///
/// When a new chunk enters the horizon:
/// 1. [TrackStreamer] generates platforms and enemy spawn points.
/// 2. [TrackManager] merges the new solids into collision geometry.
/// 3. Collectibles and restoration items are placed via [SpawnService].
/// 4. Surface graph is rebuilt so enemies can navigate new platforms.
library;

import 'collision/static_world_geometry_index.dart';
import 'ecs/stores/restoration_item_store.dart' show RestorationStat;
import 'ecs/systems/enemy_system.dart';
import 'enemies/enemy_id.dart';
import 'navigation/surface_graph_builder.dart';
import 'navigation/utils/jump_template.dart';
import 'snapshots/static_ground_gap_snapshot.dart';
import 'snapshots/static_solid_snapshot.dart';
import 'spawn_service.dart' hide StaticSolid;
import 'track/chunk_pattern_pool.dart';
import 'track/track_streamer.dart';
import 'tuning/collectible_tuning.dart';
import 'tuning/restoration_item_tuning.dart';
import 'tuning/track_tuning.dart';

// ─────────────────────────────────────────────────────────────────────────────
// Types
// ─────────────────────────────────────────────────────────────────────────────

/// Callback invoked when a chunk's enemy spawn point enters the horizon.
///
/// - [enemyId]: The type of enemy to spawn (ground or flying).
/// - [x]: The world X coordinate for the spawn.
typedef SpawnEnemyCallback = void Function(EnemyId enemyId, double x);

/// Result of a single [TrackManager.step] call.
///
/// Used by [GameCore] to decide whether to update render snapshots.
class TrackStepResult {
  const TrackStepResult({required this.geometryChanged});

  /// Whether static geometry was updated this step.
  ///
  /// When true, collision indices, surface graphs, and render snapshots
  /// have all been regenerated.
  final bool geometryChanged;
}

// ─────────────────────────────────────────────────────────────────────────────
// TrackManager
// ─────────────────────────────────────────────────────────────────────────────

/// Manages track streaming, collision geometry, and navigation graph updates.
///
/// Responsibilities:
/// - Steps [TrackStreamer] each tick to spawn/cull chunks.
/// - Merges base level geometry with dynamically streamed platforms.
/// - Rebuilds [StaticWorldGeometryIndex] for collision detection.
/// - Rebuilds [SurfaceGraph] for enemy pathfinding.
/// - Triggers collectible/item spawning for new chunks.
///
/// Usage:
/// ```dart
/// final manager = TrackManager(seed: 42, ...);
/// final result = manager.step(
///   cameraLeft: cam.left,
///   cameraRight: cam.right,
///   spawnEnemy: (id, x) => spawner.spawn(id, x),
///   lowestResourceStat: () => player.lowestStat,
/// );
/// if (result.geometryChanged) {
///   // Update render snapshots
/// }
/// ```
class TrackManager {
  /// Creates a track manager with the given dependencies.
  ///
  /// - [seed]: Master RNG seed for deterministic chunk generation.
  /// - [trackTuning]: Chunk dimensions, spawn horizons, platform density.
  /// - [collectibleTuning]: Collectible spawn parameters.
  /// - [restorationItemTuning]: Restoration item spawn parameters.
  /// - [baseGeometry]: Static level geometry (ground plane, initial platforms).
  /// - [surfaceGraphBuilder]: Builder for navigation surface graphs.
  /// - [jumpTemplate]: Precomputed jump reachability for pathfinding.
  /// - [enemySystem]: Enemy AI system (receives surface graph updates).
  /// - [spawnService]: Entity spawner (receives surface graph updates).
  /// - [groundTopY]: Y coordinate of the ground surface (for spawning).
  /// - [patternPool]: Chunk pattern pools for procedural generation.
  /// - [earlyPatternChunks]: Number of early chunks using easy patterns.
  /// - [noEnemyChunks]: Number of early chunks that suppress enemy spawns.
  TrackManager({
    required int seed,
    required TrackTuning trackTuning,
    required CollectibleTuning collectibleTuning,
    required RestorationItemTuning restorationItemTuning,
    required StaticWorldGeometry baseGeometry,
    required SurfaceGraphBuilder surfaceGraphBuilder,
    required JumpReachabilityTemplate jumpTemplate,
    required EnemySystem enemySystem,
    required SpawnService spawnService,
    required double groundTopY,
    required ChunkPatternPool patternPool,
    int earlyPatternChunks = defaultEarlyPatternChunks,
    int noEnemyChunks = defaultNoEnemyChunks,
  }) : _trackTuning = trackTuning,
        _collectibleTuning = collectibleTuning,
        _restorationItemTuning = restorationItemTuning,
        _baseGeometry = baseGeometry,
        _surfaceGraphBuilder = surfaceGraphBuilder,
        _jumpTemplate = jumpTemplate,
        _enemySystem = enemySystem,
        _spawnService = spawnService,
        _patternPool = patternPool,
        _earlyPatternChunks = earlyPatternChunks,
        _noEnemyChunks = noEnemyChunks {
    // Initialize geometry state from base level.
    _staticGeometry = baseGeometry;
    _staticIndex = StaticWorldGeometryIndex.from(baseGeometry);
    _staticSolidsSnapshot = _buildStaticSolidsSnapshot(baseGeometry);
    _staticGroundGapsSnapshot = _buildGroundGapsSnapshot(baseGeometry);

    // Create track streamer if procedural generation is enabled.
    if (_trackTuning.enabled) {
      _trackStreamer = TrackStreamer(
        seed: seed,
        tuning: _trackTuning,
        groundTopY: groundTopY,
        patterns: _patternPool,
        earlyPatternChunks: _earlyPatternChunks,
        noEnemyChunks: _noEnemyChunks,
      );
    }

    // Build initial surface graph for enemy navigation.
    _rebuildSurfaceGraph();
  }

  // ─── Dependencies ───
  final TrackTuning _trackTuning;
  final CollectibleTuning _collectibleTuning;
  final RestorationItemTuning _restorationItemTuning;
  final StaticWorldGeometry _baseGeometry;
  final SurfaceGraphBuilder _surfaceGraphBuilder;
  final JumpReachabilityTemplate _jumpTemplate;
  final EnemySystem _enemySystem;
  final SpawnService _spawnService;
  final ChunkPatternPool _patternPool;
  final int _earlyPatternChunks;
  final int _noEnemyChunks;

  // ─── Runtime State ───

  /// The track streamer (null if procedural generation is disabled).
  TrackStreamer? _trackStreamer;

  /// Version counter for surface graph rebuilds (for cache invalidation).
  int _surfaceGraphVersion = 0;

  /// Current merged geometry (base + streamed chunks).
  late StaticWorldGeometry _staticGeometry;

  /// Spatial index for broadphase collision queries.
  late StaticWorldGeometryIndex _staticIndex;

  /// Immutable snapshot of solids for the render layer.
  late List<StaticSolidSnapshot> _staticSolidsSnapshot;

  /// Immutable snapshot of ground gaps for the render layer.
  late List<StaticGroundGapSnapshot> _staticGroundGapsSnapshot;

  // ───────────────────────────────────────────────────────────────────────────
  // Public API
  // ───────────────────────────────────────────────────────────────────────────

  /// Current static world geometry (base + streamed chunks).
  ///
  /// Used by physics systems for collision resolution.
  StaticWorldGeometry get staticGeometry => _staticGeometry;

  /// Spatial index for efficient collision queries.
  ///
  /// Rebuilt whenever geometry changes.
  StaticWorldGeometryIndex get staticIndex => _staticIndex;

  /// Immutable snapshot of static solids for rendering.
  ///
  /// Contains platform AABBs, side masks, and one-way flags.
  List<StaticSolidSnapshot> get staticSolidsSnapshot => _staticSolidsSnapshot;

  /// Immutable snapshot of ground gaps for rendering.
  ///
  /// Used to draw pit hazard indicators.
  List<StaticGroundGapSnapshot> get staticGroundGapsSnapshot =>
      _staticGroundGapsSnapshot;

  /// Advances the track streamer and updates geometry if needed.
  ///
  /// This method should be called once per tick with the current camera
  /// bounds. It handles:
  /// 1. Chunk spawning/culling based on camera position.
  /// 2. Geometry merging and index rebuilding.
  /// 3. Surface graph updates for enemy AI.
  /// 4. Collectible and restoration item spawning.
  ///
  /// Parameters:
  /// - [cameraLeft], [cameraRight]: Camera X bounds for horizon calculation.
  /// - [spawnEnemy]: Callback invoked for each enemy spawn point in new chunks.
  /// - [lowestResourceStat]: Returns player's lowest resource for item type selection.
  ///
  /// Returns a [TrackStepResult] indicating whether geometry changed.
  TrackStepResult step({
    required double cameraLeft,
    required double cameraRight,
    required SpawnEnemyCallback spawnEnemy,
    required RestorationStat Function() lowestResourceStat,
  }) {
    final streamer = _trackStreamer;
    if (streamer == null) {
      // Procedural generation disabled—geometry never changes.
      return const TrackStepResult(geometryChanged: false);
    }

    // Step the streamer to spawn/cull chunks based on camera position.
    final result = streamer.step(
      cameraLeft: cameraLeft,
      cameraRight: cameraRight,
      spawnEnemy: spawnEnemy,
    );

    if (!result.changed) {
      // No chunks spawned or culled—nothing to update.
      return const TrackStepResult(geometryChanged: false);
    }

    // ─── Merge base geometry with streamed chunks ───
    final combinedSolids = <StaticSolid>[
      ..._baseGeometry.solids,
      ...streamer.dynamicSolids,
    ];
    final combinedSegments = <StaticGroundSegment>[
      ..._baseGeometry.groundSegments,
      ...streamer.dynamicGroundSegments,
    ];
    final combinedGaps = <StaticGroundGap>[
      ..._baseGeometry.groundGaps,
      ...streamer.dynamicGroundGaps,
    ];

    // Apply the new combined geometry (rebuilds index, snapshots, nav graph).
    _setStaticGeometry(
      StaticWorldGeometry(
        groundPlane: _baseGeometry.groundPlane,
        groundSegments: List<StaticGroundSegment>.unmodifiable(
          combinedSegments,
        ),
        solids: List<StaticSolid>.unmodifiable(combinedSolids),
        groundGaps: List<StaticGroundGap>.unmodifiable(combinedGaps),
      ),
    );

    // ─── Spawn items for newly created chunks ───
    if (result.spawnedChunks.isNotEmpty) {
      // Convert geometry to spawn-friendly format (avoids import cycles).
      final solidsForSpawn = _staticGeometry.solids
          .map((s) => (minX: s.minX, maxX: s.maxX, minY: s.minY, maxY: s.maxY))
          .toList();

      for (final chunk in result.spawnedChunks) {
        // Spawn collectibles if enabled.
        if (_collectibleTuning.enabled) {
          _spawnService.spawnCollectiblesForChunk(
            chunkIndex: chunk.index,
            chunkStartX: chunk.startX,
            solids: solidsForSpawn,
          );
        }

        // Spawn restoration items if enabled.
        if (_restorationItemTuning.enabled) {
          _spawnService.spawnRestorationItemForChunk(
            chunkIndex: chunk.index,
            chunkStartX: chunk.startX,
            solids: solidsForSpawn,
            lowestResourceStat: lowestResourceStat,
          );
        }
      }
    }

    return const TrackStepResult(geometryChanged: true);
  }

  // ───────────────────────────────────────────────────────────────────────────
  // Private Helpers
  // ───────────────────────────────────────────────────────────────────────────

  /// Applies new static geometry, rebuilding all derived data structures.
  ///
  /// This is the single point of geometry mutation. It ensures that the
  /// collision index, render snapshots, and navigation graph stay in sync.
  void _setStaticGeometry(StaticWorldGeometry geometry) {
    _staticGeometry = geometry;
    _staticIndex = StaticWorldGeometryIndex.from(geometry);
    _staticSolidsSnapshot = _buildStaticSolidsSnapshot(geometry);
    _staticGroundGapsSnapshot = _buildGroundGapsSnapshot(geometry);
    _rebuildSurfaceGraph();
  }

  /// Rebuilds the navigation surface graph and distributes it to consumers.
  ///
  /// The surface graph is used by:
  /// - [SpawnService]: To place items "on top of" platforms.
  /// - [EnemySystem]: To compute jump/walk paths to the player.
  ///
  /// A version counter is incremented each rebuild so consumers can
  /// invalidate cached paths.
  void _rebuildSurfaceGraph() {
    _surfaceGraphVersion += 1;
    final result = _surfaceGraphBuilder.build(
      geometry: _staticGeometry,
      jumpTemplate: _jumpTemplate,
    );

    // Distribute new graph to spawn service.
    _spawnService.setSurfaceGraph(
      graph: result.graph,
      spatialIndex: result.spatialIndex,
    );

    // Distribute new graph to enemy AI system.
    _enemySystem.setSurfaceGraph(
      graph: result.graph,
      spatialIndex: result.spatialIndex,
      graphVersion: _surfaceGraphVersion,
    );
  }

  /// Builds an immutable list of [StaticSolidSnapshot] from geometry.
  ///
  /// Converts internal collision representation to render-friendly format.
  static List<StaticSolidSnapshot> _buildStaticSolidsSnapshot(
    StaticWorldGeometry geometry,
  ) {
    return List<StaticSolidSnapshot>.unmodifiable(
      geometry.solids.map(
        (s) => StaticSolidSnapshot(
          minX: s.minX,
          minY: s.minY,
          maxX: s.maxX,
          maxY: s.maxY,
          sides: s.sides,
          oneWayTop: s.oneWayTop,
        ),
      ),
    );
  }

  /// Builds an immutable list of [StaticGroundGapSnapshot] from geometry.
  ///
  /// Returns an empty const list if no gaps exist (avoids allocation).
  static List<StaticGroundGapSnapshot> _buildGroundGapsSnapshot(
    StaticWorldGeometry geometry,
  ) {
    if (geometry.groundGaps.isEmpty) {
      return const <StaticGroundGapSnapshot>[];
    }
    return List<StaticGroundGapSnapshot>.unmodifiable(
      geometry.groundGaps.map(
        (g) => StaticGroundGapSnapshot(minX: g.minX, maxX: g.maxX),
      ),
    );
  }
}


===== FILE: lib/core/tuning/ability_tuning.dart =====
/// Player ability tuning (cast, melee).
library;

import '../util/tick_math.dart';

class AbilityTuning {
  const AbilityTuning({
    this.castCooldownSeconds = 0.25,
    this.meleeCooldownSeconds = 0.30,
    this.meleeActiveSeconds = 0.10,
    this.meleeStaminaCost = 5.0,
    this.meleeDamage = 15.0,
    this.meleeHitboxSizeX = 32.0,
    this.meleeHitboxSizeY = 16.0,
  });

  /// Cooldown between spell casts (seconds).
  final double castCooldownSeconds;

  /// Cooldown between melee attacks (seconds).
  final double meleeCooldownSeconds;

  /// Duration melee hitbox is active (seconds).
  final double meleeActiveSeconds;

  /// Stamina spent per melee attack.
  final double meleeStaminaCost;

  /// Damage dealt by melee attack.
  final double meleeDamage;

  /// Melee hitbox width (world units).
  final double meleeHitboxSizeX;

  /// Melee hitbox height (world units).
  final double meleeHitboxSizeY;
}

class AbilityTuningDerived {
  const AbilityTuningDerived._({
    required this.tickHz,
    required this.base,
    required this.castCooldownTicks,
    required this.meleeCooldownTicks,
    required this.meleeActiveTicks,
  });

  factory AbilityTuningDerived.from(
    AbilityTuning base, {
    required int tickHz,
  }) {
    if (tickHz <= 0) {
      throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
    }

    return AbilityTuningDerived._(
      tickHz: tickHz,
      base: base,
      castCooldownTicks: ticksFromSecondsCeil(base.castCooldownSeconds, tickHz),
      meleeCooldownTicks: ticksFromSecondsCeil(base.meleeCooldownSeconds, tickHz),
      meleeActiveTicks: ticksFromSecondsCeil(base.meleeActiveSeconds, tickHz),
    );
  }

  final int tickHz;
  final AbilityTuning base;

  final int castCooldownTicks;
  final int meleeCooldownTicks;
  final int meleeActiveTicks;
}


===== FILE: lib/core/tuning/anim_tuning.dart =====
/// Animation timing tuning (Core-owned, deterministic).
library;

import '../snapshots/enums.dart';
import '../util/tick_math.dart';
import 'player_anim_defs.dart';

class AnimTuning {
  const AnimTuning({
    this.hitAnimSeconds = playerAnimHitSeconds,
    this.castAnimSeconds = playerAnimCastSeconds,
    this.attackAnimSeconds = playerAnimAttackSeconds,
    this.deathAnimSeconds = playerAnimDeathSeconds,
    this.spawnAnimSeconds = playerAnimSpawnSeconds,
  });

  /// Computes a recommended duration for a strip based on frame count and step time.
  static double secondsForStrip({
    required int frameCount,
    required double stepTimeSeconds,
  }) {
    if (frameCount <= 0 || stepTimeSeconds <= 0) return 0.0;
    return frameCount * stepTimeSeconds;
  }

  /// Builds an [AnimTuning] from strip frame counts and step times.
  ///
  /// The step times should match the renderer's timing map.
  static AnimTuning fromStripFrames({
    required Map<AnimKey, int> frameCounts,
    required Map<AnimKey, double> stepTimeSecondsByKey,
  }) {
    double secondsFor(AnimKey key) {
      final frames = frameCounts[key] ?? 1;
      final step = stepTimeSecondsByKey[key] ?? 0.10;
      return secondsForStrip(frameCount: frames, stepTimeSeconds: step);
    }

    return AnimTuning(
      hitAnimSeconds: secondsFor(AnimKey.hit),
      castAnimSeconds: secondsFor(AnimKey.cast),
      attackAnimSeconds: secondsFor(AnimKey.attack),
      deathAnimSeconds: secondsFor(AnimKey.death),
      spawnAnimSeconds: secondsFor(AnimKey.spawn),
    );
  }

  /// Duration to hold `AnimKey.hit` after a hit (seconds).
  final double hitAnimSeconds;

  /// Duration to hold `AnimKey.cast` after a cast intent (seconds).
  final double castAnimSeconds;

  /// Duration to hold `AnimKey.attack` after a melee intent (seconds).
  final double attackAnimSeconds;

  /// Duration to hold `AnimKey.death` before ending the run (seconds).
  final double deathAnimSeconds;

  /// Duration to hold `AnimKey.spawn` at run start (seconds).
  final double spawnAnimSeconds;
}

class AnimTuningDerived {
  const AnimTuningDerived._({
    required this.tickHz,
    required this.base,
    required this.hitAnimTicks,
    required this.castAnimTicks,
    required this.attackAnimTicks,
    required this.deathAnimTicks,
    required this.spawnAnimTicks,
  });

  factory AnimTuningDerived.from(AnimTuning base, {required int tickHz}) {
    if (tickHz <= 0) {
      throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
    }

    return AnimTuningDerived._(
      tickHz: tickHz,
      base: base,
      hitAnimTicks: ticksFromSecondsCeil(base.hitAnimSeconds, tickHz),
      castAnimTicks: ticksFromSecondsCeil(base.castAnimSeconds, tickHz),
      attackAnimTicks: ticksFromSecondsCeil(base.attackAnimSeconds, tickHz),
      deathAnimTicks: ticksFromSecondsCeil(base.deathAnimSeconds, tickHz),
      spawnAnimTicks: ticksFromSecondsCeil(base.spawnAnimSeconds, tickHz),
    );
  }

  final int tickHz;
  final AnimTuning base;

  final int hitAnimTicks;
  final int castAnimTicks;
  final int attackAnimTicks;
  final int deathAnimTicks;
  final int spawnAnimTicks;
}


===== FILE: lib/core/tuning/camera_tuning.dart =====
/// Camera auto-scroll and follow tuning.
library;

import 'dart:math';

import 'movement_tuning.dart';

class CameraTuning {
  const CameraTuning({
    this.speedLagMulX = 0.0,
    this.accelX = 1200.0,
    this.followThresholdRatio = 0.5,
    this.catchupLerp = 8.0,
    this.targetCatchupLerp = 2.5,
  });

  /// Baseline auto-scroll lags behind `MovementTuning.maxSpeedX` by this multiplier.
  final double speedLagMulX;

  /// Acceleration used to ease camera speed toward its target speed.
  final double accelX;

  /// Threshold ratio (from left edge) after which the player can pull the camera forward.
  final double followThresholdRatio;

  /// Smoothing for camera center toward its target (per-second).
  final double catchupLerp;

  /// Smoothing for camera target toward player (per-second).
  final double targetCatchupLerp;
}

class CameraTuningDerived {
  const CameraTuningDerived({
    required this.targetSpeedX,
    required this.accelX,
    required this.followThresholdRatio,
    required this.catchupLerp,
    required this.targetCatchupLerp,
  });

  factory CameraTuningDerived.from(
    CameraTuning tuning, {
    required MovementTuningDerived movement,
  }) {
    final targetSpeedX = max(0.0, movement.base.maxSpeedX * tuning.speedLagMulX);
    return CameraTuningDerived(
      targetSpeedX: targetSpeedX,
      accelX: tuning.accelX,
      followThresholdRatio: tuning.followThresholdRatio,
      catchupLerp: tuning.catchupLerp,
      targetCatchupLerp: tuning.targetCatchupLerp,
    );
  }

  final double targetSpeedX;
  final double accelX;
  final double followThresholdRatio;
  final double catchupLerp;
  final double targetCatchupLerp;
}


===== FILE: lib/core/tuning/collectible_tuning.dart =====
/// Collectible spawning and value configuration.
class CollectibleTuning {
  const CollectibleTuning({
    this.enabled = true,
    this.minPerChunk = 1,
    this.maxPerChunk = 2,
    this.spawnStartChunkIndex = 2,
    this.collectibleSize = 10.0,
    this.surfaceClearanceY = 10.0,
    this.noSpawnMargin = 2.0,
    this.minSpacingX = 80.0,
    this.chunkEdgeMarginX = 32.0,
    this.maxAttemptsPerChunk = 40,
    this.despawnBehindCameraMargin = 900.0,
    this.valuePerCollectible = 50,
  }) : assert(maxPerChunk >= minPerChunk);

  /// Master toggle for collectible spawning.
  final bool enabled;

  /// Min collectibles spawned per chunk.
  final int minPerChunk;

  /// Max collectibles spawned per chunk.
  final int maxPerChunk;

  /// First chunk index where collectibles can spawn.
  final int spawnStartChunkIndex;

  /// Collision/render size (world units).
  final double collectibleSize;

  /// Vertical clearance above surface (world units).
  final double surfaceClearanceY;

  /// Margin from surface edges to avoid clipping (world units).
  final double noSpawnMargin;

  /// Minimum horizontal spacing between collectibles (world units).
  final double minSpacingX;

  /// Margin from chunk edges (world units).
  final double chunkEdgeMarginX;

  /// Max placement attempts before giving up.
  final int maxAttemptsPerChunk;

  /// Distance behind camera before despawn (world units).
  final double despawnBehindCameraMargin;

  /// Score value per collectible.
  final int valuePerCollectible;
}


===== FILE: lib/core/tuning/combat_tuning.dart =====
/// Combat tuning (invulnerability, damage modifiers).
library;

import '../util/tick_math.dart';

class CombatTuning {
  const CombatTuning({this.invulnerabilitySeconds = 0.25});

  /// Duration of i-frames after taking damage (seconds).
  final double invulnerabilitySeconds;
}

class CombatTuningDerived {
  const CombatTuningDerived._({
    required this.tickHz,
    required this.base,
    required this.invulnerabilityTicks,
  });

  factory CombatTuningDerived.from(
    CombatTuning base, {
    required int tickHz,
  }) {
    if (tickHz <= 0) {
      throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
    }

    return CombatTuningDerived._(
      tickHz: tickHz,
      base: base,
      invulnerabilityTicks: ticksFromSecondsCeil(
        base.invulnerabilitySeconds,
        tickHz,
      ),
    );
  }

  final int tickHz;
  final CombatTuning base;

  final int invulnerabilityTicks;
}



===== FILE: lib/core/tuning/core_tuning.dart =====
/// Aggregate tuning configuration for the game simulation core.
///
/// This class bundles all tuning parameters into a single object, simplifying
/// the [GameCore] constructor API. All fields have sensible defaults, so you
/// only need to override what you want to customize.
///
/// ## Usage
///
/// ```dart
/// // Default configuration:
/// final core = GameCore(seed: 42);
///
/// // Custom configuration:
/// final core = GameCore(
///   seed: 42,
///   tuning: CoreTuning(
///     movement: MovementTuning(jumpSpeed: 600),
///     track: TrackTuning(enabled: false),
///   ),
/// );
/// ```
///
/// ## Testing
///
/// For unit tests, create a custom [CoreTuning] with specific overrides:
/// ```dart
/// final testTuning = CoreTuning(
///   track: TrackTuning(enabled: false),  // Disable procedural gen
///   physics: PhysicsTuning(gravityY: 0), // Zero gravity
/// );
/// final core = GameCore(seed: 123, tuning: testTuning);
/// ```
library;

import 'ability_tuning.dart';
import 'anim_tuning.dart';
import 'camera_tuning.dart';
import 'collectible_tuning.dart';
import 'combat_tuning.dart';
import 'flying_enemy_tuning.dart';
import 'ground_enemy_tuning.dart';
import 'movement_tuning.dart';
import 'navigation_tuning.dart';
import 'physics_tuning.dart';
import 'resource_tuning.dart';
import 'restoration_item_tuning.dart';
import 'score_tuning.dart';
import 'spatial_grid_tuning.dart';
import 'track_tuning.dart';

/// Aggregate container for all game simulation tuning parameters.
///
/// Provides a cleaner API than passing 15+ individual tuning objects to
/// [GameCore]. All fields default to their respective tuning class defaults.
class CoreTuning {
  /// Creates a core tuning configuration with optional overrides.
  ///
  /// Any parameter not specified uses its default value.
  const CoreTuning({
    this.physics = const PhysicsTuning(),
    this.movement = const MovementTuning(),
    this.resource = const ResourceTuning(),
    this.ability = const AbilityTuning(),
    this.anim = const AnimTuning(),
    this.combat = const CombatTuning(),
    this.unocoDemon = const UnocoDemonTuning(),
    this.groundEnemy = const GroundEnemyTuning(),
    this.navigation = const NavigationTuning(),
    this.spatialGrid = const SpatialGridTuning(),
    this.camera = const CameraTuning(),
    this.track = const TrackTuning(),
    this.collectible = const CollectibleTuning(),
    this.restorationItem = const RestorationItemTuning(),
    this.score = const ScoreTuning(),
  });

  /// Physics constants (gravity, etc.).
  final PhysicsTuning physics;

  /// Player movement parameters (speed, jump, dash).
  final MovementTuning movement;

  /// Resource costs and regeneration rates.
  final ResourceTuning resource;

  /// Ability cooldowns and stamina costs.
  final AbilityTuning ability;

  /// Animation timing windows for snapshot state.
  final AnimTuning anim;

  /// Combat parameters (damage, invulnerability frames).
  final CombatTuning combat;

  /// Flying enemy AI and spawn parameters.
  final UnocoDemonTuning unocoDemon;

  /// Ground enemy AI and movement parameters.
  final GroundEnemyTuning groundEnemy;

  /// Pathfinding and navigation parameters.
  final NavigationTuning navigation;

  /// Spatial partitioning grid settings.
  final SpatialGridTuning spatialGrid;

  /// Camera behavior (autoscroll, smoothing).
  final CameraTuning camera;

  /// Track streaming and chunk generation.
  final TrackTuning track;

  /// Collectible spawn density and placement.
  final CollectibleTuning collectible;

  /// Restoration item spawn frequency and sizing.
  final RestorationItemTuning restorationItem;

  /// Score calculation parameters.
  final ScoreTuning score;
}


===== FILE: lib/core/tuning/flying_enemy_tuning.dart =====
/// Flying enemy AI tuning (steering, attacks).
library;

import '../util/tick_math.dart';

class UnocoDemonTuning {
  const UnocoDemonTuning({
    this.unocoDemonHoverOffsetY = 150.0,
    this.unocoDemonDesiredRangeMin = 50.0,
    this.unocoDemonDesiredRangeMax = 90.0,
    this.unocoDemonDesiredRangeHoldMinSeconds = 0.60,
    this.unocoDemonDesiredRangeHoldMaxSeconds = 1.40,
    this.unocoDemonHoldSlack = 20.0,
    this.unocoDemonMaxSpeedX = 300.0,
    this.unocoDemonSlowRadiusX = 80.0,
    this.unocoDemonAccelX = 600.0,
    this.unocoDemonDecelX = 400.0,
    this.unocoDemonMinHeightAboveGround = 100.0,
    this.unocoDemonMaxHeightAboveGround = 240.0,
    this.unocoDemonFlightTargetHoldMinSeconds = 1.5,
    this.unocoDemonFlightTargetHoldMaxSeconds = 3.0,
    this.unocoDemonMaxSpeedY = 300.0,
    this.unocoDemonVerticalKp = 4.0,
    this.unocoDemonVerticalDeadzone = 20.0,
    this.unocoDemonAimLeadMinSeconds = 0.08,
    this.unocoDemonAimLeadMaxSeconds = 0.40,
    this.unocoDemonCastCooldownSeconds = 2.0,
    this.unocoDemonCastOriginOffset = 20.0,
  });

  // ── Steering ──

  /// Vertical offset above player when hovering (world units).
  final double unocoDemonHoverOffsetY;

  /// Min horizontal range to maintain from player (world units).
  final double unocoDemonDesiredRangeMin;

  /// Max horizontal range to maintain from player (world units).
  final double unocoDemonDesiredRangeMax;

  /// Min time to hold a desired range before picking new (seconds).
  final double unocoDemonDesiredRangeHoldMinSeconds;

  /// Max time to hold a desired range (seconds).
  final double unocoDemonDesiredRangeHoldMaxSeconds;

  /// Slack distance before recalculating position (world units).
  final double unocoDemonHoldSlack;

  /// Max horizontal speed (world units/sec).
  final double unocoDemonMaxSpeedX;

  /// Distance from target where decel starts (world units).
  final double unocoDemonSlowRadiusX;

  /// Horizontal acceleration (world units/sec²).
  final double unocoDemonAccelX;

  /// Horizontal deceleration (world units/sec²).
  final double unocoDemonDecelX;

  /// Min height above ground (world units).
  final double unocoDemonMinHeightAboveGround;

  /// Max height above ground (world units).
  final double unocoDemonMaxHeightAboveGround;

  /// Min time to hold a flight target (seconds).
  final double unocoDemonFlightTargetHoldMinSeconds;

  /// Max time to hold a flight target (seconds).
  final double unocoDemonFlightTargetHoldMaxSeconds;

  /// Max vertical speed (world units/sec).
  final double unocoDemonMaxSpeedY;

  /// Proportional gain for vertical steering.
  final double unocoDemonVerticalKp;

  /// Deadzone for vertical error (world units).
  final double unocoDemonVerticalDeadzone;

  // ── Attacks ──

  /// Min lead time when aiming at player (seconds).
  final double unocoDemonAimLeadMinSeconds;

  /// Max lead time when aiming at player (seconds).
  final double unocoDemonAimLeadMaxSeconds;

  /// Cooldown between casts (seconds).
  final double unocoDemonCastCooldownSeconds;

  /// Projectile spawn offset from center (world units).
  final double unocoDemonCastOriginOffset;
}

class UnocoDemonTuningDerived {
  const UnocoDemonTuningDerived._({
    required this.tickHz,
    required this.base,
    required this.unocoDemonCastCooldownTicks,
  });

  factory UnocoDemonTuningDerived.from(
    UnocoDemonTuning base, {
    required int tickHz,
  }) {
    if (tickHz <= 0) {
      throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
    }

    return UnocoDemonTuningDerived._(
      tickHz: tickHz,
      base: base,
      unocoDemonCastCooldownTicks: ticksFromSecondsCeil(
        base.unocoDemonCastCooldownSeconds,
        tickHz,
      ),
    );
  }

  final int tickHz;
  final UnocoDemonTuning base;

  final int unocoDemonCastCooldownTicks;
}


===== FILE: lib/core/tuning/ground_enemy_tuning.dart =====
/// Ground enemy AI tuning (steering, melee).
library;

import '../util/tick_math.dart';

class GroundEnemyTuning {
  const GroundEnemyTuning({
    this.groundEnemySpeedX = 300.0,
    this.groundEnemyStopDistanceX = 6.0,
    this.groundEnemyAccelX = 600.0,
    this.groundEnemyDecelX = 400.0,
    this.groundEnemyChaseOffsetMaxX = 18.0,
    this.groundEnemyChaseOffsetMinAbsX = 6.0,
    this.groundEnemyChaseOffsetMeleeX = 3.0,
    this.groundEnemyChaseSpeedScaleMin = 0.92,
    this.groundEnemyChaseSpeedScaleMax = 1.08,
    this.groundEnemyJumpSpeed = 500.0,
    this.groundEnemyMeleeRangeX = 26.0,
    this.groundEnemyMeleeCooldownSeconds = 1.0,
    this.groundEnemyMeleeActiveSeconds = 0.10,
    this.groundEnemyMeleeDamage = 5.0,
    this.groundEnemyMeleeHitboxSizeX = 28.0,
    this.groundEnemyMeleeHitboxSizeY = 16.0,
  });

  // ── Steering ──

  /// Target horizontal speed (world units/sec).
  final double groundEnemySpeedX;

  /// Distance at which enemy stops chasing (world units).
  final double groundEnemyStopDistanceX;

  /// Horizontal acceleration (world units/sec²).
  final double groundEnemyAccelX;

  /// Horizontal deceleration (world units/sec²).
  final double groundEnemyDecelX;

  /// Max random chase offset from player (world units).
  final double groundEnemyChaseOffsetMaxX;

  /// Min absolute chase offset (prevents clumping).
  final double groundEnemyChaseOffsetMinAbsX;

  /// Chase offset when in melee range (world units).
  final double groundEnemyChaseOffsetMeleeX;

  /// Min speed scale for chase variance.
  final double groundEnemyChaseSpeedScaleMin;

  /// Max speed scale for chase variance.
  final double groundEnemyChaseSpeedScaleMax;

  /// Jump velocity (world units/sec, positive = upward).
  final double groundEnemyJumpSpeed;

  // ── Melee ──

  /// Horizontal range to trigger melee attack (world units).
  final double groundEnemyMeleeRangeX;

  /// Cooldown between melee attacks (seconds).
  final double groundEnemyMeleeCooldownSeconds;

  /// Duration melee hitbox is active (seconds).
  final double groundEnemyMeleeActiveSeconds;

  /// Damage dealt by melee attack.
  final double groundEnemyMeleeDamage;

  /// Melee hitbox width (world units).
  final double groundEnemyMeleeHitboxSizeX;

  /// Melee hitbox height (world units).
  final double groundEnemyMeleeHitboxSizeY;
}

class GroundEnemyTuningDerived {
  const GroundEnemyTuningDerived._({
    required this.tickHz,
    required this.base,
    required this.groundEnemyMeleeCooldownTicks,
    required this.groundEnemyMeleeActiveTicks,
  });

  factory GroundEnemyTuningDerived.from(
    GroundEnemyTuning base, {
    required int tickHz,
  }) {
    if (tickHz <= 0) {
      throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
    }

    return GroundEnemyTuningDerived._(
      tickHz: tickHz,
      base: base,
      groundEnemyMeleeCooldownTicks: ticksFromSecondsCeil(
        base.groundEnemyMeleeCooldownSeconds,
        tickHz,
      ),
      groundEnemyMeleeActiveTicks: ticksFromSecondsCeil(
        base.groundEnemyMeleeActiveSeconds,
        tickHz,
      ),
    );
  }

  final int tickHz;
  final GroundEnemyTuning base;

  final int groundEnemyMeleeCooldownTicks;
  final int groundEnemyMeleeActiveTicks;
}


===== FILE: lib/core/tuning/movement_tuning.dart =====
import '../util/tick_math.dart';

/// Movement/physics tuning for the Core simulation.
///
/// All units are expressed in world units ("virtual pixels") and seconds:
/// - speeds: world units / second
/// - acceleration: world units / second^2
/// - times: seconds (converted to fixed-tick counts at runtime)
///
/// The derived values are computed once per [tickHz] and then used in the hot
/// per-tick loop to keep the core allocation-light.
const int defaultTickHz = 60;

/// Authoritative movement constants (expressed in seconds-based units).
class MovementTuning {
  const MovementTuning({
    this.playerRadius = 8,
    this.maxSpeedX = 200,
    this.accelerationX = 600,
    this.decelerationX = 400,
    this.minMoveSpeed = 5,
    this.maxVelX = 1500,
    this.maxVelY = 1500,
    this.jumpSpeed = 500,
    this.coyoteTimeSeconds = 0.10,
    this.jumpBufferSeconds = 0.12,
    this.dashSpeedX = 550,
    this.dashDurationSeconds = 0.20,
    this.dashCooldownSeconds = 2.0,
  });

  /// Player "collision" radius in world units.
  final double playerRadius;

  /// Target max horizontal speed when holding move input.
  final double maxSpeedX;
  final double accelerationX;
  final double decelerationX;
  final double minMoveSpeed;

  /// Speed clamps (safety caps).
  final double maxVelX;
  final double maxVelY;

  /// Instantaneous jump vertical speed (negative is upward).
  final double jumpSpeed;

  /// Jump forgiveness windows (platformer-style).
  final double coyoteTimeSeconds;
  final double jumpBufferSeconds;

  /// Dash parameters.
  final double dashSpeedX;
  final double dashDurationSeconds;
  final double dashCooldownSeconds;
}

/// Derived, tick-based tuning computed for a specific [tickHz].
class MovementTuningDerived {
  const MovementTuningDerived._({
    required this.tickHz,
    required this.dtSeconds,
    required this.base,
    required this.coyoteTicks,
    required this.jumpBufferTicks,
    required this.dashDurationTicks,
    required this.dashCooldownTicks,
  });

  factory MovementTuningDerived.from(
    MovementTuning base, {
    required int tickHz,
  }) {
    if (tickHz <= 0) {
      throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
    }
    return MovementTuningDerived._(
      tickHz: tickHz,
      dtSeconds: 1.0 / tickHz,
      base: base,
      coyoteTicks: ticksFromSecondsCeil(base.coyoteTimeSeconds, tickHz),
      jumpBufferTicks: ticksFromSecondsCeil(base.jumpBufferSeconds, tickHz),
      dashDurationTicks: ticksFromSecondsCeil(base.dashDurationSeconds, tickHz),
      dashCooldownTicks: ticksFromSecondsCeil(base.dashCooldownSeconds, tickHz),
    );
  }

  final int tickHz;
  final double dtSeconds;
  final MovementTuning base;

  final int coyoteTicks;
  final int jumpBufferTicks;
  final int dashDurationTicks;
  final int dashCooldownTicks;
}


===== FILE: lib/core/tuning/navigation_tuning.dart =====
/// Navigation tuning for surface-graph based AI.
///
/// This is intentionally separate from movement/combat tunings:
/// - movement tuning controls the player's physical feel
/// - enemy tuning controls per-enemy locomotion abilities
/// - navigation tuning controls pathfinding + graph build tradeoffs
library;
import '../navigation/types/nav_tolerances.dart';

class NavigationTuning {
  const NavigationTuning({
    this.repathCooldownTicks = 30,
    this.maxExpandedNodes = 128,
    this.edgePenaltySeconds = 0.05,
    this.surfaceEps = navSpatialEps,
    this.takeoffEpsMin = 2.0,
    this.takeoffSampleMaxStep = 64.0,
  }) : assert(repathCooldownTicks >= 0),
       assert(maxExpandedNodes > 0),
       assert(edgePenaltySeconds >= 0.0),
       assert(surfaceEps > 0.0),
       assert(takeoffEpsMin >= 0.0),
       assert(takeoffSampleMaxStep > 0.0);

  /// Throttle replans per entity to avoid per-tick A* on mobile.
  final int repathCooldownTicks;

  /// Hard cap on A* node expansions (fail fast deterministically).
  final int maxExpandedNodes;

  /// Small per-edge penalty that biases toward fewer hops when costs tie.
  final double edgePenaltySeconds;

  /// Vertical tolerance when locating the current/target surface (world units).
  final double surfaceEps;

  /// Minimum horizontal tolerance for "close enough to takeoff" (world units).
  ///
  /// The actual takeoff epsilon can be increased by the locomotion controller
  /// (e.g. tied to an enemy's stop distance) to avoid "stops too early to jump".
  final double takeoffEpsMin;

  /// Maximum step between takeoff samples on long surfaces (world units).
  final double takeoffSampleMaxStep;
}


===== FILE: lib/core/tuning/physics_tuning.dart =====
/// Global physics tuning for the Core simulation.
///
/// This is intentionally separate from movement/ability/combat tunings so it can
/// evolve into per-level/biome physics profiles later (e.g. low-gravity zones).
class PhysicsTuning {
  const PhysicsTuning({
    this.gravityY = 1200,
  });

  /// Gravity acceleration (positive is downward), in world units / second^2.
  final double gravityY;
}



===== FILE: lib/core/tuning/player_anim_defs.dart =====
/// Shared player animation definitions (Core-owned, renderer consumes).
library;

import '../snapshots/enums.dart';

const int playerAnimFrameWidth = 100;
const int playerAnimFrameHeight = 64;

const int playerAnimIdleFrames = 4;
const double playerAnimIdleStepSeconds = 0.14;

const int playerAnimRunFrames = 7;
const double playerAnimRunStepSeconds = 0.08;

const int playerAnimJumpFrames = 6;
const double playerAnimJumpStepSeconds = 0.10;

const int playerAnimFallFrames = 3;
const double playerAnimFallStepSeconds = 0.10;

const int playerAnimAttackFrames = 6;
const double playerAnimAttackStepSeconds = 0.06;

const int playerAnimCastFrames = 5;
const double playerAnimCastStepSeconds = 0.08;

const int playerAnimDashFrames = 4;
const double playerAnimDashStepSeconds = 0.05;

const int playerAnimHitFrames = 4;
const double playerAnimHitStepSeconds = 0.10;

const int playerAnimDeathFrames = 6;
const double playerAnimDeathStepSeconds = 0.12;

// Spawn reuses idle timing/frames until a dedicated strip exists.
const int playerAnimSpawnFrames = playerAnimIdleFrames;
const double playerAnimSpawnStepSeconds = playerAnimIdleStepSeconds;

const Map<AnimKey, int> playerAnimFrameCountsByKey = <AnimKey, int>{
  AnimKey.idle: playerAnimIdleFrames,
  AnimKey.run: playerAnimRunFrames,
  AnimKey.jump: playerAnimJumpFrames,
  AnimKey.fall: playerAnimFallFrames,
  AnimKey.attack: playerAnimAttackFrames,
  AnimKey.cast: playerAnimCastFrames,
  AnimKey.dash: playerAnimDashFrames,
  AnimKey.hit: playerAnimHitFrames,
  AnimKey.death: playerAnimDeathFrames,
  AnimKey.spawn: playerAnimSpawnFrames,
};

const Map<AnimKey, double> playerAnimStepTimeSecondsByKey = <AnimKey, double>{
  AnimKey.idle: playerAnimIdleStepSeconds,
  AnimKey.run: playerAnimRunStepSeconds,
  AnimKey.jump: playerAnimJumpStepSeconds,
  AnimKey.fall: playerAnimFallStepSeconds,
  AnimKey.attack: playerAnimAttackStepSeconds,
  AnimKey.cast: playerAnimCastStepSeconds,
  AnimKey.dash: playerAnimDashStepSeconds,
  AnimKey.hit: playerAnimHitStepSeconds,
  AnimKey.death: playerAnimDeathStepSeconds,
  AnimKey.spawn: playerAnimSpawnStepSeconds,
};

const double playerAnimHitSeconds =
    playerAnimHitFrames * playerAnimHitStepSeconds;
const double playerAnimCastSeconds =
    playerAnimCastFrames * playerAnimCastStepSeconds;
const double playerAnimAttackSeconds =
    playerAnimAttackFrames * playerAnimAttackStepSeconds;
const double playerAnimDeathSeconds =
    playerAnimDeathFrames * playerAnimDeathStepSeconds;
const double playerAnimSpawnSeconds =
    playerAnimSpawnFrames * playerAnimSpawnStepSeconds;


===== FILE: lib/core/tuning/resource_tuning.dart =====
/// Resource tuning (author in seconds, applied per fixed tick).
/// This includes health, mana, stamina, and their regeneration rates.
class ResourceTuning {
  const ResourceTuning({
    this.playerHpMax = 100,
    this.playerHpRegenPerSecond = 0.5,
    this.playerManaMax = 100,
    this.playerManaRegenPerSecond = 2.0,
    this.playerStaminaMax = 100,
    this.playerStaminaRegenPerSecond = 1.0,
    this.jumpStaminaCost = 2,
    this.dashStaminaCost = 2,
  });

  /// Maximum health points.
  final double playerHpMax;

  /// HP regenerated per second.
  final double playerHpRegenPerSecond;

  /// Maximum mana points.
  final double playerManaMax;

  /// Mana regenerated per second.
  final double playerManaRegenPerSecond;

  /// Maximum stamina points.
  final double playerStaminaMax;

  /// Stamina regenerated per second.
  final double playerStaminaRegenPerSecond;

  /// Stamina spent per jump.
  final double jumpStaminaCost;

  /// Stamina spent per dash.
  final double dashStaminaCost;
}


===== FILE: lib/core/tuning/restoration_item_tuning.dart =====
/// Restoration item spawning and restore configuration.
class RestorationItemTuning {
  const RestorationItemTuning({
    this.enabled = true,
    this.spawnEveryChunks = 16,
    this.spawnStartChunkIndex = 2,
    this.restorePercent = 0.30,
    this.itemSize = 12.0,
    this.surfaceClearanceY = 10.0,
    this.noSpawnMargin = 2.0,
    this.chunkEdgeMarginX = 32.0,
    this.maxAttemptsPerSpawn = 40,
    this.despawnBehindCameraMargin = 900.0,
  });

  /// Master toggle for restoration item spawning.
  final bool enabled;

  /// Spawn one item every N chunks.
  final int spawnEveryChunks;

  /// First chunk index where items can spawn.
  final int spawnStartChunkIndex;

  /// Fraction of max HP/mana/stamina restored [0–1].
  final double restorePercent;

  /// Collision/render size (world units).
  final double itemSize;

  /// Vertical clearance above surface (world units).
  final double surfaceClearanceY;

  /// Margin from surface edges (world units).
  final double noSpawnMargin;

  /// Margin from chunk edges (world units).
  final double chunkEdgeMarginX;

  /// Max placement attempts before giving up.
  final int maxAttemptsPerSpawn;

  /// Distance behind camera before despawn (world units).
  final double despawnBehindCameraMargin;
}


===== FILE: lib/core/tuning/score_tuning.dart =====
/// Scoring tuning (points per time, distance, kills).
library;

/// World units per meter (used for distance→score conversion).
const int kWorldUnitsPerMeter = 50;

class ScoreTuning {
  const ScoreTuning({
    this.timeScorePerSecond = 5,
    this.distanceScorePerMeter = 5,
    this.groundEnemyKillScore = 100,
    this.unocoDemonKillScore = 150,
  }) : assert(timeScorePerSecond >= 0),
       assert(distanceScorePerMeter >= 0),
       assert(groundEnemyKillScore >= 0),
       assert(unocoDemonKillScore >= 0);

  /// Points per real-time second survived (implemented deterministically via tickHz).
  final int timeScorePerSecond;

  /// Points per whole meter traveled (100 world units = 1 meter).
  final int distanceScorePerMeter;

  /// Points for killing an enemy (by type).
  final int groundEnemyKillScore;
  final int unocoDemonKillScore;
}


===== FILE: lib/core/tuning/spatial_grid_tuning.dart =====
/// Simulation tuning/config for grid-based spatial indexing (broadphase now,
/// navigation later).
///
/// Keep this separate from combat tuning: broadphase is a physics/simulation
/// concern, not a combat rule.
class SpatialGridTuning {
  const SpatialGridTuning({
    this.broadphaseCellSize = 32.0,
  });

  /// Default broadphase cell size for dynamic AABB queries.
  ///
  /// With current collider sizes (player ~16x16, enemies ~24x24), `32.0`
  /// keeps candidate sets small while keeping grid math cheap.
  final double broadphaseCellSize;
}



===== FILE: lib/core/tuning/track_tuning.dart =====
/// Track streaming / deterministic chunk spawning configuration.
///
/// This is simulation config (Core), not combat/ability tuning.
class TrackTuning {
  const TrackTuning({
    this.enabled = true,
    this.chunkWidth = 600.0,
    this.spawnAheadMargin = 600.0,
    this.cullBehindMargin = 600.0,
    this.enemyCullBelowGroundOffsetY = 300.0,
    this.gridSnap = 16.0,
    this.playerStartX = 400.0,
    this.gapKillOffsetY = 400.0,
  }) : assert(chunkWidth > 0),
       assert(spawnAheadMargin >= 0),
       assert(cullBehindMargin >= 0),
       assert(enemyCullBelowGroundOffsetY >= 0),
       assert(gridSnap > 0),
       assert(playerStartX >= 0),
       assert(gapKillOffsetY >= 0);

  /// If false, no chunk streaming is performed (static world only).
  final bool enabled;

  /// Width of a chunk in world units.
  final double chunkWidth;

  /// Spawn chunks while `cameraRight + spawnAheadMargin >= nextChunkStartX`.
  final double spawnAheadMargin;

  /// Cull chunks while `chunkEndX < cameraLeft - cullBehindMargin`.
  final double cullBehindMargin;

  /// Enemies are despawned if their bottom falls this far below groundTopY.
  final double enemyCullBelowGroundOffsetY;

  /// Authoring grid snap for chunk patterns (world units).
  final double gridSnap;

  /// Player spawn X position at run start (world units).
  final double playerStartX;

  /// How far below ground the player must fall before death triggers.
  ///
  /// Set high enough to give visual feedback of falling into the gap
  /// before the death screen appears.
  final double gapKillOffsetY;
}


===== FILE: lib/core/util/deterministic_rng.dart =====
/// Deterministic random number generation utilities.
///
/// Provides seedable, reproducible pseudo-random numbers for procedural
/// generation. Uses Xorshift32 (fast, small state) with MurmurHash3 mixing
/// for seed avalanche. All functions are pure and tick-deterministic.
library;

/// Bitmask for 32-bit unsigned integer operations.
const int _mask32 = 0xffffffff;

/// Fallback seed when mixing produces zero (Xorshift32 degenerates on zero).
const int _nonZeroSeed = 0x6d2b79f5;

/// MurmurHash3 finalizer-style bit mixer.
///
/// Produces a well-distributed 32-bit hash from any integer input.
/// Used to "avalanche" seed bits before RNG initialization.
int mix32(int x) {
  var v = x & _mask32;
  v ^= (v >> 16);
  v = (v * 0x7feb352d) & _mask32;
  v ^= (v >> 15);
  v = (v * 0x846ca68b) & _mask32;
  v ^= (v >> 16);
  return v & _mask32;
}

/// Derives a non-zero 32-bit RNG state from [seed] and [salt].
///
/// XORs seed with salt, then mixes. Guarantees non-zero output to
/// prevent Xorshift32 from degenerating into a constant sequence.
int seedFrom(int seed, int salt) {
  final mixed = mix32(seed ^ salt);
  return mixed == 0 ? _nonZeroSeed : mixed;
}

/// Advances [state] by one Xorshift32 step, returning the new state.
///
/// The returned value serves as both the next state and the random output.
/// Period: 2³²−1. Passes most statistical tests for game use.
int nextUint32(int state) {
  var x = state & _mask32;
  if (x == 0) x = _nonZeroSeed; // Guard against degenerate zero state.
  x ^= (x << 13) & _mask32;
  x ^= (x >> 17);
  x ^= (x << 5) & _mask32;
  return x & _mask32;
}

/// Converts a 32-bit unsigned [value] to a double in \[0, 1\].
///
/// Uses simple division for uniform distribution. Inclusive on both ends.
double uint32ToUnitDouble(int value) {
  return (value & _mask32) / _mask32;
}

/// Maps a 32-bit unsigned [value] to a double in \[[min], [max]\].
///
/// Automatically swaps [min]/[max] if inverted. Distribution is uniform.
double rangeDouble(int value, double min, double max) {
  final lo = min <= max ? min : max;
  final hi = min <= max ? max : min;
  return lo + (hi - lo) * uint32ToUnitDouble(value);
}


===== FILE: lib/core/util/double_math.dart =====
/// Floating-point math helpers.
///
/// Supplements `dart:math` with common operations not in the standard library.
library;

import 'dart:math';

/// Clamps [v] to the range \[[lo], [hi]\].
///
/// Returns [lo] if `v < lo`, [hi] if `v > hi`, otherwise [v].
double clampDouble(double v, double lo, double hi) => max(lo, min(hi, v));



===== FILE: lib/core/util/smoothing.dart =====
/// Smoothing utilities for frame-rate-independent interpolation.
///
/// Provides exponential smoothing factors that behave consistently
/// regardless of tick rate, useful for camera follow, UI animations, etc.
library;

import 'dart:math';

/// Returns an exponential smoothing factor α in \[0, 1\].
///
/// Given responsiveness [k] (1/seconds) and tick duration [dtSeconds],
/// computes `α = 1 − e^(−k·dt)`. Use as: `value += α * (target − value)`.
///
/// Matches the common pattern: `alpha = 1 - exp(-k * dt)`.
double expSmoothingFactor(double k, double dtSeconds) {
  if (k <= 0) return 0.0;
  if (dtSeconds <= 0) return 0.0;
  return 1.0 - exp(-k * dtSeconds);
}



===== FILE: lib/core/util/tick_math.dart =====
/// Tick/time conversion utilities.
///
/// Bridges between author-friendly seconds and simulation tick counts.
library;

import 'dart:math';

/// Converts [seconds] to tick count at [tickHz], rounding up.
///
/// Rules:
/// - `seconds <= 0` => `0` ticks
/// - otherwise `max(1, ceil(seconds * tickHz))`
int ticksFromSecondsCeil(double seconds, int tickHz) {
  if (tickHz <= 0) {
    throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
  }
  if (seconds <= 0) return 0;
  return max(1, (seconds * tickHz).ceil());
}



===== FILE: lib/core/util/vec2.dart =====
/// Minimal 2D vector type for Core ↔ UI data transfer.
///
/// Immutable, allocation-light, pure Dart. Used in snapshots and events.
/// Internal systems prefer raw `double` fields for hot loops.
library;

/// Immutable 2D vector with [x] and [y] coordinates.
class Vec2 {
  /// Creates a new immutable vector at ([x], [y]).
  const Vec2(this.x, this.y);

  /// Zero vector (0, 0).
  static const Vec2 zero = Vec2(0, 0);

  /// X coordinate (Horizontal), usually in world units/pixels.
  final double x;

  /// Y coordinate (Vertical), usually in world units/pixels.
  final double y;

  /// Returns a new [Vec2] with [x] replaced by [value].
  Vec2 withX(double value) => Vec2(value, y);

  /// Returns a new [Vec2] with [y] replaced by [value].
  Vec2 withY(double value) => Vec2(x, value);

  /// Component-wise Addition.
  Vec2 operator +(Vec2 other) => Vec2(x + other.x, y + other.y);

  /// Component-wise Subtraction.
  Vec2 operator -(Vec2 other) => Vec2(x - other.x, y - other.y);

  /// Scalar Multiplication.
  Vec2 scale(double factor) => Vec2(x * factor, y * factor);

  @override
  String toString() => 'Vec2(${x.toStringAsFixed(2)}, ${y.toStringAsFixed(2)})';
  
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Vec2 &&
          runtimeType == other.runtimeType &&
          x == other.x &&
          y == other.y;

  @override
  int get hashCode => x.hashCode ^ y.hashCode;
}


===== FILE: lib/core/util/velocity_math.dart =====
/// Velocity ramping utilities.
///
/// Helpers for smoothly accelerating/decelerating toward a target speed,
/// used by player and enemy movement systems.
library;

/// Ramps [current] velocity toward [desired] using asymmetric accel/decel.
///
/// - Accelerates at [accelPerSecond] when moving toward non-zero [desired].
/// - Decelerates at [decelPerSecond] when [desired] is zero.
/// - Snaps to zero if `|current| <= minStopSpeed` and `desired == 0`.
///
/// Returns the updated velocity after [dtSeconds].
double applyAccelDecel({
  required double current,
  required double desired,
  required double dtSeconds,
  required double accelPerSecond,
  required double decelPerSecond,
  double minStopSpeed = 0.0,
}) {
  if (dtSeconds <= 0.0) return current;
  if (desired == 0.0 && current.abs() <= minStopSpeed) return 0.0;

  final accel = desired == 0.0 ? decelPerSecond : accelPerSecond;
  final maxDelta = accel * dtSeconds;
  final delta = desired - current;
  if (delta.abs() > maxDelta) {
    return current + (delta > 0.0 ? maxDelta : -maxDelta);
  }
  return desired;
}


===== FILE: lib/core/weapons/ammo_type.dart =====
/// Ammo categories used by ranged weapons.
///
/// Stored in [AmmoStore] on entities that can fire ranged weapons.
enum AmmoType {
  arrow,
  throwingAxe,
}



===== FILE: lib/core/weapons/ranged_weapon_catalog.dart =====
import '../util/tick_math.dart';
import '../projectiles/projectile_id.dart';
import 'ammo_type.dart';
import 'ranged_weapon_def.dart';
import 'ranged_weapon_id.dart';

/// Lookup table for ranged weapon definitions.
class RangedWeaponCatalog {
  const RangedWeaponCatalog();

  RangedWeaponDef get(RangedWeaponId id) {
    switch (id) {
      case RangedWeaponId.bow:
        return const RangedWeaponDef(
          id: RangedWeaponId.bow,
          projectileId: ProjectileId.arrow,
          damage: 12.0,
          staminaCost: 4.0,
          ammoType: AmmoType.arrow,
          ammoCost: 1,
          originOffset: 8.0,
          cooldownSeconds: 0.25,
          ballistic: true,
          gravityScale: 0.8,
        );
      case RangedWeaponId.throwingAxe:
        return const RangedWeaponDef(
          id: RangedWeaponId.throwingAxe,
          projectileId: ProjectileId.throwingAxe,
          damage: 18.0,
          staminaCost: 8.0,
          ammoType: AmmoType.throwingAxe,
          ammoCost: 1,
          originOffset: 8.0,
          cooldownSeconds: 0.40,
          ballistic: true,
          gravityScale: 1.0,
        );
    }
  }
}

/// Tick-rate-aware wrapper for [RangedWeaponCatalog].
class RangedWeaponCatalogDerived {
  const RangedWeaponCatalogDerived._({required this.tickHz, required this.base});

  factory RangedWeaponCatalogDerived.from(
    RangedWeaponCatalog base, {
    required int tickHz,
  }) {
    if (tickHz <= 0) {
      throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
    }
    return RangedWeaponCatalogDerived._(tickHz: tickHz, base: base);
  }

  final int tickHz;
  final RangedWeaponCatalog base;

  int cooldownTicks(RangedWeaponId id) {
    return ticksFromSecondsCeil(base.get(id).cooldownSeconds, tickHz);
  }
}


===== FILE: lib/core/weapons/ranged_weapon_def.dart =====
import '../combat/damage_type.dart';
import '../combat/status/status.dart';
import '../projectiles/projectile_id.dart';
import 'ammo_type.dart';
import 'ranged_weapon_id.dart';

/// Static, data-first definition for a ranged weapon.
class RangedWeaponDef {
  const RangedWeaponDef({
    required this.id,
    required this.projectileId,
    required this.damage,
    this.damageType = DamageType.physical,
    this.statusProfileId = StatusProfileId.none,
    this.staminaCost = 0.0,
    required this.ammoType,
    this.ammoCost = 1,
    this.originOffset = 0.0,
    this.cooldownSeconds = 0.25,
    this.ballistic = true,
    this.gravityScale = 1.0,
  });

  final RangedWeaponId id;
  final ProjectileId projectileId;

  final double damage;
  final DamageType damageType;
  final StatusProfileId statusProfileId;

  /// Stamina consumed per shot.
  final double staminaCost;

  /// Ammo category and cost per shot.
  final AmmoType ammoType;
  final int ammoCost;

  /// How far from the caster center to spawn the projectile, along aim dir.
  final double originOffset;

  /// Cooldown after firing (seconds).
  final double cooldownSeconds;

  /// If true, projectile uses physics (gravity + world collision).
  final bool ballistic;

  /// Multiplier applied to global gravity for ballistic projectiles.
  final double gravityScale;
}



===== FILE: lib/core/weapons/ranged_weapon_id.dart =====
/// Stable identifiers for ranged/thrown weapons.
///
/// These are separate from spells: ranged weapons consume stamina + ammo and
/// spawn weapon projectiles.
enum RangedWeaponId {
  bow,
  throwingAxe,
}



===== FILE: lib/core/weapons/spawn_ranged_weapon_projectile.dart =====
/// Projectile spawning utilities for ranged weapons.
///
/// Similar to spell projectile spawning, but does not use [SpellId] or mana.
library;

import 'dart:math';

import '../combat/damage_type.dart';
import '../combat/faction.dart';
import '../combat/status/status.dart';
import '../ecs/entity_id.dart';
import '../ecs/stores/body_store.dart';
import '../ecs/stores/collider_aabb_store.dart';
import '../ecs/stores/lifetime_store.dart';
import '../ecs/stores/projectile_store.dart';
import '../ecs/world.dart';
import '../projectiles/projectile_catalog.dart';
import '../projectiles/projectile_id.dart';

/// Epsilon squared for near-zero direction detection.
const _dirEps2 = 1e-12;

({double x, double y}) _normalizeDirOrFallback(
  double x,
  double y, {
  required double fallbackX,
  required double fallbackY,
}) {
  final len2 = x * x + y * y;

  if (len2 <= _dirEps2) {
    final fbLen2 = fallbackX * fallbackX + fallbackY * fallbackY;
    if (fbLen2 <= _dirEps2) {
      return (x: 1.0, y: 0.0);
    }
    final invLen = 1.0 / sqrt(fbLen2);
    return (x: fallbackX * invLen, y: fallbackY * invLen);
  }

  final invLen = 1.0 / sqrt(len2);
  return (x: x * invLen, y: y * invLen);
}

EntityId spawnRangedWeaponProjectileFromCaster(
  EcsWorld world, {
  required ProjectileCatalogDerived projectiles,
  required ProjectileId projectileId,
  required Faction faction,
  required EntityId owner,
  required double casterX,
  required double casterY,
  required double originOffset,
  required double dirX,
  required double dirY,
  required double fallbackDirX,
  required double fallbackDirY,
  required double damage,
  required DamageType damageType,
  required StatusProfileId statusProfileId,
  required bool ballistic,
  required double gravityScale,
}) {
  final proj = projectiles.base.get(projectileId);
  final speedUnitsPerSecond = proj.speedUnitsPerSecond;

  final dir = _normalizeDirOrFallback(
    dirX,
    dirY,
    fallbackX: fallbackDirX,
    fallbackY: fallbackDirY,
  );

  final originX = casterX + dir.x * originOffset;
  final originY = casterY + dir.y * originOffset;

  final entity = world.createEntity();

  // Position and initial velocity.
  final initialVelX = dir.x * speedUnitsPerSecond;
  final initialVelY = dir.y * speedUnitsPerSecond;
  world.transform.add(
    entity,
    posX: originX,
    posY: originY,
    velX: initialVelX,
    velY: initialVelY,
  );

  world.projectile.add(
    entity,
    ProjectileDef(
      projectileId: projectileId,
      faction: faction,
      owner: owner,
      dirX: dir.x,
      dirY: dir.y,
      speedUnitsPerSecond: speedUnitsPerSecond,
      damage: damage,
      damageType: damageType,
      statusProfileId: statusProfileId,
      usePhysics: ballistic,
    ),
  );

  world.lifetime.add(
    entity,
    LifetimeDef(ticksLeft: projectiles.lifetimeTicks(projectileId)),
  );

  world.colliderAabb.add(
    entity,
    ColliderAabbDef(
      halfX: proj.colliderSizeX * 0.5,
      halfY: proj.colliderSizeY * 0.5,
    ),
  );

  if (ballistic) {
    world.body.add(
      entity,
      BodyDef(
        isKinematic: false,
        useGravity: true,
        gravityScale: gravityScale,
        sideMask: BodyDef.sideLeft | BodyDef.sideRight,
      ),
    );
    world.collision.add(entity);
  }

  return entity;
}



===== FILE: lib/core/weapons/weapon_catalog.dart =====
import '../combat/status/status.dart';
import 'weapon_def.dart';
import 'weapon_id.dart';

/// Lookup table for weapon definitions.
///
/// Similar to [SpellCatalog], but for melee weapons.
class WeaponCatalog {
  const WeaponCatalog();

  WeaponDef get(WeaponId id) {
    switch (id) {
      case WeaponId.basicSword:
        return const WeaponDef(
          id: WeaponId.basicSword,
          statusProfileId: StatusProfileId.meleeBleed,
        );
    }
  }
}



===== FILE: lib/core/weapons/weapon_def.dart =====
import '../combat/damage_type.dart';
import '../combat/status/status.dart';
import 'weapon_id.dart';

/// Static, data-first definition for a weapon.
///
/// Weapon definitions are queried by [WeaponId] and used by intent writers
/// (e.g. [PlayerMeleeSystem]) to fill combat metadata like damage type and
/// on-hit status profiles.
class WeaponDef {
  const WeaponDef({
    required this.id,
    this.damageType = DamageType.physical,
    this.statusProfileId = StatusProfileId.none,
  });

  final WeaponId id;
  final DamageType damageType;
  final StatusProfileId statusProfileId;
}



===== FILE: lib/core/weapons/weapon_id.dart =====
/// Stable identifiers for melee weapons.
///
/// These IDs are intended to be deterministic and allocation-light, similar to
/// [SpellId] for casting.
enum WeaponId {
  /// Default starter weapon.
  basicSword,
}



===== FILE: lib/game/components/aim_ray_component.dart =====
import 'package:flame/components.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/widgets.dart';

import '../../core/snapshots/entity_render_snapshot.dart';
import '../../core/snapshots/enums.dart';
import '../game_controller.dart';
import '../input/aim_preview.dart';

/// Renders a visual "aim ray" or laser sight extending from the player.
///
/// Reacts to [AimPreviewState] to show the player where their projectile
/// or ability will land.
class AimRayComponent extends Component {
  AimRayComponent({
    required this.controller,
    required this.preview,
    required this.length,
    Paint? paint,
    this.drawWhenNoAim = true,
  }) : _paint =
           paint ??
           (Paint()
             ..color = const Color.fromARGB(255, 120, 165, 236)
             ..strokeWidth = 2
             ..strokeCap = StrokeCap.round);

  /// Provides access to the game state (player position).
  final GameController controller;

  /// Reactive state for the current aim direction/status.
  final ValueListenable<AimPreviewState> preview;

  /// Length of the ray in world units (pixels).
  final double length;

  /// Whether to draw a "straight ahead" ray even when the player hasn't
  /// explicitly dragged to aim (fallback to player facing).
  final bool drawWhenNoAim;

  final Paint _paint;

  @override
  void render(Canvas canvas) {
    final state = preview.value;
    if (!state.active) return;
    if (!state.hasAim && !drawWhenNoAim) return;

    final player = controller.snapshot.playerEntity;
    if (player == null) return;

    final (dirX, dirY) = _resolveDir(state, player);
    final startX = player.pos.x;
    final startY = player.pos.y;
    final endX = startX + dirX * length;
    final endY = startY + dirY * length;

    canvas.drawLine(Offset(startX, startY), Offset(endX, endY), _paint);
  }

  /// Determines the ray direction.
  ///
  /// Uses the explicit aim if available; otherwise falls back to the player's
  /// current facing direction.
  (double, double) _resolveDir(
    AimPreviewState state,
    EntityRenderSnapshot player,
  ) {
    if (state.hasAim) {
      return (state.dirX, state.dirY);
    }
    final facing = player.facing;
    return (facing == Facing.right ? 1.0 : -1.0, 0.0);
  }
}


===== FILE: lib/game/components/pixel_parallax_backdrop_component.dart =====
// Renders a multi-layer parallax background for pixel-art games.
//
// Each layer scrolls at a fraction of the camera movement (controlled by
// `parallaxFactor`), creating depth. Layers are rendered in order, so
// earlier layers appear behind later ones.
//
// The component uses a fixed "virtual" viewport size to maintain pixel-perfect
// rendering regardless of actual screen resolution. Images are tiled horizontally
// and bottom-aligned within the viewport.
import 'dart:ui' as ui;
import 'package:flame/components.dart';
import 'package:flame/game.dart';
import 'package:flutter/painting.dart';
import '../util/math_util.dart';

/// Renders a pixel-perfect, multi-layer parallax background.
///
/// Layers are defined via [PixelParallaxLayerSpec] and rendered back-to-front.
/// Each layer's scroll position is determined by its [PixelParallaxLayerSpec.parallaxFactor]:
/// - `0.0` = static (doesn't move with camera)
/// - `1.0` = moves 1:1 with camera (no parallax effect)
/// - Values between create the classic parallax depth illusion
class PixelParallaxBackdropComponent extends Component
    with HasGameReference<FlameGame> {
  PixelParallaxBackdropComponent({
    required this.virtualWidth,
    required this.virtualHeight,
    required this.layers,
    this.snapScrollToPixels = true,
  });

  /// Width of the virtual viewport in pixels.
  final int virtualWidth;

  /// Height of the virtual viewport in pixels.
  final int virtualHeight;

  /// Layer specifications, rendered in order (index 0 = backmost).
  final List<PixelParallaxLayerSpec> layers;

  /// If true, scroll offsets are rounded to whole pixels for crisp rendering.
  final bool snapScrollToPixels;

  /// Loaded images for each layer (parallel to [layers]).
  late final List<ui.Image> _images;

  /// Previous frame's camera X position (for delta calculation).
  int? _prevCameraLeftX;

  /// Accumulated scroll offset for each layer (in pixels).
  late final List<double> _scroll;

  /// Paint configured for nearest-neighbor (pixel-perfect) filtering.
  final Paint _paint = Paint()..filterQuality = FilterQuality.none;

  @override
  Future<void> onLoad() async {
    await super.onLoad();
    _images = await Future.wait(
      layers.map((layer) => game.images.load(layer.assetPath)),
    );
    _scroll = List<double>.filled(layers.length, 0);
  }

  /// Updates scroll offsets based on camera movement.
  ///
  /// Each layer's scroll is incremented by `cameraDelta * parallaxFactor`,
  /// then wrapped to avoid floating-point overflow on long play sessions.
  @override
  void update(double dt) {
    super.update(dt);

    final viewWidth = virtualWidth;
    final cameraLeftX =
        (game.camera.viewfinder.position.x - viewWidth / 2).round();

    final prev = _prevCameraLeftX;
    _prevCameraLeftX = cameraLeftX;
    if (prev == null) return; // First frame: just record position, skip scroll.

    final delta = cameraLeftX - prev;
    if (delta == 0) return; // No camera movement, nothing to update.

    for (var i = 0; i < layers.length; i++) {
      _scroll[i] += delta * layers[i].parallaxFactor;
      // Wrap scroll to [0, imageWidth) to prevent overflow.
      _scroll[i] = positiveModDouble(_scroll[i], _images[i].width.toDouble());
    }
  }

  /// Renders all parallax layers, back-to-front.
  ///
  /// Each layer is horizontally tiled and bottom-aligned within the virtual
  /// viewport. The viewport is clipped to prevent overdraw outside bounds.
  @override
  void render(ui.Canvas canvas) {
    super.render(canvas);

    final viewWidth = virtualWidth;
    final viewHeight = virtualHeight;

    canvas.save();
    canvas.clipRect(
      ui.Rect.fromLTWH(0, 0, viewWidth.toDouble(), viewHeight.toDouble()),
    );

    for (var i = 0; i < layers.length; i++) {
      final image = _images[i];

      final imageW = image.width;
      final imageH = image.height;
      final y = (viewHeight - imageH).toDouble(); // Bottom-aligned.

      // Optionally snap to whole pixels for crisp pixel-art rendering.
      final scroll =
          snapScrollToPixels ? _scroll[i].roundToDouble() : _scroll[i];
      final offsetPx = -scroll;
      final startX = positiveModDouble(offsetPx, imageW.toDouble());

      // Tile the image across the viewport width.
      for (var x = startX - imageW; x < viewWidth; x += imageW) {
        canvas.drawImage(image, ui.Offset(x, y), _paint);
      }
    }

    canvas.restore();
  }
}

/// Configuration for a single parallax layer.
class PixelParallaxLayerSpec {
  const PixelParallaxLayerSpec({
    required this.assetPath,
    required this.parallaxFactor,
  });

  /// Path to the layer image (relative to assets/images/).
  final String assetPath;

  /// How much this layer scrolls relative to camera movement.
  ///
  /// - `0.0`: Layer is static (sky, distant mountains).
  /// - `0.5`: Layer moves at half camera speed (mid-ground).
  /// - `1.0`: Layer moves 1:1 with camera (no parallax, foreground).
  final double parallaxFactor;
}


===== FILE: lib/game/components/player/player_animations.dart =====
/// Player animation loading utilities (render layer only).
///
/// Loads horizontal sprite-strip animations from `assets/images/entities/player/`.
library;

import 'dart:ui';

import 'package:flame/cache.dart';
import 'package:flame/components.dart';

import '../../../core/snapshots/enums.dart';
import '../../../core/tuning/player_anim_defs.dart';

class PlayerAnimationSet {
  const PlayerAnimationSet({
    required this.animations,
    required this.stepTimeSecondsByKey,
    required this.oneShotKeys,
    required this.frameSize,
  });

  final Map<AnimKey, SpriteAnimation> animations;
  final Map<AnimKey, double> stepTimeSecondsByKey;
  final Set<AnimKey> oneShotKeys;

  /// Source frame size inside each horizontal strip image.
  final Vector2 frameSize;
}

Future<PlayerAnimationSet> loadPlayerAnimations(Images images) async {
  final oneShotKeys = <AnimKey>{
    AnimKey.attack,
    AnimKey.cast,
    AnimKey.dash,
    AnimKey.hit,
    AnimKey.death,
  };

  final frameSize = Vector2(
    playerAnimFrameWidth.toDouble(),
    playerAnimFrameHeight.toDouble(),
  );
  final sources = <AnimKey, String>{
    AnimKey.idle: 'entities/player/idle.png',
    AnimKey.run: 'entities/player/move.png',
    AnimKey.jump: 'entities/player/jump.png',
    AnimKey.fall: 'entities/player/fall.png',
    AnimKey.attack: 'entities/player/attack.png',
    AnimKey.cast: 'entities/player/cast.png',
    AnimKey.dash: 'entities/player/dash.png',
    AnimKey.hit: 'entities/player/hit.png',
    AnimKey.death: 'entities/player/death.png',
  };

  final imagesByKey = <AnimKey, Image>{};
  for (final entry in sources.entries) {
    imagesByKey[entry.key] = await images.load(entry.value);
  }

  final animations = <AnimKey, SpriteAnimation>{};

  for (final entry in imagesByKey.entries) {
    final key = entry.key;
    final img = entry.value;
    final stepTime =
        playerAnimStepTimeSecondsByKey[key] ?? playerAnimIdleStepSeconds;
    final frameCount =
        playerAnimFrameCountsByKey[key] ?? playerAnimIdleFrames;
    assert(
      img.height == frameSize.y.toInt() &&
          img.width == frameSize.x.toInt() * frameCount,
      'Strip ${key.name} must match ${frameSize.x.toInt()}x${frameSize.y.toInt()} frames x $frameCount.',
    );
    final data = SpriteAnimationData.sequenced(
      amount: frameCount,
      stepTime: stepTime,
      textureSize: frameSize,
      loop: !oneShotKeys.contains(key),
    );
    animations[key] = SpriteAnimation.fromFrameData(img, data);
  }

  // No dedicated spawn strip yet; map to idle for now.
  animations[AnimKey.spawn] ??= animations[AnimKey.idle]!;

  return PlayerAnimationSet(
    animations: animations,
    stepTimeSecondsByKey: playerAnimStepTimeSecondsByKey,
    oneShotKeys: oneShotKeys,
    frameSize: frameSize,
  );
}


===== FILE: lib/game/components/player/player_view_component.dart =====
/// Player render component driven purely by Core snapshots.
library;

import 'dart:math';

import 'package:flame/components.dart';
import 'package:flutter/widgets.dart';

import '../../../core/snapshots/entity_render_snapshot.dart';
import '../../../core/snapshots/enums.dart';
import 'player_animations.dart';

class PlayerViewComponent extends SpriteAnimationGroupComponent<AnimKey> {
  PlayerViewComponent({
    required PlayerAnimationSet animationSet,
    Vector2? renderSize,
    Vector2? renderScale,
  }) : _stepTimeSecondsByKey = animationSet.stepTimeSecondsByKey,
       _availableAnimations = animationSet.animations,
       _oneShotKeys = animationSet.oneShotKeys,
       _baseScale = renderScale?.clone() ?? Vector2.all(1.0),
       super(
         animations: animationSet.animations,
         current: AnimKey.idle,
         size: renderSize ??
             Vector2(animationSet.frameSize.x, animationSet.frameSize.y),
         scale: renderScale?.clone() ?? Vector2.all(1.0),
         anchor: Anchor.center,
         paint: Paint()..filterQuality = FilterQuality.none,
       ) {
    // We drive animation frames deterministically from `EntityRenderSnapshot.animFrame`.
    playing = false;
  }

  final Map<AnimKey, double> _stepTimeSecondsByKey;
  final Map<AnimKey, SpriteAnimation> _availableAnimations;
  final Set<AnimKey> _oneShotKeys;
  final Vector2 _baseScale;

  void applySnapshot(EntityRenderSnapshot e, {required int tickHz}) {
    position.setValues(e.pos.x.roundToDouble(), e.pos.y.roundToDouble());

    final nextAnim = _availableAnimations.containsKey(e.anim)
        ? e.anim
        : AnimKey.idle;
    if (current != nextAnim) {
      current = nextAnim;
    }

    final desiredScaleX = _baseScale.x * (e.facing == Facing.right ? 1.0 : -1.0);
    if (scale.x != desiredScaleX || scale.y != _baseScale.y) {
      scale.setValues(desiredScaleX, _baseScale.y);
    }

    final frameHint = e.animFrame;
    if (frameHint == null) return;

    final ticker = animationTicker;
    final anim = animation;
    if (ticker == null || anim == null) return;

    final framesLen = anim.frames.length;
    if (framesLen <= 1) return;

    final stepSeconds = _stepTimeSecondsByKey[current] ?? 0.10;
    final ticksPerFrame = max(1, (stepSeconds * tickHz).round());
    final rawIndex = frameHint ~/ ticksPerFrame;
    final index = _oneShotKeys.contains(current)
        ? rawIndex.clamp(0, framesLen - 1).toInt()
        : rawIndex % framesLen;
    ticker.currentIndex = index;
  }
}


===== FILE: lib/game/components/tiled_ground_band_component.dart =====
// Renders a horizontally-tiled ground band (e.g., grass, dirt, platforms).
//
// Supports two rendering modes:
// - **Backdrop mode** (`renderInBackdrop = true`): Renders in screen-space with
//   a fixed virtual viewport. Used for decorative ground in the parallax stack.
// - **World-space mode** (`renderInBackdrop = false`): Renders tiles in world
//   coordinates, following the camera. Used for gameplay-relevant ground.
//
// **Ground Gaps**: Both modes support "gaps" (holes in the ground) by using
// `BlendMode.clear` to punch transparent regions into the tile strip.
//
// **Performance Note**: When gaps are present, `canvas.saveLayer` is used to
// enable the clear blend mode. This incurs GPU overhead due to offscreen
// rasterization. Scenes with many gaps may see performance impact.
import 'dart:ui' as ui;

import 'package:flame/components.dart';
import 'package:flame/game.dart';
import 'package:flutter/painting.dart';

import '../../core/snapshots/static_ground_gap_snapshot.dart';
import '../game_controller.dart';
import '../util/math_util.dart';

/// Renders a horizontally-tiled ground band with optional gap support.
///
/// See file header for rendering mode details and performance considerations.
class TiledGroundBandComponent extends Component
    with HasGameReference<FlameGame> {
  TiledGroundBandComponent({
    required this.assetPath,
    required this.controller,
    this.virtualWidth,
    required this.virtualHeight,
    this.renderInBackdrop = false,
  }) {
    if (renderInBackdrop && virtualWidth == null) {
      throw ArgumentError(
        'virtualWidth is required when renderInBackdrop is true',
      );
    }
  }

  /// Path to the tile image asset (loaded via Flame's image cache).
  final String assetPath;

  /// Game controller providing snapshot data (including ground gaps).
  final GameController controller;

  /// Fixed viewport width for backdrop mode. Required when [renderInBackdrop] is true.
  final int? virtualWidth;

  /// Virtual viewport height; tiles are bottom-aligned to this value.
  final int virtualHeight;

  /// If true, render in screen-space (backdrop); otherwise, render in world-space.
  final bool renderInBackdrop;

  late final ui.Image _image;

  /// Paint with nearest-neighbor filtering for pixel-perfect rendering.
  final Paint _paint = Paint()..filterQuality = FilterQuality.none;

  /// Paint used to "punch holes" for ground gaps.
  final Paint _clearPaint = Paint()..blendMode = ui.BlendMode.clear;

  @override
  Future<void> onLoad() async {
    await super.onLoad();
    _image = await game.images.load(assetPath);
  }

  @override
  void render(ui.Canvas canvas) {
    super.render(canvas);

    final gaps = controller.snapshot.groundGaps;
    final tileW = _image.width;
    final tileH = _image.height;
    final y = (virtualHeight - tileH).toDouble(); // bottom-aligned

    if (renderInBackdrop) {
      _renderBackdropMode(canvas, gaps, tileW, tileH, y);
    } else {
      _renderWorldMode(canvas, gaps, tileW, tileH, y);
    }
  }

  /// Renders tiles in screen-space (fixed virtual viewport).
  void _renderBackdropMode(
    ui.Canvas canvas,
    List<StaticGroundGapSnapshot> gaps,
    int tileW,
    int tileH,
    double y,
  ) {
    final viewWidth = virtualWidth!;
    final cameraLeftX = game.camera.viewfinder.position.x - viewWidth / 2;
    final offsetPx = -cameraLeftX;
    final startX = positiveModDouble(offsetPx, tileW.toDouble());
    final clipRect = ui.Rect.fromLTWH(
      0,
      0,
      viewWidth.toDouble(),
      virtualHeight.toDouble(),
    );

    _withGapSupport(canvas, clipRect, gaps.isNotEmpty, () {
      _drawTileStrip(canvas, startX - tileW, viewWidth.toDouble(), tileW, y);

      if (gaps.isNotEmpty) {
        _clearGapRects(
          canvas,
          gaps: gaps,
          offsetX: -cameraLeftX,
          visibleMinX: 0.0,
          visibleMaxX: viewWidth.toDouble(),
          y: y,
          height: tileH.toDouble(),
        );
      }
    });
  }

  /// Renders tiles in world-space (following camera).
  void _renderWorldMode(
    ui.Canvas canvas,
    List<StaticGroundGapSnapshot> gaps,
    int tileW,
    int tileH,
    double y,
  ) {
    final visible = game.camera.visibleWorldRect;
    final left = visible.left.floor();
    final right = visible.right.ceil();

    final startTile = floorDivInt(left, tileW) - 1;
    final endTile = floorDivInt(right, tileW) + 1;

    final clipRect = ui.Rect.fromLTRB(
      visible.left,
      0,
      visible.right,
      virtualHeight.toDouble(),
    );

    _withGapSupport(canvas, clipRect, gaps.isNotEmpty, () {
      for (var tile = startTile; tile <= endTile; tile++) {
        final x = (tile * tileW).toDouble();
        canvas.drawImage(_image, ui.Offset(x, y), _paint);
      }

      if (gaps.isNotEmpty) {
        _clearGapRects(
          canvas,
          gaps: gaps,
          offsetX: 0.0,
          visibleMinX: visible.left,
          visibleMaxX: visible.right,
          y: y,
          height: tileH.toDouble(),
        );
      }
    });
  }

  /// Wraps rendering in saveLayer (if gaps exist) or save, then restores.
  ///
  /// When [hasGaps] is true, uses `saveLayer` to enable `BlendMode.clear`.
  /// This has GPU overhead but is necessary for punching transparent holes.
  void _withGapSupport(
    ui.Canvas canvas,
    ui.Rect clipRect,
    bool hasGaps,
    void Function() drawCallback,
  ) {
    if (hasGaps) {
      canvas.saveLayer(clipRect, Paint());
    } else {
      canvas.save();
    }
    canvas.clipRect(clipRect);

    drawCallback();

    canvas.restore();
  }

  /// Draws horizontally-tiled images from [startX] to [endX].
  void _drawTileStrip(
    ui.Canvas canvas,
    double startX,
    double endX,
    int tileW,
    double y,
  ) {
    for (var x = startX; x < endX; x += tileW) {
      canvas.drawImage(_image, ui.Offset(x, y), _paint);
    }
  }

  /// Punches transparent holes in the tile strip for each gap.
  ///
  /// Uses [_clearPaint] with `BlendMode.clear` to erase pixels. Only draws
  /// gaps that intersect the visible range `[visibleMinX, visibleMaxX]`.
  void _clearGapRects(
    ui.Canvas canvas, {
    required List<StaticGroundGapSnapshot> gaps,
    required double offsetX,
    required double visibleMinX,
    required double visibleMaxX,
    required double y,
    required double height,
  }) {
    for (final gap in gaps) {
      final x0 = gap.minX + offsetX;
      final x1 = gap.maxX + offsetX;
      if (x1 < visibleMinX || x0 > visibleMaxX) continue;
      canvas.drawRect(ui.Rect.fromLTRB(x0, y, x1, y + height), _clearPaint);
    }
  }
}


===== FILE: lib/game/game_controller.dart =====
// Bridge between Core simulation and the Flutter/Flame runtime.
//
// Responsibilities:
// - Owns the `GameCore` instance
// - Queues tick-stamped input commands
// - Runs a fixed-tick simulation loop using an accumulator
// - Exposes (`prevSnapshot`, `snapshot`, `alpha`) for render interpolation
// - Buffers transient `GameEvent`s for Render/UI to consume
import 'dart:math';

import 'package:flutter/foundation.dart';

import '../core/commands/command.dart';
import '../core/events/game_event.dart';
import '../core/game_core.dart';
import '../core/snapshots/game_state_snapshot.dart';
import '../core/tuning/score_tuning.dart';
import 'tick_input_frame.dart';

/// Owns the simulation clock and provides a stable interface to UI/renderer.
class GameController extends ChangeNotifier {
  GameController({required GameCore core, this.tickHz = 60, this.inputLead = 1})
    : _core = core {
    if (tickHz <= 0) {
      throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
    }
    if (inputLead < 1) {
      throw ArgumentError.value(inputLead, 'inputLead', 'must be >= 1');
    }
    if (tickHz != _core.tickHz) {
      throw ArgumentError(
        'GameController.tickHz ($tickHz) must match GameCore.tickHz (${_core.tickHz}).',
      );
    }
    _curr = _core.buildSnapshot();
    _prev = _curr;
  }

  final GameCore _core;

  /// Fixed simulation tick frequency.
  final int tickHz;

  /// How many ticks ahead local input is scheduled by default.
  ///
  /// `1` means "next tick".
  final int inputLead;

  /// Buffered commands keyed by their target tick.
  final Map<int, TickInputFrame> _inputsByTick = <int, TickInputFrame>{};

  /// Scratch buffer for building command lists without allocation.
  final List<Command> _commandScratch = <Command>[];

  /// Fallback input frame for ticks with no buffered commands.
  final TickInputFrame _frameScratch = TickInputFrame();

  /// Buffered transient events produced by the core.
  final List<GameEvent> _events = <GameEvent>[];

  /// The most recent [RunEndedEvent], if any.
  ///
  /// Stored separately so UI can access it after events are drained.
  RunEndedEvent? lastRunEndedEvent;

  late GameStateSnapshot _prev;
  late GameStateSnapshot _curr;

  /// Accumulated time for fixed-tick simulation.
  double _accumulatorSeconds = 0;

  /// Current simulation tick (authoritative).
  int get tick => _core.tick;

  ScoreTuning get scoreTuning => _core.scoreTuning;

  /// Latest snapshot produced by the core.
  GameStateSnapshot get snapshot => _curr;

  /// Previous snapshot (used for render interpolation).
  GameStateSnapshot get prevSnapshot => _prev;

  /// Interpolation factor between `prevSnapshot` and `snapshot` for rendering.
  double get alpha {
    final dtTick = 1.0 / tickHz;
    return (_accumulatorSeconds / dtTick).clamp(0, 1);
  }

  /// Enqueues a command to be applied at its declared tick.
  void enqueue(Command command) {
    final frame = _inputsByTick.putIfAbsent(
      command.tick,
      () => TickInputFrame(),
    );
    frame.apply(command);
  }

  /// Helper to schedule a command for the next tick (plus `inputLead`).
  void enqueueForNextTick(Command Function(int tick) factory) {
    enqueue(factory(tick + inputLead));
  }

  /// Drains and clears all buffered transient events.
  List<GameEvent> drainEvents() {
    if (_events.isEmpty) return const <GameEvent>[];
    final drained = List<GameEvent>.unmodifiable(_events);
    _events.clear();
    return drained;
  }

  /// Pauses/unpauses the simulation.
  void setPaused(bool value) {
    if (_core.paused == value) return;
    _core.paused = value;
    _accumulatorSeconds = 0;
    _prev = _core.buildSnapshot();
    _curr = _prev;
    notifyListeners();
  }

  /// Permanently stops this controller for the current session.
  ///
  /// Use this when leaving the mini-game route (dispose), NOT for backgrounding
  /// (that's what [setPaused] is for).
  ///
  /// What it does:
  /// - pauses the core
  /// - clears queued commands (prevents "stuck input" on next mount)
  /// - clears buffered transient events
  /// - resets interpolation state (accumulator + snapshots)
  void shutdown() {
    // Pause regardless of current state (do NOT early-return like setPaused()).
    _core.paused = true;

    // Drop any in-flight fixed-tick accumulation.
    _accumulatorSeconds = 0;

    // Kill transient buffers so nothing leaks across sessions.
    _inputsByTick.clear();
    _events.clear();

    // Make snapshots consistent with the paused state.
    _curr = _core.buildSnapshot();
    _prev = _curr;
    lastRunEndedEvent = null;
    notifyListeners();
  }

  /// Ends the current run early (player quit).
  ///
  /// Triggers a [RunEndedEvent] with the current score and resets interpolation.
  void giveUp() {
    if (_core.gameOver) return;
    _core.giveUp();
    _accumulatorSeconds = 0;

    _collectCoreEvents();

    _prev = _core.buildSnapshot();
    _curr = _prev;
    notifyListeners();
  }

  /// Advances the simulation clock based on a variable frame delta.
  ///
  /// This uses an accumulator to execute a fixed number of simulation ticks.
  /// [dtSeconds] is clamped to [dtFrameMaxSeconds] (default 100ms) to avoid
  /// "spiral of death" when the app resumes from background or after a lag spike.
  void advanceFrame(double dtSeconds, {double dtFrameMaxSeconds = 0.1}) {
    if (dtSeconds.isNaN || dtSeconds.isInfinite) return;
    if (_core.paused) {
      _accumulatorSeconds = 0;
      return;
    }

    final clamped = max(0.0, min(dtSeconds, dtFrameMaxSeconds));
    _accumulatorSeconds += clamped;

    final dtTick = 1.0 / tickHz;
    var didStep = false;

    while (_accumulatorSeconds >= dtTick) {
      if (_core.paused) {
        _accumulatorSeconds = 0;
        break;
      }
      final nextTick = _core.tick + 1;
      final input = _inputsByTick.remove(nextTick) ?? _frameScratch;
      _applyTickInput(nextTick, input);
      _core.stepOneTick();

      _collectCoreEvents();

      _prev = _curr;
      _curr = _core.buildSnapshot();
      _accumulatorSeconds -= dtTick;
      didStep = true;

      // If the core became paused during the tick (e.g. game over), stop consuming
      // accumulator to avoid an infinite loop.
      if (_core.paused) {
        _accumulatorSeconds = 0;
        break;
      }
    }
    if (didStep) {
      notifyListeners();
    }
  }

  /// Drains events from the core and buffers them for UI consumption.
  ///
  /// Also captures [RunEndedEvent] into [lastRunEndedEvent] for easy access.
  void _collectCoreEvents() {
    final newEvents = _core.drainEvents();
    for (final event in newEvents) {
      if (event is RunEndedEvent) {
        lastRunEndedEvent = event;
      }
    }
    if (newEvents.isNotEmpty) {
      _events.addAll(newEvents);
    }
  }

  /// Converts a [TickInputFrame] into [Command]s and applies them to the core.
  ///
  /// Uses [_commandScratch] to avoid allocating a new list each tick.
  /// Only non-default values are sent (e.g., zero axis is skipped since the
  /// core treats absence of input as no movement).
  void _applyTickInput(int tick, TickInputFrame input) {
    _commandScratch.clear();

    final axis = input.moveAxis;
    if (axis != 0) {
      _commandScratch.add(MoveAxisCommand(tick: tick, axis: axis));
    }

    if (input.projectileAimDirSet) {
      _commandScratch.add(
        ProjectileAimDirCommand(tick: tick, x: input.projectileAimDirX, y: input.projectileAimDirY),
      );
    }
    if (input.meleeAimDirSet) {
      _commandScratch.add(
        MeleeAimDirCommand(
          tick: tick,
          x: input.meleeAimDirX,
          y: input.meleeAimDirY,
        ),
      );
    }
    if (input.rangedAimDirSet) {
      _commandScratch.add(
        RangedAimDirCommand(tick: tick, x: input.rangedAimDirX, y: input.rangedAimDirY),
      );
    }
    if (input.jumpPressed) {
      _commandScratch.add(JumpPressedCommand(tick: tick));
    }
    if (input.dashPressed) {
      _commandScratch.add(DashPressedCommand(tick: tick));
    }
    if (input.attackPressed) {
      _commandScratch.add(AttackPressedCommand(tick: tick));
    }
    if (input.castPressed) {
      _commandScratch.add(CastPressedCommand(tick: tick));
    }
    if (input.rangedPressed) {
      _commandScratch.add(RangedPressedCommand(tick: tick));
    }

    _core.applyCommands(_commandScratch);

    // If this is a scratch fallback, it will be reset by the next use anyway.
    // For frames stored in the map we drop the instance after remove().
    input.reset();
  }
}


===== FILE: lib/game/input/aim_preview.dart =====
// Observable aim preview state for the UI layer.
//
// Provides reactive state so that UI widgets (e.g., aim indicators, arrows)
// can listen and update when the player begins aiming, moves the aim direction,
// or releases aim input. This decouples the input router from the rendering layer.
import 'package:flutter/foundation.dart';

/// Immutable snapshot of the current aim preview state.
///
/// - [active]: Whether the player is currently in aiming mode (e.g., touch held).
/// - [hasAim]: Whether a valid aim direction has been determined.
/// - [dirX], [dirY]: The normalized aim direction vector (only meaningful when [hasAim] is true).
class AimPreviewState {
  const AimPreviewState({
    required this.active,
    required this.hasAim,
    required this.dirX,
    required this.dirY,
  });

  /// True when the player is actively aiming (e.g., dragging on the cast button).
  final bool active;

  /// True when a valid direction has been established (drag exceeds dead zone).
  final bool hasAim;

  /// Horizontal component of the normalized aim direction.
  final double dirX;

  /// Vertical component of the normalized aim direction.
  final double dirY;

  /// Default state when the player is not aiming.
  static const AimPreviewState inactive = AimPreviewState(
    active: false,
    hasAim: false,
    dirX: 0,
    dirY: 0,
  );
}

/// Reactive model for aim preview state.
///
/// Extends [ValueNotifier] so UI widgets can listen for changes via
/// [ValueListenableBuilder] or similar patterns. The input layer updates this
/// model as the player interacts with aim controls, and the UI layer consumes
/// it to render visual feedback (e.g., directional arrow, aim reticle).
class AimPreviewModel extends ValueNotifier<AimPreviewState> {
  /// Creates an [AimPreviewModel] initialized to the inactive state.
  AimPreviewModel() : super(AimPreviewState.inactive);

  /// Called when the player starts an aiming gesture (e.g., touch down on cast button).
  ///
  /// Sets [active] to true but [hasAim] remains false until a direction is established.
  void begin() {
    value = const AimPreviewState(
      active: true,
      hasAim: false,
      dirX: 0,
      dirY: 0,
    );
  }

  /// Updates the aim direction during an active aiming gesture.
  ///
  /// [x] and [y] should be the normalized direction vector.
  /// Sets both [active] and [hasAim] to true.
  void updateAim(double x, double y) {
    value = AimPreviewState(active: true, hasAim: true, dirX: x, dirY: y);
  }

  /// Clears the aim direction while keeping the aiming gesture active.
  ///
  /// Used when the drag returns inside the dead zone—player is still touching
  /// but hasn't committed to a direction yet.
  void clearAim() {
    value = const AimPreviewState(
      active: true,
      hasAim: false,
      dirX: 0,
      dirY: 0,
    );
  }

  /// Called when the player ends the aiming gesture (e.g., touch up).
  ///
  /// Resets the model to the fully inactive state.
  void end() {
    value = AimPreviewState.inactive;
  }
}


===== FILE: lib/game/input/aim_quantizer.dart =====
// Utility for quantizing aim direction values.
//
// Quantization reduces floating-point precision to avoid scheduling redundant
// aim commands when the direction changes by negligible amounts. This improves
// determinism and reduces command spam in the input queue.

/// Quantizes aim direction components to a fixed precision.
///
/// By rounding to 1/256 increments, tiny floating-point variations (e.g., from
/// touch jitter) are collapsed into stable values. This ensures:
/// - Fewer redundant [ProjectileAimDirCommand] / [MeleeAimDirCommand] commands.
/// - Consistent behavior across frames when the aim direction is nearly unchanged.
class AimQuantizer {
  /// Private constructor to prevent instantiation; all methods are static.
  const AimQuantizer._();

  /// Quantization scale factor (256 levels per unit).
  ///
  /// Chosen to provide ~0.4% precision, which is imperceptible to players
  /// but sufficient to filter out floating-point noise.
  static const double _aimQuantizeScale = 256.0;

  /// Returns [value] rounded to the nearest 1/256 increment.
  ///
  /// Returns 0 unchanged to preserve exact zero (no aim bias).
  static double quantize(double value) {
    if (value == 0) return 0;
    return (value * _aimQuantizeScale).roundToDouble() / _aimQuantizeScale;
  }
}


===== FILE: lib/game/input/runner_input_router.dart =====
import 'dart:math';

import '../../core/commands/command.dart';
import '../game_controller.dart';
import 'aim_quantizer.dart';

/// Shared input scheduler for multiple input sources (touch + keyboard + mouse).
///
/// - Holds the current continuous inputs (move axis, projectile aim direction).
/// - Schedules them into the GameController for upcoming ticks so Core receives
///   tick-stamped Commands.
/// - Schedules edge-triggered presses (jump/dash/attack/cast) for the next tick.
///
/// The router distinguishes between:
/// - **Continuous inputs** (movement axis, aim directions): held state is pumped
///   each frame via [pumpHeldInputs], scheduling commands for upcoming ticks.
/// - **Edge-triggered inputs** (jump, dash, attack, cast): one-shot events
///   scheduled immediately for the next tick via [pressJump], [pressDash], etc.
class RunnerInputRouter {
  /// Creates a router bound to the given [controller].
  RunnerInputRouter({required this.controller});

  /// The game controller that receives scheduled commands.
  final GameController controller;

  /// Input buffering window in seconds.
  ///
  /// This determines how far ahead continuous inputs (move, aim) are scheduled
  /// to smooth over frame rate hitches.
  static const double _inputBufferSeconds = 0.1;

  // ─────────────────────────────────────────────────────────────────────────
  // Movement axis state
  // ─────────────────────────────────────────────────────────────────────────

  /// Current horizontal movement axis in [-1, 1]. Set by touch/keyboard input.
  double _moveAxis = 0;

  /// Last axis value that was scheduled, used to detect changes.
  double _lastScheduledAxis = 0;

  /// Highest tick for which axis commands have been enqueued.
  int _axisScheduledThroughTick = 0;

  // ─────────────────────────────────────────────────────────────────────────
  // Aim state channels
  // ─────────────────────────────────────────────────────────────────────────

  final _AimInputChannel _projectileAim = _AimInputChannel();

  final _AimInputChannel _meleeAim = _AimInputChannel();

  final _AimInputChannel _rangedAim = _AimInputChannel();

  // ─────────────────────────────────────────────────────────────────────────
  // Public setters for continuous inputs
  // ─────────────────────────────────────────────────────────────────────────

  /// Sets the horizontal movement axis (clamped to [-1, 1]).
  ///
  /// Called by joystick or keyboard handlers. The value is held until changed
  /// and pumped to the controller each frame via [pumpHeldInputs].
  void setMoveAxis(double axis) {
    _moveAxis = axis.clamp(-1.0, 1.0);
  }

  /// Sets the projectile aim direction (should be normalized or near-normalized).
  ///
  /// The direction is quantized to reduce floating-point noise. If the quantized
  /// value matches the current aim, the call is a no-op to avoid redundant updates.
  void setProjectileAimDir(double x, double y) => _projectileAim.set(x, y);

  /// Clears the projectile aim direction.
  ///
  /// Called when the player releases the aim input. Subsequent [pumpHeldInputs]
  /// calls will schedule [ClearProjectileAimDirCommand] for upcoming ticks.
  void clearProjectileAimDir() => _projectileAim.clear();

  /// Sets the melee aim direction (should be normalized or near-normalized).
  ///
  /// Quantized similarly to [setProjectileAimDir] to reduce jitter.
  void setMeleeAimDir(double x, double y) => _meleeAim.set(x, y);

  /// Clears the melee aim direction.
  ///
  /// Called when the player releases the melee aim input.
  void clearMeleeAimDir() => _meleeAim.clear();

  /// Sets the ranged weapon aim direction (should be normalized or near-normalized).
  void setRangedAimDir(double x, double y) => _rangedAim.set(x, y);

  /// Clears the ranged weapon aim direction.
  void clearRangedAimDir() => _rangedAim.clear();

  // ─────────────────────────────────────────────────────────────────────────
  // Edge-triggered (one-shot) input methods
  // ─────────────────────────────────────────────────────────────────────────

  /// Schedules a jump press for the next tick.
  void pressJump() =>
      controller.enqueueForNextTick((tick) => JumpPressedCommand(tick: tick));

  /// Schedules a dash press for the next tick.
  void pressDash() =>
      controller.enqueueForNextTick((tick) => DashPressedCommand(tick: tick));

  /// Schedules a melee attack press for the next tick.
  void pressAttack() =>
      controller.enqueueForNextTick((tick) => AttackPressedCommand(tick: tick));

  /// Schedules a cast (projectile) press for the next tick.
  void pressCast() =>
      controller.enqueueForNextTick((tick) => CastPressedCommand(tick: tick));

  // ─────────────────────────────────────────────────────────────────────────
  // Combined action methods (aim + action in a single tick)
  // ─────────────────────────────────────────────────────────────────────────

  /// Presses cast on the next tick and ensures the projectile aim direction is set
  /// for the same tick.
  ///
  /// Unlike [pressCast], this guarantees the aim and cast commands share the same
  /// tick, which is important for aimed projectile attacks.
  void pressCastWithAim() {
    commitCastWithAim(clearAim: false);
  }

  /// Commits cast on the next tick using the current projectile aim dir (if set).
  ///
  /// When [clearAim] is true, clear commands are delayed until after the cast
  /// tick to avoid overwriting the aimed cast.
  void commitCastWithAim({required bool clearAim}) {
    final tick = controller.tick + controller.inputLead;
    final hadAim = _projectileAim.isSet;
    if (hadAim) {
      controller.enqueue(
        ProjectileAimDirCommand(
          tick: tick,
          x: _projectileAim.x,
          y: _projectileAim.y,
        ),
      );
    }

    controller.enqueue(CastPressedCommand(tick: tick));

    if (clearAim) {
      _projectileAim.clear();
      if (hadAim) {
        // Prevent immediate clear command from overwriting the aim we just committed
        _projectileAim.blockClearThrough(tick);
      }
    }
  }

  /// Commits a melee attack on the next tick using the current melee aim dir.
  void commitMeleeAttack() {
    final tick = controller.tick + controller.inputLead;
    final hadAim = _meleeAim.isSet;
    if (hadAim) {
      controller.enqueue(
        MeleeAimDirCommand(tick: tick, x: _meleeAim.x, y: _meleeAim.y),
      );
    } else {
      controller.enqueue(ClearMeleeAimDirCommand(tick: tick));
    }
    controller.enqueue(AttackPressedCommand(tick: tick));

    // Clear aim after commit (release behavior).
    _meleeAim.clear();
    if (hadAim) {
      _meleeAim.blockClearThrough(tick);
    }
  }

  /// Commits a ranged weapon shot on the next tick using the current ranged aim dir.
  void commitRangedAttack() {
    final tick = controller.tick + controller.inputLead;
    final hadAim = _rangedAim.isSet;
    if (hadAim) {
      controller.enqueue(
        RangedAimDirCommand(tick: tick, x: _rangedAim.x, y: _rangedAim.y),
      );
    } else {
      controller.enqueue(ClearRangedAimDirCommand(tick: tick));
    }
    controller.enqueue(RangedPressedCommand(tick: tick));

    _rangedAim.clear();
    if (hadAim) {
      _rangedAim.blockClearThrough(tick);
    }
  }

  // ─────────────────────────────────────────────────────────────────────────
  // Frame pump: schedule continuous inputs for upcoming ticks
  // ─────────────────────────────────────────────────────────────────────────

  /// Schedules the current held inputs across upcoming ticks.
  ///
  /// This method should be called once per frame, before `controller.advanceFrame(dt)`,
  /// to ensure that continuous inputs (movement, aim) are scheduled far enough
  /// ahead that the simulation always has input data available.
  ///
  /// The scheduling window extends `inputLead + maxTicksPerFrame` ticks into the
  /// future to handle variable frame rates without input starvation.
  void pumpHeldInputs() {
    // 1. Movement: enqueue MoveAxisCommand for upcoming ticks (or overwrite if axis changed).
    _scheduleHeldMoveAxis();

    // 2. Projectile aim: enqueue aim direction or clear commands for upcoming ticks.
    _projectileAim.schedule(
      controller,
      _inputBufferSeconds,
      (t, x, y) => ProjectileAimDirCommand(tick: t, x: x, y: y),
      (t) => ClearProjectileAimDirCommand(tick: t),
    );

    // 3. Melee aim: same pattern as projectile, but for melee attack direction.
    _meleeAim.schedule(
      controller,
      _inputBufferSeconds,
      (t, x, y) => MeleeAimDirCommand(tick: t, x: x, y: y),
      (t) => ClearMeleeAimDirCommand(tick: t),
    );

    // 4. Ranged weapon aim: for thrown weapons / bows.
    _rangedAim.schedule(
      controller,
      _inputBufferSeconds,
      (t, x, y) => RangedAimDirCommand(tick: t, x: x, y: y),
      (t) => ClearRangedAimDirCommand(tick: t),
    );
  }

  /// Schedules [MoveAxisCommand]s for upcoming ticks based on the current axis value.
  ///
  /// Detects axis changes and re-schedules to overwrite any already-buffered ticks.
  void _scheduleHeldMoveAxis() {
    final axis = _moveAxis;

    if (axis == 0 && _lastScheduledAxis == 0) {
      // No held axis and nothing to override.
      _axisScheduledThroughTick = controller.tick;
      return;
    }

    if (axis != _lastScheduledAxis) {
      // Axis changed (including to 0); reschedule to overwrite any already
      // buffered ticks.
      _axisScheduledThroughTick = controller.tick;
      _lastScheduledAxis = axis;
    }

    final maxTicksPerFrame = (controller.tickHz * _inputBufferSeconds).ceil();
    final targetMaxTick =
        controller.tick + controller.inputLead + maxTicksPerFrame;

    final startTick = max(controller.tick + 1, _axisScheduledThroughTick + 1);
    for (var t = startTick; t <= targetMaxTick; t += 1) {
      controller.enqueue(MoveAxisCommand(tick: t, axis: axis));
    }
    _axisScheduledThroughTick = targetMaxTick;
  }
}

/// Helper class to encapsulate the state and scheduling logic for a single aim input (e.g., Projectile or Melee).
class _AimInputChannel {
  /// Whether an aim direction is currently set.
  bool isSet = false;

  /// The X component of the current aim direction (quantized).
  double x = 0;

  /// The Y component of the current aim direction (quantized).
  double y = 0;

  // -- Scheduling State --

  /// Whether the aim was set during the last schedule pass.
  bool _lastScheduledSet = false;

  /// The X component scheduled during the last pass.
  double _lastScheduledX = 0;

  /// The Y component scheduled during the last pass.
  double _lastScheduledY = 0;

  /// The highest tick for which we have already scheduled aim commands.
  int _scheduledThroughTick = 0;

  /// Tick through which clear commands are blocked.
  ///
  /// This is used when a "commit" action (like casting) uses the aim, and we want
  /// to ensure the subsequent clear command doesn't overwrite it in the same tick.
  int _clearBlockedThroughTick = 0;

  /// Updates the aim direction.
  void set(double rawX, double rawY) {
    final qx = AimQuantizer.quantize(rawX);
    final qy = AimQuantizer.quantize(rawY);

    if (isSet && qx == x && qy == y) {
      return;
    }

    isSet = true;
    x = qx;
    y = qy;
  }

  /// Clears the aim direction.
  void clear() {
    isSet = false;
    x = 0;
    y = 0;
  }

  /// Prevents `Clear...Command` from being scheduled up to and including [tick].
  void blockClearThrough(int tick) {
    _clearBlockedThroughTick = max(_clearBlockedThroughTick, tick);
  }

  /// Schedules aim or clear commands for upcoming ticks.
  ///
  /// [bufferSeconds] determines how far ahead to schedule.
  /// [createAimCmd] factory for the specific aim command (Projectile vs Melee).
  /// [createClearCmd] factory for the specific clear command.
  void schedule(
    GameController controller,
    double bufferSeconds,
    Command Function(int tick, double x, double y) createAimCmd,
    Command Function(int tick) createClearCmd,
  ) {
    if (!isSet && !_lastScheduledSet) {
      // No held aim and nothing to override.
      _scheduledThroughTick = controller.tick;
      return;
    }

    if (isSet != _lastScheduledSet) {
      // Aim active state changed; force reschedule from current tick to overwrite buffers.
      _scheduledThroughTick = controller.tick;
      _lastScheduledSet = isSet;
      _lastScheduledX = x;
      _lastScheduledY = y;
    }

    if (isSet && (x != _lastScheduledX || y != _lastScheduledY)) {
      // Vector changed; force reschedule from current tick.
      _scheduledThroughTick = controller.tick;
      _lastScheduledX = x;
      _lastScheduledY = y;
    }

    final maxTicksPerFrame = (controller.tickHz * bufferSeconds).ceil();
    final targetMaxTick =
        controller.tick + controller.inputLead + maxTicksPerFrame;

    var startTick = max(controller.tick + 1, _scheduledThroughTick + 1);

    // If we are clearing aim, ensure we don't overwrite a committed action tick.
    if (!isSet) {
      startTick = max(startTick, _clearBlockedThroughTick + 1);
    }

    for (var t = startTick; t <= targetMaxTick; t += 1) {
      if (isSet) {
        controller.enqueue(createAimCmd(t, x, y));
      } else {
        controller.enqueue(createClearCmd(t));
      }
    }
    _scheduledThroughTick = targetMaxTick;
  }
}


===== FILE: lib/game/runner_flame_game.dart =====
// Flame rendering layer for the runner (Milestone 0 placeholder).
//
// Reads the latest `GameStateSnapshot` from `GameController` each frame and
// renders a minimal representation (a player dot + debug text). This file is
// intentionally tiny and non-authoritative: gameplay truth lives in Core.
import 'package:flame/components.dart';
import 'package:flame/game.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/widgets.dart';

import '../core/contracts/render_contract.dart';
import '../core/snapshots/entity_render_snapshot.dart';
import '../core/snapshots/enums.dart';
import '../core/snapshots/static_solid_snapshot.dart';
import 'components/player/player_animations.dart';
import 'components/player/player_view_component.dart';
import 'tuning/player_render_tuning.dart';
import 'input/runner_input_router.dart';
import 'input/aim_preview.dart';
import 'components/pixel_parallax_backdrop_component.dart';
import 'components/tiled_ground_band_component.dart';
import 'components/aim_ray_component.dart';
import 'game_controller.dart';
import 'themes/parallax_theme_registry.dart';


// ─────────────────────────────────────────────────────────────────────────────
// Render priorities
// ─────────────────────────────────────────────────────────────────────────────

const _priorityBackgroundParallax = -30;
const _priorityGroundTiles = -20;
const _priorityForegroundParallax = -10;
const _priorityStaticSolids = -5;
const _priorityPlayer = -3;
const _priorityEnemies = -2;
const _priorityProjectiles = -1;
const _priorityCollectibles = -1;
const _priorityHitboxes = 1;
const _priorityProjectileAimRay = 5;
const _priorityMeleeAimRay = 6;
const _priorityRangedAimRay = 7;
const PlayerRenderTuning _playerRenderTuning = PlayerRenderTuning();

/// Minimal Flame `Game` that renders from snapshots.
class RunnerFlameGame extends FlameGame {
  RunnerFlameGame({
    required this.controller,
    required this.input,
    required this.projectileAimPreview,
    required this.meleeAimPreview,
    required this.rangedAimPreview,
  }) : super(
         camera: CameraComponent.withFixedResolution(
           width: virtualWidth.toDouble(),
           height: virtualHeight.toDouble(),
         ),
       );

  /// Bridge/controller that owns the simulation and produces snapshots.
  final GameController controller;

  /// Input scheduler/aggregator (touch + keyboard + mouse).
  final RunnerInputRouter input;

  /// UI-driven aim preview (render-only).
  final ValueListenable<AimPreviewState> projectileAimPreview;
  final ValueListenable<AimPreviewState> meleeAimPreview;
  final ValueListenable<AimPreviewState> rangedAimPreview;

  late final PlayerViewComponent _player;
  final List<RectangleComponent> _staticSolids = <RectangleComponent>[];
  List<StaticSolidSnapshot>? _lastStaticSolidsSnapshot;

  /// Entity view pools, keyed by entity ID.
  final Map<int, RectangleComponent> _projectiles = <int, RectangleComponent>{};
  final Map<int, RectangleComponent> _collectibles = <int, RectangleComponent>{};
  final Map<int, CircleComponent> _enemies = <int, CircleComponent>{};
  final Map<int, RectangleComponent> _hitboxes = <int, RectangleComponent>{};

  final Paint _projectilePaint = Paint()..color = const Color(0xFF60A5FA);
  final Map<int, Paint> _pickupPaints = <int, Paint>{
    PickupVariant.collectible: Paint()..color = const Color(0xFFFFEB3B),
    PickupVariant.restorationHealth: Paint()..color = const Color(0xFFEF4444),
    PickupVariant.restorationMana: Paint()..color = const Color(0xFF3B82F6),
    PickupVariant.restorationStamina: Paint()..color = const Color(0xFF22C55E),
  };
  final List<Paint> _enemyPaints = <Paint>[
    Paint()..color = const Color(0xFFA855F7), // purple
    Paint()..color = const Color(0xFFF97316), // orange
  ];
  final Paint _hitboxPaint = Paint()..color = const Color(0x66EF4444);

  @override
  Future<void> onLoad() async {
    await super.onLoad();
    final theme = ParallaxThemeRegistry.forThemeId(controller.snapshot.themeId);

    // Background parallax layers (sky, distant mountains, etc.)
    camera.backdrop.add(
      PixelParallaxBackdropComponent(
        virtualWidth: virtualWidth,
        virtualHeight: virtualHeight,
        snapScrollToPixels: false,
        layers: theme.backgroundLayers,
      )..priority = _priorityBackgroundParallax,
    );

    // Ground tiles (with gap support)
    camera.backdrop.add(
      TiledGroundBandComponent(
        assetPath: theme.groundLayerAsset,
        controller: controller,
        virtualWidth: virtualWidth,
        virtualHeight: virtualHeight,
        renderInBackdrop: true,
      )..priority = _priorityGroundTiles,
    );

    // Foreground parallax layers (grass, bushes, etc.)
    camera.backdrop.add(
      PixelParallaxBackdropComponent(
        virtualWidth: virtualWidth,
        virtualHeight: virtualHeight,
        snapScrollToPixels: false,
        layers: theme.foregroundLayers,
      )..priority = _priorityForegroundParallax,
    );

    final playerAnimations = await loadPlayerAnimations(images);
    _player = PlayerViewComponent(
      animationSet: playerAnimations,
      renderScale: Vector2.all(_playerRenderTuning.scale),
    )
      ..priority = _priorityPlayer;
    world.add(_player);

    world.add(
      AimRayComponent(
        controller: controller,
        preview: projectileAimPreview,
        length: projectileAimRayLength,
        drawWhenNoAim: false,
      )..priority = _priorityProjectileAimRay,
    );

    world.add(
      AimRayComponent(
        controller: controller,
        preview: meleeAimPreview,
        length: meleeAimRayLength,
        drawWhenNoAim: false,
        paint: Paint()
          ..color = const Color(0xFFDC4440)
          ..strokeWidth = 2
          ..strokeCap = StrokeCap.round,
      )..priority = _priorityMeleeAimRay,
    );

    world.add(
      AimRayComponent(
        controller: controller,
        preview: rangedAimPreview,
        length: projectileAimRayLength,
        drawWhenNoAim: false,
        paint: Paint()
          ..color = const Color(0xFFF59E0B)
          ..strokeWidth = 2
          ..strokeCap = StrokeCap.round,
      )..priority = _priorityRangedAimRay,
    );

    _mountStaticSolids(controller.snapshot.staticSolids);
    _lastStaticSolidsSnapshot = controller.snapshot.staticSolids;
  }

  @override
  void update(double dt) {
    final snapshot = controller.snapshot;
    if (!snapshot.paused && !snapshot.gameOver) {
      input.pumpHeldInputs();
    }

    super.update(dt);

    // Step the deterministic core using the frame delta, then render the
    // newest snapshot.
    controller.advanceFrame(dt);
    final updatedSnapshot = controller.snapshot;
    _syncStaticSolids(updatedSnapshot.staticSolids);

    final player = updatedSnapshot.playerEntity;
    if (player != null) {
      _player.applySnapshot(player, tickHz: controller.tickHz);
    }
    camera.viewfinder.position = Vector2(
      updatedSnapshot.cameraCenterX.roundToDouble(),
      updatedSnapshot.cameraCenterY.roundToDouble(),
    );

    _syncEnemies(updatedSnapshot.entities);
    _syncProjectiles(updatedSnapshot.entities);
    _syncCollectibles(updatedSnapshot.entities);
    _syncHitboxes(updatedSnapshot.entities);
  }

  /// Mounts static solid rectangles into the world.
  ///
  /// Called once on load and whenever the static solids list changes.
  /// One-way platforms are rendered with a green tint, solid platforms with
  /// purple.
  void _mountStaticSolids(List<StaticSolidSnapshot> solids) {
    if (solids.isEmpty) return;

    for (final solid in solids) {
      final color = solid.oneWayTop
          ? const Color(0x6648BB78) // green-ish translucent
          : const Color(0x668B5CF6); // purple translucent

      final rect = RectangleComponent(
        position: Vector2(solid.minX, solid.minY),
        size: Vector2(solid.maxX - solid.minX, solid.maxY - solid.minY),
        paint: Paint()..color = color,
      );
      rect.priority = _priorityStaticSolids;
      _staticSolids.add(rect);
      world.add(rect);
    }
  }

  /// Synchronizes enemy view components with the snapshot.
  ///
  /// Creates circle components for new enemies, updates position/rotation for
  /// existing ones, and removes components for despawned enemies.
  void _syncEnemies(List<EntityRenderSnapshot> entities) {
    final seen = <int>{};

    for (final e in entities) {
      if (e.kind != EntityKind.enemy) continue;
      seen.add(e.id);

      var view = _enemies[e.id];
      if (view == null) {
        final size = e.size;
        final radius =
            ((size != null) ? (size.x < size.y ? size.x : size.y) : 16.0) * 0.5;
        final paint = _enemyPaints[e.id % _enemyPaints.length];
        view = CircleComponent(
          radius: radius,
          anchor: Anchor.center,
          paint: paint,
        );
        view.priority = _priorityEnemies;
        _enemies[e.id] = view;
        world.add(view);
      } else {
        final size = e.size;
        if (size != null) {
          final radius = (size.x < size.y ? size.x : size.y) * 0.5;
          view.radius = radius;
        }
      }

      view.position.setValues(e.pos.x.roundToDouble(), e.pos.y.roundToDouble());
      view.angle = e.rotationRad;
    }

    if (_enemies.isEmpty) return;
    final toRemove = <int>[];
    for (final id in _enemies.keys) {
      if (!seen.contains(id)) toRemove.add(id);
    }
    for (final id in toRemove) {
      _enemies.remove(id)?.removeFromParent();
    }
  }

  /// Synchronizes projectile view components with the snapshot.
  ///
  /// Creates rectangle components for new projectiles, updates position/size
  /// for existing ones, and removes components for despawned projectiles.
  void _syncProjectiles(List<EntityRenderSnapshot> entities) {
    final seen = <int>{};

    for (final e in entities) {
      if (e.kind != EntityKind.projectile) continue;
      seen.add(e.id);

      var view = _projectiles[e.id];
      if (view == null) {
        final size = e.size;
        view = RectangleComponent(
          size: Vector2(size?.x ?? 8.0, size?.y ?? 8.0),
          anchor: Anchor.center,
          paint: _projectilePaint,
        );
        view.priority = _priorityProjectiles;
        _projectiles[e.id] = view;
        world.add(view);
      } else {
        final size = e.size;
        if (size != null) {
          view.size.setValues(size.x, size.y);
        }
      }

      view.position.setValues(e.pos.x.roundToDouble(), e.pos.y.roundToDouble());
      view.angle = e.rotationRad;
    }

    if (_projectiles.isEmpty) return;
    final toRemove = <int>[];
    for (final id in _projectiles.keys) {
      if (!seen.contains(id)) toRemove.add(id);
    }
    for (final id in toRemove) {
      _projectiles.remove(id)?.removeFromParent();
    }
  }

  /// Synchronizes collectible/pickup view components with the snapshot.
  ///
  /// Creates rectangle components for new pickups, updates position/paint for
  /// existing ones, and removes components for collected pickups.
  void _syncCollectibles(List<EntityRenderSnapshot> entities) {
    final seen = <int>{};

    for (final e in entities) {
      if (e.kind != EntityKind.pickup) continue;
      seen.add(e.id);

      var view = _collectibles[e.id];
      final variant = e.pickupVariant ?? PickupVariant.collectible;
      final paint =
          _pickupPaints[variant] ?? _pickupPaints[PickupVariant.collectible]!;
      if (view == null) {
        final size = e.size;
        view = RectangleComponent(
          size: Vector2(size?.x ?? 8.0, size?.y ?? 8.0),
          anchor: Anchor.center,
          paint: paint,
        );
        view.priority = _priorityCollectibles;
        _collectibles[e.id] = view;
        world.add(view);
      } else {
        final size = e.size;
        if (size != null) {
          view.size.setValues(size.x, size.y);
        }
        if (view.paint != paint) {
          view.paint = paint;
        }
      }

      view.position.setValues(e.pos.x.roundToDouble(), e.pos.y.roundToDouble());
      view.angle = e.rotationRad;
    }

    if (_collectibles.isEmpty) return;
    final toRemove = <int>[];
    for (final id in _collectibles.keys) {
      if (!seen.contains(id)) toRemove.add(id);
    }
    for (final id in toRemove) {
      _collectibles.remove(id)?.removeFromParent();
    }
  }

  /// Synchronizes trigger/hitbox view components with the snapshot.
  ///
  /// Creates translucent red rectangle components for new triggers, updates
  /// position/size for existing ones, and removes components for despawned
  /// triggers.
  void _syncHitboxes(List<EntityRenderSnapshot> entities) {
    final seen = <int>{};

    for (final e in entities) {
      if (e.kind != EntityKind.trigger) continue;
      seen.add(e.id);

      var view = _hitboxes[e.id];
      if (view == null) {
        final size = e.size;
        view = RectangleComponent(
          size: Vector2(size?.x ?? 8.0, size?.y ?? 8.0),
          anchor: Anchor.center,
          paint: _hitboxPaint,
        );
        view.priority = _priorityHitboxes;
        _hitboxes[e.id] = view;
        world.add(view);
      } else {
        final size = e.size;
        if (size != null) {
          view.size.setValues(size.x, size.y);
        }
      }

      view.position.setValues(e.pos.x.roundToDouble(), e.pos.y.roundToDouble());
    }

    if (_hitboxes.isEmpty) return;
    final toRemove = <int>[];
    for (final id in _hitboxes.keys) {
      if (!seen.contains(id)) toRemove.add(id);
    }
    for (final id in toRemove) {
      _hitboxes.remove(id)?.removeFromParent();
    }
  }

  /// Synchronizes static solid views with the snapshot.
  ///
  /// Uses identity comparison as a cheap version check since Core rebuilds
  /// the list only when geometry actually changes (spawn/cull).
  void _syncStaticSolids(List<StaticSolidSnapshot> solids) {
    // Core rebuilds the list only when geometry changes (spawn/cull),
    // so identity check is a cheap "version" check.
    if (identical(solids, _lastStaticSolidsSnapshot)) return;
    _lastStaticSolidsSnapshot = solids;

    for (final c in _staticSolids) {
      c.removeFromParent();
    }
    _staticSolids.clear();

    _mountStaticSolids(solids);
  }

  @override
  void onRemove() {
    images.clearCache();
    super.onRemove();
  }
}


===== FILE: lib/game/themes/parallax_theme.dart =====
/// Render-layer parallax theme configuration.
library;

import '../components/pixel_parallax_backdrop_component.dart';

class ParallaxTheme {
  const ParallaxTheme({
    required this.backgroundLayers,
    required this.groundLayerAsset,
    required this.foregroundLayers,
  });

  final List<PixelParallaxLayerSpec> backgroundLayers;
  final String groundLayerAsset;
  final List<PixelParallaxLayerSpec> foregroundLayers;
}



===== FILE: lib/game/themes/parallax_theme_registry.dart =====
/// Render-layer mapping of Core theme IDs to concrete parallax assets.
library;

import 'parallax_theme.dart';
import '../components/pixel_parallax_backdrop_component.dart';

/// Returns the [ParallaxTheme] for a given Core `themeId`.
///
/// Unknown or null theme IDs fall back to the default theme.
class ParallaxThemeRegistry {
  const ParallaxThemeRegistry._();

  static ParallaxTheme forThemeId(String? themeId) {
    switch (themeId) {
      case 'field':
        return _field;
      case 'forest':
        return _forest;
      default:
        return _field;
    }
  }
}

const ParallaxTheme _field = ParallaxTheme(
  backgroundLayers: <PixelParallaxLayerSpec>[
    PixelParallaxLayerSpec(
      assetPath: 'parallax/field/Field Layer 01.png',
      parallaxFactor: 0.10,
    ),
    PixelParallaxLayerSpec(
      assetPath: 'parallax/field/Field Layer 02.png',
      parallaxFactor: 0.15,
    ),
    PixelParallaxLayerSpec(
      assetPath: 'parallax/field/Field Layer 03.png',
      parallaxFactor: 0.20,
    ),
    PixelParallaxLayerSpec(
      assetPath: 'parallax/field/Field Layer 04.png',
      parallaxFactor: 0.30,
    ),
    PixelParallaxLayerSpec(
      assetPath: 'parallax/field/Field Layer 05.png',
      parallaxFactor: 0.40,
    ),
    PixelParallaxLayerSpec(
      assetPath: 'parallax/field/Field Layer 06.png',
      parallaxFactor: 0.50,
    ),
    PixelParallaxLayerSpec(
      assetPath: 'parallax/field/Field Layer 07.png',
      parallaxFactor: 0.60,
    ),
    PixelParallaxLayerSpec(
      assetPath: 'parallax/field/Field Layer 08.png',
      parallaxFactor: 0.70,
    ),
  ],
  groundLayerAsset: 'parallax/field/Field Layer 09.png',
  foregroundLayers: <PixelParallaxLayerSpec>[
    PixelParallaxLayerSpec(
      assetPath: 'parallax/field/Field Layer 10.png',
      parallaxFactor: 1.0,
    ),
  ],
);

const ParallaxTheme _forest = ParallaxTheme(
  backgroundLayers: <PixelParallaxLayerSpec>[
    PixelParallaxLayerSpec(
      assetPath: 'parallax/forest/Forest Layer 01.png',
      parallaxFactor: 0.10,
    ),
    PixelParallaxLayerSpec(
      assetPath: 'parallax/forest/Forest Layer 02.png',
      parallaxFactor: 0.20,
    ),
    PixelParallaxLayerSpec(
      assetPath: 'parallax/forest/Forest Layer 03.png',
      parallaxFactor: 0.30,
    ),
  ],
  groundLayerAsset: 'parallax/forest/Forest Layer 04.png',
  foregroundLayers: <PixelParallaxLayerSpec>[
    PixelParallaxLayerSpec(
      assetPath: 'parallax/forest/Forest Layer 05.png',
      parallaxFactor: 1.0,
    ),
  ],
);

===== FILE: lib/game/tick_input_frame.dart =====
// Aggregated input state for a single simulation tick.
//
// The game schedules input commands ahead of time (via RunnerInputRouter).
// Multiple commands may target the same tick, so this class merges them into
// a single coherent state that the simulation consumes.
import '../core/commands/command.dart';

/// Aggregated per-tick input for the simulation.
///
/// This replaces `List<Command>` buffering for a given tick to avoid duplicate
/// commands (e.g., multiple [MoveAxisCommand]s for the same tick). Instead of
/// storing a list, we collapse commands into their final values.
///
/// **Usage pattern:**
/// 1. [GameController] creates one [TickInputFrame] per buffered tick.
/// 2. As commands arrive, [apply] merges them into the frame.
/// 3. When the tick executes, the simulation reads the aggregated state.
/// 4. After use, [reset] clears the frame for potential reuse.
class TickInputFrame {
  // ─────────────────────────────────────────────────────────────────────────
  // Movement
  // ─────────────────────────────────────────────────────────────────────────

  /// Horizontal movement axis in [-1, 1]. Last [MoveAxisCommand] wins.
  double moveAxis = 0;

  // ─────────────────────────────────────────────────────────────────────────
  // Edge-triggered actions (one-shot per tick)
  // ─────────────────────────────────────────────────────────────────────────

  /// True if jump was pressed this tick.
  bool jumpPressed = false;

  /// True if dash was pressed this tick.
  bool dashPressed = false;

  /// True if melee attack was pressed this tick.
  bool attackPressed = false;

  /// True if cast (projectile) was pressed this tick.
  bool castPressed = false;

  /// True if ranged weapon was pressed this tick.
  bool rangedPressed = false;

  // ─────────────────────────────────────────────────────────────────────────
  // Projectile aim direction
  // ─────────────────────────────────────────────────────────────────────────

  /// Whether a projectile aim direction is set for this tick.
  bool projectileAimDirSet = false;

  /// Projectile aim X component (only valid if [projectileAimDirSet] is true).
  double projectileAimDirX = 0;

  /// Projectile aim Y component (only valid if [projectileAimDirSet] is true).
  double projectileAimDirY = 0;

  // ─────────────────────────────────────────────────────────────────────────
  // Melee aim direction
  // ─────────────────────────────────────────────────────────────────────────

  /// Whether a melee aim direction is set for this tick.
  bool meleeAimDirSet = false;

  /// Melee aim X component (only valid if [meleeAimDirSet] is true).
  double meleeAimDirX = 0;

  /// Melee aim Y component (only valid if [meleeAimDirSet] is true).
  double meleeAimDirY = 0;

  // ─────────────────────────────────────────────────────────────────────────
  // Ranged weapon aim direction
  // ─────────────────────────────────────────────────────────────────────────

  /// Whether a ranged weapon aim direction is set for this tick.
  bool rangedAimDirSet = false;

  /// Ranged weapon aim X component (only valid if [rangedAimDirSet] is true).
  double rangedAimDirX = 0;

  /// Ranged weapon aim Y component (only valid if [rangedAimDirSet] is true).
  double rangedAimDirY = 0;

  /// Applies a [Command] to this frame, merging it with existing state.
  ///
  /// For continuous inputs (move axis, aim), later commands overwrite earlier ones.
  /// For edge-triggered inputs (jump, dash, attack, cast), any press sets the flag.
  void apply(Command command) {
    switch (command) {
      case MoveAxisCommand(:final axis):
        moveAxis = axis.clamp(-1.0, 1.0);
      case JumpPressedCommand():
        jumpPressed = true;
      case DashPressedCommand():
        dashPressed = true;
      case AttackPressedCommand():
        attackPressed = true;
      case ProjectileAimDirCommand(:final x, :final y):
        projectileAimDirSet = true;
        projectileAimDirX = x;
        projectileAimDirY = y;
      case MeleeAimDirCommand(:final x, :final y):
        meleeAimDirSet = true;
        meleeAimDirX = x;
        meleeAimDirY = y;
      case ClearProjectileAimDirCommand():
        projectileAimDirSet = false;
        projectileAimDirX = 0;
        projectileAimDirY = 0;
      case ClearMeleeAimDirCommand():
        meleeAimDirSet = false;
        meleeAimDirX = 0;
        meleeAimDirY = 0;
      case CastPressedCommand():
        castPressed = true;
      case RangedAimDirCommand(:final x, :final y):
        rangedAimDirSet = true;
        rangedAimDirX = x;
        rangedAimDirY = y;
      case ClearRangedAimDirCommand():
        rangedAimDirSet = false;
        rangedAimDirX = 0;
        rangedAimDirY = 0;
      case RangedPressedCommand():
        rangedPressed = true;
    }
  }

  /// Resets all fields to their default (idle) state.
  ///
  /// Call this to reuse the frame for a new tick without allocating a new object.
  void reset() {
    moveAxis = 0;
    jumpPressed = false;
    dashPressed = false;
    attackPressed = false;
    projectileAimDirSet = false;
    projectileAimDirX = 0;
    projectileAimDirY = 0;
    meleeAimDirSet = false;
    meleeAimDirX = 0;
    meleeAimDirY = 0;
    castPressed = false;
    rangedPressed = false;
    rangedAimDirSet = false;
    rangedAimDirX = 0;
    rangedAimDirY = 0;
  }
}


===== FILE: lib/game/tuning/player_render_tuning.dart =====
/// Render-layer tuning for player sprite presentation.
library;

import 'package:flutter/foundation.dart';

@immutable
class PlayerRenderTuning {
  const PlayerRenderTuning({
    this.scale = 0.75,
  });

  /// Uniform scale applied to the 100x64 sprite frames.
  final double scale;
}


===== FILE: lib/game/util/math_util.dart =====
// Math utilities for the game layer.
//
// Provides helper functions for common math operations that Dart's standard
// library doesn't handle correctly for game use cases (e.g., negative modulo,
// floor division with negative numbers).

/// Returns `value % mod`, always in the range `[0, mod)`.
///
/// Dart's `%` operator can return negative results for negative [value];
/// this function corrects that.
double positiveModDouble(double value, double mod) {
  if (mod <= 0) throw ArgumentError.value(mod, 'mod', 'must be > 0');
  final r = value % mod;
  return r < 0 ? r + mod : r;
}

/// Integer floor division that correctly handles negative dividends.
///
/// Dart's `~/` operator truncates toward zero, which gives incorrect results
/// for negative numbers when you want true floor division (toward -∞).
///
/// Example: `-1 ~/ 16` returns `0`, but `floorDivInt(-1, 16)` returns `-1`.
int floorDivInt(int a, int b) {
  if (b <= 0) throw ArgumentError.value(b, 'b', 'must be > 0');
  if (a >= 0) return a ~/ b;
  return -(((-a) + b - 1) ~/ b);
}



===== FILE: lib/main.dart =====
import 'package:flutter/material.dart';

import 'ui/dev_menu_page.dart';

/// Development-only host app for running the mini-game standalone.
///
/// The runner is intended to be embedded in another Flutter app via
/// `RunnerGameWidget` / `createRunnerGameRoute` (see `lib/runner.dart`).
/// Keep `main.dart` free of assumptions that would prevent embedding.
void main() {
  runApp(const _DevApp());
}

class _DevApp extends StatelessWidget {
  const _DevApp();

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Walkscape Runner (Dev)',
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(
          seedColor: const Color.fromARGB(255, 6, 21, 48),
        ),
        useMaterial3: true,
      ),
      home: const DevMenuPage(),
    );
  }
}


===== FILE: lib/runner.dart =====
// Public entrypoint ("barrel file") for embedding the runner in a host app.
//
// Host apps should import only this file:
// `import 'package:walkscape_runner/runner.dart';`
//
// This keeps the public API stable while allowing internal folders/files to
// evolve without breaking downstream imports.
export 'core/levels/level_id.dart';
export 'ui/runner_game_route.dart';
export 'ui/runner_game_widget.dart';


===== FILE: lib/ui/controls/action_button.dart =====
import 'package:flutter/material.dart';

import 'cooldown_ring.dart';

class ActionButton extends StatelessWidget {
  const ActionButton({
    super.key,
    required this.label,
    required this.icon,
    required this.onPressed,
    this.affordable = true,
    this.cooldownTicksLeft = 0,
    this.cooldownTicksTotal = 0,
    this.size = 72,
    this.backgroundColor = const Color(0x33000000),
    this.foregroundColor = Colors.white,
    this.labelFontSize = 12,
    this.labelGap = 2,
  });

  final String label;
  final IconData icon;
  final VoidCallback onPressed;
  final bool affordable;
  final int cooldownTicksLeft;
  final int cooldownTicksTotal;
  final double size;
  final Color backgroundColor;
  final Color foregroundColor;
  final double labelFontSize;
  final double labelGap;

  @override
  Widget build(BuildContext context) {
    final interactable = affordable && cooldownTicksLeft <= 0;
    final effectiveForeground = affordable
        ? foregroundColor
        : _disabledForeground(foregroundColor);
    final effectiveBackground = affordable
        ? backgroundColor
        : _disabledBackground(backgroundColor);

    return SizedBox(
      width: size,
      height: size,
      child: Stack(
        fit: StackFit.expand,
        children: [
          Material(
            color: effectiveBackground,
            shape: const CircleBorder(),
            child: InkWell(
              customBorder: const CircleBorder(),
              onTap: interactable ? onPressed : null,
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(icon, color: effectiveForeground),
                  SizedBox(height: labelGap),
                  Text(
                    label,
                    style: TextStyle(
                      fontSize: labelFontSize,
                      color: effectiveForeground,
                    ),
                  ),
                ],
              ),
            ),
          ),
          IgnorePointer(
            child: CooldownRing(
              cooldownTicksLeft: cooldownTicksLeft,
              cooldownTicksTotal: cooldownTicksTotal,
            ),
          ),
        ],
      ),
    );
  }

  Color _disabledForeground(Color color) => color.withValues(alpha: 0.35);

  Color _disabledBackground(Color color) =>
      color.withValues(alpha: color.a * 0.6);
}


===== FILE: lib/ui/controls/controls_tuning.dart =====
import 'dart:ui';

import 'package:flutter/foundation.dart';

enum ControlsJoystickKind { fixed, floating }

@immutable
class ControlsTuning {
  const ControlsTuning({
    this.edgePadding = 16,
    this.bottomEdgePadding = 96,
    this.buttonGap = 12,
    this.rowGap = 12,
    this.joystickKind = ControlsJoystickKind.floating,
    this.fixedJoystick = const FixedJoystickTuning(),
    this.floatingJoystick = const FloatingJoystickTuning(),
    this.actionButton = const ActionButtonTuning(),
    this.directionalActionButton = const DirectionalActionButtonTuning(),
  });

  final double edgePadding;
  final double bottomEdgePadding;
  final double buttonGap;
  final double rowGap;

  final ControlsJoystickKind joystickKind;
  final FixedJoystickTuning fixedJoystick;
  final FloatingJoystickTuning floatingJoystick;

  final ActionButtonTuning actionButton;
  final DirectionalActionButtonTuning directionalActionButton;

  static const floating = ControlsTuning();
  static const fixed = ControlsTuning(
    joystickKind: ControlsJoystickKind.fixed,
  );
}

@immutable
class ActionButtonTuning {
  const ActionButtonTuning({
    this.size = 72,
    this.backgroundColor = const Color(0x33000000),
    this.foregroundColor = const Color(0xFFFFFFFF),
    this.labelFontSize = 12,
    this.labelGap = 2,
  });

  final double size;
  final Color backgroundColor;
  final Color foregroundColor;
  final double labelFontSize;
  final double labelGap;
}

@immutable
class DirectionalActionButtonTuning {
  const DirectionalActionButtonTuning({
    this.size = 72,
    this.deadzoneRadius = 12,
    this.backgroundColor = const Color(0x33000000),
    this.foregroundColor = const Color(0xFFFFFFFF),
    this.labelFontSize = 12,
    this.labelGap = 2,
  });

  final double size;
  final double deadzoneRadius;
  final Color backgroundColor;
  final Color foregroundColor;
  final double labelFontSize;
  final double labelGap;
}

@immutable
class FixedJoystickTuning {
  const FixedJoystickTuning({
    this.size = 120,
    this.knobSize = 56,
    this.baseColor = const Color(0x33000000),
    this.baseBorderColor = const Color(0x55FFFFFF),
    this.baseBorderWidth = 1,
    this.knobColor = const Color(0x66FFFFFF),
    this.knobBorderColor = const Color(0x88FFFFFF),
    this.knobBorderWidth = 1,
  });

  final double size;
  final double knobSize;
  final Color baseColor;
  final Color baseBorderColor;
  final double baseBorderWidth;
  final Color knobColor;
  final Color knobBorderColor;
  final double knobBorderWidth;
}

@immutable
class FloatingJoystickTuning {
  const FloatingJoystickTuning({
    this.areaSize = 220,
    this.baseSize = 120,
    this.knobSize = 56,
    this.followSmoothing = 0.25,
    this.baseColor = const Color(0x33000000),
    this.baseBorderColor = const Color(0x55FFFFFF),
    this.baseBorderWidth = 1,
    this.knobColor = const Color(0x66FFFFFF),
    this.knobBorderColor = const Color(0x88FFFFFF),
    this.knobBorderWidth = 1,
  });

  final double areaSize;
  final double baseSize;
  final double knobSize;
  final double followSmoothing;
  final Color baseColor;
  final Color baseBorderColor;
  final double baseBorderWidth;
  final Color knobColor;
  final Color knobBorderColor;
  final double knobBorderWidth;
}


===== FILE: lib/ui/controls/cooldown_ring.dart =====
import 'dart:math' as math;

import 'package:flutter/widgets.dart';

class CooldownRing extends StatelessWidget {
  const CooldownRing({
    super.key,
    required this.cooldownTicksLeft,
    required this.cooldownTicksTotal,
    this.thickness = 3,
    this.trackColor = const Color(0x66FFFFFF),
    this.progressColor = const Color(0xFFFFFFFF),
  });

  final int cooldownTicksLeft;
  final int cooldownTicksTotal;
  final double thickness;
  final Color trackColor;
  final Color progressColor;

  @override
  Widget build(BuildContext context) {
    if (cooldownTicksLeft <= 0 || cooldownTicksTotal <= 0) {
      return const SizedBox.shrink();
    }

    final clampedLeft = cooldownTicksLeft.clamp(0, cooldownTicksTotal);
    final elapsed = 1.0 - (clampedLeft / cooldownTicksTotal);

    return CustomPaint(
      painter: _CooldownRingPainter(
        elapsedFraction: elapsed.clamp(0.0, 1.0),
        thickness: thickness,
        trackColor: trackColor,
        progressColor: progressColor,
      ),
    );
  }
}

class _CooldownRingPainter extends CustomPainter {
  _CooldownRingPainter({
    required this.elapsedFraction,
    required this.thickness,
    required this.trackColor,
    required this.progressColor,
  });

  final double elapsedFraction;
  final double thickness;
  final Color trackColor;
  final Color progressColor;

  @override
  void paint(Canvas canvas, Size size) {
    final inset = thickness / 2;
    final rect = Rect.fromLTWH(
      inset,
      inset,
      size.width - thickness,
      size.height - thickness,
    );

    final trackPaint = Paint()
      ..color = trackColor
      ..style = PaintingStyle.stroke
      ..strokeWidth = thickness;

    final progressPaint = Paint()
      ..color = progressColor
      ..style = PaintingStyle.stroke
      ..strokeWidth = thickness
      ..strokeCap = StrokeCap.round;

    const startAngle = -math.pi / 2;
    canvas.drawArc(rect, startAngle, math.pi * 2, false, trackPaint);
    if (elapsedFraction > 0) {
      canvas.drawArc(
        rect,
        startAngle,
        math.pi * 2 * elapsedFraction,
        false,
        progressPaint,
      );
    }
  }

  @override
  bool shouldRepaint(covariant _CooldownRingPainter oldDelegate) {
    return oldDelegate.elapsedFraction != elapsedFraction ||
        oldDelegate.thickness != thickness ||
        oldDelegate.trackColor != trackColor ||
        oldDelegate.progressColor != progressColor;
  }
}


===== FILE: lib/ui/controls/directional_action_button.dart =====
import 'dart:math' as math;

import 'package:flutter/material.dart';

import '../../game/input/aim_preview.dart';
import '../../game/input/aim_quantizer.dart';
import 'cooldown_ring.dart';

class DirectionalActionButton extends StatefulWidget {
  const DirectionalActionButton({
    super.key,
    required this.label,
    required this.icon,
    required this.onAimDir,
    required this.onAimClear,
    required this.onCommit,
    required this.projectileAimPreview,
    this.affordable = true,
    this.cooldownTicksLeft = 0,
    this.cooldownTicksTotal = 0,
    this.size = 72,
    this.deadzoneRadius = 12,
    this.backgroundColor = const Color(0x33000000),
    this.foregroundColor = Colors.white,
    this.labelFontSize = 12,
    this.labelGap = 2,
  });

  final String label;
  final IconData icon;
  final void Function(double x, double y) onAimDir;
  final VoidCallback onAimClear;
  final VoidCallback onCommit;
  final AimPreviewModel projectileAimPreview;
  final bool affordable;
  final int cooldownTicksLeft;
  final int cooldownTicksTotal;
  final double size;
  final double deadzoneRadius;
  final Color backgroundColor;
  final Color foregroundColor;
  final double labelFontSize;
  final double labelGap;

  @override
  State<DirectionalActionButton> createState() =>
      _DirectionalActionButtonState();
}

class _DirectionalActionButtonState extends State<DirectionalActionButton> {
  int? _pointer;
  bool _leftButtonOnce = false;
  bool _canceled = false;

  @override
  Widget build(BuildContext context) {
    final interactable = widget.affordable && widget.cooldownTicksLeft <= 0;
    final effectiveForeground = widget.affordable
        ? widget.foregroundColor
        : _disabledForeground(widget.foregroundColor);
    final effectiveBackground = widget.affordable
        ? widget.backgroundColor
        : _disabledBackground(widget.backgroundColor);

    return SizedBox(
      width: widget.size,
      height: widget.size,
      child: Stack(
        fit: StackFit.expand,
        children: [
          IgnorePointer(
            ignoring: !interactable,
            child: Listener(
              onPointerDown: _handlePointerDown,
              onPointerMove: _handlePointerMove,
              onPointerUp: _handlePointerUp,
              onPointerCancel: _handlePointerCancel,
              child: Material(
                color: effectiveBackground,
                shape: const CircleBorder(),
                child: Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Icon(widget.icon, color: effectiveForeground),
                      SizedBox(height: widget.labelGap),
                      Text(
                        widget.label,
                        style: TextStyle(
                          fontSize: widget.labelFontSize,
                          color: effectiveForeground,
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            ),
          ),
          IgnorePointer(
            child: CooldownRing(
              cooldownTicksLeft: widget.cooldownTicksLeft,
              cooldownTicksTotal: widget.cooldownTicksTotal,
            ),
          ),
        ],
      ),
    );
  }

  void _handlePointerDown(PointerDownEvent event) {
    if (_pointer != null) return;
    _pointer = event.pointer;
    _leftButtonOnce = false;
    _canceled = false;
    widget.projectileAimPreview.begin();
    widget.onAimClear();
    _updateAim(event.localPosition);
  }

  void _handlePointerMove(PointerMoveEvent event) {
    if (event.pointer != _pointer) return;
    final inside = _isInside(event.localPosition);
    if (!inside && !_leftButtonOnce) {
      _leftButtonOnce = true;
    }
    if (inside && _leftButtonOnce) {
      _cancelAim();
      return;
    }
    _updateAim(event.localPosition);
  }

  void _handlePointerUp(PointerUpEvent event) {
    if (event.pointer != _pointer) return;
    if (!_canceled) {
      widget.onCommit();
    }
    _resetAim();
  }

  void _handlePointerCancel(PointerCancelEvent event) {
    if (event.pointer != _pointer) return;
    _resetAim();
  }

  void _updateAim(Offset localPosition) {
    if (_canceled) return;
    final center = Offset(widget.size / 2, widget.size / 2);
    final dx = localPosition.dx - center.dx;
    final dy = localPosition.dy - center.dy;
    final len = math.sqrt(dx * dx + dy * dy);
    if (len <= widget.deadzoneRadius) {
      widget.onAimClear();
      widget.projectileAimPreview.clearAim();
      return;
    }
    final nx = dx / len;
    final ny = dy / len;
    final qx = AimQuantizer.quantize(nx);
    final qy = AimQuantizer.quantize(ny);
    widget.onAimDir(qx, qy);
    widget.projectileAimPreview.updateAim(qx, qy);
  }

  void _cancelAim() {
    if (_canceled) return;
    _canceled = true;
    widget.onAimClear();
    widget.projectileAimPreview.end();
  }

  void _resetAim() {
    _pointer = null;
    _leftButtonOnce = false;
    _canceled = false;
    widget.onAimClear();
    widget.projectileAimPreview.end();
  }

  bool _isInside(Offset local) {
    final center = Offset(widget.size / 2, widget.size / 2);
    final dx = local.dx - center.dx;
    final dy = local.dy - center.dy;
    final radius = widget.size / 2;
    return (dx * dx + dy * dy) <= radius * radius;
  }

  Color _disabledForeground(Color color) => color.withValues(alpha: 0.35);

  Color _disabledBackground(Color color) =>
      color.withValues(alpha: color.a * 0.6);
}


===== FILE: lib/ui/controls/fixed_joystick.dart =====
import 'package:flutter/widgets.dart';

/// Fixed-position horizontal joystick.
///
/// - Only outputs an X axis in `[-1, 1]`.
/// - Centered at the widget's bounds; drag left/right to set axis.
class FixedJoystick extends StatefulWidget {
  const FixedJoystick({
    super.key,
    required this.onAxisChanged,
    this.size = 120,
    this.knobSize = 56,
    this.baseColor = const Color(0x33000000),
    this.baseBorderColor = const Color(0x55FFFFFF),
    this.baseBorderWidth = 1,
    this.knobColor = const Color(0x66FFFFFF),
    this.knobBorderColor = const Color(0x88FFFFFF),
    this.knobBorderWidth = 1,
  });

  final ValueChanged<double> onAxisChanged;
  final double size;
  final double knobSize;
  final Color baseColor;
  final Color baseBorderColor;
  final double baseBorderWidth;
  final Color knobColor;
  final Color knobBorderColor;
  final double knobBorderWidth;

  @override
  State<FixedJoystick> createState() => _FixedJoystickState();
}

class _FixedJoystickState extends State<FixedJoystick> {
  double _axis = 0;

  @override
  Widget build(BuildContext context) {
    final baseSize = widget.size;
    final knobSize = widget.knobSize;
    final radius = (baseSize - knobSize) / 2;

    return SizedBox(
      width: baseSize,
      height: baseSize,
      child: GestureDetector(
        onPanStart: (d) => _update(d.localPosition, radius),
        onPanUpdate: (d) => _update(d.localPosition, radius),
        onPanEnd: (_) => _setAxis(0),
        onPanCancel: () => _setAxis(0),
        child: Stack(
          children: [
            Positioned.fill(
              child: Center(
                child: Container(
                  width: baseSize,
                  height: baseSize,
                  decoration: BoxDecoration(
                    color: widget.baseColor,
                    shape: BoxShape.circle,
                    border: Border.all(
                      color: widget.baseBorderColor,
                      width: widget.baseBorderWidth,
                    ),
                  ),
                ),
              ),
            ),
            Positioned.fill(
              child: Center(
                child: Transform.translate(
                  offset: Offset(_axis * radius, 0),
                  child: Container(
                    width: knobSize,
                    height: knobSize,
                    decoration: BoxDecoration(
                      color: widget.knobColor,
                      shape: BoxShape.circle,
                      border: Border.all(
                        color: widget.knobBorderColor,
                        width: widget.knobBorderWidth,
                      ),
                    ),
                  ),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  void _update(Offset local, double radius) {
    final center = Offset(widget.size / 2, widget.size / 2);
    final dx = local.dx - center.dx;
    final clamped = dx.clamp(-radius, radius);
    final axis = radius <= 0 ? 0.0 : clamped / radius;
    _setAxis(axis);
  }

  void _setAxis(double axis) {
    final a = axis.clamp(-1.0, 1.0);
    if (a == _axis) return;
    setState(() => _axis = a);
    widget.onAxisChanged(a);
  }
}


===== FILE: lib/ui/controls/floating_joystick.dart =====
import 'package:flutter/widgets.dart';

/// Floating horizontal joystick.
///
/// - Touch anywhere inside the widget bounds to place the base.
/// - Drag left/right to set axis in `[-1, 1]`.
/// - Soft-follow: when dragged past the knob radius, the base eases toward the
///   pointer so the gesture stays comfortable.
/// - Release to snap back to center and hide.
class FloatingJoystick extends StatefulWidget {
  const FloatingJoystick({
    super.key,
    required this.onAxisChanged,
    this.areaSize = 220,
    this.baseSize = 120,
    this.knobSize = 56,
    this.followSmoothing = 0.25,
    this.baseColor = const Color(0x33000000),
    this.baseBorderColor = const Color(0x55FFFFFF),
    this.baseBorderWidth = 1,
    this.knobColor = const Color(0x66FFFFFF),
    this.knobBorderColor = const Color(0x88FFFFFF),
    this.knobBorderWidth = 1,
  });

  final ValueChanged<double> onAxisChanged;

  /// Size of the touch area (square).
  final double areaSize;

  /// Visual size of the joystick base circle.
  final double baseSize;

  /// Visual size of the joystick knob circle.
  final double knobSize;

  /// How strongly the base follows the pointer when stretched past the knob
  /// radius.
  ///
  /// - `0`: no follow (base stays where pressed).
  /// - `1`: hard follow (base snaps to keep the pointer on the edge).
  final double followSmoothing;
  final Color baseColor;
  final Color baseBorderColor;
  final double baseBorderWidth;
  final Color knobColor;
  final Color knobBorderColor;
  final double knobBorderWidth;

  @override
  State<FloatingJoystick> createState() => _FloatingJoystickState();
}

class _FloatingJoystickState extends State<FloatingJoystick> {
  int? _activePointer;
  Offset? _baseCenter;
  double _axis = 0;

  @override
  Widget build(BuildContext context) {
    final areaSize = widget.areaSize;
    final baseSize = widget.baseSize;
    final knobSize = widget.knobSize;
    final radius = (baseSize - knobSize) / 2;

    return SizedBox(
      width: areaSize,
      height: areaSize,
      child: Listener(
        behavior: HitTestBehavior.opaque,
        onPointerDown: (e) => _onPointerDown(e, radius),
        onPointerMove: (e) => _onPointerMove(e, radius),
        onPointerUp: _onPointerUp,
        onPointerCancel: _onPointerCancel,
        child: Stack(
          children: [
            if (_baseCenter case final baseCenter?) ...[
              _JoystickBase(
                center: baseCenter,
                size: baseSize,
                color: widget.baseColor,
                borderColor: widget.baseBorderColor,
                borderWidth: widget.baseBorderWidth,
              ),
              _JoystickKnob(
                center: baseCenter.translate(_axis * radius, 0),
                size: knobSize,
                color: widget.knobColor,
                borderColor: widget.knobBorderColor,
                borderWidth: widget.knobBorderWidth,
              ),
            ],
          ],
        ),
      ),
    );
  }

  void _onPointerDown(PointerDownEvent event, double radius) {
    if (_activePointer != null) return;
    final center = _clampBaseCenter(event.localPosition);
    setState(() {
      _activePointer = event.pointer;
      _baseCenter = center;
      _axis = 0;
    });
    widget.onAxisChanged(0);
  }

  void _onPointerMove(PointerMoveEvent event, double radius) {
    if (event.pointer != _activePointer) return;
    final baseCenter = _baseCenter;
    if (baseCenter == null) return;

    final pointer = event.localPosition;

    var nextBaseCenter = baseCenter;
    if (radius > 0) {
      final delta = pointer - baseCenter;
      final dist = delta.distance;
      if (dist > radius && dist > 0) {
        final targetBaseCenter = pointer - (delta / dist) * radius;
        final t = widget.followSmoothing.clamp(0.0, 1.0).toDouble();
        nextBaseCenter =
            Offset.lerp(baseCenter, targetBaseCenter, t) ?? baseCenter;
        nextBaseCenter = _clampBaseCenter(nextBaseCenter);
      }
    }

    final dx = pointer.dx - nextBaseCenter.dx;
    final clamped = dx.clamp(-radius, radius);
    final axis = radius <= 0 ? 0.0 : clamped / radius;
    _setBaseAndAxis(baseCenter: nextBaseCenter, axis: axis);
  }

  void _onPointerUp(PointerUpEvent event) {
    if (event.pointer != _activePointer) return;
    _reset();
  }

  void _onPointerCancel(PointerCancelEvent event) {
    if (event.pointer != _activePointer) return;
    _reset();
  }

  Offset _clampBaseCenter(Offset local) {
    final areaSize = widget.areaSize;
    final baseSize = widget.baseSize;
    final halfBase = baseSize / 2;

    if (areaSize <= baseSize) {
      return Offset(areaSize / 2, areaSize / 2);
    }

    final clampedX = local.dx.clamp(halfBase, areaSize - halfBase).toDouble();
    final clampedY = local.dy.clamp(halfBase, areaSize - halfBase).toDouble();
    return Offset(clampedX, clampedY);
  }

  void _reset() {
    final shouldNotify = _axis != 0;
    setState(() {
      _activePointer = null;
      _baseCenter = null;
      _axis = 0;
    });
    if (shouldNotify) widget.onAxisChanged(0);
  }

  void _setBaseAndAxis({required Offset baseCenter, required double axis}) {
    final nextAxis = axis.clamp(-1.0, 1.0);
    final axisChanged = nextAxis != _axis;
    final baseChanged = baseCenter != _baseCenter;
    if (!axisChanged && !baseChanged) return;

    setState(() {
      _baseCenter = baseCenter;
      _axis = nextAxis;
    });
    if (axisChanged) widget.onAxisChanged(nextAxis);
  }
}

class _JoystickBase extends StatelessWidget {
  const _JoystickBase({
    required this.center,
    required this.size,
    required this.color,
    required this.borderColor,
    required this.borderWidth,
  });

  final Offset center;
  final double size;
  final Color color;
  final Color borderColor;
  final double borderWidth;

  @override
  Widget build(BuildContext context) {
    return Positioned(
      left: center.dx - size / 2,
      top: center.dy - size / 2,
      width: size,
      height: size,
      child: Container(
        decoration: BoxDecoration(
          color: color,
          shape: BoxShape.circle,
          border: Border.all(color: borderColor, width: borderWidth),
        ),
      ),
    );
  }
}

class _JoystickKnob extends StatelessWidget {
  const _JoystickKnob({
    required this.center,
    required this.size,
    required this.color,
    required this.borderColor,
    required this.borderWidth,
  });

  final Offset center;
  final double size;
  final Color color;
  final Color borderColor;
  final double borderWidth;

  @override
  Widget build(BuildContext context) {
    return Positioned(
      left: center.dx - size / 2,
      top: center.dy - size / 2,
      width: size,
      height: size,
      child: Container(
        decoration: BoxDecoration(
          color: color,
          shape: BoxShape.circle,
          border: Border.all(color: borderColor, width: borderWidth),
        ),
      ),
    );
  }
}


===== FILE: lib/ui/controls/runner_controls_overlay.dart =====
import 'dart:math' as math;

import 'package:flutter/material.dart';

import '../../game/input/aim_preview.dart';
import 'action_button.dart';
import 'controls_tuning.dart';
import 'directional_action_button.dart';
import 'fixed_joystick.dart';
import 'floating_joystick.dart';

class RunnerControlsOverlay extends StatelessWidget {
  const RunnerControlsOverlay({
    super.key,
    required this.onMoveAxis,
    required this.onJumpPressed,
    required this.onDashPressed,
    required this.onCastCommitted,
    required this.onProjectileAimDir,
    required this.onProjectileAimClear,
    required this.projectileAimPreview,
    required this.projectileAffordable,
    required this.projectileCooldownTicksLeft,
    required this.projectileCooldownTicksTotal,
    required this.onMeleeAimDir,
    required this.onMeleeAimClear,
    required this.onMeleeCommitted,
    required this.meleeAimPreview,
    required this.meleeAffordable,
    required this.meleeCooldownTicksLeft,
    required this.meleeCooldownTicksTotal,
    required this.onRangedAimDir,
    required this.onRangedAimClear,
    required this.onRangedCommitted,
    required this.rangedAimPreview,
    required this.rangedAffordable,
    required this.rangedCooldownTicksLeft,
    required this.rangedCooldownTicksTotal,
    required this.jumpAffordable,
    required this.dashAffordable,
    required this.dashCooldownTicksLeft,
    required this.dashCooldownTicksTotal,
    this.tuning = ControlsTuning.fixed,
  });

  final ValueChanged<double> onMoveAxis;
  final VoidCallback onJumpPressed;
  final VoidCallback onDashPressed;
  final VoidCallback onCastCommitted;
  final void Function(double x, double y) onProjectileAimDir;
  final VoidCallback onProjectileAimClear;
  final AimPreviewModel projectileAimPreview;
  final bool projectileAffordable;
  final int projectileCooldownTicksLeft;
  final int projectileCooldownTicksTotal;
  final void Function(double x, double y) onMeleeAimDir;
  final VoidCallback onMeleeAimClear;
  final VoidCallback onMeleeCommitted;
  final AimPreviewModel meleeAimPreview;
  final bool meleeAffordable;
  final int meleeCooldownTicksLeft;
  final int meleeCooldownTicksTotal;
  final void Function(double x, double y) onRangedAimDir;
  final VoidCallback onRangedAimClear;
  final VoidCallback onRangedCommitted;
  final AimPreviewModel rangedAimPreview;
  final bool rangedAffordable;
  final int rangedCooldownTicksLeft;
  final int rangedCooldownTicksTotal;
  final bool jumpAffordable;
  final bool dashAffordable;
  final int dashCooldownTicksLeft;
  final int dashCooldownTicksTotal;
  final ControlsTuning tuning;

  @override
  Widget build(BuildContext context) {
    final t = tuning;
    final action = t.actionButton;
    final directional = t.directionalActionButton;
    final jumpSize = action.size * 1.50;
    final smallActionSize = action.size * 0.85;
    final smallDirectionalSize = directional.size * 0.85;
    final smallDeadzoneRadius = directional.deadzoneRadius * 0.85;

    Offset polar(double radius, double degrees) {
      final radians = degrees * math.pi / 180.0;
      return Offset(math.cos(radians) * radius, math.sin(radians) * radius);
    }

    double rightFor(Offset centerOffset, double targetSize) {
      return t.edgePadding + jumpSize * 0.5 - centerOffset.dx - targetSize * 0.5;
    }

    double bottomFor(Offset centerOffset, double targetSize) {
      return t.edgePadding + jumpSize * 0.5 - centerOffset.dy - targetSize * 0.5;
    }

    final jumpRadius = jumpSize * 0.5;
    final arcGap = t.buttonGap * 0.8;
    final arcRadius = jumpRadius + smallDirectionalSize * 0.5 + arcGap;
    final dashRadius = jumpRadius + smallActionSize * 0.5 + arcGap;

    final dashOffset = polar(dashRadius, 160);
    final meleeOffset = polar(arcRadius, 200);
    final spellOffset = polar(arcRadius, 240);
    final throwOffset = polar(arcRadius, 280);

    return Stack(
      children: [
        Positioned(
          left: t.edgePadding,
          bottom: t.bottomEdgePadding,
          child: t.joystickKind == ControlsJoystickKind.floating
              ? FloatingJoystick(
                  onAxisChanged: onMoveAxis,
                  areaSize: t.floatingJoystick.areaSize,
                  baseSize: t.floatingJoystick.baseSize,
                  knobSize: t.floatingJoystick.knobSize,
                  followSmoothing: t.floatingJoystick.followSmoothing,
                  baseColor: t.floatingJoystick.baseColor,
                  baseBorderColor: t.floatingJoystick.baseBorderColor,
                  baseBorderWidth: t.floatingJoystick.baseBorderWidth,
                  knobColor: t.floatingJoystick.knobColor,
                  knobBorderColor: t.floatingJoystick.knobBorderColor,
                  knobBorderWidth: t.floatingJoystick.knobBorderWidth,
                )
              : FixedJoystick(
                  onAxisChanged: onMoveAxis,
                  size: t.fixedJoystick.size,
                  knobSize: t.fixedJoystick.knobSize,
                  baseColor: t.fixedJoystick.baseColor,
                  baseBorderColor: t.fixedJoystick.baseBorderColor,
                  baseBorderWidth: t.fixedJoystick.baseBorderWidth,
                  knobColor: t.fixedJoystick.knobColor,
                  knobBorderColor: t.fixedJoystick.knobBorderColor,
                  knobBorderWidth: t.fixedJoystick.knobBorderWidth,
                ),
        ),
        Positioned(
          right: rightFor(throwOffset, smallDirectionalSize),
          bottom: bottomFor(throwOffset, smallDirectionalSize),
          child: DirectionalActionButton(
            label: 'Throw',
            icon: Icons.near_me,
            onAimDir: onRangedAimDir,
            onAimClear: onRangedAimClear,
            onCommit: onRangedCommitted,
            projectileAimPreview: rangedAimPreview,
            affordable: rangedAffordable,
            cooldownTicksLeft: rangedCooldownTicksLeft,
            cooldownTicksTotal: rangedCooldownTicksTotal,
            size: smallDirectionalSize,
            deadzoneRadius: smallDeadzoneRadius,
            backgroundColor: directional.backgroundColor,
            foregroundColor: directional.foregroundColor,
            labelFontSize: directional.labelFontSize,
            labelGap: directional.labelGap,
          ),
        ),
        Positioned(
          right: rightFor(spellOffset, smallDirectionalSize),
          bottom: bottomFor(spellOffset, smallDirectionalSize),
          child: DirectionalActionButton(
            label: 'Spell',
            icon: Icons.auto_awesome,
            onAimDir: onProjectileAimDir,
            onAimClear: onProjectileAimClear,
            onCommit: onCastCommitted,
            projectileAimPreview: projectileAimPreview,
            affordable: projectileAffordable,
            cooldownTicksLeft: projectileCooldownTicksLeft,
            cooldownTicksTotal: projectileCooldownTicksTotal,
            size: smallDirectionalSize,
            deadzoneRadius: smallDeadzoneRadius,
            backgroundColor: directional.backgroundColor,
            foregroundColor: directional.foregroundColor,
            labelFontSize: directional.labelFontSize,
            labelGap: directional.labelGap,
          ),
        ),
        Positioned(
          right: rightFor(meleeOffset, smallDirectionalSize),
          bottom: bottomFor(meleeOffset, smallDirectionalSize),
          child: DirectionalActionButton(
            label: 'Atk',
            icon: Icons.close,
            onAimDir: onMeleeAimDir,
            onAimClear: onMeleeAimClear,
            onCommit: onMeleeCommitted,
            projectileAimPreview: meleeAimPreview,
            affordable: meleeAffordable,
            cooldownTicksLeft: meleeCooldownTicksLeft,
            cooldownTicksTotal: meleeCooldownTicksTotal,
            size: smallDirectionalSize,
            deadzoneRadius: smallDeadzoneRadius,
            backgroundColor: directional.backgroundColor,
            foregroundColor: directional.foregroundColor,
            labelFontSize: directional.labelFontSize,
            labelGap: directional.labelGap,
          ),
        ),
        Positioned(
          right: rightFor(dashOffset, smallActionSize),
          bottom: bottomFor(dashOffset, smallActionSize),
          child: ActionButton(
            label: 'Dash',
            icon: Icons.flash_on,
            onPressed: onDashPressed,
            affordable: dashAffordable,
            cooldownTicksLeft: dashCooldownTicksLeft,
            cooldownTicksTotal: dashCooldownTicksTotal,
            size: smallActionSize,
            backgroundColor: action.backgroundColor,
            foregroundColor: action.foregroundColor,
            labelFontSize: action.labelFontSize,
            labelGap: action.labelGap,
          ),
        ),
        Positioned(
          right: t.edgePadding,
          bottom: t.edgePadding,
          child: ActionButton(
            label: 'Jump',
            icon: Icons.arrow_upward,
            onPressed: onJumpPressed,
            affordable: jumpAffordable,
            size: jumpSize,
            backgroundColor: action.backgroundColor,
            foregroundColor: action.foregroundColor,
            labelFontSize: action.labelFontSize,
            labelGap: action.labelGap,
          ),
        ),
      ],
    );
  }
}


===== FILE: lib/ui/dev_menu_page.dart =====
import 'package:flutter/material.dart';

import 'menus/runner_menu_page.dart';

/// Development-only menu used by the standalone host app (`lib/main.dart`).
///
/// Not part of the embeddable runner API. Host apps should integrate the game
/// via `RunnerGameWidget` / `createRunnerGameRoute` (see `lib/runner.dart`).
class DevMenuPage extends StatelessWidget {
  const DevMenuPage({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text(
          'Walkscape Runner (Dev)',
          style: TextStyle(color: Colors.white),
        ),
        backgroundColor: Color.fromARGB(255, 6, 21, 48),
      ),
      body: Center(
        child: FilledButton(
          onPressed: () {
            Navigator.of(context).push(
              MaterialPageRoute<void>(
                builder: (context) => const RunnerMenuPage(),
              ),
            );
          },
          child: const Text('Menu'),
        ),
      ),
    );
  }
}


===== FILE: lib/ui/hud/game/exit_button_overlay.dart =====
import 'package:flutter/material.dart';

class ExitButtonOverlay extends StatelessWidget {
  const ExitButtonOverlay({
    super.key,
    required this.onPressed,
    required this.highlight,
  });

  final VoidCallback? onPressed;
  final bool highlight;

  @override
  Widget build(BuildContext context) {
    return Align(
      alignment: Alignment.topRight,
      child: Padding(
        padding: const EdgeInsets.all(8),
        child: IconButton(
          onPressed: onPressed,
          icon: const Icon(Icons.close),
          color: highlight ? Colors.white : null,
        ),
      ),
    );
  }
}


===== FILE: lib/ui/hud/game/game_overlay.dart =====
import 'package:flutter/widgets.dart';

import '../../../game/game_controller.dart';
import '../../../game/input/aim_preview.dart';
import '../../../game/input/runner_input_router.dart';
import '../../controls/runner_controls_overlay.dart';
import '../../runner_game_ui_state.dart';
import 'pause_overlay.dart';
import 'ready_overlay.dart';
import 'top_center_hud_overlay.dart';
import 'top_left_hud_overlay.dart';
import 'top_right_hud_overlay.dart';

class GameOverlay extends StatelessWidget {
  const GameOverlay({
    super.key,
    required this.controller,
    required this.input,
    required this.projectileAimPreview,
    required this.meleeAimPreview,
    required this.rangedAimPreview,
    required this.uiState,
    required this.onStart,
    required this.onTogglePause,
    required this.showExitButton,
    required this.onExit,
  });

  final GameController controller;
  final RunnerInputRouter input;
  final AimPreviewModel projectileAimPreview;
  final AimPreviewModel meleeAimPreview;
  final AimPreviewModel rangedAimPreview;
  final RunnerGameUiState uiState;
  final VoidCallback onStart;
  final VoidCallback onTogglePause;
  final bool showExitButton;
  final VoidCallback? onExit;

  @override
  Widget build(BuildContext context) {
    final hud = controller.snapshot.hud;

    return Stack(
      fit: StackFit.expand,
      children: [
        IgnorePointer(
          ignoring: !uiState.isRunning,
          child: RunnerControlsOverlay(
            onMoveAxis: input.setMoveAxis,
            onJumpPressed: input.pressJump,
            onDashPressed: input.pressDash,
            onCastCommitted: () => input.commitCastWithAim(clearAim: true),
            onProjectileAimDir: input.setProjectileAimDir,
            onProjectileAimClear: input.clearProjectileAimDir,
            projectileAimPreview: projectileAimPreview,
            projectileAffordable: hud.canAffordProjectile,
            projectileCooldownTicksLeft: hud.projectileCooldownTicksLeft,
            projectileCooldownTicksTotal: hud.projectileCooldownTicksTotal,
            onMeleeAimDir: input.setMeleeAimDir,
            onMeleeAimClear: input.clearMeleeAimDir,
            onMeleeCommitted: input.commitMeleeAttack,
            meleeAimPreview: meleeAimPreview,
            meleeAffordable: hud.canAffordMelee,
            meleeCooldownTicksLeft: hud.meleeCooldownTicksLeft,
            meleeCooldownTicksTotal: hud.meleeCooldownTicksTotal,
            onRangedAimDir: input.setRangedAimDir,
            onRangedAimClear: input.clearRangedAimDir,
            onRangedCommitted: input.commitRangedAttack,
            rangedAimPreview: rangedAimPreview,
            rangedAffordable: hud.canAffordRangedWeapon,
            rangedCooldownTicksLeft: hud.rangedWeaponCooldownTicksLeft,
            rangedCooldownTicksTotal: hud.rangedWeaponCooldownTicksTotal,
            jumpAffordable: hud.canAffordJump,
            dashAffordable: hud.canAffordDash,
            dashCooldownTicksLeft: hud.dashCooldownTicksLeft,
            dashCooldownTicksTotal: hud.dashCooldownTicksTotal,
          ),
        ),
        PauseOverlay(visible: uiState.showPauseOverlay),
        ReadyOverlay(visible: uiState.showReadyOverlay, onTap: onStart),
        Align(
          alignment: Alignment.topLeft,
          child: Padding(
            padding: const EdgeInsets.all(12),
            child: TopLeftHudOverlay(controller: controller),
          ),
        ),
        TopCenterHudOverlay(
          controller: controller,
          uiState: uiState,
          onStart: onStart,
          onTogglePause: onTogglePause,
        ),
        TopRightHudOverlay(
          controller: controller,
          showExitButton: showExitButton,
          onExit: onExit,
        ),
      ],
    );
  }
}


===== FILE: lib/ui/hud/game/pause_overlay.dart =====
import 'package:flutter/widgets.dart';

class PauseOverlay extends StatelessWidget {
  const PauseOverlay({super.key, required this.visible});

  final bool visible;

  @override
  Widget build(BuildContext context) {
    if (!visible) return const SizedBox.shrink();

    return const IgnorePointer(child: ColoredBox(color: Color(0x66000000)));
  }
}


===== FILE: lib/ui/hud/game/ready_overlay.dart =====
import 'package:flutter/widgets.dart';

class ReadyOverlay extends StatelessWidget {
  const ReadyOverlay({super.key, required this.visible, required this.onTap});

  final bool visible;
  final VoidCallback onTap;

  @override
  Widget build(BuildContext context) {
    if (!visible) return const SizedBox.shrink();

    return GestureDetector(
      behavior: HitTestBehavior.opaque,
      onTap: onTap,
      child: const ColoredBox(
        color: Color(0x88000000),
        child: Center(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Text(
                'Tap to start',
                style: TextStyle(
                  color: Color(0xFFFFFFFF),
                  fontSize: 28,
                  fontWeight: FontWeight.w600,
                ),
              ),
              SizedBox(height: 8),
              Text(
                'Survive as long as possible',
                style: TextStyle(color: Color(0xB3FFFFFF), fontSize: 14),
              ),
            ],
          ),
        ),
      ),
    );
  }
}


===== FILE: lib/ui/hud/game/score_overlay.dart =====
import 'dart:ui' show Color, FontFeature;

import 'package:flutter/widgets.dart';

import '../../../game/game_controller.dart';

class ScoreOverlay extends StatelessWidget {
  const ScoreOverlay({
    super.key,
    required this.controller,
    this.padding = const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
  });

  final GameController controller;
  final EdgeInsets padding;

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: controller,
      builder: (context, _) {
        final distanceMeters =
            (controller.snapshot.distance / 100.0).floor();
        final collectibles = controller.snapshot.hud.collectibles;
        return IgnorePointer(
          child: RepaintBoundary(
            child: Container(
              padding: padding,
              decoration: BoxDecoration(
                color: const Color(0x66000000),
                borderRadius: BorderRadius.circular(10),
              ),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Text(
                    'Distance ${distanceMeters}m',
                    textAlign: TextAlign.center,
                    style: const TextStyle(
                      fontSize: 14,
                      color: Color(0xFFFFFFFF),
                      fontFeatures: [FontFeature.tabularFigures()],
                    ),
                  ),
                  const SizedBox(height: 2),
                  Text(
                    'Collectibles $collectibles',
                    textAlign: TextAlign.center,
                    style: const TextStyle(
                      fontSize: 14,
                      color: Color(0xFFFFFFFF),
                      fontFeatures: [FontFeature.tabularFigures()],
                    ),
                  ),
                ],
              ),
            ),
          ),
        );
      },
    );
  }
}


===== FILE: lib/ui/hud/game/start_pause_button_overlay.dart =====
import 'package:flutter/material.dart';

import '../../runner_game_ui_state.dart';

class StartPauseButtonOverlay extends StatelessWidget {
  const StartPauseButtonOverlay({
    super.key,
    required this.uiState,
    required this.onStart,
    required this.onTogglePause,
  });

  final RunnerGameUiState uiState;
  final VoidCallback onStart;
  final VoidCallback onTogglePause;

  @override
  Widget build(BuildContext context) {
    return IconButton(
      onPressed: uiState.gameOver
          ? null
          : () {
              if (!uiState.started) {
                onStart();
                return;
              }
              onTogglePause();
            },
      icon: Icon(uiState.paused ? Icons.play_arrow : Icons.pause),
      color: Colors.white,
      tooltip: uiState.paused ? 'Play' : 'Pause',
    );
  }
}


===== FILE: lib/ui/hud/game/survival_timer_overlay.dart =====
import 'package:flutter/widgets.dart';

import '../../../game/game_controller.dart';

class SurvivalTimerOverlay extends StatelessWidget {
  const SurvivalTimerOverlay({
    super.key,
    required this.controller,
    this.padding = const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
  });

  final GameController controller;
  final EdgeInsets padding;

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: controller,
      builder: (context, _) {
        final ticks = controller.snapshot.tick;
        final hz = controller.tickHz;

        final totalSeconds = ticks ~/ hz;
        final minutes = totalSeconds ~/ 60;
        final seconds = totalSeconds % 60;

        final text =
            '${minutes.toString().padLeft(2, '0')}:${seconds.toString().padLeft(2, '0')}';

        return IgnorePointer(
          child: RepaintBoundary(
            child: Container(
              padding: padding,
              decoration: BoxDecoration(
                color: const Color(0x66000000),
                borderRadius: BorderRadius.circular(10),
              ),
              child: Text(
                text,
                textAlign: TextAlign.center,
                style: const TextStyle(
                  fontSize: 18,
                  color: Color(0xFFFFFFFF),
                  fontFeatures: [FontFeature.tabularFigures()],
                ),
              ),
            ),
          ),
        );
      },
    );
  }
}


===== FILE: lib/ui/hud/game/top_center_hud_overlay.dart =====
import 'package:flutter/material.dart';

import '../../../game/game_controller.dart';
import 'survival_timer_overlay.dart';
import '../../runner_game_ui_state.dart';
import 'start_pause_button_overlay.dart';

class TopCenterHudOverlay extends StatelessWidget {
  const TopCenterHudOverlay({
    super.key,
    required this.controller,
    required this.uiState,
    required this.onStart,
    required this.onTogglePause,
  });

  final GameController controller;
  final RunnerGameUiState uiState;
  final VoidCallback onStart;
  final VoidCallback onTogglePause;

  @override
  Widget build(BuildContext context) {
    return Align(
      alignment: Alignment.topCenter,
      child: Padding(
        padding: const EdgeInsets.only(top: 8),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            SurvivalTimerOverlay(controller: controller),
            const SizedBox(width: 8),
            StartPauseButtonOverlay(
              uiState: uiState,
              onStart: onStart,
              onTogglePause: onTogglePause,
            ),
          ],
        ),
      ),
    );
  }
}


===== FILE: lib/ui/hud/game/top_left_hud_overlay.dart =====
import 'package:flutter/widgets.dart';

import '../../../game/game_controller.dart';

class TopLeftHudOverlay extends StatelessWidget {
  const TopLeftHudOverlay({required this.controller, super.key});

  final GameController controller;

  static const double _barWidth = 140;
  static const double _barHeight = 6;
  static const double _barGap = 4;

  @override
  Widget build(BuildContext context) {
    final totalHeight = _barHeight * 3 + _barGap * 2;

    return AnimatedBuilder(
      animation: controller,
      builder: (context, _) {
        final hud = controller.snapshot.hud;
        return IgnorePointer(
          child: RepaintBoundary(
            child: SizedBox(
              width: _barWidth,
              height: totalHeight,

              child: CustomPaint(
                painter: _HudBarsPainter(
                  hp: hud.hp,
                  hpMax: hud.hpMax,
                  mana: hud.mana,
                  manaMax: hud.manaMax,
                  stamina: hud.stamina,
                  staminaMax: hud.staminaMax,
                  barWidth: _barWidth,
                  barHeight: _barHeight,
                  barGap: _barGap,
                ),
              ),
            ),
          ),
        );
      },
    );
  }
}

class _HudBarsPainter extends CustomPainter {
  _HudBarsPainter({
    required this.hp,
    required this.hpMax,
    required this.mana,
    required this.manaMax,
    required this.stamina,
    required this.staminaMax,
    required this.barWidth,
    required this.barHeight,
    required this.barGap,
  });

  final double hp;
  final double hpMax;
  final double mana;
  final double manaMax;
  final double stamina;
  final double staminaMax;
  final double barWidth;
  final double barHeight;
  final double barGap;

  static final Paint _back = Paint()..color = const Color(0xAA000000);
  static final Paint _outline = Paint()
    ..color = const Color(0xFFFFFFFF)
    ..style = PaintingStyle.stroke
    ..strokeWidth = 1;
  static final Paint _hp = Paint()..color = const Color(0xFFDC4440);
  static final Paint _mana = Paint()..color = const Color(0xFF2D98DA);
  static final Paint _stamina = Paint()..color = const Color(0xFF4CD137);

  @override
  void paint(Canvas canvas, Size size) {
    _drawBar(
      canvas,
      y: 0,
      value: hp,
      max: hpMax,
      fill: _hp,
    );
    _drawBar(
      canvas,
      y: barHeight + barGap,
      value: mana,
      max: manaMax,
      fill: _mana,
    );
    _drawBar(
      canvas,
      y: (barHeight + barGap) * 2,
      value: stamina,
      max: staminaMax,
      fill: _stamina,
    );
  }

  void _drawBar(
    Canvas canvas, {
    required double y,
    required double value,
    required double max,
    required Paint fill,
  }) {
    final backRect = Rect.fromLTWH(0, y, barWidth, barHeight);
    canvas.drawRect(backRect, _back);
    canvas.drawRect(backRect, _outline);

    if (max <= 0) return;
    final t = (value / max).clamp(0.0, 1.0);
    if (t <= 0) return;
    canvas.drawRect(Rect.fromLTWH(0, y, barWidth * t, barHeight), fill);
  }

  @override
  bool shouldRepaint(covariant _HudBarsPainter oldDelegate) {
    return hp != oldDelegate.hp ||
        hpMax != oldDelegate.hpMax ||
        mana != oldDelegate.mana ||
        manaMax != oldDelegate.manaMax ||
        stamina != oldDelegate.stamina ||
        staminaMax != oldDelegate.staminaMax ||
        barWidth != oldDelegate.barWidth ||
        barHeight != oldDelegate.barHeight ||
        barGap != oldDelegate.barGap;
  }
}


===== FILE: lib/ui/hud/game/top_right_hud_overlay.dart =====
import 'package:flutter/material.dart';

import '../../../game/game_controller.dart';
import 'score_overlay.dart';

class TopRightHudOverlay extends StatelessWidget {
  const TopRightHudOverlay({
    super.key,
    required this.controller,
    required this.showExitButton,
    required this.onExit,
  });

  final GameController controller;
  final bool showExitButton;
  final VoidCallback? onExit;

  @override
  Widget build(BuildContext context) {
    return Align(
      alignment: Alignment.topRight,
      child: Padding(
        padding: const EdgeInsets.all(8),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            ScoreOverlay(controller: controller),
            if (showExitButton) ...[
              const SizedBox(width: 8),
              IconButton(
                onPressed: onExit,
                icon: const Icon(Icons.close),
                color: Colors.white,
                disabledColor: Colors.white,
              ),
            ],
          ],
        ),
      ),
    );
  }
}


===== FILE: lib/ui/hud/gameover/game_over_header.dart =====
import 'package:flutter/material.dart';

class GameOverHeader extends StatelessWidget {
  const GameOverHeader({
    super.key,
    required this.subtitleDeathReason,
    required this.displayScore,
  });

  final String? subtitleDeathReason;
  final int? displayScore;

  @override
  Widget build(BuildContext context) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        const Text(
          'Game Over',
          style: TextStyle(
            color: Color(0xFFFFFFFF),
            fontSize: 28,
            fontWeight: FontWeight.w600,
          ),
        ),
        if (subtitleDeathReason != null) ...[
          const SizedBox(height: 8),
          Text(
            subtitleDeathReason!,
            style: const TextStyle(
              color: Color(0xFFFFFFFF),
              fontSize: 14,
              fontWeight: FontWeight.w500,
            ),
            textAlign: TextAlign.center,
          ),
        ],
        if (displayScore != null) ...[
          const SizedBox(height: 14),
          Text(
            'Score: $displayScore',
            style: const TextStyle(
              color: Color(0xFFFFFFFF),
              fontSize: 16,
              fontWeight: FontWeight.w600,
            ),
            textAlign: TextAlign.center,
          ),
        ],
      ],
    );
  }
}


===== FILE: lib/ui/hud/gameover/game_over_overlay.dart =====
import 'package:flutter/material.dart';
import 'package:flutter/scheduler.dart';

import '../../../core/enemies/enemy_id.dart';
import '../../../core/events/game_event.dart';
import '../../../core/levels/level_id.dart';
import '../../../core/projectiles/projectile_id.dart';
import '../../../core/scoring/run_score_breakdown.dart';
import '../../../core/tuning/score_tuning.dart';
import '../../leaderboard/leaderboard_store.dart';
import 'game_over_header.dart';
import 'leaderboard_panel.dart';
import 'restart_exit_buttons.dart';
import 'score_breakdown_formatter.dart';
import 'score_distribution.dart';
import 'score_feed_controller.dart';
// import '../../../core/spells/spell_id.dart';

class GameOverOverlay extends StatefulWidget {
  const GameOverOverlay({
    super.key,
    required this.visible,
    required this.onRestart,
    required this.onExit,
    required this.showExitButton,
    required this.levelId,
    required this.runEndedEvent,
    required this.scoreTuning,
    required this.tickHz,
    this.leaderboardStore,
  });

  final bool visible;
  final VoidCallback onRestart;
  final VoidCallback? onExit;
  final bool showExitButton;
  final LevelId levelId;
  final RunEndedEvent? runEndedEvent;
  final ScoreTuning scoreTuning;
  final int tickHz;
  final LeaderboardStore? leaderboardStore;

  @override
  State<GameOverOverlay> createState() => _GameOverOverlayState();
}

class _GameOverOverlayState extends State<GameOverOverlay>
    with SingleTickerProviderStateMixin {
  late final RunScoreBreakdown _breakdown;
  late final ScoreFeedController _feedController;

  Ticker? _ticker;
  Duration _lastElapsed = Duration.zero;

  @override
  void initState() {
    super.initState();
    _breakdown = _buildBreakdown();
    _feedController = ScoreFeedController(
      rows: _breakdown.rows,
      totalPoints: _breakdown.totalPoints,
    );
  }

  RunScoreBreakdown _buildBreakdown() {
    final event = widget.runEndedEvent;
    if (event == null) {
      return const RunScoreBreakdown(rows: <RunScoreRow>[], totalPoints: 0);
    }

    return buildRunScoreBreakdown(
      tick: event.tick,
      distanceUnits: event.distance,
      collectibles: event.stats.collectibles,
      collectibleScore: event.stats.collectibleScore,
      enemyKillCounts: event.stats.enemyKillCounts,
      tuning: widget.scoreTuning,
      tickHz: widget.tickHz,
    );
  }

  void _startFeed() {
    if (_feedController.startFeed()) {
      _startTicker();
      setState(() {});
    }
  }

  void _startTicker() {
    _ticker?.dispose();
    _lastElapsed = Duration.zero;
    _ticker = createTicker(_onTick)..start();
  }

  void _stopTicker() {
    final ticker = _ticker;
    if (ticker == null) return;
    ticker.stop();
    ticker.dispose();
    _ticker = null;
  }

  void _onTick(Duration elapsed) {
    if (_feedController.feedState != ScoreFeedState.feeding) return;

    final dt =
        (elapsed - _lastElapsed).inMicroseconds.toDouble() / 1000000.0;
    _lastElapsed = elapsed;
    if (dt <= 0) return;

    final changed = _feedController.tick(dt);
    if (_feedController.feedState == ScoreFeedState.complete) {
      _stopTicker();
    }
    if (changed && mounted) setState(() {});
  }

  void _completeFeed() {
    _feedController.completeFeed();
    _stopTicker();
  }

  void _onCollectPressed() {
    if (_feedController.feedState == ScoreFeedState.idle) {
      _startFeed();
      return;
    }
    if (_feedController.feedState == ScoreFeedState.feeding) {
      _completeFeed();
      setState(() {});
    }
  }

  void _completeThen(VoidCallback? action) {
    if (_feedController.feedState != ScoreFeedState.complete) {
      _completeFeed();
      setState(() {});
    }
    if (action == null) return;
    WidgetsBinding.instance.addPostFrameCallback((_) => action());
  }

  @override
  void dispose() {
    _stopTicker();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    if (!widget.visible) return const SizedBox.shrink();

    final subtitleDeathReason = _buildSubtitleDeathReason(widget.runEndedEvent);
    final showCollectButton =
        _feedController.totalPoints > 0 &&
        _feedController.feedState != ScoreFeedState.complete;
    final showScoreInHeader =
        _feedController.feedState == ScoreFeedState.complete;
    final collectLabel =
        _feedController.feedState == ScoreFeedState.idle
            ? 'Collect score'
            : 'Skip';
    final rowLabels = [
      for (var i = 0; i < _feedController.rows.length; i += 1)
        formatScoreRow(
          _feedController.rows[i].row,
          _feedController.rows[i].remainingPoints,
          enemyName: _enemyName,
        ),
    ];

    return SizedBox.expand(
      child: ColoredBox(
        color: const Color(0x88000000),
        child: SafeArea(
          minimum: const EdgeInsets.all(18),
          child: Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Expanded(
                flex: 2,
                child: Align(
                  alignment: Alignment.topCenter,
                  child: Column(
                    mainAxisSize: MainAxisSize.max,
                    children: [
                      GameOverHeader(
                        subtitleDeathReason: subtitleDeathReason,
                        displayScore:
                            showScoreInHeader ? _feedController.displayScore : null,
                      ),
                      const SizedBox(height: 14),
                      if (showCollectButton)
                        _OverlayButton(
                          label: collectLabel,
                          onPressed: _onCollectPressed,
                        )
                      else
                        RestartExitButtons(
                          restartButton: _OverlayButton(
                            label: 'Restart',
                            onPressed: () => _completeThen(widget.onRestart),
                          ),
                          exitButton: widget.showExitButton
                              ? _OverlayButton(
                                  label: 'Exit',
                                  onPressed: () => _completeThen(widget.onExit),
                                )
                              : null,
                        ),
                      const SizedBox(height: 16),
                      Flexible(child: ScoreDistribution(rowLabels: rowLabels)),
                    ],
                  ),
                ),
              ),
              Expanded(
                flex: 1,
                child: Align(
                  alignment: Alignment.topCenter,
                  child: LeaderboardPanel(
                    levelId: widget.levelId,
                    runEndedEvent: widget.runEndedEvent,
                    scoreTuning: widget.scoreTuning,
                    tickHz: widget.tickHz,
                    revealCurrentRunScore:
                        _feedController.feedState == ScoreFeedState.complete,
                    leaderboardStore: widget.leaderboardStore,
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

String? _buildSubtitleDeathReason(RunEndedEvent? event) {
  if (event == null) return null;
  switch (event.reason) {
    case RunEndReason.gaveUp:
      return 'You gave up the run.';
    case RunEndReason.fellBehindCamera:
      return 'You fell behind.';
    case RunEndReason.fellIntoGap:
      return 'You fell into a gap.';
    case RunEndReason.playerDied:
      return _buildDeathSubtitle(event.deathInfo);
  }
}

String _buildDeathSubtitle(DeathInfo? info) {
  if (info == null) return 'You died.';
  switch (info.kind) {
    case DeathSourceKind.projectile:
      return _buildProjectileDeath(info);
    case DeathSourceKind.meleeHitbox:
      return _buildMeleeDeath(info);
    case DeathSourceKind.statusEffect:
      return 'You succumbed to a status effect.';
    case DeathSourceKind.unknown:
      return 'You died.';
  }
}

String _buildProjectileDeath(DeathInfo info) {
  final projectileId = info.projectileId;
  if (projectileId == null) return 'You died.';
  final projectileName = _projectileName(projectileId);
  /* final spellName =
      info.spellId == null ? null : _spellName(info.spellId!); */
  final enemyName = info.enemyId == null ? null : _enemyName(info.enemyId!);

  final buffer = StringBuffer('Killed by $projectileName');
  /*   if (spellName != null) {
    buffer.write(' ($spellName)');
  } */
  if (enemyName != null) {
    buffer.write(' from $enemyName.');
  } else {
    buffer.write('.');
  }
  return buffer.toString();
}

String _buildMeleeDeath(DeathInfo info) {
  if (info.enemyId == null) return 'You died.';
  return 'Killed by a melee strike from a ${_enemyName(info.enemyId!)}.';
}

String _enemyName(EnemyId id) {
  switch (id) {
    case EnemyId.unocoDemon:
      return 'Unoco Demon';
    case EnemyId.groundEnemy:
      return 'Ground enemy';
  }
}

String _projectileName(ProjectileId id) {
  switch (id) {
    case ProjectileId.iceBolt:
      return 'Ice Bolt';
    case ProjectileId.lightningBolt:
      return 'Lightning Bolt';
    case ProjectileId.arrow:
      return 'Arrow';
    case ProjectileId.throwingAxe:
      return 'Throwing Axe';
  }
}

/* String _spellName(SpellId id) {
  switch (id) {
    case SpellId.iceBolt:
      return 'Ice Bolt';
    case SpellId.lightning:
      return 'Lightning';
  }
} */

class _OverlayButton extends StatelessWidget {
  const _OverlayButton({required this.label, required this.onPressed});

  final String label;
  final VoidCallback? onPressed;

  @override
  Widget build(BuildContext context) {
    return TextButton(
      onPressed: onPressed,
      style: TextButton.styleFrom(
        foregroundColor: const Color(0xFFFFFFFF),
        backgroundColor: const Color(0xAA000000),
        padding: const EdgeInsets.symmetric(horizontal: 18, vertical: 10),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(10),
          side: const BorderSide(color: Color(0xFFFFFFFF)),
        ),
      ),
      child: Text(
        label,
        style: const TextStyle(fontSize: 14, fontWeight: FontWeight.w600),
      ),
    );
  }
}


===== FILE: lib/ui/hud/gameover/leaderboard_panel.dart =====
import 'package:flutter/material.dart';

import '../../../core/events/game_event.dart';
import '../../../core/levels/level_id.dart';
import '../../../core/tuning/score_tuning.dart';
import '../../leaderboard/leaderboard_store.dart';
import '../../leaderboard/run_result.dart';
import '../../leaderboard/shared_prefs_leaderboard_store.dart';
import '../../levels/level_id_ui.dart';

class LeaderboardPanel extends StatefulWidget {
  const LeaderboardPanel({
    super.key,
    required this.levelId,
    required this.runEndedEvent,
    required this.scoreTuning,
    required this.tickHz,
    this.revealCurrentRunScore = true,
    this.leaderboardStore,
  });

  final LevelId levelId;
  final RunEndedEvent? runEndedEvent;
  final ScoreTuning scoreTuning;
  final int tickHz;
  final bool revealCurrentRunScore;
  final LeaderboardStore? leaderboardStore;

  @override
  State<LeaderboardPanel> createState() => _LeaderboardPanelState();
}

class _LeaderboardPanelState extends State<LeaderboardPanel> {
  late final LeaderboardStore _store;
  List<RunResult> _entries = const <RunResult>[];
  int? _currentRunId;
  bool _loaded = false;

  static const double _rankColWidth = 28;
  static const double _scoreColWidth = 64;
  static const double _distanceColWidth = 56;
  static const double _timeColWidth = 54;

  @override
  void initState() {
    super.initState();
    _store = widget.leaderboardStore ?? SharedPrefsLeaderboardStore();
    _loadLeaderboard();
  }

  Future<void> _loadLeaderboard() async {
    final event = widget.runEndedEvent;
    if (event == null) {
      final entries = await _store.loadTop10(levelId: widget.levelId);
      if (!mounted) return;
      setState(() {
        _entries = entries;
        _loaded = true;
      });
      return;
    }

    final draft = buildRunResult(
      event: event,
      scoreTuning: widget.scoreTuning,
      tickHz: widget.tickHz,
      endedAtMs: DateTime.now().millisecondsSinceEpoch,
    );
    final snapshot = await _store.addResult(
      levelId: widget.levelId,
      result: draft,
    );
    if (!mounted) return;
    setState(() {
      _entries = snapshot.entries;
      _currentRunId = snapshot.current.runId;
      _loaded = true;
    });
  }

  Widget _buildRow(int rank, RunResult entry) {
    final isCurrent = _currentRunId != null && entry.runId == _currentRunId;
    final color = isCurrent ? const Color(0xFFFFF59D) : const Color(0xFFFFFFFF);
    final scoreText =
        isCurrent && !widget.revealCurrentRunScore ? '—' : entry.score.toString();

    return DecoratedBox(
      decoration: isCurrent
          ? BoxDecoration(
              color: const Color(0x33FFFFFF),
              borderRadius: BorderRadius.circular(6),
            )
          : const BoxDecoration(),
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 3),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            SizedBox(
              width: _rankColWidth,
              child: Text(
                '#$rank',
                style: TextStyle(color: color),
              ),
            ),
            SizedBox(
              width: _scoreColWidth,
              child: Text(
                scoreText,
                textAlign: TextAlign.right,
                style: TextStyle(color: color),
              ),
            ),
            SizedBox(
              width: _distanceColWidth,
              child: Text(
                '${entry.distanceMeters}m',
                textAlign: TextAlign.right,
                style: TextStyle(color: color),
              ),
            ),
            SizedBox(
              width: _timeColWidth,
              child: Text(
                _formatTime(entry.durationSeconds),
                textAlign: TextAlign.right,
                style: TextStyle(color: color),
              ),
            ),
          ],
        ),
      ),
    );
  }

  String _formatTime(int totalSeconds) {
    final minutes = totalSeconds ~/ 60;
    final seconds = totalSeconds % 60;
    return '${minutes.toString().padLeft(2, '0')}:${seconds.toString().padLeft(2, '0')}';
  }

  @override
  Widget build(BuildContext context) {
    final titleStyle = const TextStyle(
      color: Color(0xFFFFFFFF),
      fontSize: 14,
      fontWeight: FontWeight.w600,
    );
    final textStyle = const TextStyle(
      color: Color(0xFFFFFFFF),
      fontSize: 12,
      fontWeight: FontWeight.w500,
    );

    Widget content;
    if (!_loaded) {
      content = Text('Loading leaderboard...', style: textStyle);
    } else if (_entries.isEmpty) {
      content = Text('No runs yet.', style: textStyle);
    } else {
      content = Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          for (var i = 0; i < _entries.length; i += 1) ...[
            _buildRow(i + 1, _entries[i]),
            if (i < _entries.length - 1) const SizedBox(height: 4),
          ],
        ],
      );
    }

    return ConstrainedBox(
      constraints: const BoxConstraints(maxWidth: 240),
      child: DecoratedBox(
        decoration: BoxDecoration(
          color: const Color(0x66000000),
          borderRadius: BorderRadius.circular(10),
        ),
        child: Padding(
          padding: const EdgeInsets.all(12),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text('${widget.levelId.displayName} Scoreboard', style: titleStyle),
              const SizedBox(height: 8),
              DefaultTextStyle(style: textStyle, child: content),
            ],
          ),
        ),
      ),
    );
  }
}


===== FILE: lib/ui/hud/gameover/restart_exit_buttons.dart =====
import 'package:flutter/material.dart';

class RestartExitButtons extends StatelessWidget {
  const RestartExitButtons({
    super.key,
    required this.restartButton,
    this.exitButton,
    this.trailingButton,
  });

  final Widget restartButton;
  final Widget? exitButton;
  final Widget? trailingButton;

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      width: double.infinity,
      child: Stack(
        alignment: Alignment.center,
        children: [
          Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              restartButton,
              if (exitButton != null) ...[
                const SizedBox(width: 12),
                exitButton!,
              ],
            ],
          ),
          if (trailingButton != null)
            Align(alignment: Alignment.centerRight, child: trailingButton),
        ],
      ),
    );
  }
}


===== FILE: lib/ui/hud/gameover/score_breakdown_formatter.dart =====
import '../../../core/enemies/enemy_id.dart';
import '../../../core/scoring/run_score_breakdown.dart';

String formatScoreRow(
  RunScoreRow row,
  int remainingPoints, {
  required String Function(EnemyId id) enemyName,
}) {
  switch (row.kind) {
    case RunScoreRowKind.distance:
      return 'Distance: ${row.count}m -> $remainingPoints';
    case RunScoreRowKind.time:
      return 'Time: ${_formatTime(row.count)} -> $remainingPoints';
    case RunScoreRowKind.collectibles:
      return 'Collectibles: ${row.count} -> $remainingPoints';
    case RunScoreRowKind.enemyKill:
      final name = row.enemyId == null ? 'Enemy' : enemyName(row.enemyId!);
      return '$name x${row.count} -> $remainingPoints';
  }
}

String _formatTime(int totalSeconds) {
  final minutes = totalSeconds ~/ 60;
  final seconds = totalSeconds % 60;
  return '${minutes.toString().padLeft(2, '0')}:${seconds.toString().padLeft(2, '0')}';
}


===== FILE: lib/ui/hud/gameover/score_distribution.dart =====
import 'package:flutter/material.dart';

class ScoreDistribution extends StatelessWidget {
  const ScoreDistribution({
    super.key,
    required this.rowLabels,
  });

  final List<String> rowLabels;

  @override
  Widget build(BuildContext context) {
    return Scrollbar(
      child: SingleChildScrollView(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            for (var i = 0; i < rowLabels.length; i += 1) ...[
              Text(
                rowLabels[i],
                style: const TextStyle(
                  color: Color(0xFFFFFFFF),
                  fontSize: 14,
                  fontWeight: FontWeight.w500,
                ),
                textAlign: TextAlign.center,
              ),
              if (i < rowLabels.length - 1) const SizedBox(height: 4),
            ],
          ],
        ),
      ),
    );
  }
}


===== FILE: lib/ui/hud/gameover/score_feed_controller.dart =====
import '../../../core/scoring/run_score_breakdown.dart';

enum ScoreFeedState { idle, feeding, complete }

class ScoreFeedRowState {
  ScoreFeedRowState({
    required this.row,
    required this.pointsPerSecond,
  }) : remainingPoints = row.points;

  final RunScoreRow row;
  final double pointsPerSecond;
  int remainingPoints;
  double carry = 0.0;
}

class ScoreFeedController {
  ScoreFeedController({
    required List<RunScoreRow> rows,
    required this.totalPoints,
    double feedDurationSeconds = 0.8,
  }) : _rows = [
          for (final row in rows)
            ScoreFeedRowState(
              row: row,
              pointsPerSecond:
                  row.points <= 0 ? 0.0 : row.points / feedDurationSeconds,
            ),
        ],
        displayScore = 0,
        feedState =
            totalPoints > 0 ? ScoreFeedState.idle : ScoreFeedState.complete;

  final int totalPoints;
  final List<ScoreFeedRowState> _rows;

  int displayScore;
  ScoreFeedState feedState;

  List<ScoreFeedRowState> get rows => _rows;

  bool startFeed() {
    if (feedState != ScoreFeedState.idle || totalPoints <= 0) return false;
    feedState = ScoreFeedState.feeding;
    return true;
  }

  bool tick(double dtSeconds) {
    if (feedState != ScoreFeedState.feeding || dtSeconds <= 0) {
      return false;
    }

    var gained = 0;
    var anyRemaining = false;

    for (final row in _rows) {
      if (row.remainingPoints <= 0 || row.pointsPerSecond <= 0) continue;
      row.carry += dtSeconds * row.pointsPerSecond;
      final raw = row.carry.floor();
      if (raw <= 0) {
        anyRemaining = true;
        continue;
      }
      row.carry -= raw;
      final consume =
          raw > row.remainingPoints ? row.remainingPoints : raw;
      row.remainingPoints -= consume;
      gained += consume;
      if (row.remainingPoints > 0) anyRemaining = true;
    }

    if (gained > 0) {
      displayScore += gained;
      if (displayScore > totalPoints) displayScore = totalPoints;
    }

    if (!anyRemaining) {
      completeFeed();
      return true;
    }

    return gained > 0;
  }

  void completeFeed() {
    displayScore = totalPoints;
    for (final row in _rows) {
      row.remainingPoints = 0;
      row.carry = 0.0;
    }
    feedState = ScoreFeedState.complete;
  }
}


===== FILE: lib/ui/leaderboard/leaderboard_store.dart =====
import '../../core/levels/level_id.dart';

import 'run_result.dart';

class LeaderboardSnapshot {
  const LeaderboardSnapshot({
    required this.entries,
    required this.current,
  });

  final List<RunResult> entries;
  final RunResult current;
}

abstract class LeaderboardStore {
  Future<LeaderboardSnapshot> addResult({
    required LevelId levelId,
    required RunResult result,
  });

  Future<List<RunResult>> loadTop10({required LevelId levelId});
}


===== FILE: lib/ui/leaderboard/run_result.dart =====
import '../../core/events/game_event.dart';
import '../../core/scoring/run_score_breakdown.dart';
import '../../core/tuning/score_tuning.dart';

class RunResult {
  const RunResult({
    required this.runId,
    required this.endedAtMs,
    required this.endedReason,
    required this.score,
    required this.distanceMeters,
    required this.durationSeconds,
    required this.tick,
  });

  final int runId;
  final int endedAtMs;
  final RunEndReason endedReason;
  final int score;
  final int distanceMeters;
  final int durationSeconds;
  final int tick;

  RunResult copyWith({
    int? runId,
    int? endedAtMs,
  }) {
    return RunResult(
      runId: runId ?? this.runId,
      endedAtMs: endedAtMs ?? this.endedAtMs,
      endedReason: endedReason,
      score: score,
      distanceMeters: distanceMeters,
      durationSeconds: durationSeconds,
      tick: tick,
    );
  }

  Map<String, dynamic> toJson() => <String, dynamic>{
        'runId': runId,
        'endedAtMs': endedAtMs,
        'endedReason': endedReason.name,
        'score': score,
        'distanceMeters': distanceMeters,
        'durationSeconds': durationSeconds,
        'tick': tick,
      };

  static RunResult fromJson(Map<String, dynamic> json) {
    final reasonName = json['endedReason'] as String?;
    final reason = _reasonFromName(reasonName);
    return RunResult(
      runId: json['runId'] as int? ?? 0,
      endedAtMs: json['endedAtMs'] as int? ?? 0,
      endedReason: reason,
      score: json['score'] as int? ?? 0,
      distanceMeters: json['distanceMeters'] as int? ?? 0,
      durationSeconds: json['durationSeconds'] as int? ?? 0,
      tick: json['tick'] as int? ?? 0,
    );
  }

  static RunEndReason _reasonFromName(String? name) {
    if (name == null) return RunEndReason.playerDied;
    for (final value in RunEndReason.values) {
      if (value.name == name) return value;
    }
    return RunEndReason.playerDied;
  }
}

RunResult buildRunResult({
  required RunEndedEvent event,
  required ScoreTuning scoreTuning,
  required int tickHz,
  required int endedAtMs,
}) {
  final breakdown = buildRunScoreBreakdown(
    tick: event.tick,
    distanceUnits: event.distance,
    collectibles: event.stats.collectibles,
    collectibleScore: event.stats.collectibleScore,
    enemyKillCounts: event.stats.enemyKillCounts,
    tuning: scoreTuning,
    tickHz: tickHz,
  );

  final distanceMeters = (event.distance / kWorldUnitsPerMeter).floor();
  final durationSeconds = tickHz <= 0 ? 0 : event.tick ~/ tickHz;

  return RunResult(
    runId: 0,
    endedAtMs: endedAtMs,
    endedReason: event.reason,
    score: breakdown.totalPoints,
    distanceMeters: distanceMeters,
    durationSeconds: durationSeconds,
    tick: event.tick,
  );
}


===== FILE: lib/ui/leaderboard/shared_prefs_leaderboard_store.dart =====
import 'dart:convert';

import 'package:shared_preferences/shared_preferences.dart';

import '../../core/levels/level_id.dart';
import 'leaderboard_store.dart';
import 'run_result.dart';

class SharedPrefsLeaderboardStore implements LeaderboardStore {
  static const String _entriesKeyPrefix = 'leaderboard_v2_entries_';
  static const String _nextIdKeyPrefix = 'leaderboard_v2_next_id_';

  String _entriesKey(LevelId levelId) => '$_entriesKeyPrefix${levelId.name}';
  String _nextIdKey(LevelId levelId) => '$_nextIdKeyPrefix${levelId.name}';

  @override
  Future<LeaderboardSnapshot> addResult({
    required LevelId levelId,
    required RunResult result,
  }) async {
    final prefs = await SharedPreferences.getInstance();

    final nextId = (prefs.getInt(_nextIdKey(levelId)) ?? 1);
    final stored = result.copyWith(runId: nextId);
    final entries = _loadEntries(prefs, levelId);
    entries.add(stored);
    entries.sort(_compare);

    final top = entries.length > 10 ? entries.sublist(0, 10) : entries;
    await prefs.setString(_entriesKey(levelId), _encode(top));
    await prefs.setInt(_nextIdKey(levelId), nextId + 1);

    return LeaderboardSnapshot(
      entries: List<RunResult>.unmodifiable(top),
      current: stored,
    );
  }

  @override
  Future<List<RunResult>> loadTop10({required LevelId levelId}) async {
    final prefs = await SharedPreferences.getInstance();
    final entries = _loadEntries(prefs, levelId);
    entries.sort(_compare);
    if (entries.length > 10) return entries.sublist(0, 10);
    return List<RunResult>.unmodifiable(entries);
  }

  List<RunResult> _loadEntries(SharedPreferences prefs, LevelId levelId) {
    final raw = prefs.getString(_entriesKey(levelId));
    if (raw == null || raw.isEmpty) return <RunResult>[];

    final decoded = jsonDecode(raw);
    if (decoded is! List) return <RunResult>[];

    final entries = <RunResult>[];
    for (final entry in decoded) {
      if (entry is Map<String, dynamic>) {
        entries.add(RunResult.fromJson(entry));
      } else if (entry is Map) {
        entries.add(RunResult.fromJson(Map<String, dynamic>.from(entry)));
      }
    }
    return entries;
  }

  String _encode(List<RunResult> entries) {
    return jsonEncode(entries.map((entry) => entry.toJson()).toList());
  }

  int _compare(RunResult a, RunResult b) {
    if (a.score != b.score) return b.score.compareTo(a.score);
    if (a.endedAtMs != b.endedAtMs) {
      return b.endedAtMs.compareTo(a.endedAtMs);
    }
    return b.runId.compareTo(a.runId);
  }
}


===== FILE: lib/ui/levels/level_id_ui.dart =====
import '../../core/levels/level_id.dart';

extension LevelIdUi on LevelId {
  String get displayName {
    switch (this) {
      case LevelId.defaultLevel:
        return 'Default';
      case LevelId.forest:
        return 'Forest';
      case LevelId.field:
        return 'Field';
    }
  }
}



===== FILE: lib/ui/menus/level_select_section.dart =====
import 'package:flutter/material.dart';

import '../../core/levels/level_id.dart';
import '../levels/level_id_ui.dart';

class LevelSelectSection extends StatelessWidget {
  const LevelSelectSection({super.key, required this.onStartLevel});

  final void Function(LevelId levelId) onStartLevel;

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        Text(
          'Level Selection',
          style: Theme.of(context).textTheme.titleLarge,
        ),
        const SizedBox(height: 12),
        FilledButton(
          onPressed: () => onStartLevel(LevelId.defaultLevel),
          child: Text(LevelId.defaultLevel.displayName),
        ),
        const SizedBox(height: 8),
        FilledButton(
          onPressed: () => onStartLevel(LevelId.forest),
          child: Text(LevelId.forest.displayName),
        ),
        const SizedBox(height: 8),
        FilledButton(
          onPressed: () => onStartLevel(LevelId.field),
          child: Text(LevelId.field.displayName),
        ),
      ],
    );
  }
}


===== FILE: lib/ui/menus/runner_menu_page.dart =====
import 'dart:math';

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import '../../core/levels/level_id.dart';
import '../runner_game_route.dart';
import 'level_select_section.dart';

/// Development-only menu that will expand over time.
///
/// For now it only supports level selection and starting a run.
class RunnerMenuPage extends StatelessWidget {
  const RunnerMenuPage({super.key});

  void _startLevel(BuildContext context, LevelId levelId) {
    final seed = Random().nextInt(1 << 31);
    Navigator.of(context).push(
      createRunnerGameRoute(
        seed: seed,
        levelId: levelId,
        restoreOrientations: const [DeviceOrientation.portraitUp],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Runner Menu', style: TextStyle(color: Colors.white)),
        backgroundColor: const Color.fromARGB(255, 6, 21, 48),
      ),
      body: Padding(
        padding: const EdgeInsets.all(16),
        child: LevelSelectSection(
          onStartLevel: (levelId) => _startLevel(context, levelId),
        ),
      ),
    );
  }
}



===== FILE: lib/ui/runner_game_route.dart =====
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import '../core/levels/level_id.dart';
import 'runner_game_widget.dart';
import 'scoped/scoped_preferred_orientations.dart';
import 'scoped/scoped_system_ui_mode.dart';

/// Embed-friendly route factory for hosting the mini-game in any Flutter app.
///
/// Host apps can `Navigator.push(createRunnerGameRoute(...))` without depending
/// on this package's development host app (`lib/main.dart`).
///
Route<void> createRunnerGameRoute({
  int seed = 1,
  LevelId levelId = LevelId.defaultLevel,
  bool lockLandscape = true,
  List<DeviceOrientation>? restoreOrientations,
}) {
  return MaterialPageRoute<void>(
    builder: (context) {
      Widget child = RunnerGameWidget(
        seed: seed,
        levelId: levelId,
        onExit: () => Navigator.of(context).maybePop(),
      );

      if (lockLandscape) {
        child = ScopedPreferredOrientations(
          preferredOrientations: const [
            DeviceOrientation.landscapeLeft,
            DeviceOrientation.landscapeRight,
          ],
          restoreOrientations: restoreOrientations,
          child: child,
        );
      }

      // Hide status + nav bars only for this route.
      child = ScopedSystemUiMode(
        mode: SystemUiMode.immersiveSticky,
        restoreMode: SystemUiMode.edgeToEdge,
        child: child,
      );

      return Scaffold(body: child);
    },
  );
}


===== FILE: lib/ui/runner_game_ui_state.dart =====
class RunnerGameUiState {
  const RunnerGameUiState({
    required this.started,
    required this.paused,
    required this.gameOver,
  });

  final bool started;
  final bool paused;
  final bool gameOver;

  bool get canRun => started && !gameOver;

  bool get isRunning => canRun && !paused;

  bool get showReadyOverlay => !started;

  bool get showPauseOverlay => started && paused && !gameOver;
}


===== FILE: lib/ui/runner_game_widget.dart =====
import 'package:flame/game.dart';
import 'package:flutter/material.dart';

import '../core/contracts/render_contract.dart';
import '../core/game_core.dart';
import '../core/levels/level_id.dart';
import '../core/levels/level_registry.dart';
import '../game/game_controller.dart';
import '../game/input/aim_preview.dart';
import '../game/input/runner_input_router.dart';
import '../game/runner_flame_game.dart';
import 'hud/game/game_overlay.dart';
import 'hud/gameover/game_over_overlay.dart';
import 'runner_game_ui_state.dart';
import 'viewport/game_viewport.dart';
import 'viewport/viewport_metrics.dart';

/// Embed-friendly widget that hosts the mini-game.
///
/// Intended to be mounted by a host app. It owns its [GameController] and
/// cleans it up on dispose.
///
/// Viewport scaling is applied by [GameViewport] to keep the fixed virtual
/// resolution fitted to the available screen.
class RunnerGameWidget extends StatefulWidget {
  const RunnerGameWidget({
    super.key,
    this.seed = 1,
    this.levelId = LevelId.defaultLevel,
    this.onExit,
    this.showExitButton = true,
    this.viewportMode = ViewportScaleMode.pixelPerfectContain,
    this.viewportAlignment = Alignment.center,
  });

  /// Master RNG seed for deterministic generation.
  final int seed;

  /// Which core level definition to run.
  final LevelId levelId;

  final VoidCallback? onExit;
  final bool showExitButton;

  /// How the game view is scaled to the available screen.
  final ViewportScaleMode viewportMode;

  /// Where the scaled view is placed within the available screen.
  final Alignment viewportAlignment;

  @override
  State<RunnerGameWidget> createState() => _RunnerGameWidgetState();
}

class _RunnerGameWidgetState extends State<RunnerGameWidget>
    with WidgetsBindingObserver {
  bool _pausedByLifecycle = false;
  bool _started = false;

  late GameController _controller;
  late RunnerInputRouter _input;
  late AimPreviewModel _projectileAimPreview;
  late AimPreviewModel _meleeAimPreview;
  late AimPreviewModel _rangedAimPreview;
  late RunnerFlameGame _game;

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);

    _initGame();

    // Start in "ready" (paused) until the user taps to begin.
    _controller.setPaused(true);
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) =>
      _onLifecycle(state);

  void _onLifecycle(AppLifecycleState state) {
    final uiState = _buildUiState();
    if (state == AppLifecycleState.resumed) {
      if (_pausedByLifecycle && uiState.started && !uiState.gameOver) {
        _pausedByLifecycle = false;
        _controller.setPaused(false);
      }
      return;
    }

    // Only mark lifecycle-paused if we were actually running.
    _pausedByLifecycle = uiState.isRunning;
    _controller.setPaused(true);
    _clearInputs();
  }

  void _clearInputs() {
    _input.setMoveAxis(0);
    _input.clearProjectileAimDir();
    _input.clearMeleeAimDir();
    _input.clearRangedAimDir();
    _projectileAimPreview.end();
    _meleeAimPreview.end();
    _rangedAimPreview.end();
    _input.pumpHeldInputs();
  }

  RunnerGameUiState _buildUiState() {
    final snapshot = _controller.snapshot;
    return RunnerGameUiState(
      started: _started,
      paused: snapshot.paused,
      gameOver: snapshot.gameOver,
    );
  }

  void _startGame() {
    setState(() => _started = true);
    _clearInputs();
    _controller.setPaused(false);
  }

  void _restartGame() {
    final oldController = _controller;
    final oldProjectilePreview = _projectileAimPreview;
    final oldMeleePreview = _meleeAimPreview;
    final oldRangedPreview = _rangedAimPreview;

    setState(() {
      _pausedByLifecycle = false;
      _started = false;
      _initGame();
    });
    _controller.setPaused(true);
    _clearInputs();

    WidgetsBinding.instance.addPostFrameCallback((_) {
      oldController.shutdown();
      oldController.dispose();
      oldProjectilePreview.dispose();
      oldMeleePreview.dispose();
      oldRangedPreview.dispose();
    });
  }

  void _togglePause() {
    final paused = _controller.snapshot.paused;
    if (!paused) _clearInputs();
    _controller.setPaused(!paused);
  }

  void _initGame() {
    _controller = GameController(
      core: GameCore(
        seed: widget.seed,
        levelDefinition: LevelRegistry.byId(widget.levelId),
      ),
    );
    _input = RunnerInputRouter(controller: _controller);
    _projectileAimPreview = AimPreviewModel();
    _meleeAimPreview = AimPreviewModel();
    _rangedAimPreview = AimPreviewModel();
    _game = RunnerFlameGame(
      controller: _controller,
      input: _input,
      projectileAimPreview: _projectileAimPreview,
      meleeAimPreview: _meleeAimPreview,
      rangedAimPreview: _rangedAimPreview,
    );
  }

  void _disposeGame() {
    _controller.shutdown();
    _controller.dispose();
    _projectileAimPreview.dispose();
    _meleeAimPreview.dispose();
    _rangedAimPreview.dispose();
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    _disposeGame();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Stack(
      fit: StackFit.expand,
      children: [
        LayoutBuilder(
          builder: (context, constraints) {
            final devicePixelRatio = MediaQuery.devicePixelRatioOf(context);
            final metrics = computeViewportMetrics(
              constraints,
              devicePixelRatio,
              virtualWidth,
              virtualHeight,
              widget.viewportMode,
              alignment: widget.viewportAlignment,
            );
            Widget gameView = GameViewport(
              metrics: metrics,
              child: GameWidget(
                key: ValueKey(_game),
                game: _game,
                autofocus: false,
              ),
            );

            return gameView;
          },
        ),
        AnimatedBuilder(
          animation: _controller,
          builder: (context, _) {
            final uiState = _buildUiState();
            if (uiState.gameOver) {
              final runEndedEvent = _controller.lastRunEndedEvent;
              final runEndKey = runEndedEvent?.tick ?? _controller.snapshot.tick;
              return GameOverOverlay(
                key: ValueKey('gameOver-$runEndKey-${runEndedEvent?.reason}'),
                visible: true,
                onRestart: _restartGame,
                onExit: widget.onExit,
                showExitButton: widget.showExitButton,
                levelId: _controller.snapshot.levelId,
                runEndedEvent: runEndedEvent,
                scoreTuning: _controller.scoreTuning,
                tickHz: _controller.tickHz,
              );
            }
            return GameOverlay(
              controller: _controller,
              input: _input,
              projectileAimPreview: _projectileAimPreview,
              meleeAimPreview: _meleeAimPreview,
              rangedAimPreview: _rangedAimPreview,
              uiState: uiState,
              onStart: _startGame,
              onTogglePause: _togglePause,
              showExitButton: widget.showExitButton,
              onExit: uiState.started && !uiState.gameOver
                  ? _controller.giveUp
                  : widget.onExit,
            );
          },
        ),
      ],
    );
  }
}


===== FILE: lib/ui/scoped/scoped_preferred_orientations.dart =====
import 'package:flutter/foundation.dart';
import 'package:flutter/services.dart';
import 'package:flutter/widgets.dart';

/// Applies `SystemChrome.setPreferredOrientations` while this widget is mounted.
///
/// This is intentionally scoped to a subtree (typically a route) so the runner
/// can be embedded in a host app without enforcing a global orientation policy.
///
/// Notes:
/// - Flutter does not expose the *previous* preferred orientations, so the
///   caller must decide what to restore on dispose.
/// - Platform-level orientation support (Android manifest / iOS Info.plist)
///   still needs to include the requested orientations.
class ScopedPreferredOrientations extends StatefulWidget {
  const ScopedPreferredOrientations({
    super.key,
    required this.preferredOrientations,
    required this.child,
    this.restoreOrientations,
  });

  final List<DeviceOrientation> preferredOrientations;
  final List<DeviceOrientation>? restoreOrientations;
  final Widget child;

  @override
  State<ScopedPreferredOrientations> createState() =>
      _ScopedPreferredOrientationsState();
}

class _ScopedPreferredOrientationsState
    extends State<ScopedPreferredOrientations> {
  @override
  void initState() {
    super.initState();
    SystemChrome.setPreferredOrientations(widget.preferredOrientations);
  }

  @override
  void didUpdateWidget(covariant ScopedPreferredOrientations oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (!listEquals(
      oldWidget.preferredOrientations,
      widget.preferredOrientations,
    )) {
      SystemChrome.setPreferredOrientations(widget.preferredOrientations);
    }
  }

  @override
  void dispose() {
    final restore = widget.restoreOrientations;
    if (restore != null) {
      SystemChrome.setPreferredOrientations(restore);
    }
    super.dispose();
  }

  @override
  Widget build(BuildContext context) => widget.child;
}


===== FILE: lib/ui/scoped/scoped_system_ui_mode.dart =====
import 'package:flutter/services.dart';
import 'package:flutter/widgets.dart';

/// Applies `SystemChrome.setEnabledSystemUIMode` while this widget is mounted.
///
/// Scoped to a subtree (typically a route) so embedding stays clean.
class ScopedSystemUiMode extends StatefulWidget {
  const ScopedSystemUiMode({
    super.key,
    required this.mode,
    required this.child,
    this.overlays,
    this.restoreMode = SystemUiMode.edgeToEdge,
    this.restoreOverlays,
  });

  final SystemUiMode mode;
  final List<SystemUiOverlay>? overlays;

  final SystemUiMode restoreMode;
  final List<SystemUiOverlay>? restoreOverlays;

  final Widget child;

  @override
  State<ScopedSystemUiMode> createState() => _ScopedSystemUiModeState();
}

class _ScopedSystemUiModeState extends State<ScopedSystemUiMode> {
  @override
  void initState() {
    super.initState();
    _apply();
  }

  @override
  void didUpdateWidget(covariant ScopedSystemUiMode oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.mode != widget.mode ||
        oldWidget.overlays != widget.overlays) {
      _apply();
    }
  }

  void _apply() {
    SystemChrome.setEnabledSystemUIMode(widget.mode, overlays: widget.overlays);
  }

  @override
  void dispose() {
    SystemChrome.setEnabledSystemUIMode(
      widget.restoreMode,
      overlays: widget.restoreOverlays,
    );
    super.dispose();
  }

  @override
  Widget build(BuildContext context) => widget.child;
}


===== FILE: lib/ui/viewport/game_viewport.dart =====
import 'package:flutter/widgets.dart';

import 'viewport_metrics.dart';

/// Scales a fixed virtual canvas into the available space.
///
/// Use [computeViewportMetrics] so rendering and input mapping share the same
/// view size + offset.
class GameViewport extends StatelessWidget {
  const GameViewport({
    super.key,
    required this.metrics,
    required this.child,
    this.letterboxColor = const Color(0xFF000000),
  });

  final ViewportMetrics metrics;
  final Widget child;
  final Color letterboxColor;

  @override
  Widget build(BuildContext context) {
    return ColoredBox(
      color: letterboxColor,
      child: ClipRect(
        child: SizedBox.expand(
          child: Stack(
            fit: StackFit.expand,
            children: [
              Positioned(
                left: metrics.offsetX,
                top: metrics.offsetY,
                width: metrics.viewW,
                height: metrics.viewH,
                child: child,
              ),
            ],
          ),
        ),
      ),
    );
  }
}


===== FILE: lib/ui/viewport/viewport_metrics.dart =====
import 'dart:math' as math;

import 'package:flutter/widgets.dart';
/// Viewport scaling modes for fitting a fixed virtual canvas to the screen.
enum ViewportScaleMode {
  /// Integer physical-pixel scale (pixel-perfect, no cropping).
  ///
  /// Fits the entire virtual canvas on-screen, letterboxing the remaining area.
  pixelPerfectContain,

  /// Integer physical-pixel scale (pixel-perfect, with cropping).
  ///
  /// Fully covers the screen by scaling up until both dimensions fit. Any
  /// overflow is cropped by the outer [ClipRect].
  pixelPerfectCover,
}

/// Shared viewport sizing results for rendering and input mapping.
@immutable
class ViewportMetrics {
  const ViewportMetrics({
    required this.viewW,
    required this.viewH,
    required this.offsetX,
    required this.offsetY,
  });

  /// Scaled viewport width in logical pixels.
  final double viewW;

  /// Scaled viewport height in logical pixels.
  final double viewH;

  /// Viewport top-left offset in logical pixels.
  final double offsetX;

  /// Viewport top-left offset in logical pixels.
  final double offsetY;
}

/// Computes shared viewport metrics from the current layout constraints.
ViewportMetrics computeViewportMetrics(
  BoxConstraints constraints,
  double devicePixelRatio,
  int virtualW,
  int virtualH,
  ViewportScaleMode mode, {
  Alignment alignment = Alignment.center,
}) {
  assert(devicePixelRatio > 0);
  assert(virtualW > 0);
  assert(virtualH > 0);

  final screenW = constraints.hasBoundedWidth ? constraints.maxWidth : 0.0;
  final screenH = constraints.hasBoundedHeight ? constraints.maxHeight : 0.0;
  final screenPxW = screenW * devicePixelRatio;
  final screenPxH = screenH * devicePixelRatio;

  final scaleW = screenPxW / virtualW;
  final scaleH = screenPxH / virtualH;

  final scalePx = switch (mode) {
    ViewportScaleMode.pixelPerfectContain =>
      math.max(1.0, math.min(scaleW, scaleH).floorToDouble()),
    ViewportScaleMode.pixelPerfectCover =>
      math.max(1.0, math.max(scaleW, scaleH).ceilToDouble()),
  };

  final viewPxW = virtualW * scalePx;
  final viewPxH = virtualH * scalePx;
  final viewW = viewPxW / devicePixelRatio;
  final viewH = viewPxH / devicePixelRatio;

  final alignX = (alignment.x + 1.0) * 0.5;
  final alignY = (alignment.y + 1.0) * 0.5;
  final offsetX = (screenW - viewW) * alignX;
  final offsetY = (screenH - viewH) * alignY;

  return ViewportMetrics(
    viewW: viewW,
    viewH: viewH,
    offsetX: offsetX,
    offsetY: offsetY,
  );
}

