REPO: C:\dev\rpg_runner
COMMIT: ee33453ee8b3
DATE: 2026-02-25 14:37:02


===== FILE: lib/AGENTS.md =====
# AGENTS.md

Instructions for AI coding agents working in the `lib/` directory.

## Project Mission

Build a **complete vertical slice** of a production-grade Flutter + Flame runner game with:

**Core Features:**
- **Advanced combat & abilities** - Mobility skills, spells, weapons, and ultimate abilities
- **Character system** - 2 playable characters with unique traits
- **Loadout customization** - Pre-run ability selection menu
- **Content variety** - 2-3 distinct levels, 5-6 enemy types
- **Narrative integration** - Light story elements enhancing engagement

**Technical Excellence:**
- **Deterministic Core** - Enables ghost replay, multiplayer races, and eventual battle royale
- **Firebase backend** - Player data, progression, leaderboards
- **Multiplayer-ready** - Architecture supports online races and competitive modes
- **Monetization pipeline** - IAP and progression hooks
- **Mobile performance** - 60 FPS, clean architecture, scalable design

**Implementation phases** (step-by-step):
1. **Combat & Abilities** - Implement mobility, spells, weapons, ultimates (foundation for customization)
2. **Character & Loadout** - Character selection, loadout menu, customization system
3. **Content Scale** - Additional levels, enemy variety, balancing
4. **Backend & Ghost Run** - Firebase integration, replay system
5. **Narrative & Monetization** - Story elements, IAP pipeline
6. **Multiplayer Foundation** - Online race infrastructure, leaderboards

## Clean Architecture & Modularization Principles

**Senior-level engineering standards apply throughout this codebase.**

### Dependency Management

**Dependency Rule**: Dependencies point inward (UI → Game → Core, never reversed).

- **Core** has ZERO dependencies on Game or UI layers
- **Game** depends on Core contracts (snapshots, events), not Core internals
- **UI** depends on Game controller interfaces, not Core directly
- Use **dependency inversion** when lower layers need to notify upper layers (events, callbacks)

**Example violation to avoid**:
```dart
// ❌ BAD: Core importing Flutter
import 'package:flutter/material.dart'; // in lib/core/**

// ✅ GOOD: Core defines contracts, UI implements
abstract class GameEventListener {
  void onPlayerDeath(PlayerDeathEvent event);
}
```

### SOLID Principles

**Single Responsibility**:
- Each system/component has ONE reason to change
- `MovementSystem` does movement, not collision or damage
- Separate read operations from write operations where it improves clarity

**Open/Closed**:
- Extend behavior via composition, not modification
- Use strategy pattern for abilities (don't hardcode in player class)
- Level definitions extend base contracts without modifying core loading logic

**Liskov Substitution**:
- Subclasses must be substitutable for base types
- All `LevelDefinition` implementations must work with same loading logic
- All `Ability` implementations must work with same activation system

**Interface Segregation**:
- Narrow interfaces over fat ones
- Don't force systems to depend on methods they don't use
- Split large interfaces into focused contracts

**Dependency Inversion**:
- Depend on abstractions, not concrete implementations
- Core defines event interfaces, Game/UI implement handlers
- Use factory patterns for entity creation

### Decision-Making Standards

When approaching any implementation task, follow these standards:

**1. Consider Edge Cases First**
- What happens on different screen sizes, orientations, lifecycle events?
- What if the user backgrounds the app? Rotates the device? Loses network?
- What if this feature scales to 10x the current usage?

**2. Apply DRY Proactively**
- Before writing code, ask: "Does a similar pattern already exist?"
- If a pattern appears twice, extract it immediately into a reusable component
- Create shared utilities/widgets rather than duplicating logic

**3. Prefer Reusable Solutions**
- Create components that can be configured, not specialized one-offs
- Use composition over inheritance for flexibility
- Design for the 80% case but make the 20% possible via parameters

**4. Think About Future Changes**
- Will this pattern need to scale? What if we add 10 more pages/entities?
- Is the API stable enough for others to depend on?
- Are there implicit assumptions that could break later?

**5. Propose Alternatives for Non-Trivial Changes**
- Present 2-3 approaches with tradeoffs for architectural decisions
- Explain why one approach is preferred over others
- Call out risks and mitigation strategies

**6. Validate Before Implementing**
- Check if the solution handles lifecycle events (pause, resume, navigation)
- Consider platform-specific behaviors (iOS vs Android vs Web)
- Think about error states and graceful degradation

### Domain Separation

**Core domains** (organize by feature, not layer):
- **Combat** - Damage calculation, abilities, weapons, status effects
- **Movement** - Physics, velocity, collision response
- **Character** - Character definitions, stats, loadouts
- **Level** - Level data, spawning, progression
- **Inventory/Progression** - Items, unlocks, player progression

**Rules**:
- Keep domains loosely coupled
- Use events for cross-domain communication
- Define clear contracts between domains
- Avoid circular dependencies between domains

### Code Organization

**Module structure**:
```
lib/core/
  combat/          # Combat domain
    abilities/
    weapons/
    damage_system.dart
  character/       # Character domain
    character_definition.dart
    loadout.dart
  ecs/             # ECS framework (infrastructure)
    world.dart
    query.dart
```

**File size limits**:
- Keep files under 300 lines (ideally under 200)
- Extract helpers/utilities when files grow
- Split large systems into sub-systems

**Naming conventions**:
- Systems: `XxxSystem` (e.g., `CombatSystem`)
- Components: `XxxComponent` (e.g., `HealthComponent`)
- Events: `XxxEvent` (e.g., `PlayerDeathEvent`)
- Commands: `XxxCommand` (e.g., `UseAbilityCommand`)

### Testing Strategy

**Test coverage priorities**:
1. **Critical path** - Core gameplay loop, combat, movement (MUST have tests)
2. **Complex logic** - Ability interactions, damage calculations, AI decisions
3. **Edge cases** - Boundary conditions, error states, race conditions
4. **Regression** - Add tests for every bug fix

**Test types**:
- **Unit tests** (`test/core/**`) - Pure logic, systems, components
- **Integration tests** (`test/integration/**`) - Multi-system interactions
- **Widget tests** (`test/ui/**`) - UI behavior, interactions
- **Determinism tests** - Same seed → same results (critical for multiplayer)

**Test quality standards**:
- Tests must be fast (< 1s per test)
- Tests must be isolated (no shared state)
- Use meaningful test names: `test('shield recharges after cooldown expires')`
- Arrange-Act-Assert pattern

### Performance & Scalability

**Core performance rules**:
- **No allocations in hot loops** (per-tick systems)
- **Object pooling** for frequently created/destroyed entities
- **Batch operations** where possible (process arrays, not individual items)
- **Profile before optimizing** - measure, don't guess

**Scalability patterns**:
- Design systems to handle 100+ entities efficiently
- Use spatial partitioning for collision (quadtree/grid)
- Limit entity counts with object pools
- Async loading for heavy operations (assets, save data)

### Code Review Standards

When implementing/reviewing code, ensure:

- ✅ **No layer violations** (Core importing Flutter/Flame)
- ✅ **Single Responsibility** maintained
- ✅ **Tests included** for new behavior
- ✅ **Documentation updated** when contracts change
- ✅ **Performance considered** in hot paths
- ✅ **Error handling** for edge cases
- ✅ **Type safety** (no `dynamic` in gameplay code)
- ✅ **Consistent style** with existing codebase

## Architecture Overview

This project has **three hard layers**:

1. **Core** (`lib/core/`) - Pure Dart simulation: deterministic gameplay, physics, AI, RNG
2. **Game** (`lib/game/`) - Flame rendering: visuals only (sprites, animations, camera, parallax, VFX)
3. **UI** (`lib/ui/`) - Flutter widgets: menus, overlays, navigation, settings

**Hard rules:**
- **Core must not import Flutter or Flame.**
- Flame must not be authoritative for gameplay/collision.
- UI must not modify gameplay state directly; it sends **Commands** to the controller.
- The game must be embeddable: expose a reusable widget/route entrypoint; keep `lib/main.dart` as a dev host/demo only.

**For layer-specific implementation details**, see:
- **[lib/core/AGENTS.md](file:///c:/dev/rpg_runner/lib/core/AGENTS.md)** - ECS patterns, determinism, Core contracts
- **[lib/game/AGENTS.md](file:///c:/dev/rpg_runner/lib/game/AGENTS.md)** - Flame components, rendering, snapshot consumption
- **[lib/ui/AGENTS.md](file:///c:/dev/rpg_runner/lib/ui/AGENTS.md)** - Widget structure, command patterns, UI state

## Level System

**Goal**: Support multiple distinct levels (2-3 for vertical slice) as part of a scalable content pipeline.

**Rules:**
- Levels are **data-first**: define a `LevelId` + `LevelDefinition` (and optional level-specific systems) behind stable Core contracts.
- Level switching resets Core deterministically (seeded RNG, tick counter, entity world) and is driven by a **Command** from UI.
- Spawning/layout rules live in **Core** (authoritative). Render/UI only visualize and present selection/progress.
- Assets are organized and loaded **per level/scene**; avoid global "load everything at boot".
- Levels can have unique enemy compositions, difficulty curves, and environmental mechanics.

## Determinism Contract

- Simulation runs in **fixed ticks** (e.g. 60 Hz). Ticks are the only time authority.
- Inputs are **Commands** queued for a specific tick.
- RNG is seeded and owned by the Core. No wall-clock randomness.
- On app resume, clamp frame dt and **never** try to "catch up" thousands of ticks.

## Data Flow

### Commands → Core → Snapshots/Events

- **Input**: UI and Game layers send `Command` objects to the controller
- **Processing**: Core processes commands during tick execution
- **Output**: Core produces:
  - Immutable `GameStateSnapshot` for render/UI (serializable, renderer-friendly)
  - Transient `GameEvent`s (spawn/despawn/hit/sfx/screenshake/reward, etc.)

### Animation Resolution

Animation selection is resolved in Core via `AnimSystem` using `AnimResolver` + `AnimProfile`, and stored in `AnimStateStore` for snapshot consumption.

Renderer/UI must:
- Treat snapshots as read-only.
- Interpolate visuals using (`prevSnapshot`, `currSnapshot`, `alpha`) but **never simulate**.

## Prefer Existing Solutions

Before building something custom, check if a better solution already exists:

- In this repo (search for an existing pattern/component first)
- In Flame APIs (camera, viewport, parallax, input, effects)
- In well-maintained Dart/Flutter packages

**Rule of thumb:**
- Prefer **Flame** for *render concerns* (camera components, parallax rendering, effects).
- Prefer **UI (Flutter)** for *UI/input widgets* (joystick/buttons/menus/overlays).
- Prefer **Core** for *authoritative gameplay concerns* (movement/physics/collision, ability timing, damage rules), especially when determinism/networking is a goal.

## Implementation Sequencing

Prefer small, testable increments that move toward "multiple levels":

1. Define the Core level contracts (`LevelId`/`LevelDefinition`, load/reset flow).
2. Add level selection entry points (UI + dev menu) that send Commands only.
3. Make level-specific spawning/layout data-driven and deterministic.
4. Ship a second level that differs meaningfully (layout/spawns/tempo) without special-casing.
5. Add/extend Core tests to lock determinism per level (same seed ⇒ same snapshots/events).

## Code Quality Rules

- **Keep the codebase modular and scalable:**
  - Prefer small, cohesive modules with clear boundaries
  - Avoid tight coupling across Core/Game/UI; depend on stable contracts instead
  - Keep public embedding API stable (`lib/runner.dart`), treat internal folders as refactorable
- **Keep responsibilities narrow**: Avoid "god" classes that mix input/sim/render.
- **Prefer explicit data flow**: Commands in, snapshots/events out.
- **Keep Core allocation-light**: Avoid per-tick new Lists/Maps in hot loops.
- **Prefer `final`, `const`, and value types** for small structs (e.g. `Vec2`).
- **No `dynamic` in gameplay code**: Prefer typed payloads; if a temporary map is unavoidable, confine it to UI/debug only.
- **Make side effects explicit**: Core returns events; render/UI consume them.
- **Keep changes consistent** with existing style; avoid renames/reformatting unrelated code.
- **Add/extend tests** when relevant (especially when new behavior is introduced or existing behavior changes):
  - Core behavior: unit tests in `test/core/**` (`dart test`)
  - UI/viewport/widget behavior: widget tests where appropriate
- **Keep docs in sync** with code: update relevant docs whenever behavior, contracts, milestones, or public APIs change.

### UI House Style

When working in `lib/ui/**`, default to the UI “house style” described in `lib/ui/AGENTS.md`:

- Theme-driven components (`ThemeExtension`) with semantic APIs (`variant`, `size`), minimal styling knobs.
- No deprecated Flutter APIs (`WidgetState*`, `Color.withValues`).
- Avoid side-effects in `build` (e.g. `SystemChrome`).

## What an Agent Must Do on Each Task

When asked to implement/fix something:

1. **Identify which layer** it belongs to (Core vs Game vs UI).
2. **Check for an existing solution/pattern** that already fits the goal (repo + Flame + packages).
3. **Propose a minimal plan** (1-3 steps) and acceptance criteria.
4. **Implement** with deterministic rules intact.
5. **Update docs/comments** whenever a change affects behavior, contracts, milestones, or usage:
   - Update `docs/building/plan.md` if architecture rules/contracts change
   - If no existing doc fits, add a short doc under `docs/building/` and link it from `docs/building/plan.md`
   - Update `docs/building/TODO.md` if milestone checklist/follow-ups change
   - Treat `docs/building/v0-implementation-plan.md` as historical unless asked to revise it
   - Update top-of-file docs and public API docs (`lib/runner.dart`, route/widget docs) when embedding/API expectations change
6. **Add/extend relevant tests** when new behavior is introduced or existing behavior changes (especially Core determinism and systems).
7. **Provide:**
   - Files changed + why
   - How to run/verify (build + quick sanity checks)
   - Follow-ups (next incremental step)

## What NOT to Do

- Don't add Flutter/Flame imports into `lib/core/**`.
- Don't use Flame collision callbacks as gameplay truth.
- Don't introduce wall-clock timing in simulation (no `DateTime.now()`, no frame-dt gameplay).
- Don't "just make it work" by mixing UI/render/core responsibilities.

---

**For detailed layer-specific implementation guidance**, see the `AGENTS.md` file in each subdirectory (`core/`, `game/`, `ui/`).


===== FILE: lib/core/abilities/ability_catalog.dart =====
import 'catalog/common_ability_defs.dart';
import 'catalog/eloise_ability_defs.dart';
import 'ability_def.dart';

/// Read-only ability definition lookup contract.
///
/// Systems should depend on this interface so tests and alternate catalogs can
/// be injected without coupling to static globals.
abstract interface class AbilityResolver {
  /// Returns the authored ability for [key], or null when unknown.
  AbilityDef? resolve(AbilityKey key);
}

/// Static registry of all available abilities.
///
/// This is currently code-authored data to keep ability tuning deterministic
/// and reviewable in source control.
class AbilityCatalog implements AbilityResolver {
  const AbilityCatalog();

  /// Shared default resolver for convenience call sites.
  static const AbilityCatalog shared = AbilityCatalog();

  /// Complete ability definition table keyed by [AbilityKey].
  ///
  /// Keys should remain stable because they are referenced by loadouts, tests,
  /// and persisted run/telemetry data.
  static final Map<AbilityKey, AbilityDef> abilities =
      Map<AbilityKey, AbilityDef>.unmodifiable(<AbilityKey, AbilityDef>{
        ...commonAbilityDefs,
        ...eloiseAbilityDefs,
      });

  static final bool _integrityChecked = _validateIntegrity();

  static bool _validateIntegrity() {
    assert(() {
      final seenIds = <AbilityKey>{};
      for (final entry in abilities.entries) {
        final key = entry.key;
        final def = entry.value;
        if (key != def.id) {
          throw StateError(
            'AbilityCatalog key "$key" does not match AbilityDef.id "${def.id}".',
          );
        }
        if (!seenIds.add(def.id)) {
          throw StateError('Duplicate AbilityDef.id "${def.id}" in catalog.');
        }
      }
      return true;
    }());
    return true;
  }

  @override
  AbilityDef? resolve(AbilityKey key) {
    assert(_integrityChecked);
    return abilities[key];
  }
}


===== FILE: lib/core/abilities/ability_def.dart =====
import '../projectiles/projectile_id.dart';
import '../combat/damage_type.dart';
import '../combat/status/status.dart';
import '../snapshots/enums.dart';
import '../weapons/weapon_proc.dart';

/// Stable ability identifier used by loadouts, systems, and authored data.
///
/// Example: `eloise.sword_strike`.
typedef AbilityKey = String;

/// Logical action slot where an ability may be equipped/triggered.
enum AbilitySlot { primary, secondary, projectile, mobility, spell, jump }

/// High-level semantic grouping used by UI and systems.
enum AbilityCategory { melee, ranged, mobility, defense, utility }

/// Weapon family classification used for ability gating.
enum WeaponType { oneHandedSword, shield, throwingWeapon, projectileSpell }

/// Where this ability should fetch its combat payload from at commit-time.
///
/// This is the missing "source of truth" that decouples:
/// - which button/slot triggers an ability
/// - from where the ability derives weapon/projectile stats/procs/damage-type.
///
/// Critical for spell slot (can host anything).
enum AbilityPayloadSource {
  none,
  primaryWeapon,
  secondaryWeapon, // off-hand unless primary is two-handed (then primary)
  projectile,
  spellBook,
}

/// How target direction/position is acquired when committing an ability.
enum TargetingModel {
  none, // Instant self-cast / buff
  directional, // Uses input direction (melee)
  aimed, // Uses explicit aim cursor (ranged)
  aimedLine, // Directional line shot; strong when targets align
  aimedCharge, // Charged shot with long commit window
  homing, // Auto-locks nearest target
  groundTarget, // AOE circle on ground
}

/// How a committed ability is maintained after initial activation.
enum AbilityHoldMode {
  /// Standard one-shot ability lifecycle (windup -> active -> recovery).
  none,

  /// Ability remains active while the owning slot is held.
  ///
  /// The authored [AbilityDef.activeTicks] is treated as the maximum hold
  /// duration, and runtime systems may end it early on release or resource
  /// depletion.
  holdToMaintain,
}

/// Input lifecycle model authored per ability.
///
/// This is independent from targeting and charge behavior.
enum AbilityInputLifecycle {
  /// Commit on press edge.
  tap,

  /// Hold to prepare/aim/charge, commit on release edge.
  holdRelease,

  /// Commit on hold start and maintain while held.
  holdMaintain,
}

/// Runtime lifecycle stage of a committed ability.
enum AbilityPhase { idle, windup, active, recovery }

/// External/system causes that can forcibly cancel an ability.
enum ForcedInterruptCause {
  stun, // control lock stun
  death, // hp <= 0 or death state
  damageTaken, // non-zero damage applied this tick
}

// --------------------------------------------------------------------------
// HIT DELIVERY
// --------------------------------------------------------------------------

/// How often a delivery can apply damage during one activation.
enum HitPolicy {
  once, // Hit once per activation (e.g. explosion)
  oncePerTarget, // Hit each target once (e.g. sword swing)
  everyTick, // Hit every frame (e.g. beam)
}

/// Marker interface for authored hit-delivery definitions.
abstract class HitDeliveryDef {
  const HitDeliveryDef();
}

/// Melee hit volume authored in local-space rectangle terms.
class MeleeHitDelivery extends HitDeliveryDef {
  const MeleeHitDelivery({
    required this.sizeX,
    required this.sizeY,
    required this.offsetX,
    required this.offsetY,
    required this.hitPolicy,
  });

  /// Dimensions and offset in world units.
  final double sizeX;
  final double sizeY;
  final double offsetX;
  final double offsetY;
  final HitPolicy hitPolicy;
}

/// Projectile delivery config used by projectile intent/spawn systems.
class ProjectileHitDelivery extends HitDeliveryDef {
  const ProjectileHitDelivery({
    required this.projectileId,
    this.pierce = false,
    this.chain = false,
    this.chainCount = 0,
    this.hitPolicy = HitPolicy.oncePerTarget,
  }) : assert(chainCount >= 0, 'Chain count must be non-negative'),
       assert(!chain || chainCount > 0, 'If chain is true, count must be > 0');

  final ProjectileId projectileId;
  final bool pierce;
  final bool chain;
  final int chainCount;
  final HitPolicy hitPolicy;
}

/// For abilities that affect the user (Buff/Block) or have no hitbox (Dash).
class SelfHitDelivery extends HitDeliveryDef {
  const SelfHitDelivery();
}

/// Authored contact-impact payload for mobility abilities (dash/roll).
///
/// Effects are applied when the mobility user overlaps hostile targets during
/// the active phase.
class MobilityImpactDef {
  const MobilityImpactDef({
    this.hitPolicy = HitPolicy.oncePerTarget,
    this.damage100 = 0,
    this.critChanceBp = 0,
    this.damageType = DamageType.physical,
    this.procs = const <WeaponProc>[],
    this.statusProfileId = StatusProfileId.none,
  }) : assert(damage100 >= 0, 'mobility impact damage cannot be negative'),
       assert(
         critChanceBp >= 0 && critChanceBp <= 10000,
         'mobility impact crit chance must be in range [0, 10000]',
       );

  /// Convenience "no contact effects" preset.
  static const MobilityImpactDef none = MobilityImpactDef();

  /// Delivery cadence during a single activation.
  final HitPolicy hitPolicy;

  /// Fixed-point contact damage (`100 == 1.0`).
  final int damage100;

  /// Crit chance in basis points (`10000 == 100%`).
  final int critChanceBp;

  /// Damage type used for queued contact damage and status scaling.
  final DamageType damageType;

  /// Optional on-hit procs for contact damage applications.
  final List<WeaponProc> procs;

  /// Optional direct status applied on contact (independent from damage).
  final StatusProfileId statusProfileId;

  /// True when this definition would produce at least one gameplay effect.
  bool get hasAnyEffect =>
      damage100 > 0 ||
      procs.isNotEmpty ||
      statusProfileId != StatusProfileId.none;
}

// --------------------------------------------------------------------------
// CHARGE AUTHORING
// --------------------------------------------------------------------------

/// Authoring tier for charged commits.
///
/// Tiers are authored in 60 Hz tick semantics and selected by highest
/// [minHoldTicks60] <= runtime hold ticks (scaled to current tick rate).
class AbilityChargeTierDef {
  const AbilityChargeTierDef({
    required this.minHoldTicks60,
    required this.damageScaleBp,
    this.critBonusBp = 0,
    this.speedScaleBp = 10000,
    this.pierce,
    this.maxPierceHits,
  }) : assert(minHoldTicks60 >= 0, 'minHoldTicks60 cannot be negative'),
       assert(damageScaleBp >= 0, 'damageScaleBp cannot be negative'),
       assert(speedScaleBp > 0, 'speedScaleBp must be > 0'),
       assert(
         maxPierceHits == null || maxPierceHits > 0,
         'maxPierceHits must be > 0 when provided',
       );

  /// Minimum hold duration in authored 60 Hz ticks required for this tier.
  final int minHoldTicks60;

  /// Damage scale in basis points (`10000 == 1.0x`).
  final int damageScaleBp;

  /// Crit chance bonus in basis points (`100 == 1%`).
  final int critBonusBp;

  /// Projectile speed scale in basis points (`10000 == 1.0x`).
  final int speedScaleBp;

  /// Optional projectile piercing override.
  final bool? pierce;

  /// Optional projectile max pierce hit override.
  final int? maxPierceHits;
}

/// Data-authored charge profile shared by melee/projectile commit paths.
class AbilityChargeProfile {
  AbilityChargeProfile({required List<AbilityChargeTierDef> tiers})
    : assert(tiers.isNotEmpty, 'Charge profile must define at least one tier'),
      assert(
        _isStrictlyIncreasingMinHoldTicks(tiers),
        'Charge tiers must be strictly ordered by minHoldTicks60.',
      ),
      tiers = List<AbilityChargeTierDef>.unmodifiable(tiers);

  final List<AbilityChargeTierDef> tiers;

  static bool _isStrictlyIncreasingMinHoldTicks(
    List<AbilityChargeTierDef> tiers,
  ) {
    var previous = -1;
    for (final tier in tiers) {
      final current = tier.minHoldTicks60;
      if (current <= previous) return false;
      previous = current;
    }
    return true;
  }
}

// --------------------------------------------------------------------------
// RUNTIME DATA STRUCTS
// --------------------------------------------------------------------------

/// Captured aim state snapshot used by ability/runtime systems.
class AimSnapshot {
  const AimSnapshot({
    required this.angleRad,
    this.hasAngle = true,
    required this.capturedTick,
  });

  static const AimSnapshot empty = AimSnapshot(
    angleRad: 0.0,
    hasAngle: false,
    capturedTick: 0,
  );

  final double angleRad;
  final bool hasAngle;
  final int capturedTick;

  @override
  String toString() =>
      'AimSnapshot(rad: ${angleRad.toStringAsFixed(2)}, tick: $capturedTick)';
}

// --------------------------------------------------------------------------
// COOLDOWN GROUPS
// --------------------------------------------------------------------------

/// Maximum supported cooldown groups per entity.
///
/// Value: `8`.
const int kMaxCooldownGroups = 8;

/// Semantic constants for cooldown group IDs.
///
/// Abilities sharing a group share a cooldown. Use these constants
/// for clarity, or use raw integers for custom groupings.
abstract final class CooldownGroup {
  /// Primary melee abilities (sword strike, etc.)
  static const int primary = 0;

  /// Secondary/off-hand abilities (shield bash, shield block, etc.)
  static const int secondary = 1;

  /// Projectile abilities (spells, throwing weapons)
  static const int projectile = 2;

  /// Mobility abilities (dash, roll)
  static const int mobility = 3;

  /// Jump ability
  static const int jump = 4;

  /// Spell slot abilities (5-7 reserved for future/spell)
  static const int spell0 = 5;
  static const int spell1 = 6;
  static const int spell2 = 7;

  /// Returns the default cooldown group for a given slot.
  static int fromSlot(AbilitySlot slot) {
    switch (slot) {
      case AbilitySlot.primary:
        return primary;
      case AbilitySlot.secondary:
        return secondary;
      case AbilitySlot.projectile:
        return projectile;
      case AbilitySlot.mobility:
        return mobility;
      case AbilitySlot.jump:
        return jump;
      case AbilitySlot.spell:
        return spell0;
    }
  }
}

// --------------------------------------------------------------------------
// ABILITY DEFINITION
// --------------------------------------------------------------------------

/// Fixed-point resource costs for ability commits (`100 == 1.0`).
class AbilityResourceCost {
  const AbilityResourceCost({
    this.healthCost100 = 0,
    this.staminaCost100 = 0,
    this.manaCost100 = 0,
  }) : assert(healthCost100 >= 0, 'Health cost cannot be negative'),
       assert(staminaCost100 >= 0, 'Stamina cost cannot be negative'),
       assert(manaCost100 >= 0, 'Mana cost cannot be negative');

  static const AbilityResourceCost zero = AbilityResourceCost();

  final int healthCost100;
  final int staminaCost100;
  final int manaCost100;
}

/// Immutable authored definition for a playable/system ability.
class AbilityDef {
  /// Default forced interrupts for authored abilities: stun + death.
  static const Set<ForcedInterruptCause> defaultForcedInterruptCauses =
      <ForcedInterruptCause>{
        ForcedInterruptCause.stun,
        ForcedInterruptCause.death,
      };

  /// Authoring constructor for immutable ability data.
  ///
  /// Parameter order is grouped by authoring flow:
  /// identity -> delivery/input -> damage/payload -> timing/hold/charge
  /// -> costs/cooldown -> gating/self-effects -> presentation.
  ///
  AbilityDef({
    required this.id,
    required this.category,
    required Set<AbilitySlot> allowedSlots,
    this.hitDelivery = const SelfHitDelivery(),
    this.targetingModel = TargetingModel.none,
    required this.inputLifecycle,
    this.payloadSource = AbilityPayloadSource.none,
    this.baseDamage = 0,
    this.baseDamageType = DamageType.physical,
    List<WeaponProc> procs = const <WeaponProc>[],
    required this.windupTicks,
    required this.activeTicks,
    required this.recoveryTicks,
    this.holdMode = AbilityHoldMode.none,
    this.holdStaminaDrainPerSecond100 = 0,
    this.damageIgnoredBp = 0,
    this.grantsRiposteOnGuardedHit = false,
    this.mobilityImpact = MobilityImpactDef.none,
    this.mobilitySpeedX,
    this.groundJumpSpeedY,
    this.airJumpSpeedY,
    this.maxAirJumps = 0,
    this.airJumpCost = AbilityResourceCost.zero,
    this.chargeProfile,
    this.chargeMaxHoldTicks60 = 0,
    this.defaultCost = AbilityResourceCost.zero,
    Map<WeaponType, AbilityResourceCost> costProfileByWeaponType =
        const <WeaponType, AbilityResourceCost>{},
    required this.cooldownTicks,
    this.cooldownGroupId,
    Set<WeaponType> requiredWeaponTypes = const <WeaponType>{},
    this.requiresEquippedWeapon = false,
    Set<ForcedInterruptCause> forcedInterruptCauses =
        defaultForcedInterruptCauses,
    this.selfStatusProfileId = StatusProfileId.none,
    required this.animKey,
  }) : allowedSlots = Set<AbilitySlot>.unmodifiable(allowedSlots),
       procs = List<WeaponProc>.unmodifiable(procs),
       costProfileByWeaponType =
           Map<WeaponType, AbilityResourceCost>.unmodifiable(
             costProfileByWeaponType,
           ),
       requiredWeaponTypes = Set<WeaponType>.unmodifiable(requiredWeaponTypes),
       forcedInterruptCauses = Set<ForcedInterruptCause>.unmodifiable(
         forcedInterruptCauses,
       ),
       assert(id != '', 'Ability id cannot be empty.'),
       assert(
         windupTicks >= 0 && activeTicks >= 0 && recoveryTicks >= 0,
         'Ticks cannot be negative',
       ),
       assert(cooldownTicks >= 0, 'Cooldown cannot be negative'),
       assert(
         holdStaminaDrainPerSecond100 >= 0,
         'Hold stamina drain cannot be negative',
       ),
       assert(
         damageIgnoredBp >= 0 && damageIgnoredBp <= 10000,
         'Damage ignored bp must be in range [0, 10000].',
       ),
       assert(
         holdMode != AbilityHoldMode.none || holdStaminaDrainPerSecond100 == 0,
         'Non-hold abilities must not define hold stamina drain.',
       ),
       assert(
         category == AbilityCategory.mobility || !mobilityImpact.hasAnyEffect,
         'Only mobility abilities may author mobilityImpact effects.',
       ),
       assert(
         mobilitySpeedX == null || category == AbilityCategory.mobility,
         'Only mobility abilities may define mobilitySpeedX.',
       ),
       assert(
         mobilitySpeedX == null || mobilitySpeedX > 0,
         'mobilitySpeedX must be positive when defined.',
       ),
       assert(
         groundJumpSpeedY == null || groundJumpSpeedY > 0,
         'groundJumpSpeedY must be positive when defined.',
       ),
       assert(
         airJumpSpeedY == null || airJumpSpeedY > 0,
         'airJumpSpeedY must be positive when defined.',
       ),
       assert(
         groundJumpSpeedY == null || allowedSlots.contains(AbilitySlot.jump),
         'Only jump-slot abilities may define groundJumpSpeedY.',
       ),
       assert(
         airJumpSpeedY == null || allowedSlots.contains(AbilitySlot.jump),
         'Only jump-slot abilities may define airJumpSpeedY.',
       ),
       assert(
         groundJumpSpeedY == null || category == AbilityCategory.mobility,
         'Only mobility abilities may define groundJumpSpeedY.',
       ),
       assert(
         airJumpSpeedY == null || category == AbilityCategory.mobility,
         'Only mobility abilities may define airJumpSpeedY.',
       ),
       assert(maxAirJumps >= 0, 'maxAirJumps cannot be negative.'),
       assert(
         maxAirJumps == 0 || allowedSlots.contains(AbilitySlot.jump),
         'Only jump-slot abilities may define maxAirJumps.',
       ),
       assert(
         maxAirJumps == 0 || category == AbilityCategory.mobility,
         'Only mobility abilities may define maxAirJumps.',
       ),
       assert(
         airJumpCost.healthCost100 >= 0 &&
             airJumpCost.staminaCost100 >= 0 &&
             airJumpCost.manaCost100 >= 0,
         'airJumpCost cannot contain negative values.',
       ),
       assert(
         (airJumpCost.healthCost100 == 0 &&
                 airJumpCost.staminaCost100 == 0 &&
                 airJumpCost.manaCost100 == 0) ||
             allowedSlots.contains(AbilitySlot.jump),
         'Only jump-slot abilities may define airJumpCost.',
       ),
       assert(
         (airJumpCost.healthCost100 == 0 &&
                 airJumpCost.staminaCost100 == 0 &&
                 airJumpCost.manaCost100 == 0) ||
             category == AbilityCategory.mobility,
         'Only mobility abilities may define airJumpCost.',
       ),
       assert(
         mobilityImpact.damage100 > 0 || mobilityImpact.procs.isEmpty,
         'mobilityImpact procs require positive mobilityImpact damage.',
       ),
       assert(
         chargeMaxHoldTicks60 >= 0,
         'Charge max hold ticks cannot be negative',
       ),
       assert(
         chargeProfile != null || chargeMaxHoldTicks60 == 0,
         'Charge max hold ticks requires a charge profile.',
       ),
       assert(
         holdMode == AbilityHoldMode.none || activeTicks > 0,
         'Hold abilities require activeTicks > 0 for max hold duration.',
       ),
       assert(
         inputLifecycle != AbilityInputLifecycle.holdMaintain ||
             holdMode == AbilityHoldMode.holdToMaintain,
         'holdMaintain lifecycle requires holdToMaintain hold mode.',
       ),
       assert(
         holdMode != AbilityHoldMode.holdToMaintain ||
             inputLifecycle == AbilityInputLifecycle.holdMaintain,
         'holdToMaintain abilities must use holdMaintain lifecycle.',
       ),
       assert(
         chargeProfile == null || inputLifecycle != AbilityInputLifecycle.tap,
         'tap lifecycle cannot be combined with tiered charge.',
       ),
       assert(
         targetingModel != TargetingModel.none ||
             inputLifecycle != AbilityInputLifecycle.holdRelease,
         'holdRelease + self is intentionally unsupported.',
       ),
       assert(
         cooldownGroupId == null ||
             (cooldownGroupId >= 0 && cooldownGroupId < kMaxCooldownGroups),
         'Cooldown group must be in range [0, $kMaxCooldownGroups)',
       );

  final AbilityKey id;

  /// UI/system grouping category.
  final AbilityCategory category;

  /// Slots where this ability is legal to equip.
  final Set<AbilitySlot> allowedSlots;

  /// Targeting mode used at commit-time.
  final TargetingModel targetingModel;

  /// Delivery definition consumed by strike systems.
  final HitDeliveryDef hitDelivery;

  /// Where payload stats/procs are sourced from when committed.
  final AbilityPayloadSource payloadSource;

  /// Authored input lifecycle contract for this ability.
  final AbilityInputLifecycle inputLifecycle;

  /// Timing values authored at `60 Hz` tick semantics.
  ///
  /// For [AbilityHoldMode.holdToMaintain], [activeTicks] is the max hold
  /// window before automatic termination.
  final int windupTicks;
  final int activeTicks;
  final int recoveryTicks;

  /// Default resource cost when no weapon-type override is authored.
  final AbilityResourceCost defaultCost;

  /// Optional resource-cost overrides keyed by resolved payload [WeaponType].
  ///
  /// This enables abilities whose commit cost depends on the active payload
  /// source (for example, same projectile ability using spell mana or throw
  /// stamina based on the currently selected projectile weapon type).
  final Map<WeaponType, AbilityResourceCost> costProfileByWeaponType;

  /// Runtime hold behavior model.
  final AbilityHoldMode holdMode;

  /// Fixed-point stamina drain per second while a hold ability is maintained.
  ///
  /// `100 == 1.0 stamina/second`.
  final int holdStaminaDrainPerSecond100;

  /// Incoming hit damage ignored while this ability is active.
  ///
  /// Basis points: `10000 == 100%` (full ignore), `5000 == 50%`.
  /// This is consumed by combat middleware and is intentionally ability-authored
  /// so defensive abilities can tune mitigation independently.
  final int damageIgnoredBp;

  /// Whether a guarded hit during this ability grants the one-shot riposte buff.
  ///
  /// This is intentionally independent from [damageIgnoredBp] so designers can
  /// author "pure block" abilities (full mitigation, no riposte reward).
  final bool grantsRiposteOnGuardedHit;

  /// Optional contact payload applied during active mobility overlaps.
  final MobilityImpactDef mobilityImpact;

  /// Horizontal speed in world-units/second for this mobility ability.
  ///
  /// Each mobility ability defines its own speed. Non-mobility abilities
  /// leave this `null`.
  final double? mobilitySpeedX;

  /// Optional authored initial vertical speed for ground jump execution.
  ///
  /// Positive value in world-units/second. Runtime applies this upward
  /// (negative Y velocity) when a ground/coyote jump executes.
  final double? groundJumpSpeedY;

  /// Optional authored fixed vertical speed for air-jump execution.
  ///
  /// Positive value in world-units/second. Runtime applies this upward
  /// (negative Y velocity) when an air jump executes.
  final double? airJumpSpeedY;

  /// Number of extra airborne jumps allowed before touching ground.
  ///
  /// `0` means no extra air jump.
  final int maxAirJumps;

  /// Resource cost applied when performing an airborne jump.
  ///
  /// Ground jumps still use [defaultCost].
  final AbilityResourceCost airJumpCost;

  /// Cooldown duration in ticks.
  final int cooldownTicks;

  /// Cooldown group index (0-7). Abilities sharing a group share a cooldown.
  ///
  /// If null, defaults to the slot's default group via [CooldownGroup.fromSlot].
  /// Suggested defaults:
  ///   0 = primary melee
  ///   1 = secondary melee
  ///   2 = projectile
  ///   3 = mobility
  ///   4 = jump
  ///   5-7 = future/spell
  final int? cooldownGroupId;

  /// Forced interruption causes this ability opts into.
  final Set<ForcedInterruptCause> forcedInterruptCauses;

  /// Animation key to play while this ability is active.
  final AnimKey animKey;

  /// Weapon families required for this ability to be legal/equippable.
  final Set<WeaponType> requiredWeaponTypes;

  /// If true, this ability requires *some* weapon to be equipped in its slot,
  /// even if [requiredWeaponTypes] is empty.
  final bool requiresEquippedWeapon;

  /// Guaranteed or probabilistic effects applied on hit (ability-owned).
  /// Merged deterministically with item procs in [HitPayloadBuilder].
  final List<WeaponProc> procs;

  /// Status profile applied to self on execute (SelfHitDelivery only).
  final StatusProfileId selfStatusProfileId;

  /// Optional charge tuning profile for hold/release commits.
  final AbilityChargeProfile? chargeProfile;

  /// Optional hard timeout for charge holds in authored 60 Hz ticks.
  ///
  /// `0` means no timeout.
  final int chargeMaxHoldTicks60;

  /// Base damage for this ability.
  /// Fixed-point: 100 = 1.0 damage.
  /// - Melee: Base damage of the swing.
  /// - Thrown: Base damage of the throw.
  /// - Spell: Base damage of the spell projectile.
  final int baseDamage;

  /// Base damage type (element) for this ability.
  /// Explicitly defined in authored data.
  final DamageType baseDamageType;

  /// Returns the effective cooldown group for this ability.
  ///
  /// Uses [cooldownGroupId] if set, otherwise falls back to slot default.
  int effectiveCooldownGroup(AbilitySlot slot) {
    if (cooldownGroupId != null) return cooldownGroupId!;
    return CooldownGroup.fromSlot(slot);
  }

  /// Resolves the effective commit cost for the given payload [weaponType].
  ///
  /// Falls back to [defaultCost] when no matching override exists.
  AbilityResourceCost resolveCostForWeaponType(WeaponType? weaponType) {
    if (weaponType == null) return defaultCost;
    return costProfileByWeaponType[weaponType] ?? defaultCost;
  }

  @override
  String toString() => 'AbilityDef($id)';
}


===== FILE: lib/core/abilities/ability_gate.dart =====
import '../ecs/entity_id.dart';
import '../ecs/world.dart';

/// Reason why an ability commit was rejected by [AbilityGate].
enum AbilityGateFail {
  /// Entity is currently stun-locked.
  stunned,

  /// Cooldown group still has remaining ticks.
  onCooldown,

  /// Required mana resource store is missing.
  missingMana,

  /// Available mana is below requested cost.
  insufficientMana,

  /// Required stamina resource store is missing.
  missingStamina,

  /// Available stamina is below requested cost.
  insufficientStamina,

  /// Required health resource store is missing.
  missingHealth,

  /// Health cost would reduce HP below the non-lethal floor.
  insufficientHealth,

  // Mobility-only
  /// Mobility requires [MovementStore], but entity has none.
  missingMovement,

  /// Mobility requires [BodyStore], but entity has none.
  missingBody,

  /// Mobility cannot commit with disabled or kinematic bodies.
  bodyDisabledOrKinematic,

  /// Dash already active; disallow overlapping mobility commits.
  dashAlreadyActive,
}

/// Static guard helpers used before creating ability intents.
///
/// These checks are deterministic and side-effect free. Callers can use the
/// returned failure reason for telemetry or UI messaging.
abstract class AbilityGate {
  /// Returns `null` when combat ability commit is allowed, otherwise a reason.
  static AbilityGateFail? canCommitCombat(
    EcsWorld world, {
    required EntityId entity,
    required int currentTick,
    required int cooldownGroupId,
    required int healthCost100,
    required int manaCost100,
    required int staminaCost100,
  }) {
    if (world.controlLock.isStunned(entity, currentTick)) {
      return AbilityGateFail.stunned;
    }
    // Cooldown is checked before resource costs so failures report "on cooldown"
    // consistently when both constraints are true.
    if (world.cooldown.isOnCooldown(entity, cooldownGroupId)) {
      return AbilityGateFail.onCooldown;
    }

    if (manaCost100 > 0) {
      final mi = world.mana.tryIndexOf(entity);
      if (mi == null) return AbilityGateFail.missingMana;
      if (world.mana.mana[mi] < manaCost100) {
        return AbilityGateFail.insufficientMana;
      }
    }

    if (staminaCost100 > 0) {
      final si = world.stamina.tryIndexOf(entity);
      if (si == null) return AbilityGateFail.missingStamina;
      if (world.stamina.stamina[si] < staminaCost100) {
        return AbilityGateFail.insufficientStamina;
      }
    }

    if (healthCost100 > 0) {
      final hi = world.health.tryIndexOf(entity);
      if (hi == null) return AbilityGateFail.missingHealth;
      if (world.health.hp[hi] - healthCost100 < _minCommitHp100) {
        return AbilityGateFail.insufficientHealth;
      }
    }

    return null;
  }

  /// Returns `null` when mobility ability commit is allowed, otherwise a reason.
  static AbilityGateFail? canCommitMobility(
    EcsWorld world, {
    required EntityId entity,
    required int currentTick,
    required int cooldownGroupId,
    required int healthCost100,
    required int manaCost100,
    required int staminaCost100,
  }) {
    if (world.controlLock.isStunned(entity, currentTick)) {
      return AbilityGateFail.stunned;
    }

    final mi = world.movement.tryIndexOf(entity);
    if (mi == null) return AbilityGateFail.missingMovement;

    final bi = world.body.tryIndexOf(entity);
    if (bi == null) return AbilityGateFail.missingBody;

    if (!world.body.enabled[bi] || world.body.isKinematic[bi]) {
      return AbilityGateFail.bodyDisabledOrKinematic;
    }

    if (world.movement.dashTicksLeft[mi] > 0) {
      return AbilityGateFail.dashAlreadyActive;
    }

    if (world.cooldown.isOnCooldown(entity, cooldownGroupId)) {
      return AbilityGateFail.onCooldown;
    }

    if (manaCost100 > 0) {
      final mi = world.mana.tryIndexOf(entity);
      if (mi == null) return AbilityGateFail.missingMana;
      if (world.mana.mana[mi] < manaCost100) {
        return AbilityGateFail.insufficientMana;
      }
    }

    if (staminaCost100 > 0) {
      final si = world.stamina.tryIndexOf(entity);
      if (si == null) return AbilityGateFail.missingStamina;
      if (world.stamina.stamina[si] < staminaCost100) {
        return AbilityGateFail.insufficientStamina;
      }
    }

    if (healthCost100 > 0) {
      final hi = world.health.tryIndexOf(entity);
      if (hi == null) return AbilityGateFail.missingHealth;
      if (world.health.hp[hi] - healthCost100 < _minCommitHp100) {
        return AbilityGateFail.insufficientHealth;
      }
    }

    return null;
  }

  static const int _minCommitHp100 = 1;
}


===== FILE: lib/core/abilities/catalog/common_ability_defs.dart =====
import '../../combat/damage_type.dart';
import '../../projectiles/projectile_id.dart';
import '../../snapshots/enums.dart';
import '../ability_def.dart';

/// Common/system-authored abilities shared by AI/system actors.
final Map<AbilityKey, AbilityDef> commonAbilityDefs = <AbilityKey, AbilityDef>{
  'common.enemy_strike': AbilityDef(
    id: 'common.enemy_strike',
    category: AbilityCategory.melee,
    allowedSlots: {AbilitySlot.primary},
    targetingModel: TargetingModel.directional,
    inputLifecycle: AbilityInputLifecycle.tap,
    hitDelivery: MeleeHitDelivery(
      sizeX: 1.0,
      sizeY: 1.0,
      offsetX: 0.5,
      offsetY: 0.0,
      hitPolicy: HitPolicy.oncePerTarget,
    ),
    windupTicks: 8,
    activeTicks: 4,
    recoveryTicks: 24,
    cooldownTicks: 0,
    animKey: AnimKey.strike,
    baseDamage: 0,
  ),
  'common.enemy_cast': AbilityDef(
    id: 'common.enemy_cast',
    category: AbilityCategory.ranged,
    allowedSlots: {AbilitySlot.projectile},
    targetingModel: TargetingModel.aimed,
    inputLifecycle: AbilityInputLifecycle.holdRelease,
    hitDelivery: ProjectileHitDelivery(
      projectileId: ProjectileId.fireBolt,
      hitPolicy: HitPolicy.oncePerTarget,
    ),
    windupTicks: 6,
    activeTicks: 2,
    recoveryTicks: 12,
    cooldownTicks: 0,
    animKey: AnimKey.cast,
    requiredWeaponTypes: {WeaponType.projectileSpell},
    payloadSource: AbilityPayloadSource.projectile,
    baseDamage: 500, // Thunder bolt legacy damage 5.0
    baseDamageType: DamageType.physical,
  ),
};


===== FILE: lib/core/abilities/catalog/eloise_ability_defs.dart =====
import '../../combat/status/status.dart';
import '../../projectiles/projectile_id.dart';
import '../../snapshots/enums.dart';
import '../../weapons/weapon_proc.dart';
import '../ability_def.dart';

/// Eloise-authored playable ability definitions.
final Map<AbilityKey, AbilityDef> eloiseAbilityDefs = <AbilityKey, AbilityDef>{
  // --------------------------------------------------------------------------
  // ELOISE: PRIMARY (Sword)
  // --------------------------------------------------------------------------
  'eloise.bloodletter_slash': AbilityDef(
    id: 'eloise.bloodletter_slash',
    category: AbilityCategory.melee,
    allowedSlots: {AbilitySlot.primary},
    targetingModel: TargetingModel.directional,
    inputLifecycle: AbilityInputLifecycle.holdRelease,
    hitDelivery: MeleeHitDelivery(
      sizeX: 32,
      sizeY: 32,
      offsetX: 12,
      offsetY: 0.0,
      hitPolicy: HitPolicy.oncePerTarget,
    ),
    // 6 frames @ 0.06s = 0.36s -> ~22 ticks
    // Tuning: Active 0.10s (6 ticks)
    windupTicks: 8,
    activeTicks: 6,
    recoveryTicks: 8,
    defaultCost: AbilityResourceCost(staminaCost100: 500), // 5.0 stamina
    cooldownTicks: 18, // 0.30s
    animKey: AnimKey.strike,
    requiredWeaponTypes: {WeaponType.oneHandedSword},
    payloadSource: AbilityPayloadSource.primaryWeapon,
    procs: <WeaponProc>[
      WeaponProc(
        hook: ProcHook.onHit,
        statusProfileId: StatusProfileId.meleeBleed,
        chanceBp: 10000,
      ),
    ],
    baseDamage: 1500, // PlayerTuning meleeDamage 15.0
  ),
  'eloise.bloodletter_cleave': AbilityDef(
    id: 'eloise.bloodletter_cleave',
    category: AbilityCategory.melee,
    allowedSlots: {AbilitySlot.primary},
    targetingModel: TargetingModel.aimedCharge,
    inputLifecycle: AbilityInputLifecycle.holdRelease,
    hitDelivery: MeleeHitDelivery(
      sizeX: 32,
      sizeY: 32,
      offsetX: 12,
      offsetY: 0.0,
      hitPolicy: HitPolicy.oncePerTarget,
    ),
    windupTicks: 10,
    activeTicks: 6,
    recoveryTicks: 10,
    defaultCost: AbilityResourceCost(staminaCost100: 550),
    cooldownTicks: 24,
    forcedInterruptCauses: <ForcedInterruptCause>{
      ForcedInterruptCause.stun,
      ForcedInterruptCause.death,
      ForcedInterruptCause.damageTaken,
    },
    animKey: AnimKey.strike,
    requiredWeaponTypes: {WeaponType.oneHandedSword},
    payloadSource: AbilityPayloadSource.primaryWeapon,
    chargeProfile: AbilityChargeProfile(
      tiers: <AbilityChargeTierDef>[
        AbilityChargeTierDef(minHoldTicks60: 0, damageScaleBp: 9000),
        AbilityChargeTierDef(
          minHoldTicks60: 8,
          damageScaleBp: 10800,
          critBonusBp: 500,
        ),
        AbilityChargeTierDef(
          minHoldTicks60: 16,
          damageScaleBp: 13000,
          critBonusBp: 1000,
        ),
      ],
    ),
    chargeMaxHoldTicks60: 150,
    procs: <WeaponProc>[
      WeaponProc(
        hook: ProcHook.onHit,
        statusProfileId: StatusProfileId.meleeBleed,
        chanceBp: 10000,
      ),
    ],
    baseDamage: 1600,
  ),
  'eloise.seeker_slash': AbilityDef(
    id: 'eloise.seeker_slash',
    category: AbilityCategory.melee,
    allowedSlots: {AbilitySlot.primary},
    targetingModel: TargetingModel.homing,
    inputLifecycle: AbilityInputLifecycle.tap,
    hitDelivery: MeleeHitDelivery(
      sizeX: 32,
      sizeY: 32,
      offsetX: 12,
      offsetY: 0.0,
      hitPolicy: HitPolicy.oncePerTarget,
    ),
    // Match Sword Strike exactly; only targeting differs.
    windupTicks: 8,
    activeTicks: 6,
    recoveryTicks: 8,
    // Reliability tax for deterministic lock-on.
    defaultCost: AbilityResourceCost(staminaCost100: 550),
    cooldownTicks: 24,
    animKey: AnimKey.strike,
    requiredWeaponTypes: {WeaponType.oneHandedSword},
    payloadSource: AbilityPayloadSource.primaryWeapon,
    procs: <WeaponProc>[
      WeaponProc(
        hook: ProcHook.onHit,
        statusProfileId: StatusProfileId.meleeBleed,
        chanceBp: 10000,
      ),
    ],
    baseDamage: 1400,
  ),

  'eloise.riposte_guard': AbilityDef(
    id: 'eloise.riposte_guard',
    category: AbilityCategory.defense,
    allowedSlots: {AbilitySlot.primary},
    inputLifecycle: AbilityInputLifecycle.holdMaintain,
    windupTicks: 2,
    activeTicks: 180,
    recoveryTicks: 2,
    holdMode: AbilityHoldMode.holdToMaintain,
    holdStaminaDrainPerSecond100: 700,
    damageIgnoredBp: 5000,
    grantsRiposteOnGuardedHit: true,
    cooldownTicks: 30, // 0.50s
    animKey: AnimKey.parry,
    requiredWeaponTypes: {WeaponType.oneHandedSword},
    payloadSource: AbilityPayloadSource.primaryWeapon,
  ),

  // --------------------------------------------------------------------------
  // ELOISE: SECONDARY (Shield)
  // --------------------------------------------------------------------------
  'eloise.concussive_bash': AbilityDef(
    id: 'eloise.concussive_bash',
    category: AbilityCategory.melee,
    allowedSlots: {AbilitySlot.secondary},
    targetingModel: TargetingModel.directional,
    inputLifecycle: AbilityInputLifecycle.tap,
    hitDelivery: MeleeHitDelivery(
      sizeX: 32,
      sizeY: 32,
      offsetX: 12.0,
      offsetY: 0.0,
      hitPolicy: HitPolicy.oncePerTarget,
    ),
    windupTicks: 8,
    activeTicks: 6,
    recoveryTicks: 8,
    defaultCost: AbilityResourceCost(staminaCost100: 500),
    cooldownTicks: 18, // 0.30s
    animKey: AnimKey.shieldBash,
    requiredWeaponTypes: {WeaponType.shield},
    payloadSource: AbilityPayloadSource.secondaryWeapon,
    procs: <WeaponProc>[
      WeaponProc(
        hook: ProcHook.onHit,
        statusProfileId: StatusProfileId.stunOnHit,
        chanceBp: 10000,
      ),
    ],
    baseDamage: 1500, // Assuming standardized melee damage
  ),
  'eloise.concussive_breaker': AbilityDef(
    id: 'eloise.concussive_breaker',
    category: AbilityCategory.melee,
    allowedSlots: {AbilitySlot.secondary},
    targetingModel: TargetingModel.aimedCharge,
    inputLifecycle: AbilityInputLifecycle.holdRelease,
    hitDelivery: MeleeHitDelivery(
      sizeX: 32,
      sizeY: 32,
      offsetX: 12.0,
      offsetY: 0.0,
      hitPolicy: HitPolicy.oncePerTarget,
    ),
    windupTicks: 10,
    activeTicks: 6,
    recoveryTicks: 10,
    defaultCost: AbilityResourceCost(staminaCost100: 550),
    cooldownTicks: 24,
    forcedInterruptCauses: <ForcedInterruptCause>{
      ForcedInterruptCause.stun,
      ForcedInterruptCause.death,
      ForcedInterruptCause.damageTaken,
    },
    animKey: AnimKey.shieldBash,
    requiredWeaponTypes: {WeaponType.shield},
    payloadSource: AbilityPayloadSource.secondaryWeapon,
    chargeProfile: AbilityChargeProfile(
      tiers: <AbilityChargeTierDef>[
        AbilityChargeTierDef(minHoldTicks60: 0, damageScaleBp: 9000),
        AbilityChargeTierDef(
          minHoldTicks60: 8,
          damageScaleBp: 10800,
          critBonusBp: 500,
        ),
        AbilityChargeTierDef(
          minHoldTicks60: 16,
          damageScaleBp: 13000,
          critBonusBp: 1000,
        ),
      ],
    ),
    chargeMaxHoldTicks60: 150,
    procs: <WeaponProc>[
      WeaponProc(
        hook: ProcHook.onHit,
        statusProfileId: StatusProfileId.stunOnHit,
        chanceBp: 10000,
      ),
    ],
    baseDamage: 1600,
  ),
  'eloise.seeker_bash': AbilityDef(
    id: 'eloise.seeker_bash',
    category: AbilityCategory.melee,
    allowedSlots: {AbilitySlot.secondary},
    targetingModel: TargetingModel.homing,
    inputLifecycle: AbilityInputLifecycle.tap,
    hitDelivery: MeleeHitDelivery(
      sizeX: 32,
      sizeY: 32,
      offsetX: 12.0,
      offsetY: 0.0,
      hitPolicy: HitPolicy.oncePerTarget,
    ),
    // Match Shield Bash exactly; only targeting differs.
    windupTicks: 8,
    activeTicks: 6,
    recoveryTicks: 8,
    // Reliability tax for deterministic lock-on.
    defaultCost: AbilityResourceCost(staminaCost100: 550),
    cooldownTicks: 24,
    animKey: AnimKey.shieldBash,
    requiredWeaponTypes: {WeaponType.shield},
    payloadSource: AbilityPayloadSource.secondaryWeapon,
    procs: <WeaponProc>[
      WeaponProc(
        hook: ProcHook.onHit,
        statusProfileId: StatusProfileId.stunOnHit,
        chanceBp: 10000,
      ),
    ],
    baseDamage: 1400,
  ),

  'eloise.aegis_riposte': AbilityDef(
    id: 'eloise.aegis_riposte',
    category: AbilityCategory.defense,
    allowedSlots: {AbilitySlot.secondary},
    inputLifecycle: AbilityInputLifecycle.holdMaintain,
    windupTicks: 2,
    activeTicks: 180,
    recoveryTicks: 2,
    holdMode: AbilityHoldMode.holdToMaintain,
    holdStaminaDrainPerSecond100: 700,
    damageIgnoredBp: 5000,
    grantsRiposteOnGuardedHit: true,
    cooldownTicks: 30,
    animKey: AnimKey.shieldBlock,
    requiredWeaponTypes: {WeaponType.shield},
    payloadSource: AbilityPayloadSource.secondaryWeapon,
  ),

  'eloise.shield_block': AbilityDef(
    id: 'eloise.shield_block',
    category: AbilityCategory.defense,
    allowedSlots: {AbilitySlot.secondary},
    inputLifecycle: AbilityInputLifecycle.holdMaintain,
    windupTicks: 2,
    activeTicks: 180,
    recoveryTicks: 2,
    holdMode: AbilityHoldMode.holdToMaintain,
    holdStaminaDrainPerSecond100: 700,
    damageIgnoredBp: 10000,
    grantsRiposteOnGuardedHit: false,
    cooldownTicks: 30,
    animKey: AnimKey.shieldBlock,
    requiredWeaponTypes: {WeaponType.shield},
    payloadSource: AbilityPayloadSource.secondaryWeapon,
  ),

  // --------------------------------------------------------------------------
  // ELOISE: PROJECTILE
  // --------------------------------------------------------------------------
  'eloise.snap_shot': AbilityDef(
    id: 'eloise.snap_shot',
    category: AbilityCategory.ranged,
    allowedSlots: {AbilitySlot.projectile},
    targetingModel: TargetingModel.homing,
    inputLifecycle: AbilityInputLifecycle.tap,
    // Projectile id comes from the equipped projectile item at runtime.
    hitDelivery: ProjectileHitDelivery(
      projectileId: ProjectileId.iceBolt,
      hitPolicy: HitPolicy.oncePerTarget,
    ),
    windupTicks: 10,
    activeTicks: 2,
    recoveryTicks: 12,
    defaultCost: AbilityResourceCost(manaCost100: 800),
    costProfileByWeaponType: <WeaponType, AbilityResourceCost>{
      WeaponType.throwingWeapon: AbilityResourceCost(staminaCost100: 800),
    },
    cooldownTicks: 40,
    animKey: AnimKey.ranged,
    requiredWeaponTypes: {
      WeaponType.throwingWeapon,
      WeaponType.projectileSpell,
    },
    payloadSource: AbilityPayloadSource.projectile,
    baseDamage: 1300,
  ),

  'eloise.quick_shot': AbilityDef(
    id: 'eloise.quick_shot',
    category: AbilityCategory.ranged,
    allowedSlots: {AbilitySlot.projectile},
    targetingModel: TargetingModel.aimed,
    inputLifecycle: AbilityInputLifecycle.holdRelease,
    // Projectile id comes from the equipped projectile item at runtime.
    hitDelivery: ProjectileHitDelivery(
      projectileId: ProjectileId.throwingKnife,
      hitPolicy: HitPolicy.oncePerTarget,
    ),
    windupTicks: 10,
    activeTicks: 2,
    recoveryTicks: 12,
    defaultCost: AbilityResourceCost(manaCost100: 600),
    costProfileByWeaponType: <WeaponType, AbilityResourceCost>{
      WeaponType.throwingWeapon: AbilityResourceCost(staminaCost100: 600),
    },
    cooldownTicks: 14,
    animKey: AnimKey.ranged,
    requiredWeaponTypes: {
      WeaponType.throwingWeapon,
      WeaponType.projectileSpell,
    },
    payloadSource: AbilityPayloadSource.projectile,
    baseDamage: 900,
  ),

  'eloise.skewer_shot': AbilityDef(
    id: 'eloise.skewer_shot',
    category: AbilityCategory.ranged,
    allowedSlots: {AbilitySlot.projectile},
    targetingModel: TargetingModel.aimedLine,
    inputLifecycle: AbilityInputLifecycle.holdRelease,
    // Projectile id comes from the equipped projectile item at runtime.
    hitDelivery: ProjectileHitDelivery(
      projectileId: ProjectileId.throwingAxe,
      pierce: true,
      chainCount: 3,
      hitPolicy: HitPolicy.oncePerTarget,
    ),
    windupTicks: 10,
    activeTicks: 2,
    recoveryTicks: 12,
    defaultCost: AbilityResourceCost(manaCost100: 1000),
    costProfileByWeaponType: <WeaponType, AbilityResourceCost>{
      WeaponType.throwingWeapon: AbilityResourceCost(staminaCost100: 1000),
    },
    cooldownTicks: 32,
    animKey: AnimKey.ranged,
    requiredWeaponTypes: {
      WeaponType.throwingWeapon,
      WeaponType.projectileSpell,
    },
    payloadSource: AbilityPayloadSource.projectile,
    baseDamage: 1800,
  ),

  'eloise.overcharge_shot': AbilityDef(
    id: 'eloise.overcharge_shot',
    category: AbilityCategory.ranged,
    allowedSlots: {AbilitySlot.projectile},
    targetingModel: TargetingModel.aimedCharge,
    inputLifecycle: AbilityInputLifecycle.holdRelease,
    // Projectile id comes from the equipped projectile item at runtime.
    hitDelivery: ProjectileHitDelivery(
      projectileId: ProjectileId.fireBolt,
      hitPolicy: HitPolicy.oncePerTarget,
    ),
    windupTicks: 10,
    activeTicks: 2,
    recoveryTicks: 12,
    defaultCost: AbilityResourceCost(manaCost100: 1300),
    costProfileByWeaponType: <WeaponType, AbilityResourceCost>{
      WeaponType.throwingWeapon: AbilityResourceCost(staminaCost100: 1300),
    },
    cooldownTicks: 40,
    forcedInterruptCauses: <ForcedInterruptCause>{
      ForcedInterruptCause.stun,
      ForcedInterruptCause.death,
      ForcedInterruptCause.damageTaken,
    },
    animKey: AnimKey.ranged,
    requiredWeaponTypes: {
      WeaponType.throwingWeapon,
      WeaponType.projectileSpell,
    },
    payloadSource: AbilityPayloadSource.projectile,
    chargeProfile: AbilityChargeProfile(
      tiers: <AbilityChargeTierDef>[
        AbilityChargeTierDef(
          minHoldTicks60: 0,
          damageScaleBp: 8200,
          speedScaleBp: 9000,
        ),
        AbilityChargeTierDef(
          minHoldTicks60: 5,
          damageScaleBp: 10000,
          critBonusBp: 500,
          speedScaleBp: 10500,
        ),
        AbilityChargeTierDef(
          minHoldTicks60: 10,
          damageScaleBp: 12250,
          critBonusBp: 1000,
          speedScaleBp: 12000,
          pierce: true,
          maxPierceHits: 2,
        ),
      ],
    ),
    chargeMaxHoldTicks60: 150,
    baseDamage: 2300,
  ),

  // --------------------------------------------------------------------------
  // ELOISE: BONUS / BUFFS
  // --------------------------------------------------------------------------
  'eloise.arcane_haste': AbilityDef(
    id: 'eloise.arcane_haste',
    category: AbilityCategory.utility,
    allowedSlots: {AbilitySlot.spell},
    targetingModel: TargetingModel.none,
    inputLifecycle: AbilityInputLifecycle.tap,
    // Instant cast, short recovery.
    windupTicks: 0,
    activeTicks: 0,
    recoveryTicks: 10,
    defaultCost: AbilityResourceCost(manaCost100: 1000),
    cooldownTicks: 300, // 5s @ 60Hz
    animKey: AnimKey.cast,
    requiredWeaponTypes: {WeaponType.projectileSpell},
    payloadSource: AbilityPayloadSource.spellBook,
    selfStatusProfileId: StatusProfileId.speedBoost,
  ),
  'eloise.vital_surge': AbilityDef(
    id: 'eloise.vital_surge',
    category: AbilityCategory.utility,
    allowedSlots: {AbilitySlot.spell},
    targetingModel: TargetingModel.none,
    inputLifecycle: AbilityInputLifecycle.tap,
    windupTicks: 0,
    activeTicks: 0,
    recoveryTicks: 10,
    defaultCost: AbilityResourceCost(manaCost100: 1500),
    cooldownTicks: 420, // 7s @ 60Hz
    animKey: AnimKey.cast,
    requiredWeaponTypes: {WeaponType.projectileSpell},
    payloadSource: AbilityPayloadSource.spellBook,
    selfStatusProfileId: StatusProfileId.restoreHealth,
  ),
  'eloise.mana_infusion': AbilityDef(
    id: 'eloise.mana_infusion',
    category: AbilityCategory.utility,
    allowedSlots: {AbilitySlot.spell},
    targetingModel: TargetingModel.none,
    inputLifecycle: AbilityInputLifecycle.tap,
    windupTicks: 0,
    activeTicks: 0,
    recoveryTicks: 10,
    defaultCost: AbilityResourceCost(staminaCost100: 1500),
    cooldownTicks: 420, // 7s @ 60Hz
    animKey: AnimKey.cast,
    requiredWeaponTypes: {WeaponType.projectileSpell},
    payloadSource: AbilityPayloadSource.spellBook,
    selfStatusProfileId: StatusProfileId.restoreMana,
  ),
  'eloise.second_wind': AbilityDef(
    id: 'eloise.second_wind',
    category: AbilityCategory.utility,
    allowedSlots: {AbilitySlot.spell},
    targetingModel: TargetingModel.none,
    inputLifecycle: AbilityInputLifecycle.tap,
    windupTicks: 0,
    activeTicks: 0,
    recoveryTicks: 10,
    defaultCost: AbilityResourceCost(manaCost100: 1500),
    cooldownTicks: 420, // 7s @ 60Hz
    animKey: AnimKey.cast,
    requiredWeaponTypes: {WeaponType.projectileSpell},
    payloadSource: AbilityPayloadSource.spellBook,
    selfStatusProfileId: StatusProfileId.restoreStamina,
  ),

  // --------------------------------------------------------------------------
  // ELOISE: MOBILITY
  // --------------------------------------------------------------------------
  'eloise.jump': AbilityDef(
    id: 'eloise.jump',
    category: AbilityCategory.mobility,
    allowedSlots: {AbilitySlot.jump},
    inputLifecycle: AbilityInputLifecycle.tap,
    windupTicks: 0,
    activeTicks: 0,
    recoveryTicks: 0,
    defaultCost: AbilityResourceCost(
      staminaCost100: 200,
    ), // 2.0 stamina (matches default jump tuning)
    cooldownTicks: 0,
    animKey: AnimKey.jump,
  ),

  // Two-tap jump profile:
  // - First jump uses fixed lower impulse.
  // - Second tap (air jump) applies the same fixed impulse.
  // Timing of the second tap changes the resulting two-arc path.
  'eloise.double_jump': AbilityDef(
    id: 'eloise.double_jump',
    category: AbilityCategory.mobility,
    allowedSlots: {AbilitySlot.jump},
    inputLifecycle: AbilityInputLifecycle.tap,
    windupTicks: 0,
    activeTicks: 0,
    recoveryTicks: 0,
    defaultCost: AbilityResourceCost(staminaCost100: 200),
    groundJumpSpeedY: 450,
    airJumpSpeedY: 450,
    maxAirJumps: 1,
    airJumpCost: AbilityResourceCost(manaCost100: 200),
    cooldownTicks: 0,
    animKey: AnimKey.jump,
  ),

  'eloise.dash': AbilityDef(
    id: 'eloise.dash',
    category: AbilityCategory.mobility,
    allowedSlots: {AbilitySlot.mobility},
    targetingModel: TargetingModel.directional,
    inputLifecycle: AbilityInputLifecycle.tap,
    windupTicks: 0,
    activeTicks: 15,
    recoveryTicks: 0,
    defaultCost: AbilityResourceCost(staminaCost100: 200),
    cooldownTicks: 120,
    mobilitySpeedX: 550,
    animKey: AnimKey.dash,
  ),

  'eloise.roll': AbilityDef(
    id: 'eloise.roll',
    category: AbilityCategory.mobility,
    allowedSlots: {AbilitySlot.mobility},
    targetingModel: TargetingModel.directional,
    inputLifecycle: AbilityInputLifecycle.tap,
    windupTicks: 0,
    activeTicks: 10,
    recoveryTicks: 0,
    defaultCost: AbilityResourceCost(staminaCost100: 200),
    cooldownTicks: 120,
    mobilityImpact: MobilityImpactDef(
      hitPolicy: HitPolicy.oncePerTarget,
      statusProfileId: StatusProfileId.stunOnHit,
    ),
    mobilitySpeedX: 400,
    animKey: AnimKey.roll,
  ),
};


===== FILE: lib/core/abilities/effective_ability_cost.dart =====
import '../ecs/stores/combat/equipped_loadout_store.dart';
import '../projectiles/projectile_catalog.dart';
import '../projectiles/projectile_id.dart';
import '../spellBook/spell_book_catalog.dart';
import '../weapons/weapon_catalog.dart';
import 'ability_def.dart';

/// Resolves the effective commit cost for [ability] in [slot] for one loadout.
///
/// The resolved cost honors:
/// - [AbilityDef.defaultCost]
/// - [AbilityDef.costProfileByWeaponType]
/// - runtime payload source + currently selected projectile spell/weapon.
AbilityResourceCost resolveEffectiveAbilityCostForSlot({
  required AbilityDef ability,
  required EquippedLoadoutStore loadout,
  required int loadoutIndex,
  required AbilitySlot slot,
  required WeaponCatalog weapons,
  required ProjectileCatalog projectiles,
  required SpellBookCatalog spellBooks,
}) {
  final payloadWeaponType = resolvePayloadWeaponTypeForAbilitySlot(
    ability: ability,
    loadout: loadout,
    loadoutIndex: loadoutIndex,
    slot: slot,
    weapons: weapons,
    projectiles: projectiles,
    spellBooks: spellBooks,
  );
  return ability.resolveCostForWeaponType(payloadWeaponType);
}

/// Resolves the payload [WeaponType] that [ability] will use for [slot].
WeaponType? resolvePayloadWeaponTypeForAbilitySlot({
  required AbilityDef ability,
  required EquippedLoadoutStore loadout,
  required int loadoutIndex,
  required AbilitySlot slot,
  required WeaponCatalog weapons,
  required ProjectileCatalog projectiles,
  required SpellBookCatalog spellBooks,
}) {
  switch (ability.payloadSource) {
    case AbilityPayloadSource.none:
      return null;
    case AbilityPayloadSource.primaryWeapon:
      return weapons.tryGet(loadout.mainWeaponId[loadoutIndex])?.weaponType;
    case AbilityPayloadSource.secondaryWeapon:
      final mainId = loadout.mainWeaponId[loadoutIndex];
      final main = weapons.tryGet(mainId);
      if (main != null && main.isTwoHanded) return main.weaponType;
      return weapons.tryGet(loadout.offhandWeaponId[loadoutIndex])?.weaponType;
    case AbilityPayloadSource.projectile:
      final projectileId = resolveProjectilePayloadForAbilitySlot(
        ability: ability,
        loadout: loadout,
        loadoutIndex: loadoutIndex,
        slot: slot,
        projectiles: projectiles,
        spellBooks: spellBooks,
      );
      return projectiles.tryGet(projectileId)?.weaponType;
    case AbilityPayloadSource.spellBook:
      return spellBooks.tryGet(loadout.spellBookId[loadoutIndex])?.weaponType;
  }
}

/// Resolves the projectile item id that ability payload should use for [slot].
///
/// For projectile slot abilities this will prefer a selected projectile spell
/// from the equipped spellbook when valid; otherwise it falls back to the
/// equipped projectile item.
ProjectileId resolveProjectilePayloadForAbilitySlot({
  required AbilityDef ability,
  required EquippedLoadoutStore loadout,
  required int loadoutIndex,
  required AbilitySlot slot,
  required ProjectileCatalog projectiles,
  required SpellBookCatalog spellBooks,
}) {
  final selectedSpellId = slot == AbilitySlot.projectile
      ? loadout.projectileSlotSpellId[loadoutIndex]
      : null;
  if (selectedSpellId != null) {
    final selectedSpell = projectiles.tryGet(selectedSpellId);
    final spellBook = spellBooks.tryGet(loadout.spellBookId[loadoutIndex]);
    final supportsSpell =
        selectedSpell != null &&
        selectedSpell.weaponType == WeaponType.projectileSpell &&
        spellBook != null &&
        spellBook.containsProjectileSpell(selectedSpellId) &&
        (ability.requiredWeaponTypes.isEmpty ||
            ability.requiredWeaponTypes.contains(WeaponType.projectileSpell));
    if (supportsSpell) return selectedSpellId;
  }
  return loadout.projectileId[loadoutIndex];
}


===== FILE: lib/core/abilities/forced_interrupt_policy.dart =====
import 'ability_catalog.dart';
import 'ability_def.dart';

/// Ability interruption policy backed by authored ability definitions.
///
/// Inject this policy where interruption rules are evaluated so all systems
/// resolve ability data through the same catalog instance.
class ForcedInterruptPolicy {
  const ForcedInterruptPolicy({this.abilities = AbilityCatalog.shared});

  /// Ability resolver used to fetch authored forced-interrupt settings.
  final AbilityResolver abilities;

  /// Shared default policy backed by the shipped static catalog.
  static const ForcedInterruptPolicy defaultPolicy = ForcedInterruptPolicy();

  /// Returns the forced-interrupt causes allowed for the given [abilityId].
  ///
  /// Falls back to [AbilityDef.defaultForcedInterruptCauses] when the ability
  /// id is null, empty, or unknown.
  Set<ForcedInterruptCause> forcedInterruptCausesForAbility(
    AbilityKey? abilityId,
  ) {
    if (abilityId == null || abilityId.isEmpty) {
      return AbilityDef.defaultForcedInterruptCauses;
    }
    final ability = abilities.resolve(abilityId);
    if (ability == null) return AbilityDef.defaultForcedInterruptCauses;
    return ability.forcedInterruptCauses;
  }

  /// Whether [abilityId] allows being forcibly interrupted by [cause].
  ///
  /// This is used by interruption systems to keep per-ability opt-in behavior
  /// centralized in authored ability data.
  bool abilityAllowsForcedInterrupt(
    AbilityKey? abilityId,
    ForcedInterruptCause cause,
  ) {
    return forcedInterruptCausesForAbility(abilityId).contains(cause);
  }
}


===== FILE: lib/core/accessories/accessory_catalog.dart =====
import 'accessory_def.dart';
import 'accessory_id.dart';
import '../stats/gear_stat_bonuses.dart';

/// Read-only authored accessory definitions.
///
/// This catalog uses an exhaustive enum switch so adding a new [AccessoryId]
/// forces a compile-time update here.
class AccessoryCatalog {
  const AccessoryCatalog();

  /// Returns the authored definition for [id].
  ///
  /// This API is intentionally non-nullable: every valid [AccessoryId] must
  /// resolve to a definition.
  AccessoryDef get(AccessoryId id) {
    switch (id) {
      case AccessoryId.speedBoots:
        return const AccessoryDef(
          id: AccessoryId.speedBoots,
          // 500 bp = +5% move speed.
          stats: GearStatBonuses(moveSpeedBonusBp: 500),
        );
      case AccessoryId.goldenRing:
        return const AccessoryDef(
          id: AccessoryId.goldenRing,
          // 200 bp = +2% max health.
          stats: GearStatBonuses(hpBonus100: 200),
        );
      case AccessoryId.teethNecklace:
        return const AccessoryDef(
          id: AccessoryId.teethNecklace,
          // 200 bp = +2% max stamina.
          stats: GearStatBonuses(staminaBonus100: 200),
        );
    }
  }
}


===== FILE: lib/core/accessories/accessory_def.dart =====
import '../stats/gear_stat_bonuses.dart';
import 'accessory_id.dart';

/// Accessory equip location.
///
/// There is currently one accessory slot. Keeping this enum allows future
/// expansion (for example, ring/amulet split) without changing the model type.
enum AccessorySlot { trinket }

/// Immutable authored definition for an accessory item.
///
/// Accessories currently contribute only aggregated stat bonuses. Combat proc
/// behavior is intentionally modeled elsewhere and is not part of this payload.
class AccessoryDef {
  const AccessoryDef({
    required this.id,
    this.slot = AccessorySlot.trinket,
    this.stats = const GearStatBonuses(),
  });

  /// Stable accessory key referenced by meta/inventory state.
  final AccessoryId id;

  /// Equip location this accessory occupies.
  final AccessorySlot slot;

  /// Additive stat contribution merged into resolved character stats.
  ///
  /// Values use [GearStatBonuses] units (`100 = 1%` for basis-point fields).
  final GearStatBonuses stats;
}


===== FILE: lib/core/accessories/accessory_id.dart =====
/// Stable accessory identifiers used by loadouts, inventory, and persistence.
///
/// Keep these values stable once shipped; saved player data stores enum names.
enum AccessoryId { speedBoots, goldenRing, teethNecklace }


===== FILE: lib/core/AGENTS.md =====
# AGENTS.md - Core Layer

Instructions for AI coding agents working in the **Core** simulation layer (`lib/core/`).

## Core Responsibility

The Core layer is a **pure Dart simulation engine**. It is the single source of truth for all gameplay logic, physics, AI, and state management.

**Hard rule:** Core must **never import Flutter or Flame**. This ensures determinism, testability, and future network-readiness.

## ECS Architecture

### Entity Storage

Core uses **SoA (Structure of Arrays) + SparseSet** per component type.

**Entity ID rules:**
- Entity IDs are **monotonic** and **never reused**
- IDs increment sequentially as entities are spawned
- Destroyed entity IDs are not recycled

### Component Iteration

**Query-based iteration:**
- Systems iterate via queries (e.g., `world.query<Position, Velocity>()`)
- Never directly access sparse/dense arrays unless implementing a new storage mechanism

**Structural change rules:**
- **Do not add/remove components or destroy entities mid-iteration**
- Queue structural changes and apply them after system execution
- Use deferred operations or command buffers for mid-tick mutations
- Do not keep references to dense arrays across ticks

### System Patterns

Systems should follow these patterns:

```dart
class ExampleSystem {
  void execute(World world, double dt) {
    // Query entities with required components
    final entities = world.query<ComponentA, ComponentB>();
    
    // Process entities (read-only iteration)
    for (final entity in entities) {
      final a = world.get<ComponentA>(entity);
      final b = world.get<ComponentB>(entity);
      
      // Update components in-place (safe)
      a.value += b.delta;
      
      // NEVER: world.destroyEntity(entity) here!
      // NEVER: world.addComponent(entity, newComponent) here!
    }
    
    // Apply structural changes after iteration
    // (queued during iteration, applied here)
  }
}
```

## Determinism Requirements

### Fixed Tick Simulation

- Simulation runs at a **fixed tick rate** (e.g., 60 Hz / 16.67ms per tick)
- Ticks are the **only time authority** in Core
- Use tick count for all timing logic, not wall-clock time

### Seeded RNG

- RNG is owned by Core and **must be seeded**
- Use a seeded `Random` instance stored in the game state
- Never use `Random()` without a seed in Core code
- Never use `DateTime.now()` or any wall-clock source for randomness

### Command Queueing

- Inputs are represented as **Command objects**
- Commands are queued for a specific tick
- Commands are processed deterministically during tick execution
- Example: `JumpCommand(tickNumber: 1234, playerId: 0)`

### Resumption Behavior

- On app resume, **clamp the frame delta-time**
- **Never** try to "catch up" thousands of ticks after backgrounding
- Skip or fast-forward deterministically if catch-up is needed

## Core Outputs

### GameStateSnapshot

- **Immutable** representation of the current game state
- Serializable and renderer-friendly
- Contains all data needed for rendering (positions, animations, health, etc.)
- Includes a `runId` field for session/replay/ghost metadata
- Produced once per tick
- Consumer layers (Game/UI) must treat this as **read-only**

### GameEvents

- **Transient** events emitted during tick execution
- Examples: spawn, despawn, hit, sfx, screenshake, reward, level-up
- Events have a short lifetime (typically one frame)
- Consumed by Game layer for VFX, sound effects, camera shake, etc.
- Not part of the persistent state

### Animation State

- Animation selection is resolved **in Core** via `AnimSystem`
- Uses `AnimResolver` + `AnimProfile` to determine which animation to play
- Stored in `AnimStateStore` for snapshot consumption
- Game layer reads animation state from snapshots and updates Flame sprite components accordingly

## Data Flow Pattern

**Commands → Core → Snapshots + Events**

1. **Input**: Game and UI layers create `Command` objects
2. **Queue**: Commands are queued for the next tick
3. **Process**: Core executes the tick, processing all queued commands
4. **Output**: Core produces:
   - One `GameStateSnapshot` (read by Game/UI for rendering)
   - Zero or more `GameEvent`s (consumed by Game for VFX/SFX)

## Performance Considerations

### Allocation-Light Hot Loops

- Avoid creating new `List`, `Map`, or objects in per-tick hot loops
- Prefer reusing buffers or pre-allocated pools
- Profile and optimize allocation-heavy systems

### Value Types

- Prefer **value types** for small structs (e.g., `Vec2`, `Rect`, `Color`)
- Use `final` and `const` where possible to prevent accidental mutations
- Avoid boxing primitives unnecessarily

### No Dynamic Types

- **Never use `dynamic`** in Core gameplay code
- Prefer strongly-typed payloads for all data structures
- If a temporary map is unavoidable, confine it to debug/tooling only

## Testing Core

### Unit Tests

- Core behavior should be covered by **unit tests** in `test/core/**`
- Run tests with: `dart test`
- Focus on:
  - Determinism (same seed → same results)
  - System behavior (physics, collision, AI)
  - Command processing
  - Edge cases (entity destruction, spawn limits, etc.)

### Determinism Tests

Example determinism test pattern:

```dart
test('same seed produces same results', () {
  final level = LevelRegistry.byId(LevelId.field);
  final game1 = GameCore(
    seed: 12345,
    levelDefinition: level,
    playerCharacter: PlayerCharacterRegistry.eloise,
  );
  final game2 = GameCore(
    seed: 12345,
    levelDefinition: level,
    playerCharacter: PlayerCharacterRegistry.eloise,
  );
  
  for (int i = 0; i < 100; i++) {
    game1.tick();
    game2.tick();
    
    expect(game1.snapshot, equals(game2.snapshot));
  }
});
```

## Common Core Subsystems

- **ECS** (`lib/core/ecs/`) - Entity-Component-System framework
- **Commands** (`lib/core/commands/`) - Input command definitions
- **Snapshots** (`lib/core/snapshots/`) - Snapshot data structures
- **Events** (`lib/core/events/`) - Game event definitions
- **Collision** (`lib/core/collision/`) - Authoritative collision detection
- **Combat** (`lib/core/combat/`) - Damage, health, abilities
- **Levels** (`lib/core/levels/`) - Level definitions and loading
- **Navigation** (`lib/core/navigation/`) - Pathfinding, AI movement
- **Track** (`lib/core/track/`) - Track/lane system
- **Tuning** (`lib/core/tuning/`) - Gameplay constants and balance values
- **Util** (`lib/core/util/`) - Pure Dart utilities (math, geometry, RNG helpers)

## What NOT to Do in Core

- ❌ **Do not import Flutter** (`package:flutter/...`)
- ❌ **Do not import Flame** (`package:flame/...`)
- ❌ **Do not use wall-clock time** (`DateTime.now()`, `Stopwatch`, frame delta-time)
- ❌ **Do not mutate structure mid-iteration** (adding/removing components, destroying entities)
- ❌ **Do not make rendering decisions** (that's Game layer's job)
- ❌ **Do not read user input directly** (use Commands instead)

---

**For cross-layer architecture and general rules**, see [lib/AGENTS.md](file:///c:/dev/rpg_runner/lib/AGENTS.md).


===== FILE: lib/core/anim/anim_resolver.dart =====
/// Shared animation resolver for Core entities.
library;

import '../enemies/death_behavior.dart';
import '../snapshots/enums.dart';

/// Configuration profile for an entity's animation capabilities and key mappings.
///
/// Defines which animations are supported (walk, jump, cast, etc.) and maps them
/// to specific [AnimKey]s in the animation atlas.
class AnimProfile {
  const AnimProfile({
    required this.minMoveSpeed,
    required this.runSpeedThresholdX,
    this.supportsWalk = true,
    this.supportsJumpFall = true,
    this.supportsDash = false,
    this.supportsCast = false,
    this.supportsRanged = false,
    this.supportsSpawn = false,
    this.supportsStun = false,
    this.directionalStrike = false,
    this.strikeAnimKey = AnimKey.strike,
    this.idleAnimKey = AnimKey.idle,
    this.walkAnimKey = AnimKey.walk,
    this.runAnimKey = AnimKey.run,
    this.jumpAnimKey = AnimKey.jump,
    this.fallAnimKey = AnimKey.fall,
    this.castAnimKey = AnimKey.cast,
    this.rangedAnimKey = AnimKey.ranged,
    this.dashAnimKey = AnimKey.dash,
    this.hitAnimKey = AnimKey.hit,
    this.deathAnimKey = AnimKey.death,
    this.spawnAnimKey = AnimKey.spawn,
    this.stunAnimKey = AnimKey.stun,
  });

  final double minMoveSpeed;
  final double runSpeedThresholdX;
  final bool supportsWalk;
  final bool supportsJumpFall;
  final bool supportsDash;
  final bool supportsCast;
  final bool supportsRanged;
  final bool supportsSpawn;
  final bool supportsStun;
  final bool directionalStrike;

  final AnimKey strikeAnimKey;
  final AnimKey idleAnimKey;
  final AnimKey walkAnimKey;
  final AnimKey runAnimKey;
  final AnimKey jumpAnimKey;
  final AnimKey fallAnimKey;
  final AnimKey castAnimKey;
  final AnimKey rangedAnimKey;
  final AnimKey dashAnimKey;
  final AnimKey hitAnimKey;
  final AnimKey deathAnimKey;
  final AnimKey spawnAnimKey;
  final AnimKey stunAnimKey;
}

/// Input state signals required to resolve the current animation frame.
///
/// Contains all relevant entity state (velocity, flags, timers) that affects
/// animation selection. This class is immutable and typically constructed
/// via [AnimSignals.player] or [AnimSignals.enemy] factories.
class AnimSignals {
  const AnimSignals._({
    required this.tick,
    required this.hp,
    required this.deathPhase,
    this.deathStartTick = -1,
    this.grounded = false,
    this.velX = 0.0,
    this.velY = 0.0,
    this.lastDamageTick = -1,
    this.hitAnimTicks = 0,
    this.spawnStartTick = -1,
    this.spawnAnimTicks = 0,
    this.stunLocked = false,
    this.stunStartTick = -1,
    this.activeActionAnim,
    this.activeActionFrame = 0,
  });

  factory AnimSignals.player({
    required int tick,
    required int hp,
    DeathPhase deathPhase = DeathPhase.none,
    int deathStartTick = -1,
    bool grounded = false,
    double velX = 0.0,
    double velY = 0.0,
    int lastDamageTick = -1,
    int hitAnimTicks = 0,
    int spawnStartTick = 0,
    int spawnAnimTicks = 0,
    bool stunLocked = false,
    int stunStartTick = -1,
    AnimKey? activeActionAnim,
    int activeActionFrame = 0,
  }) {
    return AnimSignals._(
      tick: tick,
      hp: hp,
      deathPhase: deathPhase,
      deathStartTick: deathStartTick,
      grounded: grounded,
      velX: velX,
      velY: velY,
      lastDamageTick: lastDamageTick,
      hitAnimTicks: hitAnimTicks,
      spawnStartTick: spawnStartTick,
      spawnAnimTicks: spawnAnimTicks,
      stunLocked: stunLocked,
      stunStartTick: stunStartTick,
      activeActionAnim: activeActionAnim,
      activeActionFrame: activeActionFrame,
    );
  }

  factory AnimSignals.enemy({
    required int tick,
    required int hp,
    required DeathPhase deathPhase,
    int deathStartTick = -1,
    bool grounded = false,
    double velX = 0.0,
    double velY = 0.0,
    int lastDamageTick = -1,
    int hitAnimTicks = 0,
    bool stunLocked = false,
    int stunStartTick = -1,
    AnimKey? activeActionAnim,
    int activeActionFrame = 0,
  }) {
    return AnimSignals._(
      tick: tick,
      hp: hp,
      deathPhase: deathPhase,
      deathStartTick: deathStartTick,
      grounded: grounded,
      velX: velX,
      velY: velY,
      lastDamageTick: lastDamageTick,
      hitAnimTicks: hitAnimTicks,
      stunLocked: stunLocked,
      stunStartTick: stunStartTick,
      activeActionAnim: activeActionAnim,
      activeActionFrame: activeActionFrame,
    );
  }
  final int tick;
  final int hp;
  final DeathPhase deathPhase;
  final int deathStartTick;
  final bool grounded;
  final double velX;
  final double velY;
  final int lastDamageTick;
  final int hitAnimTicks;
  final int spawnStartTick;
  final int spawnAnimTicks;
  final bool stunLocked;
  final int stunStartTick;
  final AnimKey? activeActionAnim;
  final int activeActionFrame;
}

/// The result of the animation resolution process.
///
/// Contains the resolved [AnimKey] and the specific frame index (or tick) to render.
class AnimResult {
  const AnimResult({required this.anim, required this.animFrame});

  final AnimKey anim;
  final int animFrame;
}

/// Pure logic resolver for determining the current animation.
///
/// Takes a static [AnimProfile] and dynamic [AnimSignals] to determine
/// the correct [AnimResult] based on a strictly prioritized state machine.
class AnimResolver {
  /// Resolves the current animation based on the provided profile and signals.
  ///
  /// Priority Order:
  /// 1. Stun (if stun locked)
  /// 2. Death (if dying or dead)
  /// 3. Hit React (if taking damage)
  /// 4. Active Action (manual overrides from abilities)
  /// 5. Movement (Jump/Fall > Spawn > Run > Walk > Idle)
  ///
  /// Frame-origin policy:
  /// - Relative-to-start: stun, death, hit, active action, spawn.
  /// - Global tick: jump, fall, idle, walk, run.
  ///
  /// Locomotion branches use global tick intentionally to keep loops phase-
  /// continuous through brief state toggles (for example grounded jitter).
  static AnimResult resolve(AnimProfile profile, AnimSignals signals) {
    final tick = signals.tick;
    final lastDamageTick = signals.lastDamageTick;
    final showHit =
        signals.hitAnimTicks > 0 &&
        lastDamageTick >= 0 &&
        (tick - lastDamageTick) < signals.hitAnimTicks;

    // 1. Stun
    if (profile.supportsStun && signals.stunLocked) {
      return AnimResult(
        anim: profile.stunAnimKey,
        animFrame: _frameFromTick(tick, signals.stunStartTick),
      );
    }

    // 2. Death
    if (signals.deathPhase == DeathPhase.deathAnim) {
      return AnimResult(
        anim: profile.deathAnimKey,
        animFrame: _frameFromTick(tick, signals.deathStartTick),
      );
    }
    if (signals.deathPhase == DeathPhase.fallingUntilGround) {
      if (profile.supportsJumpFall && !signals.grounded) {
        return AnimResult(
          anim: signals.velY < 0 ? profile.jumpAnimKey : profile.fallAnimKey,
          animFrame: tick,
        );
      }
      return AnimResult(anim: profile.idleAnimKey, animFrame: tick);
    }
    if (signals.hp <= 0) {
      // Legacy compatibility fallback: if lifecycle plumbing failed to provide
      // deathStartTick, hold at frame 0 instead of deriving from stale hit data.
      if (signals.deathStartTick < 0) {
        return AnimResult(anim: profile.deathAnimKey, animFrame: 0);
      }
      return AnimResult(
        anim: profile.deathAnimKey,
        animFrame: _frameFromTick(tick, signals.deathStartTick),
      );
    }

    // 3. Hit React
    if (showHit) {
      return AnimResult(
        anim: profile.hitAnimKey,
        animFrame: _frameFromTick(tick, lastDamageTick),
      );
    }

    // 4. Active Action Layer.
    if (signals.activeActionAnim != null) {
      final actionKey = _mapActiveActionKey(profile, signals.activeActionAnim!);
      if (actionKey != null) {
        return AnimResult(
          anim: actionKey,
          animFrame: signals.activeActionFrame,
        );
      }
    }

    // Locomotion loops intentionally use global tick as frame origin.
    if (profile.supportsJumpFall && !signals.grounded) {
      return AnimResult(
        anim: signals.velY < 0 ? profile.jumpAnimKey : profile.fallAnimKey,
        animFrame: tick,
      );
    }
    if (profile.supportsSpawn &&
        signals.spawnAnimTicks > 0 &&
        signals.spawnStartTick >= 0) {
      final spawnElapsed = tick - signals.spawnStartTick;
      if (spawnElapsed >= 0 && spawnElapsed < signals.spawnAnimTicks) {
        return AnimResult(
          anim: profile.spawnAnimKey,
          animFrame: _frameFromTick(tick, signals.spawnStartTick),
        );
      }
    }

    final speedX = signals.velX.abs();
    if (speedX <= profile.minMoveSpeed) {
      return AnimResult(anim: profile.idleAnimKey, animFrame: tick);
    }
    if (profile.supportsWalk && speedX < profile.runSpeedThresholdX) {
      return AnimResult(anim: profile.walkAnimKey, animFrame: tick);
    }
    return AnimResult(anim: profile.runAnimKey, animFrame: tick);
  }

  /// Maps a tick to a frame index.
  static int _frameFromTick(int tick, int startTick) {
    if (startTick < 0) return tick;
    final frame = tick - startTick;
    return frame < 0 ? 0 : frame;
  }

  /// Maps an [AnimKey] to the corresponding [AnimKey] for the given [AnimProfile].
  static AnimKey? _mapActiveActionKey(AnimProfile profile, AnimKey key) {
    switch (key) {
      case AnimKey.strike:
        return profile.strikeAnimKey;
      case AnimKey.backStrike:
        return profile.directionalStrike
            ? AnimKey.backStrike
            : profile.strikeAnimKey;
      case AnimKey.cast:
        return profile.supportsCast ? profile.castAnimKey : null;
      case AnimKey.ranged:
        return profile.supportsRanged ? profile.rangedAnimKey : null;
      case AnimKey.dash:
        return profile.supportsDash ? profile.dashAnimKey : null;
      case AnimKey.jump:
        return profile.supportsJumpFall ? profile.jumpAnimKey : null;
      case AnimKey.fall:
        return profile.supportsJumpFall ? profile.fallAnimKey : null;
      case AnimKey.roll:
        return profile.supportsDash ? key : null;
      case AnimKey.parry:
      case AnimKey.shieldBash:
      case AnimKey.shieldBlock:
        // Explicitly allow authored one-off action strips.
        return key;
      default:
        return null;
    }
  }
}


===== FILE: lib/core/camera/autoscroll_camera.dart =====
import '../util/smoothing.dart';
import '../util/double_math.dart';
import '../tuning/camera_tuning.dart';

class CameraState {
  const CameraState({
    required this.centerX,
    required this.targetX,
    required this.centerY,
    required this.targetY,
    required this.speedX,
  });

  /// Current visual center X of the camera view.
  final double centerX;

  /// The "ideal" center position the camera is trying to reach.
  /// This leads [centerX] and pulls it forward via smoothing.
  final double targetX;

  /// Current visual center Y of the camera view.
  final double centerY;

  /// The "ideal" Y center the camera is trying to reach.
  final double targetY;

  /// Current scroll speed (pixels/second).
  final double speedX;

  /// Creates a copy with updated fields.
  CameraState copyWith({
    double? centerX,
    double? targetX,
    double? centerY,
    double? targetY,
    double? speedX,
  }) {
    return CameraState(
      centerX: centerX ?? this.centerX,
      targetX: targetX ?? this.targetX,
      centerY: centerY ?? this.centerY,
      targetY: targetY ?? this.targetY,
      speedX: speedX ?? this.speedX,
    );
  }
}

/// Deterministic auto-scroll camera (Core).
///
/// Mirrors the reference behavior:
/// - baseline target speed with ease-in acceleration
/// - camera center eases toward a monotonic target X (never moves backward)
/// - player can pull the target forward only after passing a follow threshold
class AutoscrollCamera {
  AutoscrollCamera({
    required this.viewWidth,
    required this.viewHeight,
    required CameraTuningDerived tuning,
    required CameraState initial,
  }) : _tuning = tuning,
       _state = initial;

  final double viewWidth;
  final double viewHeight;
  final CameraTuningDerived _tuning;

  CameraState get state => _state;
  CameraState _state;

  double left() => _state.centerX - viewWidth * 0.5;
  double right() => _state.centerX + viewWidth * 0.5;
  double top() => _state.centerY - viewHeight * 0.5;
  double bottom() => _state.centerY + viewHeight * 0.5;

  /// The X coordinate where the player starts pushing the camera forward.
  ///
  /// Calculated from the viewport's left edge with:
  /// `thresholdX = left() + followThresholdRatio * viewWidth`.
  ///
  /// The camera only applies pull-forward when `playerRightX > thresholdX`.
  double followThresholdX() =>
      left() + _tuning.followThresholdRatio * viewWidth;

  /// Advances camera simulation by [dtSeconds].
  ///
  /// [playerRightX]/[playerY] are nullable to handle cases where the player is
  /// dead or despawned.
  ///
  /// [playerRightX] must be the collider/front-right X used by run-end
  /// behind-camera checks so camera pull and failure rules share one reference
  /// point.
  void updateTick({
    required double dtSeconds,
    required double? playerRightX,
    required double? playerY,
  }) {
    final t = _tuning;

    // 1. Update base scroll speed (accelerate/decelerate towards target speed).
    var speedX = _state.speedX;
    if (speedX < t.targetSpeedX) {
      speedX = clampDouble(speedX + t.accelX * dtSeconds, 0.0, t.targetSpeedX);
    } else if (speedX > t.targetSpeedX) {
      speedX = clampDouble(
        speedX - t.accelX * dtSeconds,
        t.targetSpeedX,
        speedX,
      );
    }

    // 2. Integrate target position based on speed.
    var targetX = _state.targetX + speedX * dtSeconds;

    // 3. Player catch-up logic.
    // If the player pushes past the threshold, the target point is pulled forward.
    // This allows the player to run faster than the scroll speed without staying
    // pinned to the edge (camera speeds up to catch them).
    if (playerRightX != null) {
      final threshold = followThresholdX();
      if (playerRightX > threshold) {
        final alphaT = expSmoothingFactor(t.targetCatchupLerp, dtSeconds);
        final newTarget = targetX + (playerRightX - targetX) * alphaT;
        targetX = targetX > newTarget ? targetX : newTarget;
      }
    }

    // 4. Smooth the actual camera center towards the target.
    final alpha = expSmoothingFactor(t.catchupLerp, dtSeconds);
    var centerX = _state.centerX + (targetX - _state.centerX) * alpha;

    // 5. Monotonicity clamp: the camera is an auto-scroller, it never goes left.
    if (centerX < _state.centerX) centerX = _state.centerX;
    if (targetX < _state.targetX) targetX = _state.targetX;

    var targetY = _state.targetY;
    var centerY = _state.centerY;
    if (t.verticalMode == CameraVerticalMode.followPlayer && playerY != null) {
      final deadZone = t.verticalDeadZone < 0 ? 0.0 : t.verticalDeadZone;
      var desiredTargetY = targetY;
      final deltaY = playerY - targetY;
      if (deltaY > deadZone) {
        desiredTargetY = playerY - deadZone;
      } else if (deltaY < -deadZone) {
        desiredTargetY = playerY + deadZone;
      }
      final alphaTargetY = expSmoothingFactor(
        t.verticalTargetCatchupLerp,
        dtSeconds,
      );
      targetY = targetY + (desiredTargetY - targetY) * alphaTargetY;
      final alphaCenterY = expSmoothingFactor(t.verticalCatchupLerp, dtSeconds);
      centerY = centerY + (targetY - centerY) * alphaCenterY;
    }

    _state = _state.copyWith(
      centerX: centerX,
      targetX: targetX,
      centerY: centerY,
      targetY: targetY,
      speedX: speedX,
    );
  }
}


===== FILE: lib/core/collision/static_world_geometry.dart =====
/// Static collision geometry owned by the Core simulation.
///
/// Starts with a set of base geometry (ground band), and extended with
/// deterministic chunk spawning.
class StaticGroundPlane {
  const StaticGroundPlane({required this.topY});

  /// World-space Y coordinate of the ground surface (solid top).
  final double topY;
}

/// A "hole" in the infinite ground plane where the player can fall through.
///
/// Use this to create pits or interruptions in the otherwise continuous ground.
class StaticGroundGap {
  const StaticGroundGap({required this.minX, required this.maxX})
    : assert(maxX >= minX);

  /// Start X coordinate of the gap (inclusive start of hole).
  final double minX;

  /// End X coordinate of the gap (inclusive end of hole).
  final double maxX;
}

/// A pre-computed walkable 1D segment for faster collision and navigation.
///
/// These are typically generated from the [StaticGroundPlane] minus any
/// [StaticGroundGap]s.
class StaticGroundSegment {
  const StaticGroundSegment({
    required this.minX,
    required this.maxX,
    required this.topY,
    this.chunkIndex = StaticSolid.groundChunk,
    this.localSegmentIndex = -1,
  }) : assert(maxX >= minX);

  /// Start X coordinate of the walkable surface.
  final double minX;

  /// End X coordinate of the walkable surface.
  final double maxX;

  /// Y coordinate of the surface (constant height).
  final double topY;

  /// Chunk index this segment was generated from, or [StaticSolid.groundChunk].
  final int chunkIndex;

  /// Stable local index within the chunk pattern authoring list.
  final int localSegmentIndex;
}

/// A generic AABB obstacle or platform in the world.
///
/// Can represent solid blocks, walls, floating platforms (one-way), or ceilings.
class StaticSolid {
  const StaticSolid({
    required this.minX,
    required this.minY,
    required this.maxX,
    required this.maxY,
    this.sides = sideTop,
    this.oneWayTop = true,
    this.chunkIndex = noChunk,
    this.localSolidIndex = -1,
  }) : assert(maxX >= minX),
       assert(maxY >= minY);

  /// Left edge world coordinate.
  final double minX;

  /// Bottom edge world coordinate.
  final double minY;

  /// Right edge world coordinate.
  final double maxX;

  /// Top edge world coordinate.
  final double maxY;

  /// Which faces of this solid participate in collision resolution.
  ///
  /// - one-way platforms typically use `sideTop` only
  /// - obstacles typically use `sideAll`
  final int sides;

  /// If true, the top surface only collides while falling (platform behavior).
  ///
  /// This only applies when [sides] includes [sideTop].
  final bool oneWayTop;

  /// Chunk index this solid was generated from (streaming), or [noChunk] for
  /// base/static geometry.
  final int chunkIndex;

  /// Stable local index within the chunk pattern authoring list.
  ///
  /// If negative, callers should derive a stable index from the owning list.
  final int localSolidIndex;

  /// Collision side flags.
  static const int sideNone = 0;
  static const int sideTop = 1 << 0;
  static const int sideBottom = 1 << 1;
  static const int sideLeft = 1 << 2;
  static const int sideRight = 1 << 3;
  static const int sideAll = sideTop | sideBottom | sideLeft | sideRight;

  /// Sentinel for solids not tied to a streamed chunk.
  static const int noChunk = -2;

  /// Reserved chunk index for always-on surfaces (e.g. ground plane).
  static const int groundChunk = -1;
}

/// Immutable bundle of static solids for a run/session.
class StaticWorldGeometry {
  const StaticWorldGeometry({
    this.groundPlane,
    this.groundSegments = const <StaticGroundSegment>[],
    this.solids = const <StaticSolid>[],
    this.groundGaps = const <StaticGroundGap>[],
  });

  /// Optional infinite ground plane (top surface only).
  final StaticGroundPlane? groundPlane;

  /// Walkable ground segments (used for collision + navigation).
  final List<StaticGroundSegment> groundSegments;

  /// Arbitrary static solids (platforms, walls, blocks).
  final List<StaticSolid> solids;

  /// Holes in the ground plane (world-space X ranges).
  final List<StaticGroundGap> groundGaps;
}


===== FILE: lib/core/collision/static_world_geometry_index.dart =====
import 'static_world_geometry.dart';
export 'static_world_geometry.dart';

/// Pre-indexed view of static world geometry for faster collision queries.
///
/// This is constructed once (per run/session) and preserves the original solid
/// ordering in each face list to keep behavior deterministic.
class StaticWorldGeometryIndex {
  StaticWorldGeometryIndex._({
    required this.geometry,
    required this.groundPlane,
    required this.groundSegments,
    required this.groundGaps,
    required List<StaticSolid> tops,
    required List<StaticSolid> bottoms,
    required List<StaticSolid> leftWalls,
    required List<StaticSolid> rightWalls,
    required double maxTopWidth,
    required double maxBottomWidth,
    required double maxLeftWidth,
    required double maxRightWidth,
  }) : _tops = tops,
       _bottoms = bottoms,
       _leftWalls = leftWalls,
       _rightWalls = rightWalls,
       _maxTopWidth = maxTopWidth,
       _maxBottomWidth = maxBottomWidth,
       _maxLeftWidth = maxLeftWidth,
       _maxRightWidth = maxRightWidth;

  /// Creates a spatial index from the raw static geometry.
  ///
  /// This process involves:
  /// 1. Categorizing solids by their active sides (top, bottom, left, right).
  /// 2. Sorting each list by [minX] to enable binary search.
  /// 3. Computing max widths for each list to optimize overlap queries.
  /// 4. Merging the ground plane and gaps into a unified list of walkable segments.
  factory StaticWorldGeometryIndex.from(StaticWorldGeometry geometry) {
    final tops = <StaticSolid>[];
    final bottoms = <StaticSolid>[];
    final leftWalls = <StaticSolid>[];
    final rightWalls = <StaticSolid>[];

    for (final solid in geometry.solids) {
      final sides = solid.sides;
      if ((sides & StaticSolid.sideTop) != 0) tops.add(solid);
      if ((sides & StaticSolid.sideBottom) != 0) bottoms.add(solid);
      if ((sides & StaticSolid.sideLeft) != 0) leftWalls.add(solid);
      if ((sides & StaticSolid.sideRight) != 0) rightWalls.add(solid);
    }

    // Sort for binary search.
    _sortByMinX(tops);
    _sortByMinX(bottoms);
    _sortByMinX(leftWalls);
    _sortByMinX(rightWalls);

    final groundSegments = _buildGroundSegments(geometry);
    // Ground segments are already sorted by _buildGroundSegments.

    final groundGaps = geometry.groundGaps.isEmpty
        ? const <StaticGroundGap>[]
        : List<StaticGroundGap>.unmodifiable(
            List<StaticGroundGap>.from(geometry.groundGaps),
          );

    return StaticWorldGeometryIndex._(
      geometry: geometry,
      groundPlane: geometry.groundPlane,
      groundSegments: groundSegments,
      groundGaps: groundGaps,
      tops: List<StaticSolid>.unmodifiable(tops),
      bottoms: List<StaticSolid>.unmodifiable(bottoms),
      leftWalls: List<StaticSolid>.unmodifiable(leftWalls),
      rightWalls: List<StaticSolid>.unmodifiable(rightWalls),
      maxTopWidth: _computeMaxWidth(tops),
      maxBottomWidth: _computeMaxWidth(bottoms),
      maxLeftWidth: _computeMaxWidth(leftWalls),
      maxRightWidth: _computeMaxWidth(rightWalls),
    );
  }

  /// Source geometry (unchanged).
  final StaticWorldGeometry geometry;

  /// Optional infinite ground plane.
  final StaticGroundPlane? groundPlane;

  /// Walkable ground segments (used for collision + navigation).
  final List<StaticGroundSegment> groundSegments;

  /// Ground gaps (holes in the ground plane).
  final List<StaticGroundGap> groundGaps;

  /// Solids with an enabled top face.
  final List<StaticSolid> _tops;

  /// Solids with an enabled bottom face (ceilings).
  final List<StaticSolid> _bottoms;

  /// Solids with an enabled left face (walls hit when moving right).
  final List<StaticSolid> _leftWalls;

  /// Solids with an enabled right face (walls hit when moving left).
  final List<StaticSolid> _rightWalls;

  final double _maxTopWidth;
  final double _maxBottomWidth;
  final double _maxLeftWidth;
  final double _maxRightWidth;

  /// Fills [out] with solids overlapping the range [minX, maxX].
  ///
  /// Uses binary search to find potential candidates in O(log N) time.
  void queryTops(double minX, double maxX, List<StaticSolid> out) {
    _query(_tops, minX, maxX, _maxTopWidth, out);
  }

  /// Fills [out] with solids overlapping the range [minX, maxX].
  ///
  /// Uses binary search to find potential candidates in O(log N) time.
  void queryBottoms(double minX, double maxX, List<StaticSolid> out) {
    _query(_bottoms, minX, maxX, _maxBottomWidth, out);
  }

  /// Fills [out] with solids overlapping the range [minX, maxX].
  ///
  /// Uses binary search to find potential candidates in O(log N) time.
  void queryLeftWalls(double minX, double maxX, List<StaticSolid> out) {
    _query(_leftWalls, minX, maxX, _maxLeftWidth, out);
  }

  /// Fills [out] with solids overlapping the range [minX, maxX].
  ///
  /// Uses binary search to find potential candidates in O(log N) time.
  void queryRightWalls(double minX, double maxX, List<StaticSolid> out) {
    _query(_rightWalls, minX, maxX, _maxRightWidth, out);
  }

  /// Fills [out] with ground segments overlapping the range [minX, maxX].
  ///
  /// Ground segments are guaranteed to be sorted and disjoint, allowing efficient
  /// traversal.
  void queryGroundSegments(
    double minX,
    double maxX,
    List<StaticGroundSegment> out,
  ) {
    final start = _lowerBoundSegments(groundSegments, minX);
    for (var i = start; i < groundSegments.length; i += 1) {
      final seg = groundSegments[i];
      if (seg.minX >= maxX) break;
      if (seg.maxX > minX) {
        out.add(seg);
      }
    }
  }

  /// Internal helper to query a sorted list of solids.
  ///
  /// [maxWidth] is used to determine the search window. Since the list is sorted
  /// by [minX], a solid can only overlap if its [minX] is within [maxWidth] of
  /// the query's [minX].
  static void _query(
    List<StaticSolid> list,
    double minX,
    double maxX,
    double maxWidth,
    List<StaticSolid> out,
  ) {
    final lowerBoundX = minX - maxWidth;
    final start = _lowerBound(list, lowerBoundX);

    for (var i = start; i < list.length; i += 1) {
      final s = list[i];
      if (s.minX >= maxX) break;
      if (s.maxX > minX) {
        out.add(s);
      }
    }
  }
}

void _sortByMinX(List<StaticSolid> list) {
  list.sort((a, b) => a.minX.compareTo(b.minX));
}

double _computeMaxWidth(List<StaticSolid> list) {
  var maxW = 0.0;
  for (final s in list) {
    final w = s.maxX - s.minX;
    if (w > maxW) maxW = w;
  }
  return maxW;
}

/// Standard binary search (lower bound) for `List<StaticSolid>`.
/// Returns the first index where `list[i].minX >= xValue`.
int _lowerBound(List<StaticSolid> list, double xValue) {
  var min = 0;
  var max = list.length;
  while (min < max) {
    final mid = min + ((max - min) >> 1);
    final element = list[mid];
    if (element.minX < xValue) {
      min = mid + 1;
    } else {
      max = mid;
    }
  }
  return min;
}

/// Specialized search for ground segments.
/// Returns the first index where `list[i].maxX > xValue`.
/// Since ground segments are disjoint, finding where they end relative to the
/// query start is a good entry point.
int _lowerBoundSegments(List<StaticGroundSegment> list, double xValue) {
  var min = 0;
  var max = list.length;
  while (min < max) {
    final mid = min + ((max - min) >> 1);
    if (list[mid].maxX <= xValue) {
      min = mid + 1;
    } else {
      max = mid;
    }
  }
  return min;
}

/// Helper to unify the ground plane and gaps into a single sorted list of
/// walkable segments.
List<StaticGroundSegment> _buildGroundSegments(StaticWorldGeometry geometry) {
  // If segments are already provided (e.g. from a chunk generator), use them.
  if (geometry.groundSegments.isNotEmpty) {
    _validateProvidedGroundSegments(geometry.groundSegments);
    return List<StaticGroundSegment>.unmodifiable(geometry.groundSegments);
  }

  // If no ground plane exists, there are no segments (void world).
  final groundPlane = geometry.groundPlane;
  if (groundPlane == null) {
    return const <StaticGroundSegment>[];
  }

  // If there are no gaps, the ground is a single infinite plane.
  if (geometry.groundGaps.isEmpty) {
    return List<StaticGroundSegment>.unmodifiable(<StaticGroundSegment>[
      StaticGroundSegment(
        minX: double.negativeInfinity,
        maxX: double.infinity,
        topY: groundPlane.topY,
        chunkIndex: StaticSolid.groundChunk,
        localSegmentIndex: 0,
      ),
    ]);
  }

  // 1. Sort gaps by minX to process them in order.
  final gaps = List<StaticGroundGap>.from(geometry.groundGaps)
    ..sort((a, b) => a.minX.compareTo(b.minX));

  // 2. Merge overlapping or adjacent gaps into fewer, larger gaps.
  final merged = <StaticGroundGap>[];
  for (final gap in gaps) {
    if (merged.isEmpty) {
      merged.add(gap);
      continue;
    }
    final last = merged.last;
    if (gap.minX <= last.maxX) {
      // Overlapping or touching gap. Extend the last gap if needed.
      if (gap.maxX > last.maxX) {
        merged[merged.length - 1] = StaticGroundGap(
          minX: last.minX,
          maxX: gap.maxX,
        );
      }
    } else {
      // Disjoint gap.
      merged.add(gap);
    }
  }

  // 3. Create segments strictly *between* the merged gaps.
  final segments = <StaticGroundSegment>[];
  var cursor = double.negativeInfinity;
  var localIndex = 0;
  for (final gap in merged) {
    // If there is space between the current cursor (end of last gap) and
    // the start of this gap, create a segment.
    if (gap.minX > cursor) {
      segments.add(
        StaticGroundSegment(
          minX: cursor,
          maxX: gap.minX,
          topY: groundPlane.topY,
          chunkIndex: StaticSolid.groundChunk,
          localSegmentIndex: localIndex,
        ),
      );
      localIndex += 1;
    }
    // Move cursor to the end of this gap.
    cursor = gap.maxX > cursor ? gap.maxX : cursor;
  }

  // 4. Create the final segment from the last gap to infinity.
  if (cursor < double.infinity) {
    segments.add(
      StaticGroundSegment(
        minX: cursor,
        maxX: double.infinity,
        topY: groundPlane.topY,
        chunkIndex: StaticSolid.groundChunk,
        localSegmentIndex: localIndex,
      ),
    );
  }

  return List<StaticGroundSegment>.unmodifiable(segments);
}

/// Validates externally-provided ground segments.
///
/// Required contract:
/// - sorted by [minX] ascending
/// - disjoint (touching is allowed, overlap is not)
/// - valid ranges (`maxX >= minX`)
void _validateProvidedGroundSegments(List<StaticGroundSegment> segments) {
  if (segments.isEmpty) return;
  const eps = 1e-9;

  for (var i = 0; i < segments.length; i += 1) {
    final segment = segments[i];
    if (segment.maxX < segment.minX - eps) {
      throw StateError(
        'Invalid ground segment at index $i: maxX (${segment.maxX}) < minX (${segment.minX}).',
      );
    }

    if (i == 0) continue;
    final previous = segments[i - 1];
    if (segment.minX < previous.minX - eps) {
      throw StateError(
        'Ground segments must be sorted by minX. '
        'Index ${i - 1} has minX=${previous.minX}, index $i has minX=${segment.minX}.',
      );
    }
    if (segment.minX < previous.maxX - eps) {
      throw StateError(
        'Ground segments must be disjoint. '
        'Index ${i - 1} maxX=${previous.maxX} overlaps index $i minX=${segment.minX}.',
      );
    }
  }
}


===== FILE: lib/core/combat/control_lock.dart =====
/// Lock flag bit constants for ability/action gating.
///
/// These flags control what actions an entity can perform.
/// Multiple locks can be active simultaneously with independent expiry times.
///
/// Use [LockFlag.stun] as a "master lock" that blocks everything.
library;

/// Bit flag constants for control locks.
abstract class LockFlag {
  /// Stun lock - blocks ALL actions and movement.
  /// This is the "master lock" - systems should check isStunned() first.
  static const int stun = 1 << 0;

  /// Movement lock - blocks horizontal control input.
  static const int move = 1 << 1;

  /// Jump lock - blocks jump input.
  static const int jump = 1 << 2;

  /// Dash lock - blocks dash ability.
  static const int dash = 1 << 3;

  /// Strike lock - blocks melee attacks.
  static const int strike = 1 << 4;

  /// Cast lock - blocks spell casting.
  static const int cast = 1 << 5;

  /// Ranged lock - blocks ranged weapon attacks.
  static const int ranged = 1 << 6;

  /// Nav lock - blocks enemy navigation/pathfinding.
  static const int nav = 1 << 7;

  // ─────────────────────────────────────────────────────────────────────────
  // Composite masks for convenience
  // ─────────────────────────────────────────────────────────────────────────

  /// All offensive actions (strike, cast, ranged).
  static const int allActions = strike | cast | ranged;

  /// All movement abilities (move, jump, dash).
  static const int allMovement = move | jump | dash;

  /// Everything except stun.
  static const int allExceptStun = allActions | allMovement | nav;

  /// All flags combined.
  static const int all = stun | allExceptStun;
}


===== FILE: lib/core/combat/creature_tag.dart =====
/// Broad classification tags shared across enemies and player variants.
enum CreatureTag {
  humanoid,
  demon,
  flying,
  undead,
}

/// Bitmask constants for [CreatureTag].
class CreatureTagMask {
  const CreatureTagMask._();

  static const int humanoid = 1 << 0;
  static const int demon = 1 << 1;
  static const int flying = 1 << 2;
  static const int undead = 1 << 3;

  static int forTag(CreatureTag tag) {
    switch (tag) {
      case CreatureTag.humanoid:
        return humanoid;
      case CreatureTag.demon:
        return demon;
      case CreatureTag.flying:
        return flying;
      case CreatureTag.undead:
        return undead;
    }
  }
}



===== FILE: lib/core/combat/damage.dart =====
import '../ecs/entity_id.dart';
import '../enemies/enemy_id.dart';
import '../events/game_event.dart';
import '../projectiles/projectile_id.dart';
import '../weapons/weapon_proc.dart';
import 'damage_type.dart';

/// Represents a request to apply damage to an entity.
///
/// This structure captures the target, the amount of damage, and comprehensive
/// metadata about the source of the damage (entity, enemy type, projectile)
/// to be used for combat logic, death events, and statistics.
class DamageRequest {
  const DamageRequest({
    required this.target,
    required this.amount100,
    this.critChanceBp = 0,
    this.damageType = DamageType.physical,
    this.procs = const <WeaponProc>[],
    this.source,
    this.sourceKind = DeathSourceKind.unknown,
    this.sourceEnemyId,
    this.sourceProjectileId,
  });

  /// The entity receiving the damage.
  final EntityId target;

  /// The amount of health points to deduct.
  ///
  /// Fixed-point: 100 = 1.0
  final int amount100;

  /// Critical strike chance in basis points (100 = 1%).
  final int critChanceBp;

  /// Category used for resistance/vulnerability lookup.
  final DamageType damageType;

  /// Potential on-hit procs to roll at application time.
  final List<WeaponProc> procs;

  /// The optional entity responsible for dealing the damage (e.g. the shooter).
  final EntityId? source;

  /// Categorization of the damage source for death messages or analytics.
  final DeathSourceKind sourceKind;

  /// If the dissolved source was an enemy, its static ID.
  final EnemyId? sourceEnemyId;

  /// If the damage came from a projectile, its static ID.
  final ProjectileId? sourceProjectileId;
}


===== FILE: lib/core/combat/damage_type.dart =====
/// High-level damage categories for resistance/vulnerability rules.
enum DamageType {
  physical,
  fire,
  ice,
  water,
  thunder,
  acid,
  dark,
  bleed,
  earth,
  holy,
}


===== FILE: lib/core/combat/faction.dart =====
/// Defines the side an entity belongs to in combat.
///
/// Factions determine friend-or-foe relationships for targeting and collision.
enum Faction {
  /// The player and their allies/summons.
  player,

  /// Hostile entities that strike the player.
  enemy
}



===== FILE: lib/core/combat/hit_payload.dart =====
import '../abilities/ability_def.dart' show AbilityKey;
import '../ecs/entity_id.dart';
import '../weapons/weapon_id.dart';
import '../weapons/weapon_proc.dart';
import 'damage_type.dart';

/// Resolved payload for a damaging action.
///
/// This is the "Frozen Snapshot" of an attack, constructed by [HitPayloadBuilder].
/// It carries all necessary data for the consumer (Projectile/Melee System) to
/// execute the hit.
///
/// **Design Pillars:**
/// *   **Integer Determinism**: [damage100] is in fixed-point (100 = 1.0).
/// *   **Explicit Type**: [damageType] is fully resolved.
/// *   **Potential Procs**: [procs] list candidate effects (rng roll happens at hit time).
class HitPayload {
  const HitPayload({
    required this.damage100,
    required this.critChanceBp,
    required this.damageType,
    required this.procs,
    required this.sourceId,
    this.abilityId,
    this.weaponId,
  });

  /// Final calculated damage in fixed-point units (100 = 1.0 visual damage).
  ///
  /// Includes base ability damage + weapon scaling + any intent-time modifiers.
  final int damage100;

  /// Critical strike chance in basis points (100 = 1%).
  final int critChanceBp;

  /// The elemental type of the damage (resolved from Ability vs Weapon priority).
  final DamageType damageType;

  /// List of potential on-hit effects contributed by the weapon/ability.
  ///
  /// The consumer is responsible for rolling the chance (bp) to apply these.
  final List<WeaponProc> procs;

  /// The entity that originated this hit (Player/Enemy).
  final EntityId sourceId;

  // Debugging / Logging
  final AbilityKey? abilityId;
  final WeaponId? weaponId;
}


===== FILE: lib/core/combat/hit_payload_builder.dart =====
import '../weapons/weapon_proc.dart';
import '../stats/gear_stat_bonuses.dart';
import '../abilities/ability_def.dart';
import '../ecs/entity_id.dart';
import 'damage_type.dart';
import 'hit_payload.dart';

/// Canonical builder for [HitPayload].
///
/// Encapsulates the logic for combining an [AbilityDef] (Base) with a
/// set of Modifiers (Stats/Procs) to produce a deterministic damage snapshot.
///
/// **Usage:**
/// *   **Producers** (Intent Systems): Call `build` to freeze the payload into the intent.
/// *   **UI** (Tooltip/Preview): Call `build` to show predicted damage.
class HitPayloadBuilder {
  static HitPayload build({
    required AbilityDef ability,
    required EntityId source,
    // Modifiers (extracted from WeaponDef or ProjectileItemDef or Buffs)
    GearStatBonuses? weaponStats,
    int globalPowerBonusBp = 0,
    int globalCritChanceBonusBp = 0,
    DamageType? weaponDamageType,
    List<WeaponProc> weaponProcs = const [],
    List<WeaponProc> buffProcs = const [],
    List<WeaponProc> passiveProcs = const [],
  }) {
    // 1. Start with Ability Base
    int finalDamage100 = ability.baseDamage; // Fixed-point (e.g. 1500 = 15.0)
    DamageType finalDamageType = ability.baseDamageType;
    int finalCritChanceBp = globalCritChanceBonusBp;
    final List<WeaponProc> finalProcs = [];

    // 2. Apply global offensive modifiers.
    if (globalPowerBonusBp != 0) {
      finalDamage100 = (finalDamage100 * (10000 + globalPowerBonusBp)) ~/ 10000;
      if (finalDamage100 < 0) finalDamage100 = 0;
    }

    // 3. Apply payload-source weapon modifiers.
    if (weaponStats != null) {
      // A. Power Scaling (Integer Math)
      // Math: damage = base * (1 + bonusBp/10000)
      // Impl: (base * (10000 + bonusBp)) ~/ 10000
      final bonusBp = weaponStats.powerBonusBp;
      // e.g. 1500 * 12000 ~/ 10000 = 1800
      finalDamage100 = (finalDamage100 * (10000 + bonusBp)) ~/ 10000;
      if (finalDamage100 < 0) finalDamage100 = 0;

      // B. Crit chance is additive, with later cap at payload level.
      finalCritChanceBp += weaponStats.critChanceBonusBp;
    }

    if (weaponDamageType != null) {
      // C. Damage Type Override
      // Rule: Weapon overrides Physical ability. Elemental ability (Fire/Ice) keeps its element.
      if (finalDamageType == DamageType.physical) {
        finalDamageType = weaponDamageType;
      }
    }

    // D. Procs (deterministic merge + dedupe)
    // Order is canonical: ability -> item -> buffs -> passives.
    final Set<int> seen = <int>{};
    void addProcs(List<WeaponProc> procs) {
      for (final proc in procs) {
        final key = (proc.hook.index << 16) | proc.statusProfileId.index;
        if (!seen.add(key)) continue;
        finalProcs.add(proc);
      }
    }

    if (ability.procs.isNotEmpty) {
      addProcs(ability.procs);
    }
    if (weaponProcs.isNotEmpty) {
      addProcs(weaponProcs);
    }
    if (buffProcs.isNotEmpty) {
      addProcs(buffProcs);
    }
    if (passiveProcs.isNotEmpty) {
      addProcs(passiveProcs);
    }

    if (finalCritChanceBp < 0) finalCritChanceBp = 0;
    if (finalCritChanceBp > 10000) finalCritChanceBp = 10000;

    return HitPayload(
      damage100: finalDamage100,
      critChanceBp: finalCritChanceBp,
      damageType: finalDamageType,
      procs: finalProcs,
      sourceId: source,
      abilityId: ability.id,
    );
  }
}


===== FILE: lib/core/combat/middleware/parry_middleware.dart =====
import '../../abilities/ability_catalog.dart';
import '../../abilities/ability_def.dart';
import '../../ecs/stores/damage_queue_store.dart';
import '../../ecs/systems/damage_middleware_system.dart';
import '../../ecs/world.dart';
import '../../events/game_event.dart';
import '../../util/fixed_math.dart';

/// Mitigates incoming hits while a guard-like ability is active and can grant a
/// one-shot riposte buff when authored to do so.
///
/// This is used by multiple abilities (e.g. sword parry, shield block) to keep
/// defense rules centralized and deterministic.
class ParryMiddleware implements DamageMiddleware {
  static const int defaultRiposteBonusBp = 10000;
  static const int defaultRiposteLifetimeTicks = 60;

  ParryMiddleware({
    required Set<AbilityKey> abilityIds,
    this.abilityResolver = AbilityCatalog.shared,
    this.defaultDamageIgnoredBp = bpScale,
    this.defaultGrantsRiposte = true,
    this.riposteBonusBp = defaultRiposteBonusBp,
    this.riposteLifetimeTicks = defaultRiposteLifetimeTicks,
  }) : _abilityIds = abilityIds,
       assert(
         defaultDamageIgnoredBp >= 0 && defaultDamageIgnoredBp <= bpScale,
         'defaultDamageIgnoredBp must be in range [0, $bpScale].',
       );

  final Set<AbilityKey> _abilityIds;
  final AbilityResolver abilityResolver;
  final int defaultDamageIgnoredBp;
  final bool defaultGrantsRiposte;
  final int riposteBonusBp;
  final int riposteLifetimeTicks;

  @override
  void apply(
    EcsWorld world,
    DamageQueueStore queue,
    int index,
    int currentTick,
  ) {
    final target = queue.target[index];

    if (world.deathState.has(target)) return;
    final ai = world.activeAbility.tryIndexOf(target);
    if (ai == null) return;
    final activeAbilityId = world.activeAbility.abilityId[ai];
    if (activeAbilityId == null || !_abilityIds.contains(activeAbilityId)) {
      return;
    }

    if (world.activeAbility.phase[ai] != AbilityPhase.active) return;

    // "Hit" only: do not block tick-based damage that comes from already-applied statuses.
    if (queue.sourceKind[index] == DeathSourceKind.statusEffect) return;

    final startTick = world.activeAbility.startTick[ai];

    final elapsed = currentTick - startTick;
    final windup = world.activeAbility.windupTicks[ai];
    final activeElapsed = elapsed - windup;
    if (activeElapsed < 0) return;

    final damageIgnoredBp = _resolveDamageIgnoredBp(activeAbilityId);
    var mitigatedHit = false;
    if (damageIgnoredBp >= bpScale) {
      queue.flags[index] |= DamageQueueFlags.canceled;
      mitigatedHit = true;
    } else if (damageIgnoredBp > 0) {
      final reducedAmount = applyBp(queue.amount100[index], -damageIgnoredBp);
      if (reducedAmount <= 0) {
        queue.flags[index] |= DamageQueueFlags.canceled;
      } else {
        queue.amount100[index] = reducedAmount;
      }
      mitigatedHit = true;
    }
    if (!mitigatedHit) {
      return;
    }

    if (!_shouldGrantRiposte(activeAbilityId)) {
      return;
    }

    // Grant riposte only once per activation (first mitigated hit),
    // while still mitigating subsequent hits during the same activation.
    final consumeIndex = world.parryConsume.indexOfOrAdd(target);
    if (world.parryConsume.consumedStartTick[consumeIndex] == startTick) {
      return;
    }
    world.parryConsume.consumedStartTick[consumeIndex] = startTick;

    // Grant a one-shot bonus that is consumed on the next landed melee hit.
    world.riposte.grant(
      target,
      expiresAtTick: currentTick + riposteLifetimeTicks,
      bonusBp: riposteBonusBp,
    );
  }

  int _resolveDamageIgnoredBp(AbilityKey abilityId) {
    final ability = abilityResolver.resolve(abilityId);
    if (ability == null) return defaultDamageIgnoredBp;
    final ignoredBp = ability.damageIgnoredBp;
    if (ignoredBp <= 0) return 0;
    if (ignoredBp >= bpScale) return bpScale;
    return ignoredBp;
  }

  bool _shouldGrantRiposte(AbilityKey abilityId) {
    final ability = abilityResolver.resolve(abilityId);
    if (ability == null) return defaultGrantsRiposte;
    return ability.grantsRiposteOnGuardedHit;
  }
}


===== FILE: lib/core/combat/status/status.dart =====
import '../../ecs/entity_id.dart';
import '../damage_type.dart';

/// Runtime status effect categories.
enum StatusEffectType {
  dot,
  slow,
  stun,
  haste,
  vulnerable,
  weaken,
  drench,
  silence,
  resourceOverTime,
}

/// Resources that can be restored through status effects.
enum StatusResourceType { health, mana, stamina }

/// Stable identifiers for status application profiles.
enum StatusProfileId {
  none,
  slowOnHit,
  burnOnHit,
  acidOnHit,
  weakenOnHit,
  drenchOnHit,
  silenceOnHit,
  meleeBleed,
  stunOnHit,
  speedBoost,
  restoreHealth,
  restoreMana,
  restoreStamina,
}

/// A single status application inside a profile.
class StatusApplication {
  const StatusApplication({
    required this.type,
    required this.magnitude,
    required this.durationSeconds,
    this.periodSeconds = 1.0,
    this.scaleByDamageType = false,
    this.dotDamageType,
    this.resourceType,
    this.applyOnApply = false,
  }) : assert(
         type != StatusEffectType.dot || dotDamageType != null,
         'dotDamageType is required when type is StatusEffectType.dot.',
       ),
       assert(
         type != StatusEffectType.resourceOverTime || resourceType != null,
         'resourceType is required when type is StatusEffectType.resourceOverTime.',
       ),
       assert(
         periodSeconds > 0,
         'periodSeconds must be > 0 for periodic status effects.',
       ),
       assert(durationSeconds >= 0, 'durationSeconds cannot be negative.');

  final StatusEffectType type;

  /// Effect strength:
  /// - Slow/Haste: basis points (100 = 1%)
  /// - DoT: damage per second in fixed-point (100 = 1.0)
  /// - ResourceOverTime: basis points restored per pulse (`100 = 1%` of max).
  final int magnitude;

  /// Total duration (seconds).
  final double durationSeconds;

  /// Tick period for DoT effects (seconds). Ignored for non-DoTs.
  final double periodSeconds;

  /// Whether to scale magnitude by damage resistance/vulnerability.
  final bool scaleByDamageType;

  /// Damage type dealt by [StatusEffectType.dot]. Ignored for non-DoTs.
  final DamageType? dotDamageType;

  /// Resource restored by [StatusEffectType.resourceOverTime].
  final StatusResourceType? resourceType;

  /// Applies one pulse immediately when the status is queued/applied.
  final bool applyOnApply;

  StatusApplication copyWith({
    StatusEffectType? type,
    int? magnitude,
    double? durationSeconds,
    double? periodSeconds,
    bool? scaleByDamageType,
    DamageType? dotDamageType,
    StatusResourceType? resourceType,
    bool? applyOnApply,
  }) {
    return StatusApplication(
      type: type ?? this.type,
      magnitude: magnitude ?? this.magnitude,
      durationSeconds: durationSeconds ?? this.durationSeconds,
      periodSeconds: periodSeconds ?? this.periodSeconds,
      scaleByDamageType: scaleByDamageType ?? this.scaleByDamageType,
      dotDamageType: dotDamageType ?? this.dotDamageType,
      resourceType: resourceType ?? this.resourceType,
      applyOnApply: applyOnApply ?? this.applyOnApply,
    );
  }
}

/// Reusable baseline status applications with optional tuning overrides.
class StatusApplicationPreset {
  const StatusApplicationPreset(this._baseline);

  final StatusApplication _baseline;

  StatusApplication get baseline => _baseline;

  StatusApplication build({
    int? magnitude,
    double? durationSeconds,
    double? periodSeconds,
    bool? scaleByDamageType,
    DamageType? dotDamageType,
  }) {
    return _baseline.copyWith(
      magnitude: magnitude,
      durationSeconds: durationSeconds,
      periodSeconds: periodSeconds,
      scaleByDamageType: scaleByDamageType,
      dotDamageType: dotDamageType,
    );
  }
}

/// Shared presets used by [StatusProfileCatalog] to avoid duplicated literals.
class StatusApplicationPresets {
  const StatusApplicationPresets._();

  static const StatusApplicationPreset slowOnHit = StatusApplicationPreset(
    StatusApplication(
      type: StatusEffectType.slow,
      magnitude: 2500, // 25%
      durationSeconds: 3.0,
      scaleByDamageType: true,
    ),
  );

  static const StatusApplicationPreset onHitDot = StatusApplicationPreset(
    StatusApplication(
      type: StatusEffectType.dot,
      magnitude: 500, // 5.0 DPS
      durationSeconds: 5.0,
      scaleByDamageType: true,
      dotDamageType: DamageType.fire,
    ),
  );

  static const StatusApplicationPreset vulnerableOnHit =
      StatusApplicationPreset(
        StatusApplication(
          type: StatusEffectType.vulnerable,
          magnitude: 5000, // +50% incoming damage.
          durationSeconds: 5.0,
          scaleByDamageType: false,
        ),
      );

  static const StatusApplicationPreset weakenOnHit = StatusApplicationPreset(
    StatusApplication(
      type: StatusEffectType.weaken,
      magnitude: 3500, // -35% outgoing damage.
      durationSeconds: 5.0,
      scaleByDamageType: false,
    ),
  );

  static const StatusApplicationPreset drenchOnHit = StatusApplicationPreset(
    StatusApplication(
      type: StatusEffectType.drench,
      magnitude: 5000, // -50% attack/cast speed.
      durationSeconds: 5.0,
      scaleByDamageType: false,
    ),
  );

  static const StatusApplicationPreset silenceOnHit = StatusApplicationPreset(
    StatusApplication(
      type: StatusEffectType.silence,
      magnitude: 100, // placeholder (silence uses only duration ticks)
      durationSeconds: 3.0,
      scaleByDamageType: false,
    ),
  );

  static const StatusApplicationPreset stunOnHit = StatusApplicationPreset(
    StatusApplication(
      type: StatusEffectType.stun,
      magnitude: 100, // placeholder (stun uses only duration ticks)
      durationSeconds: 1.0,
      scaleByDamageType: false,
    ),
  );

  static const StatusApplicationPreset speedBoost = StatusApplicationPreset(
    StatusApplication(
      type: StatusEffectType.haste,
      magnitude: 5000, // +50% move speed
      durationSeconds: 5.0,
      scaleByDamageType: false,
    ),
  );

  static const StatusApplicationPreset healthRestore = StatusApplicationPreset(
    StatusApplication(
      type: StatusEffectType.resourceOverTime,
      magnitude: 3500, // 35% max health over full duration
      durationSeconds: 5.0,
      resourceType: StatusResourceType.health,
    ),
  );

  static const StatusApplicationPreset manaRestore = StatusApplicationPreset(
    StatusApplication(
      type: StatusEffectType.resourceOverTime,
      magnitude: 3500, // 35% max mana over full duration
      durationSeconds: 5.0,
      resourceType: StatusResourceType.mana,
    ),
  );

  static const StatusApplicationPreset staminaRestore = StatusApplicationPreset(
    StatusApplication(
      type: StatusEffectType.resourceOverTime,
      magnitude: 3500, // 35% max stamina over full duration
      durationSeconds: 5.0,
      resourceType: StatusResourceType.stamina,
    ),
  );
}

/// A bundle of status applications applied on hit.
class StatusProfile {
  const StatusProfile(this.applications);

  final List<StatusApplication> applications;
}

/// Lookup table for status profiles.
class StatusProfileCatalog {
  const StatusProfileCatalog();

  StatusProfile get(StatusProfileId id) {
    switch (id) {
      case StatusProfileId.none:
        return const StatusProfile(<StatusApplication>[]);
      case StatusProfileId.slowOnHit:
        return StatusProfile(<StatusApplication>[
          StatusApplicationPresets.slowOnHit.baseline,
        ]);
      case StatusProfileId.meleeBleed:
        return StatusProfile(<StatusApplication>[
          StatusApplicationPresets.onHitDot.build(
            magnitude: 300, // 3.0 DPS
            dotDamageType: DamageType.physical,
          ),
        ]);
      case StatusProfileId.burnOnHit:
        return StatusProfile(<StatusApplication>[
          StatusApplicationPresets.onHitDot.build(
            dotDamageType: DamageType.fire,
          ),
        ]);
      case StatusProfileId.acidOnHit:
        return StatusProfile(<StatusApplication>[
          StatusApplicationPresets.vulnerableOnHit.baseline,
        ]);
      case StatusProfileId.weakenOnHit:
        return StatusProfile(<StatusApplication>[
          StatusApplicationPresets.weakenOnHit.baseline,
        ]);
      case StatusProfileId.drenchOnHit:
        return StatusProfile(<StatusApplication>[
          StatusApplicationPresets.drenchOnHit.baseline,
        ]);
      case StatusProfileId.silenceOnHit:
        return StatusProfile(<StatusApplication>[
          StatusApplicationPresets.silenceOnHit.baseline,
        ]);
      case StatusProfileId.stunOnHit:
        return StatusProfile(<StatusApplication>[
          StatusApplicationPresets.stunOnHit.baseline,
        ]);
      case StatusProfileId.speedBoost:
        return StatusProfile(<StatusApplication>[
          StatusApplicationPresets.speedBoost.baseline,
        ]);
      case StatusProfileId.restoreHealth:
        return StatusProfile(<StatusApplication>[
          StatusApplicationPresets.healthRestore.baseline,
        ]);
      case StatusProfileId.restoreMana:
        return StatusProfile(<StatusApplication>[
          StatusApplicationPresets.manaRestore.baseline,
        ]);
      case StatusProfileId.restoreStamina:
        return StatusProfile(<StatusApplication>[
          StatusApplicationPresets.staminaRestore.baseline,
        ]);
    }
  }
}

/// Runtime request for applying a status profile to a target.
class StatusRequest {
  const StatusRequest({
    required this.target,
    required this.profileId,
    this.damageType = DamageType.physical,
  });

  final EntityId target;
  final StatusProfileId profileId;
  final DamageType damageType;
}


===== FILE: lib/core/commands/command.dart =====
import '../abilities/ability_def.dart';

/// Core input command model for the deterministic simulation.
///
/// Commands represent discrete user inputs scheduled for a specific simulation tick.
/// To ensure determinism, the UI must schedule commands in advance (via `GameController.enqueue`),
/// and the Core processes them only when the simulation clock reaches the specified [tick].
sealed class Command {
  const Command({required this.tick});

  /// Simulation tick at which this command must be applied.
  final int tick;
}

/// Player movement input for the given tick.
///
/// `axis` is typically in `[-1, 1]` (left/right), originating from a joystick.
final class MoveAxisCommand extends Command {
  const MoveAxisCommand({required super.tick, required this.axis});

  /// Horizontal movement axis, usually in `[-1, 1]`.
  final double axis;
}

/// One-shot jump press event for the given tick.
final class JumpPressedCommand extends Command {
  const JumpPressedCommand({required super.tick});
}

/// One-shot dash press event for the given tick.
final class DashPressedCommand extends Command {
  const DashPressedCommand({required super.tick});
}

/// One-shot strike press event for the given tick.
final class StrikePressedCommand extends Command {
  const StrikePressedCommand({required super.tick});
}

/// One-shot secondary press event for the given tick.
final class SecondaryPressedCommand extends Command {
  const SecondaryPressedCommand({required super.tick});
}

/// Continuous global aim direction for the given tick.
///
/// The direction should be normalized (or near-normalized). It is expressed in
/// world space and consumed by whichever ability commits this tick.
final class AimDirCommand extends Command {
  const AimDirCommand({required super.tick, required this.x, required this.y});

  final double x;
  final double y;
}

/// Clears any held global aim direction for the given tick.
///
/// This exists so input schedulers that pre-buffer future ticks can overwrite
/// previously-scheduled aim commands when the player releases aim input.
final class ClearAimDirCommand extends Command {
  const ClearAimDirCommand({required super.tick});
}

/// One-shot projectile slot press event for the given tick.
///
/// Preferred over spell/ranged-specific presses when using slot-based input.
final class ProjectilePressedCommand extends Command {
  const ProjectilePressedCommand({required super.tick});
}

/// One-shot spell slot press event for the given tick.
final class SpellPressedCommand extends Command {
  const SpellPressedCommand({required super.tick});
}

/// Hold-state edge for an ability slot at the given tick.
///
/// Core latches slot hold state until another [AbilitySlotHeldCommand] updates
/// it, so input routers should send this on transitions only:
/// - `held: true` when hold starts
/// - `held: false` when hold ends
final class AbilitySlotHeldCommand extends Command {
  const AbilitySlotHeldCommand({
    required super.tick,
    required this.slot,
    required this.held,
  });

  final AbilitySlot slot;
  final bool held;
}


===== FILE: lib/core/contracts/render_anim_set_definition.dart =====
/// Render animation strip metadata shared between Core and Render.
library;

import '../snapshots/enums.dart';
import '../util/vec2.dart';

/// Data-driven animation strip definition (frame size, paths, timing).
class RenderAnimSetDefinition {
  const RenderAnimSetDefinition({
    required this.frameWidth,
    required this.frameHeight,
    required this.sourcesByKey,
    this.rowByKey = const <AnimKey, int>{},
    this.anchorInFramePx,
    this.frameStartByKey = const <AnimKey, int>{},
    this.gridColumnsByKey = const <AnimKey, int>{},
    required this.frameCountsByKey,
    required this.stepTimeSecondsByKey,
  });

  final int frameWidth;
  final int frameHeight;

  /// Asset paths (relative to `assets/images/`) for each animation source.
  ///
  /// A single path can be reused for multiple keys:
  /// - **Strip format**: each key points to a single-row horizontal strip (row 0).
  /// - **Sheet format**: multiple keys point to one multi-row sheet, using
  ///   [rowByKey] to select the row for each [AnimKey].
  final Map<AnimKey, String> sourcesByKey;

  /// Optional 0-based row index per [AnimKey] when using a multi-row sheet.
  ///
  /// If a key is missing, render assumes row 0 (strip compatibility).
  final Map<AnimKey, int> rowByKey;

  /// Optional anchor/pivot location inside a single source frame (in pixels).
  ///
  /// When null, render uses `Anchor.center`.
  ///
  /// This is useful when the authored art is not centered on the logical
  /// collider (e.g. enemies with long weapons/tails). The renderer treats the
  /// Core snapshot position as the world-space position of this anchor.
  final Vec2? anchorInFramePx;

  /// Optional 0-based frame start offset per [AnimKey] for strip reuse.
  ///
  /// Defaults to 0 (start of the strip). Use this when multiple animations
  /// share a single horizontal strip but start at different frame indices.
  final Map<AnimKey, int> frameStartByKey;

  /// Optional sheet column count per [AnimKey] for row-wrapped animations.
  ///
  /// When present for a key, [frameStartByKey] is treated as a start column and
  /// frame sampling wraps to following rows using this column count.
  final Map<AnimKey, int> gridColumnsByKey;

  final Map<AnimKey, int> frameCountsByKey;
  final Map<AnimKey, double> stepTimeSecondsByKey;
}


===== FILE: lib/core/contracts/render_contract.dart =====
/// Defines the virtual resolution and coordinate system constants for the valid
/// gameplay area.
///
/// These values are the "truth" for the simulation and the renderer.
/// The renderer scales this virtual viewport to fit the actual screen.
library;

import 'spatial_contract.dart';

/// The fixed virtual width of the gameplay view in logic units (pixels).
const int virtualWidth = virtualViewportWidth;

/// The fixed virtual height of the gameplay view in logic units (pixels).
const int virtualHeight = virtualViewportHeight;

// -- Gameplay Constants --

/// Length of the ray cast for projectile aiming.
const double projectileAimRayLength = virtualWidth * 0.5;

/// Length of the ray cast for melee aiming.
const double meleeAimRayLength = virtualWidth * 0.20;


===== FILE: lib/core/contracts/spatial_contract.dart =====
/// Defines shared spatial coordinate contract constants.
///
/// This file intentionally contains coordinate-system primitives only.
/// Asset-specific alignment constants stay outside this contract.
library;

/// Fixed virtual viewport width used by gameplay and rendering.
const int virtualViewportWidth = 600;

/// Fixed virtual viewport height used by gameplay and rendering.
const int virtualViewportHeight = 270;

/// Camera center X for the default fixed-resolution runner framing.
const double virtualCameraCenterX = virtualViewportWidth / 2;

/// Camera center Y for the default fixed-resolution runner framing.
const double virtualCameraCenterY = virtualViewportHeight / 2;

/// In world/view coordinates, increasing Y moves downward on screen.
const bool yAxisPointsDown = true;


===== FILE: lib/core/ecs/components/abilities/active_ability_state.dart =====
import 'package:rpg_runner/core/abilities/ability_def.dart';

class ActiveAbilityState {
  AbilityKey? abilityId; // null when idle
  AbilitySlot slot = AbilitySlot.primary;

  AbilityPhase phase = AbilityPhase.idle;
  int phaseTicksRemaining = 0;
  int totalDurationTicks = 0;

  int commitTick = 0; // Tick when the ability committed (costs paid)
  AimSnapshot aim = AimSnapshot.empty;
  
  bool get isIdle => phase == AbilityPhase.idle;
  bool get isBusy => phase != AbilityPhase.idle;

  void reset() {
    abilityId = null;
    slot = AbilitySlot.primary;
    phase = AbilityPhase.idle;
    phaseTicksRemaining = 0;
    totalDurationTicks = 0;
    commitTick = 0;
    aim = AimSnapshot.empty;
  }
}


===== FILE: lib/core/ecs/components/abilities/buffered_input_state.dart =====
import 'package:rpg_runner/core/abilities/ability_def.dart';

class BufferedInputState {
  bool hasValue = false;
  AbilitySlot slot = AbilitySlot.primary;
  int pressedTick = 0;
  AimSnapshot aim = AimSnapshot.empty;

  void set(AbilitySlot s, int tick, AimSnapshot a) {
    hasValue = true;
    slot = s;
    pressedTick = tick;
    aim = a;
  }

  void clear() {
    hasValue = false;
    aim = AimSnapshot.empty;
  }
}


===== FILE: lib/core/ecs/components/death_state.dart =====
class DeathState {
  DeathState({
    required this.phase,
    required this.deathStartTick,
    required this.despawnTick,
    required this.maxFallDespawnTick,
  });

  DeathPhase phase;
  int deathStartTick;
  int despawnTick;
  int maxFallDespawnTick;
}

enum DeathPhase {
  fallingUntilGround,
  deathAnim,
}

class DeathStateComponent {
  final Map<int, DeathState> _data = {};

  bool has(int entity) => _data.containsKey(entity);
  int indexOf(int entity) => entity;
  int? tryIndexOf(int entity) => _data.containsKey(entity) ? entity : null;

  void add(int entity, DeathState state) {
    _data[entity] = state;
  }

  DeathPhase get phase => throw UnimplementedError('Use entity index');
  // This component structure seems to be property-based in the system.
  // Let's look at how other components are used in world.dart or other systems.
}

// Based on the system usage, it expects:
// deathState.phase[di]
// deathState.deathStartTick[di]
// deathState.despawnTick[di]
// deathState.maxFallDespawnTick[di]
// This suggests deathState is a component with multiple arrays or maps.

class DeathStateDef {
  const DeathStateDef({
    required this.phase,
    required this.deathStartTick,
    required this.despawnTick,
    required this.maxFallDespawnTick,
  });

  final DeathPhase phase;
  final int deathStartTick;
  final int despawnTick;
  final int maxFallDespawnTick;
}

===== FILE: lib/core/ecs/entity_factory.dart =====
import '../combat/faction.dart';
import '../enemies/enemy_id.dart';
import '../snapshots/enums.dart';
import '../util/deterministic_rng.dart';
import 'entity_id.dart';
import 'stores/body_store.dart';
import 'stores/collider_aabb_store.dart';
import 'stores/combat/creature_tag_store.dart';
import 'stores/combat/damage_resistance_store.dart';
import 'stores/combat/equipped_loadout_store.dart';
import 'stores/combat/stat_modifier_store.dart';
import 'stores/combat/status_immunity_store.dart';
import 'stores/enemies/enemy_store.dart';
import 'stores/faction_store.dart';
import 'stores/enemies/flying_enemy_steering_store.dart';
import 'stores/enemies/ground_enemy_chase_offset_store.dart';
import 'stores/health_store.dart';
import 'stores/mana_store.dart';
import 'stores/stamina_store.dart';
import 'world.dart';

/// Factory for creating complex entities composed of multiple components.
///
/// This class encapsulates the logic for assembling entities from their constituent
/// components. It ensures that all necessary components are added and initialized
/// correctly for each entity type (e.g., Player, Enemy).
class EntityFactory {
  /// Creates a factory bound to the given [world].
  EntityFactory(this.world);

  /// The [EcsWorld] into which entities will be created.
  final EcsWorld world;

  /// Creates a fully assembled Player entity.
  ///
  /// Adds the following components:
  /// - [TransformStore]: Position and velocity.
  /// - [PlayerInputStore]: Marks this entity as controllable by player input.
  /// - [AnimStateStore]: Stores resolved animation state for rendering.
  /// - [MovementStore]: Handles movement logic and facing direction.
  /// - [JumpStateStore]: Tracks coyote/buffer/air-jump runtime counters.
  /// - [BodyStore]: Physics body properties (mass, friction, etc.).
  /// - [ColliderAabbStore]: Axis-aligned bounding box for collision detection.
  /// - [CollisionStateStore]: Tracks current collision state.
  /// - [CooldownStore]: Manages ability cooldowns.
  /// - [ProjectileIntentStore]: Tracks intent to fire projectile items.
  /// - [CreatureTagStore]: Broad combat classification tags.
  /// - [FactionStore]: Sets the faction to [Faction.player].
  /// - [HealthStore]: Health points and max health.
  /// - [DamageResistanceStore]: Damage modifiers per type.
  /// - [InvulnerabilityStore]: Grants temporary invulnerability after damage.
  /// - [LastDamageStore]: Tracks the last source of damage for UI/effects.
  /// - [StatusImmunityStore]: Status effect immunities.
  /// - [ManaStore]: Mana points and max mana.
  /// - [EquippedLoadoutStore]: Equipped abilities and gear.
  /// - [MeleeIntentStore]: Tracks intent to perform melee strikes.
  /// - [MobilityIntentStore]: Tracks intent to perform mobility actions.
  /// - [StatModifierStore]: Runtime stat modifiers from statuses.
  /// - [StaminaStore]: Stamina points and max stamina.
  ///
  /// The [grounded] parameter sets the initial ground state in the collision store.
  EntityId createPlayer({
    required double posX,
    required double posY,
    required double velX,
    required double velY,
    required Facing facing,
    required bool grounded,
    required BodyDef body,
    required ColliderAabbDef collider,
    required HealthDef health,
    required ManaDef mana,
    required StaminaDef stamina,
    CreatureTagDef tags = const CreatureTagDef(),
    DamageResistanceDef resistance = const DamageResistanceDef(),
    StatusImmunityDef statusImmunity = const StatusImmunityDef(),
    EquippedLoadoutDef equippedLoadout = const EquippedLoadoutDef(),
  }) {
    final id = world.createEntity();
    world.transform.add(id, posX: posX, posY: posY, velX: velX, velY: velY);
    world.playerInput.add(id);
    world.abilityInputBuffer.add(id);
    world.abilityCharge.add(id);
    world.activeAbility.add(id);
    world.animState.add(id);
    world.movement.add(id, facing: facing);
    world.jumpState.add(id);
    world.body.add(id, body);
    world.colliderAabb.add(id, collider);
    world.collision.add(id);
    world.cooldown.add(id);
    world.creatureTag.add(id, tags);
    world.faction.add(id, const FactionDef(faction: Faction.player));
    world.health.add(id, health);
    world.damageResistance.add(id, resistance);
    world.invulnerability.add(id);
    world.lastDamage.add(id);
    world.statusImmunity.add(id, statusImmunity);
    world.mana.add(id, mana);
    world.meleeIntent.add(id);
    world.mobilityIntent.add(id);
    world.projectileIntent.add(id);
    world.selfIntent.add(id);
    world.equippedLoadout.add(id, equippedLoadout);
    world.statModifier.add(id);
    world.stamina.add(id, stamina);
    world.collision.grounded[world.collision.indexOf(id)] = grounded;
    return id;
  }

  /// Creates an Enemy entity based on the provided [enemyId].
  ///
  /// Adds common components for all enemies:
  /// - [TransformStore]: Position and velocity.
  /// - [BodyStore]: Physics properties.
  /// - [ColliderAabbStore]: Collision boounding box.
  /// - [CollisionStateStore]: Collision state tracking.
  /// - [CooldownStore]: Ability cooldowns.
  /// - [ProjectileIntentStore]: Projectile intent.
  /// - [CreatureTagStore]: Broad combat classification tags.
  /// - [FactionStore]: Sets faction to [Faction.enemy].
  /// - [HealthStore], [ManaStore], [StaminaStore]: Vital stats.
  /// - [LastDamageStore]: Tracks most recent applied damage metadata.
  /// - [MeleeIntentStore]: Melee strike intent.
  /// - [DamageResistanceStore]: Damage modifiers per type.
  /// - [StatusImmunityStore]: Status effect immunities.
  /// - [StatModifierStore]: Runtime stat modifiers from statuses.
  /// - [EnemyStore]: Identifies the entity as an enemy and stores its type.
  /// - [AnimStateStore]: Animation state computed by [AnimSystem].
  /// - [MeleeEngagementStore]: Engagement state for melee AI.
  /// - [NavIntentStore]: Navigation output for ground enemies.
  /// - [EngagementIntentStore]: Engagement output for melee enemies.
  ///
  /// Adds specific components based on [enemyId]:
  /// - [EnemyId.unocoDemon]: Adds [FlyingEnemySteeringStore] for air movement.
  /// - [EnemyId.grojib]: Adds [SurfaceNavStateStore], [GroundEnemyChaseOffsetStore],
  ///   [NavIntentStore], and [EngagementIntentStore] for ground navigation/engagement.
  EntityId createEnemy({
    required EnemyId enemyId,
    required double posX,
    required double posY,
    required double velX,
    required double velY,
    required Facing facing,
    required BodyDef body,
    required ColliderAabbDef collider,
    required HealthDef health,
    required ManaDef mana,
    required StaminaDef stamina,
    CreatureTagDef tags = const CreatureTagDef(),
    DamageResistanceDef resistance = const DamageResistanceDef(),
    StatusImmunityDef statusImmunity = const StatusImmunityDef(),
  }) {
    final id = world.createEntity();
    world.transform.add(id, posX: posX, posY: posY, velX: velX, velY: velY);
    world.body.add(id, body);
    world.colliderAabb.add(id, collider);
    world.collision.add(id);
    world.cooldown.add(id);
    world.projectileIntent.add(id);
    world.creatureTag.add(id, tags);
    world.faction.add(id, const FactionDef(faction: Faction.enemy));
    world.health.add(id, health);
    world.lastDamage.add(id);
    world.damageResistance.add(id, resistance);
    world.mana.add(id, mana);
    world.meleeIntent.add(id);
    world.meleeEngagement.add(id);
    world.statModifier.add(id);
    world.stamina.add(id, stamina);
    world.enemy.add(id, EnemyDef(enemyId: enemyId, facing: facing));
    world.activeAbility.add(id);
    world.abilityCharge.add(id);
    world.animState.add(id);
    world.statusImmunity.add(id, statusImmunity);
    if (enemyId == EnemyId.unocoDemon) {
      world.flyingEnemySteering.add(
        id,
        FlyingEnemySteeringDef(rngState: seedFrom(world.seed, id)),
      );
    }
    if (enemyId == EnemyId.grojib) {
      world.surfaceNav.add(id);
      world.groundEnemyChaseOffset.add(
        id,
        GroundEnemyChaseOffsetDef(rngState: seedFrom(world.seed, id)),
      );
      world.navIntent.add(id);
      world.engagementIntent.add(id);
    }
    return id;
  }
}


===== FILE: lib/core/ecs/entity_id.dart =====
/// Opaque identifier for entities in the Core simulation.
///
/// An [EntityId] is a simple integer that uniquely identifies an entity within
/// the [EcsWorld]. It serves as a key to access components associated with
/// the entity across different [SparseSet] stores.
///
/// Entity IDs are managed by the [EcsWorld]. When an entity is destroyed, its
/// ID is recycled and may be assigned to a new entity in the future to keep the
/// range of active IDs compact, which benefits the performance of sparse sets.
typedef EntityId = int;


===== FILE: lib/core/ecs/hit/aabb_hit_utils.dart =====
import '../../combat/faction.dart';
import '../entity_id.dart';
import '../world.dart';

/// Shared helpers for hit resolution math + filtering.
///
/// IMPORTANT:
/// - Keep these helpers allocation-free and deterministic.
/// - Systems still own iteration/selection rules (e.g. "first hit wins") until
///   Hit Resolution Module is fully unified.

/// Checks if two factions are allied.
///
/// Used for friendly-fire logic (skipping hits on allies).
bool areAllies(Faction a, Faction b) => a == b;

/// Per-tick cache of "damageable collider targets" to reduce repeated sparse
/// lookups in hot loops.
///
/// A target is included if it has:
/// - `HealthStore` (source list)
/// - `FactionStore` (for friendly-fire filtering)
/// - `TransformStore` + `ColliderAabbStore` (for overlap tests)
///
/// Determinism: preserves `HealthStore.denseEntities` iteration order.
class DamageableTargetCache {
  /// The [EntityId] of the target.
  final List<EntityId> entities = <EntityId>[];
  /// The [Faction] of the target.
  final List<Faction> factions = <Faction>[];

  // World-space collider center and half extents (Parallel arrays).
  final List<double> centerX = <double>[];
  final List<double> centerY = <double>[];
  final List<double> halfX = <double>[];
  final List<double> halfY = <double>[];

  int get length => entities.length;
  bool get isEmpty => entities.isEmpty;

  /// Rebuilds the cache by iterating directly over all entities with Health.
  ///
  /// This is an O(N) operation where N is the number of entities with Health,
  /// but it avoids O(log N) or hashing costs during the hot hit-check loop.
  void rebuild(EcsWorld world) {
    // 1. Reset state.
    entities.clear();
    factions.clear();
    centerX.clear();
    centerY.clear();
    halfX.clear();
    halfY.clear();

    final health = world.health;
    if (health.denseEntities.isEmpty) return;

    // 2. Iterate source (HealthStore) to find potential targets.
    for (var i = 0; i < health.denseEntities.length; i += 1) {
      final e = health.denseEntities[i];

      if (world.deathState.has(e)) continue;

      // 3. Filter: Must have Faction, Transform, and Collider.
      // (Using tryIndexOf avoids exception overhead for missing components)
      final fi = world.faction.tryIndexOf(e);
      if (fi == null) continue;
      final ti = world.transform.tryIndexOf(e);
      if (ti == null) continue;
      final aabbi = world.colliderAabb.tryIndexOf(e);
      if (aabbi == null) continue;

      // 4. Pre-calculate world-space AABB to save work during hit tests.
      // (Transform Pos + Collider Offset)
      final cx = world.transform.posX[ti] + world.colliderAabb.offsetX[aabbi];
      final cy = world.transform.posY[ti] + world.colliderAabb.offsetY[aabbi];

      // 5. Commit valid target to cache.
      entities.add(e);
      factions.add(world.faction.faction[fi]);
      centerX.add(cx);
      centerY.add(cy);
      halfX.add(world.colliderAabb.halfX[aabbi]);
      halfY.add(world.colliderAabb.halfY[aabbi]);
    }
  }
}

/// Checks strict overlap between two AABBs defined by Min/Max coordinates.
///
/// Returns true if they overlap. Touching edges does NOT count as overlap.
bool aabbOverlapsMinMax({
  required double aMinX,
  required double aMaxX,
  required double aMinY,
  required double aMaxY,
  required double bMinX,
  required double bMaxX,
  required double bMinY,
  required double bMaxY,
}) {
  // Classic Separating Axis Theorem (SAT):
  // Overlap exists if and only if ranges overlap on BOTH X and Y axes.
  // (Start of A < End of B) AND (End of A > Start of B)
  return aMinX < bMaxX && aMaxX > bMinX && aMinY < bMaxY && aMaxY > bMinY;
}

/// Checks strict overlap between two AABBs defined by Center/Half-Extents.
bool aabbOverlapsCenters({
  required double aCenterX,
  required double aCenterY,
  required double aHalfX,
  required double aHalfY,
  required double bCenterX,
  required double bCenterY,
  required double bHalfX,
  required double bHalfY,
}) {
  return aabbOverlapsMinMax(
    aMinX: aCenterX - aHalfX,
    aMaxX: aCenterX + aHalfX,
    aMinY: aCenterY - aHalfY,
    aMaxY: aCenterY + aHalfY,
    bMinX: bCenterX - bHalfX,
    bMaxX: bCenterX + bHalfX,
    bMinY: bCenterY - bHalfY,
    bMaxY: bCenterY + bHalfY,
  );
}

/// Helper that resolves entity indices to world components and checks overlap.
bool aabbOverlapsWorldColliders(
  EcsWorld world, {
  required int aTransformIndex,
  required int aAabbIndex,
  required int bTransformIndex,
  required int bAabbIndex,
}) {
  // 1. Resolve world-space AABB for Entity A.
  final aCenterX = world.transform.posX[aTransformIndex] +
      world.colliderAabb.offsetX[aAabbIndex];
  final aCenterY = world.transform.posY[aTransformIndex] +
      world.colliderAabb.offsetY[aAabbIndex];
  final aHalfX = world.colliderAabb.halfX[aAabbIndex];
  final aHalfY = world.colliderAabb.halfY[aAabbIndex];

  // 2. Resolve world-space AABB for Entity B.
  final bCenterX = world.transform.posX[bTransformIndex] +
      world.colliderAabb.offsetX[bAabbIndex];
  final bCenterY = world.transform.posY[bTransformIndex] +
      world.colliderAabb.offsetY[bAabbIndex];
  final bHalfX = world.colliderAabb.halfX[bAabbIndex];
  final bHalfY = world.colliderAabb.halfY[bAabbIndex];

  // 3. Check overlap.
  return aabbOverlapsCenters(
    aCenterX: aCenterX,
    aCenterY: aCenterY,
    aHalfX: aHalfX,
    aHalfY: aHalfY,
    bCenterX: bCenterX,
    bCenterY: bCenterY,
    bHalfX: bHalfX,
    bHalfY: bHalfY,
  );
}


===== FILE: lib/core/ecs/hit/capsule_hit_utils.dart =====
import 'dart:math' as math;

const double _segmentEps = 1e-12;

/// Checks if a capsule (line segment + radius) intersects an Axis-Aligned Bounding Box (AABB).
///
/// The capsule is defined by start point ([ax], [ay]), end point ([bx], [by]),
/// and [radius]. The AABB is defined by min/max coordinates.
///
/// This works by padding the AABB by the capsule radius and performing a segment-to-box
/// intersection test.
bool capsuleIntersectsAabb({
  required double ax,
  required double ay,
  required double bx,
  required double by,
  required double radius,
  required double minX,
  required double minY,
  required double maxX,
  required double maxY,
}) {
  final r = radius < 0 ? 0.0 : radius;
  // Expanding the AABB by the radius allows us to treat the capsule as a simple
  // line segment against the larger box.
  return _segmentIntersectsAabb(
    ax: ax,
    ay: ay,
    bx: bx,
    by: by,
    minX: minX - r,
    minY: minY - r,
    maxX: maxX + r,
    maxY: maxY + r,
  );
}

/// Core segment-AABB intersection test using slab method logic.
///
/// Checks if the line segment from A to B intersects the given AABB.
bool _segmentIntersectsAabb({
  required double ax,
  required double ay,
  required double bx,
  required double by,
  required double minX,
  required double minY,
  required double maxX,
  required double maxY,
}) {
  final dx = bx - ax;
  final dy = by - ay;
  var t0 = 0.0;
  var t1 = 1.0;

  // --- X-axis slab test ---
  if (dx.abs() < _segmentEps) {
    // Segment is parallel to Y-axis. If X is outside, no intersection.
    if (ax < minX || ax > maxX) return false;
  } else {
    // Compute intersection times (t) with X-planes.
    final inv = 1.0 / dx;
    var tNear = (minX - ax) * inv;
    var tFar = (maxX - ax) * inv;
    if (tNear > tFar) {
      final tmp = tNear;
      tNear = tFar;
      tFar = tmp;
    }
    // Narrow the valid segment range [t0, t1].
    t0 = math.max(t0, tNear);
    t1 = math.min(t1, tFar);
    // If range becomes invalid, segment missed.
    if (t0 > t1) return false;
  }

  // --- Y-axis slab test ---
  if (dy.abs() < _segmentEps) {
    // Segment is parallel to X-axis. If Y is outside, no intersection.
    if (ay < minY || ay > maxY) return false;
  } else {
    // Compute intersection times (t) with Y-planes.
    final inv = 1.0 / dy;
    var tNear = (minY - ay) * inv;
    var tFar = (maxY - ay) * inv;
    if (tNear > tFar) {
      final tmp = tNear;
      tNear = tFar;
      tFar = tmp;
    }
    // Further narrow the valid segment range.
    t0 = math.max(t0, tNear);
    t1 = math.min(t1, tFar);
    // If range becomes invalid, segment missed.
    if (t0 > t1) return false;
  }

  // Intersection confirmed if we survived both slab tests.
  return true;
}


===== FILE: lib/core/ecs/hit/hit_resolver.dart =====
import 'dart:math' as math;

import '../../combat/faction.dart';
import '../entity_id.dart';
import '../spatial/broadphase_grid.dart';
import 'aabb_hit_utils.dart';
import 'capsule_hit_utils.dart';

/// Shared narrowphase + deterministic hit candidate ordering.
///
/// Responsibilities:
/// - broadphase query
/// - filtering (owner exclusion + friendly-fire)
/// - AABB overlap test
/// - deterministic ordering (EntityId ascending)
///
/// Non-responsibilities:
/// - world mutation (damage, despawns, HitOnce marking)
class HitResolver {
  // Temporary list to hold candidates from the broadphase before processing.
  final List<int> _candidates = <int>[];

  /// Collects ALL entities intersecting the given AABB into [outTargetIndices].
  ///
  /// The results are filtered strictly (overlaps only) and loosely (owner/friendly fire),
  /// and are guaranteed to be sorted by [EntityId].
  void collectOrderedOverlapsCenters({
    required BroadphaseGrid broadphase,
    required double centerX,
    required double centerY,
    required double halfX,
    required double halfY,
    required EntityId owner,
    required Faction sourceFaction,
    required List<int> outTargetIndices,
  }) {
    outTargetIndices.clear();

    // 1. Broadphase Query + deterministic sort.
    final hasCandidates = _prepareCandidates(
      broadphase: broadphase,
      minX: centerX - halfX,
      minY: centerY - halfY,
      maxX: centerX + halfX,
      maxY: centerY + halfY,
    );
    if (!hasCandidates) return;

    // 2. Narrowphase Check on processed candidates.
    for (var i = 0; i < _candidates.length; i += 1) {
      final targetIndex = _candidates[i];

      // 2a. Filter logic (Owner + Faction).
      if (!_isValidTarget(targetIndex, broadphase, owner, sourceFaction)) {
        continue;
      }

      // 2b. Exact AABB overlap test.
      if (!aabbOverlapsCenters(
        aCenterX: centerX,
        aCenterY: centerY,
        aHalfX: halfX,
        aHalfY: halfY,
        bCenterX: broadphase.targets.centerX[targetIndex],
        bCenterY: broadphase.targets.centerY[targetIndex],
        bHalfX: broadphase.targets.halfX[targetIndex],
        bHalfY: broadphase.targets.halfY[targetIndex],
      )) {
        continue;
      }

      // 3. Collect valid hit.
      outTargetIndices.add(targetIndex);
    }
  }

  /// Returns the FIRST entity intersecting the given AABB (lowest EntityId).
  int? firstOrderedOverlapCenters({
    required BroadphaseGrid broadphase,
    required double centerX,
    required double centerY,
    required double halfX,
    required double halfY,
    required EntityId owner,
    required Faction sourceFaction,
  }) {
    // 1. Broadphase Query.
    final hasCandidates = _prepareCandidates(
      broadphase: broadphase,
      minX: centerX - halfX,
      minY: centerY - halfY,
      maxX: centerX + halfX,
      maxY: centerY + halfY,
    );
    if (!hasCandidates) return null;

    // 2. Determine the first valid hit.
    for (var i = 0; i < _candidates.length; i += 1) {
      final targetIndex = _candidates[i];

      // 2a. Filter logic.
      if (!_isValidTarget(targetIndex, broadphase, owner, sourceFaction)) {
        continue;
      }

      // 2b. Exact AABB overlap test.
      if (!aabbOverlapsCenters(
        aCenterX: centerX,
        aCenterY: centerY,
        aHalfX: halfX,
        aHalfY: halfY,
        bCenterX: broadphase.targets.centerX[targetIndex],
        bCenterY: broadphase.targets.centerY[targetIndex],
        bHalfX: broadphase.targets.halfX[targetIndex],
        bHalfY: broadphase.targets.halfY[targetIndex],
      )) {
        continue;
      }

      // 3. Return immediately on first hit (Sorted by EntityId).
      return targetIndex;
    }

    return null;
  }

  /// Collects ALL entities intersecting the given capsule into [outTargetIndices].
  void collectOrderedOverlapsCapsule({
    required BroadphaseGrid broadphase,
    required double ax,
    required double ay,
    required double bx,
    required double by,
    required double radius,
    required EntityId owner,
    required Faction sourceFaction,
    required List<int> outTargetIndices,
  }) {
    outTargetIndices.clear();

    // 1. Broadphase Query using capsule AABB bounds.
    final hasCandidates = _prepareCandidates(
      broadphase: broadphase,
      minX: math.min(ax, bx) - radius,
      minY: math.min(ay, by) - radius,
      maxX: math.max(ax, bx) + radius,
      maxY: math.max(ay, by) + radius,
    );
    if (!hasCandidates) return;

    // 2. Narrowphase Check.
    for (var i = 0; i < _candidates.length; i += 1) {
      final targetIndex = _candidates[i];

      // 2a. Filter logic.
      if (!_isValidTarget(targetIndex, broadphase, owner, sourceFaction)) {
        continue;
      }

      final targetCenterX = broadphase.targets.centerX[targetIndex];
      final targetCenterY = broadphase.targets.centerY[targetIndex];
      final targetHalfX = broadphase.targets.halfX[targetIndex];
      final targetHalfY = broadphase.targets.halfY[targetIndex];

      // 2b. Capsule vs AABB intersection test.
      if (!capsuleIntersectsAabb(
        ax: ax,
        ay: ay,
        bx: bx,
        by: by,
        radius: radius,
        minX: targetCenterX - targetHalfX,
        minY: targetCenterY - targetHalfY,
        maxX: targetCenterX + targetHalfX,
        maxY: targetCenterY + targetHalfY,
      )) {
        continue;
      }

      // 3. Collect valid hit.
      outTargetIndices.add(targetIndex);
    }
  }

  /// Returns the FIRST entity intersecting the given capsule (lowest EntityId).
  int? firstOrderedOverlapCapsule({
    required BroadphaseGrid broadphase,
    required double ax,
    required double ay,
    required double bx,
    required double by,
    required double radius,
    required EntityId owner,
    required Faction sourceFaction,
  }) {
    // 1. Broadphase Query.
    final hasCandidates = _prepareCandidates(
      broadphase: broadphase,
      minX: math.min(ax, bx) - radius,
      minY: math.min(ay, by) - radius,
      maxX: math.max(ax, bx) + radius,
      maxY: math.max(ay, by) + radius,
    );
    if (!hasCandidates) return null;

    // 2. Determine the first valid hit.
    for (var i = 0; i < _candidates.length; i += 1) {
      final targetIndex = _candidates[i];

      // 2a. Filter logic.
      if (!_isValidTarget(targetIndex, broadphase, owner, sourceFaction)) {
        continue;
      }

      final targetCenterX = broadphase.targets.centerX[targetIndex];
      final targetCenterY = broadphase.targets.centerY[targetIndex];
      final targetHalfX = broadphase.targets.halfX[targetIndex];
      final targetHalfY = broadphase.targets.halfY[targetIndex];

      // 2b. Capsule vs AABB intersection test.
      if (!capsuleIntersectsAabb(
        ax: ax,
        ay: ay,
        bx: bx,
        by: by,
        radius: radius,
        minX: targetCenterX - targetHalfX,
        minY: targetCenterY - targetHalfY,
        maxX: targetCenterX + targetHalfX,
        maxY: targetCenterY + targetHalfY,
      )) {
        continue;
      }

      // 3. Return immediately on first hit.
      return targetIndex;
    }

    return null;
  }

  /// Helper: Runs broadphase query and sorts results by EntityId.
  ///
  /// Returns `false` if no candidates were found.
  bool _prepareCandidates({
    required BroadphaseGrid broadphase,
    required double minX,
    required double minY,
    required double maxX,
    required double maxY,
  }) {
    // 1. Get raw cell-based candidates (contains duplicates if spanning cells).
    broadphase.queryAabbMinMax(
      minX: minX,
      minY: minY,
      maxX: maxX,
      maxY: maxY,
      outTargetIndices: _candidates,
    );
    if (_candidates.isEmpty) return false;

    // 2. Sort by EntityId to ensure deterministic order (1, 2, 3...)
    // regardless of cell iteration order.
    _sortCandidatesByEntityId(broadphase);
    return true;
  }

  /// Helper: Checks non-geometric filtering rules.
  ///
  /// - Excludes [owner] (can't hit self).
  /// - Excludes allies of [sourceFaction] (friendly fire).
  bool _isValidTarget(
    int targetIndex,
    BroadphaseGrid broadphase,
    EntityId owner,
    Faction sourceFaction,
  ) {
    final target = broadphase.targets.entities[targetIndex];
    if (target == owner) return false;

    return !areAllies(
      sourceFaction,
      broadphase.targets.factions[targetIndex],
    );
  }

  void _sortCandidatesByEntityId(BroadphaseGrid broadphase) {
    _candidates.sort(
      (a, b) => broadphase.targets.entities[a].compareTo(
        broadphase.targets.entities[b],
      ),
    );
  }
}


===== FILE: lib/core/ecs/queries.dart =====
import 'entity_id.dart';
import 'world.dart';

/// Callback signature for iterating over entities with movement-related components.
///
/// [e] is the Entity ID.
/// [mi], [ti], [ii], [bi] are the **dense indices** for:
/// - [mi]: MovementStore
/// - [ti]: TransformStore
/// - [ii]: PlayerInputStore
/// - [bi]: BodyStore
typedef MovementQueryFn =
    void Function(EntityId e, int mi, int ti, int ii, int bi);

/// Callback signature for iterating over entities with collision-related components.
///
/// [e] is the Entity ID.
/// [ti], [bi], [coli], [aabbi] are the **dense indices** for:
/// - [ti]: TransformStore
/// - [bi]: BodyStore
/// - [coli]: CollisionStateStore
/// - [aabbi]: ColliderAabbStore
typedef ColliderQueryFn =
    void Function(EntityId e, int ti, int bi, int coli, int aabbi);

/// Provides optimized iteration methods for groups of components used in common systems.
///
/// These static methods perform "joins" across multiple component stores. They iterate
/// efficiently by driving the loop with the "primary" store (usually the one expected
/// to have the fewest entities or the one we want to iterate linearly) and checking
/// for the presence of other required components.
class EcsQueries {
  /// Iterates over all entities that have [MovementStore], [TransformStore],
  /// [PlayerInputStore], and [BodyStore].
  ///
  /// This query is typically used by the [MovementSystem] to process player movement.
  /// It effectively filters for "controllable physics bodies".
  static void forMovementBodies(EcsWorld world, MovementQueryFn fn) {
    // We drive iteration with the MovementStore.
    final movement = world.movement;
    final entities = movement.denseEntities;

    for (var mi = 0; mi < entities.length; mi += 1) {
      final e = entities[mi];

      // Check existence and get indices for all other required components.
      final ti = world.transform.tryIndexOf(e);
      if (ti == null) continue;
      final ii = world.playerInput.tryIndexOf(e);
      if (ii == null) continue;
      final bi = world.body.tryIndexOf(e);
      if (bi == null) continue;

      fn(e, mi, ti, ii, bi);
    }
  }

  /// Iterates over all entities that have [ColliderAabbStore], [TransformStore],
  /// [BodyStore], and [CollisionStateStore].
  ///
  /// This query finds all physical objects that can collide. It is used by the
  /// [CollisionSystem] to resolve physics interactions.
  static void forColliders(EcsWorld world, ColliderQueryFn fn) {
    // Drive iteration with the ColliderAabbStore.
    final aabb = world.colliderAabb;
    final entities = aabb.denseEntities;

    for (var aabbi = 0; aabbi < entities.length; aabbi += 1) {
      final e = entities[aabbi];

      final ti = world.transform.tryIndexOf(e);
      if (ti == null) continue;
      final bi = world.body.tryIndexOf(e);
      if (bi == null) continue;
      final coli = world.collision.tryIndexOf(e);
      if (coli == null) continue;

      fn(e, ti, bi, coli, aabbi);
    }
  }
}


===== FILE: lib/core/ecs/sparse_set.dart =====
import 'entity_id.dart';

/// Base sparse-set bookkeeping for component stores.
///
/// A sparse set is a data structure that efficiently maps a potentially sparse range
/// of integers (the entity IDs) to a dense, contiguous array of data.
///
/// Internally, it maintains two lists:
/// - `_sparse`: An array indexed by [EntityId]. `_sparse[entity]` stores the
///   index into `denseEntities` plus 1 (0 indicates the entity is not present).
/// - `denseEntities`: A list of [EntityId]s packed contiguously. This allows for
///   fast iteration over all entities that possess this component.
///
/// Subclasses (Component Stores) will maintain their own component data in parallel
/// arrays, also indexed by the values stored in `_sparse` (the "dense index").
///
/// Capabilities:
/// - O(1) membership check (`has`).
/// - O(1) lookup of component data index (`indexOf`).
/// - O(1) insertion (`addEntity`).
/// - O(1) removal (`removeEntity`) using the "swap-and-pop" technique.
/// - Cache-friendly iteration over `denseEntities`.
abstract class SparseSet {
  /// The list of entities that have this component, packed densely.
  /// Iterating this list is the standard way to process all components of this type.
  final List<EntityId> denseEntities = <EntityId>[];

  /// The sparse array mapping EntityId to (denseIndex + 1).
  /// A value of 0 means the entity does not have this component.
  final List<int> _sparse = <int>[];

  /// Returns true if [entity] has this component.
  bool has(EntityId entity) {
    if (entity < 0) return false;
    if (entity >= _sparse.length) return false;
    return _sparse[entity] != 0;
  }

  /// Returns the dense index for [entity].
  ///
  /// Throws if the entity does not have this component. Use [has] or [tryIndexOf] to check.
  int indexOf(EntityId entity) {
    final idxPlus1 = _sparse[entity];
    return idxPlus1 - 1;
  }

  /// Returns the dense index for [entity], or null if it doesn't have this component.
  int? tryIndexOf(EntityId entity) {
    if (entity < 0 || entity >= _sparse.length) return null;
    final idxPlus1 = _sparse[entity];
    if (idxPlus1 == 0) return null;
    return idxPlus1 - 1;
  }

  /// Ensures the internal sparse array is large enough to hold [entity].
  void ensureCapacity(EntityId entity) {
    if (entity < _sparse.length) return;
    final toAdd = entity + 1 - _sparse.length;
    if (toAdd <= 0) return;
    _sparse.addAll(List<int>.filled(toAdd, 0));
  }

  /// Registers [entity] with this store.
  ///
  /// Returns the new stable dense index for this entity's component data.
  /// If the entity is already present, returns its existing dense index.
  ///
  /// Subclasses should call this first, then add their data to their parallel arrays.
  int addEntity(EntityId entity) {
    ensureCapacity(entity);
    final existing = _sparse[entity];
    if (existing != 0) return existing - 1;

    final denseIndex = denseEntities.length;
    denseEntities.add(entity);
    _sparse[entity] = denseIndex + 1;
    onDenseAdded(denseIndex);
    return denseIndex;
  }

  /// Removes [entity] from this store.
  ///
  /// Uses "swap-and-pop" to remove in O(1):
  /// 1. The component data for the entity to be removed is swapped with the
  ///    last component in the dense arrays.
  /// 2. The mapping in `_sparse` for the swapped entity is updated.
  /// 3. The last element is removed (popped).
  ///
  /// This operation changes the dense index of the entity that was at the end.
  void removeEntity(EntityId entity) {
    if (!has(entity)) return;

    final removeIndex = indexOf(entity);
    final lastIndex = denseEntities.length - 1;

    // Hook for subclasses to swap their data arrays before we modify indices.
    onSwapRemove(removeIndex, lastIndex);

    final lastEntity = denseEntities[lastIndex];
    denseEntities[removeIndex] = lastEntity;
    denseEntities.removeLast();

    _sparse[entity] = 0;
    if (removeIndex != lastIndex) {
      // Update the sparse map for the entity that was moved into the empty slot.
      _sparse[lastEntity] = removeIndex + 1;
    }
  }

  /// Called after a new dense slot has been appended.
  /// Subclasses should rely on this to know when a valid index has been established,
  /// though usually they just push data to their lists.
  void onDenseAdded(int denseIndex);

  /// Called before dense arrays are swap-removed from [removeIndex] and [lastIndex].
  ///
  /// Subclasses MUST perform the swap on their parallel data lists inside this method:
  /// `dataList[removeIndex] = dataList[lastIndex]; dataList.removeLast();`
  void onSwapRemove(int removeIndex, int lastIndex);
}


===== FILE: lib/core/ecs/spatial/broadphase_grid.dart =====
import '../hit/aabb_hit_utils.dart';
import '../world.dart';
import 'grid_index_2d.dart';

/// Deterministic broadphase grid rebuilt each tick from dynamic damageable AABBs.
///
/// This grid implementation uses spatial hashing to bucket entities into cells.
/// AABBs that overlap multiple cells are added to all corresponding buckets.
///
/// **Memory Strategy**:
/// - [targets]: Rebuilt every frame to store flat arrays of AABB components.
/// - [_buckets]: Map of cell keys to lists of target indices. Keys are removed
///   when buckets become empty to keep the map size bounded to the visible/active
///   world (vital for infinite runners).
/// - [_bucketPool]: Reuses `List<int>` instances to avoid allocation churn.
/// - [_seenStampByTargetIndex]: Used for O(1) deduplication during queries (avoiding `Set`).
///
/// **Determinism**:
/// - The grid structure itself is order-independent for population.
/// - [queryAabbMinMax] iterates cells in a strict (Y then X) order.
/// - Note: The order of indices *within* a bucket is insertion order (index order in [targets]).
///   Since [targets] is rebuilt by iterating the [EcsWorld], this order depends on
///   Entity ID iteration order.
class BroadphaseGrid {
  BroadphaseGrid({required GridIndex2D index}) : _index = index;

  /// Helper for grid math (coordinate conversion, key packing).
  final GridIndex2D _index;

  /// Stores component data for all damageable entities in the current frame.
  /// Rebuilt at the start of `rebuild()`.
  final DamageableTargetCache targets = DamageableTargetCache();

  // cellKey -> list of target indices into `targets`.
  final Map<int, List<int>> _buckets = <int, List<int>>{};
  // Tracks keys currently in `_buckets` to allow fast iteration/clearing without
  // scanning the whole map (if it were sparse/large).
  final List<int> _activeKeys = <int>[];
  // Pool of lists to avoid allocating new Lists every frame.
  final List<List<int>> _bucketPool = <List<int>>[];

  // Per-query dedup for targets that span multiple cells.
  // We use a "timestamp" strategy: each query increments `_stamp`.
  // If `seen[target] == _stamp`, we've already added it this query.
  final List<int> _seenStampByTargetIndex = <int>[];
  int _stamp = 0;

  /// Rebuilds the spatial grid from the current state of [world].
  ///
  /// This must be called once per tick before any queries are performed.
  void rebuild(EcsWorld world) {
    targets.rebuild(world);

    // clear() old buckets and return lists to the pool.
    // We remove keys from the map to keep the map size small (only active cells).
    for (var i = 0; i < _activeKeys.length; i += 1) {
      final key = _activeKeys[i];
      final bucket = _buckets.remove(key);
      if (bucket == null) continue;
      bucket.clear();
      _bucketPool.add(bucket);
    }
    _activeKeys.clear();

    if (targets.isEmpty) return;

    // Populate buckets.
    for (var ti = 0; ti < targets.length; ti += 1) {
      final cx = targets.centerX[ti];
      final cy = targets.centerY[ti];
      final hx = targets.halfX[ti];
      final hy = targets.halfY[ti];

      // Calculate AABB min/max in world space.
      final minX = cx - hx;
      final maxX = cx + hx;
      final minY = cy - hy;
      final maxY = cy + hy;

      // Convert world AABB to cell index range (inclusive).
      final minCx = _index.worldToCellX(minX);
      final maxCx = _index.worldToCellX(maxX);
      final minCy = _index.worldToCellY(minY);
      final maxCy = _index.worldToCellY(maxY);

      // Add target to every cell its AABB overlaps.
      // This handles "large" entities that span multiple grid cells.
      for (var cellY = minCy; cellY <= maxCy; cellY += 1) {
        for (var cellX = minCx; cellX <= maxCx; cellX += 1) {
          final key = _index.cellKey(cellX, cellY);
          var bucket = _buckets[key];
          if (bucket == null) {
            // Get a list from the pool or allocate new.
            bucket = _bucketPool.isNotEmpty ? _bucketPool.removeLast() : <int>[];
            _buckets[key] = bucket;
            _activeKeys.add(key);
          }
          // Store the target index (not EntityId) for fast lookups.
          bucket.add(ti);
        }
      }
    }
  }

  /// Fills [outTargetIndices] with unique target indices whose AABBs may overlap
  /// the query AABB.
  ///
  /// This involves a broadphase lookup (finding grid cells) and deduplication.
  ///
  /// IMPORTANT (determinism):
  /// - Cell scan order is stable (y then x, increasing).
  /// - The output order depends on bucket insertion order (which depends on entity order).
  /// - Callers must sort by `targets.entities[targetIndex]` if they need a stable
  ///   per-query hit selection order.
  void queryAabbMinMax({
    required double minX,
    required double minY,
    required double maxX,
    required double maxY,
    required List<int> outTargetIndices,
  }) {
    outTargetIndices.clear();
    if (targets.isEmpty) return;

    _stamp += 1;

    // Handle stamp overflow (wrap around)
    if (_stamp == 0x7FFFFFFF) {
      // Reset all seen stamps to 0 so we can safely start over at 1
      for (var i = 0; i < _seenStampByTargetIndex.length; i += 1) {
        _seenStampByTargetIndex[i] = 0;
      }
      _stamp = 1;
    }

    final minCx = _index.worldToCellX(minX);
    final maxCx = _index.worldToCellX(maxX);
    final minCy = _index.worldToCellY(minY);
    final maxCy = _index.worldToCellY(maxY);

    // Ensure strict capacity for the seen array to match current targets.
    // This handles the case where new targets were added in `rebuild`.
    if (_seenStampByTargetIndex.length < targets.length) {
      final missing = targets.length - _seenStampByTargetIndex.length;
      for (var i = 0; i < missing; i += 1) {
        _seenStampByTargetIndex.add(0);
      }
    }

    // Iterate over all cells touched by the query AABB.
    // Order: Row by row (Y), then column by column (X).
    for (var cellY = minCy; cellY <= maxCy; cellY += 1) {
      for (var cellX = minCx; cellX <= maxCx; cellX += 1) {
        final key = _index.cellKey(cellX, cellY);
        final bucket = _buckets[key];
        
        // Skip empty cells.
        if (bucket == null || bucket.isEmpty) continue;

        // Iterate contents of the bucket.
        // Elements are roughly sorted by insertion order (EntityId order).
        for (var bi = 0; bi < bucket.length; bi += 1) {
          final targetIndex = bucket[bi];
          
          // Use stamp to check if already visited this query.
          // This avoids adding the same entity multiple times if it spans multiple cells.
          if (_seenStampByTargetIndex[targetIndex] == _stamp) continue;
          _seenStampByTargetIndex[targetIndex] = _stamp;
          outTargetIndices.add(targetIndex);
        }
      }
    }
  }
}


===== FILE: lib/core/ecs/spatial/grid_index_2d.dart =====
import '../../util/vec2.dart';

class CellAabb {
  const CellAabb({
    required this.minX,
    required this.minY,
    required this.maxX,
    required this.maxY,
  });

  /// World space minimum X coordinate of the cell.
  final double minX;

  /// World space minimum Y coordinate of the cell.
  final double minY;

  /// World space maximum X coordinate of the cell.
  final double maxX;

  /// World space maximum Y coordinate of the cell.
  final double maxY;
}

/// Generic 2D grid math + hashing utility.
///
/// This is intentionally reusable for both:
/// - dynamic broadphase buckets (Milestone 9), and
/// - future nav/cost grids (later milestone).
///
/// IMPORTANT (determinism):
/// - `cellKey(cx, cy)` must be stable and must not use Dart `hashCode`.
class GridIndex2D {
  GridIndex2D({required this.cellSize}) : invCellSize = 1.0 / cellSize;

  /// The width/height of a single square grid cell in world units.
  final double cellSize;

  /// Precomputed `1.0 / cellSize` to avoid divisions in tight loops.
  final double invCellSize;

  /// Converts world X coordinate to grid cell X index.
  /// Uses floor() to handle negative coordinates correctly.
  int worldToCellX(double x) => (x * invCellSize).floor();

  /// Converts world Y coordinate to grid cell Y index.
  int worldToCellY(double y) => (y * invCellSize).floor();

  /// returns the top-left (min) world position of the cell at [cx], [cy].
  Vec2 cellToWorldMin(int cx, int cy) => Vec2(cx * cellSize, cy * cellSize);

  CellAabb cellAabb(int cx, int cy) {
    final minX = cx * cellSize;
    final minY = cy * cellSize;
    return CellAabb(
      minX: minX,
      minY: minY,
      maxX: minX + cellSize,
      maxY: minY + cellSize,
    );
  }

  /// Packs signed (cx, cy) into a single int key (two 32-bit lanes).
  ///
  /// The key is constructed by placing `cy` in the upper 32 bits and `cx` in the
  /// lower 32 bits.
  ///
  /// **Platform Note**: This logic relies on Dart's 64-bit integers (VM/Native).
  /// On the web, where `int` is a double and bitwise operations are 32-bit,
  /// this will lose data (collisions) for keys requiring >32 bits.
  /// For cross-platform safety use a String key or customized class, or ensure
  /// coordinates fit in 16 bits (packed to 32).
  int cellKey(int cx, int cy) {
    // Mask to 32 bits to treat as unsigned for packing, then shift.
    return ((cy & 0xFFFFFFFF) << 32) | (cx & 0xFFFFFFFF);
  }

  /// Iterates 4 neighbors (or 8 if [diagonal] is true) around [cx], [cy].
  ///
  /// Order is guaranteed for determinism:
  /// 1. Cardinals: N, W, E, S
  /// 2. Diagonals (if enabled): NW, NE, SW, SE
  void forNeighbors(
    int cx,
    int cy, {
    bool diagonal = false,
    required void Function(int nx, int ny) visit,
  }) {
    // Stable order (N, W, E, S), then diagonals (NW, NE, SW, SE).
    visit(cx, cy - 1); // North
    visit(cx - 1, cy); // West
    visit(cx + 1, cy); // East
    visit(cx, cy + 1); // South

    if (!diagonal) return;
    
    visit(cx - 1, cy - 1); // NW
    visit(cx + 1, cy - 1); // NE
    visit(cx - 1, cy + 1); // SW
    visit(cx + 1, cy + 1); // SE
  }
}



===== FILE: lib/core/ecs/stores/ability_charge_state_store.dart =====
import '../../abilities/ability_def.dart';
import '../entity_id.dart';
import '../sparse_set.dart';

/// Per-entity authoritative charge state derived from slot hold transitions.
///
/// Charge is tracked in simulation ticks only. UI/client timers are advisory;
/// authoritative commit-time charge comes from this store.
class AbilityChargeStateStore extends SparseSet {
  static final int slotCount = AbilitySlot.values.length;

  /// Bitmask for current hold state by slot.
  final List<int> heldMask = <int>[];

  /// Per-slot hold start tick (flattened: denseIndex * slotCount + slot.index).
  final List<int> holdStartTickBySlot = <int>[];

  /// Per-slot current hold duration in ticks while held.
  final List<int> currentHoldTicksBySlot = <int>[];

  /// Per-slot hold duration captured on the most recent release transition.
  final List<int> releasedHoldTicksBySlot = <int>[];

  /// Tick when [releasedHoldTicksBySlot] was captured; `-1` if none.
  final List<int> releasedTickBySlot = <int>[];

  /// Bitmask of slots whose charge hold timed out and was auto-canceled.
  ///
  /// Cleared when a new hold-start edge is processed for the slot.
  final List<int> canceledMask = <int>[];

  void add(EntityId entity) {
    addEntity(entity);
  }

  bool slotHeld(EntityId entity, AbilitySlot slot) {
    if (!has(entity)) return false;
    final denseIndex = indexOf(entity);
    final bit = 1 << slot.index;
    return (heldMask[denseIndex] & bit) != 0;
  }

  int currentHoldTicks(EntityId entity, AbilitySlot slot) {
    if (!has(entity)) return 0;
    return currentHoldTicksBySlot[_slotOffset(indexOf(entity), slot)];
  }

  /// Returns authoritative commit charge ticks when available.
  ///
  /// - While held: current hold duration.
  /// - On release tick: released hold duration.
  /// - Otherwise: `-1` (no authoritative charge sample for this commit).
  int commitChargeTicksOrUntracked(
    EntityId entity, {
    required AbilitySlot slot,
    required int currentTick,
  }) {
    if (!has(entity)) return -1;
    final denseIndex = indexOf(entity);
    final offset = _slotOffset(denseIndex, slot);
    if (slotHeld(entity, slot)) {
      return currentHoldTicksBySlot[offset];
    }
    if (releasedTickBySlot[offset] == currentTick) {
      return releasedHoldTicksBySlot[offset];
    }
    return -1;
  }

  int slotOffsetForDenseIndex(int denseIndex, AbilitySlot slot) {
    return _slotOffset(denseIndex, slot);
  }

  bool slotChargeCanceled(EntityId entity, AbilitySlot slot) {
    if (!has(entity)) return false;
    final denseIndex = indexOf(entity);
    final bit = 1 << slot.index;
    return (canceledMask[denseIndex] & bit) != 0;
  }

  void setSlotChargeCanceled(
    EntityId entity, {
    required AbilitySlot slot,
    required bool canceled,
  }) {
    if (!has(entity)) return;
    final denseIndex = indexOf(entity);
    final bit = 1 << slot.index;
    if (canceled) {
      canceledMask[denseIndex] |= bit;
    } else {
      canceledMask[denseIndex] &= ~bit;
    }
  }

  int _slotOffset(int denseIndex, AbilitySlot slot) {
    return denseIndex * slotCount + slot.index;
  }

  @override
  void onDenseAdded(int denseIndex) {
    heldMask.add(0);
    canceledMask.add(0);
    for (var i = 0; i < slotCount; i += 1) {
      holdStartTickBySlot.add(-1);
      currentHoldTicksBySlot.add(0);
      releasedHoldTicksBySlot.add(0);
      releasedTickBySlot.add(-1);
    }
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    heldMask[removeIndex] = heldMask[lastIndex];
    canceledMask[removeIndex] = canceledMask[lastIndex];

    final removeBase = removeIndex * slotCount;
    final lastBase = lastIndex * slotCount;
    for (var i = 0; i < slotCount; i += 1) {
      holdStartTickBySlot[removeBase + i] = holdStartTickBySlot[lastBase + i];
      currentHoldTicksBySlot[removeBase + i] =
          currentHoldTicksBySlot[lastBase + i];
      releasedHoldTicksBySlot[removeBase + i] =
          releasedHoldTicksBySlot[lastBase + i];
      releasedTickBySlot[removeBase + i] = releasedTickBySlot[lastBase + i];
    }

    heldMask.removeLast();
    canceledMask.removeLast();
    holdStartTickBySlot.removeRange(lastBase, lastBase + slotCount);
    currentHoldTicksBySlot.removeRange(lastBase, lastBase + slotCount);
    releasedHoldTicksBySlot.removeRange(lastBase, lastBase + slotCount);
    releasedTickBySlot.removeRange(lastBase, lastBase + slotCount);
  }
}


===== FILE: lib/core/ecs/stores/ability_input_buffer_store.dart =====
import '../../abilities/ability_def.dart';
import '../../snapshots/enums.dart';
import '../entity_id.dart';
import '../sparse_set.dart';

/// Stores a single buffered ability input per entity.
///
/// Buffering is used when an input is pressed during an ability's Recovery phase.
/// The latest press overwrites any previous buffer.
class AbilityInputBufferStore extends SparseSet {
  final List<bool> hasBuffered = <bool>[];
  final List<AbilitySlot> slot = <AbilitySlot>[];
  final List<AbilityKey?> abilityId = <AbilityKey?>[];
  final List<double> aimDirX = <double>[];
  final List<double> aimDirY = <double>[];
  final List<Facing> facing = <Facing>[];
  final List<int> commitTick = <int>[];
  final List<int> expiresTick = <int>[];

  /// Ensures entity has this component. Idempotent.
  void ensure(EntityId entity) {
    if (!has(entity)) {
      addEntity(entity);
    }
  }

  /// Strict add — asserts entity is NOT already present.
  void add(EntityId entity) {
    assert(!has(entity), 'Entity $entity already has AbilityInputBufferStore');
    addEntity(entity);
  }

  void setBuffer(
    EntityId entity, {
    required AbilitySlot slot,
    required AbilityKey abilityId,
    required double aimDirX,
    required double aimDirY,
    required Facing facing,
    required int commitTick,
    required int expiresTick,
  }) {
    assert(
      has(entity),
      'AbilityInputBufferStore.setBuffer called for entity without AbilityInputBufferStore.',
    );
    final i = indexOf(entity);
    hasBuffered[i] = true;
    this.slot[i] = slot;
    this.abilityId[i] = abilityId;
    this.aimDirX[i] = aimDirX;
    this.aimDirY[i] = aimDirY;
    this.facing[i] = facing;
    this.commitTick[i] = commitTick;
    this.expiresTick[i] = expiresTick;
  }

  void clear(EntityId entity) {
    if (!has(entity)) return;
    final i = indexOf(entity);
    hasBuffered[i] = false;
    abilityId[i] = null;
    commitTick[i] = -1;
    expiresTick[i] = -1;
  }

  @override
  void onDenseAdded(int denseIndex) {
    hasBuffered.add(false);
    slot.add(AbilitySlot.primary);
    abilityId.add(null);
    aimDirX.add(0.0);
    aimDirY.add(0.0);
    facing.add(Facing.right);
    commitTick.add(-1);
    expiresTick.add(-1);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    hasBuffered[removeIndex] = hasBuffered[lastIndex];
    slot[removeIndex] = slot[lastIndex];
    abilityId[removeIndex] = abilityId[lastIndex];
    aimDirX[removeIndex] = aimDirX[lastIndex];
    aimDirY[removeIndex] = aimDirY[lastIndex];
    facing[removeIndex] = facing[lastIndex];
    commitTick[removeIndex] = commitTick[lastIndex];
    expiresTick[removeIndex] = expiresTick[lastIndex];

    hasBuffered.removeLast();
    slot.removeLast();
    abilityId.removeLast();
    aimDirX.removeLast();
    aimDirY.removeLast();
    facing.removeLast();
    commitTick.removeLast();
    expiresTick.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/active_ability_state_store.dart =====
import '../../abilities/ability_def.dart';
import '../../snapshots/enums.dart'; // For Facing
import '../sparse_set.dart';
import '../entity_id.dart';

/// Tracks the state of the currently active "Action Ability" for animation purposes.
///
/// This store is the single source of truth for "what action is the character doing?".
/// It replaces disparate timestamps like `lastCastTick`, `lastMeleeTick`, etc.
/// in the Animation System.
///
/// **Design Pillar**:
/// - **Single Channel**: Only one Action Ability active at a time.
/// - **Layering**: Overridden by Death, Stun, and potentially Hit Reactions.
/// - **Lifecycle**: Must be explicitly cleared when the action completes.
class ActiveAbilityStateStore extends SparseSet {
  /// The ID of the ability currently controlling the character.
  /// Null (or empty string/special value) if no ability is active.
  /// Using String (AbilityKey) here. Nullable?
  /// SparseSet usage usually implies non-nullable defaults in lists?
  /// Let's use nullable for logic, or empty string.
  /// Pattern in other stores: `List<AbilityKey>` with default.
  final List<AbilityKey?> abilityId = [];

  /// The tick when this ability was committed.
  /// Used to calculate (currentTick - commitTick) for phase timing.
  final List<int> startTick = [];

  /// The facing direction at the moment of commitment.
  final List<Facing> facing = [];

  /// Slot that owns this ability (Primary/Secondary/Projectile/Mobility/Bonus).
  final List<AbilitySlot> slot = [];

  /// Current phase of the active ability.
  final List<AbilityPhase> phase = [];

  /// Phase durations (scaled to tickHz at commit time).
  final List<int> windupTicks = [];
  final List<int> activeTicks = [];
  final List<int> recoveryTicks = [];
  final List<int> totalTicks = [];

  /// Cooldown metadata captured at commit-time.
  final List<int> cooldownGroupId = [];
  final List<int> cooldownTicks = [];
  final List<bool> cooldownStarted = [];

  /// Cached elapsed ticks since commit (updated by phase system).
  final List<int> elapsedTicks = [];

  // Future: aimDir for multi-directional sprites.

  void add(EntityId entity) {
    addEntity(entity);
  }

  /// Sets the active ability for [entity].
  /// Overwrites any existing ability.
  void set(
    EntityId entity, {
    required AbilityKey id,
    required AbilitySlot slot,
    required int commitTick,
    required int windupTicks,
    required int activeTicks,
    required int recoveryTicks,
    required Facing facingDir,
    int cooldownGroupId = 0,
    int cooldownTicks = 0,
    bool cooldownStarted = true,
  }) {
    if (!has(entity)) {
      // Auto-add if missing? Or should it be added at spawn?
      // Best practice: Add at spawn. But here we can safe-guard.
      // EcsWorld usually adds components via add().
      // If we assume it's added, we just assert.
      // But for robustness in this refactor, let's assert.
      assert(has(entity), 'Entity $entity missing ActiveAbilityStateStore');
      return;
    }
    final i = indexOf(entity);
    abilityId[i] = id;
    this.slot[i] = slot;
    startTick[i] = commitTick;
    facing[i] = facingDir;
    this.windupTicks[i] = windupTicks;
    this.activeTicks[i] = activeTicks;
    this.recoveryTicks[i] = recoveryTicks;
    totalTicks[i] = windupTicks + activeTicks + recoveryTicks;
    this.cooldownGroupId[i] = cooldownGroupId;
    this.cooldownTicks[i] = cooldownTicks;
    this.cooldownStarted[i] = cooldownStarted;
    if (windupTicks > 0) {
      phase[i] = AbilityPhase.windup;
    } else if (activeTicks > 0) {
      phase[i] = AbilityPhase.active;
    } else if (recoveryTicks > 0) {
      phase[i] = AbilityPhase.recovery;
    } else {
      phase[i] = AbilityPhase.idle;
    }
    elapsedTicks[i] = 0;
  }

  /// Clears the active ability state for [entity].
  void clear(EntityId entity) {
    if (has(entity)) {
      final i = indexOf(entity);
      abilityId[i] = null;
      startTick[i] = -1;
      phase[i] = AbilityPhase.idle;
      elapsedTicks[i] = 0;
    }
  }

  /// Checks if [entity] has an active ability.
  bool hasActiveAbility(EntityId entity) {
    if (!has(entity)) return false;
    final i = indexOf(entity);
    return abilityId[i] != null;
  }

  @override
  void onDenseAdded(int denseIndex) {
    abilityId.add(null);
    startTick.add(-1);
    facing.add(Facing.right);
    slot.add(AbilitySlot.primary);
    phase.add(AbilityPhase.idle);
    windupTicks.add(0);
    activeTicks.add(0);
    recoveryTicks.add(0);
    totalTicks.add(0);
    cooldownGroupId.add(0);
    cooldownTicks.add(0);
    cooldownStarted.add(true);
    elapsedTicks.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    abilityId[removeIndex] = abilityId[lastIndex];
    startTick[removeIndex] = startTick[lastIndex];
    facing[removeIndex] = facing[lastIndex];
    slot[removeIndex] = slot[lastIndex];
    phase[removeIndex] = phase[lastIndex];
    windupTicks[removeIndex] = windupTicks[lastIndex];
    activeTicks[removeIndex] = activeTicks[lastIndex];
    recoveryTicks[removeIndex] = recoveryTicks[lastIndex];
    totalTicks[removeIndex] = totalTicks[lastIndex];
    cooldownGroupId[removeIndex] = cooldownGroupId[lastIndex];
    cooldownTicks[removeIndex] = cooldownTicks[lastIndex];
    cooldownStarted[removeIndex] = cooldownStarted[lastIndex];
    elapsedTicks[removeIndex] = elapsedTicks[lastIndex];

    abilityId.removeLast();
    startTick.removeLast();
    facing.removeLast();
    slot.removeLast();
    phase.removeLast();
    windupTicks.removeLast();
    activeTicks.removeLast();
    recoveryTicks.removeLast();
    totalTicks.removeLast();
    cooldownGroupId.removeLast();
    cooldownTicks.removeLast();
    cooldownStarted.removeLast();
    elapsedTicks.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/anim/anim_state_store.dart =====
import '../../../snapshots/enums.dart';
import '../../entity_id.dart';
import '../../sparse_set.dart';

/// Per-entity animation state computed by [AnimSystem].
class AnimStateStore extends SparseSet {
  /// Current animation key (idle, run, hit, death, etc.).
  final List<AnimKey> anim = <AnimKey>[];

  /// Frame offset for the current animation (ticks since anim start).
  final List<int> animFrame = <int>[];

  void add(EntityId entity) {
    final i = addEntity(entity);
    anim[i] = AnimKey.idle;
    animFrame[i] = 0;
  }

  @override
  void onDenseAdded(int denseIndex) {
    anim.add(AnimKey.idle);
    animFrame.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    anim[removeIndex] = anim[lastIndex];
    animFrame[removeIndex] = animFrame[lastIndex];

    anim.removeLast();
    animFrame.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/anim/TODO.md =====
# TODO — `lib/core/ecs/stores/anim_state_store.dart`

> Goal: keep `AnimStateStore` **SoA-fast**, safe against misuse (silent resets), and aligned with how AnimSystem writes animation state.

---

## P0 — Correctness / misuse prevention

### [ ] Prevent silent state reset when `add()` is called for an existing entity

**Problem**: `addEntity(entity)` returns an index even if the entity already exists. Calling `add()` twice will overwrite current anim state (idle/0) and hide bugs.

**Fix options** (pick one):

**Option A (recommended): split intent explicitly**

* `ensure(int entity)` → add if missing, do not modify state if already present
* `reset(int entity)` → force idle + frame 0
* Keep `add()` private or remove it.

**Option B: strict add**

* `add(int entity)` asserts `!has(entity)` in debug builds (and/or throws in release if you want to be strict).

**Acceptance**

* Calling “add/ensure” twice never accidentally resets animation.
* Resets are explicit.

---

### [ ] Reduce redundancy between `add()` and `onDenseAdded()`

**Problem**: both set the default state to idle/0 (duplication).

**Task**

* Centralize default initialization in one place.

  * Usually: `onDenseAdded()` initializes arrays, and callers use `ensure()`.

**Acceptance**

* Only one initialization path exists.

---

## P1 — API clarity & ergonomics

### [ ] Provide explicit setters used by systems

AnimSystem likely does something like `store.anim[i]=...; store.animFrame[i]=...`.

**Task**

* Add small helpers for clarity and future invariants:

  * `setByIndex(int dense, AnimKey key, int frame)`
  * `set(int entity, AnimKey key, int frame)`

**Why**

* Makes it trivial to add clamps/invariants later without rewriting every call site.

**Acceptance**

* Systems don’t manually poke arrays everywhere.

---

### [ ] Consider adding getters with safe defaults

**Task**

* `AnimKey getAnim(int entity, {AnimKey defaultKey = AnimKey.idle})`
* `int getFrame(int entity, {int defaultFrame = 0})`

**Acceptance**

* Render path doesn’t need to special-case missing anim state.

---

## P2 — Invariants & safety

### [ ] Clamp/validate `animFrame` (debug)

**Problem**: negative frames or huge frames indicate broken start ticks upstream.

**Task**

* In debug builds:

  * assert `animFrame >= 0`
  * optionally assert `animFrame < someReasonableMax` (or leave unbounded but log)

**Acceptance**

* Broken upstream timing is caught early.

---

### [ ] Document store semantics

Add a short comment describing:

* What `animFrame` means (tick-relative frame hint)
* Whether it can be absolute tick (should converge to “relative ticks since anim start”)
* Who writes it (AnimSystem only)

**Acceptance**

* Future systems don’t mutate anim state.

---

## P3 — Performance (only if needed)

### [ ] Keep arrays tight and reuse memory

Already good: `ensureDenseLength` + `swapRemoveDense`.

**Task**

* If you start storing more fields, keep them SoA and avoid per-entity objects.

---

### [ ] Optional: expose a `writeView` for batched updates

If you want ultra-hot-loop writing:

* expose references or a tiny struct wrapper to avoid repeated bounds checks.

**Only do this after profiling.**

---

## Suggested implementation order

1. Add `ensure()` + `reset()` (or strict `add()`) (P0)
2. Remove redundant init path (P0)
3. Add `set()/setByIndex()` helpers (P1)
4. Add debug asserts + comments (P2)
5. Perf-only changes after profiling (P3)


===== FILE: lib/core/ecs/stores/body_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

/// Configuration for how an entity participates in physics.
///
/// This is intentionally "config-like" and reusable across players/enemies:
/// - `Transform` holds state (pos/vel)
/// - `Movement`/`JumpState` hold controller-specific runtime state
/// - `Body` holds physics participation and constraints (gravity, clamps, kinematic)
class BodyDef {
  const BodyDef({
    this.enabled = true,
    this.isKinematic = false,
    this.useGravity = true,
    this.ignoreCeilings = false,
    this.topOnlyGround = true,
    this.gravityScale = 1.0,
    this.maxVelX = defaultMaxVelX,
    this.maxVelY = defaultMaxVelY,
    this.sideMask = sideLeft | sideRight,
  });

  /// Default velocity cap (safety limit).
  static const double defaultMaxVelX = 3000.0;
  static const double defaultMaxVelY = 3000.0;

  /// Master on/off switch for physics on this entity.
  final bool enabled;

  /// If true, physics does not integrate position/velocity (gameplay code drives it).
  final bool isKinematic;

  /// Whether gravity affects this body.
  final bool useGravity;

  /// If true, upward motion ignores bottom faces (ceilings).
  final bool ignoreCeilings;

  /// If true, collision should resolve only top contacts (platformer-style).
  /// Used by `CollisionSystem` (later milestone).
  final bool topOnlyGround;

  /// Scale applied to global/tuning gravity (1.0 = normal gravity).
  final double gravityScale;

  /// Per-axis velocity clamps (safety caps).
  final double maxVelX;
  final double maxVelY;

  /// Horizontal collision sides bitmask (used by `CollisionSystem` later).
  final int sideMask;

  static const int sideNone = 0;
  static const int sideLeft = 1 << 0;
  static const int sideRight = 1 << 1;
}

/// SoA store for `Body` configuration.
class BodyStore extends SparseSet {
  final List<bool> enabled = <bool>[];
  final List<bool> isKinematic = <bool>[];
  final List<bool> useGravity = <bool>[];
  final List<bool> ignoreCeilings = <bool>[];
  final List<bool> topOnlyGround = <bool>[];

  final List<double> gravityScale = <double>[];
  final List<double> maxVelX = <double>[];
  final List<double> maxVelY = <double>[];

  final List<int> sideMask = <int>[];

  void add(EntityId entity, BodyDef def) {
    final i = addEntity(entity);
    enabled[i] = def.enabled;
    isKinematic[i] = def.isKinematic;
    useGravity[i] = def.useGravity;
    ignoreCeilings[i] = def.ignoreCeilings;
    topOnlyGround[i] = def.topOnlyGround;
    gravityScale[i] = def.gravityScale;
    maxVelX[i] = def.maxVelX;
    maxVelY[i] = def.maxVelY;
    sideMask[i] = def.sideMask;
  }

  @override
  void onDenseAdded(int denseIndex) {
    enabled.add(true);
    isKinematic.add(false);
    useGravity.add(true);
    ignoreCeilings.add(false);
    topOnlyGround.add(true);
    gravityScale.add(1);
    maxVelX.add(BodyDef.defaultMaxVelX);
    maxVelY.add(BodyDef.defaultMaxVelY);
    sideMask.add(BodyDef.sideLeft | BodyDef.sideRight);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    enabled[removeIndex] = enabled[lastIndex];
    isKinematic[removeIndex] = isKinematic[lastIndex];
    useGravity[removeIndex] = useGravity[lastIndex];
    ignoreCeilings[removeIndex] = ignoreCeilings[lastIndex];
    topOnlyGround[removeIndex] = topOnlyGround[lastIndex];
    gravityScale[removeIndex] = gravityScale[lastIndex];
    maxVelX[removeIndex] = maxVelX[lastIndex];
    maxVelY[removeIndex] = maxVelY[lastIndex];
    sideMask[removeIndex] = sideMask[lastIndex];

    enabled.removeLast();
    isKinematic.removeLast();
    useGravity.removeLast();
    ignoreCeilings.removeLast();
    topOnlyGround.removeLast();
    gravityScale.removeLast();
    maxVelX.removeLast();
    maxVelY.removeLast();
    sideMask.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/collectible_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

class CollectibleDef {
  const CollectibleDef({required this.value});

  final int value;
}

/// SoA store for collectible metadata.
///
/// Holds the value/score of the collectible.
class CollectibleStore extends SparseSet {
  final List<int> value = <int>[];

  void add(EntityId entity, CollectibleDef def) {
    final i = addEntity(entity);
    value[i] = def.value;
  }

  @override
  void onDenseAdded(int denseIndex) {
    value.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    value[removeIndex] = value[lastIndex];
    value.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/collider_aabb_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

/// AABB collider configuration for an entity.
///
/// Representation is center-based for stability:
/// - `Transform.pos` is treated as the entity center
/// - collider center is `pos + offset`
/// - extents are half-sizes in world units (virtual pixels)
class ColliderAabbDef {
  const ColliderAabbDef({
    required this.halfX,
    required this.halfY,
    this.offsetX = 0,
    this.offsetY = 0,
  });

  final double halfX;
  final double halfY;
  final double offsetX;
  final double offsetY;
}

/// SoA store for AABB collider config (half extents + offset).
///
/// Collision bounds are distinct from render bounds or hitbox bounds (which are temporary).
class ColliderAabbStore extends SparseSet {
  final List<double> halfX = <double>[];
  final List<double> halfY = <double>[];
  final List<double> offsetX = <double>[];
  final List<double> offsetY = <double>[];

  void add(EntityId entity, ColliderAabbDef def) {
    final i = addEntity(entity);
    halfX[i] = def.halfX;
    halfY[i] = def.halfY;
    offsetX[i] = def.offsetX;
    offsetY[i] = def.offsetY;
  }

  @override
  void onDenseAdded(int denseIndex) {
    halfX.add(0);
    halfY.add(0);
    offsetX.add(0);
    offsetY.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    halfX[removeIndex] = halfX[lastIndex];
    halfY[removeIndex] = halfY[lastIndex];
    offsetX[removeIndex] = offsetX[lastIndex];
    offsetY[removeIndex] = offsetY[lastIndex];

    halfX.removeLast();
    halfY.removeLast();
    offsetX.removeLast();
    offsetY.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/collision_state_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

/// Per-tick collision results for an entity.
///
/// This is reset each tick by the CollisionSystem.
/// These flags track *physical* collision (blocking), not combat hits.
class CollisionStateStore extends SparseSet {
  final List<bool> grounded = <bool>[];
  final List<bool> hitCeiling = <bool>[];
  final List<bool> hitLeft = <bool>[];
  final List<bool> hitRight = <bool>[];

  void add(EntityId entity) {
    addEntity(entity);
  }

  void resetTick(EntityId entity) {
    final i = indexOf(entity);
    grounded[i] = false;
    hitCeiling[i] = false;
    hitLeft[i] = false;
    hitRight[i] = false;
  }

  @override
  void onDenseAdded(int denseIndex) {
    grounded.add(false);
    hitCeiling.add(false);
    hitLeft.add(false);
    hitRight.add(false);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    grounded[removeIndex] = grounded[lastIndex];
    hitCeiling[removeIndex] = hitCeiling[lastIndex];
    hitLeft[removeIndex] = hitLeft[lastIndex];
    hitRight[removeIndex] = hitRight[lastIndex];

    grounded.removeLast();
    hitCeiling.removeLast();
    hitLeft.removeLast();
    hitRight.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/combat/creature_tag_store.dart =====
import '../../../combat/creature_tag.dart';
import '../../entity_id.dart';
import '../../sparse_set.dart';

class CreatureTagDef {
  const CreatureTagDef({this.mask = 0});

  final int mask;
}

/// Broad tag classifications for creatures (enemies + player variants).
class CreatureTagStore extends SparseSet {
  final List<int> tagsMask = <int>[];

  void add(EntityId entity, [CreatureTagDef def = const CreatureTagDef()]) {
    final i = addEntity(entity);
    tagsMask[i] = def.mask;
  }

  bool hasTag(EntityId entity, CreatureTag tag) {
    final i = tryIndexOf(entity);
    if (i == null) return false;
    return (tagsMask[i] & CreatureTagMask.forTag(tag)) != 0;
  }

  void addTag(EntityId entity, CreatureTag tag) {
    final i = tryIndexOf(entity);
    if (i == null) return;
    tagsMask[i] |= CreatureTagMask.forTag(tag);
  }

  @override
  void onDenseAdded(int denseIndex) {
    tagsMask.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    tagsMask[removeIndex] = tagsMask[lastIndex];
    tagsMask.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/combat/damage_resistance_store.dart =====
import '../../../combat/damage_type.dart';
import '../../entity_id.dart';
import '../../sparse_set.dart';

class DamageResistanceDef {
  const DamageResistanceDef({
    this.physicalBp = 0,
    this.fireBp = 0,
    this.iceBp = 0,
    this.waterBp = 0,
    this.thunderBp = 0,
    this.acidBp = 0,
    this.darkBp = 0,
    this.bleedBp = 0,
    this.earthBp = 0,
    this.holyBp = 0,
  });

  /// Basis points (100 = 1%).
  final int physicalBp;
  final int fireBp;
  final int iceBp;
  final int waterBp;
  final int thunderBp;
  final int acidBp;
  final int darkBp;
  final int bleedBp;
  final int earthBp;
  final int holyBp;

  int modBpFor(DamageType type) {
    switch (type) {
      case DamageType.physical:
        return physicalBp;
      case DamageType.fire:
        return fireBp;
      case DamageType.ice:
        return iceBp;
      case DamageType.water:
        return waterBp;
      case DamageType.thunder:
        return thunderBp;
      case DamageType.acid:
        return acidBp;
      case DamageType.dark:
        return darkBp;
      case DamageType.bleed:
        return bleedBp;
      case DamageType.earth:
        return earthBp;
      case DamageType.holy:
        return holyBp;
    }
  }
}

/// Per-entity resistance/vulnerability modifiers by [DamageType].
class DamageResistanceStore extends SparseSet {
  /// Basis points (100 = 1%).
  final List<int> physicalBp = <int>[];
  final List<int> fireBp = <int>[];
  final List<int> iceBp = <int>[];
  final List<int> waterBp = <int>[];
  final List<int> thunderBp = <int>[];
  final List<int> acidBp = <int>[];
  final List<int> darkBp = <int>[];
  final List<int> bleedBp = <int>[];
  final List<int> earthBp = <int>[];
  final List<int> holyBp = <int>[];

  void add(
    EntityId entity, [
    DamageResistanceDef def = const DamageResistanceDef(),
  ]) {
    final i = addEntity(entity);
    physicalBp[i] = def.physicalBp;
    fireBp[i] = def.fireBp;
    iceBp[i] = def.iceBp;
    waterBp[i] = def.waterBp;
    thunderBp[i] = def.thunderBp;
    acidBp[i] = def.acidBp;
    darkBp[i] = def.darkBp;
    bleedBp[i] = def.bleedBp;
    earthBp[i] = def.earthBp;
    holyBp[i] = def.holyBp;
  }

  int modBpForEntity(EntityId entity, DamageType type) {
    final i = tryIndexOf(entity);
    if (i == null) return 0;
    return modBpForIndex(i, type);
  }

  int modBpForIndex(int index, DamageType type) {
    switch (type) {
      case DamageType.physical:
        return physicalBp[index];
      case DamageType.fire:
        return fireBp[index];
      case DamageType.ice:
        return iceBp[index];
      case DamageType.water:
        return waterBp[index];
      case DamageType.thunder:
        return thunderBp[index];
      case DamageType.acid:
        return acidBp[index];
      case DamageType.dark:
        return darkBp[index];
      case DamageType.bleed:
        return bleedBp[index];
      case DamageType.earth:
        return earthBp[index];
      case DamageType.holy:
        return holyBp[index];
    }
  }

  @override
  void onDenseAdded(int denseIndex) {
    physicalBp.add(0);
    fireBp.add(0);
    iceBp.add(0);
    waterBp.add(0);
    thunderBp.add(0);
    acidBp.add(0);
    darkBp.add(0);
    bleedBp.add(0);
    earthBp.add(0);
    holyBp.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    physicalBp[removeIndex] = physicalBp[lastIndex];
    fireBp[removeIndex] = fireBp[lastIndex];
    iceBp[removeIndex] = iceBp[lastIndex];
    waterBp[removeIndex] = waterBp[lastIndex];
    thunderBp[removeIndex] = thunderBp[lastIndex];
    acidBp[removeIndex] = acidBp[lastIndex];
    darkBp[removeIndex] = darkBp[lastIndex];
    bleedBp[removeIndex] = bleedBp[lastIndex];
    earthBp[removeIndex] = earthBp[lastIndex];
    holyBp[removeIndex] = holyBp[lastIndex];

    physicalBp.removeLast();
    fireBp.removeLast();
    iceBp.removeLast();
    waterBp.removeLast();
    thunderBp.removeLast();
    acidBp.removeLast();
    darkBp.removeLast();
    bleedBp.removeLast();
    earthBp.removeLast();
    holyBp.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/combat/equipped_loadout_store.dart =====
import '../../../projectiles/projectile_id.dart';
import '../../../spellBook/spell_book_id.dart';
import '../../../accessories/accessory_id.dart';
import '../../../weapons/weapon_id.dart';
import '../../entity_id.dart';
import '../../sparse_set.dart';
import '../../../abilities/ability_def.dart';

/// Bitmask constants for loadout slots.
///
/// Each bit represents a slot that a character may or may not have access to.
/// Use these to check/set which equipment slots are enabled for an entity.
class LoadoutSlotMask {
  const LoadoutSlotMask._();

  /// Main hand weapon slot (melee).
  static const int mainHand = 1 << 0;

  /// Off-hand slot (shield or secondary weapon).
  static const int offHand = 1 << 1;

  /// Projectile slot (spells or throwing weapons).
  static const int projectile = 1 << 2;

  /// All slots enabled.
  static const int all = mainHand | offHand | projectile;

  /// Default slots for most characters (no off-hand).
  static const int defaultMask = mainHand | projectile;
}

/// Definition for creating an equipped loadout component.
class EquippedLoadoutDef {
  const EquippedLoadoutDef({
    this.mask = LoadoutSlotMask.defaultMask,
    this.mainWeaponId = WeaponId.woodenSword,
    this.offhandWeaponId = WeaponId.woodenShield,
    this.projectileId = ProjectileId.throwingKnife,
    this.spellBookId = SpellBookId.basicSpellBook,
    this.projectileSlotSpellId = ProjectileId.fireBolt,
    this.accessoryId = AccessoryId.speedBoots,
    this.abilityPrimaryId = 'eloise.bloodletter_slash',
    this.abilitySecondaryId = 'eloise.aegis_riposte',
    this.abilityProjectileId = 'eloise.quick_shot',
    this.abilitySpellId = 'eloise.arcane_haste',
    this.abilityMobilityId = 'eloise.dash',
    this.abilityJumpId = 'eloise.jump',
  });

  /// Bitmask of enabled slots (see [LoadoutSlotMask]).
  final int mask;

  /// Main hand weapon.
  final WeaponId mainWeaponId;

  /// Off-hand weapon or shield.
  final WeaponId offhandWeaponId;

  /// Equipped projectile item fallback (typically throwing weapon).
  final ProjectileId projectileId;

  /// Equipped spell book (spell payload provider).
  final SpellBookId spellBookId;

  /// Optional projectile spell selection for [AbilitySlot.projectile].
  ///
  /// If null, projectile abilities in the projectile slot use [projectileId].
  final ProjectileId? projectileSlotSpellId;

  /// Equipped accessory (meta gear; contributes via CharacterStatsResolver).
  final AccessoryId accessoryId;

  // New Ability System IDs
  final AbilityKey abilityPrimaryId;
  final AbilityKey abilitySecondaryId;
  final AbilityKey abilityProjectileId;
  final AbilityKey abilitySpellId;
  final AbilityKey abilityMobilityId;
  final AbilityKey abilityJumpId;
}

/// Per-entity equipment loadout (single source of truth).
///
/// This store holds all equipped items for an entity in a unified structure.
/// Systems should read from this store for equipment info.
///
/// **Slot mask**: Determines which slots are available for this entity.
/// Use [hasSlot] to check if an entity has a specific slot enabled.
class EquippedLoadoutStore extends SparseSet {
  // SoA fields for each component.
  final List<int> mask = <int>[];
  final List<WeaponId> mainWeaponId = <WeaponId>[];
  final List<WeaponId> offhandWeaponId = <WeaponId>[];
  final List<ProjectileId> projectileId = <ProjectileId>[];
  final List<SpellBookId> spellBookId = <SpellBookId>[];
  final List<ProjectileId?> projectileSlotSpellId = <ProjectileId?>[];
  final List<AccessoryId> accessoryId = <AccessoryId>[];

  // New Ability System Lists
  final List<AbilityKey> abilityPrimaryId = <AbilityKey>[];
  final List<AbilityKey> abilitySecondaryId = <AbilityKey>[];
  final List<AbilityKey> abilityProjectileId = <AbilityKey>[];
  final List<AbilityKey> abilitySpellId = <AbilityKey>[];
  final List<AbilityKey> abilityMobilityId = <AbilityKey>[];
  final List<AbilityKey> abilityJumpId = <AbilityKey>[];

  void add(
    EntityId entity, [
    EquippedLoadoutDef def = const EquippedLoadoutDef(),
  ]) {
    final i = addEntity(entity);
    mask[i] = def.mask;
    mainWeaponId[i] = def.mainWeaponId;
    offhandWeaponId[i] = def.offhandWeaponId;
    projectileId[i] = def.projectileId;
    spellBookId[i] = def.spellBookId;
    projectileSlotSpellId[i] = def.projectileSlotSpellId;
    accessoryId[i] = def.accessoryId;
    abilityPrimaryId[i] = def.abilityPrimaryId;
    abilitySecondaryId[i] = def.abilitySecondaryId;
    abilityProjectileId[i] = def.abilityProjectileId;
    abilitySpellId[i] = def.abilitySpellId;
    abilityMobilityId[i] = def.abilityMobilityId;
    abilityJumpId[i] = def.abilityJumpId;
  }

  /// Updates the loadout for an existing entity.
  void set(EntityId entity, EquippedLoadoutDef def) {
    final i = indexOf(entity);
    mask[i] = def.mask;
    mainWeaponId[i] = def.mainWeaponId;
    offhandWeaponId[i] = def.offhandWeaponId;
    projectileId[i] = def.projectileId;
    spellBookId[i] = def.spellBookId;
    projectileSlotSpellId[i] = def.projectileSlotSpellId;
    accessoryId[i] = def.accessoryId;
    abilityPrimaryId[i] = def.abilityPrimaryId;
    abilitySecondaryId[i] = def.abilitySecondaryId;
    abilityProjectileId[i] = def.abilityProjectileId;
    abilitySpellId[i] = def.abilitySpellId;
    abilityMobilityId[i] = def.abilityMobilityId;
    abilityJumpId[i] = def.abilityJumpId;
  }

  /// Returns true if [entity] has the given [slotBit] enabled.
  bool hasSlot(EntityId entity, int slotBit) {
    final i = tryIndexOf(entity);
    if (i == null) return false;
    return (mask[i] & slotBit) != 0;
  }

  @override
  void onDenseAdded(int denseIndex) {
    mask.add(LoadoutSlotMask.defaultMask);
    mainWeaponId.add(WeaponId.woodenSword);
    offhandWeaponId.add(WeaponId.woodenShield);
    projectileId.add(ProjectileId.throwingKnife);
    spellBookId.add(SpellBookId.basicSpellBook);
    projectileSlotSpellId.add(ProjectileId.fireBolt);
    accessoryId.add(AccessoryId.speedBoots);
    abilityPrimaryId.add('eloise.bloodletter_slash');
    abilitySecondaryId.add('eloise.aegis_riposte');
    abilityProjectileId.add('eloise.quick_shot');
    abilitySpellId.add('eloise.arcane_haste');
    abilityMobilityId.add('eloise.dash');
    abilityJumpId.add('eloise.jump');
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    mask[removeIndex] = mask[lastIndex];
    mainWeaponId[removeIndex] = mainWeaponId[lastIndex];
    offhandWeaponId[removeIndex] = offhandWeaponId[lastIndex];
    projectileId[removeIndex] = projectileId[lastIndex];
    spellBookId[removeIndex] = spellBookId[lastIndex];
    projectileSlotSpellId[removeIndex] = projectileSlotSpellId[lastIndex];
    accessoryId[removeIndex] = accessoryId[lastIndex];
    abilityPrimaryId[removeIndex] = abilityPrimaryId[lastIndex];
    abilitySecondaryId[removeIndex] = abilitySecondaryId[lastIndex];
    abilityProjectileId[removeIndex] = abilityProjectileId[lastIndex];
    abilitySpellId[removeIndex] = abilitySpellId[lastIndex];
    abilityMobilityId[removeIndex] = abilityMobilityId[lastIndex];
    abilityJumpId[removeIndex] = abilityJumpId[lastIndex];

    mask.removeLast();
    mainWeaponId.removeLast();
    offhandWeaponId.removeLast();
    projectileId.removeLast();
    spellBookId.removeLast();
    projectileSlotSpellId.removeLast();
    accessoryId.removeLast();
    abilityPrimaryId.removeLast();
    abilitySecondaryId.removeLast();
    abilityProjectileId.removeLast();
    abilitySpellId.removeLast();
    abilityMobilityId.removeLast();
    abilityJumpId.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/combat/resolved_stats_cache_store.dart =====
import '../../../accessories/accessory_id.dart';
import '../../../projectiles/projectile_id.dart';
import '../../../spellBook/spell_book_id.dart';
import '../../../stats/character_stats_resolver.dart';
import '../../../stats/gear_stat_bonuses.dart';
import '../../../weapons/weapon_id.dart';
import '../../entity_id.dart';
import '../../sparse_set.dart';

/// Cached per-entity resolved stats derived from equipped loadout.
///
/// This store mirrors only the gear-relevant loadout fields used by
/// [CharacterStatsResolver]. Systems can compare against live loadout values and
/// reuse [stats] when unchanged.
class ResolvedStatsCacheStore extends SparseSet {
  final List<int> mask = <int>[];
  final List<WeaponId> mainWeaponId = <WeaponId>[];
  final List<WeaponId> offhandWeaponId = <WeaponId>[];
  final List<ProjectileId> projectileId = <ProjectileId>[];
  final List<SpellBookId> spellBookId = <SpellBookId>[];
  final List<AccessoryId> accessoryId = <AccessoryId>[];
  final List<ResolvedCharacterStats> stats = <ResolvedCharacterStats>[];

  void setForEntity(
    EntityId entity, {
    required int mask,
    required WeaponId mainWeaponId,
    required WeaponId offhandWeaponId,
    required ProjectileId projectileId,
    required SpellBookId spellBookId,
    required AccessoryId accessoryId,
    required ResolvedCharacterStats stats,
  }) {
    final i = addEntity(entity);
    this.mask[i] = mask;
    this.mainWeaponId[i] = mainWeaponId;
    this.offhandWeaponId[i] = offhandWeaponId;
    this.projectileId[i] = projectileId;
    this.spellBookId[i] = spellBookId;
    this.accessoryId[i] = accessoryId;
    this.stats[i] = stats;
  }

  bool matchesLoadout({
    required int cacheIndex,
    required int mask,
    required WeaponId mainWeaponId,
    required WeaponId offhandWeaponId,
    required ProjectileId projectileId,
    required SpellBookId spellBookId,
    required AccessoryId accessoryId,
  }) {
    return this.mask[cacheIndex] == mask &&
        this.mainWeaponId[cacheIndex] == mainWeaponId &&
        this.offhandWeaponId[cacheIndex] == offhandWeaponId &&
        this.projectileId[cacheIndex] == projectileId &&
        this.spellBookId[cacheIndex] == spellBookId &&
        this.accessoryId[cacheIndex] == accessoryId;
  }

  @override
  void onDenseAdded(int denseIndex) {
    mask.add(0);
    mainWeaponId.add(WeaponId.woodenSword);
    offhandWeaponId.add(WeaponId.woodenShield);
    projectileId.add(ProjectileId.throwingKnife);
    spellBookId.add(SpellBookId.basicSpellBook);
    accessoryId.add(AccessoryId.speedBoots);
    stats.add(const ResolvedCharacterStats(bonuses: GearStatBonuses.zero));
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    mask[removeIndex] = mask[lastIndex];
    mainWeaponId[removeIndex] = mainWeaponId[lastIndex];
    offhandWeaponId[removeIndex] = offhandWeaponId[lastIndex];
    projectileId[removeIndex] = projectileId[lastIndex];
    spellBookId[removeIndex] = spellBookId[lastIndex];
    accessoryId[removeIndex] = accessoryId[lastIndex];
    stats[removeIndex] = stats[lastIndex];

    mask.removeLast();
    mainWeaponId.removeLast();
    offhandWeaponId.removeLast();
    projectileId.removeLast();
    spellBookId.removeLast();
    accessoryId.removeLast();
    stats.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/combat/stat_modifier_store.dart =====
import '../../../util/fixed_math.dart';
import '../../entity_id.dart';
import '../../sparse_set.dart';

class StatModifierDef {
  const StatModifierDef({
    this.moveSpeedMul = 1.0,
    this.actionSpeedBp = bpScale,
  });

  final double moveSpeedMul;
  final int actionSpeedBp;
}

/// Runtime modifiers derived from status effects and buffs.
class StatModifierStore extends SparseSet {
  final List<double> moveSpeedMul = <double>[];
  final List<int> actionSpeedBp = <int>[];

  void add(EntityId entity, [StatModifierDef def = const StatModifierDef()]) {
    final i = addEntity(entity);
    moveSpeedMul[i] = def.moveSpeedMul;
    actionSpeedBp[i] = def.actionSpeedBp;
  }

  @override
  void onDenseAdded(int denseIndex) {
    moveSpeedMul.add(1.0);
    actionSpeedBp.add(bpScale);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    moveSpeedMul[removeIndex] = moveSpeedMul[lastIndex];
    actionSpeedBp[removeIndex] = actionSpeedBp[lastIndex];
    moveSpeedMul.removeLast();
    actionSpeedBp.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/combat/status_immunity_store.dart =====
import '../../../combat/status/status.dart';
import '../../entity_id.dart';
import '../../sparse_set.dart';

class StatusImmunityMask {
  const StatusImmunityMask._();

  static const int dot = 1 << 0;
  static const int slow = 1 << 1;
  static const int stun = 1 << 2;
  static const int haste = 1 << 3;
  static const int vulnerable = 1 << 4;
  static const int weaken = 1 << 5;
  static const int drench = 1 << 6;
  static const int silence = 1 << 7;
  static const int resourceOverTime = 1 << 8;
  static int forType(StatusEffectType type) {
    switch (type) {
      case StatusEffectType.dot:
        return dot;
      case StatusEffectType.slow:
        return slow;
      case StatusEffectType.stun:
        return stun;
      case StatusEffectType.haste:
        return haste;
      case StatusEffectType.vulnerable:
        return vulnerable;
      case StatusEffectType.weaken:
        return weaken;
      case StatusEffectType.drench:
        return drench;
      case StatusEffectType.silence:
        return silence;
      case StatusEffectType.resourceOverTime:
        return resourceOverTime;
    }
  }
}

class StatusImmunityDef {
  const StatusImmunityDef({this.mask = 0});

  final int mask;
}

/// Per-entity status immunities (bitmask of [StatusEffectType]).
class StatusImmunityStore extends SparseSet {
  final List<int> mask = <int>[];

  void add(
    EntityId entity, [
    StatusImmunityDef def = const StatusImmunityDef(),
  ]) {
    final i = addEntity(entity);
    mask[i] = def.mask;
  }

  bool isImmune(EntityId entity, StatusEffectType type) {
    final i = tryIndexOf(entity);
    if (i == null) return false;
    return (mask[i] & StatusImmunityMask.forType(type)) != 0;
  }

  @override
  void onDenseAdded(int denseIndex) {
    mask.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    mask[removeIndex] = mask[lastIndex];
    mask.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/control_lock_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';
import '../../combat/control_lock.dart';

/// SoA store for control locks with per-flag expiry.
///
/// Each flag has its own `untilTick` field. A lock is active if
/// `currentTick < untilTick`. The [activeMask] is recomputed each tick
/// by [ControlLockSystem].
///
/// **Refresh rule**: When adding a lock, use `max(existing, new)` for the
/// untilTick to handle overlapping/refreshing locks correctly.
class ControlLockStore extends SparseSet {
  /// Cached active mask (refreshed each tick by ControlLockSystem).
  final List<int> activeMask = <int>[];

  /// Per-flag expiry ticks.
  ///
  /// A lock is active while `currentTick < untilTickX`.
  final List<int> untilTickStun = <int>[];
  final List<int> untilTickMove = <int>[];
  final List<int> untilTickJump = <int>[];
  final List<int> untilTickDash = <int>[];
  final List<int> untilTickStrike = <int>[];
  final List<int> untilTickCast = <int>[];
  final List<int> untilTickRanged = <int>[];
  final List<int> untilTickNav = <int>[];

  /// Tick where the current continuous stun window started.
  ///
  /// This is set when an entity transitions from "not stunned" to "stunned".
  /// Refreshing an already-active stun extends duration without restarting this
  /// origin tick.
  final List<int> stunStartTick = <int>[];

  // ─────────────────────────────────────────────────────────────────────────
  // Public API
  // ─────────────────────────────────────────────────────────────────────────

  /// Adds or refreshes a lock on [entity].
  ///
  /// Uses `max(existing, new)` for the untilTick to correctly handle
  /// refreshing or overlapping locks with different durations.
  void addLock(EntityId entity, int flag, int durationTicks, int currentTick) {
    if (durationTicks <= 0) return;

    final newUntilTick = currentTick + durationTicks;

    int idx = tryIndexOf(entity) ?? addEntity(entity);

    // Apply lock(s) using max() for refresh behavior
    if ((flag & LockFlag.stun) != 0) {
      final wasStunned = currentTick < untilTickStun[idx];
      untilTickStun[idx] = _max(untilTickStun[idx], newUntilTick);
      if (!wasStunned) {
        stunStartTick[idx] = currentTick;
      }
    }
    if ((flag & LockFlag.move) != 0) {
      untilTickMove[idx] = _max(untilTickMove[idx], newUntilTick);
    }
    if ((flag & LockFlag.jump) != 0) {
      untilTickJump[idx] = _max(untilTickJump[idx], newUntilTick);
    }
    if ((flag & LockFlag.dash) != 0) {
      untilTickDash[idx] = _max(untilTickDash[idx], newUntilTick);
    }
    if ((flag & LockFlag.strike) != 0) {
      untilTickStrike[idx] = _max(untilTickStrike[idx], newUntilTick);
    }
    if ((flag & LockFlag.cast) != 0) {
      untilTickCast[idx] = _max(untilTickCast[idx], newUntilTick);
    }
    if ((flag & LockFlag.ranged) != 0) {
      untilTickRanged[idx] = _max(untilTickRanged[idx], newUntilTick);
    }
    if ((flag & LockFlag.nav) != 0) {
      untilTickNav[idx] = _max(untilTickNav[idx], newUntilTick);
    }

    // Update cached mask immediately
    _refreshMaskAt(idx, currentTick);
  }

  /// Returns true if [entity] has [flag] locked.
  bool isLocked(EntityId entity, int flag, int currentTick) {
    final idx = tryIndexOf(entity);
    if (idx == null) return false;

    // Check stun first (master lock)
    if (currentTick < untilTickStun[idx]) return true;

    // Then check specific flag
    return _isFlagActiveAt(idx, flag, currentTick);
  }

  /// Returns true if [entity] is stunned.
  ///
  /// This is the primary check for gameplay systems. Stun blocks everything.
  bool isStunned(EntityId entity, int currentTick) {
    final idx = tryIndexOf(entity);
    if (idx == null) return false;
    return currentTick < untilTickStun[idx];
  }

  /// Returns stun animation origin tick for [entity], or `-1` if not stunned.
  int stunStartTickFor(EntityId entity, int currentTick) {
    final idx = tryIndexOf(entity);
    if (idx == null) return -1;
    if (currentTick >= untilTickStun[idx]) return -1;
    return stunStartTick[idx];
  }

  /// Returns the cached active mask for [entity].
  ///
  /// Note: This mask is refreshed by ControlLockSystem each tick.
  /// For immediate checks, use [isLocked] or [isStunned].
  int getActiveMask(EntityId entity) {
    final idx = tryIndexOf(entity);
    if (idx == null) return 0;
    return activeMask[idx];
  }

  /// Refreshes the active mask for entity at [idx] based on [currentTick].
  ///
  /// Called by ControlLockSystem each tick and after addLock.
  void refreshMask(int idx, int currentTick) {
    _refreshMaskAt(idx, currentTick);
  }

  // ─────────────────────────────────────────────────────────────────────────
  // SparseSet overrides
  // ─────────────────────────────────────────────────────────────────────────

  @override
  void onDenseAdded(int denseIndex) {
    activeMask.add(0);
    untilTickStun.add(0);
    untilTickMove.add(0);
    untilTickJump.add(0);
    untilTickDash.add(0);
    untilTickStrike.add(0);
    untilTickCast.add(0);
    untilTickRanged.add(0);
    untilTickNav.add(0);
    stunStartTick.add(-1);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    activeMask[removeIndex] = activeMask[lastIndex];
    untilTickStun[removeIndex] = untilTickStun[lastIndex];
    untilTickMove[removeIndex] = untilTickMove[lastIndex];
    untilTickJump[removeIndex] = untilTickJump[lastIndex];
    untilTickDash[removeIndex] = untilTickDash[lastIndex];
    untilTickStrike[removeIndex] = untilTickStrike[lastIndex];
    untilTickCast[removeIndex] = untilTickCast[lastIndex];
    untilTickRanged[removeIndex] = untilTickRanged[lastIndex];
    untilTickNav[removeIndex] = untilTickNav[lastIndex];
    stunStartTick[removeIndex] = stunStartTick[lastIndex];

    activeMask.removeLast();
    untilTickStun.removeLast();
    untilTickMove.removeLast();
    untilTickJump.removeLast();
    untilTickDash.removeLast();
    untilTickStrike.removeLast();
    untilTickCast.removeLast();
    untilTickRanged.removeLast();
    untilTickNav.removeLast();
    stunStartTick.removeLast();
  }

  // ─────────────────────────────────────────────────────────────────────────
  // Private helpers
  // ─────────────────────────────────────────────────────────────────────────

  void _refreshMaskAt(int idx, int currentTick) {
    int mask = 0;
    if (currentTick < untilTickStun[idx]) mask |= LockFlag.stun;
    if (currentTick < untilTickMove[idx]) mask |= LockFlag.move;
    if (currentTick < untilTickJump[idx]) mask |= LockFlag.jump;
    if (currentTick < untilTickDash[idx]) mask |= LockFlag.dash;
    if (currentTick < untilTickStrike[idx]) mask |= LockFlag.strike;
    if (currentTick < untilTickCast[idx]) mask |= LockFlag.cast;
    if (currentTick < untilTickRanged[idx]) mask |= LockFlag.ranged;
    if (currentTick < untilTickNav[idx]) mask |= LockFlag.nav;
    activeMask[idx] = mask;
  }

  bool _isFlagActiveAt(int idx, int flag, int currentTick) {
    if ((flag & LockFlag.move) != 0 && currentTick < untilTickMove[idx]) {
      return true;
    }
    if ((flag & LockFlag.jump) != 0 && currentTick < untilTickJump[idx]) {
      return true;
    }
    if ((flag & LockFlag.dash) != 0 && currentTick < untilTickDash[idx]) {
      return true;
    }
    if ((flag & LockFlag.strike) != 0 && currentTick < untilTickStrike[idx]) {
      return true;
    }
    if ((flag & LockFlag.cast) != 0 && currentTick < untilTickCast[idx]) {
      return true;
    }
    if ((flag & LockFlag.ranged) != 0 && currentTick < untilTickRanged[idx]) {
      return true;
    }
    if ((flag & LockFlag.nav) != 0 && currentTick < untilTickNav[idx]) {
      return true;
    }
    return false;
  }

  static int _max(int a, int b) => a > b ? a : b;
}


===== FILE: lib/core/ecs/stores/cooldown_store.dart =====
import '../../abilities/ability_def.dart';
import '../entity_id.dart';
import '../sparse_set.dart';

/// Tracks ability cooldowns by group index.
///
/// Each entity has [kMaxCooldownGroups] cooldown slots (default 8).
/// Abilities sharing a group share a cooldown.
///
/// **SoA Layout**: `ticksLeft[entityIndex * kMaxCooldownGroups + groupId]`
class CooldownStore extends SparseSet {
  /// Ticks remaining per group.
  /// Access via: ticksLeft[entityIndex * kMaxCooldownGroups + groupId]
  final List<int> _ticksLeft = <int>[];

  /// Ensures entity has this component. Idempotent.
  void ensure(EntityId entity) {
    if (!has(entity)) {
      addEntity(entity);
    }
  }

  /// Strict add — asserts entity is NOT already present.
  void add(EntityId entity) {
    assert(!has(entity), 'Entity $entity already has CooldownStore');
    addEntity(entity);
  }

  /// Resets all cooldowns for entity to 0.
  void reset(EntityId entity) {
    if (!has(entity)) return;
    final i = indexOf(entity);
    for (var g = 0; g < kMaxCooldownGroups; g++) {
      _ticksLeft[i * kMaxCooldownGroups + g] = 0;
    }
  }

  /// Gets ticks remaining for a specific cooldown group.
  int getTicksLeft(EntityId entity, int groupId) {
    assert(
      groupId >= 0 && groupId < kMaxCooldownGroups,
      'Group ID must be in range [0, $kMaxCooldownGroups)',
    );
    if (!has(entity)) return 0;
    final i = indexOf(entity);
    return _ticksLeft[i * kMaxCooldownGroups + groupId];
  }

  /// Sets ticks remaining for a specific cooldown group.
  void setTicksLeft(EntityId entity, int groupId, int ticks) {
    assert(
      groupId >= 0 && groupId < kMaxCooldownGroups,
      'Group ID must be in range [0, $kMaxCooldownGroups)',
    );
    assert(has(entity), 'Entity $entity missing CooldownStore');
    final i = indexOf(entity);
    _ticksLeft[i * kMaxCooldownGroups + groupId] = ticks;
  }

  /// Starts a cooldown for the given group.
  ///
  /// Uses "max refresh" semantics: if the group is already on cooldown,
  /// the new duration is applied only if it is longer than the current remaining ticks.
  /// This prevents accidental shortening of cooldowns.
  void startCooldown(EntityId entity, int groupId, int durationTicks) {
    final i = indexOf(entity);
    final idx = i * kMaxCooldownGroups + groupId;
    final current = _ticksLeft[idx];
    if (durationTicks > current) {
      _ticksLeft[idx] = durationTicks;
    }
  }

  /// Checks if a cooldown group is active (ticks remaining > 0).
  bool isOnCooldown(EntityId entity, int groupId) {
    return getTicksLeft(entity, groupId) > 0;
  }

  /// Decrements all cooldowns by 1 tick for all entities.
  /// Called by CooldownSystem each tick.
  void tickAll() {
    final count = denseEntities.length;
    for (var i = 0; i < count; i++) {
      for (var g = 0; g < kMaxCooldownGroups; g++) {
        final idx = i * kMaxCooldownGroups + g;
        if (_ticksLeft[idx] > 0) {
          _ticksLeft[idx] -= 1;
        }
      }
    }
  }

  // SparseSet overrides
  // ---------------------------------------------------------------------------

  @override
  void onDenseAdded(int denseIndex) {
    // Add kMaxCooldownGroups slots for new entity, all initialized to 0
    for (var g = 0; g < kMaxCooldownGroups; g++) {
      _ticksLeft.add(0);
    }
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    // Swap all group slots
    for (var g = 0; g < kMaxCooldownGroups; g++) {
      final ri = removeIndex * kMaxCooldownGroups + g;
      final li = lastIndex * kMaxCooldownGroups + g;
      _ticksLeft[ri] = _ticksLeft[li];
    }
    // Remove last kMaxCooldownGroups entries
    _ticksLeft.length -= kMaxCooldownGroups;
  }
}


===== FILE: lib/core/ecs/stores/damage_queue_store.dart =====
import '../../combat/damage.dart';
import '../../combat/damage_type.dart';
import '../../enemies/enemy_id.dart';
import '../../events/game_event.dart';
import '../../projectiles/projectile_id.dart';
import '../../weapons/weapon_proc.dart';
import '../entity_id.dart';

/// Flags stored alongside queued damage requests.
class DamageQueueFlags {
  static const int canceled = 1 << 0;
}

/// World-level queue for pending damage requests (SoA).
///
/// This queue is populated by hit resolution systems and processed by
/// [DamageMiddlewareSystem] and [DamageSystem].
class DamageQueueStore {
  final List<EntityId> target = <EntityId>[];
  final List<int> amount100 = <int>[];
  final List<int> critChanceBp = <int>[];
  final List<DamageType> damageType = <DamageType>[];
  final List<List<WeaponProc>> procs = <List<WeaponProc>>[];
  final List<DeathSourceKind> sourceKind = <DeathSourceKind>[];
  final List<EntityId?> sourceEntity = <EntityId?>[];
  final List<EnemyId?> sourceEnemyId = <EnemyId?>[];
  final List<ProjectileId?> sourceProjectileId = <ProjectileId?>[];
  final List<int> flags = <int>[];

  int get length => target.length;

  /// Adds a damage request, returning its index or -1 if ignored.
  int add(DamageRequest request) {
    if (request.amount100 <= 0) {
      return -1;
    }

    final index = target.length;
    target.add(request.target);
    amount100.add(request.amount100);
    critChanceBp.add(request.critChanceBp);
    damageType.add(request.damageType);
    procs.add(request.procs);
    sourceKind.add(request.sourceKind);
    sourceEntity.add(request.source);
    sourceEnemyId.add(request.sourceEnemyId);
    sourceProjectileId.add(request.sourceProjectileId);
    flags.add(0);
    return index;
  }

  void cancel(int index) {
    flags[index] |= DamageQueueFlags.canceled;
  }

  void clear() {
    target.clear();
    amount100.clear();
    critChanceBp.clear();
    damageType.clear();
    procs.clear();
    sourceKind.clear();
    sourceEntity.clear();
    sourceEnemyId.clear();
    sourceProjectileId.clear();
    flags.clear();
  }
}


===== FILE: lib/core/ecs/stores/death_state_store.dart =====
import '../../enemies/death_behavior.dart';
import '../entity_id.dart';
import '../sparse_set.dart';

class DeathStateDef {
  const DeathStateDef({
    required this.phase,
    this.deathStartTick = -1,
    this.despawnTick = -1,
    this.maxFallDespawnTick = -1,
  });

  final DeathPhase phase;
  final int deathStartTick;
  final int despawnTick;
  final int maxFallDespawnTick;
}

/// Per-entity death lifecycle state (enemy-only for now).
class DeathStateStore extends SparseSet {
  final List<DeathPhase> phase = <DeathPhase>[];
  final List<int> deathStartTick = <int>[];
  final List<int> despawnTick = <int>[];
  final List<int> maxFallDespawnTick = <int>[];

  void add(EntityId entity, DeathStateDef def) {
    final i = addEntity(entity);
    phase[i] = def.phase;
    deathStartTick[i] = def.deathStartTick;
    despawnTick[i] = def.despawnTick;
    maxFallDespawnTick[i] = def.maxFallDespawnTick;
  }

  @override
  void onDenseAdded(int denseIndex) {
    phase.add(DeathPhase.none);
    deathStartTick.add(-1);
    despawnTick.add(-1);
    maxFallDespawnTick.add(-1);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    phase[removeIndex] = phase[lastIndex];
    deathStartTick[removeIndex] = deathStartTick[lastIndex];
    despawnTick[removeIndex] = despawnTick[lastIndex];
    maxFallDespawnTick[removeIndex] = maxFallDespawnTick[lastIndex];

    phase.removeLast();
    deathStartTick.removeLast();
    despawnTick.removeLast();
    maxFallDespawnTick.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/enemies/enemy_store.dart =====
import '../../../enemies/enemy_id.dart';
import '../../../snapshots/enums.dart';
import '../../entity_id.dart';
import '../../sparse_set.dart';

class EnemyDef {
  const EnemyDef({
    required this.enemyId,
    this.facing = Facing.left,
  });

  final EnemyId enemyId;
  final Facing facing;
}

/// Minimal enemy marker + per-enemy state.
///
/// Indicates this entity is an enemy and which type it is.
/// Also holds facing direction.
class EnemyStore extends SparseSet {
  final List<EnemyId> enemyId = <EnemyId>[];
  final List<Facing> facing = <Facing>[];
  final List<int> lastMeleeTick = <int>[];
  final List<Facing> lastMeleeFacing = <Facing>[];
  final List<int> lastMeleeAnimTicks = <int>[];

  void add(EntityId entity, EnemyDef def) {
    final i = addEntity(entity);
    enemyId[i] = def.enemyId;
    facing[i] = def.facing;
    lastMeleeTick[i] = -1;
    lastMeleeFacing[i] = def.facing;
    lastMeleeAnimTicks[i] = 0;
  }

  @override
  void onDenseAdded(int denseIndex) {
    enemyId.add(EnemyId.unocoDemon);
    facing.add(Facing.left);
    lastMeleeTick.add(-1);
    lastMeleeFacing.add(Facing.left);
    lastMeleeAnimTicks.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    enemyId[removeIndex] = enemyId[lastIndex];
    facing[removeIndex] = facing[lastIndex];
    lastMeleeTick[removeIndex] = lastMeleeTick[lastIndex];
    lastMeleeFacing[removeIndex] = lastMeleeFacing[lastIndex];
    lastMeleeAnimTicks[removeIndex] = lastMeleeAnimTicks[lastIndex];

    enemyId.removeLast();
    facing.removeLast();
    lastMeleeTick.removeLast();
    lastMeleeFacing.removeLast();
    lastMeleeAnimTicks.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/enemies/engagement_intent_store.dart =====
import '../../entity_id.dart';
import '../../sparse_set.dart';

/// Engagement intent for melee enemies (desired slot + movement modifiers).
class EngagementIntentStore extends SparseSet {
  /// Desired target X for locomotion when not following a nav plan.
  final List<double> desiredTargetX = <double>[];

  /// Arrival slow radius used to dampen speed near the slot.
  final List<double> arrivalSlowRadiusX = <double>[];

  /// Speed multiplier for the current engagement state.
  final List<double> stateSpeedMul = <double>[];

  /// Speed scale to apply when chasing without a nav plan.
  final List<double> speedScale = <double>[];

  void add(EntityId entity) {
    final i = addEntity(entity);
    desiredTargetX[i] = 0.0;
    arrivalSlowRadiusX[i] = 0.0;
    stateSpeedMul[i] = 1.0;
    speedScale[i] = 1.0;
  }

  @override
  void onDenseAdded(int denseIndex) {
    desiredTargetX.add(0.0);
    arrivalSlowRadiusX.add(0.0);
    stateSpeedMul.add(1.0);
    speedScale.add(1.0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    desiredTargetX[removeIndex] = desiredTargetX[lastIndex];
    arrivalSlowRadiusX[removeIndex] = arrivalSlowRadiusX[lastIndex];
    stateSpeedMul[removeIndex] = stateSpeedMul[lastIndex];
    speedScale[removeIndex] = speedScale[lastIndex];

    desiredTargetX.removeLast();
    arrivalSlowRadiusX.removeLast();
    stateSpeedMul.removeLast();
    speedScale.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/enemies/flying_enemy_steering_store.dart =====
import '../../entity_id.dart';
import '../../sparse_set.dart';

class FlyingEnemySteeringDef {
  const FlyingEnemySteeringDef({
    required this.rngState,
  });

  final int rngState;
}

/// Per flying enemy steering state for deterministic hover behavior.
///
/// Holds RNG state and smoothed target ranges to make enemies wobble nicely.
class FlyingEnemySteeringStore extends SparseSet {
  final List<int> rngState = <int>[];
  final List<bool> initialized = <bool>[];
  final List<double> desiredRange = <double>[];
  final List<double> desiredRangeHoldLeftS = <double>[];
  final List<double> flightTargetAboveGround = <double>[];
  final List<double> flightTargetHoldLeftS = <double>[];

  void add(EntityId entity, FlyingEnemySteeringDef def) {
    final i = addEntity(entity);
    rngState[i] = def.rngState;
    initialized[i] = false;
    desiredRange[i] = 0.0;
    desiredRangeHoldLeftS[i] = 0.0;
    flightTargetAboveGround[i] = 0.0;
    flightTargetHoldLeftS[i] = 0.0;
  }

  @override
  void onDenseAdded(int denseIndex) {
    rngState.add(1);
    initialized.add(false);
    desiredRange.add(0.0);
    desiredRangeHoldLeftS.add(0.0);
    flightTargetAboveGround.add(0.0);
    flightTargetHoldLeftS.add(0.0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    rngState[removeIndex] = rngState[lastIndex];
    initialized[removeIndex] = initialized[lastIndex];
    desiredRange[removeIndex] = desiredRange[lastIndex];
    desiredRangeHoldLeftS[removeIndex] = desiredRangeHoldLeftS[lastIndex];
    flightTargetAboveGround[removeIndex] = flightTargetAboveGround[lastIndex];
    flightTargetHoldLeftS[removeIndex] = flightTargetHoldLeftS[lastIndex];

    rngState.removeLast();
    initialized.removeLast();
    desiredRange.removeLast();
    desiredRangeHoldLeftS.removeLast();
    flightTargetAboveGround.removeLast();
    flightTargetHoldLeftS.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/enemies/ground_enemy_chase_offset_store.dart =====
import '../../entity_id.dart';
import '../../sparse_set.dart';

class GroundEnemyChaseOffsetDef {
  const GroundEnemyChaseOffsetDef({
    required this.rngState,
  });

  final int rngState;
}

/// Per ground enemy chase offset state for deterministic path separation.
///
/// Ensures multiple enemies don't stack perfectly on top of one another while chasing.
class GroundEnemyChaseOffsetStore extends SparseSet {
  final List<int> rngState = <int>[];
  final List<double> chaseOffsetX = <double>[];
  final List<double> chaseSpeedScale = <double>[];
  final List<bool> initialized = <bool>[];

  void add(EntityId entity, GroundEnemyChaseOffsetDef def) {
    final i = addEntity(entity);
    rngState[i] = def.rngState;
    chaseOffsetX[i] = 0.0;
    chaseSpeedScale[i] = 1.0;
    initialized[i] = false;
  }

  @override
  void onDenseAdded(int denseIndex) {
    rngState.add(1);
    chaseOffsetX.add(0.0);
    chaseSpeedScale.add(1.0);
    initialized.add(false);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    rngState[removeIndex] = rngState[lastIndex];
    chaseOffsetX[removeIndex] = chaseOffsetX[lastIndex];
    chaseSpeedScale[removeIndex] = chaseSpeedScale[lastIndex];
    initialized[removeIndex] = initialized[lastIndex];

    rngState.removeLast();
    chaseOffsetX.removeLast();
    chaseSpeedScale.removeLast();
    initialized.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/enemies/melee_engagement_store.dart =====
import '../../entity_id.dart';
import '../../sparse_set.dart';

/// Engagement state for melee-focused enemies.
///
/// Keeps lightweight state so AI can avoid oscillating around the target and
/// apply different movement rules during strike/recover windows.
class MeleeEngagementStore extends SparseSet {
  /// Current engagement state.
  final List<MeleeEngagementState> state = <MeleeEngagementState>[];

  /// Remaining ticks in the current state (used for strike/recover windows).
  final List<int> ticksLeft = <int>[];

  /// Preferred side relative to the target (+1 right, -1 left, 0 unset).
  final List<int> preferredSide = <int>[];

  /// Tick when the current strike started (edge-trigger).
  ///
  /// Used to start telegraph animations once and schedule future hit ticks.
  final List<int> strikeStartTick = <int>[];

  /// Tick when the melee hitbox should spawn for the current strike.
  final List<int> plannedHitTick = <int>[];

  void add(EntityId entity) {
    final i = addEntity(entity);
    state[i] = MeleeEngagementState.approach;
    ticksLeft[i] = 0;
    preferredSide[i] = 0;
    strikeStartTick[i] = -1;
    plannedHitTick[i] = -1;
  }

  @override
  void onDenseAdded(int denseIndex) {
    state.add(MeleeEngagementState.approach);
    ticksLeft.add(0);
    preferredSide.add(0);
    strikeStartTick.add(-1);
    plannedHitTick.add(-1);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    state[removeIndex] = state[lastIndex];
    ticksLeft[removeIndex] = ticksLeft[lastIndex];
    preferredSide[removeIndex] = preferredSide[lastIndex];
    strikeStartTick[removeIndex] = strikeStartTick[lastIndex];
    plannedHitTick[removeIndex] = plannedHitTick[lastIndex];

    state.removeLast();
    ticksLeft.removeLast();
    preferredSide.removeLast();
    strikeStartTick.removeLast();
    plannedHitTick.removeLast();
  }
}

enum MeleeEngagementState {
  approach,
  engage,
  strike,
  recover,
}


===== FILE: lib/core/ecs/stores/enemies/nav_intent_store.dart =====
import '../../entity_id.dart';
import '../../sparse_set.dart';

/// Navigation intent produced by pathfinding for ground enemies.
class NavIntentStore extends SparseSet {
  /// Target X used for path planning (player or predicted landing).
  final List<double> navTargetX = <double>[];

  /// Desired X from the navigator (immediate movement goal).
  final List<double> desiredX = <double>[];

  /// Whether the enemy should jump this tick.
  final List<bool> jumpNow = <bool>[];

  /// Whether a valid navigation plan exists.
  final List<bool> hasPlan = <bool>[];

  /// Committed move direction for plan execution (-1, 0, 1).
  final List<int> commitMoveDirX = <int>[];

  /// Safe surface bounds for no-plan movement.
  final List<double> safeSurfaceMinX = <double>[];
  final List<double> safeSurfaceMaxX = <double>[];
  final List<bool> hasSafeSurface = <bool>[];

  void add(EntityId entity) {
    final i = addEntity(entity);
    navTargetX[i] = 0.0;
    desiredX[i] = 0.0;
    jumpNow[i] = false;
    hasPlan[i] = false;
    commitMoveDirX[i] = 0;
    safeSurfaceMinX[i] = 0.0;
    safeSurfaceMaxX[i] = 0.0;
    hasSafeSurface[i] = false;
  }

  @override
  void onDenseAdded(int denseIndex) {
    navTargetX.add(0.0);
    desiredX.add(0.0);
    jumpNow.add(false);
    hasPlan.add(false);
    commitMoveDirX.add(0);
    safeSurfaceMinX.add(0.0);
    safeSurfaceMaxX.add(0.0);
    hasSafeSurface.add(false);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    navTargetX[removeIndex] = navTargetX[lastIndex];
    desiredX[removeIndex] = desiredX[lastIndex];
    jumpNow[removeIndex] = jumpNow[lastIndex];
    hasPlan[removeIndex] = hasPlan[lastIndex];
    commitMoveDirX[removeIndex] = commitMoveDirX[lastIndex];
    safeSurfaceMinX[removeIndex] = safeSurfaceMinX[lastIndex];
    safeSurfaceMaxX[removeIndex] = safeSurfaceMaxX[lastIndex];
    hasSafeSurface[removeIndex] = hasSafeSurface[lastIndex];

    navTargetX.removeLast();
    desiredX.removeLast();
    jumpNow.removeLast();
    hasPlan.removeLast();
    commitMoveDirX.removeLast();
    safeSurfaceMinX.removeLast();
    safeSurfaceMaxX.removeLast();
    hasSafeSurface.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/enemies/surface_nav_state_store.dart =====
import '../../../navigation/types/surface_id.dart';
import '../../entity_id.dart';
import '../../sparse_set.dart';

/// Per-entity pathfinding state.
///
/// Tracks the current surface segment, the target segment, and the calculated path edges.
/// Used by `SurfaceNavigationSystem` to move ground enemies.
class SurfaceNavStateStore extends SparseSet {
  final List<int> graphVersion = <int>[];
  final List<int> repathTicksLeft = <int>[];
  final List<int> currentSurfaceId = <int>[];
  final List<int> lastGroundSurfaceId = <int>[];
  final List<int> targetSurfaceId = <int>[];
  final List<int> activeEdgeIndex = <int>[];
  final List<int> pathCursor = <int>[];
  final List<List<int>> pathEdges = <List<int>>[];

  void add(EntityId entity) {
    addEntity(entity);
  }

  @override
  void onDenseAdded(int denseIndex) {
    graphVersion.add(-1);
    repathTicksLeft.add(0);
    currentSurfaceId.add(surfaceIdUnknown);
    lastGroundSurfaceId.add(surfaceIdUnknown);
    targetSurfaceId.add(surfaceIdUnknown);
    activeEdgeIndex.add(-1);
    pathCursor.add(0);
    pathEdges.add(<int>[]);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    graphVersion[removeIndex] = graphVersion[lastIndex];
    repathTicksLeft[removeIndex] = repathTicksLeft[lastIndex];
    currentSurfaceId[removeIndex] = currentSurfaceId[lastIndex];
    lastGroundSurfaceId[removeIndex] = lastGroundSurfaceId[lastIndex];
    targetSurfaceId[removeIndex] = targetSurfaceId[lastIndex];
    activeEdgeIndex[removeIndex] = activeEdgeIndex[lastIndex];
    pathCursor[removeIndex] = pathCursor[lastIndex];
    pathEdges[removeIndex] = pathEdges[lastIndex];

    graphVersion.removeLast();
    repathTicksLeft.removeLast();
    currentSurfaceId.removeLast();
    lastGroundSurfaceId.removeLast();
    targetSurfaceId.removeLast();
    activeEdgeIndex.removeLast();
    pathCursor.removeLast();
    pathEdges.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/faction_store.dart =====
import '../../combat/faction.dart';
import '../entity_id.dart';
import '../sparse_set.dart';

class FactionDef {
  const FactionDef({required this.faction});

  final Faction faction;
}

class FactionStore extends SparseSet {
  final List<Faction> faction = <Faction>[];

  void add(EntityId entity, FactionDef def) {
    final i = addEntity(entity);
    faction[i] = def.faction;
  }

  @override
  void onDenseAdded(int denseIndex) {
    // Default to player if not specified.
    faction.add(Faction.player);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    faction[removeIndex] = faction[lastIndex];
    faction.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/health_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

class HealthDef {
  const HealthDef({
    required this.hp,
    required this.hpMax,
    required this.regenPerSecond100,
  });

  /// Fixed-point: 100 = 1.0
  final int hp;
  final int hpMax;
  final int regenPerSecond100;
}

/// Tracks current and max hit points for damageable entities.
class HealthStore extends SparseSet {
  /// Fixed-point: 100 = 1.0
  final List<int> hp = <int>[];
  final List<int> hpMax = <int>[];
  final List<int> regenPerSecond100 = <int>[];
  final List<int> regenAccumulator = <int>[];

  void add(EntityId entity, HealthDef def) {
    final i = addEntity(entity);
    hp[i] = def.hp;
    hpMax[i] = def.hpMax;
    regenPerSecond100[i] = def.regenPerSecond100;
    regenAccumulator[i] = 0;
  }

  @override
  void onDenseAdded(int denseIndex) {
    hp.add(0);
    hpMax.add(0);
    regenPerSecond100.add(0);
    regenAccumulator.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    hp[removeIndex] = hp[lastIndex];
    hpMax[removeIndex] = hpMax[lastIndex];
    regenPerSecond100[removeIndex] = regenPerSecond100[lastIndex];
    regenAccumulator[removeIndex] = regenAccumulator[lastIndex];

    hp.removeLast();
    hpMax.removeLast();
    regenPerSecond100.removeLast();
    regenAccumulator.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/hit_once_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

/// Tracks unique hit targets for a single strike instance (e.g. one swing).
///
/// **Optimization**: Uses inline fields (`hit0`...`hit3`) instead of a `List`
/// to avoid allocation per entity per frame. Saturation limit is 4 targets.
class HitOnceStore extends SparseSet {
  final List<int> count = <int>[];
  final List<EntityId> hit0 = <EntityId>[];
  final List<EntityId> hit1 = <EntityId>[];
  final List<EntityId> hit2 = <EntityId>[];
  final List<EntityId> hit3 = <EntityId>[];

  void add(EntityId entity) {
    addEntity(entity);
  }

  bool hasHit(EntityId entity, EntityId target) {
    final i = indexOf(entity);
    final c = count[i];
    if (c > 4) return true; // saturated: treat as "already hit everything"
    if (c <= 0) return false;
    if (hit0[i] == target) return true;
    if (c <= 1) return false;
    if (hit1[i] == target) return true;
    if (c <= 2) return false;
    if (hit2[i] == target) return true;
    if (c <= 3) return false;
    return hit3[i] == target;
  }

  void markHit(EntityId entity, EntityId target) {
    final i = indexOf(entity);
    var c = count[i];
    if (c > 4) return; // already saturated
    if (c <= 0) {
      hit0[i] = target;
      count[i] = 1;
      return;
    }
    if (c == 1) {
      hit1[i] = target;
      count[i] = 2;
      return;
    }
    if (c == 2) {
      hit2[i] = target;
      count[i] = 3;
      return;
    }
    if (c == 3) {
      hit3[i] = target;
      count[i] = 4;
      return;
    }
    // We don't expect more than 4 hits per swing.
    //
    // IMPORTANT (determinism + safety): once saturated, treat as "already hit"
    // for any target so a single swing cannot multi-hit due to overflow.
    count[i] = 5;
  }

  @override
  void onDenseAdded(int denseIndex) {
    count.add(0);
    hit0.add(0);
    hit1.add(0);
    hit2.add(0);
    hit3.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    count[removeIndex] = count[lastIndex];
    hit0[removeIndex] = hit0[lastIndex];
    hit1[removeIndex] = hit1[lastIndex];
    hit2[removeIndex] = hit2[lastIndex];
    hit3[removeIndex] = hit3[lastIndex];

    count.removeLast();
    hit0.removeLast();
    hit1.removeLast();
    hit2.removeLast();
    hit3.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/hitbox_store.dart =====
import '../../combat/damage_type.dart';
import '../../combat/faction.dart';
import '../../weapons/weapon_proc.dart';
import '../entity_id.dart';
import '../sparse_set.dart';

class HitboxDef {
  const HitboxDef({
    required this.owner,
    required this.faction,
    required this.damage100,
    this.critChanceBp = 0,
    required this.damageType,
    this.procs = const <WeaponProc>[],
    required this.halfX,
    required this.halfY,
    required this.offsetX,
    required this.offsetY,
    required this.dirX,
    required this.dirY,
  });

  final EntityId owner;
  final Faction faction;

  /// Fixed-point: 100 = 1.0
  final int damage100;

  /// Critical strike chance in basis points (100 = 1%).
  final int critChanceBp;
  final DamageType damageType;
  final List<WeaponProc> procs;
  final double halfX;
  final double halfY;
  final double offsetX;
  final double offsetY;
  final double dirX;
  final double dirY;
}

/// Short-lived damage hitbox used by melee strikes and area effects.
///
/// These entities usually exist for only a few frames (strike windows).
/// They are queried by `HitboxDamageSystem`.
class HitboxStore extends SparseSet {
  final List<EntityId> owner = <EntityId>[];
  final List<Faction> faction = <Faction>[];

  /// Fixed-point: 100 = 1.0
  final List<int> damage100 = <int>[];
  final List<int> critChanceBp = <int>[];
  final List<DamageType> damageType = <DamageType>[];
  final List<List<WeaponProc>> procs = <List<WeaponProc>>[];
  final List<double> halfX = <double>[];
  final List<double> halfY = <double>[];
  final List<double> offsetX = <double>[];
  final List<double> offsetY = <double>[];
  final List<double> dirX = <double>[];
  final List<double> dirY = <double>[];

  void add(EntityId entity, HitboxDef def) {
    final i = addEntity(entity);
    owner[i] = def.owner;
    faction[i] = def.faction;
    damage100[i] = def.damage100;
    critChanceBp[i] = def.critChanceBp;
    damageType[i] = def.damageType;
    procs[i] = def.procs;
    halfX[i] = def.halfX;
    halfY[i] = def.halfY;
    offsetX[i] = def.offsetX;
    offsetY[i] = def.offsetY;
    dirX[i] = def.dirX;
    dirY[i] = def.dirY;
  }

  @override
  void onDenseAdded(int denseIndex) {
    owner.add(0);
    faction.add(Faction.player);
    damage100.add(0);
    critChanceBp.add(0);
    damageType.add(DamageType.physical);
    procs.add(const <WeaponProc>[]);
    halfX.add(0);
    halfY.add(0);
    offsetX.add(0);
    offsetY.add(0);
    dirX.add(1.0);
    dirY.add(0.0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    owner[removeIndex] = owner[lastIndex];
    faction[removeIndex] = faction[lastIndex];
    damage100[removeIndex] = damage100[lastIndex];
    critChanceBp[removeIndex] = critChanceBp[lastIndex];
    damageType[removeIndex] = damageType[lastIndex];
    procs[removeIndex] = procs[lastIndex];
    halfX[removeIndex] = halfX[lastIndex];
    halfY[removeIndex] = halfY[lastIndex];
    offsetX[removeIndex] = offsetX[lastIndex];
    offsetY[removeIndex] = offsetY[lastIndex];
    dirX[removeIndex] = dirX[lastIndex];
    dirY[removeIndex] = dirY[lastIndex];

    owner.removeLast();
    faction.removeLast();
    damage100.removeLast();
    critChanceBp.removeLast();
    damageType.removeLast();
    procs.removeLast();
    halfX.removeLast();
    halfY.removeLast();
    offsetX.removeLast();
    offsetY.removeLast();
    dirX.removeLast();
    dirY.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/lifetime_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

class LifetimeDef {
  const LifetimeDef({required this.ticksLeft});

  final int ticksLeft;
}

/// Tracks entity lifetime in ticks. Entity is despawned when `ticksLeft <= 0`.
class LifetimeStore extends SparseSet {
  final List<int> ticksLeft = <int>[];

  void add(EntityId entity, LifetimeDef def) {
    final i = addEntity(entity);
    ticksLeft[i] = def.ticksLeft;
  }

  @override
  void onDenseAdded(int denseIndex) {
    ticksLeft.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    ticksLeft[removeIndex] = ticksLeft[lastIndex];
    ticksLeft.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/mana_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

class ManaDef {
  const ManaDef({
    required this.mana,
    required this.manaMax,
    required this.regenPerSecond100,
  });

  /// Fixed-point: 100 = 1.0
  final int mana;
  final int manaMax;
  final int regenPerSecond100;
}

/// Tracks current and max mana for spellcasters (Player).
class ManaStore extends SparseSet {
  /// Fixed-point: 100 = 1.0
  final List<int> mana = <int>[];
  final List<int> manaMax = <int>[];
  final List<int> regenPerSecond100 = <int>[];
  final List<int> regenAccumulator = <int>[];

  void add(EntityId entity, ManaDef def) {
    final i = addEntity(entity);
    mana[i] = def.mana;
    manaMax[i] = def.manaMax;
    regenPerSecond100[i] = def.regenPerSecond100;
    regenAccumulator[i] = 0;
  }

  @override
  void onDenseAdded(int denseIndex) {
    mana.add(0);
    manaMax.add(0);
    regenPerSecond100.add(0);
    regenAccumulator.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    mana[removeIndex] = mana[lastIndex];
    manaMax[removeIndex] = manaMax[lastIndex];
    regenPerSecond100[removeIndex] = regenPerSecond100[lastIndex];
    regenAccumulator[removeIndex] = regenAccumulator[lastIndex];

    mana.removeLast();
    manaMax.removeLast();
    regenPerSecond100.removeLast();
    regenAccumulator.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/melee_intent_store.dart =====
import '../../abilities/ability_def.dart';
import '../../combat/damage_type.dart';
import '../../weapons/weapon_proc.dart';
import '../entity_id.dart';
import '../sparse_set.dart';

class MeleeIntentDef {
  const MeleeIntentDef({
    required this.abilityId,
    required this.slot,
    required this.damage100,
    this.critChanceBp = 0,
    required this.damageType,
    this.procs = const <WeaponProc>[],
    required this.halfX,
    required this.halfY,
    required this.offsetX,
    required this.offsetY,
    required this.dirX,
    required this.dirY,
    required this.commitTick,
    required this.windupTicks,
    required this.activeTicks,
    required this.recoveryTicks,
    required this.cooldownTicks,
    required this.staminaCost100,
    required this.cooldownGroupId,
    required this.tick,
  });

  final AbilityKey abilityId;
  final AbilitySlot slot;

  /// Fixed-point: 100 = 1.0
  final int damage100;

  /// Critical strike chance in basis points (100 = 1%).
  final int critChanceBp;
  final DamageType damageType;
  final List<WeaponProc> procs;
  final double halfX;
  final double halfY;
  final double offsetX;
  final double offsetY;
  final double dirX;
  final double dirY;

  /// Tick the ability was committed (costs/cooldown start).
  final int commitTick;

  /// Windup duration (ticks) before hitbox spawns.
  final int windupTicks;
  final int activeTicks;

  /// Recovery duration (ticks) after active window.
  final int recoveryTicks;
  final int cooldownTicks;

  /// Fixed-point: 100 = 1.0
  final int staminaCost100;
  final int cooldownGroupId;

  /// Tick stamp for effect execution.
  ///
  /// Use `-1` for "no intent". The effect spawns only when `tick == currentTick`.
  final int tick;
}

/// Per-entity "perform a melee strike this tick" intent.
///
/// This is written by player/enemy intent writers and consumed by `MeleeStrikeSystem`.
///
/// **Usage**: Persistent component. Intents are set via `set()` with a `tick` stamp.
/// Old intents are ignored if `tick` matches current game tick.
class MeleeIntentStore extends SparseSet {
  final List<AbilityKey?> abilityId = <AbilityKey?>[];
  final List<AbilitySlot> slot = <AbilitySlot>[];

  /// Fixed-point: 100 = 1.0
  final List<int> damage100 = <int>[];
  final List<int> critChanceBp = <int>[];
  final List<DamageType> damageType = <DamageType>[];
  final List<List<WeaponProc>> procs = <List<WeaponProc>>[];
  final List<double> halfX = <double>[];
  final List<double> halfY = <double>[];
  final List<double> offsetX = <double>[];
  final List<double> offsetY = <double>[];
  final List<double> dirX = <double>[];
  final List<double> dirY = <double>[];
  final List<int> commitTick = <int>[];
  final List<int> windupTicks = <int>[];
  final List<int> activeTicks = <int>[];
  final List<int> recoveryTicks = <int>[];
  final List<int> cooldownTicks = <int>[];

  /// Fixed-point: 100 = 1.0
  final List<int> staminaCost100 = <int>[];
  final List<int> cooldownGroupId = <int>[];
  final List<int> tick = <int>[];

  void add(EntityId entity) {
    addEntity(entity);
  }

  void set(EntityId entity, MeleeIntentDef def) {
    assert(
      has(entity),
      'MeleeIntentStore.set called for entity without MeleeIntentStore; add the component at spawn time.',
    );
    final i = indexOf(entity);
    abilityId[i] = def.abilityId;
    slot[i] = def.slot;
    damage100[i] = def.damage100;
    critChanceBp[i] = def.critChanceBp;
    damageType[i] = def.damageType;
    procs[i] = def.procs;
    halfX[i] = def.halfX;
    halfY[i] = def.halfY;
    offsetX[i] = def.offsetX;
    offsetY[i] = def.offsetY;
    dirX[i] = def.dirX;
    dirY[i] = def.dirY;
    commitTick[i] = def.commitTick;
    windupTicks[i] = def.windupTicks;
    activeTicks[i] = def.activeTicks;
    recoveryTicks[i] = def.recoveryTicks;
    cooldownTicks[i] = def.cooldownTicks;
    staminaCost100[i] = def.staminaCost100;
    cooldownGroupId[i] = def.cooldownGroupId;
    tick[i] = def.tick;
  }

  @override
  void onDenseAdded(int denseIndex) {
    abilityId.add(null);
    slot.add(AbilitySlot.primary);
    damage100.add(0);
    critChanceBp.add(0);
    damageType.add(DamageType.physical);
    procs.add(const <WeaponProc>[]);
    halfX.add(0.0);
    halfY.add(0.0);
    offsetX.add(0.0);
    offsetY.add(0.0);
    dirX.add(1.0);
    dirY.add(0.0);
    commitTick.add(-1);
    windupTicks.add(0);
    activeTicks.add(0);
    recoveryTicks.add(0);
    cooldownTicks.add(0);
    staminaCost100.add(0);
    cooldownGroupId.add(0);
    tick.add(-1);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    abilityId[removeIndex] = abilityId[lastIndex];
    slot[removeIndex] = slot[lastIndex];
    damage100[removeIndex] = damage100[lastIndex];
    critChanceBp[removeIndex] = critChanceBp[lastIndex];
    damageType[removeIndex] = damageType[lastIndex];
    procs[removeIndex] = procs[lastIndex];
    halfX[removeIndex] = halfX[lastIndex];
    halfY[removeIndex] = halfY[lastIndex];
    offsetX[removeIndex] = offsetX[lastIndex];
    offsetY[removeIndex] = offsetY[lastIndex];
    dirX[removeIndex] = dirX[lastIndex];
    dirY[removeIndex] = dirY[lastIndex];
    commitTick[removeIndex] = commitTick[lastIndex];
    windupTicks[removeIndex] = windupTicks[lastIndex];
    activeTicks[removeIndex] = activeTicks[lastIndex];
    recoveryTicks[removeIndex] = recoveryTicks[lastIndex];
    cooldownTicks[removeIndex] = cooldownTicks[lastIndex];
    staminaCost100[removeIndex] = staminaCost100[lastIndex];
    cooldownGroupId[removeIndex] = cooldownGroupId[lastIndex];
    tick[removeIndex] = tick[lastIndex];

    abilityId.removeLast();
    slot.removeLast();
    damage100.removeLast();
    critChanceBp.removeLast();
    damageType.removeLast();
    procs.removeLast();
    halfX.removeLast();
    halfY.removeLast();
    offsetX.removeLast();
    offsetY.removeLast();
    dirX.removeLast();
    dirY.removeLast();
    commitTick.removeLast();
    windupTicks.removeLast();
    activeTicks.removeLast();
    recoveryTicks.removeLast();
    cooldownTicks.removeLast();
    staminaCost100.removeLast();
    cooldownGroupId.removeLast();
    tick.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/mobility_impact_state_store.dart =====
import '../../abilities/ability_def.dart';
import '../entity_id.dart';

/// Tracks per-source mobility contact hit state for one active ability lifecycle.
///
/// This supports mobility impact hit policies without spawning synthetic hitboxes.
class MobilityImpactStateStore {
  final List<EntityId> denseEntities = <EntityId>[];
  final Map<EntityId, int> _sparse = <EntityId, int>{};

  /// Active ability startTick currently tracked for each source entity.
  final List<int> activationStartTick = <int>[];

  /// For [HitPolicy.once]: whether one contact has already been consumed.
  final List<bool> consumedOnce = <bool>[];

  /// For [HitPolicy.oncePerTarget]: compact tracked target set count.
  final List<int> hitCount = <int>[];
  final List<EntityId> hit0 = <EntityId>[];
  final List<EntityId> hit1 = <EntityId>[];
  final List<EntityId> hit2 = <EntityId>[];
  final List<EntityId> hit3 = <EntityId>[];
  final List<EntityId> hit4 = <EntityId>[];
  final List<EntityId> hit5 = <EntityId>[];
  final List<EntityId> hit6 = <EntityId>[];
  final List<EntityId> hit7 = <EntityId>[];

  int indexOfOrAdd(EntityId entity) {
    final existing = _sparse[entity];
    if (existing != null) return existing;
    final i = denseEntities.length;
    denseEntities.add(entity);
    _sparse[entity] = i;
    activationStartTick.add(-1);
    consumedOnce.add(false);
    hitCount.add(0);
    hit0.add(0);
    hit1.add(0);
    hit2.add(0);
    hit3.add(0);
    hit4.add(0);
    hit5.add(0);
    hit6.add(0);
    hit7.add(0);
    return i;
  }

  /// Returns true if the contact should apply according to [hitPolicy].
  bool registerImpact({
    required EntityId source,
    required EntityId target,
    required int activationTick,
    required HitPolicy hitPolicy,
  }) {
    final i = indexOfOrAdd(source);
    if (activationStartTick[i] != activationTick) {
      _resetActivation(i, activationTick);
    }

    switch (hitPolicy) {
      case HitPolicy.everyTick:
        return true;
      case HitPolicy.once:
        if (consumedOnce[i]) return false;
        consumedOnce[i] = true;
        return true;
      case HitPolicy.oncePerTarget:
        if (_hasHit(i, target)) return false;
        _markHit(i, target);
        return true;
    }
  }

  void _resetActivation(int index, int activationTick) {
    activationStartTick[index] = activationTick;
    consumedOnce[index] = false;
    hitCount[index] = 0;
  }

  bool _hasHit(int index, EntityId target) {
    final c = hitCount[index];
    if (c > _maxTrackedTargets) return true; // saturated
    if (c <= 0) return false;
    if (hit0[index] == target) return true;
    if (c <= 1) return false;
    if (hit1[index] == target) return true;
    if (c <= 2) return false;
    if (hit2[index] == target) return true;
    if (c <= 3) return false;
    if (hit3[index] == target) return true;
    if (c <= 4) return false;
    if (hit4[index] == target) return true;
    if (c <= 5) return false;
    if (hit5[index] == target) return true;
    if (c <= 6) return false;
    if (hit6[index] == target) return true;
    if (c <= 7) return false;
    return hit7[index] == target;
  }

  void _markHit(int index, EntityId target) {
    final c = hitCount[index];
    if (c > _maxTrackedTargets) return;
    if (c <= 0) {
      hit0[index] = target;
      hitCount[index] = 1;
      return;
    }
    if (c == 1) {
      hit1[index] = target;
      hitCount[index] = 2;
      return;
    }
    if (c == 2) {
      hit2[index] = target;
      hitCount[index] = 3;
      return;
    }
    if (c == 3) {
      hit3[index] = target;
      hitCount[index] = 4;
      return;
    }
    if (c == 4) {
      hit4[index] = target;
      hitCount[index] = 5;
      return;
    }
    if (c == 5) {
      hit5[index] = target;
      hitCount[index] = 6;
      return;
    }
    if (c == 6) {
      hit6[index] = target;
      hitCount[index] = 7;
      return;
    }
    if (c == 7) {
      hit7[index] = target;
      hitCount[index] = 8;
      return;
    }
    hitCount[index] = _maxTrackedTargets + 1;
  }

  void removeEntity(EntityId entity) {
    final i = _sparse.remove(entity);
    if (i == null) return;

    final last = denseEntities.length - 1;
    if (i != last) {
      final moved = denseEntities[last];
      denseEntities[i] = moved;
      _sparse[moved] = i;
      activationStartTick[i] = activationStartTick[last];
      consumedOnce[i] = consumedOnce[last];
      hitCount[i] = hitCount[last];
      hit0[i] = hit0[last];
      hit1[i] = hit1[last];
      hit2[i] = hit2[last];
      hit3[i] = hit3[last];
      hit4[i] = hit4[last];
      hit5[i] = hit5[last];
      hit6[i] = hit6[last];
      hit7[i] = hit7[last];
    }

    denseEntities.removeLast();
    activationStartTick.removeLast();
    consumedOnce.removeLast();
    hitCount.removeLast();
    hit0.removeLast();
    hit1.removeLast();
    hit2.removeLast();
    hit3.removeLast();
    hit4.removeLast();
    hit5.removeLast();
    hit6.removeLast();
    hit7.removeLast();
  }

  static const int _maxTrackedTargets = 8;
}


===== FILE: lib/core/ecs/stores/mobility_intent_store.dart =====
import '../../abilities/ability_def.dart';
import '../entity_id.dart';
import '../sparse_set.dart';

class MobilityIntentDef {
  const MobilityIntentDef({
    required this.abilityId,
    required this.slot,
    required this.dirX,
    required this.dirY,
    required this.speedScaleBp,
    required this.mobilitySpeedX,
    required this.commitTick,
    required this.windupTicks,
    required this.activeTicks,
    required this.recoveryTicks,
    required this.cooldownTicks,
    required this.cooldownGroupId,
    required this.staminaCost100,
    required this.tick,
  });

  final AbilityKey abilityId;
  final AbilitySlot slot;

  /// Direction of the mobility action (normalized X).
  final double dirX;

  /// Direction of the mobility action (normalized Y).
  final double dirY;

  /// Mobility speed scale in basis points (`10000 == 1.0x`).
  final int speedScaleBp;

  /// Horizontal speed in world-units/second for this mobility ability.
  final double mobilitySpeedX;

  /// Tick the ability was committed (costs/cooldown start).
  final int commitTick;

  /// Windup duration (ticks) before movement starts.
  final int windupTicks;
  final int activeTicks;

  /// Recovery duration (ticks) after active window.
  final int recoveryTicks;
  final int cooldownTicks;
  final int cooldownGroupId;

  /// Fixed-point: 100 = 1.0
  final int staminaCost100;

  /// Tick stamp for movement execution.
  ///
  /// Use `-1` for "no intent". The effect triggers only when
  /// `tick == currentTick`.
  final int tick;
}

/// Per-entity "perform a mobility action this tick" intent.
///
/// Written by [AbilityActivationSystem], consumed by [MobilitySystem].
class MobilityIntentStore extends SparseSet {
  final List<AbilityKey> abilityId = <AbilityKey>[];
  final List<AbilitySlot> slot = <AbilitySlot>[];
  final List<double> dirX = <double>[];
  final List<double> dirY = <double>[];
  final List<int> speedScaleBp = <int>[];
  final List<double> mobilitySpeedX = <double>[];
  final List<int> commitTick = <int>[];
  final List<int> windupTicks = <int>[];
  final List<int> activeTicks = <int>[];
  final List<int> recoveryTicks = <int>[];
  final List<int> cooldownTicks = <int>[];
  final List<int> cooldownGroupId = <int>[];

  /// Fixed-point: 100 = 1.0
  final List<int> staminaCost100 = <int>[];
  final List<int> tick = <int>[];

  void add(EntityId entity) {
    addEntity(entity);
  }

  void set(EntityId entity, MobilityIntentDef def) {
    assert(
      has(entity),
      'MobilityIntentStore.set called for entity without MobilityIntentStore; add the component at spawn time.',
    );
    final i = indexOf(entity);
    abilityId[i] = def.abilityId;
    slot[i] = def.slot;
    dirX[i] = def.dirX;
    dirY[i] = def.dirY;
    speedScaleBp[i] = def.speedScaleBp;
    mobilitySpeedX[i] = def.mobilitySpeedX;
    commitTick[i] = def.commitTick;
    windupTicks[i] = def.windupTicks;
    activeTicks[i] = def.activeTicks;
    recoveryTicks[i] = def.recoveryTicks;
    cooldownTicks[i] = def.cooldownTicks;
    cooldownGroupId[i] = def.cooldownGroupId;
    staminaCost100[i] = def.staminaCost100;
    tick[i] = def.tick;
  }

  @override
  void onDenseAdded(int denseIndex) {
    abilityId.add('eloise.dash');
    slot.add(AbilitySlot.mobility);
    dirX.add(1.0);
    dirY.add(0.0);
    speedScaleBp.add(10000);
    mobilitySpeedX.add(0.0);
    commitTick.add(-1);
    windupTicks.add(0);
    activeTicks.add(0);
    recoveryTicks.add(0);
    cooldownTicks.add(0);
    cooldownGroupId.add(0);
    staminaCost100.add(0);
    tick.add(-1);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    abilityId[removeIndex] = abilityId[lastIndex];
    slot[removeIndex] = slot[lastIndex];
    dirX[removeIndex] = dirX[lastIndex];
    dirY[removeIndex] = dirY[lastIndex];
    speedScaleBp[removeIndex] = speedScaleBp[lastIndex];
    mobilitySpeedX[removeIndex] = mobilitySpeedX[lastIndex];
    commitTick[removeIndex] = commitTick[lastIndex];
    windupTicks[removeIndex] = windupTicks[lastIndex];
    activeTicks[removeIndex] = activeTicks[lastIndex];
    recoveryTicks[removeIndex] = recoveryTicks[lastIndex];
    cooldownTicks[removeIndex] = cooldownTicks[lastIndex];
    cooldownGroupId[removeIndex] = cooldownGroupId[lastIndex];
    staminaCost100[removeIndex] = staminaCost100[lastIndex];
    tick[removeIndex] = tick[lastIndex];

    abilityId.removeLast();
    slot.removeLast();
    dirX.removeLast();
    dirY.removeLast();
    speedScaleBp.removeLast();
    mobilitySpeedX.removeLast();
    commitTick.removeLast();
    windupTicks.removeLast();
    activeTicks.removeLast();
    recoveryTicks.removeLast();
    cooldownTicks.removeLast();
    cooldownGroupId.removeLast();
    staminaCost100.removeLast();
    tick.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/parry_consume_store.dart =====
import '../entity_id.dart';

/// Tracks per-entity parry consumption for the current activation.
/// We key by the active-ability startTick, so re-activations reset automatically.
class ParryConsumeStore {
  final List<EntityId> denseEntities = <EntityId>[];
  final Map<EntityId, int> _sparse = <EntityId, int>{};

  /// Last parry activation startTick consumed.
  final List<int> consumedStartTick = <int>[];

  bool has(EntityId e) => _sparse.containsKey(e);

  int? tryIndexOf(EntityId e) => _sparse[e];

  int indexOfOrAdd(EntityId e) {
    final existing = _sparse[e];
    if (existing != null) return existing;
    final i = denseEntities.length;
    denseEntities.add(e);
    _sparse[e] = i;
    consumedStartTick.add(-1);
    return i;
  }

  void removeEntity(EntityId e) {
    final i = _sparse.remove(e);
    if (i == null) return;
    final last = denseEntities.length - 1;
    if (i != last) {
      final moved = denseEntities[last];
      denseEntities[i] = moved;
      _sparse[moved] = i;
      consumedStartTick[i] = consumedStartTick[last];
    }
    denseEntities.removeLast();
    consumedStartTick.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/player/gravity_control_store.dart =====
import '../../entity_id.dart';
import '../../sparse_set.dart';

/// Tracks entities that are temporarily ignoring global gravity.
///
/// Used by movement skills (e.g. Dash) to keep the player straight.
/// Entities are removed from this store when `suppressGravityTicksLeft` hits 0.
class GravityControlStore extends SparseSet {
  final List<int> suppressGravityTicksLeft = <int>[];

  void setSuppressForTicks(EntityId entity, int ticks) {
    if (ticks <= 0) {
      removeEntity(entity);
      return;
    }

    final i = addEntity(entity);
    suppressGravityTicksLeft[i] = ticks;
  }

  @override
  void onDenseAdded(int denseIndex) {
    suppressGravityTicksLeft.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    suppressGravityTicksLeft[removeIndex] = suppressGravityTicksLeft[lastIndex];
    suppressGravityTicksLeft.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/player/invulnerability_store.dart =====
import '../../entity_id.dart';
import '../../sparse_set.dart';

class InvulnerabilityDef {
  const InvulnerabilityDef({this.ticksLeft = 0});

  final int ticksLeft;
}

/// Per-entity invulnerability window after taking damage.
///
/// This store is only attached to the player (no enemy i-frames).
class InvulnerabilityStore extends SparseSet {
  final List<int> ticksLeft = <int>[];

  void add(EntityId entity, [InvulnerabilityDef def = const InvulnerabilityDef()]) {
    final i = addEntity(entity);
    ticksLeft[i] = def.ticksLeft;
  }

  @override
  void onDenseAdded(int denseIndex) {
    ticksLeft.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    ticksLeft[removeIndex] = ticksLeft[lastIndex];
    ticksLeft.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/player/jump_state_store.dart =====
import '../../entity_id.dart';
import '../../sparse_set.dart';

/// Per-entity jump runtime state (forgiveness + air-jump tracking).
///
/// This store is consumed by [JumpSystem] and intentionally keeps jump-only
/// counters out of generic movement state.
class JumpStateStore extends SparseSet {
  /// Remaining ticks of coyote-time grace.
  final List<int> coyoteTicksLeft = <int>[];

  /// Remaining ticks of buffered jump input.
  final List<int> jumpBufferTicksLeft = <int>[];

  /// Number of airborne jumps used since last grounded tick.
  final List<int> airJumpsUsed = <int>[];

  void add(EntityId entity) {
    addEntity(entity);
  }

  @override
  void onDenseAdded(int denseIndex) {
    coyoteTicksLeft.add(0);
    jumpBufferTicksLeft.add(0);
    airJumpsUsed.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    coyoteTicksLeft[removeIndex] = coyoteTicksLeft[lastIndex];
    jumpBufferTicksLeft[removeIndex] = jumpBufferTicksLeft[lastIndex];
    airJumpsUsed[removeIndex] = airJumpsUsed[lastIndex];

    coyoteTicksLeft.removeLast();
    jumpBufferTicksLeft.removeLast();
    airJumpsUsed.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/player/last_damage_store.dart =====
import '../../../enemies/enemy_id.dart';
import '../../../events/game_event.dart';
import '../../../projectiles/projectile_id.dart';
import '../../entity_id.dart';
import '../../sparse_set.dart';

/// Per-entity record of the last applied damage metadata.
///
/// Used to populate the "Game Over" screen with cause of death.
class LastDamageStore extends SparseSet {
  final List<DeathSourceKind> kind = <DeathSourceKind>[];
  final List<EnemyId> enemyId = <EnemyId>[];
  final List<bool> hasEnemyId = <bool>[];
  final List<ProjectileId> projectileId = <ProjectileId>[];
  final List<bool> hasProjectileId = <bool>[];
  final List<ProjectileId> sourceProjectileId = <ProjectileId>[];
  final List<bool> hasSourceProjectileId = <bool>[];

  /// Fixed-point: 100 = 1.0
  final List<int> amount100 = <int>[];
  final List<int> tick = <int>[];

  void add(EntityId entity) {
    addEntity(entity);
  }

  @override
  void onDenseAdded(int denseIndex) {
    kind.add(DeathSourceKind.unknown);
    enemyId.add(EnemyId.unocoDemon);
    hasEnemyId.add(false);
    projectileId.add(ProjectileId.unknown);
    hasProjectileId.add(false);
    sourceProjectileId.add(ProjectileId.unknown);
    hasSourceProjectileId.add(false);
    amount100.add(0);
    tick.add(-1);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    kind[removeIndex] = kind[lastIndex];
    enemyId[removeIndex] = enemyId[lastIndex];
    hasEnemyId[removeIndex] = hasEnemyId[lastIndex];
    projectileId[removeIndex] = projectileId[lastIndex];
    hasProjectileId[removeIndex] = hasProjectileId[lastIndex];
    sourceProjectileId[removeIndex] = sourceProjectileId[lastIndex];
    hasSourceProjectileId[removeIndex] = hasSourceProjectileId[lastIndex];
    amount100[removeIndex] = amount100[lastIndex];
    tick[removeIndex] = tick[lastIndex];

    kind.removeLast();
    enemyId.removeLast();
    hasEnemyId.removeLast();
    projectileId.removeLast();
    hasProjectileId.removeLast();
    sourceProjectileId.removeLast();
    hasSourceProjectileId.removeLast();
    amount100.removeLast();
    tick.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/player/movement_store.dart =====
import '../../../snapshots/enums.dart';
import '../../entity_id.dart';
import '../../sparse_set.dart';

/// Movement state for platformer-style motion (dash timers + facing).
///
/// Contains transient movement state counters:
/// - Active dash state (duration, direction)
///
/// **Note**: Dash *cooldown* is now managed by [CooldownStore] using
/// [CooldownGroup.mobility]. This store only tracks active dash execution.
class MovementStore extends SparseSet {
  /// Ticks remaining in active dash. 0 = not dashing.
  final List<int> dashTicksLeft = <int>[];

  /// Direction of current dash (-1.0 or 1.0).
  final List<double> dashDirX = <double>[];
  final List<double> dashDirY = <double>[];

  /// Dash speed multiplier sampled at commit-time.
  final List<double> dashSpeedScale = <double>[];
  final List<double> mobilitySpeedX = <double>[];

  final List<Facing> facing = <Facing>[];
  final List<int> facingLockTicksLeft = <int>[];

  void add(EntityId entity, {required Facing facing}) {
    final i = addEntity(entity);
    this.facing[i] = facing;
  }

  bool isDashing(EntityId entity) => dashTicksLeft[indexOf(entity)] > 0;

  @override
  void onDenseAdded(int denseIndex) {
    dashTicksLeft.add(0);
    dashDirX.add(1);
    dashDirY.add(0);
    dashSpeedScale.add(1.0);
    mobilitySpeedX.add(0.0);
    facing.add(Facing.right);
    facingLockTicksLeft.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    dashTicksLeft[removeIndex] = dashTicksLeft[lastIndex];
    dashDirX[removeIndex] = dashDirX[lastIndex];
    dashDirY[removeIndex] = dashDirY[lastIndex];
    dashSpeedScale[removeIndex] = dashSpeedScale[lastIndex];
    mobilitySpeedX[removeIndex] = mobilitySpeedX[lastIndex];
    facing[removeIndex] = facing[lastIndex];
    facingLockTicksLeft[removeIndex] = facingLockTicksLeft[lastIndex];

    dashTicksLeft.removeLast();
    dashDirX.removeLast();
    dashDirY.removeLast();
    dashSpeedScale.removeLast();
    mobilitySpeedX.removeLast();
    facing.removeLast();
    facingLockTicksLeft.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/player/player_input_store.dart =====
import '../../../abilities/ability_def.dart';
import '../../entity_id.dart';
import '../../sparse_set.dart';

/// Per-tick player input (authoritative commands decoded by the core).
///
/// This is reset/overwritten each tick by `GameCore.applyCommands`.
/// All actions are boolean or axis values used by `MovementSystem` and decision systems.
class PlayerInputStore extends SparseSet {
  final List<double> moveAxis = <double>[];
  final List<bool> jumpPressed = <bool>[];
  final List<bool> dashPressed = <bool>[];
  final List<bool> strikePressed = <bool>[];
  final List<double> aimDirX = <double>[];
  final List<double> aimDirY = <double>[];
  final List<bool> projectilePressed = <bool>[];
  final List<bool> secondaryPressed = <bool>[];
  final List<bool> spellPressed = <bool>[];
  final List<bool> hasAbilitySlotPressed = <bool>[];
  final List<AbilitySlot> lastAbilitySlotPressed = <AbilitySlot>[];
  final List<int> heldAbilitySlotMask = <int>[];

  void add(EntityId entity) {
    addEntity(entity);
  }

  void resetTickInputs(EntityId entity) {
    final i = indexOf(entity);
    moveAxis[i] = 0;
    jumpPressed[i] = false;
    dashPressed[i] = false;
    strikePressed[i] = false;
    aimDirX[i] = 0;
    aimDirY[i] = 0;
    projectilePressed[i] = false;
    secondaryPressed[i] = false;
    spellPressed[i] = false;
    hasAbilitySlotPressed[i] = false;
  }

  bool isAbilitySlotHeld(EntityId entity, AbilitySlot slot) {
    if (!has(entity)) return false;
    final i = indexOf(entity);
    final bit = 1 << slot.index;
    return (heldAbilitySlotMask[i] & bit) != 0;
  }

  void setAbilitySlotHeld(EntityId entity, AbilitySlot slot, bool held) {
    final i = indexOf(entity);
    final bit = 1 << slot.index;
    if (held) {
      // Only one held slot is allowed at a time; latest hold wins.
      heldAbilitySlotMask[i] = bit;
    } else {
      heldAbilitySlotMask[i] &= ~bit;
    }
  }

  @override
  void onDenseAdded(int denseIndex) {
    moveAxis.add(0);
    jumpPressed.add(false);
    dashPressed.add(false);
    strikePressed.add(false);
    aimDirX.add(0);
    aimDirY.add(0);
    projectilePressed.add(false);
    secondaryPressed.add(false);
    spellPressed.add(false);
    hasAbilitySlotPressed.add(false);
    lastAbilitySlotPressed.add(AbilitySlot.primary);
    heldAbilitySlotMask.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    moveAxis[removeIndex] = moveAxis[lastIndex];
    jumpPressed[removeIndex] = jumpPressed[lastIndex];
    dashPressed[removeIndex] = dashPressed[lastIndex];
    strikePressed[removeIndex] = strikePressed[lastIndex];
    aimDirX[removeIndex] = aimDirX[lastIndex];
    aimDirY[removeIndex] = aimDirY[lastIndex];
    projectilePressed[removeIndex] = projectilePressed[lastIndex];
    secondaryPressed[removeIndex] = secondaryPressed[lastIndex];
    spellPressed[removeIndex] = spellPressed[lastIndex];
    hasAbilitySlotPressed[removeIndex] = hasAbilitySlotPressed[lastIndex];
    lastAbilitySlotPressed[removeIndex] = lastAbilitySlotPressed[lastIndex];
    heldAbilitySlotMask[removeIndex] = heldAbilitySlotMask[lastIndex];

    moveAxis.removeLast();
    jumpPressed.removeLast();
    dashPressed.removeLast();
    strikePressed.removeLast();
    aimDirX.removeLast();
    aimDirY.removeLast();
    projectilePressed.removeLast();
    secondaryPressed.removeLast();
    spellPressed.removeLast();
    hasAbilitySlotPressed.removeLast();
    lastAbilitySlotPressed.removeLast();
    heldAbilitySlotMask.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/projectile_intent_store.dart =====
import '../../abilities/ability_def.dart';
import '../../combat/damage_type.dart';
import '../../projectiles/projectile_id.dart';
import '../../weapons/weapon_proc.dart';
import '../entity_id.dart';
import '../sparse_set.dart';

class ProjectileIntentDef {
  const ProjectileIntentDef({
    required this.projectileId,
    required this.abilityId,
    required this.slot,
    required this.damage100,
    this.critChanceBp = 0,
    required this.staminaCost100,
    required this.manaCost100,
    required this.cooldownTicks,
    required this.cooldownGroupId,
    required this.pierce,
    required this.maxPierceHits,
    required this.damageType,
    this.procs = const <WeaponProc>[],
    required this.ballistic,
    required this.gravityScale,
    this.speedScaleBp = 10000,
    required this.dirX,
    required this.dirY,
    required this.fallbackDirX,
    required this.fallbackDirY,
    required this.originOffset,
    required this.commitTick,
    required this.windupTicks,
    required this.activeTicks,
    required this.recoveryTicks,
    required this.tick,
  });

  final ProjectileId projectileId;
  final AbilityKey abilityId;
  final AbilitySlot slot;
  final int damage100;
  final int critChanceBp;
  final int staminaCost100;
  final int manaCost100;
  final int cooldownTicks;
  final int cooldownGroupId;
  final bool pierce;
  final int maxPierceHits;
  final DamageType damageType;
  final List<WeaponProc> procs;
  final bool ballistic;
  final double gravityScale;
  final int speedScaleBp;

  final double dirX;
  final double dirY;
  final double fallbackDirX;
  final double fallbackDirY;
  final double originOffset;
  final int commitTick;
  final int windupTicks;
  final int activeTicks;
  final int recoveryTicks;
  final int tick;
}

/// Per-entity "fire a projectile item this tick" intent.
class ProjectileIntentStore extends SparseSet {
  final List<ProjectileId> projectileId = <ProjectileId>[];
  final List<AbilityKey> abilityId = <AbilityKey>[];
  final List<AbilitySlot> slot = <AbilitySlot>[];
  final List<int> damage100 = <int>[];
  final List<int> critChanceBp = <int>[];
  final List<int> staminaCost100 = <int>[];
  final List<int> manaCost100 = <int>[];
  final List<int> cooldownTicks = <int>[];
  final List<int> cooldownGroupId = <int>[];
  final List<bool> pierce = <bool>[];
  final List<int> maxPierceHits = <int>[];
  final List<DamageType> damageType = <DamageType>[];
  final List<List<WeaponProc>> procs = <List<WeaponProc>>[];
  final List<bool> ballistic = <bool>[];
  final List<double> gravityScale = <double>[];
  final List<int> speedScaleBp = <int>[];

  final List<double> dirX = <double>[];
  final List<double> dirY = <double>[];
  final List<double> fallbackDirX = <double>[];
  final List<double> fallbackDirY = <double>[];
  final List<double> originOffset = <double>[];
  final List<int> commitTick = <int>[];
  final List<int> windupTicks = <int>[];
  final List<int> activeTicks = <int>[];
  final List<int> recoveryTicks = <int>[];
  final List<int> tick = <int>[];

  void add(EntityId entity) {
    addEntity(entity);
  }

  void set(EntityId entity, ProjectileIntentDef def) {
    assert(
      has(entity),
      'ProjectileIntentStore.set called for entity without ProjectileIntentStore; add the component at spawn time.',
    );
    final i = indexOf(entity);
    projectileId[i] = def.projectileId;
    abilityId[i] = def.abilityId;
    slot[i] = def.slot;
    damage100[i] = def.damage100;
    critChanceBp[i] = def.critChanceBp;
    staminaCost100[i] = def.staminaCost100;
    manaCost100[i] = def.manaCost100;
    cooldownTicks[i] = def.cooldownTicks;
    cooldownGroupId[i] = def.cooldownGroupId;
    pierce[i] = def.pierce;
    maxPierceHits[i] = def.maxPierceHits;
    damageType[i] = def.damageType;
    procs[i] = def.procs;
    ballistic[i] = def.ballistic;
    gravityScale[i] = def.gravityScale;
    speedScaleBp[i] = def.speedScaleBp;
    dirX[i] = def.dirX;
    dirY[i] = def.dirY;
    fallbackDirX[i] = def.fallbackDirX;
    fallbackDirY[i] = def.fallbackDirY;
    originOffset[i] = def.originOffset;
    commitTick[i] = def.commitTick;
    windupTicks[i] = def.windupTicks;
    activeTicks[i] = def.activeTicks;
    recoveryTicks[i] = def.recoveryTicks;
    tick[i] = def.tick;
  }

  @override
  void onDenseAdded(int denseIndex) {
    projectileId.add(ProjectileId.unknown);
    abilityId.add('eloise.overcharge_shot');
    slot.add(AbilitySlot.projectile);
    damage100.add(0);
    critChanceBp.add(0);
    staminaCost100.add(0);
    manaCost100.add(0);
    cooldownTicks.add(0);
    cooldownGroupId.add(0);
    pierce.add(false);
    maxPierceHits.add(1);
    damageType.add(DamageType.ice);
    procs.add(const <WeaponProc>[]);
    ballistic.add(false);
    gravityScale.add(1.0);
    speedScaleBp.add(10000);
    dirX.add(0.0);
    dirY.add(0.0);
    fallbackDirX.add(1.0);
    fallbackDirY.add(0.0);
    originOffset.add(0.0);
    commitTick.add(-1);
    windupTicks.add(0);
    activeTicks.add(0);
    recoveryTicks.add(0);
    tick.add(-1);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    projectileId[removeIndex] = projectileId[lastIndex];
    abilityId[removeIndex] = abilityId[lastIndex];
    slot[removeIndex] = slot[lastIndex];
    damage100[removeIndex] = damage100[lastIndex];
    critChanceBp[removeIndex] = critChanceBp[lastIndex];
    staminaCost100[removeIndex] = staminaCost100[lastIndex];
    manaCost100[removeIndex] = manaCost100[lastIndex];
    cooldownTicks[removeIndex] = cooldownTicks[lastIndex];
    cooldownGroupId[removeIndex] = cooldownGroupId[lastIndex];
    pierce[removeIndex] = pierce[lastIndex];
    maxPierceHits[removeIndex] = maxPierceHits[lastIndex];
    damageType[removeIndex] = damageType[lastIndex];
    procs[removeIndex] = procs[lastIndex];
    ballistic[removeIndex] = ballistic[lastIndex];
    gravityScale[removeIndex] = gravityScale[lastIndex];
    speedScaleBp[removeIndex] = speedScaleBp[lastIndex];
    dirX[removeIndex] = dirX[lastIndex];
    dirY[removeIndex] = dirY[lastIndex];
    fallbackDirX[removeIndex] = fallbackDirX[lastIndex];
    fallbackDirY[removeIndex] = fallbackDirY[lastIndex];
    originOffset[removeIndex] = originOffset[lastIndex];
    commitTick[removeIndex] = commitTick[lastIndex];
    windupTicks[removeIndex] = windupTicks[lastIndex];
    activeTicks[removeIndex] = activeTicks[lastIndex];
    recoveryTicks[removeIndex] = recoveryTicks[lastIndex];
    tick[removeIndex] = tick[lastIndex];

    projectileId.removeLast();
    abilityId.removeLast();
    slot.removeLast();
    damage100.removeLast();
    critChanceBp.removeLast();
    staminaCost100.removeLast();
    manaCost100.removeLast();
    cooldownTicks.removeLast();
    cooldownGroupId.removeLast();
    pierce.removeLast();
    maxPierceHits.removeLast();
    damageType.removeLast();
    procs.removeLast();
    ballistic.removeLast();
    gravityScale.removeLast();
    speedScaleBp.removeLast();
    dirX.removeLast();
    dirY.removeLast();
    fallbackDirX.removeLast();
    fallbackDirY.removeLast();
    originOffset.removeLast();
    commitTick.removeLast();
    windupTicks.removeLast();
    activeTicks.removeLast();
    recoveryTicks.removeLast();
    tick.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/projectile_item_origin_store.dart =====
import '../../projectiles/projectile_id.dart';
import '../entity_id.dart';
import '../sparse_set.dart';

class ProjectileOriginDef {
  const ProjectileOriginDef({required this.projectileId});

  final ProjectileId projectileId;
}

/// Metadata for projectile entities (spawned from projectile slot items).
class ProjectileOriginStore extends SparseSet {
  final List<ProjectileId> projectileId = <ProjectileId>[];

  void add(EntityId entity, ProjectileOriginDef def) {
    final i = addEntity(entity);
    projectileId[i] = def.projectileId;
  }

  @override
  void onDenseAdded(int denseIndex) {
    projectileId.add(ProjectileId.unknown);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    projectileId[removeIndex] = projectileId[lastIndex];
    projectileId.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/projectile_store.dart =====
import '../../combat/damage_type.dart';
import '../../combat/faction.dart';
import '../../projectiles/projectile_id.dart';
import '../../weapons/weapon_proc.dart';
import '../entity_id.dart';
import '../sparse_set.dart';

class ProjectileEntityDef {
  const ProjectileEntityDef({
    required this.projectileId,
    required this.faction,
    required this.owner,
    required this.dirX,
    required this.dirY,
    required this.speedUnitsPerSecond,
    required this.damage100,
    this.critChanceBp = 0,
    required this.damageType,
    this.procs = const <WeaponProc>[],
    this.pierce = false,
    this.maxPierceHits = 1,
    this.usePhysics = false,
  }) : assert(maxPierceHits > 0, 'maxPierceHits must be > 0');

  final ProjectileId projectileId;
  final Faction faction;
  final EntityId owner;
  final double dirX;
  final double dirY;
  final double speedUnitsPerSecond;

  /// Fixed-point: 100 = 1.0
  final int damage100;

  /// Critical strike chance in basis points (100 = 1%).
  final int critChanceBp;
  final DamageType damageType;
  final List<WeaponProc> procs;
  final bool pierce;
  final int maxPierceHits;

  /// If true, this projectile is moved by core physics (GravitySystem +
  /// CollisionSystem) rather than [ProjectileSystem].
  final bool usePhysics;
}

/// Immutable metadata for active projectiles.
///
/// Combines with `Transform` (for position) and `ColliderAabb` (for hit detection).
class ProjectileStore extends SparseSet {
  final List<ProjectileId> projectileId = <ProjectileId>[];
  final List<Faction> faction = <Faction>[];
  final List<EntityId> owner = <EntityId>[];
  final List<double> dirX = <double>[];
  final List<double> dirY = <double>[];
  final List<double> speedUnitsPerSecond = <double>[];

  /// Fixed-point: 100 = 1.0
  final List<int> damage100 = <int>[];
  final List<int> critChanceBp = <int>[];
  final List<DamageType> damageType = <DamageType>[];
  final List<List<WeaponProc>> procs = <List<WeaponProc>>[];
  final List<bool> pierce = <bool>[];
  final List<int> maxPierceHits = <int>[];
  final List<bool> usePhysics = <bool>[];

  void add(EntityId entity, ProjectileEntityDef def) {
    final i = addEntity(entity);
    projectileId[i] = def.projectileId;
    faction[i] = def.faction;
    owner[i] = def.owner;
    dirX[i] = def.dirX;
    dirY[i] = def.dirY;
    speedUnitsPerSecond[i] = def.speedUnitsPerSecond;
    damage100[i] = def.damage100;
    critChanceBp[i] = def.critChanceBp;
    damageType[i] = def.damageType;
    procs[i] = def.procs;
    pierce[i] = def.pierce;
    maxPierceHits[i] = def.maxPierceHits;
    usePhysics[i] = def.usePhysics;
  }

  @override
  void onDenseAdded(int denseIndex) {
    projectileId.add(ProjectileId.unknown);
    faction.add(Faction.player);
    owner.add(0);
    dirX.add(1.0);
    dirY.add(0.0);
    speedUnitsPerSecond.add(0.0);
    damage100.add(0);
    critChanceBp.add(0);
    damageType.add(DamageType.physical);
    procs.add(const <WeaponProc>[]);
    pierce.add(false);
    maxPierceHits.add(1);
    usePhysics.add(false);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    projectileId[removeIndex] = projectileId[lastIndex];
    faction[removeIndex] = faction[lastIndex];
    owner[removeIndex] = owner[lastIndex];
    dirX[removeIndex] = dirX[lastIndex];
    dirY[removeIndex] = dirY[lastIndex];
    speedUnitsPerSecond[removeIndex] = speedUnitsPerSecond[lastIndex];
    damage100[removeIndex] = damage100[lastIndex];
    critChanceBp[removeIndex] = critChanceBp[lastIndex];
    damageType[removeIndex] = damageType[lastIndex];
    procs[removeIndex] = procs[lastIndex];
    pierce[removeIndex] = pierce[lastIndex];
    maxPierceHits[removeIndex] = maxPierceHits[lastIndex];
    usePhysics[removeIndex] = usePhysics[lastIndex];

    projectileId.removeLast();
    faction.removeLast();
    owner.removeLast();
    dirX.removeLast();
    dirY.removeLast();
    speedUnitsPerSecond.removeLast();
    damage100.removeLast();
    critChanceBp.removeLast();
    damageType.removeLast();
    procs.removeLast();
    pierce.removeLast();
    maxPierceHits.removeLast();
    usePhysics.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/restoration_item_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

enum RestorationStat {
  health,
  mana,
  stamina,
}

class RestorationItemDef {
  const RestorationItemDef({required this.stat});

  final RestorationStat stat;
}

/// SoA store for restoration item metadata (health/mana/stamina).
class RestorationItemStore extends SparseSet {
  final List<RestorationStat> stat = <RestorationStat>[];

  void add(EntityId entity, RestorationItemDef def) {
    final i = addEntity(entity);
    stat[i] = def.stat;
  }

  @override
  void onDenseAdded(int denseIndex) {
    stat.add(RestorationStat.health);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    stat[removeIndex] = stat[lastIndex];
    stat.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/riposte_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

/// One-shot offensive buff granted by a successful parry.
///
/// The buff is consumed only when a melee hit actually lands (so misses do not
/// waste it). It may also expire after a fixed number of ticks.
class RiposteStore extends SparseSet {
  /// Tick at which this buff expires (inclusive).
  final List<int> expiresTick = <int>[];

  /// Damage bonus in basis points (bpScale = 10000).
  /// Example: 10000 = +100% (i.e. x2 total when applied).
  final List<int> bonusBp = <int>[];

  void grant(
    EntityId entity, {
    required int expiresAtTick,
    required int bonusBp,
  }) {
    final i = addEntity(entity);
    expiresTick[i] = expiresAtTick;
    this.bonusBp[i] = bonusBp;
  }

  void consume(EntityId entity) {
    removeEntity(entity);
  }

  @override
  void onDenseAdded(int denseIndex) {
    expiresTick.add(-1);
    bonusBp.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    expiresTick[removeIndex] = expiresTick[lastIndex];
    bonusBp[removeIndex] = bonusBp[lastIndex];
    expiresTick.removeLast();
    bonusBp.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/self_intent_store.dart =====
import '../../abilities/ability_def.dart';
import '../../combat/status/status.dart';
import '../entity_id.dart';
import '../sparse_set.dart';

class SelfIntentDef {
  const SelfIntentDef({
    required this.abilityId,
    required this.slot,
    this.selfStatusProfileId = StatusProfileId.none,
    required this.commitTick,
    required this.windupTicks,
    required this.activeTicks,
    required this.recoveryTicks,
    required this.cooldownTicks,
    required this.cooldownGroupId,
    required this.staminaCost100,
    required this.manaCost100,
    required this.tick,
  });

  final AbilityKey abilityId;
  final AbilitySlot slot;
  final StatusProfileId selfStatusProfileId;

  /// Tick the ability was committed (costs/cooldown start).
  final int commitTick;

  /// Windup duration (ticks) before effect window.
  final int windupTicks;
  final int activeTicks;

  /// Recovery duration (ticks) after active window.
  final int recoveryTicks;
  final int cooldownTicks;
  final int cooldownGroupId;

  /// Fixed-point: 100 = 1.0
  final int staminaCost100;

  /// Fixed-point: 100 = 1.0
  final int manaCost100;

  /// Tick stamp for execution.
  ///
  /// Use `-1` for "no intent". The effect triggers only when
  /// `tick == currentTick`.
  final int tick;
}

/// Per-entity "perform a self ability this tick" intent.
///
/// Written by [AbilityActivationSystem], consumed by [SelfAbilitySystem].
class SelfIntentStore extends SparseSet {
  final List<AbilityKey> abilityId = <AbilityKey>[];
  final List<AbilitySlot> slot = <AbilitySlot>[];
  final List<StatusProfileId> selfStatusProfileId = <StatusProfileId>[];
  final List<int> commitTick = <int>[];
  final List<int> windupTicks = <int>[];
  final List<int> activeTicks = <int>[];
  final List<int> recoveryTicks = <int>[];
  final List<int> cooldownTicks = <int>[];
  final List<int> cooldownGroupId = <int>[];

  /// Fixed-point: 100 = 1.0
  final List<int> staminaCost100 = <int>[];

  /// Fixed-point: 100 = 1.0
  final List<int> manaCost100 = <int>[];
  final List<int> tick = <int>[];

  void add(EntityId entity) {
    addEntity(entity);
  }

  void set(EntityId entity, SelfIntentDef def) {
    assert(
      has(entity),
      'SelfIntentStore.set called for entity without SelfIntentStore; add the component at spawn time.',
    );
    final i = indexOf(entity);
    abilityId[i] = def.abilityId;
    slot[i] = def.slot;
    selfStatusProfileId[i] = def.selfStatusProfileId;
    commitTick[i] = def.commitTick;
    windupTicks[i] = def.windupTicks;
    activeTicks[i] = def.activeTicks;
    recoveryTicks[i] = def.recoveryTicks;
    cooldownTicks[i] = def.cooldownTicks;
    cooldownGroupId[i] = def.cooldownGroupId;
    staminaCost100[i] = def.staminaCost100;
    manaCost100[i] = def.manaCost100;
    tick[i] = def.tick;
  }

  @override
  void onDenseAdded(int denseIndex) {
    abilityId.add('eloise.riposte_guard');
    slot.add(AbilitySlot.primary);
    selfStatusProfileId.add(StatusProfileId.none);
    commitTick.add(-1);
    windupTicks.add(0);
    activeTicks.add(0);
    recoveryTicks.add(0);
    cooldownTicks.add(0);
    cooldownGroupId.add(0);
    staminaCost100.add(0);
    manaCost100.add(0);
    tick.add(-1);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    abilityId[removeIndex] = abilityId[lastIndex];
    slot[removeIndex] = slot[lastIndex];
    selfStatusProfileId[removeIndex] = selfStatusProfileId[lastIndex];
    commitTick[removeIndex] = commitTick[lastIndex];
    windupTicks[removeIndex] = windupTicks[lastIndex];
    activeTicks[removeIndex] = activeTicks[lastIndex];
    recoveryTicks[removeIndex] = recoveryTicks[lastIndex];
    cooldownTicks[removeIndex] = cooldownTicks[lastIndex];
    cooldownGroupId[removeIndex] = cooldownGroupId[lastIndex];
    staminaCost100[removeIndex] = staminaCost100[lastIndex];
    manaCost100[removeIndex] = manaCost100[lastIndex];
    tick[removeIndex] = tick[lastIndex];

    abilityId.removeLast();
    slot.removeLast();
    selfStatusProfileId.removeLast();
    commitTick.removeLast();
    windupTicks.removeLast();
    activeTicks.removeLast();
    recoveryTicks.removeLast();
    cooldownTicks.removeLast();
    cooldownGroupId.removeLast();
    staminaCost100.removeLast();
    manaCost100.removeLast();
    tick.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/stamina_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';

class StaminaDef {
  const StaminaDef({
    required this.stamina,
    required this.staminaMax,
    required this.regenPerSecond100,
  });

  /// Fixed-point: 100 = 1.0
  final int stamina;
  final int staminaMax;
  final int regenPerSecond100;
}

/// Tracks stamina for dashing and melee strikes.
class StaminaStore extends SparseSet {
  /// Fixed-point: 100 = 1.0
  final List<int> stamina = <int>[];
  final List<int> staminaMax = <int>[];
  final List<int> regenPerSecond100 = <int>[];
  final List<int> regenAccumulator = <int>[];

  void add(EntityId entity, StaminaDef def) {
    final i = addEntity(entity);
    stamina[i] = def.stamina;
    staminaMax[i] = def.staminaMax;
    regenPerSecond100[i] = def.regenPerSecond100;
    regenAccumulator[i] = 0;
  }

  @override
  void onDenseAdded(int denseIndex) {
    stamina.add(0);
    staminaMax.add(0);
    regenPerSecond100.add(0);
    regenAccumulator.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    stamina[removeIndex] = stamina[lastIndex];
    staminaMax[removeIndex] = staminaMax[lastIndex];
    regenPerSecond100[removeIndex] = regenPerSecond100[lastIndex];
    regenAccumulator[removeIndex] = regenAccumulator[lastIndex];

    stamina.removeLast();
    staminaMax.removeLast();
    regenPerSecond100.removeLast();
    regenAccumulator.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/status/dot_store.dart =====
import '../../../combat/damage_type.dart';
import '../../entity_id.dart';
import '../../sparse_set.dart';

class DotDef {
  const DotDef({
    required this.damageType,
    required this.ticksLeft,
    required this.periodTicks,
    required this.dps100,
  }) : periodTicksLeft = periodTicks;

  final DamageType damageType;
  final int ticksLeft;
  final int periodTicks;
  final int periodTicksLeft;

  /// Fixed-point DPS: 100 = 1.0 per second.
  final int dps100;
}

/// Active damage-over-time effects keyed by target entity.
///
/// A target can host multiple DoTs at once as long as they use different
/// [DamageType] channels (for example, physical and fire).
class DotStore extends SparseSet {
  final List<List<DamageType>> damageTypes = <List<DamageType>>[];
  final List<List<int>> ticksLeft = <List<int>>[];
  final List<List<int>> periodTicks = <List<int>>[];
  final List<List<int>> periodTicksLeft = <List<int>>[];
  final List<List<int>> dps100 = <List<int>>[];

  void add(EntityId entity, DotDef def) {
    final entityIndex = addEntity(entity);
    final channelIndex = _channelIndexFor(entityIndex, def.damageType);
    if (channelIndex == null) {
      _addChannel(entityIndex, def);
      return;
    }
    _setChannel(entityIndex, channelIndex, def);
  }

  int? channelIndexFor(EntityId entity, DamageType damageType) {
    final entityIndex = tryIndexOf(entity);
    if (entityIndex == null) return null;
    return _channelIndexFor(entityIndex, damageType);
  }

  int? channelIndexForEntityIndex(int entityIndex, DamageType damageType) {
    return _channelIndexFor(entityIndex, damageType);
  }

  void addChannel(EntityId entity, DotDef def) {
    final entityIndex = addEntity(entity);
    _addChannel(entityIndex, def);
  }

  void setChannel(EntityId entity, int channelIndex, DotDef def) {
    final entityIndex = indexOf(entity);
    _setChannel(entityIndex, channelIndex, def);
  }

  void removeChannelAt(EntityId entity, int channelIndex) {
    final entityIndex = indexOf(entity);
    _removeChannelAt(entityIndex, channelIndex);
  }

  void removeChannelAtEntityIndex(int entityIndex, int channelIndex) {
    _removeChannelAt(entityIndex, channelIndex);
  }

  bool hasNoChannelsEntityIndex(int entityIndex) {
    return damageTypes[entityIndex].isEmpty;
  }

  int? _channelIndexFor(int entityIndex, DamageType damageType) {
    final channels = damageTypes[entityIndex];
    for (var i = 0; i < channels.length; i += 1) {
      if (channels[i] == damageType) return i;
    }
    return null;
  }

  void _addChannel(int entityIndex, DotDef def) {
    damageTypes[entityIndex].add(def.damageType);
    ticksLeft[entityIndex].add(def.ticksLeft);
    periodTicks[entityIndex].add(def.periodTicks);
    periodTicksLeft[entityIndex].add(def.periodTicksLeft);
    dps100[entityIndex].add(def.dps100);
  }

  void _setChannel(int entityIndex, int channelIndex, DotDef def) {
    damageTypes[entityIndex][channelIndex] = def.damageType;
    ticksLeft[entityIndex][channelIndex] = def.ticksLeft;
    periodTicks[entityIndex][channelIndex] = def.periodTicks;
    periodTicksLeft[entityIndex][channelIndex] = def.periodTicksLeft;
    dps100[entityIndex][channelIndex] = def.dps100;
  }

  void _removeChannelAt(int entityIndex, int channelIndex) {
    damageTypes[entityIndex].removeAt(channelIndex);
    ticksLeft[entityIndex].removeAt(channelIndex);
    periodTicks[entityIndex].removeAt(channelIndex);
    periodTicksLeft[entityIndex].removeAt(channelIndex);
    dps100[entityIndex].removeAt(channelIndex);
  }

  @override
  void onDenseAdded(int denseIndex) {
    damageTypes.add(<DamageType>[]);
    ticksLeft.add(<int>[]);
    periodTicks.add(<int>[]);
    periodTicksLeft.add(<int>[]);
    dps100.add(<int>[]);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    damageTypes[removeIndex] = damageTypes[lastIndex];
    ticksLeft[removeIndex] = ticksLeft[lastIndex];
    periodTicks[removeIndex] = periodTicks[lastIndex];
    periodTicksLeft[removeIndex] = periodTicksLeft[lastIndex];
    dps100[removeIndex] = dps100[lastIndex];

    damageTypes.removeLast();
    ticksLeft.removeLast();
    periodTicks.removeLast();
    periodTicksLeft.removeLast();
    dps100.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/status/drench_store.dart =====
import '../../entity_id.dart';
import '../../sparse_set.dart';

class DrenchDef {
  const DrenchDef({required this.ticksLeft, required this.magnitude});

  final int ticksLeft;

  /// Basis points (100 = 1%) subtracted from attack/cast speed.
  final int magnitude;
}

/// Active attack/cast speed reduction status.
class DrenchStore extends SparseSet {
  final List<int> ticksLeft = <int>[];

  /// Basis points (100 = 1%) subtracted from attack/cast speed.
  final List<int> magnitude = <int>[];

  void add(EntityId entity, DrenchDef def) {
    final i = addEntity(entity);
    ticksLeft[i] = def.ticksLeft;
    magnitude[i] = def.magnitude;
  }

  @override
  void onDenseAdded(int denseIndex) {
    ticksLeft.add(0);
    magnitude.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    ticksLeft[removeIndex] = ticksLeft[lastIndex];
    magnitude[removeIndex] = magnitude[lastIndex];
    ticksLeft.removeLast();
    magnitude.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/status/haste_store.dart =====
import '../../entity_id.dart';
import '../../sparse_set.dart';

class HasteDef {
  const HasteDef({required this.ticksLeft, required this.magnitude});

  final int ticksLeft;
  /// Basis points (100 = 1%).
  final int magnitude;
}

/// Active haste status (movement speed multiplier).
class HasteStore extends SparseSet {
  final List<int> ticksLeft = <int>[];
  /// Basis points (100 = 1%).
  final List<int> magnitude = <int>[];

  void add(EntityId entity, HasteDef def) {
    final i = addEntity(entity);
    ticksLeft[i] = def.ticksLeft;
    magnitude[i] = def.magnitude;
  }

  @override
  void onDenseAdded(int denseIndex) {
    ticksLeft.add(0);
    magnitude.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    ticksLeft[removeIndex] = ticksLeft[lastIndex];
    magnitude[removeIndex] = magnitude[lastIndex];
    ticksLeft.removeLast();
    magnitude.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/status/resource_over_time_store.dart =====
import '../../../combat/status/status.dart';
import '../../entity_id.dart';
import '../../sparse_set.dart';

class ResourceOverTimeDef {
  const ResourceOverTimeDef({
    required this.resourceType,
    required this.ticksLeft,
    required this.totalTicks,
    required this.totalAmount100,
    required this.amountBp,
    this.accumulatorNumerator = 0,
  });

  final StatusResourceType resourceType;
  final int ticksLeft;

  /// Authored total duration for this channel in ticks.
  final int totalTicks;

  /// Total fixed-point resource restored across the full channel duration.
  final int totalAmount100;

  /// Authored total restore percentage (`100 = 1%`).
  final int amountBp;

  /// Fractional carry for deterministic per-tick distribution.
  ///
  /// Units are "resource * ticks"; per tick we add [totalAmount100], divide by
  /// [totalTicks], and carry the remainder here.
  final int accumulatorNumerator;
}

/// Active continuous resource restoration keyed by target entity.
///
/// A target can host multiple channels at once as long as they use different
/// resource types (health/mana/stamina).
class ResourceOverTimeStore extends SparseSet {
  final List<List<StatusResourceType>> resourceTypes =
      <List<StatusResourceType>>[];
  final List<List<int>> ticksLeft = <List<int>>[];
  final List<List<int>> totalTicks = <List<int>>[];
  final List<List<int>> totalAmount100 = <List<int>>[];
  final List<List<int>> amountBp = <List<int>>[];
  final List<List<int>> accumulatorNumerator = <List<int>>[];

  void add(EntityId entity, ResourceOverTimeDef def) {
    final entityIndex = addEntity(entity);
    final channelIndex = _channelIndexFor(entityIndex, def.resourceType);
    if (channelIndex == null) {
      _addChannel(entityIndex, def);
      return;
    }
    _setChannel(entityIndex, channelIndex, def);
  }

  int? channelIndexFor(EntityId entity, StatusResourceType resourceType) {
    final entityIndex = tryIndexOf(entity);
    if (entityIndex == null) return null;
    return _channelIndexFor(entityIndex, resourceType);
  }

  int? channelIndexForEntityIndex(
    int entityIndex,
    StatusResourceType resourceType,
  ) {
    return _channelIndexFor(entityIndex, resourceType);
  }

  void addChannel(EntityId entity, ResourceOverTimeDef def) {
    final entityIndex = addEntity(entity);
    _addChannel(entityIndex, def);
  }

  void setChannel(EntityId entity, int channelIndex, ResourceOverTimeDef def) {
    final entityIndex = indexOf(entity);
    _setChannel(entityIndex, channelIndex, def);
  }

  void removeChannelAtEntityIndex(int entityIndex, int channelIndex) {
    _removeChannelAt(entityIndex, channelIndex);
  }

  bool hasNoChannelsEntityIndex(int entityIndex) {
    return resourceTypes[entityIndex].isEmpty;
  }

  int? _channelIndexFor(int entityIndex, StatusResourceType resourceType) {
    final channels = resourceTypes[entityIndex];
    for (var i = 0; i < channels.length; i += 1) {
      if (channels[i] == resourceType) return i;
    }
    return null;
  }

  void _addChannel(int entityIndex, ResourceOverTimeDef def) {
    resourceTypes[entityIndex].add(def.resourceType);
    ticksLeft[entityIndex].add(def.ticksLeft);
    totalTicks[entityIndex].add(def.totalTicks);
    totalAmount100[entityIndex].add(def.totalAmount100);
    amountBp[entityIndex].add(def.amountBp);
    accumulatorNumerator[entityIndex].add(def.accumulatorNumerator);
  }

  void _setChannel(int entityIndex, int channelIndex, ResourceOverTimeDef def) {
    resourceTypes[entityIndex][channelIndex] = def.resourceType;
    ticksLeft[entityIndex][channelIndex] = def.ticksLeft;
    totalTicks[entityIndex][channelIndex] = def.totalTicks;
    totalAmount100[entityIndex][channelIndex] = def.totalAmount100;
    amountBp[entityIndex][channelIndex] = def.amountBp;
    accumulatorNumerator[entityIndex][channelIndex] = def.accumulatorNumerator;
  }

  void _removeChannelAt(int entityIndex, int channelIndex) {
    resourceTypes[entityIndex].removeAt(channelIndex);
    ticksLeft[entityIndex].removeAt(channelIndex);
    totalTicks[entityIndex].removeAt(channelIndex);
    totalAmount100[entityIndex].removeAt(channelIndex);
    amountBp[entityIndex].removeAt(channelIndex);
    accumulatorNumerator[entityIndex].removeAt(channelIndex);
  }

  @override
  void onDenseAdded(int denseIndex) {
    resourceTypes.add(<StatusResourceType>[]);
    ticksLeft.add(<int>[]);
    totalTicks.add(<int>[]);
    totalAmount100.add(<int>[]);
    amountBp.add(<int>[]);
    accumulatorNumerator.add(<int>[]);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    resourceTypes[removeIndex] = resourceTypes[lastIndex];
    ticksLeft[removeIndex] = ticksLeft[lastIndex];
    totalTicks[removeIndex] = totalTicks[lastIndex];
    totalAmount100[removeIndex] = totalAmount100[lastIndex];
    amountBp[removeIndex] = amountBp[lastIndex];
    accumulatorNumerator[removeIndex] = accumulatorNumerator[lastIndex];

    resourceTypes.removeLast();
    ticksLeft.removeLast();
    totalTicks.removeLast();
    totalAmount100.removeLast();
    amountBp.removeLast();
    accumulatorNumerator.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/status/slow_store.dart =====
import '../../entity_id.dart';
import '../../sparse_set.dart';

class SlowDef {
  const SlowDef({required this.ticksLeft, required this.magnitude});

  final int ticksLeft;
  /// Basis points (100 = 1%).
  final int magnitude;
}

/// Active slow status (movement speed multiplier).
class SlowStore extends SparseSet {
  final List<int> ticksLeft = <int>[];
  /// Basis points (100 = 1%).
  final List<int> magnitude = <int>[];

  void add(EntityId entity, SlowDef def) {
    final i = addEntity(entity);
    ticksLeft[i] = def.ticksLeft;
    magnitude[i] = def.magnitude;
  }

  @override
  void onDenseAdded(int denseIndex) {
    ticksLeft.add(0);
    magnitude.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    ticksLeft[removeIndex] = ticksLeft[lastIndex];
    magnitude[removeIndex] = magnitude[lastIndex];
    ticksLeft.removeLast();
    magnitude.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/status/vulnerable_store.dart =====
import '../../entity_id.dart';
import '../../sparse_set.dart';

class VulnerableDef {
  const VulnerableDef({required this.ticksLeft, required this.magnitude});

  final int ticksLeft;

  /// Basis points (100 = 1%) added to incoming damage.
  final int magnitude;
}

/// Active vulnerability status (global incoming damage amplification).
class VulnerableStore extends SparseSet {
  final List<int> ticksLeft = <int>[];

  /// Basis points (100 = 1%) added to incoming damage.
  final List<int> magnitude = <int>[];

  void add(EntityId entity, VulnerableDef def) {
    final i = addEntity(entity);
    ticksLeft[i] = def.ticksLeft;
    magnitude[i] = def.magnitude;
  }

  @override
  void onDenseAdded(int denseIndex) {
    ticksLeft.add(0);
    magnitude.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    ticksLeft[removeIndex] = ticksLeft[lastIndex];
    magnitude[removeIndex] = magnitude[lastIndex];
    ticksLeft.removeLast();
    magnitude.removeLast();
  }
}


===== FILE: lib/core/ecs/stores/status/weaken_store.dart =====
import '../../entity_id.dart';
import '../../sparse_set.dart';

class WeakenDef {
  const WeakenDef({required this.ticksLeft, required this.magnitude});

  final int ticksLeft;

  /// Basis points (100 = 1%) subtracted from outgoing damage.
  final int magnitude;
}

/// Active outgoing-damage reduction status.
class WeakenStore extends SparseSet {
  final List<int> ticksLeft = <int>[];

  /// Basis points (100 = 1%) subtracted from outgoing damage.
  final List<int> magnitude = <int>[];

  void add(EntityId entity, WeakenDef def) {
    final i = addEntity(entity);
    ticksLeft[i] = def.ticksLeft;
    magnitude[i] = def.magnitude;
  }

  @override
  void onDenseAdded(int denseIndex) {
    ticksLeft.add(0);
    magnitude.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    ticksLeft[removeIndex] = ticksLeft[lastIndex];
    magnitude[removeIndex] = magnitude[lastIndex];
    ticksLeft.removeLast();
    magnitude.removeLast();
  }
}



===== FILE: lib/core/ecs/stores/transform_store.dart =====
import '../entity_id.dart';
import '../sparse_set.dart';
import '../../util/fixed_math.dart';

/// SoA store for `Transform` (position + velocity).
///
/// This is the "hot" store accessed by almost every system.
class TransformStore extends SparseSet {
  final List<double> posX = <double>[];
  final List<double> posY = <double>[];
  final List<double> velX = <double>[];
  final List<double> velY = <double>[];

  void add(
    EntityId entity, {
    required double posX,
    required double posY,
    required double velX,
    required double velY,
  }) {
    final i = addEntity(entity);
    this.posX[i] = posX;
    this.posY[i] = posY;
    this.velX[i] = velX;
    this.velY[i] = velY;
  }

  void setPosXY(EntityId entity, double x, double y) {
    final i = indexOf(entity);
    posX[i] = x;
    posY[i] = y;
  }

  void setVelXY(EntityId entity, double x, double y) {
    final i = indexOf(entity);
    velX[i] = x;
    velY[i] = y;
  }

  /// Quantizes velocity to a subpixel grid for fixed-point pilot paths.
  void quantizeVelAtIndex(int denseIndex, {required int subpixelScale}) {
    velX[denseIndex] = quantizeToScale(velX[denseIndex], subpixelScale);
    velY[denseIndex] = quantizeToScale(velY[denseIndex], subpixelScale);
  }

  /// Quantizes position + velocity to a subpixel grid for fixed-point pilot paths.
  void quantizePosVelAtIndex(int denseIndex, {required int subpixelScale}) {
    posX[denseIndex] = quantizeToScale(posX[denseIndex], subpixelScale);
    posY[denseIndex] = quantizeToScale(posY[denseIndex], subpixelScale);
    quantizeVelAtIndex(denseIndex, subpixelScale: subpixelScale);
  }

  @override
  void onDenseAdded(int denseIndex) {
    posX.add(0);
    posY.add(0);
    velX.add(0);
    velY.add(0);
  }

  @override
  void onSwapRemove(int removeIndex, int lastIndex) {
    posX[removeIndex] = posX[lastIndex];
    posY[removeIndex] = posY[lastIndex];
    velX[removeIndex] = velX[lastIndex];
    velY[removeIndex] = velY[lastIndex];

    posX.removeLast();
    posY.removeLast();
    velX.removeLast();
    velY.removeLast();
  }
}


===== FILE: lib/core/ecs/systems/ability_activation_system.dart =====
import 'dart:math';

import '../../abilities/ability_gate.dart';
import '../../abilities/ability_catalog.dart';
import '../../abilities/ability_def.dart';
import '../../abilities/effective_ability_cost.dart';
import '../../accessories/accessory_catalog.dart';
import '../../combat/damage_type.dart';
import '../../combat/hit_payload_builder.dart';
import '../../snapshots/enums.dart';
import '../../projectiles/projectile_id.dart';
import '../../projectiles/projectile_catalog.dart';
import '../../spellBook/spell_book_catalog.dart';
import '../../weapons/weapon_catalog.dart';
import '../../weapons/weapon_proc.dart';
import '../../stats/gear_stat_bonuses.dart';
import '../../stats/character_stats_resolver.dart';
import '../../stats/resolved_stats_cache.dart';
import '../../util/fixed_math.dart';
import '../../util/tick_math.dart';
import '../entity_id.dart';
import '../hit/aabb_hit_utils.dart';
import '../stores/combat/equipped_loadout_store.dart';
import '../stores/melee_intent_store.dart';
import '../stores/mobility_intent_store.dart';
import '../stores/projectile_intent_store.dart';
import '../stores/self_intent_store.dart';
import '../world.dart';

/// Routes player input into ability intents based on the equipped loadout.
///
/// **Responsibilities**:
/// - Read player input (strike/projectile/secondary/mobility/jump).
/// - Resolve the equipped ability for each slot.
/// - Emit intent stores (melee/projectile) for execution systems.
///
/// **Determinism**:
/// - No RNG.
/// - No wall-clock time; uses [currentTick].
class AbilityActivationSystem {
  AbilityActivationSystem({
    required this.tickHz,
    required this.inputBufferTicks,
    required this.abilities,
    required this.weapons,
    required this.projectiles,
    required this.spellBooks,
    required this.accessories,
    ResolvedStatsCache? statsCache,
  }) : _statsCache =
           statsCache ??
           ResolvedStatsCache(
             resolver: CharacterStatsResolver(
               weapons: weapons,
               projectiles: projectiles,
               spellBooks: spellBooks,
               accessories: accessories,
             ),
           );

  final int tickHz;
  final int inputBufferTicks;
  final AbilityResolver abilities;
  final WeaponCatalog weapons;
  final ProjectileCatalog projectiles;
  final SpellBookCatalog spellBooks;
  final AccessoryCatalog accessories;

  final ResolvedStatsCache _statsCache;

  void step(
    EcsWorld world, {
    required EntityId player,
    required int currentTick,
  }) {
    final inputIndex = world.playerInput.tryIndexOf(player);
    if (inputIndex == null) return;

    final movementIndex = world.movement.tryIndexOf(player);
    if (movementIndex == null) return;

    final loadoutIndex = world.equippedLoadout.tryIndexOf(player);
    if (loadoutIndex == null) return;

    if (world.controlLock.isStunned(player, currentTick)) return;

    final axis = world.playerInput.moveAxis[inputIndex];
    final Facing facing = axis != 0
        ? (axis > 0 ? Facing.right : Facing.left)
        : world.movement.facing[movementIndex];

    final bufferIndex = world.abilityInputBuffer.tryIndexOf(player);
    if (bufferIndex == null) {
      assert(
        false,
        'AbilityActivationSystem requires AbilityInputBufferStore on the player; add it at spawn time.',
      );
      return;
    }

    _expireBuffer(world, player, bufferIndex, currentTick);

    final activePhase = _activePhaseFor(world, player);
    final hasActive = activePhase != AbilityPhase.idle;
    final isRecovery = activePhase == AbilityPhase.recovery;

    final input = world.playerInput;
    if (input.dashPressed[inputIndex]) {
      _cancelCombatOnMobilityPress(world, player);
      _commitSlot(
        world,
        player: player,
        loadoutIndex: loadoutIndex,
        inputIndex: inputIndex,
        movementIndex: movementIndex,
        facing: facing,
        slot: AbilitySlot.mobility,
        commitTick: currentTick,
      );
      return;
    }
    if (input.jumpPressed[inputIndex]) {
      _cancelCombatOnMobilityPress(world, player);
      _commitSlot(
        world,
        player: player,
        loadoutIndex: loadoutIndex,
        inputIndex: inputIndex,
        movementIndex: movementIndex,
        facing: facing,
        slot: AbilitySlot.jump,
        commitTick: currentTick,
      );
      return;
    }

    final slotPressed = _resolvePressedSlot(world, inputIndex);

    if (hasActive) {
      if (slotPressed != null && isRecovery) {
        _bufferInput(
          world,
          player: player,
          bufferIndex: bufferIndex,
          loadoutIndex: loadoutIndex,
          inputIndex: inputIndex,
          facing: facing,
          slot: slotPressed,
          currentTick: currentTick,
        );
      }
      return;
    }

    if (slotPressed != null) {
      _commitSlot(
        world,
        player: player,
        loadoutIndex: loadoutIndex,
        inputIndex: inputIndex,
        movementIndex: movementIndex,
        facing: facing,
        slot: slotPressed,
        commitTick: currentTick,
      );
      return;
    }

    if (world.abilityInputBuffer.hasBuffered[bufferIndex]) {
      _commitBuffered(
        world,
        player: player,
        bufferIndex: bufferIndex,
        loadoutIndex: loadoutIndex,
        movementIndex: movementIndex,
        commitTick: currentTick,
      );
    }
  }

  AbilityPhase _activePhaseFor(EcsWorld world, EntityId entity) {
    if (!world.activeAbility.has(entity)) return AbilityPhase.idle;
    final index = world.activeAbility.indexOf(entity);
    final abilityId = world.activeAbility.abilityId[index];
    if (abilityId == null || abilityId.isEmpty) return AbilityPhase.idle;
    return world.activeAbility.phase[index];
  }

  AbilitySlot? _resolvePressedSlot(EcsWorld world, int inputIndex) {
    final input = world.playerInput;
    if (input.hasAbilitySlotPressed[inputIndex]) {
      return input.lastAbilitySlotPressed[inputIndex];
    }
    if (input.strikePressed[inputIndex]) return AbilitySlot.primary;
    if (input.secondaryPressed[inputIndex]) return AbilitySlot.secondary;
    if (input.projectilePressed[inputIndex]) return AbilitySlot.projectile;
    if (input.spellPressed[inputIndex]) return AbilitySlot.spell;
    return null;
  }

  void _expireBuffer(
    EcsWorld world,
    EntityId player,
    int bufferIndex,
    int currentTick,
  ) {
    if (!world.abilityInputBuffer.hasBuffered[bufferIndex]) return;
    final expires = world.abilityInputBuffer.expiresTick[bufferIndex];
    if (expires >= 0 && currentTick > expires) {
      world.abilityInputBuffer.clear(player);
    }
  }

  void _bufferInput(
    EcsWorld world, {
    required EntityId player,
    required int bufferIndex,
    required int loadoutIndex,
    required int inputIndex,
    required Facing facing,
    required AbilitySlot slot,
    required int currentTick,
  }) {
    final abilityId = _abilityIdForSlot(
      world,
      loadoutIndex,
      slot,
      inputIndex: inputIndex,
    );
    if (abilityId == null) return;
    final ability = abilities.resolve(abilityId);
    if (ability == null) return;

    final aim = _aimForAbility(world, inputIndex, ability);

    world.abilityInputBuffer.setBuffer(
      player,
      slot: slot,
      abilityId: abilityId,
      aimDirX: aim.$1,
      aimDirY: aim.$2,
      facing: facing,
      commitTick: currentTick,
      expiresTick: currentTick + inputBufferTicks,
    );
  }

  void _commitBuffered(
    EcsWorld world, {
    required EntityId player,
    required int bufferIndex,
    required int loadoutIndex,
    required int movementIndex,
    required int commitTick,
  }) {
    final slot = world.abilityInputBuffer.slot[bufferIndex];
    final abilityId = world.abilityInputBuffer.abilityId[bufferIndex];
    final aimX = world.abilityInputBuffer.aimDirX[bufferIndex];
    final aimY = world.abilityInputBuffer.aimDirY[bufferIndex];
    final facing = world.abilityInputBuffer.facing[bufferIndex];

    final committed = _commitSlot(
      world,
      player: player,
      loadoutIndex: loadoutIndex,
      inputIndex: null,
      movementIndex: movementIndex,
      facing: facing,
      slot: slot,
      commitTick: commitTick,
      aimOverrideX: aimX,
      aimOverrideY: aimY,
      abilityOverrideId: abilityId,
    );

    if (committed) {
      world.abilityInputBuffer.clear(player);
    }
  }

  AbilityKey? _abilityIdForSlot(
    EcsWorld world,
    int loadoutIndex,
    AbilitySlot slot, {
    int? inputIndex,
  }) {
    final loadout = world.equippedLoadout;
    switch (slot) {
      case AbilitySlot.primary:
        return loadout.abilityPrimaryId[loadoutIndex];
      case AbilitySlot.secondary:
        return loadout.abilitySecondaryId[loadoutIndex];
      case AbilitySlot.projectile:
        return loadout.abilityProjectileId[loadoutIndex];
      case AbilitySlot.mobility:
        return loadout.abilityMobilityId[loadoutIndex];
      case AbilitySlot.jump:
        return loadout.abilityJumpId[loadoutIndex];
      case AbilitySlot.spell:
        return loadout.abilitySpellId[loadoutIndex];
    }
  }

  (double, double) _aimForAbility(
    EcsWorld world,
    int inputIndex,
    AbilityDef ability,
  ) {
    final input = world.playerInput;
    if (ability.targetingModel == TargetingModel.none) return (0.0, 0.0);
    return (input.aimDirX[inputIndex], input.aimDirY[inputIndex]);
  }

  bool _commitSlot(
    EcsWorld world, {
    required EntityId player,
    required int loadoutIndex,
    required int movementIndex,
    required Facing facing,
    required AbilitySlot slot,
    required int commitTick,
    int? inputIndex,
    double? aimOverrideX,
    double? aimOverrideY,
    AbilityKey? abilityOverrideId,
  }) {
    final abilityId =
        abilityOverrideId ??
        _abilityIdForSlot(world, loadoutIndex, slot, inputIndex: inputIndex);
    if (abilityId == null) return false;

    final ability = abilities.resolve(abilityId);
    if (ability == null) {
      assert(false, 'Ability not found: $abilityId');
      return false;
    }

    if (!ability.allowedSlots.contains(slot)) {
      return false;
    }

    if (_isChargeCommitBlocked(
      world,
      player: player,
      slot: slot,
      ability: ability,
    )) {
      return false;
    }

    if (ability.category == AbilityCategory.mobility) {
      return _commitMobility(
        world,
        player: player,
        loadoutIndex: loadoutIndex,
        movementIndex: movementIndex,
        inputIndex: inputIndex,
        ability: ability,
        slot: slot,
        commitTick: commitTick,
        aimOverrideX: aimOverrideX,
        aimOverrideY: aimOverrideY,
      );
    }

    final hitDelivery = ability.hitDelivery;
    if (hitDelivery is MeleeHitDelivery) {
      return _commitMelee(
        world,
        player: player,
        loadoutIndex: loadoutIndex,
        inputIndex: inputIndex,
        ability: ability,
        slot: slot,
        commitTick: commitTick,
        aimOverrideX: aimOverrideX,
        aimOverrideY: aimOverrideY,
      );
    }
    if (hitDelivery is ProjectileHitDelivery) {
      return _commitProjectile(
        world,
        player: player,
        loadoutIndex: loadoutIndex,
        inputIndex: inputIndex,
        movementIndex: movementIndex,
        ability: ability,
        slot: slot,
        commitTick: commitTick,
        aimOverrideX: aimOverrideX,
        aimOverrideY: aimOverrideY,
      );
    }
    if (hitDelivery is SelfHitDelivery) {
      return _commitSelf(
        world,
        player: player,
        loadoutIndex: loadoutIndex,
        facing: facing,
        ability: ability,
        slot: slot,
        commitTick: commitTick,
      );
    }

    return false;
  }

  bool _isChargeCommitBlocked(
    EcsWorld world, {
    required EntityId player,
    required AbilitySlot slot,
    required AbilityDef ability,
  }) {
    if (ability.chargeProfile == null) return false;
    return world.abilityCharge.slotChargeCanceled(player, slot);
  }

  bool _commitSelf(
    EcsWorld world, {
    required EntityId player,
    required int loadoutIndex,
    required Facing facing,
    required AbilityDef ability,
    required AbilitySlot slot,
    required int commitTick,
  }) {
    if (!world.selfIntent.has(player)) {
      assert(
        false,
        'AbilityActivationSystem requires SelfIntentStore on the player; add it at spawn time.',
      );
      return false;
    }

    // Gate by payload source (Bonus can host anything, so slot is irrelevant).
    final mask = world.equippedLoadout.mask[loadoutIndex];
    switch (ability.payloadSource) {
      case AbilityPayloadSource.none:
        break;
      case AbilityPayloadSource.primaryWeapon:
        if ((mask & LoadoutSlotMask.mainHand) == 0) return false;
        break;
      case AbilityPayloadSource.secondaryWeapon:
        // Off-hand unless primary is two-handed.
        final mainId = world.equippedLoadout.mainWeaponId[loadoutIndex];
        final main = weapons.tryGet(mainId);
        if (main != null && main.isTwoHanded) {
          if ((mask & LoadoutSlotMask.mainHand) == 0) return false;
        } else {
          if ((mask & LoadoutSlotMask.offHand) == 0) return false;
        }
        break;
      case AbilityPayloadSource.projectile:
        if ((mask & LoadoutSlotMask.projectile) == 0) return false;
        break;
      case AbilityPayloadSource.spellBook:
        final spellBookId = world.equippedLoadout.spellBookId[loadoutIndex];
        final spellBook = spellBooks.tryGet(spellBookId);
        if (spellBook == null) return false;
        if (slot == AbilitySlot.spell &&
            !spellBook.containsSpellAbility(ability.id)) {
          return false;
        }
        break;
    }

    final commitCost = resolveEffectiveAbilityCostForSlot(
      ability: ability,
      loadout: world.equippedLoadout,
      loadoutIndex: loadoutIndex,
      slot: slot,
      weapons: weapons,
      projectiles: projectiles,
      spellBooks: spellBooks,
    );
    final actionSpeedBp = _actionSpeedBpFor(world, player, slot: slot);
    final windupTicks = _scaleTicksForActionSpeed(
      _scaleAbilityTicks(ability.windupTicks),
      actionSpeedBp,
    );
    final activeTicks = _scaleAbilityTicks(ability.activeTicks);
    final recoveryTicks = _scaleTicksForActionSpeed(
      _scaleAbilityTicks(ability.recoveryTicks),
      actionSpeedBp,
    );
    final executeTick = commitTick + windupTicks;
    final cooldownGroupId = ability.effectiveCooldownGroup(slot);
    final resolvedStats = _resolvedStatsForLoadout(world, player);
    final baseCooldownTicks = resolvedStats.applyCooldownReduction(
      _scaleAbilityTicks(ability.cooldownTicks),
    );
    final cooldownTicks = _scaleTicksForActionSpeed(
      baseCooldownTicks,
      actionSpeedBp,
    );

    final fail = AbilityGate.canCommitCombat(
      world,
      entity: player,
      currentTick: commitTick,
      cooldownGroupId: cooldownGroupId,
      healthCost100: commitCost.healthCost100,
      manaCost100: commitCost.manaCost100,
      staminaCost100: commitCost.staminaCost100,
    );
    if (fail != null) return false;
    if (ability.holdMode == AbilityHoldMode.holdToMaintain &&
        ability.holdStaminaDrainPerSecond100 > 0) {
      final staminaIndex = world.stamina.tryIndexOf(player);
      if (staminaIndex == null) return false;
      if (world.stamina.stamina[staminaIndex] <= 0) return false;
    }

    _applyCommitSideEffects(
      world,
      player: player,
      abilityId: ability.id,
      slot: slot,
      commitTick: commitTick,
      windupTicks: windupTicks,
      activeTicks: activeTicks,
      recoveryTicks: recoveryTicks,
      facingDir: facing,
      cooldownGroupId: cooldownGroupId,
      cooldownTicks: cooldownTicks,
      healthCost100: commitCost.healthCost100,
      manaCost100: commitCost.manaCost100,
      staminaCost100: commitCost.staminaCost100,
    );

    world.selfIntent.set(
      player,
      SelfIntentDef(
        abilityId: ability.id,
        slot: slot,
        selfStatusProfileId: ability.selfStatusProfileId,
        commitTick: commitTick,
        windupTicks: windupTicks,
        activeTicks: activeTicks,
        recoveryTicks: recoveryTicks,
        cooldownTicks: cooldownTicks,
        staminaCost100: commitCost.staminaCost100,
        manaCost100: commitCost.manaCost100,
        cooldownGroupId: cooldownGroupId,
        tick: executeTick,
      ),
    );
    return true;
  }

  bool _commitMobility(
    EcsWorld world, {
    required EntityId player,
    required int loadoutIndex,
    required int movementIndex,
    required AbilityDef ability,
    required AbilitySlot slot,
    required int commitTick,
    int? inputIndex,
    double? aimOverrideX,
    double? aimOverrideY,
  }) {
    if (!world.mobilityIntent.has(player)) {
      assert(
        false,
        'AbilityActivationSystem requires MobilityIntentStore on the player; add it at spawn time.',
      );
      return false;
    }

    final rawAimX =
        aimOverrideX ??
        (inputIndex == null ? 0.0 : world.playerInput.aimDirX[inputIndex]);
    final rawAimY =
        aimOverrideY ??
        (inputIndex == null ? 0.0 : world.playerInput.aimDirY[inputIndex]);
    final windupTicks = _scaleAbilityTicks(ability.windupTicks);
    final activeTicks = _scaleAbilityTicks(ability.activeTicks);
    final recoveryTicks = _scaleAbilityTicks(ability.recoveryTicks);
    final directionalFallback = _directionalFallbackDirection(
      world,
      movementIndex: movementIndex,
      inputIndex: inputIndex,
    );
    final dir = _resolveCommitDirection(
      world,
      source: player,
      ability: ability,
      rawAimX: rawAimX,
      rawAimY: rawAimY,
      directionalFallbackX: directionalFallback.$1,
      directionalFallbackY: directionalFallback.$2,
      homingWindupTicks: windupTicks,
      homingProjectileSpeedUnitsPerSecond: null,
    );
    final dirX = dir.$1;
    final dirY = dir.$2;
    final executeTick = commitTick + windupTicks;
    final cooldownGroupId = ability.effectiveCooldownGroup(slot);
    final resolvedStats = _resolvedStatsForLoadout(world, player);
    final cooldownTicks = resolvedStats.applyCooldownReduction(
      _scaleAbilityTicks(ability.cooldownTicks),
    );
    final chargeTicks = _resolveCommitChargeTicks(
      world,
      player: player,
      slot: slot,
      commitTick: commitTick,
    );
    final chargeTuning = _resolveChargeTuning(
      ability: ability,
      chargeTicks: chargeTicks,
      defaults: const _ChargeTuning(
        damageScaleBp: 10000,
        critBonusBp: 0,
        speedScaleBp: 10000,
      ),
    );
    final commitCost = resolveEffectiveAbilityCostForSlot(
      ability: ability,
      loadout: world.equippedLoadout,
      loadoutIndex: loadoutIndex,
      slot: slot,
      weapons: weapons,
      projectiles: projectiles,
      spellBooks: spellBooks,
    );

    // Preserve old behavior: mobility cancels pending combat + buffered input + active combat ability.
    _cancelCombatOnMobilityPress(world, player);

    final isJump = slot == AbilitySlot.jump;
    final fail = AbilityGate.canCommitMobility(
      world,
      entity: player,
      currentTick: commitTick,
      cooldownGroupId: cooldownGroupId,
      healthCost100: isJump ? 0 : commitCost.healthCost100,
      manaCost100: isJump ? 0 : commitCost.manaCost100,
      staminaCost100: isJump ? 0 : commitCost.staminaCost100,
    );
    if (fail != null) return false;

    // Jump resolves resources/execution in JumpSystem (ground vs air costs).
    if (!isJump) {
      final facingDir = _facingFromDirectionX(
        dirX,
        fallbackDirX: directionalFallback.$1,
      );
      _applyCommitSideEffects(
        world,
        player: player,
        abilityId: ability.id,
        slot: slot,
        commitTick: commitTick,
        windupTicks: windupTicks,
        activeTicks: activeTicks,
        recoveryTicks: recoveryTicks,
        facingDir: facingDir,
        cooldownGroupId: cooldownGroupId,
        cooldownTicks: cooldownTicks,
        healthCost100: commitCost.healthCost100,
        manaCost100: commitCost.manaCost100,
        staminaCost100: commitCost.staminaCost100,
        movementIndex: movementIndex,
      );
    }

    world.mobilityIntent.set(
      player,
      MobilityIntentDef(
        abilityId: ability.id,
        slot: slot,
        dirX: dirX,
        dirY: dirY,
        speedScaleBp: chargeTuning.speedScaleBp,
        mobilitySpeedX: ability.mobilitySpeedX ?? 0,
        commitTick: commitTick,
        windupTicks: windupTicks,
        activeTicks: activeTicks,
        recoveryTicks: recoveryTicks,
        cooldownTicks: cooldownTicks,
        staminaCost100: commitCost.staminaCost100,
        cooldownGroupId: cooldownGroupId,
        tick: executeTick,
      ),
    );
    return true;
  }

  bool _commitMelee(
    EcsWorld world, {
    required EntityId player,
    required int loadoutIndex,
    required AbilityDef ability,
    required AbilitySlot slot,
    required int commitTick,
    int? inputIndex,
    double? aimOverrideX,
    double? aimOverrideY,
  }) {
    if (!world.meleeIntent.has(player)) {
      assert(
        false,
        'AbilityActivationSystem requires MeleeIntentStore on the player; add it at spawn time.',
      );
      return false;
    }

    final mask = world.equippedLoadout.mask[loadoutIndex];
    // Gate by payload source, not by triggered slot.
    switch (ability.payloadSource) {
      case AbilityPayloadSource.none:
        break;
      case AbilityPayloadSource.primaryWeapon:
        if ((mask & LoadoutSlotMask.mainHand) == 0) return false;
        break;
      case AbilityPayloadSource.secondaryWeapon:
        final mainId = world.equippedLoadout.mainWeaponId[loadoutIndex];
        final main = weapons.tryGet(mainId);
        if (main != null && main.isTwoHanded) {
          if ((mask & LoadoutSlotMask.mainHand) == 0) return false;
        } else {
          if ((mask & LoadoutSlotMask.offHand) == 0) return false;
        }
        break;
      case AbilityPayloadSource.projectile:
        // Melee delivery cannot legally pull payload from projectile item.
        return false;
      case AbilityPayloadSource.spellBook:
        // Melee delivery cannot legally pull payload from spell book.
        return false;
    }

    final hitDelivery = ability.hitDelivery;
    if (hitDelivery is! MeleeHitDelivery) return false;

    final rawAimX =
        aimOverrideX ??
        (inputIndex == null ? 0.0 : world.playerInput.aimDirX[inputIndex]);
    final rawAimY =
        aimOverrideY ??
        (inputIndex == null ? 0.0 : world.playerInput.aimDirY[inputIndex]);
    final actionSpeedBp = _actionSpeedBpFor(world, player, slot: slot);
    final windupTicks = _scaleTicksForActionSpeed(
      _scaleAbilityTicks(ability.windupTicks),
      actionSpeedBp,
    );
    final activeTicks = _scaleAbilityTicks(ability.activeTicks);
    final recoveryTicks = _scaleTicksForActionSpeed(
      _scaleAbilityTicks(ability.recoveryTicks),
      actionSpeedBp,
    );
    final directionalFallback = _directionalFallbackDirection(
      world,
      movementIndex: world.movement.indexOf(player),
      inputIndex: inputIndex,
    );
    final dir = _resolveCommitDirection(
      world,
      source: player,
      ability: ability,
      rawAimX: rawAimX,
      rawAimY: rawAimY,
      directionalFallbackX: directionalFallback.$1,
      directionalFallbackY: directionalFallback.$2,
      homingWindupTicks: windupTicks,
      homingProjectileSpeedUnitsPerSecond: null,
    );
    final dirX = dir.$1;
    final dirY = dir.$2;

    final chargeTicks = _resolveCommitChargeTicks(
      world,
      player: player,
      slot: slot,
      commitTick: commitTick,
    );
    final chargeTuning = _resolveChargeTuning(
      ability: ability,
      chargeTicks: chargeTicks,
      defaults: const _ChargeTuning(
        damageScaleBp: 10000,
        critBonusBp: 0,
        speedScaleBp: 10000,
      ),
    );

    // Resolve hitbox dimensions from the ability.
    final baseHalfX = hitDelivery.sizeX * 0.5;
    final baseHalfY = hitDelivery.sizeY * 0.5;
    final halfX = baseHalfX;
    final halfY = baseHalfY;

    // Offset: push the hitbox forward from the player collider.
    var maxHalfExtent = 0.0;
    if (world.colliderAabb.has(player)) {
      final aabbi = world.colliderAabb.indexOf(player);
      final colliderHalfX = world.colliderAabb.halfX[aabbi];
      final colliderHalfY = world.colliderAabb.halfY[aabbi];
      maxHalfExtent = colliderHalfX > colliderHalfY
          ? colliderHalfX
          : colliderHalfY;
    }
    final forward =
        maxHalfExtent * 0.5 + max(halfX, halfY) + hitDelivery.offsetX;
    final offsetX = dirX * forward;
    final offsetY = dirY * forward + hitDelivery.offsetY;

    final weaponId = () {
      switch (ability.payloadSource) {
        case AbilityPayloadSource.primaryWeapon:
          return world.equippedLoadout.mainWeaponId[loadoutIndex];
        case AbilityPayloadSource.secondaryWeapon:
          final mainId = world.equippedLoadout.mainWeaponId[loadoutIndex];
          final main = weapons.tryGet(mainId);
          if (main != null && main.isTwoHanded) return mainId;
          return world.equippedLoadout.offhandWeaponId[loadoutIndex];
        case AbilityPayloadSource.none:
          // Fallback: preserve old behavior (slot-based) for any legacy melee.
          return slot == AbilitySlot.secondary
              ? world.equippedLoadout.offhandWeaponId[loadoutIndex]
              : world.equippedLoadout.mainWeaponId[loadoutIndex];
        case AbilityPayloadSource.projectile:
          return world.equippedLoadout.mainWeaponId[loadoutIndex];
        case AbilityPayloadSource.spellBook:
          return world.equippedLoadout.mainWeaponId[loadoutIndex];
      }
    }();
    final weapon = weapons.get(weaponId);
    final commitCost = resolveEffectiveAbilityCostForSlot(
      ability: ability,
      loadout: world.equippedLoadout,
      loadoutIndex: loadoutIndex,
      slot: slot,
      weapons: weapons,
      projectiles: projectiles,
      spellBooks: spellBooks,
    );
    final resolvedStats = _resolvedStatsForLoadout(world, player);

    final payload = HitPayloadBuilder.build(
      ability: ability,
      source: player,
      weaponStats: weapon.stats,
      globalPowerBonusBp: resolvedStats.globalPowerBonusBp,
      weaponDamageType: weapon.damageType,
      weaponProcs: weapon.procs,
      globalCritChanceBonusBp: resolvedStats.globalCritChanceBonusBp,
    );
    final tunedDamage100 =
        (payload.damage100 * chargeTuning.damageScaleBp) ~/ 10000;
    final tunedCritChanceBp = clampInt(
      payload.critChanceBp + chargeTuning.critBonusBp,
      0,
      10000,
    );

    final cooldownGroupId = ability.effectiveCooldownGroup(slot);
    final baseCooldownTicks = resolvedStats.applyCooldownReduction(
      _scaleAbilityTicks(ability.cooldownTicks),
    );
    final cooldownTicks = _scaleTicksForActionSpeed(
      baseCooldownTicks,
      actionSpeedBp,
    );

    final fail = AbilityGate.canCommitCombat(
      world,
      entity: player,
      currentTick: commitTick,
      cooldownGroupId: cooldownGroupId,
      healthCost100: commitCost.healthCost100,
      manaCost100: commitCost.manaCost100,
      staminaCost100: commitCost.staminaCost100,
    );
    if (fail != null) return false;

    final facingDir = _facingFromDirectionX(
      dirX,
      fallbackDirX: directionalFallback.$1,
    );
    _applyCommitSideEffects(
      world,
      player: player,
      abilityId: ability.id,
      slot: slot,
      commitTick: commitTick,
      windupTicks: windupTicks,
      activeTicks: activeTicks,
      recoveryTicks: recoveryTicks,
      facingDir: facingDir,
      cooldownGroupId: cooldownGroupId,
      cooldownTicks: cooldownTicks,
      healthCost100: commitCost.healthCost100,
      manaCost100: commitCost.manaCost100,
      staminaCost100: commitCost.staminaCost100,
    );

    world.meleeIntent.set(
      player,
      MeleeIntentDef(
        abilityId: ability.id,
        slot: slot,
        damage100: tunedDamage100,
        critChanceBp: tunedCritChanceBp,
        damageType: payload.damageType,
        procs: payload.procs,
        halfX: halfX,
        halfY: halfY,
        offsetX: offsetX,
        offsetY: offsetY,
        dirX: dirX,
        dirY: dirY,
        commitTick: commitTick,
        windupTicks: windupTicks,
        activeTicks: activeTicks,
        recoveryTicks: recoveryTicks,
        cooldownTicks: cooldownTicks,
        staminaCost100: commitCost.staminaCost100,
        cooldownGroupId: cooldownGroupId,
        tick: commitTick + windupTicks,
      ),
    );
    return true;
  }

  bool _commitProjectile(
    EcsWorld world, {
    required EntityId player,
    required int loadoutIndex,
    required int movementIndex,
    required AbilityDef ability,
    required AbilitySlot slot,
    required int commitTick,
    int? inputIndex,
    double? aimOverrideX,
    double? aimOverrideY,
  }) {
    if (!world.projectileIntent.has(player)) {
      assert(
        false,
        'AbilityActivationSystem requires ProjectileIntentStore on the player; add it at spawn time.',
      );
      return false;
    }

    // Projectile delivery must pull payload from a projectile item or spell book.
    if (ability.payloadSource != AbilityPayloadSource.projectile &&
        ability.payloadSource != AbilityPayloadSource.spellBook) {
      return false;
    }
    final mask = world.equippedLoadout.mask[loadoutIndex];
    if ((mask & LoadoutSlotMask.projectile) == 0) return false;

    if (ability.category != AbilityCategory.ranged) {
      return false;
    }

    final hitDelivery = ability.hitDelivery;
    if (hitDelivery is! ProjectileHitDelivery) return false;
    final actionSpeedBp = _actionSpeedBpFor(world, player, slot: slot);
    final windupTicks = _scaleTicksForActionSpeed(
      _scaleAbilityTicks(ability.windupTicks),
      actionSpeedBp,
    );
    final activeTicks = _scaleAbilityTicks(ability.activeTicks);
    final recoveryTicks = _scaleTicksForActionSpeed(
      _scaleAbilityTicks(ability.recoveryTicks),
      actionSpeedBp,
    );

    final ProjectileId projectileId;
    final bool ballistic;
    final double gravityScale;
    final double originOffset;
    final double projectileBaseSpeedUnitsPerSecond;
    GearStatBonuses? weaponStats;
    DamageType? weaponDamageType;
    List<WeaponProc> weaponProcs = const <WeaponProc>[];

    switch (ability.payloadSource) {
      case AbilityPayloadSource.projectile:
        final equippedId = resolveProjectilePayloadForAbilitySlot(
          ability: ability,
          loadout: world.equippedLoadout,
          loadoutIndex: loadoutIndex,
          slot: slot,
          projectiles: projectiles,
          spellBooks: spellBooks,
        );
        final projectile = projectiles.tryGet(equippedId);
        if (projectile == null) {
          assert(false, 'Projectile item not found: $equippedId');
          return false;
        }
        if (ability.requiredWeaponTypes.isNotEmpty &&
            !ability.requiredWeaponTypes.contains(projectile.weaponType)) {
          return false;
        }
        projectileId = equippedId;
        ballistic = projectile.ballistic;
        gravityScale = projectile.gravityScale;
        projectileBaseSpeedUnitsPerSecond = projectile.speedUnitsPerSecond;
        originOffset =
            projectile.weaponType == WeaponType.projectileSpell &&
                projectile.originOffset == 0
            ? _spellOriginOffset(world, player)
            : projectile.originOffset;
        weaponStats = projectile.stats;
        weaponDamageType = projectile.damageType;
        weaponProcs = projectile.procs;
        break;
      case AbilityPayloadSource.spellBook:
        final spellBookId = world.equippedLoadout.spellBookId[loadoutIndex];
        final spellBook = spellBooks.tryGet(spellBookId);
        if (spellBook == null) {
          assert(false, 'Spell book not found: $spellBookId');
          return false;
        }
        projectileId = hitDelivery.projectileId;
        projectileBaseSpeedUnitsPerSecond = projectiles
            .get(projectileId)
            .speedUnitsPerSecond;
        ballistic = false;
        gravityScale = 1.0;
        originOffset = _spellOriginOffset(world, player);
        weaponStats = spellBook.stats;
        weaponDamageType = spellBook.damageType;
        weaponProcs = spellBook.procs;
        break;
      case AbilityPayloadSource.none:
      case AbilityPayloadSource.primaryWeapon:
      case AbilityPayloadSource.secondaryWeapon:
        return false;
    }

    final chargeTicks = _resolveCommitChargeTicks(
      world,
      player: player,
      slot: slot,
      commitTick: commitTick,
    );
    final basePierce = hitDelivery.pierce;
    final baseMaxPierceHits = _maxPierceHitsFor(hitDelivery);
    final chargeTuning = _resolveChargeTuning(
      ability: ability,
      chargeTicks: chargeTicks,
      defaults: _ChargeTuning(
        damageScaleBp: 10000,
        critBonusBp: 0,
        speedScaleBp: 10000,
        pierce: basePierce,
        maxPierceHits: baseMaxPierceHits,
      ),
    );

    final rawAimX =
        aimOverrideX ??
        (inputIndex == null ? 0.0 : world.playerInput.aimDirX[inputIndex]);
    final rawAimY =
        aimOverrideY ??
        (inputIndex == null ? 0.0 : world.playerInput.aimDirY[inputIndex]);
    final directionalFallback = _directionalFallbackDirection(
      world,
      movementIndex: movementIndex,
      inputIndex: inputIndex,
    );
    final fallbackDirX = directionalFallback.$1;
    final fallbackDirY = directionalFallback.$2;
    final resolvedDir = _resolveCommitDirection(
      world,
      source: player,
      ability: ability,
      rawAimX: rawAimX,
      rawAimY: rawAimY,
      directionalFallbackX: fallbackDirX,
      directionalFallbackY: fallbackDirY,
      homingWindupTicks: windupTicks,
      homingProjectileSpeedUnitsPerSecond:
          projectileBaseSpeedUnitsPerSecond *
          (chargeTuning.speedScaleBp / 10000.0),
    );
    final aimX = resolvedDir.$1;
    final aimY = resolvedDir.$2;

    if (ability.category == AbilityCategory.ranged) {
      final dirX = aimX;
      if (dirX.abs() > 1e-6) {
        world.movement.facing[movementIndex] = dirX >= 0
            ? Facing.right
            : Facing.left;
        world.movement.facingLockTicksLeft[movementIndex] = 1;
      }
    }

    final resolvedStats = _resolvedStatsForLoadout(world, player);

    final payload = HitPayloadBuilder.build(
      ability: ability,
      source: player,
      weaponStats: weaponStats,
      globalPowerBonusBp: resolvedStats.globalPowerBonusBp,
      weaponDamageType: weaponDamageType,
      weaponProcs: weaponProcs,
      globalCritChanceBonusBp: resolvedStats.globalCritChanceBonusBp,
    );
    final tunedDamage100 =
        (payload.damage100 * chargeTuning.damageScaleBp) ~/ 10000;
    final tunedCritChanceBp = clampInt(
      payload.critChanceBp + chargeTuning.critBonusBp,
      0,
      10000,
    );

    final cooldownGroupId = ability.effectiveCooldownGroup(slot);
    final baseCooldownTicks = resolvedStats.applyCooldownReduction(
      _scaleAbilityTicks(ability.cooldownTicks),
    );
    final cooldownTicks = _scaleTicksForActionSpeed(
      baseCooldownTicks,
      actionSpeedBp,
    );
    final commitCost = resolveEffectiveAbilityCostForSlot(
      ability: ability,
      loadout: world.equippedLoadout,
      loadoutIndex: loadoutIndex,
      slot: slot,
      weapons: weapons,
      projectiles: projectiles,
      spellBooks: spellBooks,
    );

    final fail = AbilityGate.canCommitCombat(
      world,
      entity: player,
      currentTick: commitTick,
      cooldownGroupId: cooldownGroupId,
      healthCost100: commitCost.healthCost100,
      manaCost100: commitCost.manaCost100,
      staminaCost100: commitCost.staminaCost100,
    );
    if (fail != null) return false;

    final facingDir = _facingFromDirectionX(aimX, fallbackDirX: fallbackDirX);
    _applyCommitSideEffects(
      world,
      player: player,
      abilityId: ability.id,
      slot: slot,
      commitTick: commitTick,
      windupTicks: windupTicks,
      activeTicks: activeTicks,
      recoveryTicks: recoveryTicks,
      facingDir: facingDir,
      cooldownGroupId: cooldownGroupId,
      cooldownTicks: cooldownTicks,
      healthCost100: commitCost.healthCost100,
      manaCost100: commitCost.manaCost100,
      staminaCost100: commitCost.staminaCost100,
    );

    world.projectileIntent.set(
      player,
      ProjectileIntentDef(
        projectileId: projectileId,
        abilityId: ability.id,
        slot: slot,
        damage100: tunedDamage100,
        critChanceBp: tunedCritChanceBp,
        staminaCost100: commitCost.staminaCost100,
        manaCost100: commitCost.manaCost100,
        cooldownTicks: cooldownTicks,
        cooldownGroupId: cooldownGroupId,
        damageType: payload.damageType,
        procs: payload.procs,
        ballistic: ballistic,
        gravityScale: gravityScale,
        speedScaleBp: chargeTuning.speedScaleBp,
        dirX: aimX,
        dirY: aimY,
        fallbackDirX: fallbackDirX,
        fallbackDirY: fallbackDirY,
        originOffset: originOffset,
        pierce: chargeTuning.pierce ?? basePierce,
        maxPierceHits: chargeTuning.maxPierceHits ?? baseMaxPierceHits,
        commitTick: commitTick,
        windupTicks: windupTicks,
        activeTicks: activeTicks,
        recoveryTicks: recoveryTicks,
        tick: commitTick + windupTicks,
      ),
    );
    return true;
  }

  _ChargeTuning _resolveChargeTuning({
    required AbilityDef ability,
    required int chargeTicks,
    required _ChargeTuning defaults,
  }) {
    final profile = ability.chargeProfile;
    if (profile == null) return defaults;

    final holdTicks = chargeTicks < 0 ? 0 : chargeTicks;
    var resolved = defaults;
    for (final tier in profile.tiers) {
      final minHoldTicks = _scaleAbilityTicks(tier.minHoldTicks60);
      if (holdTicks < minHoldTicks) continue;
      resolved = _ChargeTuning(
        damageScaleBp: tier.damageScaleBp,
        critBonusBp: tier.critBonusBp,
        speedScaleBp: tier.speedScaleBp,
        pierce: tier.pierce ?? defaults.pierce,
        maxPierceHits: tier.maxPierceHits ?? defaults.maxPierceHits,
      );
    }
    return resolved;
  }

  int _resolveCommitChargeTicks(
    EcsWorld world, {
    required EntityId player,
    required AbilitySlot slot,
    required int commitTick,
  }) {
    final authoritative = world.abilityCharge.commitChargeTicksOrUntracked(
      player,
      slot: slot,
      currentTick: commitTick,
    );
    return authoritative >= 0 ? authoritative : 0;
  }

  int _maxPierceHitsFor(ProjectileHitDelivery hitDelivery) {
    if (!hitDelivery.pierce) return 1;
    if (hitDelivery.chainCount > 0) return hitDelivery.chainCount;
    // Keep explicit piercing behavior even when no count is authored.
    return 2;
  }

  (double, double) _resolveCommitDirection(
    EcsWorld world, {
    required EntityId source,
    required AbilityDef ability,
    required double rawAimX,
    required double rawAimY,
    required double directionalFallbackX,
    required double directionalFallbackY,
    required int homingWindupTicks,
    required double? homingProjectileSpeedUnitsPerSecond,
  }) {
    final targetSpecific = _resolveTargetSpecificDirection(
      world,
      source: source,
      ability: ability,
      rawAimX: rawAimX,
      rawAimY: rawAimY,
      directionalFallbackX: directionalFallbackX,
      directionalFallbackY: directionalFallbackY,
      homingWindupTicks: homingWindupTicks,
      homingProjectileSpeedUnitsPerSecond: homingProjectileSpeedUnitsPerSecond,
    );
    if (targetSpecific != null) return targetSpecific;

    final inputIndex = world.playerInput.tryIndexOf(source);
    if (inputIndex != null) {
      final globalAim = _normalizeDirectionOrNull(
        world.playerInput.aimDirX[inputIndex],
        world.playerInput.aimDirY[inputIndex],
      );
      if (globalAim != null) return globalAim;
    }

    final directionalFallback = _normalizeDirectionOrNull(
      directionalFallbackX,
      directionalFallbackY,
    );
    if (directionalFallback != null) return directionalFallback;
    return (1.0, 0.0);
  }

  (double, double)? _resolveTargetSpecificDirection(
    EcsWorld world, {
    required EntityId source,
    required AbilityDef ability,
    required double rawAimX,
    required double rawAimY,
    required double directionalFallbackX,
    required double directionalFallbackY,
    required int homingWindupTicks,
    required double? homingProjectileSpeedUnitsPerSecond,
  }) {
    switch (ability.targetingModel) {
      case TargetingModel.none:
        return null;
      case TargetingModel.homing:
        return _nearestHostileAim(
          world,
          source: source,
          windupTicks: homingWindupTicks,
          projectileSpeedUnitsPerSecond: homingProjectileSpeedUnitsPerSecond,
        );
      case TargetingModel.directional:
        return _normalizeDirectionOrNull(rawAimX, rawAimY) ??
            _normalizeDirectionOrNull(
              directionalFallbackX,
              directionalFallbackY,
            );
      case TargetingModel.aimed:
      case TargetingModel.aimedLine:
      case TargetingModel.aimedCharge:
      case TargetingModel.groundTarget:
        return _normalizeDirectionOrNull(rawAimX, rawAimY);
    }
  }

  (double, double)? _normalizeDirectionOrNull(double x, double y) {
    final len2 = x * x + y * y;
    if (len2 <= 1e-12) return null;
    final invLen = 1.0 / sqrt(len2);
    return (x * invLen, y * invLen);
  }

  (double, double) _directionalFallbackDirection(
    EcsWorld world, {
    required int movementIndex,
    required int? inputIndex,
  }) {
    final axis = inputIndex == null
        ? 0.0
        : world.playerInput.moveAxis[inputIndex];
    if (axis.abs() > 1e-6) {
      return (axis > 0 ? 1.0 : -1.0, 0.0);
    }
    final facing = world.movement.facing[movementIndex];
    return (facing == Facing.right ? 1.0 : -1.0, 0.0);
  }

  Facing _facingFromDirectionX(double dirX, {required double fallbackDirX}) {
    final primaryX = dirX.abs() > 1e-6 ? dirX : fallbackDirX;
    return primaryX >= 0 ? Facing.right : Facing.left;
  }

  (double, double)? _nearestHostileAim(
    EcsWorld world, {
    required EntityId source,
    required int windupTicks,
    required double? projectileSpeedUnitsPerSecond,
  }) {
    final sourceTi = world.transform.tryIndexOf(source);
    if (sourceTi == null) return null;
    final sourceFi = world.faction.tryIndexOf(source);
    if (sourceFi == null) return null;
    final sourceFaction = world.faction.faction[sourceFi];

    final sourceX = world.transform.posX[sourceTi];
    final sourceY = world.transform.posY[sourceTi];
    final sourceVelX = world.transform.velX[sourceTi];
    final sourceVelY = world.transform.velY[sourceTi];
    final windupSeconds = max(0.0, windupTicks.toDouble()) / tickHz;
    final sourceExecuteX = sourceX + sourceVelX * windupSeconds;
    final sourceExecuteY = sourceY + sourceVelY * windupSeconds;

    final hasProjectileLead =
        projectileSpeedUnitsPerSecond != null &&
        projectileSpeedUnitsPerSecond > 1e-6;

    var bestDist2 = double.infinity;
    var bestInterceptSeconds = double.infinity;
    var bestHasIntercept = false;
    var bestAimX = 0.0;
    var bestAimY = 0.0;
    var bestEntity = -1;

    final targets = world.health.denseEntities;
    for (var i = 0; i < targets.length; i += 1) {
      final target = targets[i];
      if (target == source || world.deathState.has(target)) continue;

      final targetFi = world.faction.tryIndexOf(target);
      if (targetFi == null) continue;
      if (areAllies(sourceFaction, world.faction.faction[targetFi])) continue;

      final targetTi = world.transform.tryIndexOf(target);
      if (targetTi == null) continue;
      final targetX = world.transform.posX[targetTi];
      final targetY = world.transform.posY[targetTi];
      final targetVelX = world.transform.velX[targetTi];
      final targetVelY = world.transform.velY[targetTi];

      final targetExecuteX = targetX + targetVelX * windupSeconds;
      final targetExecuteY = targetY + targetVelY * windupSeconds;
      final relX = targetExecuteX - sourceExecuteX;
      final relY = targetExecuteY - sourceExecuteY;
      final relDist2 = relX * relX + relY * relY;
      if (relDist2 <= 1e-12) continue;

      var candidateHasIntercept = false;
      var candidateInterceptSeconds = double.infinity;
      var candidateAimX = relX;
      var candidateAimY = relY;

      if (hasProjectileLead) {
        final interceptSeconds = _solveInterceptSeconds(
          relX: relX,
          relY: relY,
          targetVelX: targetVelX,
          targetVelY: targetVelY,
          projectileSpeedUnitsPerSecond: projectileSpeedUnitsPerSecond,
        );
        if (interceptSeconds != null) {
          candidateHasIntercept = true;
          candidateInterceptSeconds = interceptSeconds;
          candidateAimX = relX + targetVelX * interceptSeconds;
          candidateAimY = relY + targetVelY * interceptSeconds;
        }
      }

      final candidateAimLen2 =
          candidateAimX * candidateAimX + candidateAimY * candidateAimY;
      if (candidateAimLen2 <= 1e-12) continue;

      var take = false;
      if (bestEntity == -1) {
        take = true;
      } else if (hasProjectileLead) {
        if (candidateHasIntercept != bestHasIntercept) {
          take = candidateHasIntercept && !bestHasIntercept;
        } else if (candidateHasIntercept) {
          final faster =
              candidateInterceptSeconds < bestInterceptSeconds - 1e-9;
          final sameTime =
              (candidateInterceptSeconds - bestInterceptSeconds).abs() <= 1e-9;
          final betterTie = sameTime && target < bestEntity;
          take = faster || betterTie;
        } else {
          final closer = relDist2 < bestDist2 - 1e-9;
          final sameDist = (relDist2 - bestDist2).abs() <= 1e-9;
          final betterTie = sameDist && target < bestEntity;
          take = closer || betterTie;
        }
      } else {
        final closer = relDist2 < bestDist2 - 1e-9;
        final sameDist = (relDist2 - bestDist2).abs() <= 1e-9;
        final betterTie = sameDist && target < bestEntity;
        take = closer || betterTie;
      }

      if (take) {
        bestEntity = target;
        bestDist2 = relDist2;
        bestInterceptSeconds = candidateInterceptSeconds;
        bestHasIntercept = candidateHasIntercept;
        bestAimX = candidateAimX;
        bestAimY = candidateAimY;
      }
    }

    if (bestEntity == -1) return null;

    final bestAimLen2 = bestAimX * bestAimX + bestAimY * bestAimY;
    if (bestAimLen2 <= 1e-12) return null;
    final invLen = 1.0 / sqrt(bestAimLen2);
    return (bestAimX * invLen, bestAimY * invLen);
  }

  double? _solveInterceptSeconds({
    required double relX,
    required double relY,
    required double targetVelX,
    required double targetVelY,
    required double projectileSpeedUnitsPerSecond,
  }) {
    if (projectileSpeedUnitsPerSecond <= 1e-9) return null;
    final c = relX * relX + relY * relY;
    if (c <= 1e-12) return 0.0;

    final speed2 =
        projectileSpeedUnitsPerSecond * projectileSpeedUnitsPerSecond;
    final vv = targetVelX * targetVelX + targetVelY * targetVelY;
    final rv = relX * targetVelX + relY * targetVelY;
    final a = vv - speed2;
    final b = 2.0 * rv;

    // Degenerate to linear solve when quadratic term is tiny.
    if (a.abs() <= 1e-9) {
      if (b.abs() <= 1e-9) return null;
      final t = -c / b;
      return t >= 0.0 ? t : null;
    }

    final discriminant = b * b - 4.0 * a * c;
    if (discriminant < 0.0) return null;
    final sqrtDisc = sqrt(discriminant);
    final denom = 2.0 * a;
    final t0 = (-b - sqrtDisc) / denom;
    final t1 = (-b + sqrtDisc) / denom;

    double? best;
    if (t0 >= 0.0) best = t0;
    if (t1 >= 0.0 && (best == null || t1 < best)) best = t1;
    return best;
  }

  double _spellOriginOffset(EcsWorld world, EntityId player) {
    var maxHalfExtent = 0.0;
    if (world.colliderAabb.has(player)) {
      final aabbi = world.colliderAabb.indexOf(player);
      final halfX = world.colliderAabb.halfX[aabbi];
      final halfY = world.colliderAabb.halfY[aabbi];
      maxHalfExtent = halfX > halfY ? halfX : halfY;
    }
    return maxHalfExtent * 0.5;
  }

  ResolvedCharacterStats _resolvedStatsForLoadout(
    EcsWorld world,
    EntityId entity,
  ) {
    return _statsCache.resolveForEntity(world, entity);
  }

  int _actionSpeedBpFor(
    EcsWorld world,
    EntityId entity, {
    required AbilitySlot slot,
  }) {
    if (!_isAttackOrCastSlot(slot)) return bpScale;
    final modifierIndex = world.statModifier.tryIndexOf(entity);
    if (modifierIndex == null) return bpScale;
    return world.statModifier.actionSpeedBp[modifierIndex];
  }

  bool _isAttackOrCastSlot(AbilitySlot slot) {
    switch (slot) {
      case AbilitySlot.primary:
      case AbilitySlot.secondary:
      case AbilitySlot.projectile:
      case AbilitySlot.spell:
        return true;
      case AbilitySlot.mobility:
      case AbilitySlot.jump:
        return false;
    }
  }

  int _scaleTicksForActionSpeed(int ticks, int actionSpeedBp) {
    if (ticks <= 0) return 0;
    final clampedSpeedBp = clampInt(actionSpeedBp, 1000, 20000);
    if (clampedSpeedBp == bpScale) return ticks;
    return (ticks * bpScale + clampedSpeedBp - 1) ~/ clampedSpeedBp;
  }

  void _applyCommitSideEffects(
    EcsWorld world, {
    required EntityId player,
    required AbilityKey abilityId,
    required AbilitySlot slot,
    required int commitTick,
    required int windupTicks,
    required int activeTicks,
    required int recoveryTicks,
    required Facing facingDir,
    required int cooldownGroupId,
    required int cooldownTicks,
    required int healthCost100,
    required int manaCost100,
    required int staminaCost100,
    int? movementIndex,
  }) {
    final abilityDef = abilities.resolve(abilityId);
    final deferCooldown =
        abilityDef?.holdMode == AbilityHoldMode.holdToMaintain;

    // Deduct mana (fixed-point) — deterministic clamp.
    if (manaCost100 > 0) {
      final mi = world.mana.tryIndexOf(player);
      assert(
        mi != null,
        'Missing ManaStore on $player for manaCost=$manaCost100',
      );
      if (mi != null) {
        final cur = world.mana.mana[mi];
        final max = world.mana.manaMax[mi];
        world.mana.mana[mi] = clampInt(cur - manaCost100, 0, max);
      }
    }

    // Deduct stamina (fixed-point) — deterministic clamp.
    if (staminaCost100 > 0) {
      final si = world.stamina.tryIndexOf(player);
      assert(
        si != null,
        'Missing StaminaStore on $player for staminaCost=$staminaCost100',
      );
      if (si != null) {
        final cur = world.stamina.stamina[si];
        final max = world.stamina.staminaMax[si];
        world.stamina.stamina[si] = clampInt(cur - staminaCost100, 0, max);
      }
    }

    // Deduct health (fixed-point) with non-lethal floor.
    if (healthCost100 > 0) {
      final hi = world.health.tryIndexOf(player);
      assert(
        hi != null,
        'Missing HealthStore on $player for healthCost=$healthCost100',
      );
      if (hi != null) {
        final cur = world.health.hp[hi];
        final max = world.health.hpMax[hi];
        final next = clampInt(cur - healthCost100, _minCommitHp100, max);
        world.health.hp[hi] = next;
      }
    }

    // For hold abilities cooldown starts when hold ends; all others start at commit.
    if (!deferCooldown) {
      world.cooldown.startCooldown(player, cooldownGroupId, cooldownTicks);
    }

    // Mark active ability at commit.
    world.activeAbility.set(
      player,
      id: abilityId,
      slot: slot,
      commitTick: commitTick,
      windupTicks: windupTicks,
      activeTicks: activeTicks,
      recoveryTicks: recoveryTicks,
      facingDir: facingDir,
      cooldownGroupId: cooldownGroupId,
      cooldownTicks: cooldownTicks,
      cooldownStarted: !deferCooldown,
    );

    // Keep movement facing consistent for mobility-like commits (matches old MobilitySystem behavior).
    if (movementIndex != null) {
      world.movement.facing[movementIndex] = facingDir;
    }
  }

  int _scaleAbilityTicks(int ticks) {
    if (ticks <= 0) return 0;
    if (tickHz == _abilityTickHz) return ticks;
    final seconds = ticks / _abilityTickHz;
    return ticksFromSecondsCeil(seconds, tickHz);
  }

  static const int _abilityTickHz = 60;
  static const int _minCommitHp100 = 1;

  void _cancelCombatOnMobilityPress(EcsWorld world, EntityId player) {
    _clearCombatIntents(world, player);
    if (world.abilityInputBuffer.has(player)) {
      world.abilityInputBuffer.clear(player);
    }
    _clearActiveCombatAbility(world, player);
  }

  void _clearCombatIntents(EcsWorld world, EntityId player) {
    if (world.meleeIntent.has(player)) {
      final i = world.meleeIntent.indexOf(player);
      world.meleeIntent.tick[i] = -1;
      world.meleeIntent.commitTick[i] = -1;
    }
    if (world.projectileIntent.has(player)) {
      final i = world.projectileIntent.indexOf(player);
      world.projectileIntent.tick[i] = -1;
      world.projectileIntent.commitTick[i] = -1;
    }
    if (world.selfIntent.has(player)) {
      final i = world.selfIntent.indexOf(player);
      world.selfIntent.tick[i] = -1;
      world.selfIntent.commitTick[i] = -1;
    }
  }

  void _clearActiveCombatAbility(EcsWorld world, EntityId player) {
    if (!world.activeAbility.has(player)) return;
    final i = world.activeAbility.indexOf(player);
    final abilityId = world.activeAbility.abilityId[i];
    if (abilityId == null || abilityId.isEmpty) {
      world.activeAbility.clear(player);
      return;
    }
    final def = abilities.resolve(abilityId);
    if (def == null || def.category != AbilityCategory.mobility) {
      world.activeAbility.clear(player);
    }
  }
}

class _ChargeTuning {
  const _ChargeTuning({
    required this.damageScaleBp,
    required this.speedScaleBp,
    required this.critBonusBp,
    this.pierce,
    this.maxPierceHits,
  });

  final int damageScaleBp;
  final int speedScaleBp;
  final int critBonusBp;
  final bool? pierce;
  final int? maxPierceHits;
}


===== FILE: lib/core/ecs/systems/ability_charge_tracking_system.dart =====
import '../../abilities/ability_catalog.dart';
import '../../abilities/ability_def.dart';
import '../../events/game_event.dart';
import '../../util/tick_math.dart';
import '../world.dart';

/// Tracks authoritative slot hold durations for charged ability commits.
///
/// This system derives charge purely from simulation-time hold state:
/// - hold start tick on transition to held
/// - current hold ticks while held
/// - released hold ticks captured on release transition
class AbilityChargeTrackingSystem {
  AbilityChargeTrackingSystem({required this.tickHz, required this.abilities});

  final int tickHz;
  final AbilityResolver abilities;

  void step(
    EcsWorld world, {
    required int currentTick,
    void Function(GameEvent event)? queueEvent,
  }) {
    final charge = world.abilityCharge;
    if (charge.denseEntities.isEmpty) return;

    for (var ci = 0; ci < charge.denseEntities.length; ci += 1) {
      final entity = charge.denseEntities[ci];
      if (!world.playerInput.has(entity)) continue;
      if (!world.equippedLoadout.has(entity)) continue;

      final loadoutIndex = world.equippedLoadout.indexOf(entity);

      var heldMask = charge.heldMask[ci];
      for (final slot in AbilitySlot.values) {
        final bit = 1 << slot.index;
        final slotOffset = charge.slotOffsetForDenseIndex(ci, slot);
        var heldNow = world.playerInput.isAbilitySlotHeld(entity, slot);
        final heldBefore = (heldMask & bit) != 0;
        final ability = _abilityForSlot(world, loadoutIndex, slot);

        if (heldNow) {
          if (!heldBefore) {
            charge.holdStartTickBySlot[slotOffset] = currentTick;
            charge.currentHoldTicksBySlot[slotOffset] = 0;
            charge.releasedHoldTicksBySlot[slotOffset] = 0;
            charge.releasedTickBySlot[slotOffset] = -1;
            charge.setSlotChargeCanceled(entity, slot: slot, canceled: false);
          } else {
            final start = charge.holdStartTickBySlot[slotOffset];
            final ticks = start >= 0 ? currentTick - start : 0;
            charge.currentHoldTicksBySlot[slotOffset] = ticks < 0 ? 0 : ticks;
          }

          final timedOut = _isChargeHoldTimedOut(
            ability,
            holdTicks: charge.currentHoldTicksBySlot[slotOffset],
          );
          if (timedOut) {
            world.playerInput.setAbilitySlotHeld(entity, slot, false);
            heldNow = false;
            charge.setSlotChargeCanceled(entity, slot: slot, canceled: true);
            if (ability != null) {
              queueEvent?.call(
                AbilityChargeEndedEvent(
                  tick: currentTick,
                  entity: entity,
                  slot: slot,
                  abilityId: ability.id,
                  reason: AbilityChargeEndReason.timeout,
                ),
              );
            }
          }
        }

        if (heldNow) {
          heldMask |= bit;
          continue;
        }

        if (heldBefore) {
          final start = charge.holdStartTickBySlot[slotOffset];
          final releasedTicks = start >= 0 ? currentTick - start : 0;
          charge.releasedHoldTicksBySlot[slotOffset] = releasedTicks < 0
              ? 0
              : releasedTicks;
          charge.releasedTickBySlot[slotOffset] = currentTick;
          charge.holdStartTickBySlot[slotOffset] = -1;
          charge.currentHoldTicksBySlot[slotOffset] = 0;
        } else {
          charge.currentHoldTicksBySlot[slotOffset] = 0;
        }
        heldMask &= ~bit;
      }

      charge.heldMask[ci] = heldMask;
    }
  }

  AbilityDef? _abilityForSlot(
    EcsWorld world,
    int loadoutIndex,
    AbilitySlot slot,
  ) {
    final loadout = world.equippedLoadout;
    final key = switch (slot) {
      AbilitySlot.primary => loadout.abilityPrimaryId[loadoutIndex],
      AbilitySlot.secondary => loadout.abilitySecondaryId[loadoutIndex],
      AbilitySlot.projectile => loadout.abilityProjectileId[loadoutIndex],
      AbilitySlot.mobility => loadout.abilityMobilityId[loadoutIndex],
      AbilitySlot.spell => loadout.abilitySpellId[loadoutIndex],
      AbilitySlot.jump => loadout.abilityJumpId[loadoutIndex],
    };
    return abilities.resolve(key);
  }

  bool _isChargeHoldTimedOut(AbilityDef? ability, {required int holdTicks}) {
    if (ability == null) return false;
    if (ability.chargeProfile == null) return false;
    if (ability.chargeMaxHoldTicks60 <= 0) return false;
    final maxHoldTicks = _scaleAbilityTicks(ability.chargeMaxHoldTicks60);
    if (maxHoldTicks <= 0) return false;
    return holdTicks >= maxHoldTicks;
  }

  int _scaleAbilityTicks(int ticks) {
    if (ticks <= 0) return 0;
    if (tickHz == _abilityTickHz) return ticks;
    final seconds = ticks / _abilityTickHz;
    return ticksFromSecondsCeil(seconds, tickHz);
  }

  static const int _abilityTickHz = 60;
}


===== FILE: lib/core/ecs/systems/ability_interrupt.dart =====
import '../entity_id.dart';
import '../world.dart';

/// Shared forced-interruption cleanup helpers.
///
/// Keeps interruption side-effects consistent across systems:
/// - End active ability (optionally starting deferred cooldown first).
/// - Clear buffered input.
/// - Drop pending ability intents.
abstract final class AbilityInterrupt {
  /// Clears active ability state and all transient ability state for [entity].
  ///
  /// When [startDeferredCooldown] is true and the interrupted ability has not
  /// started cooldown yet (hold-to-maintain pattern), cooldown is started
  /// before clearing active state.
  static void clearActiveAndTransient(
    EcsWorld world, {
    required EntityId entity,
    required bool startDeferredCooldown,
  }) {
    final activeIndex = world.activeAbility.tryIndexOf(entity);
    if (activeIndex != null) {
      if (startDeferredCooldown &&
          !world.activeAbility.cooldownStarted[activeIndex]) {
        world.activeAbility.cooldownStarted[activeIndex] = true;
        world.cooldown.startCooldown(
          entity,
          world.activeAbility.cooldownGroupId[activeIndex],
          world.activeAbility.cooldownTicks[activeIndex],
        );
      }
      world.activeAbility.clear(entity);
    }

    if (world.abilityInputBuffer.has(entity)) {
      world.abilityInputBuffer.clear(entity);
    }

    if (world.meleeIntent.has(entity)) {
      final i = world.meleeIntent.indexOf(entity);
      world.meleeIntent.tick[i] = -1;
      world.meleeIntent.commitTick[i] = -1;
    }
    if (world.projectileIntent.has(entity)) {
      final i = world.projectileIntent.indexOf(entity);
      world.projectileIntent.tick[i] = -1;
      world.projectileIntent.commitTick[i] = -1;
    }
    if (world.mobilityIntent.has(entity)) {
      final i = world.mobilityIntent.indexOf(entity);
      world.mobilityIntent.tick[i] = -1;
      world.mobilityIntent.commitTick[i] = -1;
    }
    if (world.selfIntent.has(entity)) {
      final i = world.selfIntent.indexOf(entity);
      world.selfIntent.tick[i] = -1;
      world.selfIntent.commitTick[i] = -1;
    }
  }
}


===== FILE: lib/core/ecs/systems/active_ability_phase_system.dart =====
import '../../abilities/ability_def.dart';
import '../../abilities/forced_interrupt_policy.dart';
import 'ability_interrupt.dart';
import '../world.dart';

/// Updates ActiveAbilityState phase timing and handles forced interruptions.
class ActiveAbilityPhaseSystem {
  const ActiveAbilityPhaseSystem({
    this.forcedInterruptPolicy = ForcedInterruptPolicy.defaultPolicy,
  });

  final ForcedInterruptPolicy forcedInterruptPolicy;

  void step(EcsWorld world, {required int currentTick}) {
    final active = world.activeAbility;
    if (active.denseEntities.isEmpty) return;

    for (var i = 0; i < active.denseEntities.length; i += 1) {
      final entity = active.denseEntities[i];
      final abilityId = active.abilityId[i];
      if (abilityId == null || abilityId.isEmpty) {
        active.phase[i] = AbilityPhase.idle;
        active.elapsedTicks[i] = 0;
        continue;
      }

      if (_isForcedInterrupted(world, entity, abilityId, currentTick)) {
        AbilityInterrupt.clearActiveAndTransient(
          world,
          entity: entity,
          startDeferredCooldown: true,
        );
        continue;
      }

      final commitTick = active.startTick[i];
      var elapsed = currentTick - commitTick;
      if (elapsed < 0) elapsed = 0;
      active.elapsedTicks[i] = elapsed;

      final total = active.totalTicks[i];
      if (total <= 0 || elapsed >= total) {
        _clearAbility(world, entity, i);
        continue;
      }

      final windup = active.windupTicks[i];
      final activeTicks = active.activeTicks[i];

      if (elapsed < windup) {
        active.phase[i] = AbilityPhase.windup;
      } else if (elapsed < windup + activeTicks) {
        active.phase[i] = AbilityPhase.active;
      } else {
        active.phase[i] = AbilityPhase.recovery;
      }
    }
  }

  bool _isForcedInterrupted(
    EcsWorld world,
    int entity,
    AbilityKey abilityId,
    int currentTick,
  ) {
    final forcedCauses = forcedInterruptPolicy.forcedInterruptCausesForAbility(
      abilityId,
    );
    if (forcedCauses.contains(ForcedInterruptCause.stun) &&
        world.controlLock.isStunned(entity, currentTick)) {
      return true;
    }
    final hi = world.health.tryIndexOf(entity);
    final hasDeathInterrupt = forcedCauses.contains(ForcedInterruptCause.death);
    if (hasDeathInterrupt && hi != null && world.health.hp[hi] <= 0) {
      return true;
    }
    if (hasDeathInterrupt && world.deathState.has(entity)) return true;
    return false;
  }

  void _clearAbility(EcsWorld world, int entity, int index) {
    final active = world.activeAbility;
    if (!active.cooldownStarted[index]) {
      active.cooldownStarted[index] = true;
      world.cooldown.startCooldown(
        entity,
        active.cooldownGroupId[index],
        active.cooldownTicks[index],
      );
    }
    world.activeAbility.clear(entity);
    active.phase[index] = AbilityPhase.idle;
    active.elapsedTicks[index] = 0;
  }
}


===== FILE: lib/core/ecs/systems/anim/anim_system.dart =====
import '../../../anim/anim_resolver.dart';
import '../../../abilities/ability_catalog.dart';
import '../../../abilities/ability_def.dart';
import '../../../events/game_event.dart';
import '../../../snapshots/enums.dart';
import '../../../enemies/death_behavior.dart';
import '../../../enemies/enemy_catalog.dart';
import '../../../enemies/enemy_id.dart';
import '../../../players/player_tuning.dart';
import '../../../util/tick_math.dart';
import '../../entity_id.dart';
import '../../world.dart';

/// System that computes per-entity animation state each tick.
///
/// Uses [AnimResolver] with per-entity [AnimProfile]s to pick the animation key
/// and frame offset deterministically.
class AnimSystem {
  AnimSystem({
    required int tickHz,
    required this.enemyCatalog,
    required MovementTuningDerived playerMovement,
    required AnimTuningDerived playerAnimTuning,
    this.abilities = AbilityCatalog.shared,
  }) : _playerAnimTuning = playerAnimTuning,
       _playerProfile = AnimProfile(
         minMoveSpeed: playerMovement.base.minMoveSpeed,
         runSpeedThresholdX: playerMovement.base.runSpeedThresholdX,
         supportsWalk: true,
         supportsJumpFall: true,
         supportsDash: true,
         supportsCast: true,
         supportsRanged: true,
         supportsSpawn: true,
         supportsStun: true,
         directionalStrike: true,
       ) {
    _buildHitAnimTicksById(tickHz);
  }

  /// Catalog for per-enemy configuration (hit windows, anim profiles).
  final EnemyCatalog enemyCatalog;
  final AbilityResolver abilities;

  final AnimTuningDerived _playerAnimTuning;
  final AnimProfile _playerProfile;

  /// Pre-computed hit animation durations in ticks per enemy type.
  late final Map<EnemyId, int> _hitAnimTicksById;

  void _buildHitAnimTicksById(int tickHz) {
    _hitAnimTicksById = <EnemyId, int>{};
    for (final id in EnemyId.values) {
      final seconds = enemyCatalog.get(id).hitAnimSeconds;
      _hitAnimTicksById[id] = ticksFromSecondsCeil(seconds, tickHz);
    }
  }

  /// Updates animation state for player and enemies.
  ///
  /// Call this once per tick before [SnapshotBuilder.build].
  void step(
    EcsWorld world, {
    required EntityId player,
    required int currentTick,
    DeathPhase playerDeathPhase = DeathPhase.none,
    int playerDeathStartTick = -1,
    int playerSpawnStartTick = 0,
  }) {
    _stepPlayer(
      world,
      player: player,
      currentTick: currentTick,
      deathPhase: playerDeathPhase,
      deathStartTick: playerDeathStartTick,
      spawnStartTick: playerSpawnStartTick,
    );
    _stepEnemies(world, currentTick: currentTick);
  }

  void _stepPlayer(
    EcsWorld world, {
    required EntityId player,
    required int currentTick,
    required DeathPhase deathPhase,
    required int deathStartTick,
    required int spawnStartTick,
  }) {
    if (player < 0) return;
    if (!world.animState.has(player)) return;
    if (!world.transform.has(player) || !world.movement.has(player)) return;

    final ai = world.animState.indexOf(player);
    final common = _readCommonSignals(
      world,
      entity: player,
      currentTick: currentTick,
    );

    // Phase 6: Active Action Layer
    final activeAction = _resolveActiveAction(
      world,
      entity: player,
      currentTick: currentTick,
      stunned: common.stunLocked,
      hp: common.hp,
      deathPhase: deathPhase,
    );

    final signals = AnimSignals.player(
      tick: currentTick,
      hp: common.hp,
      deathPhase: deathPhase,
      deathStartTick: deathStartTick,
      grounded: common.grounded,
      velX: common.velX,
      velY: common.velY,
      lastDamageTick: common.lastDamageTick,
      hitAnimTicks: _playerAnimTuning.hitAnimTicks,
      spawnStartTick: spawnStartTick,
      spawnAnimTicks: _playerAnimTuning.spawnAnimTicks,
      stunLocked: common.stunLocked,
      stunStartTick: common.stunStartTick,
      activeActionAnim: activeAction.anim,
      activeActionFrame: activeAction.frame,
    );

    final result = AnimResolver.resolve(_playerProfile, signals);
    world.animState.anim[ai] = result.anim;
    world.animState.animFrame[ai] = result.animFrame;
  }

  void _stepEnemies(EcsWorld world, {required int currentTick}) {
    final enemies = world.enemy;
    final animStore = world.animState;

    for (var ei = 0; ei < enemies.denseEntities.length; ei += 1) {
      final e = enemies.denseEntities[ei];
      if (!animStore.has(e)) continue;
      final ai = animStore.indexOf(e);
      final enemyId = enemies.enemyId[ei];
      final profile = enemyCatalog.get(enemyId).animProfile;
      final common = _readCommonSignals(
        world,
        entity: e,
        currentTick: currentTick,
      );

      final di = world.deathState.tryIndexOf(e);
      final deathPhase = di == null
          ? DeathPhase.none
          : world.deathState.phase[di];
      final deathStartTick = di == null
          ? -1
          : world.deathState.deathStartTick[di];

      final hitAnimTicks = _hitAnimTicksById[enemyId] ?? 0;

      // Phase 6: Active Action Layer (Enemies)
      final activeAction = _resolveActiveAction(
        world,
        entity: e,
        currentTick: currentTick,
        stunned: common.stunLocked,
        hp: common.hp,
        deathPhase: deathPhase,
      );

      final signals = AnimSignals.enemy(
        tick: currentTick,
        hp: common.hp,
        deathPhase: deathPhase,
        deathStartTick: deathStartTick,
        grounded: common.grounded,
        velX: common.velX,
        velY: common.velY,
        lastDamageTick: common.lastDamageTick,
        hitAnimTicks: hitAnimTicks,
        stunLocked: common.stunLocked,
        stunStartTick: common.stunStartTick,
        activeActionAnim: activeAction.anim,
        activeActionFrame: activeAction.frame,
      );

      final result = AnimResolver.resolve(profile, signals);
      animStore.anim[ai] = result.anim;
      animStore.animFrame[ai] = result.animFrame;
    }
  }

  /// Reads shared state used by both player and enemy animation signals.
  ({
    int hp,
    bool grounded,
    double velX,
    double velY,
    int lastDamageTick,
    bool stunLocked,
    int stunStartTick,
  })
  _readCommonSignals(
    EcsWorld world, {
    required EntityId entity,
    required int currentTick,
  }) {
    final hi = world.health.tryIndexOf(entity);
    final hp = hi == null ? 1 : world.health.hp[hi];

    final grounded = world.collision.has(entity)
        ? world.collision.grounded[world.collision.indexOf(entity)]
        : false;

    final ti = world.transform.tryIndexOf(entity);
    final velX = ti == null ? 0.0 : world.transform.velX[ti];
    final velY = ti == null ? 0.0 : world.transform.velY[ti];

    var lastDamageTick = -1;
    if (world.lastDamage.has(entity)) {
      final lastDamageIndex = world.lastDamage.indexOf(entity);
      if (world.lastDamage.kind[lastDamageIndex] !=
          DeathSourceKind.statusEffect) {
        lastDamageTick = world.lastDamage.tick[lastDamageIndex];
      }
    }

    final stunLocked = world.controlLock.isStunned(entity, currentTick);
    final stunStartTick = world.controlLock.stunStartTickFor(
      entity,
      currentTick,
    );

    return (
      hp: hp,
      grounded: grounded,
      velX: velX,
      velY: velY,
      lastDamageTick: lastDamageTick,
      stunLocked: stunLocked,
      stunStartTick: stunStartTick,
    );
  }

  ({AnimKey? anim, int frame}) _resolveActiveAction(
    EcsWorld world, {
    required EntityId entity,
    required int currentTick,
    required bool stunned,
    required int hp,
    required DeathPhase deathPhase,
  }) {
    if (!world.activeAbility.has(entity)) {
      return (anim: null, frame: 0);
    }

    // AnimSystem is render-only: gameplay lifecycle is owned by
    // ActiveAbilityPhaseSystem and related gameplay systems.
    if (stunned || hp <= 0 || deathPhase != DeathPhase.none) {
      return (anim: null, frame: 0);
    }

    final index = world.activeAbility.indexOf(entity);
    final activeId = world.activeAbility.abilityId[index];
    if (activeId == null || activeId.isEmpty) {
      return (anim: null, frame: 0);
    }

    final def = abilities.resolve(activeId);
    if (def == null) {
      return (anim: null, frame: 0);
    }

    final elapsed = world.activeAbility.elapsedTicks[index];
    final totalTicks = world.activeAbility.totalTicks[index];
    final maxTicks = totalTicks > 0 ? totalTicks : 1;

    if (elapsed >= maxTicks) {
      return (anim: null, frame: 0);
    }

    final actionAnim = _resolveActionAnimKey(
      world,
      entity: entity,
      activeIndex: index,
      activeId: activeId,
      ability: def,
    );

    return (anim: actionAnim, frame: elapsed < 0 ? 0 : elapsed);
  }

  AnimKey _resolveActionAnimKey(
    EcsWorld world, {
    required EntityId entity,
    required int activeIndex,
    required AbilityKey activeId,
    required AbilityDef ability,
  }) {
    // Back-strike is a directional variant of melee strike.
    if (ability.animKey != AnimKey.strike) return ability.animKey;
    if (ability.hitDelivery is! MeleeHitDelivery) return ability.animKey;
    if (!world.movement.has(entity)) return ability.animKey;

    final commitFacing = world.activeAbility.facing[activeIndex];
    final currentFacing = world.movement.facing[world.movement.indexOf(entity)];
    if (commitFacing == currentFacing) return ability.animKey;

    // Pure vertical aim keeps dirX ~ 0 and should stay on regular strike.
    final meleeIndex = world.meleeIntent.tryIndexOf(entity);
    if (meleeIndex != null) {
      final intentAbilityId = world.meleeIntent.abilityId[meleeIndex];
      if (intentAbilityId == activeId &&
          world.meleeIntent.dirX[meleeIndex].abs() <= 1e-6) {
        return ability.animKey;
      }
    }

    return AnimKey.backStrike;
  }
}


===== FILE: lib/core/ecs/systems/collectible_system.dart =====
import '../hit/aabb_hit_utils.dart';
import '../entity_id.dart';
import '../world.dart';
import '../../tuning/collectible_tuning.dart';

/// System responsible for updating collectible entities (e.g. coins).
///
/// It handles:
/// 1. Despawning collectibles that have fallen behind the camera.
/// 2. Detecting collisions between the player and collectibles.
/// 3. Triggering collection callbacks and destroying collected entities.
class CollectibleSystem {
  // Recycled list to avoid per-frame allocations for destruction.
  final List<EntityId> _toDespawn = <EntityId>[];

  /// Updates all collectibles.
  ///
  /// [cameraLeft] is the world-space X coordinate of the left edge of the camera,
  /// used for culling entities that are no longer visible.
  void step(
    EcsWorld world, {
    required EntityId player,
    required double cameraLeft,
    required CollectibleTuning tuning,
    required void Function(int value) onCollected,
  }) {
    final collectibles = world.collectible;
    if (collectibles.denseEntities.isEmpty) return;

    // Pre-resolve player components to avoid looking them up for every collectible.
    final playerTi = world.transform.tryIndexOf(player);
    final playerAi = world.colliderAabb.tryIndexOf(player);
    final canCollect = playerTi != null && playerAi != null;

    _toDespawn.clear();

    final despawnLimit = cameraLeft - tuning.despawnBehindCameraMargin;
    for (var ci = 0; ci < collectibles.denseEntities.length; ci += 1) {
      final e = collectibles.denseEntities[ci];
      final ti = world.transform.tryIndexOf(e);
      final ai = world.colliderAabb.tryIndexOf(e);
      // Skip if entity is missing required components (malformed entity).
      if (ti == null || ai == null) continue;

      final centerX = world.transform.posX[ti] + world.colliderAabb.offsetX[ai];
      
      // 1. Culling: Despawn if far behind the camera.
      if (centerX < despawnLimit) {
        _toDespawn.add(e);
        continue;
      }

      // 2. Collection: Check AABB overlap with player.
      if (canCollect) {
        final overlaps = aabbOverlapsWorldColliders(
          world,
          aTransformIndex: ti,
          aAabbIndex: ai,
          bTransformIndex: playerTi,
          bAabbIndex: playerAi,
        );
        if (overlaps) {
          onCollected(collectibles.value[ci]);
          _toDespawn.add(e);
        }
      }
    }

    // Apply deferred destruction.
    for (final e in _toDespawn) {
      world.destroyEntity(e);
    }
  }
}


===== FILE: lib/core/ecs/systems/collision_system.dart =====
import '../../collision/static_world_geometry_index.dart';
import '../../players/player_tuning.dart';
import '../../util/fixed_math.dart';
import '../queries.dart';
import '../stores/body_store.dart';
import '../world.dart';

/// Handles physics integration and collision resolution for dynamic entities.
///
/// This system operates in three main steps:
/// 1.  **Integration**: Updates position based on velocity (`pos += vel * dt`).
/// 2.  **Vertical Resolution**:
///     -   Checks floors (ground segments and one-way platforms).
///     -   Checks ceilings (if not ignored).
///     -   Snaps position to the contact surface and zeroes vertical velocity.
/// 3.  **Horizontal Resolution**:
///     -   Checks walls in the direction of movement.
///     -   Stops horizontal movement upon collision.
///
/// Order within a tick:
/// - JumpSystem/PlayerMovementSystem/MobilitySystem compute control velocities.
/// - GravitySystem applies vertical gravity acceleration.
/// - CollisionSystem integrates `pos += vel * dt`, resolves collisions, and
///   finalizes grounded/contact state for the tick.
class CollisionSystem {
  // Reusable buffers to avoid allocations during collision queries.
  final List<StaticSolid> _queryBuffer = <StaticSolid>[];
  final List<StaticGroundSegment> _groundSegBuffer = <StaticGroundSegment>[];

  /// Runs the physics update for one tick.
  ///
  /// [tuning] provides the delta time [dtSeconds].
  /// [staticWorld] is the spatial index for static geometry (floors, walls).
  void step(
    EcsWorld world,
    MovementTuningDerived tuning, {
    required StaticWorldGeometryIndex staticWorld,
    bool fixedPointPilotEnabled = false,
    int fixedPointSubpixelScale = defaultPhysicsSubpixelScale,
  }) {
    final dt = tuning.dtSeconds;
    // Epsilon for floating point comparisons and overlap tolerance.
    const eps = 1e-3;

    EcsQueries.forColliders(world, (e, ti, bi, coli, aabbi) {
      if (!world.body.enabled[bi]) return;

      // Reset per-tick collision flags (grounded, hitCeiling, etc.).
      world.collision.resetTick(e);

      // Kinematic bodies are excluded from physics integration/resolution.
      // They are moved manually by other systems.
      if (world.body.isKinematic[bi]) {
        return;
      }

      final prevPosX = world.transform.posX[ti];
      final prevPosY = world.transform.posY[ti];

      // Integrate position from the current velocity.
      if (fixedPointPilotEnabled) {
        world.transform.posX[ti] = integratePerTickFixed(
          position: world.transform.posX[ti],
          velocityPerSecond: world.transform.velX[ti],
          tickHz: tuning.tickHz,
          scale: fixedPointSubpixelScale,
        );
        world.transform.posY[ti] = integratePerTickFixed(
          position: world.transform.posY[ti],
          velocityPerSecond: world.transform.velY[ti],
          tickHz: tuning.tickHz,
          scale: fixedPointSubpixelScale,
        );
      } else {
        world.transform.posX[ti] += world.transform.velX[ti] * dt;
        world.transform.posY[ti] += world.transform.velY[ti] * dt;
      }

      final halfX = world.colliderAabb.halfX[aabbi];
      final halfY = world.colliderAabb.halfY[aabbi];
      final offsetX = world.colliderAabb.offsetX[aabbi];
      final offsetY = world.colliderAabb.offsetY[aabbi];

      final prevCenterX = prevPosX + offsetX;
      final prevCenterY = prevPosY + offsetY;
      final prevBottom = prevCenterY + halfY;

      final centerX = world.transform.posX[ti] + offsetX;
      final centerY = world.transform.posY[ti] + offsetY;
      final minX = centerX - halfX;
      final maxX = centerX + halfX;
      final bottom = centerY + halfY;
      final top = centerY - halfY;

      // Vertical top resolution (one-way platforms): only while moving downward.
      double? bestTopY;
      if (world.transform.velY[ti] > 0) {
        _queryBuffer.clear();
        staticWorld.queryTops(minX + eps, maxX - eps, _queryBuffer);
        for (final solid in _queryBuffer) {
          final topY = solid.minY;
          final crossesTop = prevBottom <= topY + eps && bottom >= topY - eps;
          if (!crossesTop) continue;

          if (bestTopY == null || topY < bestTopY) {
            bestTopY = topY;
          }
        }
      }

      // Check ceilings.
      // Only resolve if moving upward and the body collides with ceilings.
      double? bestBottomY;
      if (world.transform.velY[ti] < 0 && !world.body.ignoreCeilings[bi]) {
        final prevTop = prevCenterY - halfY;
        _queryBuffer.clear();
        staticWorld.queryBottoms(minX + eps, maxX - eps, _queryBuffer);
        for (final solid in _queryBuffer) {
          final bottomY = solid.maxY;
          // Check if we crossed the surface from below to above.
          final crossesBottom =
              prevTop >= bottomY - eps && top <= bottomY + eps;
          if (!crossesBottom) continue;

          // Keep the lowest ceiling (maximum Y) encountered.
          if (bestBottomY == null || bottomY > bestBottomY) {
            bestBottomY = bottomY;
          }
        }
      }

      // Check Ground Segments (optimized horizontal strips for ground).
      // Treated same as one-way platforms.
      if (world.transform.velY[ti] > 0) {
        _groundSegBuffer.clear();
        staticWorld.queryGroundSegments(
          minX + eps,
          maxX - eps,
          _groundSegBuffer,
        );
        for (final seg in _groundSegBuffer) {
          final groundTopY = seg.topY;
          final crossesTop =
              prevBottom <= groundTopY + eps && bottom >= groundTopY - eps;
          if (!crossesTop) continue;

          if (bestTopY == null || groundTopY < bestTopY) {
            bestTopY = groundTopY;
          }
        }
      }

      // Apply vertical resolution.
      if (bestTopY != null) {
        // Landed on floor.
        world.transform.posY[ti] = bestTopY - offsetY - halfY;
        if (world.transform.velY[ti] > 0) {
          world.transform.velY[ti] = 0;
        }
        world.collision.grounded[coli] = true;
      } else if (bestBottomY != null) {
        // Hit ceiling.
        world.transform.posY[ti] = bestBottomY - offsetY + halfY;
        if (world.transform.velY[ti] < 0) {
          world.transform.velY[ti] = 0;
        }
        world.collision.hitCeiling[coli] = true;
      }

      // Horizontal Resolution
      // Recompute AABB after vertical resolution for stable side overlap tests.
      // This prevents "snagging" on walls due to slight vertical overlap that should have been resolved.
      final resolvedCenterX = world.transform.posX[ti] + offsetX;
      final resolvedCenterY = world.transform.posY[ti] + offsetY;
      final resolvedMinY = resolvedCenterY - halfY;
      final resolvedMaxY = resolvedCenterY + halfY;

      // Resolve against static walls.
      final sideMask = world.body.sideMask[bi];
      final velX = world.transform.velX[ti];

      if (velX > 0 && (sideMask & BodyDef.sideRight) != 0) {
        // Moving Right.
        final prevRight = prevCenterX + halfX;
        final right = resolvedCenterX + halfX;
        double? bestWallX;

        _queryBuffer.clear();
        staticWorld.queryLeftWalls(prevRight - eps, right + eps, _queryBuffer);

        for (final solid in _queryBuffer) {
          // Filter by vertical overlap (y-axis).
          final overlapY =
              resolvedMaxY > solid.minY + eps &&
              resolvedMinY < solid.maxY - eps;
          if (!overlapY) continue;

          final wallX = solid.minX;
          // Check if we crossed the wall line.
          final crossesWall = prevRight <= wallX + eps && right >= wallX - eps;
          if (!crossesWall) continue;

          if (bestWallX == null || wallX < bestWallX) {
            bestWallX = wallX;
          }
        }

        if (bestWallX != null) {
          // Hit right wall.
          world.transform.posX[ti] = bestWallX - offsetX - halfX;
          world.transform.velX[ti] = 0;
          world.collision.hitRight[coli] = true;
        }
      } else if (velX < 0 && (sideMask & BodyDef.sideLeft) != 0) {
        // Moving Left.
        final prevLeft = prevCenterX - halfX;
        final left = resolvedCenterX - halfX;
        double? bestWallX;

        _queryBuffer.clear();
        staticWorld.queryRightWalls(left - eps, prevLeft + eps, _queryBuffer);

        for (final solid in _queryBuffer) {
          // Filter by vertical overlap (y-axis).
          final overlapY =
              resolvedMaxY > solid.minY + eps &&
              resolvedMinY < solid.maxY - eps;
          if (!overlapY) continue;

          final wallX = solid.maxX;
          // Check if we crossed the wall line from right to left.
          final crossesWall = prevLeft >= wallX - eps && left <= wallX + eps;
          if (!crossesWall) continue;

          // Keep the rightmost wall (maximum X) encountered.
          if (bestWallX == null || wallX > bestWallX) {
            bestWallX = wallX;
          }
        }

        if (bestWallX != null) {
          // Hit left wall.
          world.transform.posX[ti] = bestWallX - offsetX + halfX;
          world.transform.velX[ti] = 0;
          world.collision.hitLeft[coli] = true;
        }
      }

      if (fixedPointPilotEnabled) {
        world.transform.quantizePosVelAtIndex(
          ti,
          subpixelScale: fixedPointSubpixelScale,
        );
      }
    });
  }
}


===== FILE: lib/core/ecs/systems/control_lock_system.dart =====
import '../world.dart';

/// Refreshes control lock masks and removes expired locks each tick.
///
/// This system should run **early** in the tick pipeline, before any
/// gameplay systems that check locks.
///
/// **Responsibilities**:
/// - Recompute [activeMask] for each entity based on current tick
/// - Remove entities from the store when all locks have expired
class ControlLockSystem {
  /// Steps the lock system, refreshing masks and cleaning up expired entries.
  void step(EcsWorld world, {required int currentTick}) {
    final store = world.controlLock;

    // Iterate backwards to safely remove while iterating
    for (int i = store.denseEntities.length - 1; i >= 0; i--) {
      final entity = store.denseEntities[i];

      // Refresh the active mask
      store.refreshMask(i, currentTick);

      // Remove entity from store if no locks are active
      if (store.activeMask[i] == 0) {
        store.removeEntity(entity);
      }
    }
  }
}


===== FILE: lib/core/ecs/systems/cooldown_system.dart =====
import '../world.dart';

/// Decrements active action cooldowns for all entities each tick.
class CooldownSystem {
  /// Runs the cooldown logic.
  ///
  /// Iterates over all entities with a [CooldownStore] and reduces their
  /// remaining tick counts by 1 for all cooldown groups, clamping at 0.
  void step(EcsWorld world) {
    world.cooldown.tickAll();
  }
}


===== FILE: lib/core/ecs/systems/damage_middleware_system.dart =====
import '../stores/damage_queue_store.dart';
import '../world.dart';

/// Applies combat rules to queued damage before it reaches [DamageSystem].
///
/// Middlewares can cancel, redirect, or modify queued damage requests.
/// This system never writes health directly.
class DamageMiddlewareSystem {
  DamageMiddlewareSystem({
    List<DamageMiddleware> middlewares = const <DamageMiddleware>[],
  }) : _middlewares = List<DamageMiddleware>.unmodifiable(middlewares);

  final List<DamageMiddleware> _middlewares;

  void step(EcsWorld world, {required int currentTick}) {
    if (_middlewares.isEmpty) return;

    final queue = world.damageQueue;
    final initialCount = queue.length;
    if (initialCount == 0) return;

    for (var i = 0; i < initialCount; i += 1) {
      if ((queue.flags[i] & DamageQueueFlags.canceled) != 0) continue;
      for (final middleware in _middlewares) {
        middleware.apply(world, queue, i, currentTick);
        if ((queue.flags[i] & DamageQueueFlags.canceled) != 0) {
          break;
        }
      }
    }
  }
}

/// Middleware hook for editing queued damage requests.
abstract class DamageMiddleware {
  void apply(EcsWorld world, DamageQueueStore queue, int index, int currentTick);
}


===== FILE: lib/core/ecs/systems/damage_system.dart =====
import '../../abilities/ability_def.dart';
import '../../abilities/forced_interrupt_policy.dart';
import '../../combat/damage_type.dart';
import '../../combat/status/status.dart';
import '../../events/game_event.dart';
import '../../stats/character_stats_resolver.dart';
import '../../stats/resolved_stats_cache.dart';
import '../../util/deterministic_rng.dart';
import '../../util/fixed_math.dart';
import '../../weapons/weapon_proc.dart';
import 'ability_interrupt.dart';
import '../stores/damage_queue_store.dart';
import '../world.dart';

typedef DamageAppliedCallback =
    void Function({
      required int target,
      required int appliedAmount100,
      required DeathSourceKind sourceKind,
      required DamageType damageType,
    });

/// Central system for validating and applying damage to entities.
///
/// Handles:
/// 1.  Processing queued [DamageRequest]s.
/// 2.  Checking invulnerability frames (i-frames).
/// 3.  Reducing [HealthStore] HP.
/// 4.  Recording [LastDamageStore] details (source, amount) for UI/logic.
/// 5.  Applying post-hit invulnerability.
class DamageSystem {
  DamageSystem({
    required this.invulnerabilityTicksOnHit,
    required int rngSeed,
    CharacterStatsResolver statsResolver = const CharacterStatsResolver(),
    ResolvedStatsCache? statsCache,
    this.forcedInterruptPolicy = ForcedInterruptPolicy.defaultPolicy,
  }) : _rngState = seedFrom(rngSeed, 0x44a3c2f1),
       _statsCache = statsCache ?? ResolvedStatsCache(resolver: statsResolver);

  /// Number of ticks an entity is invulnerable after taking damage.
  final int invulnerabilityTicksOnHit;
  final ResolvedStatsCache _statsCache;
  final ForcedInterruptPolicy forcedInterruptPolicy;

  int _rngState;
  static const int _critDamageBonusBp = 5000; // +50% on crit.

  /// Processes all pending damage requests.
  void step(
    EcsWorld world, {
    required int currentTick,
    void Function(StatusRequest request)? queueStatus,
    DamageAppliedCallback? onDamageApplied,
  }) {
    final queue = world.damageQueue;
    if (queue.length == 0) return;

    final health = world.health;
    final invuln = world.invulnerability;
    final lastDamage = world.lastDamage;
    final resistance = world.damageResistance;
    final vulnerable = world.vulnerable;
    final weaken = world.weaken;

    for (var i = 0; i < queue.length; i += 1) {
      if ((queue.flags[i] & DamageQueueFlags.canceled) != 0) continue;

      final target = queue.target[i];
      final amount100 = queue.amount100[i];
      final critChanceBp = queue.critChanceBp[i];
      final damageType = queue.damageType[i];
      final procs = queue.procs[i];
      final sourceKind = queue.sourceKind[i];
      final sourceEntity = queue.sourceEntity[i];
      final sourceEnemyId = queue.sourceEnemyId[i];
      final sourceProjectileId = queue.sourceProjectileId[i];

      // 1. Resolve Health component.
      // Use tryIndexOf (returns int?) to combine "has check" and "get index"
      // into a single lookup for performance.
      final hi = health.tryIndexOf(target);
      if (hi == null) continue;

      // 2. Resolve Invulnerability component (optional).
      final ii = invuln.tryIndexOf(target);

      // Invulnerability applies only to entities that have `InvulnerabilityStore`
      // attached.
      if (ii != null && invuln.ticksLeft[ii] > 0) {
        continue; // Damage negated.
      }

      // 3. Apply outgoing-source modifiers (e.g. weaken).
      var amountAfterSourceModifiers = amount100;
      if (sourceEntity != null) {
        final wi = weaken.tryIndexOf(sourceEntity);
        if (wi != null && weaken.ticksLeft[wi] > 0) {
          amountAfterSourceModifiers = applyBp(
            amountAfterSourceModifiers,
            -weaken.magnitude[wi],
          );
          if (amountAfterSourceModifiers < 0) {
            amountAfterSourceModifiers = 0;
          }
        }
      }

      // 4. Resolve outgoing critical strike (if any).
      var amountAfterCrit = amountAfterSourceModifiers;
      if (critChanceBp >= bpScale) {
        amountAfterCrit = applyBp(amountAfterCrit, _critDamageBonusBp);
      } else if (critChanceBp > 0) {
        _rngState = nextUint32(_rngState);
        if ((_rngState % bpScale) < critChanceBp) {
          amountAfterCrit = applyBp(amountAfterCrit, _critDamageBonusBp);
        }
      }
      if (amountAfterCrit < 0) amountAfterCrit = 0;

      // 5. Apply global defense (if the target has equipped gear stats).
      var amountAfterDefense = amountAfterCrit;
      final resolvedStats = _statsCache.resolveForEntity(world, target);
      amountAfterDefense = resolvedStats.applyDefense(amountAfterDefense);

      // 6. Apply resistance/vulnerability modifier.
      final ri = resistance.tryIndexOf(target);
      final baseTypedModBp = ri == null
          ? 0
          : resistance.modBpForIndex(ri, damageType);
      final gearTypedModBp = resolvedStats.incomingDamageModBpForDamageType(
        damageType,
      );
      final modBp = baseTypedModBp + gearTypedModBp;
      var appliedAmount = applyBp(amountAfterDefense, modBp);
      if (appliedAmount < 0) appliedAmount = 0;
      final vi = vulnerable.tryIndexOf(target);
      if (vi != null && vulnerable.ticksLeft[vi] > 0) {
        appliedAmount = applyBp(appliedAmount, vulnerable.magnitude[vi]);
        if (appliedAmount < 0) appliedAmount = 0;
      }

      final prevHp = health.hp[hi];
      final nextHp = clampInt(prevHp - appliedAmount, 0, health.hpMax[hi]);
      health.hp[hi] = nextHp;

      // 7. Record Last Damage details (if store exists).
      // Only useful if damage was actually taken.
      if (nextHp < prevHp) {
        _interruptOnDamageTaken(world, target);

        final li = lastDamage.tryIndexOf(target);
        if (li != null) {
          lastDamage.kind[li] = sourceKind;
          lastDamage.amount100[li] = appliedAmount;
          lastDamage.tick[li] = currentTick;

          if (sourceEnemyId != null) {
            lastDamage.enemyId[li] = sourceEnemyId;
            lastDamage.hasEnemyId[li] = true;
          } else {
            lastDamage.hasEnemyId[li] = false;
          }

          if (sourceProjectileId != null) {
            lastDamage.projectileId[li] = sourceProjectileId;
            lastDamage.hasProjectileId[li] = true;
            lastDamage.sourceProjectileId[li] = sourceProjectileId;
            lastDamage.hasSourceProjectileId[li] = true;
          } else {
            lastDamage.hasProjectileId[li] = false;
            lastDamage.hasSourceProjectileId[li] = false;
          }
        }

        onDamageApplied?.call(
          target: target,
          appliedAmount100: appliedAmount,
          sourceKind: sourceKind,
          damageType: damageType,
        );
      }

      // 8. Queue status effects for non-zero damage requests.
      if (queueStatus != null && amount100 > 0 && procs.isNotEmpty) {
        for (final proc in procs) {
          if (proc.hook != ProcHook.onHit) continue;
          if (proc.statusProfileId == StatusProfileId.none) continue;
          final chance = proc.chanceBp;
          if (chance >= bpScale) {
            queueStatus(
              StatusRequest(
                target: target,
                profileId: proc.statusProfileId,
                damageType: damageType,
              ),
            );
            continue;
          }
          if (chance <= 0) continue;
          _rngState = nextUint32(_rngState);
          if ((_rngState % bpScale) < chance) {
            queueStatus(
              StatusRequest(
                target: target,
                profileId: proc.statusProfileId,
                damageType: damageType,
              ),
            );
          }
        }
      }

      // 9. Apply new Invulnerability frames.
      if (invulnerabilityTicksOnHit > 0 && ii != null) {
        invuln.ticksLeft[ii] = invulnerabilityTicksOnHit;
      }
    }
    queue.clear();
  }

  void _interruptOnDamageTaken(EcsWorld world, int entity) {
    if (!world.activeAbility.has(entity)) return;
    final activeIndex = world.activeAbility.indexOf(entity);
    final activeAbilityId = world.activeAbility.abilityId[activeIndex];
    if (!forcedInterruptPolicy.abilityAllowsForcedInterrupt(
      activeAbilityId,
      ForcedInterruptCause.damageTaken,
    )) {
      return;
    }
    AbilityInterrupt.clearActiveAndTransient(
      world,
      entity: entity,
      startDeferredCooldown: true,
    );
  }
}


===== FILE: lib/core/ecs/systems/death_despawn_system.dart =====
import '../../enemies/death_behavior.dart';
import '../entity_id.dart';
import '../world.dart';

/// Despawns entities when their death animation has completed.
class DeathDespawnSystem {
  final List<EntityId> _toDespawn = <EntityId>[];

  void step(EcsWorld world, {required int currentTick}) {
    final deathState = world.deathState;
    if (deathState.denseEntities.isEmpty) return;

    _toDespawn.clear();
    for (var i = 0; i < deathState.denseEntities.length; i += 1) {
      final e = deathState.denseEntities[i];
      if (deathState.phase[i] != DeathPhase.deathAnim) continue;

      final despawnTick = deathState.despawnTick[i];
      if (despawnTick >= 0 && currentTick >= despawnTick) {
        _toDespawn.add(e);
      }
    }

    for (final e in _toDespawn) {
      world.destroyEntity(e);
    }
  }
}



===== FILE: lib/core/ecs/systems/enemy_cast_system.dart =====
import 'dart:math';

import '../../abilities/ability_catalog.dart';
import '../../abilities/ability_def.dart';
import '../../combat/control_lock.dart';
import '../../combat/hit_payload_builder.dart';
import '../../enemies/enemy_catalog.dart';
import '../../projectiles/projectile_catalog.dart';
import '../../projectiles/projectile_item_def.dart';
import '../../projectiles/projectile_id.dart';
import '../../snapshots/enums.dart';
import '../../tuning/flying_enemy_tuning.dart';
import '../../util/double_math.dart';
import '../../util/fixed_math.dart';
import '../entity_id.dart';
import '../stores/projectile_intent_store.dart';
import '../world.dart';

/// Handles enemy projectile strike decisions and writes projectile intents.
class EnemyCastSystem {
  EnemyCastSystem({
    required this.unocoDemonTuning,
    required this.enemyCatalog,
    required this.projectiles,
    this.abilities = AbilityCatalog.shared,
  });

  final UnocoDemonTuningDerived unocoDemonTuning;
  final EnemyCatalog enemyCatalog;
  final ProjectileCatalog projectiles;
  final AbilityResolver abilities;

  /// Evaluates casts for all enemies and writes projectile intents.
  void step(
    EcsWorld world, {
    required EntityId player,
    required int currentTick,
  }) {
    if (!world.transform.has(player)) return;

    final ability = abilities.resolve(_enemyAbilityId);
    if (ability == null) return;
    final cooldownGroupId = ability.effectiveCooldownGroup(
      AbilitySlot.projectile,
    );

    final playerTi = world.transform.indexOf(player);
    final playerX = world.transform.posX[playerTi];
    final playerY = world.transform.posY[playerTi];
    final playerVelX = world.transform.velX[playerTi];
    final playerVelY = world.transform.velY[playerTi];
    var playerCenterX = playerX;
    var playerCenterY = playerY;
    if (world.colliderAabb.has(player)) {
      final ai = world.colliderAabb.indexOf(player);
      playerCenterX += world.colliderAabb.offsetX[ai];
      playerCenterY += world.colliderAabb.offsetY[ai];
    }

    final enemies = world.enemy;
    for (var ei = 0; ei < enemies.denseEntities.length; ei += 1) {
      final enemy = enemies.denseEntities[ei];
      if (world.deathState.has(enemy)) continue;
      final ti = world.transform.tryIndexOf(enemy);
      if (ti == null) continue;

      if (!world.cooldown.has(enemy)) continue;
      if (world.cooldown.isOnCooldown(enemy, cooldownGroupId)) continue;
      if (world.controlLock.isStunned(enemy, currentTick)) continue;
      if (world.controlLock.isLocked(enemy, LockFlag.cast, currentTick)) {
        continue;
      }
      if (world.activeAbility.hasActiveAbility(enemy)) continue;

      if (!world.projectileIntent.has(enemy)) {
        assert(
          false,
          'EnemyCastSystem requires ProjectileIntentStore on enemies; add it at spawn time.',
        );
        continue;
      }

      final enemyId = enemies.enemyId[ei];
      final projectileId = enemyCatalog.get(enemyId).primaryProjectileId;
      if (projectileId == null) continue;

      final projectile = projectiles.get(projectileId);
      final projectileSpeed = projectile.speedUnitsPerSecond;

      var enemyCenterX = world.transform.posX[ti];
      var enemyCenterY = world.transform.posY[ti];
      if (world.colliderAabb.has(enemy)) {
        final ai = world.colliderAabb.indexOf(enemy);
        enemyCenterX += world.colliderAabb.offsetX[ai];
        enemyCenterY += world.colliderAabb.offsetY[ai];
      }

      _writeProjectileIntent(
        world,
        ability: ability,
        projectileId: projectileId,
        projectile: projectile,
        enemyIndex: ei,
        enemyCenterX: enemyCenterX,
        enemyCenterY: enemyCenterY,
        playerCenterX: playerCenterX,
        playerCenterY: playerCenterY,
        playerVelX: playerVelX,
        playerVelY: playerVelY,
        projectileSpeed: projectileSpeed,
        currentTick: currentTick,
        cooldownGroupId: cooldownGroupId,
      );
    }
  }

  void _writeProjectileIntent(
    EcsWorld world, {
    required AbilityDef ability,
    required int enemyIndex,
    required double enemyCenterX,
    required double enemyCenterY,
    required double playerCenterX,
    required double playerCenterY,
    required double playerVelX,
    required double playerVelY,
    required double projectileSpeed,
    required int currentTick,
    required int cooldownGroupId,
    required ProjectileId projectileId,
    required ProjectileItemDef projectile,
  }) {
    final tuning = unocoDemonTuning;

    var targetX = playerCenterX;
    var targetY = playerCenterY;
    if (projectileSpeed > 0.0) {
      final dx = playerCenterX - enemyCenterX;
      final dy = playerCenterY - enemyCenterY;
      final distance = sqrt(dx * dx + dy * dy);
      final leadSeconds = clampDouble(
        distance / projectileSpeed,
        tuning.base.unocoDemonAimLeadMinSeconds,
        tuning.base.unocoDemonAimLeadMaxSeconds,
      );
      targetX = playerCenterX + playerVelX * leadSeconds;
      targetY = playerCenterY + playerVelY * leadSeconds;
    }

    final castDirX = targetX - enemyCenterX;
    if (castDirX.abs() > 1e-6) {
      world.enemy.facing[enemyIndex] = castDirX >= 0
          ? Facing.right
          : Facing.left;
    }

    final enemy = world.enemy.denseEntities[enemyIndex];
    final payload = HitPayloadBuilder.build(
      ability: ability,
      source: enemy,
      weaponStats: projectile.stats,
      weaponDamageType: projectile.damageType,
      weaponProcs: projectile.procs,
    );
    final commitCost = ability.resolveCostForWeaponType(projectile.weaponType);

    final actionSpeedBp = _actionSpeedBpForEntity(world, enemy);
    final windupTicks = _scaleTicksForActionSpeed(
      _scaleAbilityTicks(ability.windupTicks),
      actionSpeedBp,
    );
    final activeTicks = _scaleAbilityTicks(ability.activeTicks);
    final recoveryTicks = _scaleTicksForActionSpeed(
      _scaleAbilityTicks(ability.recoveryTicks),
      actionSpeedBp,
    );
    final commitTick = currentTick;
    final executeTick = commitTick + windupTicks;
    final cooldownTicks = _scaleTicksForActionSpeed(
      tuning.unocoDemonCastCooldownTicks,
      actionSpeedBp,
    );

    world.projectileIntent.set(
      enemy,
      ProjectileIntentDef(
        projectileId: projectileId,
        abilityId: ability.id,
        slot: AbilitySlot.projectile,
        damage100: payload.damage100,
        critChanceBp: payload.critChanceBp,
        staminaCost100: commitCost.staminaCost100,
        manaCost100: commitCost.manaCost100,
        cooldownTicks: cooldownTicks,
        pierce: false,
        maxPierceHits: 1,
        damageType: payload.damageType,
        procs: payload.procs,
        ballistic: projectile.ballistic,
        gravityScale: projectile.gravityScale,
        dirX: targetX - enemyCenterX,
        dirY: targetY - enemyCenterY,
        fallbackDirX: 1.0,
        fallbackDirY: 0.0,
        originOffset: tuning.base.unocoDemonCastOriginOffset,
        commitTick: commitTick,
        windupTicks: windupTicks,
        activeTicks: activeTicks,
        recoveryTicks: recoveryTicks,
        cooldownGroupId: cooldownGroupId,
        tick: executeTick,
      ),
    );

    // Commit side effects (Cooldown + ActiveAbility) must be applied manually
    // since enemies don't use AbilityActivationSystem.
    world.cooldown.startCooldown(enemy, cooldownGroupId, cooldownTicks);
    world.activeAbility.set(
      enemy,
      id: ability.id,
      slot: AbilitySlot.projectile,
      commitTick: commitTick,
      windupTicks: windupTicks,
      activeTicks: activeTicks,
      recoveryTicks: recoveryTicks,
      facingDir: world.enemy.facing[enemyIndex],
    );
  }

  int _scaleAbilityTicks(int ticks) {
    if (ticks <= 0) return 0;
    if (unocoDemonTuning.tickHz <= 0) return ticks;
    final seconds = ticks / _abilityTickHz;
    return (seconds * unocoDemonTuning.tickHz).ceil();
  }

  int _actionSpeedBpForEntity(EcsWorld world, EntityId entity) {
    final modifierIndex = world.statModifier.tryIndexOf(entity);
    if (modifierIndex == null) return bpScale;
    return world.statModifier.actionSpeedBp[modifierIndex];
  }

  int _scaleTicksForActionSpeed(int ticks, int actionSpeedBp) {
    if (ticks <= 0) return 0;
    final clampedSpeedBp = clampInt(actionSpeedBp, 1000, 20000);
    if (clampedSpeedBp == bpScale) return ticks;
    return (ticks * bpScale + clampedSpeedBp - 1) ~/ clampedSpeedBp;
  }

  static const int _abilityTickHz = 60;
  static const AbilityKey _enemyAbilityId = 'common.enemy_cast';
}


===== FILE: lib/core/ecs/systems/enemy_cull_system.dart =====
import '../../tuning/track_tuning.dart';
import '../entity_id.dart';
import '../world.dart';

/// Despawns enemies that are behind the camera or below the ground.
///
/// Rules:
/// - Behind: enemy maxX < cameraLeft - tuning.cullBehindMargin
/// - Below:  enemy bottomY > groundTopY + tuning.enemyCullBelowGroundOffsetY
class EnemyCullSystem {
  final List<EntityId> _toDespawn = <EntityId>[];

  void step(
    EcsWorld world, {
    required double cameraLeft,
    required double groundTopY,
    required TrackTuning tuning,
  }) {
    final enemies = world.enemy;
    if (enemies.denseEntities.isEmpty) return;

    _toDespawn.clear();

    final despawnX = cameraLeft - tuning.cullBehindMargin;
    final despawnY = groundTopY + tuning.enemyCullBelowGroundOffsetY;

    // 1. identify enemies to despawn
    for (var i = 0; i < enemies.denseEntities.length; i += 1) {
      final e = enemies.denseEntities[i];

      final ti = world.transform.tryIndexOf(e);
      if (ti == null) {
        // Orphan enemy, kill it.
        _toDespawn.add(e);
        continue;
      }

      // Compute bounds using ColliderAabb when present.
      var cx = world.transform.posX[ti];
      var cy = world.transform.posY[ti];
      var maxX = cx;
      var bottomY = cy;

      final ci = world.colliderAabb.tryIndexOf(e);
      if (ci != null) {
        cx += world.colliderAabb.offsetX[ci];
        cy += world.colliderAabb.offsetY[ci];
        maxX = cx + world.colliderAabb.halfX[ci];
        bottomY = cy + world.colliderAabb.halfY[ci];
      }

      if (maxX < despawnX || bottomY > despawnY) {
        _toDespawn.add(e);
      }
    }

    if (_toDespawn.isEmpty) return;

    // 2. destroy
    for (final e in _toDespawn) {
      world.destroyEntity(e);
    }
  }
}


===== FILE: lib/core/ecs/systems/enemy_death_state_system.dart =====
import '../../enemies/death_behavior.dart';
import '../../enemies/enemy_catalog.dart';
import '../../enemies/enemy_id.dart';
import '../../util/tick_math.dart';
import '../stores/death_state_store.dart';
import '../world.dart';

/// Tracks enemy death phases and schedules despawn timing.
class EnemyDeathStateSystem {
  EnemyDeathStateSystem({
    required int tickHz,
    EnemyCatalog enemyCatalog = const EnemyCatalog(),
    double maxFallSeconds = 3.0,
  }) : _enemyCatalog = enemyCatalog,
       _maxFallTicks = ticksFromSecondsCeil(maxFallSeconds, tickHz) {
    _buildDeathAnimTicksById(tickHz);
  }

  final EnemyCatalog _enemyCatalog;
  final int _maxFallTicks;

  late final Map<EnemyId, int> _deathAnimTicksById;

  void _buildDeathAnimTicksById(int tickHz) {
    _deathAnimTicksById = <EnemyId, int>{};
    for (final id in EnemyId.values) {
      final seconds = _enemyCatalog.get(id).deathAnimSeconds;
      _deathAnimTicksById[id] = ticksFromSecondsCeil(seconds, tickHz);
    }
  }

  void step(
    EcsWorld world, {
    required int currentTick,
    List<EnemyId>? outEnemiesKilled,
  }) {
    final enemies = world.enemy;
    if (enemies.denseEntities.isEmpty) return;

    final health = world.health;
    final collision = world.collision;
    final deathState = world.deathState;
    final transform = world.transform;

    for (var ei = 0; ei < enemies.denseEntities.length; ei += 1) {
      final e = enemies.denseEntities[ei];
      final di = deathState.tryIndexOf(e);
      if (di != null) {
        final phase = deathState.phase[di];
        if (phase != DeathPhase.fallingUntilGround) continue;

        final grounded = collision.has(e) &&
            collision.grounded[collision.indexOf(e)];
        final maxFallTick = deathState.maxFallDespawnTick[di];
        final shouldStartDeathAnim =
            grounded || (maxFallTick >= 0 && currentTick >= maxFallTick);

        if (!shouldStartDeathAnim) continue;

        final deathTicks = _deathAnimTicksById[enemies.enemyId[ei]] ?? 0;
        deathState.phase[di] = DeathPhase.deathAnim;
        deathState.deathStartTick[di] = currentTick;
        deathState.despawnTick[di] = currentTick + deathTicks;

        final ti = transform.tryIndexOf(e);
        if (ti != null) {
          transform.velX[ti] = 0.0;
          transform.velY[ti] = 0.0;
        }
        continue;
      }

      final hi = health.tryIndexOf(e);
      if (hi == null) continue;
      if (health.hp[hi] > 0) continue;

      final archetype = _enemyCatalog.get(enemies.enemyId[ei]);
      final deathTicks = _deathAnimTicksById[enemies.enemyId[ei]] ?? 0;

      if (outEnemiesKilled != null) {
        outEnemiesKilled.add(enemies.enemyId[ei]);
      }

      final grounded = collision.has(e) &&
          collision.grounded[collision.indexOf(e)];

      if (archetype.deathBehavior == DeathBehavior.groundImpactThenDeath &&
          !grounded) {
        deathState.add(
          e,
          DeathStateDef(
            phase: DeathPhase.fallingUntilGround,
            deathStartTick: -1,
            despawnTick: -1,
            maxFallDespawnTick: currentTick + _maxFallTicks,
          ),
        );
        continue;
      }

      deathState.add(
        e,
        DeathStateDef(
          phase: DeathPhase.deathAnim,
          deathStartTick: currentTick,
          despawnTick: currentTick + deathTicks,
        ),
      );

      final ti = transform.tryIndexOf(e);
      if (ti != null) {
        transform.velX[ti] = 0.0;
        transform.velY[ti] = 0.0;
      }
    }
  }
}


===== FILE: lib/core/ecs/systems/enemy_engagement_system.dart =====
import 'dart:math';

import '../../abilities/ability_def.dart';

import 'package:rpg_runner/core/ecs/entity_id.dart';

import '../../enemies/enemy_id.dart';
import '../../tuning/ground_enemy_tuning.dart';
import '../../util/deterministic_rng.dart';
import '../../util/double_math.dart';
import '../../util/fixed_math.dart';
import '../stores/enemies/melee_engagement_store.dart';
import '../world.dart';

/// Resolves melee engagement state and desired slots for ground enemies.
class EnemyEngagementSystem {
  EnemyEngagementSystem({required this.groundEnemyTuning});

  final GroundEnemyTuningDerived groundEnemyTuning;

  /// Updates engagement intents for ground enemies.
  void step(
    EcsWorld world, {
    required EntityId player,
    required int currentTick,
  }) {
    if (!world.transform.has(player)) return;

    final playerTi = world.transform.indexOf(player);
    final playerX = world.transform.posX[playerTi];

    final enemies = world.enemy;
    for (var ei = 0; ei < enemies.denseEntities.length; ei += 1) {
      if (enemies.enemyId[ei] != EnemyId.grojib) continue;

      final enemy = enemies.denseEntities[ei];
      if (world.deathState.has(enemy)) continue;
      final ti = world.transform.tryIndexOf(enemy);
      if (ti == null) continue;

      if (world.controlLock.isStunned(enemy, currentTick)) continue;

      final meleeIndex = world.meleeEngagement.tryIndexOf(enemy);
      if (meleeIndex == null) {
        assert(
          false,
          'EnemyEngagementSystem requires MeleeEngagementStore on melee enemies; add it at spawn time.',
        );
        continue;
      }

      final chaseIndex = world.groundEnemyChaseOffset.tryIndexOf(enemy);
      if (chaseIndex == null) continue;

      final navIntentIndex = world.navIntent.tryIndexOf(enemy);
      if (navIntentIndex == null) {
        assert(
          false,
          'EnemyEngagementSystem requires NavIntentStore on ground enemies; add it at spawn time.',
        );
        continue;
      }

      final engagementIndex = world.engagementIntent.tryIndexOf(enemy);
      if (engagementIndex == null) {
        assert(
          false,
          'EnemyEngagementSystem requires EngagementIntentStore on melee enemies; add it at spawn time.',
        );
        continue;
      }

      _ensureChaseOffsetInitialized(world, chaseIndex, enemy);

      final chaseOffset = world.groundEnemyChaseOffset;
      final chaseOffsetX = chaseOffset.chaseOffsetX[chaseIndex];
      final chaseSpeedScale = chaseOffset.chaseSpeedScale[chaseIndex];
      final actionSpeedBp = _actionSpeedBpForEntity(world, enemy);
      final scaledMeleeAnimTicks = _scaleTicksForActionSpeed(
        groundEnemyTuning.combat.meleeAnimTicks,
        actionSpeedBp,
      );
      final scaledMeleeWindupTicks = _scaleTicksForActionSpeed(
        groundEnemyTuning.combat.meleeWindupTicks,
        actionSpeedBp,
      );

      final navTargetX = world.navIntent.navTargetX[navIntentIndex];

      var state = world.meleeEngagement.state[meleeIndex];
      var ticksLeft = world.meleeEngagement.ticksLeft[meleeIndex];
      var preferredSide = world.meleeEngagement.preferredSide[meleeIndex];
      var strikeStartTick = world.meleeEngagement.strikeStartTick[meleeIndex];
      var plannedHitTick = world.meleeEngagement.plannedHitTick[meleeIndex];
      if (ticksLeft > 0) {
        ticksLeft -= 1;
      }

      final ex = world.transform.posX[ti];
      final dxToPlayer = playerX - ex;
      final distToPlayerX = dxToPlayer.abs();
      final sideNow = dxToPlayer >= 0 ? -1 : 1;
      final collapseDistX =
          groundEnemyTuning.combat.meleeRangeX +
          groundEnemyTuning.locomotion.stopDistanceX;

      final meleeOffsetMaxX = groundEnemyTuning.navigation.chaseOffsetMeleeX
          .abs();
      final meleeOffsetAbs = min(meleeOffsetMaxX, chaseOffsetX.abs());
      final meleeOffsetX = meleeOffsetAbs == 0.0
          ? 0.0
          : (chaseOffsetX >= 0.0 ? meleeOffsetAbs : -meleeOffsetAbs);

      if (preferredSide == 0 || sideNow != preferredSide) {
        preferredSide = sideNow;
      }

      final engageEnterDist =
          groundEnemyTuning.combat.meleeRangeX +
          groundEnemyTuning.locomotion.stopDistanceX +
          groundEnemyTuning.engagement.meleeEngageBufferX;
      final engageExitDist =
          engageEnterDist + groundEnemyTuning.engagement.meleeEngageHysteresisX;

      switch (state) {
        case MeleeEngagementState.approach:
          if (distToPlayerX <= engageEnterDist) {
            state = MeleeEngagementState.engage;
            ticksLeft = 0;
            strikeStartTick = -1;
            plannedHitTick = -1;
          }
          break;
        case MeleeEngagementState.engage:
          if (distToPlayerX > engageExitDist) {
            state = MeleeEngagementState.approach;
            ticksLeft = 0;
            strikeStartTick = -1;
            plannedHitTick = -1;
          } else {
            // Cooldown-gated transition into strike.
            final ci = world.cooldown.tryIndexOf(enemy);
            if (ci != null) {
              final cooldownReady = !world.cooldown.isOnCooldown(
                enemy,
                CooldownGroup.primary,
              );
              final inMeleeRange =
                  distToPlayerX <= groundEnemyTuning.combat.meleeRangeX;
              if (cooldownReady && inMeleeRange) {
                state = MeleeEngagementState.strike;
                ticksLeft = scaledMeleeAnimTicks;
                strikeStartTick = currentTick;
                plannedHitTick = currentTick + scaledMeleeWindupTicks;
              }
            }
          }
          break;
        case MeleeEngagementState.strike:
          if (ticksLeft <= 0) {
            state = MeleeEngagementState.recover;
            ticksLeft = scaledMeleeAnimTicks;
            strikeStartTick = -1;
            plannedHitTick = -1;
          }
          break;
        case MeleeEngagementState.recover:
          if (ticksLeft <= 0) {
            state = MeleeEngagementState.engage;
            strikeStartTick = -1;
            plannedHitTick = -1;
          }
          break;
      }

      final engageTargetX =
          navTargetX +
          preferredSide * groundEnemyTuning.engagement.meleeStandOffX;

      double desiredTargetX;
      var stateSpeedMul = 1.0;
      var arrivalSlowRadiusX = 0.0;
      var speedScale = 1.0;

      if (state == MeleeEngagementState.approach) {
        desiredTargetX = distToPlayerX <= collapseDistX
            ? navTargetX + meleeOffsetX
            : navTargetX + chaseOffsetX;
        speedScale = chaseSpeedScale;
      } else {
        desiredTargetX = engageTargetX;
        arrivalSlowRadiusX =
            groundEnemyTuning.engagement.meleeArriveSlowRadiusX;
        if (state == MeleeEngagementState.strike) {
          stateSpeedMul = groundEnemyTuning.engagement.meleeStrikeSpeedMul;
        } else if (state == MeleeEngagementState.recover) {
          stateSpeedMul = groundEnemyTuning.engagement.meleeRecoverSpeedMul;
        }
      }

      final engagementIntent = world.engagementIntent;
      engagementIntent.desiredTargetX[engagementIndex] = desiredTargetX;
      engagementIntent.arrivalSlowRadiusX[engagementIndex] = arrivalSlowRadiusX;
      engagementIntent.stateSpeedMul[engagementIndex] = stateSpeedMul;
      engagementIntent.speedScale[engagementIndex] = speedScale;

      world.meleeEngagement.state[meleeIndex] = state;
      world.meleeEngagement.ticksLeft[meleeIndex] = max(0, ticksLeft);
      world.meleeEngagement.preferredSide[meleeIndex] = preferredSide;
      world.meleeEngagement.strikeStartTick[meleeIndex] = strikeStartTick;
      world.meleeEngagement.plannedHitTick[meleeIndex] = plannedHitTick;
    }
  }

  int _actionSpeedBpForEntity(EcsWorld world, EntityId entity) {
    final modifierIndex = world.statModifier.tryIndexOf(entity);
    if (modifierIndex == null) return bpScale;
    return world.statModifier.actionSpeedBp[modifierIndex];
  }

  int _scaleTicksForActionSpeed(int ticks, int actionSpeedBp) {
    if (ticks <= 0) return 0;
    final clampedSpeedBp = clampInt(actionSpeedBp, 1000, 20000);
    if (clampedSpeedBp == bpScale) return ticks;
    return (ticks * bpScale + clampedSpeedBp - 1) ~/ clampedSpeedBp;
  }

  void _ensureChaseOffsetInitialized(
    EcsWorld world,
    int chaseIndex,
    EntityId enemy,
  ) {
    final chaseOffset = world.groundEnemyChaseOffset;
    if (chaseOffset.initialized[chaseIndex]) return;

    final tuning = groundEnemyTuning;
    var rngState = chaseOffset.rngState[chaseIndex];
    if (rngState == 0) {
      rngState = enemy;
    }

    final maxAbs = tuning.navigation.chaseOffsetMaxX.abs();
    var offsetX = 0.0;
    if (maxAbs > 0.0) {
      rngState = nextUint32(rngState);
      offsetX = rangeDouble(rngState, -maxAbs, maxAbs);
      final minAbs = clampDouble(
        tuning.navigation.chaseOffsetMinAbsX,
        0.0,
        maxAbs,
      );
      final absOffset = offsetX.abs();
      if (absOffset < minAbs) {
        offsetX = offsetX >= 0.0 ? minAbs : -minAbs;
        if (absOffset == 0.0) {
          offsetX = minAbs;
        }
      }
    }

    rngState = nextUint32(rngState);
    final speedScale = rangeDouble(
      rngState,
      tuning.navigation.chaseSpeedScaleMin,
      tuning.navigation.chaseSpeedScaleMax,
    );
    chaseOffset.initialized[chaseIndex] = true;
    chaseOffset.chaseOffsetX[chaseIndex] = offsetX;
    chaseOffset.chaseSpeedScale[chaseIndex] = speedScale;
    chaseOffset.rngState[chaseIndex] = rngState;
  }
}


===== FILE: lib/core/ecs/systems/enemy_melee_system.dart =====
import 'package:rpg_runner/core/ecs/entity_id.dart';

import '../../abilities/ability_def.dart';
import '../../combat/damage_type.dart';
import '../../snapshots/enums.dart';
import '../../tuning/ground_enemy_tuning.dart';
import '../../util/fixed_math.dart';
import '../stores/enemies/melee_engagement_store.dart';
import '../stores/melee_intent_store.dart';
import '../world.dart';

/// Handles enemy melee strike decisions and writes melee intents.
class EnemyMeleeSystem {
  EnemyMeleeSystem({required this.groundEnemyTuning});

  final GroundEnemyTuningDerived groundEnemyTuning;

  /// Evaluates melee strikes for all enemies and writes melee intents.
  void step(
    EcsWorld world, {
    required EntityId player,
    required int currentTick,
  }) {
    if (!world.transform.has(player)) return;

    final playerTi = world.transform.indexOf(player);
    final playerX = world.transform.posX[playerTi];

    final meleeEngagement = world.meleeEngagement;
    for (var i = 0; i < meleeEngagement.denseEntities.length; i += 1) {
      final enemy = meleeEngagement.denseEntities[i];
      if (world.deathState.has(enemy)) continue;
      final enemyIndex = world.enemy.tryIndexOf(enemy);
      if (enemyIndex == null) {
        assert(
          false,
          'EnemyMeleeSystem requires EnemyStore on melee enemies; add it at spawn time.',
        );
        continue;
      }

      if (!world.cooldown.has(enemy)) continue;

      final ti = world.transform.tryIndexOf(enemy);
      if (ti == null) continue;

      if (world.controlLock.isStunned(enemy, currentTick)) continue;
      if (world.activeAbility.hasActiveAbility(enemy)) continue;

      // Only write an intent on the first tick we enter the strike state.
      if (meleeEngagement.state[i] != MeleeEngagementState.strike) continue;
      if (meleeEngagement.strikeStartTick[i] != currentTick) continue;
      final plannedHitTick = meleeEngagement.plannedHitTick[i];
      if (plannedHitTick < 0) continue;

      if (!world.meleeIntent.has(enemy)) {
        assert(
          false,
          'EnemyMeleeSystem requires MeleeIntentStore on enemies; add it at spawn time.',
        );
        continue;
      }
      if (!world.colliderAabb.has(enemy)) {
        assert(
          false,
          'Enemy melee requires ColliderAabbStore on the enemy to compute hitbox offset.',
        );
        continue;
      }

      final ex = world.transform.posX[ti];
      final tuning = groundEnemyTuning;

      final facing = playerX >= ex ? Facing.right : Facing.left;
      world.enemy.facing[enemyIndex] = facing;
      final dirX = facing == Facing.right ? 1.0 : -1.0;

      final halfX = tuning.combat.meleeHitboxSizeX * 0.5;
      final halfY = tuning.combat.meleeHitboxSizeY * 0.5;

      final ownerHalfX =
          world.colliderAabb.halfX[world.colliderAabb.indexOf(enemy)];
      final offsetX = dirX * (ownerHalfX * 0.5 + halfX);
      const offsetY = 0.0;

      final actionSpeedBp = _actionSpeedBpForEntity(world, enemy);
      final commitTick = meleeEngagement.strikeStartTick[i];
      final windupTicks = plannedHitTick > commitTick
          ? plannedHitTick - commitTick
          : _scaleTicksForActionSpeed(
              tuning.combat.meleeWindupTicks,
              actionSpeedBp,
            );
      final scaledAnimTicks = _scaleTicksForActionSpeed(
        tuning.combat.meleeAnimTicks,
        actionSpeedBp,
      );
      final recoveryTicks =
          scaledAnimTicks - windupTicks - tuning.combat.meleeActiveTicks;
      final clampedRecovery = recoveryTicks < 0 ? 0 : recoveryTicks;
      final cooldownTicks = _scaleTicksForActionSpeed(
        tuning.combat.meleeCooldownTicks,
        actionSpeedBp,
      );

      world.meleeIntent.set(
        enemy,
        MeleeIntentDef(
          abilityId: 'common.enemy_strike',
          slot: AbilitySlot.primary,
          damage100: toFixed100(tuning.combat.meleeDamage),
          damageType: DamageType.physical,
          halfX: halfX,
          halfY: halfY,
          offsetX: offsetX,
          offsetY: offsetY,
          dirX: dirX,
          dirY: 0.0,
          commitTick: commitTick,
          windupTicks: windupTicks,
          activeTicks: tuning.combat.meleeActiveTicks,
          recoveryTicks: clampedRecovery,
          cooldownTicks: cooldownTicks,
          staminaCost100: 0,
          cooldownGroupId: CooldownGroup.primary,
          tick: plannedHitTick,
        ),
      );

      // Commit side effects (Cooldown + ActiveAbility) must be applied manually
      // since enemies don't use AbilityActivationSystem.
      world.cooldown.startCooldown(enemy, CooldownGroup.primary, cooldownTicks);

      world.activeAbility.set(
        enemy,
        id: 'common.enemy_strike',
        slot: AbilitySlot.primary,
        commitTick: commitTick,
        windupTicks: windupTicks,
        activeTicks: tuning.combat.meleeActiveTicks,
        recoveryTicks: clampedRecovery,
        facingDir: facing,
      );

      world.enemy.lastMeleeTick[enemyIndex] = currentTick;
      world.enemy.lastMeleeFacing[enemyIndex] = facing;
      world.enemy.lastMeleeAnimTicks[enemyIndex] = scaledAnimTicks;
    }
  }

  int _actionSpeedBpForEntity(EcsWorld world, EntityId entity) {
    final modifierIndex = world.statModifier.tryIndexOf(entity);
    if (modifierIndex == null) return bpScale;
    return world.statModifier.actionSpeedBp[modifierIndex];
  }

  int _scaleTicksForActionSpeed(int ticks, int actionSpeedBp) {
    if (ticks <= 0) return 0;
    final clampedSpeedBp = clampInt(actionSpeedBp, 1000, 20000);
    if (clampedSpeedBp == bpScale) return ticks;
    return (ticks * bpScale + clampedSpeedBp - 1) ~/ clampedSpeedBp;
  }
}


===== FILE: lib/core/ecs/systems/enemy_navigation_system.dart =====
import 'package:rpg_runner/core/ecs/entity_id.dart';

import '../../enemies/enemy_id.dart';
import '../../navigation/surface_navigator.dart';
import '../../navigation/types/surface_graph.dart';
import '../../navigation/types/surface_id.dart';
import '../../navigation/utils/surface_spatial_index.dart';
import '../../navigation/utils/trajectory_predictor.dart';
import '../world.dart';

/// Builds navigation intents for ground enemies using the surface graph.
class EnemyNavigationSystem {
  EnemyNavigationSystem({
    required this.surfaceNavigator,
    this.trajectoryPredictor,
    int chaseTargetDelayTicks = 0,
  }) : _chaseTargetDelayTicks = chaseTargetDelayTicks < 0
           ? 0
           : chaseTargetDelayTicks {
    final len = _chaseTargetDelayTicks <= 0 ? 1 : _chaseTargetDelayTicks + 1;
    _targetHistoryX = List<double>.filled(len, 0.0);
    _targetHistoryBottomY = List<double>.filled(len, 0.0);
    _targetHistoryGrounded = List<bool>.filled(len, true);
  }

  final SurfaceNavigator surfaceNavigator;
  final TrajectoryPredictor? trajectoryPredictor;

  final int _chaseTargetDelayTicks;

  SurfaceGraph? _surfaceGraph;
  SurfaceSpatialIndex? _surfaceIndex;
  int _surfaceGraphVersion = 0;

  late final List<double> _targetHistoryX;
  late final List<double> _targetHistoryBottomY;
  late final List<bool> _targetHistoryGrounded;
  int _targetHistoryCursor = 0;
  bool _targetHistoryPrimed = false;

  /// Updates the navigation graph used by ground enemies.
  void setSurfaceGraph({
    required SurfaceGraph graph,
    required SurfaceSpatialIndex spatialIndex,
    required int graphVersion,
  }) {
    _surfaceGraph = graph;
    _surfaceIndex = spatialIndex;
    _surfaceGraphVersion = graphVersion;
  }

  /// Computes navigation intents for all ground enemies.
  void step(
    EcsWorld world, {
    required EntityId player,
    required int currentTick,
  }) {
    if (!world.transform.has(player)) return;

    final playerTi = world.transform.indexOf(player);
    final playerX = world.transform.posX[playerTi];
    final playerY = world.transform.posY[playerTi];
    final playerVelX = world.transform.velX[playerTi];
    final playerVelY = world.transform.velY[playerTi];

    final playerGrounded = world.collision.has(player)
        ? world.collision.grounded[world.collision.indexOf(player)]
        : false;

    var playerHalfX = 0.0;
    var playerBottomY = playerY;
    if (world.colliderAabb.has(player)) {
      final ai = world.colliderAabb.indexOf(player);
      playerHalfX = world.colliderAabb.halfX[ai];
      final offsetY = world.colliderAabb.offsetY[ai];
      playerBottomY = playerY + offsetY + world.colliderAabb.halfY[ai];
    }

    final graph = _surfaceGraph;
    final spatialIndex = _surfaceIndex;

    var rawTargetX = playerX;
    var rawTargetBottomY = playerBottomY;
    var rawTargetGrounded = playerGrounded;

    if (!playerGrounded &&
        trajectoryPredictor != null &&
        graph != null &&
        spatialIndex != null) {
      final prediction = trajectoryPredictor!.predictLanding(
        startX: playerX,
        startBottomY: playerBottomY,
        velX: playerVelX,
        velY: playerVelY,
        graph: graph,
        spatialIndex: spatialIndex,
        entityHalfWidth: playerHalfX,
      );

      if (prediction != null) {
        rawTargetX = prediction.x;
        rawTargetBottomY = prediction.bottomY;
        rawTargetGrounded = true;
      }
    }

    double navTargetX;
    double navTargetBottomY;
    bool navTargetGrounded;

    if (_chaseTargetDelayTicks <= 0) {
      navTargetX = rawTargetX;
      navTargetBottomY = rawTargetBottomY;
      navTargetGrounded = rawTargetGrounded;
    } else {
      final len = _targetHistoryX.length;
      if (!_targetHistoryPrimed) {
        for (var i = 0; i < len; i += 1) {
          _targetHistoryX[i] = rawTargetX;
          _targetHistoryBottomY[i] = rawTargetBottomY;
          _targetHistoryGrounded[i] = rawTargetGrounded;
        }
        _targetHistoryCursor = 0;
        _targetHistoryPrimed = true;
      } else {
        _targetHistoryCursor += 1;
        if (_targetHistoryCursor >= len) _targetHistoryCursor = 0;
        _targetHistoryX[_targetHistoryCursor] = rawTargetX;
        _targetHistoryBottomY[_targetHistoryCursor] = rawTargetBottomY;
        _targetHistoryGrounded[_targetHistoryCursor] = rawTargetGrounded;
      }

      var delayedIndex = _targetHistoryCursor - _chaseTargetDelayTicks;
      if (delayedIndex < 0) delayedIndex += len;
      navTargetX = _targetHistoryX[delayedIndex];
      navTargetBottomY = _targetHistoryBottomY[delayedIndex];
      navTargetGrounded = _targetHistoryGrounded[delayedIndex];
    }

    final enemies = world.enemy;
    for (var ei = 0; ei < enemies.denseEntities.length; ei += 1) {
      if (enemies.enemyId[ei] != EnemyId.grojib) continue;

      final enemy = enemies.denseEntities[ei];
      if (world.deathState.has(enemy)) continue;
      final ti = world.transform.tryIndexOf(enemy);
      if (ti == null) continue;

      if (world.controlLock.isStunned(enemy, currentTick)) continue;

      final navIndex = world.surfaceNav.tryIndexOf(enemy);
      if (navIndex == null) continue;

      final intentIndex = world.navIntent.tryIndexOf(enemy);
      if (intentIndex == null) {
        assert(
          false,
          'EnemyNavigationSystem requires NavIntentStore on ground enemies; add it at spawn time.',
        );
        continue;
      }

      world.navIntent.navTargetX[intentIndex] = navTargetX;

      SurfaceNavIntent intent;
      var hasSafeSurface = false;
      var safeSurfaceMinX = 0.0;
      var safeSurfaceMaxX = 0.0;
      final ex = world.transform.posX[ti];
      final enemyGrounded =
          world.collision.has(enemy) &&
          world.collision.grounded[world.collision.indexOf(enemy)];

      if (graph == null ||
          spatialIndex == null ||
          !world.colliderAabb.has(enemy)) {
        intent = SurfaceNavIntent(
          desiredX: navTargetX,
          jumpNow: false,
          hasPlan: false,
        );
      } else {
        final ai = world.colliderAabb.indexOf(enemy);
        final enemyHalfX = world.colliderAabb.halfX[ai];
        final enemyHalfY = world.colliderAabb.halfY[ai];
        final offsetY = world.colliderAabb.offsetY[ai];
        final enemyBottomY = world.transform.posY[ti] + offsetY + enemyHalfY;

        intent = surfaceNavigator.update(
          navStore: world.surfaceNav,
          navIndex: navIndex,
          graph: graph,
          spatialIndex: spatialIndex,
          graphVersion: _surfaceGraphVersion,
          entityX: ex,
          entityBottomY: enemyBottomY,
          entityHalfWidth: enemyHalfX,
          entityGrounded: enemyGrounded,
          targetX: navTargetX,
          targetBottomY: navTargetBottomY,
          targetHalfWidth: playerHalfX,
          targetGrounded: navTargetGrounded,
        );

        if (!intent.hasPlan) {
          final currentSurfaceId = world.surfaceNav.currentSurfaceId[navIndex];
          final lastGroundSurfaceId =
              world.surfaceNav.lastGroundSurfaceId[navIndex];
          final safeSurfaceId = currentSurfaceId != surfaceIdUnknown
              ? currentSurfaceId
              : lastGroundSurfaceId;
          if (safeSurfaceId != surfaceIdUnknown) {
            final currentIndex = graph.indexOfSurfaceId(safeSurfaceId);
            if (currentIndex != null) {
              final surface = graph.surfaces[currentIndex];
              final minX = surface.xMin + enemyHalfX;
              final maxX = surface.xMax - enemyHalfX;
              if (minX <= maxX) {
                hasSafeSurface = true;
                safeSurfaceMinX = minX;
                safeSurfaceMaxX = maxX;
              }
            }
          }
        }
      }

      final navIntent = world.navIntent;
      navIntent.desiredX[intentIndex] = intent.desiredX;
      navIntent.jumpNow[intentIndex] = intent.jumpNow;
      navIntent.hasPlan[intentIndex] = intent.hasPlan;
      navIntent.commitMoveDirX[intentIndex] = intent.commitMoveDirX;
      navIntent.hasSafeSurface[intentIndex] = hasSafeSurface;
      navIntent.safeSurfaceMinX[intentIndex] = safeSurfaceMinX;
      navIntent.safeSurfaceMaxX[intentIndex] = safeSurfaceMaxX;
    }
  }
}


===== FILE: lib/core/ecs/systems/flying_enemy_locomotion_system.dart =====
import 'package:rpg_runner/core/ecs/entity_id.dart';

import '../../snapshots/enums.dart';
import '../../tuning/flying_enemy_tuning.dart';
import '../../util/deterministic_rng.dart';
import '../../util/double_math.dart';
import '../../util/velocity_math.dart';
import '../world.dart';

/// Applies movement for flying enemies based on steering behaviors.
class FlyingEnemyLocomotionSystem {
  FlyingEnemyLocomotionSystem({required this.unocoDemonTuning});

  final UnocoDemonTuningDerived unocoDemonTuning;

  /// Applies locomotion for all flying enemies.
  void step(
    EcsWorld world, {
    required EntityId player,
    required double groundTopY,
    required double dtSeconds,
    required int currentTick,
  }) {
    if (dtSeconds <= 0.0) return;
    if (!world.transform.has(player)) return;

    final playerTi = world.transform.indexOf(player);
    final playerX = world.transform.posX[playerTi];
    final playerY = world.transform.posY[playerTi];

    final steering = world.flyingEnemySteering;
    for (var i = 0; i < steering.denseEntities.length; i += 1) {
      final enemy = steering.denseEntities[i];
      if (world.deathState.has(enemy)) continue;
      final enemyTi = world.transform.tryIndexOf(enemy);
      if (enemyTi == null) continue;

      if (world.controlLock.isStunned(enemy, currentTick)) {
        // Option B: Freeze in place
        world.transform.velX[enemyTi] = 0.0;
        world.transform.velY[enemyTi] = 0.0;
        continue;
      }

      final enemyIndex = world.enemy.tryIndexOf(enemy);
      if (enemyIndex == null) {
        assert(
          false,
          'FlyingEnemyLocomotionSystem requires EnemyStore on flying enemies; add it at spawn time.',
        );
        continue;
      }

      final ex = world.transform.posX[enemyTi];
      final ey = world.transform.posY[enemyTi];
      _steerFlyingEnemy(
        world,
        enemyIndex: enemyIndex,
        enemy: enemy,
        enemyTi: enemyTi,
        steeringIndex: i,
        playerX: playerX,
        playerY: playerY,
        ex: ex,
        ey: ey,
        groundTopY: groundTopY,
        dtSeconds: dtSeconds,
      );
    }
  }

  void _steerFlyingEnemy(
    EcsWorld world, {
    required int enemyIndex,
    required EntityId enemy,
    required int enemyTi,
    required int steeringIndex,
    required double playerX,
    required double playerY,
    required double ex,
    required double ey,
    required double groundTopY,
    required double dtSeconds,
  }) {
    final tuning = unocoDemonTuning;
    final steering = world.flyingEnemySteering;

    final modIndex = world.statModifier.tryIndexOf(enemy);
    final moveSpeedMul = modIndex == null
        ? 1.0
        : world.statModifier.moveSpeedMul[modIndex];

    var rngState = steering.rngState[steeringIndex];
    double nextRange(double min, double max) {
      rngState = nextUint32(rngState);
      return rangeDouble(rngState, min, max);
    }

    if (!steering.initialized[steeringIndex]) {
      steering.initialized[steeringIndex] = true;
      steering.desiredRangeHoldLeftS[steeringIndex] = nextRange(
        tuning.base.unocoDemonDesiredRangeHoldMinSeconds,
        tuning.base.unocoDemonDesiredRangeHoldMaxSeconds,
      );
      steering.desiredRange[steeringIndex] = nextRange(
        tuning.base.unocoDemonDesiredRangeMin,
        tuning.base.unocoDemonDesiredRangeMax,
      );
      steering.flightTargetHoldLeftS[steeringIndex] = 0.0;
      steering.flightTargetAboveGround[steeringIndex] = nextRange(
        tuning.base.unocoDemonMinHeightAboveGround,
        tuning.base.unocoDemonMaxHeightAboveGround,
      );
    }

    var desiredRangeHoldLeftS = steering.desiredRangeHoldLeftS[steeringIndex];
    var desiredRange = steering.desiredRange[steeringIndex];

    if (desiredRangeHoldLeftS > 0.0) {
      desiredRangeHoldLeftS -= dtSeconds;
    } else {
      desiredRangeHoldLeftS = nextRange(
        tuning.base.unocoDemonDesiredRangeHoldMinSeconds,
        tuning.base.unocoDemonDesiredRangeHoldMaxSeconds,
      );
      desiredRange = nextRange(
        tuning.base.unocoDemonDesiredRangeMin,
        tuning.base.unocoDemonDesiredRangeMax,
      );
    }

    final dx = playerX - ex;
    final distX = dx.abs();
    if (distX > 1e-6) {
      world.enemy.facing[enemyIndex] = dx >= 0 ? Facing.right : Facing.left;
    }

    final slack = tuning.base.unocoDemonHoldSlack;
    double desiredVelX = 0.0;
    if (distX > 1e-6) {
      final dirToPlayerX = dx >= 0 ? 1.0 : -1.0;
      final error = distX - desiredRange;

      if (error.abs() > slack) {
        final slowRadiusX = tuning.base.unocoDemonSlowRadiusX;
        final t = slowRadiusX > 0.0
            ? clampDouble((error.abs() - slack) / slowRadiusX, 0.0, 1.0)
            : 1.0;
        final speed = t * tuning.base.unocoDemonMaxSpeedX;
        desiredVelX = (error > 0.0 ? dirToPlayerX : -dirToPlayerX) * speed;
      }
    }

    var flightTargetHoldLeftS =
        steering.flightTargetHoldLeftS[steeringIndex];
    var flightTargetAboveGround =
        steering.flightTargetAboveGround[steeringIndex];
    if (flightTargetHoldLeftS > 0.0) {
      flightTargetHoldLeftS -= dtSeconds;
    } else {
      flightTargetHoldLeftS = nextRange(
        tuning.base.unocoDemonFlightTargetHoldMinSeconds,
        tuning.base.unocoDemonFlightTargetHoldMaxSeconds,
      );
      flightTargetAboveGround = nextRange(
        tuning.base.unocoDemonMinHeightAboveGround,
        tuning.base.unocoDemonMaxHeightAboveGround,
      );
    }

    final targetY = groundTopY - flightTargetAboveGround;
    final deltaY = targetY - ey;
    double desiredVelY = clampDouble(
      deltaY * tuning.base.unocoDemonVerticalKp,
      -tuning.base.unocoDemonMaxSpeedY,
      tuning.base.unocoDemonMaxSpeedY,
    );
    if (deltaY.abs() <= tuning.base.unocoDemonVerticalDeadzone) {
      desiredVelY = 0.0;
    }

    desiredVelX *= moveSpeedMul;
    desiredVelY *= moveSpeedMul;
    final currentVelX = world.transform.velX[enemyTi];
    world.transform.velX[enemyTi] = applyAccelDecel(
      current: currentVelX,
      desired: desiredVelX,
      dtSeconds: dtSeconds,
      accelPerSecond: tuning.base.unocoDemonAccelX,
      decelPerSecond: tuning.base.unocoDemonDecelX,
    );
    world.transform.velY[enemyTi] = desiredVelY;

    steering.desiredRangeHoldLeftS[steeringIndex] = desiredRangeHoldLeftS;
    steering.desiredRange[steeringIndex] = desiredRange;
    steering.flightTargetHoldLeftS[steeringIndex] = flightTargetHoldLeftS;
    steering.flightTargetAboveGround[steeringIndex] = flightTargetAboveGround;
    steering.rngState[steeringIndex] = rngState;
  }
}


===== FILE: lib/core/ecs/systems/gravity_system.dart =====
import '../../players/player_tuning.dart';
import '../../tuning/physics_tuning.dart';
import '../../util/fixed_math.dart';
import '../world.dart';

/// Applies gravity to all enabled, non-kinematic bodies that opt into gravity.
///
/// Gravity is applied before collision integration/resolution each tick.
class GravitySystem {
  void step(
    EcsWorld world,
    MovementTuningDerived movement, {
    required PhysicsTuning physics,
  }) {
    final dt = movement.dtSeconds;
    if (dt <= 0.0) return;

    final gravityY = physics.gravityY;
    final fixedPointPilot = physics.fixedPointPilot;
    final bodies = world.body;

    for (var bi = 0; bi < bodies.denseEntities.length; bi += 1) {
      final e = bodies.denseEntities[bi];

      final ti = world.transform.tryIndexOf(e);
      if (ti == null) continue;

      if (!bodies.enabled[bi]) continue;
      if (bodies.isKinematic[bi]) continue;
      if (!bodies.useGravity[bi]) continue;

      // -- Gravity Suppression Logic --
      // Check if gravity is temporarily suppressed for this entity (e.g. during a dash).
      final gci = world.gravityControl.tryIndexOf(e);
      if (gci != null) {
        final ticksLeft = world.gravityControl.suppressGravityTicksLeft[gci];
        
        if (ticksLeft > 0) {
          // Decrement timer.
          final nextTicks = ticksLeft - 1;
          world.gravityControl.suppressGravityTicksLeft[gci] = nextTicks;
          
          // If timer just expired, remove the component so gravity resumes NEXT tick.
          if (nextTicks <= 0) {
            world.gravityControl.removeEntity(e);
          }
          // Skip gravity application for this frame.
          continue;
        } else {
          // Component exists but is stale (0 or negative ticks), remove it and apply gravity immediately.
          world.gravityControl.removeEntity(e);
        }
      }

      // -- Apply Gravity --
      final scaledGravityY = gravityY * bodies.gravityScale[bi];
      if (fixedPointPilot.enabled) {
        final deltaVel = accelerationDeltaPerTickFixed(
          accelerationPerSecondSq: scaledGravityY,
          tickHz: movement.tickHz,
          scale: fixedPointPilot.subpixelScale,
        );
        world.transform.velY[ti] = quantizeToScale(
          world.transform.velY[ti] + deltaVel,
          fixedPointPilot.subpixelScale,
        );
      } else {
        world.transform.velY[ti] += scaledGravityY * dt;
      }

      // -- Terminal Velocity --
      final maxVelY = bodies.maxVelY[bi];
      world.transform.velY[ti] = world.transform.velY[ti]
          .clamp(-maxVelY, maxVelY);
      if (fixedPointPilot.enabled) {
        world.transform.quantizeVelAtIndex(
          ti,
          subpixelScale: fixedPointPilot.subpixelScale,
        );
      }
    }
  }
}


===== FILE: lib/core/ecs/systems/ground_enemy_locomotion_system.dart =====
import 'package:rpg_runner/core/ecs/entity_id.dart';

import '../../navigation/types/surface_graph.dart';
import '../../snapshots/enums.dart';
import '../../tuning/ground_enemy_tuning.dart';
import '../../util/double_math.dart';
import '../../util/velocity_math.dart';
import '../stores/enemies/melee_engagement_store.dart';
import '../world.dart';

/// Applies movement for ground enemies based on nav + engagement intents.
class GroundEnemyLocomotionSystem {
  GroundEnemyLocomotionSystem({required this.groundEnemyTuning});

  final GroundEnemyTuningDerived groundEnemyTuning;

  SurfaceGraph? _surfaceGraph;

  void setSurfaceGraph({required SurfaceGraph graph}) {
    _surfaceGraph = graph;
  }

  /// Applies locomotion for all ground enemies.
  void step(
    EcsWorld world, {
    required EntityId player,
    required double dtSeconds,
    required int currentTick,
  }) {
    if (dtSeconds <= 0.0) return;
    if (!world.transform.has(player)) return;

    final playerTi = world.transform.indexOf(player);
    final playerX = world.transform.posX[playerTi];

    final navIntent = world.navIntent;
    for (var i = 0; i < navIntent.denseEntities.length; i += 1) {
      final enemy = navIntent.denseEntities[i];
      if (world.deathState.has(enemy)) continue;
      final enemyTi = world.transform.tryIndexOf(enemy);
      if (enemyTi == null) continue;

      if (world.controlLock.isStunned(enemy, currentTick)) {
        world.transform.velX[enemyTi] = 0.0;
        // Keep velY for falling
        continue;
      }

      final enemyIndex = world.enemy.tryIndexOf(enemy);
      if (enemyIndex == null) {
        assert(
          false,
          'GroundEnemyLocomotionSystem requires EnemyStore on ground enemies; add it at spawn time.',
        );
        continue;
      }

      final navIndex = world.surfaceNav.tryIndexOf(enemy);
      if (navIndex == null) {
        assert(
          false,
          'GroundEnemyLocomotionSystem requires SurfaceNavStateStore on ground enemies; add it at spawn time.',
        );
        continue;
      }

      final engagementIndex = world.engagementIntent.tryIndexOf(enemy);
      if (engagementIndex == null) {
        assert(
          false,
          'GroundEnemyLocomotionSystem requires EngagementIntentStore on ground enemies; add it at spawn time.',
        );
        continue;
      }

      final meleeIndex = world.meleeEngagement.tryIndexOf(enemy);
      if (meleeIndex == null) {
        assert(
          false,
          'GroundEnemyLocomotionSystem requires MeleeEngagementStore on ground enemies; add it at spawn time.',
        );
        continue;
      }
      final meleeState = world.meleeEngagement.state[meleeIndex];
      final lockFacingToPlayer =
          meleeState == MeleeEngagementState.engage ||
          meleeState == MeleeEngagementState.strike ||
          meleeState == MeleeEngagementState.recover;

      final ex = world.transform.posX[enemyTi];
      _applyGroundEnemyLocomotion(
        world,
        enemyIndex: enemyIndex,
        enemyTi: enemyTi,
        navIndex: navIndex,
        navIntentIndex: i,
        engagementIndex: engagementIndex,
        lockFacingToPlayer: lockFacingToPlayer,
        ex: ex,
        playerX: playerX,
        dtSeconds: dtSeconds,
      );
    }
  }

  void _applyGroundEnemyLocomotion(
    EcsWorld world, {
    required int enemyIndex,
    required int enemyTi,
    required int navIndex,
    required int navIntentIndex,
    required int engagementIndex,
    required bool lockFacingToPlayer,
    required double ex,
    required double playerX,
    required double dtSeconds,
  }) {
    final navIntent = world.navIntent;
    final engagementIntent = world.engagementIntent;

    var desiredX = navIntent.desiredX[navIntentIndex];
    if (!navIntent.hasPlan[navIntentIndex]) {
      desiredX = engagementIntent.desiredTargetX[engagementIndex];
      if (navIntent.hasSafeSurface[navIntentIndex]) {
        final minX = navIntent.safeSurfaceMinX[navIntentIndex];
        final maxX = navIntent.safeSurfaceMaxX[navIntentIndex];
        if (minX <= maxX) {
          desiredX = clampDouble(desiredX, minX, maxX);
        }
      }
    }

    final hasPlan = navIntent.hasPlan[navIntentIndex];
    final effectiveSpeedScale = hasPlan
        ? 1.0
        : engagementIntent.speedScale[engagementIndex];
    // Traversal plans (especially jump edges) should not inherit melee
    // approach/strike slowdown multipliers, or enemies can under-speed jumps
    // and appear to "jump in place" on ledges.
    final arrivalSlowRadiusX = hasPlan
        ? 0.0
        : engagementIntent.arrivalSlowRadiusX[engagementIndex];
    final stateSpeedMul = hasPlan
        ? 1.0
        : engagementIntent.stateSpeedMul[engagementIndex];

    _applyGroundEnemyPhysics(
      world,
      enemyIndex: enemyIndex,
      enemyTi: enemyTi,
      navIndex: navIndex,
      ex: ex,
      desiredX: desiredX,
      jumpNow: navIntent.jumpNow[navIntentIndex],
      hasPlan: navIntent.hasPlan[navIntentIndex],
      commitMoveDirX: navIntent.commitMoveDirX[navIntentIndex],
      hasSafeSurface: navIntent.hasSafeSurface[navIntentIndex],
      safeSurfaceMinX: navIntent.safeSurfaceMinX[navIntentIndex],
      safeSurfaceMaxX: navIntent.safeSurfaceMaxX[navIntentIndex],
      effectiveSpeedScale: effectiveSpeedScale,
      arrivalSlowRadiusX: arrivalSlowRadiusX,
      stateSpeedMul: stateSpeedMul,
      lockFacingToPlayer: lockFacingToPlayer,
      dtSeconds: dtSeconds,
      graph: _surfaceGraph,
      playerX: playerX,
    );
  }

  void _applyGroundEnemyPhysics(
    EcsWorld world, {
    required int enemyIndex,
    required int enemyTi,
    required int navIndex,
    required double ex,
    required double desiredX,
    required bool jumpNow,
    required bool hasPlan,
    required int commitMoveDirX,
    required bool hasSafeSurface,
    required double safeSurfaceMinX,
    required double safeSurfaceMaxX,
    required double effectiveSpeedScale,
    required double arrivalSlowRadiusX,
    required double stateSpeedMul,
    required bool lockFacingToPlayer,
    required double dtSeconds,
    required SurfaceGraph? graph,
    required double playerX,
  }) {
    final tuning = groundEnemyTuning;
    final enemy = world.enemy.denseEntities[enemyIndex];
    final enemyCi = world.collision.tryIndexOf(enemy);
    final grounded = enemyCi != null && world.collision.grounded[enemyCi];
    final activeJumpEdge = _activeJumpEdge(
      world,
      navIndex: navIndex,
      graph: graph,
    );
    final modIndex = world.statModifier.tryIndexOf(enemy);
    final moveSpeedMul = modIndex == null
        ? 1.0
        : world.statModifier.moveSpeedMul[modIndex];
    final dx = desiredX - ex;
    double arrivalScale = 1.0;
    if (arrivalSlowRadiusX > 0.0) {
      arrivalScale = clampDouble(dx.abs() / arrivalSlowRadiusX, 0.0, 1.0);
    }
    final baseSpeed =
        tuning.locomotion.speedX *
        effectiveSpeedScale *
        stateSpeedMul *
        moveSpeedMul;
    final currentVelX = world.transform.velX[enemyTi];
    final lockAirborneJumpVelX = hasPlan && !grounded && activeJumpEdge != null;
    final activeJumpEdgeDirX = _resolveEdgeCommitDirX(
      activeJumpEdge,
      referenceX: ex,
    );
    final activeJumpCruiseAbs = _edgeCruiseAbsSpeed(
      edge: activeJumpEdge,
      dtSeconds: dtSeconds,
      maxSpeedAbs: baseSpeed,
    );
    double desiredVelX = 0.0;
    int desiredDirX = 0;
    double? forcedAirborneVelX;
    final facingDirX = world.enemy.facing[enemyIndex] == Facing.right ? 1 : -1;
    final jumpDirX = _resolveJumpForwardDirX(
      commitMoveDirX: commitMoveDirX,
      jumpNow: jumpNow,
      activeJumpEdge: activeJumpEdge,
      facingDirX: facingDirX,
    );

    if (lockAirborneJumpVelX) {
      const edgeOffCourseVelEps = 1.0;
      final offCourse =
          activeJumpEdgeDirX != 0 &&
          (currentVelX * activeJumpEdgeDirX.toDouble()) <= edgeOffCourseVelEps;
      if (offCourse && activeJumpCruiseAbs > 0.0) {
        desiredDirX = activeJumpEdgeDirX;
        desiredVelX = desiredDirX.toDouble() * activeJumpCruiseAbs;
        // Recover from wall-induced zero/flip velocity while executing a jump
        // edge so traversal doesn't devolve into vertical hopping in place.
        forcedAirborneVelX = desiredVelX;
      } else {
        desiredVelX = currentVelX;
        if (currentVelX.abs() > 1e-6) {
          desiredDirX = currentVelX > 0.0 ? 1 : -1;
        }
      }
    } else if (commitMoveDirX != 0) {
      desiredDirX = commitMoveDirX;
      desiredVelX = desiredDirX.toDouble() * baseSpeed;
    } else if (dx.abs() > tuning.locomotion.stopDistanceX) {
      desiredDirX = dx >= 0 ? 1 : -1;
      desiredVelX = desiredDirX.toDouble() * baseSpeed * arrivalScale;
    }

    if (jumpNow && jumpDirX != 0 && !hasPlan) {
      desiredDirX = jumpDirX;
      // Avoid takeoff slowdowns that can produce "jump in place" behavior.
      if (desiredVelX.abs() < baseSpeed) {
        desiredVelX = jumpDirX.toDouble() * baseSpeed;
      }
    }

    if (jumpNow) {
      world.transform.velY[enemyTi] = -tuning.locomotion.jumpSpeed;
    }

    final nextVelX = applyAccelDecel(
      current: currentVelX,
      desired: desiredVelX,
      dtSeconds: dtSeconds,
      accelPerSecond: tuning.locomotion.accelX,
      decelPerSecond: tuning.locomotion.decelX,
    );

    double? jumpSnapVelX;
    if (hasPlan &&
        jumpNow &&
        activeJumpEdge != null &&
        activeJumpEdge.travelTicks > 0) {
      final edge = activeJumpEdge;
      final travelSeconds = edge.travelTicks * dtSeconds;
      if (travelSeconds > 0.0) {
        final dxAbs = (edge.landingX - ex).abs();
        final requiredAbs = dxAbs / travelSeconds;
        final snapAbs = clampDouble(requiredAbs, 0.0, baseSpeed);
        if (snapAbs > 0.0) {
          final sign = edge.commitDirX != 0
              ? edge.commitDirX.toDouble()
              : (desiredVelX > 0.0
                    ? 1.0
                    : (desiredVelX < 0.0
                          ? -1.0
                          : (edge.landingX >= ex ? 1.0 : -1.0)));
          jumpSnapVelX = sign * snapAbs;
        }
      }
    }

    if (jumpNow && jumpDirX != 0 && !hasPlan) {
      final candidateVelX = jumpSnapVelX ?? nextVelX;
      if (candidateVelX.abs() < baseSpeed) {
        jumpSnapVelX = jumpDirX.toDouble() * baseSpeed;
      }
    }

    final resolvedVelX = jumpSnapVelX ?? forcedAirborneVelX ?? nextVelX;

    world.transform.velX[enemyTi] = resolvedVelX;

    if (commitMoveDirX != 0) {
      world.enemy.facing[enemyIndex] = commitMoveDirX > 0
          ? Facing.right
          : Facing.left;
    } else {
      if (grounded) {
        if (desiredDirX != 0) {
          world.enemy.facing[enemyIndex] = desiredDirX > 0
              ? Facing.right
              : Facing.left;
        }
      } else {
        const airFacingVelDeadzone = 1.0;
        final vx = world.transform.velX[enemyTi];
        if (vx.abs() > airFacingVelDeadzone) {
          world.enemy.facing[enemyIndex] = vx > 0 ? Facing.right : Facing.left;
        }
      }
    }

    if (!hasPlan && hasSafeSurface) {
      final stopDist = tuning.locomotion.stopDistanceX;
      final nextVelX = world.transform.velX[enemyTi];
      if (nextVelX > 0.0 && ex >= safeSurfaceMaxX - stopDist) {
        world.transform.velX[enemyTi] = 0.0;
      } else if (nextVelX < 0.0 && ex <= safeSurfaceMinX + stopDist) {
        world.transform.velX[enemyTi] = 0.0;
      }
    }

    if (lockFacingToPlayer) {
      final dxToPlayer = playerX - ex;
      if (dxToPlayer.abs() > 1e-6) {
        world.enemy.facing[enemyIndex] = dxToPlayer >= 0
            ? Facing.right
            : Facing.left;
      }
    }
  }

  int _resolveJumpForwardDirX({
    required int commitMoveDirX,
    required bool jumpNow,
    required SurfaceEdge? activeJumpEdge,
    required int facingDirX,
  }) {
    if (!jumpNow) return 0;
    if (commitMoveDirX != 0) return commitMoveDirX;
    if (activeJumpEdge != null && activeJumpEdge.commitDirX != 0) {
      return activeJumpEdge.commitDirX;
    }
    return facingDirX;
  }

  SurfaceEdge? _activeJumpEdge(
    EcsWorld world, {
    required int navIndex,
    required SurfaceGraph? graph,
  }) {
    if (graph == null) return null;
    final activeEdgeIndex = world.surfaceNav.activeEdgeIndex[navIndex];
    if (activeEdgeIndex < 0 || activeEdgeIndex >= graph.edges.length) {
      return null;
    }
    final edge = graph.edges[activeEdgeIndex];
    return edge.kind == SurfaceEdgeKind.jump ? edge : null;
  }

  int _resolveEdgeCommitDirX(SurfaceEdge? edge, {required double referenceX}) {
    if (edge == null) return 0;
    if (edge.commitDirX != 0) return edge.commitDirX;
    if (edge.landingX > referenceX) return 1;
    if (edge.landingX < referenceX) return -1;
    return 0;
  }

  double _edgeCruiseAbsSpeed({
    required SurfaceEdge? edge,
    required double dtSeconds,
    required double maxSpeedAbs,
  }) {
    if (edge == null || edge.travelTicks <= 0 || dtSeconds <= 0.0) return 0.0;
    final travelSeconds = edge.travelTicks * dtSeconds;
    if (travelSeconds <= 0.0) return 0.0;
    final edgeDxAbs = (edge.landingX - edge.takeoffX).abs();
    final requiredAbs = edgeDxAbs / travelSeconds;
    return clampDouble(requiredAbs, 0.0, maxSpeedAbs);
  }
}


===== FILE: lib/core/ecs/systems/health_despawn_system.dart =====
import '../entity_id.dart';
import '../world.dart';

/// Despawns any non-player entity with `HealthStore` and `hp <= 0`.
///
/// **Responsibilities**:
/// *   Scans all entities with health.
/// *   Identifies those with zero or negative health points.
/// *   Removes the dead entities from the ECS world.
///
/// **IMPORTANT**: The player is intentionally exempt because player "death" is a
/// different gameplay flow (game over / respawn / end-run) than despawning an
/// entity in-place.
class HealthDespawnSystem {
  /// Internal buffer to hold entities scheduled for destruction this frame.
  /// Used to avoid modifying the entity collection while iterating over it.
  final List<EntityId> _toDespawn = <EntityId>[];

  /// Runs the system logic.
  ///
  void step(
    EcsWorld world, {
    required EntityId player,
  }) {
    final health = world.health;
    // Optimization: If no entities have health components, there's nothing to check.
    if (health.denseEntities.isEmpty) return;

    // Reset buffer for this frame.
    _toDespawn.clear();

    // -- Pass 1: Identification --
    // Iterate over all entities participating in the health system.
    for (var i = 0; i < health.denseEntities.length; i += 1) {
      final e = health.denseEntities[i];
      
      // Safety check: The player should never be despawned by this system.
      if (e == player) continue;
      
      // Enemies are handled by the enemy death state pipeline.
      if (world.enemy.has(e)) continue;

      // If health is depleted, mark for destruction.
      if (health.hp[i] <= 0) {
        _toDespawn.add(e);
      }
    }

    // -- Pass 2: Reporting & Destruction --
    // Process the list of doomed entities.
    for (final e in _toDespawn) {
      // Permanently remove the entity and all its components from the world.
      world.destroyEntity(e);
    }
  }
}


===== FILE: lib/core/ecs/systems/hitbox_damage_system.dart =====
import '../../combat/damage.dart';
import '../../events/game_event.dart';
import '../../util/fixed_math.dart';
import '../hit/hit_resolver.dart';
import '../spatial/broadphase_grid.dart';
import '../world.dart';

/// Detects collisions between active hitboxes (melee strikes) and vulnerable targets.
///
/// **Responsibilities**:
/// *   Iterate over all active hitboxes (entities with `HitboxStore`).
/// *   Perform broadphase/narrowphase collision checks against potential targets.
/// *   Filter hits based on faction (Friendly fire prevention).
/// *   Enforce "Hit Once" logic to prevent a single frame of strike from dealing damage every tick.
/// *   Queue [DamageRequest]s for resolved hits.
class HitboxDamageSystem {
  /// Helper for spatial queries and overlap sorting.
  final HitResolver _resolver = HitResolver();

  /// Reused buffer to store indices of overlapping entities each frame.
  final List<int> _overlaps = <int>[];

  /// Executes the system logic.
  ///
  /// [broadphase] provides the spatial index of all damageable entities this frame.
  void step(
    EcsWorld world,
    BroadphaseGrid broadphase, {
    required int currentTick,
  }) {
    final hitboxes = world.hitbox;
    // Early exit if no active strikes exist.
    if (hitboxes.denseEntities.isEmpty) return;

    // Early exit if there are no targets to hit.
    if (broadphase.targets.isEmpty) return;

    // Process each active hitbox.
    for (var hi = 0; hi < hitboxes.denseEntities.length; hi += 1) {
      final hb = hitboxes.denseEntities[hi];

      // Hitboxes must have a position (Transform) to overlap anything.
      if (!world.transform.has(hb)) continue;

      // Hitboxes must have a HitOnce state to track who they've already damaged.
      // This prevents "machine gun" damage from a lingering sword swing.
      if (!world.hitOnce.has(hb)) continue;

      final hbTi = world.transform.indexOf(hb);
      final hbCx = world.transform.posX[hbTi];
      final hbCy = world.transform.posY[hbTi];
      final hbHalfX = hitboxes.halfX[hi];
      final hbHalfY = hitboxes.halfY[hi];
      final hbDirX = hitboxes.dirX[hi];
      final hbDirY = hitboxes.dirY[hi];

      // Calculate capsule segment endpoints.
      // We interpret `halfX` as the half-length along the direction vector,
      // and `halfY` as the capsule radius (thickness).
      // This effectively creates a capsule centered at (hbCx, hbCy) oriented along (hbDirX, hbDirY).
      final ax = hbCx - hbDirX * hbHalfX;
      final ay = hbCy - hbDirY * hbHalfX;
      final bx = hbCx + hbDirX * hbHalfX;
      final by = hbCy + hbDirY * hbHalfX;

      final owner = hitboxes.owner[hi];
      final sourceFaction = hitboxes.faction[hi];

      if (world.deathState.has(owner)) continue;

      // Resolve enemy ID efficiently if the owner is an enemy.
      // This is used for kill credit/stats.
      final enemyIndex = world.enemy.tryIndexOf(owner);
      final enemyId = enemyIndex != null
          ? world.enemy.enemyId[enemyIndex]
          : null;

      // Ensure buffer is clear before collection (safety measure).
      _overlaps.clear();

      // Query the spatial grid for potential overlaps.
      // This handles the geometric check (Capsule vs Target Bounds) and Faction check.
      _resolver.collectOrderedOverlapsCapsule(
        broadphase: broadphase,
        ax: ax,
        ay: ay,
        bx: bx,
        by: by,
        radius: hbHalfY,
        owner: owner,
        sourceFaction: sourceFaction,
        outTargetIndices: _overlaps,
      );
      if (_overlaps.isEmpty) continue;

      // Register hits for verified overlaps.
      for (var i = 0; i < _overlaps.length; i += 1) {
        final ti = _overlaps[i];
        final target = broadphase.targets.entities[ti];

        // "Hit Once" Check: Has this specific hitbox entity already struck this specific target entity?
        if (world.hitOnce.hasHit(hb, target)) continue;

        // Mark as hit so we don't damage them again this swing.
        world.hitOnce.markHit(hb, target);

        // Send the damage request.
        var amount100 = hitboxes.damage100[hi];

        // Consume parry riposte only when a melee hit actually lands.
        final ri = world.riposte.tryIndexOf(owner);
        if (ri != null) {
          if (currentTick <= world.riposte.expiresTick[ri]) {
            amount100 =
                (amount100 * (bpScale + world.riposte.bonusBp[ri])) ~/ bpScale;
          }
          world.riposte.consume(owner);
        }

        world.damageQueue.add(
          DamageRequest(
            target: target,
            amount100: amount100,
            critChanceBp: hitboxes.critChanceBp[hi],
            damageType: hitboxes.damageType[hi],
            procs: hitboxes.procs[hi],
            source: owner,
            sourceKind: DeathSourceKind.meleeHitbox,
            sourceEnemyId: enemyId,
          ),
        );
      }
    }
  }
}


===== FILE: lib/core/ecs/systems/hitbox_follow_owner_system.dart =====
import '../entity_id.dart';
import '../world.dart';

/// Synchronizes the position of hitbox entities with their owners.
///
/// **Responsibilities**:
/// *   Iterate over all active hitboxes (entities with `HitboxStore`).
/// *   Retrieve the owner's current position.
/// *   Apply the hitbox's local offset (defined at spawn).
/// *   Update the hitbox's `Transform` component to match the calculated world position.
///
/// **Usage Note**:
/// This system ensures that a sword swing or projectile hitbox moves *with* the
/// character/projectile effectively. It runs every tick to prevent "hitbox drift".
class HitboxFollowOwnerSystem {
  final List<EntityId> _toDespawn = <EntityId>[];

  /// Executes the synchronization logic.
  void step(EcsWorld world) {
    final hitboxes = world.hitbox;
    // Early exit if no hitboxes exist.
    if (hitboxes.denseEntities.isEmpty) return;

    _toDespawn.clear();

    for (var hi = 0; hi < hitboxes.denseEntities.length; hi += 1) {
      final hitbox = hitboxes.denseEntities[hi];
      
      // Safety: The hitbox entity itself must have a Transform component to be positioned.
      if (!world.transform.has(hitbox)) {
        _toDespawn.add(hitbox);
        continue;
      }

      final owner = hitboxes.owner[hi];
      
      // If the owner has been destroyed or lacks a transform,
      // we cannot position the hitbox relative to it.
      final ownerTi = world.transform.tryIndexOf(owner);
      if (ownerTi == null) {
        _toDespawn.add(hitbox);
        continue;
      }

      // Calculate world position: Owner Position + Local Offset.
      final x = world.transform.posX[ownerTi] + hitboxes.offsetX[hi];
      final y = world.transform.posY[ownerTi] + hitboxes.offsetY[hi];

      // specific Snap behavior: We overwrite the position completely.
      // Physics forces are not applied here; it's a hard attachment.
      world.transform.setPosXY(hitbox, x, y);
    }

    for (final e in _toDespawn) {
      world.destroyEntity(e);
    }
  }
}


===== FILE: lib/core/ecs/systems/hold_ability_system.dart =====
import '../../abilities/ability_catalog.dart';
import '../../abilities/ability_def.dart';
import '../../events/game_event.dart';
import '../entity_id.dart';
import '../world.dart';

/// Maintains committed hold abilities based on slot hold state and stamina.
///
/// This system:
/// - Ends hold abilities when the owning slot is released.
/// - Drains stamina deterministically while hold windows are maintained.
/// - Emits [AbilityHoldEndedEvent] when hold ends automatically (timeout/deplete).
class HoldAbilitySystem {
  HoldAbilitySystem({required this.tickHz, required this.abilities})
    : assert(tickHz > 0, 'tickHz must be > 0');

  final int tickHz;
  final AbilityResolver abilities;

  void step(
    EcsWorld world, {
    required int currentTick,
    void Function(GameEvent event)? queueEvent,
  }) {
    final active = world.activeAbility;
    if (active.denseEntities.isEmpty) return;

    for (var i = 0; i < active.denseEntities.length; i += 1) {
      final entity = active.denseEntities[i];
      final abilityId = active.abilityId[i];
      if (abilityId == null || abilityId.isEmpty) continue;

      final ability = abilities.resolve(abilityId);
      if (ability == null ||
          ability.holdMode != AbilityHoldMode.holdToMaintain) {
        continue;
      }

      final slot = active.slot[i];
      final slotHeld = world.playerInput.isAbilitySlotHeld(entity, slot);
      final phase = active.phase[i];
      final elapsed = active.elapsedTicks[i];
      final windupTicks = active.windupTicks[i];
      final activeTicks = active.activeTicks[i];
      final activeElapsed = elapsed - windupTicks;
      final isTimeoutTick =
          slotHeld &&
          phase == AbilityPhase.recovery &&
          activeTicks > 0 &&
          activeElapsed == activeTicks;

      if ((phase == AbilityPhase.windup || phase == AbilityPhase.active) &&
          !slotHeld) {
        _forceRecovery(world, entity: entity, index: i, elapsedTicks: elapsed);
        continue;
      }

      final drainSampleTick = switch (phase) {
        AbilityPhase.active when slotHeld => activeElapsed,
        AbilityPhase.recovery when isTimeoutTick => activeElapsed,
        _ => null,
      };

      final depleted =
          slotHeld &&
          drainSampleTick != null &&
          ability.holdStaminaDrainPerSecond100 > 0 &&
          _drainStamina(
            world,
            entity: entity,
            activeElapsedTick: drainSampleTick,
            drainPerSecond100: ability.holdStaminaDrainPerSecond100,
          );

      if (depleted) {
        _forceRecovery(world, entity: entity, index: i, elapsedTicks: elapsed);
        queueEvent?.call(
          AbilityHoldEndedEvent(
            tick: currentTick,
            entity: entity,
            slot: slot,
            abilityId: ability.id,
            reason: AbilityHoldEndReason.staminaDepleted,
          ),
        );
        continue;
      }

      if (isTimeoutTick) {
        _startCooldownIfDeferred(world, entity: entity, index: i);
        queueEvent?.call(
          AbilityHoldEndedEvent(
            tick: currentTick,
            entity: entity,
            slot: slot,
            abilityId: ability.id,
            reason: AbilityHoldEndReason.timeout,
          ),
        );
      }
    }
  }

  bool _drainStamina(
    EcsWorld world, {
    required EntityId entity,
    required int activeElapsedTick,
    required int drainPerSecond100,
  }) {
    if (activeElapsedTick < 0) return false;

    final totalDrainNow = (activeElapsedTick * drainPerSecond100) ~/ tickHz;
    final prevElapsed = activeElapsedTick - 1;
    final totalDrainPrev = prevElapsed >= 0
        ? (prevElapsed * drainPerSecond100) ~/ tickHz
        : 0;
    final delta = totalDrainNow - totalDrainPrev;
    if (delta <= 0) return false;

    final staminaIndex = world.stamina.tryIndexOf(entity);
    assert(
      staminaIndex != null,
      'Hold ability drain requires StaminaStore on entity $entity.',
    );
    if (staminaIndex == null) return true;

    final current = world.stamina.stamina[staminaIndex];
    final next = current - delta;
    if (next <= 0) {
      world.stamina.stamina[staminaIndex] = 0;
      return true;
    }

    world.stamina.stamina[staminaIndex] = next;
    return false;
  }

  void _forceRecovery(
    EcsWorld world, {
    required EntityId entity,
    required int index,
    required int elapsedTicks,
  }) {
    _startCooldownIfDeferred(world, entity: entity, index: index);

    final active = world.activeAbility;
    final recoveryTicks = active.recoveryTicks[index];
    if (recoveryTicks <= 0) {
      active.clear(entity);
      return;
    }

    final normalizedElapsed = elapsedTicks < 0 ? 0 : elapsedTicks;
    active.windupTicks[index] = normalizedElapsed;
    active.activeTicks[index] = 0;
    active.totalTicks[index] = normalizedElapsed + recoveryTicks;
    active.phase[index] = AbilityPhase.recovery;
  }

  void _startCooldownIfDeferred(
    EcsWorld world, {
    required EntityId entity,
    required int index,
  }) {
    final active = world.activeAbility;
    if (active.cooldownStarted[index]) return;
    active.cooldownStarted[index] = true;
    world.cooldown.startCooldown(
      entity,
      active.cooldownGroupId[index],
      active.cooldownTicks[index],
    );
  }
}


===== FILE: lib/core/ecs/systems/invulnerability_system.dart =====
import '../world.dart';

/// Manages temporary invulnerability frames (i-frames).
///
/// **Responsibilities**:
/// *   Decrements invulnerability timers each tick.
/// *   Removes the `InvulnerabilityStore` component when the timer expires.
class InvulnerabilitySystem {
  void step(EcsWorld world) {
    final store = world.invulnerability;
    // Iterate backwards to allow safe removal of entities (Swap-Remove safe).
    for (var i = store.denseEntities.length - 1; i >= 0; i--) {
      // Decrement.
      if (store.ticksLeft[i] > 0) {
        store.ticksLeft[i] -= 1;
      }

      // Cleanup logic: If expired, remove the component so other systems
      // (collision/damage) know the entity is vulnerable again.
      if (store.ticksLeft[i] <= 0) {
        final e = store.denseEntities[i];
        store.removeEntity(e);
      }
    }
  }
}



===== FILE: lib/core/ecs/systems/jump_system.dart =====
import '../../abilities/ability_catalog.dart';
import '../../abilities/ability_def.dart';
import '../../combat/control_lock.dart';
import '../../util/fixed_math.dart';
import '../../players/player_tuning.dart';
import '../entity_id.dart';
import '../stores/mobility_intent_store.dart';
import '../stores/player/jump_state_store.dart';
import '../world.dart';

/// Executes buffered jump intents with coyote-time and air-jump rules.
///
/// Ground jumps and air jumps may have different resource costs:
/// - Ground jump uses [AbilityDef.defaultCost]
/// - Air jump uses [AbilityDef.airJumpCost]
class JumpSystem {
  JumpSystem({required this.abilities});

  final AbilityResolver abilities;

  void step(
    EcsWorld world,
    MovementTuningDerived tuning, {
    required int currentTick,
  }) {
    final jumpState = world.jumpState;
    final entities = jumpState.denseEntities;
    for (var ji = 0; ji < entities.length; ji += 1) {
      final entity = entities[ji];

      final mi = world.movement.tryIndexOf(entity);
      final ti = world.transform.tryIndexOf(entity);
      final bi = world.body.tryIndexOf(entity);
      final ci = world.collision.tryIndexOf(entity);
      if (mi == null || ti == null || bi == null || ci == null) continue;
      if (!world.body.enabled[bi] || world.body.isKinematic[bi]) continue;

      _tickForgivenessState(
        world,
        jumpState: jumpState,
        jumpStateIndex: ji,
        collisionIndex: ci,
        tuning: tuning,
      );

      final intentIndex = _jumpIntentIndex(world, entity);
      final hasJumpIntent = intentIndex != null;
      if (hasJumpIntent &&
          world.mobilityIntent.commitTick[intentIndex] == currentTick) {
        jumpState.jumpBufferTicksLeft[ji] = tuning.jumpBufferTicks;
      }

      if (jumpState.jumpBufferTicksLeft[ji] <= 0) {
        if (hasJumpIntent) {
          _invalidateIntent(world.mobilityIntent, intentIndex);
        }
        continue;
      }

      if (world.controlLock.isLocked(entity, LockFlag.jump, currentTick)) {
        continue;
      }

      if (!hasJumpIntent) {
        continue;
      }

      final intent = world.mobilityIntent;
      final ability = abilities.resolve(intent.abilityId[intentIndex]);
      if (ability == null) {
        _invalidateIntent(intent, intentIndex);
        jumpState.jumpBufferTicksLeft[ji] = 0;
        continue;
      }

      final canGroundJump =
          world.collision.grounded[ci] || jumpState.coyoteTicksLeft[ji] > 0;
      final canAirJump =
          !canGroundJump && jumpState.airJumpsUsed[ji] < ability.maxAirJumps;
      if (!canGroundJump && !canAirJump) {
        continue;
      }

      final jumpCost = canGroundJump
          ? ability.defaultCost
          : ability.airJumpCost;
      if (!_canAffordJumpCost(world, entity: entity, cost: jumpCost)) {
        continue;
      }

      _payJumpCost(world, entity: entity, cost: jumpCost);
      final jumpSpeedY = canGroundJump
          ? (ability.groundJumpSpeedY ?? tuning.base.jumpSpeed)
          : (ability.airJumpSpeedY ??
                ability.groundJumpSpeedY ??
                tuning.base.jumpSpeed);
      world.transform.velY[ti] = -jumpSpeedY;
      jumpState.jumpBufferTicksLeft[ji] = 0;
      jumpState.coyoteTicksLeft[ji] = 0;
      if (!canGroundJump) {
        jumpState.airJumpsUsed[ji] += 1;
      }

      _invalidateIntent(intent, intentIndex);
      _stampActiveJumpAbility(
        world,
        entity: entity,
        movementIndex: mi,
        intentIndex: intentIndex,
        currentTick: currentTick,
      );
      _startJumpCooldown(world, entity: entity, intentIndex: intentIndex);
    }
  }

  void _tickForgivenessState(
    EcsWorld world, {
    required JumpStateStore jumpState,
    required int jumpStateIndex,
    required int collisionIndex,
    required MovementTuningDerived tuning,
  }) {
    if (jumpState.jumpBufferTicksLeft[jumpStateIndex] > 0) {
      jumpState.jumpBufferTicksLeft[jumpStateIndex] -= 1;
    }

    final grounded = world.collision.grounded[collisionIndex];
    if (grounded) {
      jumpState.coyoteTicksLeft[jumpStateIndex] = tuning.coyoteTicks;
      jumpState.airJumpsUsed[jumpStateIndex] = 0;
    } else if (jumpState.coyoteTicksLeft[jumpStateIndex] > 0) {
      jumpState.coyoteTicksLeft[jumpStateIndex] -= 1;
    }
  }

  int? _jumpIntentIndex(EcsWorld world, EntityId entity) {
    final intentIndex = world.mobilityIntent.tryIndexOf(entity);
    if (intentIndex == null) return null;
    return world.mobilityIntent.slot[intentIndex] == AbilitySlot.jump
        ? intentIndex
        : null;
  }

  bool _canAffordJumpCost(
    EcsWorld world, {
    required EntityId entity,
    required AbilityResourceCost cost,
  }) {
    if (cost.staminaCost100 > 0) {
      final staminaIndex = world.stamina.tryIndexOf(entity);
      if (staminaIndex == null ||
          world.stamina.stamina[staminaIndex] < cost.staminaCost100) {
        return false;
      }
    }
    if (cost.manaCost100 > 0) {
      final manaIndex = world.mana.tryIndexOf(entity);
      if (manaIndex == null || world.mana.mana[manaIndex] < cost.manaCost100) {
        return false;
      }
    }
    if (cost.healthCost100 > 0) {
      final healthIndex = world.health.tryIndexOf(entity);
      if (healthIndex == null) return false;
      if (world.health.hp[healthIndex] - cost.healthCost100 < _minCommitHp100) {
        return false;
      }
    }
    return true;
  }

  void _payJumpCost(
    EcsWorld world, {
    required EntityId entity,
    required AbilityResourceCost cost,
  }) {
    if (cost.staminaCost100 > 0) {
      final staminaIndex = world.stamina.tryIndexOf(entity);
      if (staminaIndex != null) {
        final current = world.stamina.stamina[staminaIndex];
        final max = world.stamina.staminaMax[staminaIndex];
        world.stamina.stamina[staminaIndex] = clampInt(
          current - cost.staminaCost100,
          0,
          max,
        );
      }
    }
    if (cost.manaCost100 > 0) {
      final manaIndex = world.mana.tryIndexOf(entity);
      if (manaIndex != null) {
        final current = world.mana.mana[manaIndex];
        final max = world.mana.manaMax[manaIndex];
        world.mana.mana[manaIndex] = clampInt(
          current - cost.manaCost100,
          0,
          max,
        );
      }
    }
    if (cost.healthCost100 > 0) {
      final healthIndex = world.health.tryIndexOf(entity);
      if (healthIndex != null) {
        final current = world.health.hp[healthIndex];
        final max = world.health.hpMax[healthIndex];
        world.health.hp[healthIndex] = clampInt(
          current - cost.healthCost100,
          _minCommitHp100,
          max,
        );
      }
    }
  }

  void _stampActiveJumpAbility(
    EcsWorld world, {
    required EntityId entity,
    required int movementIndex,
    required int intentIndex,
    required int currentTick,
  }) {
    if (!world.activeAbility.has(entity)) return;
    final intent = world.mobilityIntent;
    world.activeAbility.set(
      entity,
      id: intent.abilityId[intentIndex],
      slot: intent.slot[intentIndex],
      commitTick: currentTick,
      windupTicks: intent.windupTicks[intentIndex],
      activeTicks: intent.activeTicks[intentIndex],
      recoveryTicks: intent.recoveryTicks[intentIndex],
      facingDir: world.movement.facing[movementIndex],
      cooldownGroupId: intent.cooldownGroupId[intentIndex],
      cooldownTicks: intent.cooldownTicks[intentIndex],
      cooldownStarted: intent.cooldownTicks[intentIndex] > 0,
    );
  }

  void _startJumpCooldown(
    EcsWorld world, {
    required EntityId entity,
    required int intentIndex,
  }) {
    final cooldownTicks = world.mobilityIntent.cooldownTicks[intentIndex];
    if (cooldownTicks <= 0) return;
    world.cooldown.startCooldown(
      entity,
      world.mobilityIntent.cooldownGroupId[intentIndex],
      cooldownTicks,
    );
  }

  void _invalidateIntent(MobilityIntentStore intent, int index) {
    intent.tick[index] = -1;
    intent.commitTick[index] = -1;
  }

  static const int _minCommitHp100 = 1;
}


===== FILE: lib/core/ecs/systems/lifetime_system.dart =====
import '../entity_id.dart';
import '../world.dart';

/// Determines when temporary entities should expire.
///
/// **Responsibilities**:
/// *   Decrements the life timer (`LifetimeStore.ticksLeft`) for all participating entities every tick.
/// *   Despawns entities when their timer reaches zero.
///
/// **Usage**:
/// Generic system used for particles, projectiles, transient UI markers, or timed buffs
/// that need to clean themselves up automatically.
class LifetimeSystem {
  /// Buffer for entities to destroy.
  /// Used to avoid `ConcurrentModificationException` when modifying the ECS state during iteration.
  final List<EntityId> _toDespawn = <EntityId>[];

  /// Executes the system logic.
  void step(EcsWorld world) {
    final lifetimes = world.lifetime;
    // Optimization: Skip processing if no timed entities exist.
    if (lifetimes.denseEntities.isEmpty) return;

    // Reset the buffer for this frame.
    _toDespawn.clear();

    // Iterate over all entities with a lifetime component.
    for (var li = 0; li < lifetimes.denseEntities.length; li += 1) {
      final e = lifetimes.denseEntities[li];
      
      // Decrement the timer (Tick down).
      lifetimes.ticksLeft[li]--;
      
      // If time has run out (or was force-set to <= 0), mark for destruction.
      if (lifetimes.ticksLeft[li] <= 0) {
        _toDespawn.add(e);
      }
    }

    // Process the destruction queue.
    for (final e in _toDespawn) {
      world.destroyEntity(e);
    }
  }
}



===== FILE: lib/core/ecs/systems/melee_strike_system.dart =====
import '../stores/hitbox_store.dart';
import '../stores/lifetime_store.dart';
import '../world.dart';

/// Processes requests to perform melee strikes.
///
/// **Responsibilities**:
/// *   Consumes committed melee intents created by input or enemy AI.
/// *   **Execution only**: converts `tick == currentTick` intents into ephemeral hitbox entities.
/// *   Spawns the actual "Hitbox" entity that performs collision checks (+ HitOnce + Lifetime).
/// *   Invalidates the intent immediately to prevent double execution in the same tick.
///
/// **Not responsible for**:
/// - Resource deduction (mana/stamina), cooldown start, or commit gating.
///   Those are handled at commit-time (e.g. AbilityActivationSystem / enemy commit logic).
///
/// **Workflow**:
/// 1. Filter intents that match the [currentTick] (synchronization via stamped execute tick).
/// 2. Invalidate the intent (so multi-pass in the same tick can’t double-spawn).
/// 3. Validate attacker existence + basic state (e.g. stunned checks).
/// 4. Spawn hitbox entity:
///    - Transform at attacker position
///    - HitboxDef from intent fields
///    - HitOnce marker
///    - LifetimeDef based on active window ticks
class MeleeStrikeSystem {
  /// Runs the system logic.
  ///
  /// [currentTick] is required to ensure we only process intents generated for THIS frame,
  /// preserving determinism.
  void step(EcsWorld world, {required int currentTick}) {
    final intents = world.meleeIntent;
    if (intents.denseEntities.isEmpty) return;

    // Iterate through all intents.
    for (var ii = 0; ii < intents.denseEntities.length; ii += 1) {
      final strikeer = intents.denseEntities[ii];

      final executeTick = intents.tick[ii];

      if (executeTick != currentTick) continue;

      // Invalidate now so accidental multi-pass execution in the same tick cannot
      // double-strike. (Intent is still ignored next tick due to stamp mismatch.)
      intents.tick[ii] = -1;
      intents.commitTick[ii] = -1;

      // -- Validation & Resource Checks --

      // Attacker must exist physically.
      final strikeerTi = world.transform.tryIndexOf(strikeer);
      if (strikeerTi == null) continue;

      // Cannot strike while stunned.
      if (world.controlLock.isStunned(strikeer, currentTick)) continue;

      // Attacker must have a faction to determine who they hit.
      final fi = world.faction.tryIndexOf(strikeer);
      if (fi == null) continue;
      final faction = world.faction.faction[fi];

      // -- Execution --

      // Spawn the hitbox.
      final hitbox = world.createEntity();
      world.transform.add(
        hitbox,
        // HitboxFollowOwnerSystem will position from `owner + offset`.
        // Initialize at owner's position to prevent 1-frame visual glitch.
        posX: world.transform.posX[strikeerTi],
        posY: world.transform.posY[strikeerTi],
        velX: 0.0,
        velY: 0.0,
      );
      world.hitbox.add(
        hitbox,
        HitboxDef(
          owner: strikeer,
          faction: faction,
          damage100: intents.damage100[ii],
          critChanceBp: intents.critChanceBp[ii],
          damageType: intents.damageType[ii],
          procs: intents.procs[ii],
          halfX: intents.halfX[ii],
          halfY: intents.halfY[ii],
          offsetX: intents.offsetX[ii],
          offsetY: intents.offsetY[ii],
          dirX: intents.dirX[ii],
          dirY: intents.dirY[ii],
        ),
      );
      // Ensure hitbox only hits things once.
      world.hitOnce.add(hitbox);
      // Hitbox is ephemeral.
      world.lifetime.add(
        hitbox,
        LifetimeDef(ticksLeft: intents.activeTicks[ii]),
      );
    }
  }
}


===== FILE: lib/core/ecs/systems/mobility_impact_system.dart =====
import '../../abilities/ability_catalog.dart';
import '../../abilities/ability_def.dart';
import '../../combat/damage.dart';
import '../../combat/status/status.dart';
import '../../events/game_event.dart';
import '../hit/hit_resolver.dart';
import '../spatial/broadphase_grid.dart';
import '../world.dart';

/// Applies authored mobility contact impacts while mobility abilities are active.
///
/// This covers roll/dash overlap effects (status and optional damage) without
/// requiring synthetic hitbox entities.
class MobilityImpactSystem {
  MobilityImpactSystem({required this.abilities});

  final AbilityResolver abilities;
  final HitResolver _resolver = HitResolver();
  final List<int> _overlaps = <int>[];

  void step(
    EcsWorld world,
    BroadphaseGrid broadphase, {
    required int currentTick,
    void Function(StatusRequest request)? queueStatus,
  }) {
    if (broadphase.targets.isEmpty) return;

    final active = world.activeAbility;
    if (active.denseEntities.isEmpty) return;

    final factions = world.faction;
    final transforms = world.transform;
    final colliders = world.colliderAabb;

    for (var i = 0; i < active.denseEntities.length; i += 1) {
      final source = active.denseEntities[i];
      final abilityId = active.abilityId[i];
      if (abilityId == null || abilityId.isEmpty) continue;
      if (active.slot[i] != AbilitySlot.mobility) continue;
      if (active.phase[i] != AbilityPhase.active) continue;
      if (world.deathState.has(source)) continue;

      final ability = abilities.resolve(abilityId);
      if (ability == null) continue;
      final impact = ability.mobilityImpact;
      if (!impact.hasAnyEffect) continue;

      final hasDamage = impact.damage100 > 0;
      final hasStatus =
          queueStatus != null && impact.statusProfileId != StatusProfileId.none;
      if (!hasDamage && !hasStatus) continue;

      final sourceFactionIndex = factions.tryIndexOf(source);
      final sourceTransformIndex = transforms.tryIndexOf(source);
      final sourceColliderIndex = colliders.tryIndexOf(source);
      if (sourceFactionIndex == null ||
          sourceTransformIndex == null ||
          sourceColliderIndex == null) {
        continue;
      }

      final sourceCenterX =
          transforms.posX[sourceTransformIndex] +
          colliders.offsetX[sourceColliderIndex];
      final sourceCenterY =
          transforms.posY[sourceTransformIndex] +
          colliders.offsetY[sourceColliderIndex];
      final sourceHalfX = colliders.halfX[sourceColliderIndex];
      final sourceHalfY = colliders.halfY[sourceColliderIndex];

      _resolver.collectOrderedOverlapsCenters(
        broadphase: broadphase,
        centerX: sourceCenterX,
        centerY: sourceCenterY,
        halfX: sourceHalfX,
        halfY: sourceHalfY,
        owner: source,
        sourceFaction: factions.faction[sourceFactionIndex],
        outTargetIndices: _overlaps,
      );
      if (_overlaps.isEmpty) continue;

      final activationTick = active.startTick[i];
      final sourceEnemyIndex = world.enemy.tryIndexOf(source);
      final sourceEnemyId = sourceEnemyIndex == null
          ? null
          : world.enemy.enemyId[sourceEnemyIndex];

      for (var oi = 0; oi < _overlaps.length; oi += 1) {
        final target = broadphase.targets.entities[_overlaps[oi]];
        final shouldApply = world.mobilityImpactState.registerImpact(
          source: source,
          target: target,
          activationTick: activationTick,
          hitPolicy: impact.hitPolicy,
        );
        if (!shouldApply) continue;

        if (hasDamage) {
          world.damageQueue.add(
            DamageRequest(
              target: target,
              amount100: impact.damage100,
              critChanceBp: impact.critChanceBp,
              damageType: impact.damageType,
              procs: impact.procs,
              source: source,
              sourceKind: DeathSourceKind.meleeHitbox,
              sourceEnemyId: sourceEnemyId,
            ),
          );
        }

        if (hasStatus) {
          queueStatus(
            StatusRequest(
              target: target,
              profileId: impact.statusProfileId,
              damageType: impact.damageType,
            ),
          );
        }

        if (impact.hitPolicy == HitPolicy.once) break;
      }
    }
  }
}


===== FILE: lib/core/ecs/systems/mobility_system.dart =====
import '../../abilities/ability_def.dart';
import '../../snapshots/enums.dart';
import '../../players/player_tuning.dart';
import '../stores/mobility_intent_store.dart';
import '../world.dart';

/// Executes mobility intents (dash/roll) and applies movement state.
///
/// Responsibilities:
/// - Validate cooldown/stamina/locks at commit.
/// - Start cooldown + ActiveAbility state on commit.
/// - Apply dash movement and gravity suppression on execute tick.
class MobilitySystem {
  void step(
    EcsWorld world,
    MovementTuningDerived tuning, {
    required int currentTick,
  }) {
    final intents = world.mobilityIntent;
    if (intents.denseEntities.isEmpty) return;

    final movements = world.movement;
    final transforms = world.transform;
    final bodies = world.body;

    final count = intents.denseEntities.length;
    for (var ii = 0; ii < count; ii += 1) {
      final entity = intents.denseEntities[ii];
      if (intents.slot[ii] == AbilitySlot.jump) {
        continue;
      }
      final executeTick = intents.tick[ii];

      if (executeTick != currentTick) continue;

      _invalidateIntent(intents, ii);

      final mi = movements.tryIndexOf(entity);
      final ti = transforms.tryIndexOf(entity);
      final bi = bodies.tryIndexOf(entity);
      if (mi == null || ti == null || bi == null) continue;
      if (!bodies.enabled[bi] || bodies.isKinematic[bi]) continue;

      final activeTicks = intents.activeTicks[ii];
      if (activeTicks <= 0) continue;

      final modifierIndex = world.statModifier.tryIndexOf(entity);
      final moveSpeedMul = modifierIndex == null
          ? 1.0
          : world.statModifier.moveSpeedMul[modifierIndex];

      final dirX = intents.dirX[ii];
      final dirY = intents.dirY[ii];
      final speedScale = intents.speedScaleBp[ii] / 10000.0;
      final baseSpeed = intents.mobilitySpeedX[ii];
      final dashSpeed = baseSpeed * moveSpeedMul * speedScale;

      movements.dashDirX[mi] = dirX;
      movements.dashDirY[mi] = dirY;
      movements.dashSpeedScale[mi] = speedScale;
      movements.mobilitySpeedX[mi] = intents.mobilitySpeedX[ii];
      movements.dashTicksLeft[mi] = activeTicks;
      if (dirX.abs() > 1e-6) {
        movements.facing[mi] = dirX >= 0 ? Facing.right : Facing.left;
      }

      transforms.velX[ti] = dirX * dashSpeed;
      transforms.velY[ti] = dirY * dashSpeed;
      world.gravityControl.setSuppressForTicks(entity, activeTicks);
    }
  }

  void _invalidateIntent(MobilityIntentStore intents, int index) {
    intents.tick[index] = -1;
    intents.commitTick[index] = -1;
  }
}


===== FILE: lib/core/ecs/systems/player_movement_system.dart =====
import '../../stats/character_stats_resolver.dart';
import '../../stats/resolved_stats_cache.dart';
import '../../snapshots/enums.dart';
import '../../players/player_tuning.dart';
import '../../util/fixed_math.dart';
import '../../util/velocity_math.dart';
import '../queries.dart';
import '../world.dart';

/// Applies platformer-style movement for entities with:
/// - Transform
/// - PlayerInput
/// - Movement
/// - Body
///
/// PlayerMovementSystem writes movement velocities only (input/dash/clamps).
/// Dash initiation is handled by [MobilitySystem].
/// Position integration and collision resolution are handled by CollisionSystem.
///
/// **Responsibilities**:
/// *   Update movement state timers (dash + facing locks).
/// *   Process horizontal input and dash movement state.
/// *   Apply horizontal/active-dash velocities.
class PlayerMovementSystem {
  PlayerMovementSystem({
    CharacterStatsResolver statsResolver = const CharacterStatsResolver(),
    ResolvedStatsCache? statsCache,
  }) : _statsCache = statsCache ?? ResolvedStatsCache(resolver: statsResolver);

  final ResolvedStatsCache _statsCache;

  void step(
    EcsWorld world,
    MovementTuningDerived tuning, {
    required int currentTick,
    bool fixedPointPilotEnabled = false,
    int fixedPointSubpixelScale = defaultPhysicsSubpixelScale,
  }) {
    final dt = tuning.dtSeconds;

    // Iterate over all controllable entities (Join: Movement + Input + Body +...).
    // Uses EcsQueries to efficiently fetch entities with all required components.
    EcsQueries.forMovementBodies(world, (e, mi, ti, ii, bi) {
      if (!world.body.enabled[bi]) return;

      // Kinematic bodies are moved by scripts/physics directly, not by player input.
      if (world.body.isKinematic[bi]) {
        return;
      }

      // -- Stun Check --
      // If stunned, Zero horizontal velocity and skip input input processing.
      // Vertical velocity (gravity) continues to apply normally (falling).
      if (world.controlLock.isStunned(e, currentTick)) {
        // Cancel dash if active (so we don't float)
        if (world.movement.dashTicksLeft[mi] > 0) {
          world.movement.dashTicksLeft[mi] = 0;
          // Restore gravity if it was suppressed by dash
          if (world.gravityControl.suppressGravityTicksLeft[world.gravityControl
                  .indexOf(e)] >
              0) {
            world.gravityControl.suppressGravityTicksLeft[world.gravityControl
                    .indexOf(e)] =
                0;
          }
        }
        world.transform.velX[ti] = 0;
        return;
      }

      // -- Timers --
      // Decrement state timers. These track temporary movement states.

      if (world.movement.dashTicksLeft[mi] > 0) {
        world.movement.dashTicksLeft[mi] -= 1;
      }
      final dashing = world.movement.dashTicksLeft[mi] > 0;
      final gearMoveSpeedMul = _gearMoveSpeedMultiplier(world, e);
      final modifierIndex = world.statModifier.tryIndexOf(e);
      final statusMoveSpeedMul = modifierIndex == null
          ? 1.0
          : world.statModifier.moveSpeedMul[modifierIndex];
      final moveSpeedMul = gearMoveSpeedMul * statusMoveSpeedMul;

      if (world.movement.facingLockTicksLeft[mi] > 0) {
        world.movement.facingLockTicksLeft[mi] -= 1;
      }

      // -- Horizontal Movement --
      if (dashing) {
        // [State: Dashing]
        // Lock velocity to the authored mobility speed and sampled scale.
        final baseSpeed = world.movement.mobilitySpeedX[mi];
        final dashSpeed =
            baseSpeed * moveSpeedMul * world.movement.dashSpeedScale[mi];
        world.transform.velX[ti] = world.movement.dashDirX[mi] * dashSpeed;
        world.transform.velY[ti] = world.movement.dashDirY[mi] * dashSpeed;
      } else {
        // [State: Normal Control]
        final axis = world.playerInput.moveAxis[ii];

        // Visuals: Update facing direction based on input.
        // This is decoupled from velocity to allow "turning" animations before velocity flips.
        if (world.movement.facingLockTicksLeft[mi] == 0 && axis != 0) {
          world.movement.facing[mi] = axis > 0 ? Facing.right : Facing.left;
        }

        // Apply horizontal acceleration/deceleration.
        world.transform.velX[ti] = _applyHorizontalMove(
          world.transform.velX[ti],
          axis,
          dt,
          tuning,
          moveSpeedMul,
        );
      }

      // -- Limits --
      // Soft cap on horizontal velocity to prevent runaway speeds from external forces.
      world.transform.velX[ti] = world.transform.velX[ti].clamp(
        -world.body.maxVelX[bi],
        world.body.maxVelX[bi],
      );

      if (fixedPointPilotEnabled) {
        world.transform.quantizeVelAtIndex(
          ti,
          subpixelScale: fixedPointSubpixelScale,
        );
      }
    });
  }

  double _gearMoveSpeedMultiplier(EcsWorld world, int entity) {
    final resolved = _statsCache.resolveForEntity(world, entity);
    return resolved.moveSpeedMultiplier;
  }

  /// Calculates the new horizontal velocity using linear acceleration/deceleration.
  ///
  /// Note:
  /// - Uses [t.decelerationX] when `axis == 0` (Stopping).
  /// - Uses [t.accelerationX] for both Speeding Up and Turning (changing direction).
  /// - Snaps to 0 if speed is below [t.minMoveSpeed] and input is 0.
  double _applyHorizontalMove(
    double velocityX,
    double axis,
    double dt,
    MovementTuningDerived tuning,
    double moveSpeedMul,
  ) {
    final t = tuning.base;
    final desiredX = axis == 0.0 ? 0.0 : axis * t.maxSpeedX * moveSpeedMul;
    return applyAccelDecel(
      current: velocityX,
      desired: desiredX,
      dtSeconds: dt,
      accelPerSecond: t.accelerationX * moveSpeedMul,
      decelPerSecond: t.decelerationX * moveSpeedMul,
      minStopSpeed: t.minMoveSpeed,
    );
  }

  // Dash initiation moved to MobilitySystem (ability-driven).
}


===== FILE: lib/core/ecs/systems/projectile_hit_system.dart =====
import 'dart:math';

import '../../combat/damage.dart';
import '../../events/game_event.dart';
import '../../snapshots/enums.dart';
import '../../util/vec2.dart';
import '../entity_id.dart';
import '../hit/hit_resolver.dart';
import '../stores/enemies/enemy_store.dart';
import '../stores/projectile_item_origin_store.dart';
import '../stores/projectile_store.dart';
import '../spatial/broadphase_grid.dart';
import '../world.dart';

/// Handles collision detection for projectiles against potentially damageable targets.
///
/// **Responsibilities**:
/// - Iterates all active projectiles.
/// - Calculates a swept capsule shape for the projectile based on its velocity/direction.
/// - Queries the [BroadphaseGrid] for collisions.
/// - Queues [DamageRequest] and despawns the projectile on impact.
class ProjectileHitSystem {
  final List<EntityId> _toDespawn = <EntityId>[];
  final List<int> _overlaps = <int>[];
  final HitResolver _resolver = HitResolver();

  /// Runs the system logic for a single tick.
  ///
  /// [broadphase] provides spatial acceleration for finding targets efficiently.
  void step(
    EcsWorld world,
    BroadphaseGrid broadphase, {
    required int currentTick,
    void Function(ProjectileHitEvent event)? queueHitEvent,
  }) {
    // Optimization: If there are no targets to hit, projectiles just fly.
    if (broadphase.targets.isEmpty) return;

    final projectiles = world.projectile;
    if (projectiles.denseEntities.isEmpty) return;

    _toDespawn.clear();

    // Cache store references for efficient lookup (Hoisting).
    final transforms = world.transform;
    final colliders = world.colliderAabb;
    final enemies = world.enemy;
    final projectileOrigins = world.projectileOrigin;
    final hitOnce = world.hitOnce;

    final count = projectiles.denseEntities.length;
    for (var pi = 0; pi < count; pi += 1) {
      final p = projectiles.denseEntities[pi];

      // Validation: Projectiles must have physical presence.
      final ti = transforms.tryIndexOf(p);
      if (ti == null) continue;

      final ci = colliders.tryIndexOf(p);
      if (ci == null) continue;

      // -- Geometry Construction --
      // Projectiles are modeled as capsules (swept circles) oriented along their velocity vector.
      // - [offsetX/Y]: Center offset relative to transform.
      // - [halfX]: Interpreted as half-length of the capsule shaft.
      // - [halfY]: Interpreted as the radius (thickness) of the projectile.
      final pcx = transforms.posX[ti] + colliders.offsetX[ci];
      final pcy = transforms.posY[ti] + colliders.offsetY[ci];

      final halfLength = colliders.halfX[ci];
      final radius = colliders.halfY[ci];

      final dirX = projectiles.dirX[pi];
      final dirY = projectiles.dirY[pi];
      final facing = dirX >= 0 ? Facing.right : Facing.left;
      final rotationRad = atan2(dirY, dirX);

      // Calculate the start (A) and end (B) points of the capsule segment.
      // The segment is centered at (pcx, pcy) and extends halfLength in both directions along (dirX, dirY).
      final ax = pcx - dirX * halfLength;
      final ay = pcy - dirY * halfLength;
      final bx = pcx + dirX * halfLength;
      final by = pcy + dirY * halfLength;

      // -- Hit Resolution --
      var owner = projectiles.owner[pi];
      final sourceFaction = projectiles.faction[pi];
      // Keep projectiles alive even if the caster has entered death state.
      //
      // If the caster entity has already been destroyed, detach ownership to
      // avoid stale/recycled entity-id coupling in later ticks.
      if (owner != 0 && !world.faction.has(owner)) {
        owner = 0;
        projectiles.owner[pi] = 0;
      }

      final isPiercing = projectiles.pierce[pi];
      final maxPierceHits = projectiles.maxPierceHits[pi];

      if (isPiercing) {
        _overlaps.clear();
        _resolver.collectOrderedOverlapsCapsule(
          broadphase: broadphase,
          ax: ax,
          ay: ay,
          bx: bx,
          by: by,
          radius: radius,
          owner: owner,
          sourceFaction: sourceFaction,
          outTargetIndices: _overlaps,
        );
        if (_overlaps.isEmpty) continue;

        var shouldDespawn = false;
        for (var oi = 0; oi < _overlaps.length; oi += 1) {
          final targetIndex = _overlaps[oi];
          final target = broadphase.targets.entities[targetIndex];
          if (hitOnce.has(p) && hitOnce.hasHit(p, target)) {
            continue;
          }
          if (hitOnce.has(p)) {
            hitOnce.markHit(p, target);
          }

          _queueProjectileDamage(
            world,
            target: target,
            owner: owner,
            projectileEntity: p,
            projectileStoreIndex: pi,
            enemies: enemies,
            projectileOrigins: projectileOrigins,
          );
          _queueProjectileHitEvent(
            queueHitEvent: queueHitEvent,
            currentTick: currentTick,
            projectileEntity: p,
            projectileStoreIndex: pi,
            projectileStoreCenterX: pcx,
            projectileStoreCenterY: pcy,
            facing: facing,
            rotationRad: rotationRad,
            projectiles: projectiles,
            projectileOrigins: projectileOrigins,
          );

          final hitCount = hitOnce.has(p)
              ? hitOnce.count[hitOnce.indexOf(p)]
              : 1;
          if (hitCount >= maxPierceHits) {
            shouldDespawn = true;
            break;
          }
        }

        if (shouldDespawn) {
          _toDespawn.add(p);
        }
        continue;
      }

      // Query the broadphase for the first valid intersection.
      // This respects "Friendly Fire" rules via [sourceFaction].
      final targetIndex = _resolver.firstOrderedOverlapCapsule(
        broadphase: broadphase,
        ax: ax,
        ay: ay,
        bx: bx,
        by: by,
        radius: radius,
        owner: owner,
        sourceFaction: sourceFaction,
      );

      // -- Impact Handling --
      if (targetIndex != null) {
        _queueProjectileDamage(
          world,
          target: broadphase.targets.entities[targetIndex],
          owner: owner,
          projectileEntity: p,
          projectileStoreIndex: pi,
          enemies: enemies,
          projectileOrigins: projectileOrigins,
        );
        _queueProjectileHitEvent(
          queueHitEvent: queueHitEvent,
          currentTick: currentTick,
          projectileEntity: p,
          projectileStoreIndex: pi,
          projectileStoreCenterX: pcx,
          projectileStoreCenterY: pcy,
          facing: facing,
          rotationRad: rotationRad,
          projectiles: projectiles,
          projectileOrigins: projectileOrigins,
        );

        // Mark projectile for removal.
        // We defer removal until after the loop or use a list to avoid modifying the collection while iterating
        // (though we are iterating by index here, deferred removal is safer/cleaner pattern).
        _toDespawn.add(p);
      }
    }

    // Process despawns.
    for (final e in _toDespawn) {
      world.destroyEntity(e);
    }
  }

  void _queueProjectileDamage(
    EcsWorld world, {
    required EntityId target,
    required EntityId owner,
    required EntityId projectileEntity,
    required int projectileStoreIndex,
    required EnemyStore enemies,
    required ProjectileOriginStore projectileOrigins,
  }) {
    final projectiles = world.projectile;

    final ei = enemies.tryIndexOf(owner);
    final enemyId = ei != null ? enemies.enemyId[ei] : null;

    final si = projectileOrigins.tryIndexOf(projectileEntity);
    final sourceProjectileId = si != null
        ? projectileOrigins.projectileId[si]
        : null;

    world.damageQueue.add(
      DamageRequest(
        target: target,
        amount100: projectiles.damage100[projectileStoreIndex],
        critChanceBp: projectiles.critChanceBp[projectileStoreIndex],
        damageType: projectiles.damageType[projectileStoreIndex],
        procs: projectiles.procs[projectileStoreIndex],
        source: owner,
        sourceKind: DeathSourceKind.projectile,
        sourceEnemyId: enemyId,
        sourceProjectileId:
            sourceProjectileId ??
            projectiles.projectileId[projectileStoreIndex],
      ),
    );
  }

  void _queueProjectileHitEvent({
    required void Function(ProjectileHitEvent event)? queueHitEvent,
    required int currentTick,
    required EntityId projectileEntity,
    required int projectileStoreIndex,
    required double projectileStoreCenterX,
    required double projectileStoreCenterY,
    required Facing facing,
    required double rotationRad,
    required ProjectileStore projectiles,
    required ProjectileOriginStore projectileOrigins,
  }) {
    if (queueHitEvent == null) return;
    final si = projectileOrigins.tryIndexOf(projectileEntity);
    final sourceProjectileId = si != null
        ? projectileOrigins.projectileId[si]
        : null;
    queueHitEvent(
      ProjectileHitEvent(
        tick: currentTick,
        projectileId: projectiles.projectileId[projectileStoreIndex],
        sourceProjectileId: sourceProjectileId,
        pos: Vec2(projectileStoreCenterX, projectileStoreCenterY),
        facing: facing,
        rotationRad: rotationRad,
      ),
    );
  }
}


===== FILE: lib/core/ecs/systems/projectile_launch_system.dart =====
import '../../projectiles/projectile_catalog.dart';
import '../../projectiles/spawn_projectile_item.dart';
import '../stores/projectile_intent_store.dart';
import '../world.dart';

/// Executes [ProjectileIntentStore] intents by spawning projectiles.
///
/// **Execution Only**:
/// - Reads committed intents (`tick == currentTick`).
/// - Spawns projectile entities.
/// - Does **not** deduct resources or start cooldowns (handled by Activation).
class ProjectileLaunchSystem {
  ProjectileLaunchSystem({required this.projectiles, required this.tickHz});

  final ProjectileCatalog projectiles;
  final int tickHz;

  void step(EcsWorld world, {required int currentTick}) {
    final intents = world.projectileIntent;
    if (intents.denseEntities.isEmpty) return;

    final transforms = world.transform;
    final factions = world.faction;

    final count = intents.denseEntities.length;
    for (var ii = 0; ii < count; ii += 1) {
      final caster = intents.denseEntities[ii];
      final executeTick = intents.tick[ii];

      final ti = transforms.tryIndexOf(caster);
      if (ti == null) {
        _invalidateIntent(intents, ii);
        continue;
      }

      if (executeTick != currentTick) continue;

      _invalidateIntent(intents, ii);

      final fi = factions.tryIndexOf(caster);
      if (fi == null) continue;
      final projectileId = intents.projectileId[ii];
      final projectile = projectiles.get(projectileId);

      spawnProjectileFromCaster(
        world,
        tickHz: tickHz,
        projectileId: projectileId,
        projectile: projectile,
        faction: factions.faction[fi],
        owner: caster,
        casterX: transforms.posX[ti],
        casterY: transforms.posY[ti],
        originOffset: intents.originOffset[ii],
        dirX: intents.dirX[ii],
        dirY: intents.dirY[ii],
        fallbackDirX: intents.fallbackDirX[ii],
        fallbackDirY: intents.fallbackDirY[ii],
        damage100: intents.damage100[ii],
        critChanceBp: intents.critChanceBp[ii],
        damageType: intents.damageType[ii],
        procs: intents.procs[ii],
        pierce: intents.pierce[ii],
        maxPierceHits: intents.maxPierceHits[ii],
        ballistic: intents.ballistic[ii],
        gravityScale: intents.gravityScale[ii],
        speedScale: intents.speedScaleBp[ii] / 10000.0,
      );
    }
  }

  void _invalidateIntent(ProjectileIntentStore intents, int index) {
    intents.tick[index] = -1;
    intents.commitTick[index] = -1;
  }
}


===== FILE: lib/core/ecs/systems/projectile_system.dart =====
import 'dart:math';

import '../../players/player_tuning.dart';
import '../world.dart';

/// Moves active projectiles based on their linear velocity.
///
/// **Responsibilities**:
/// - Updates `velX` and `velY` (for use by renderers/interpolation).
/// - Explicitly integrates position: `pos += vel * dt`.
///
/// Note: Projectiles are typically simple kinematic objects that do not participate
/// in the full physics/collision resolution loop (no `Body` component), hence the
/// manual position integration here.
class ProjectileSystem {
  void step(EcsWorld world, MovementTuningDerived movement) {
    final dt = movement.dtSeconds;
    final projectiles = world.projectile;
    final transforms = world.transform;

    // Iterate efficiently over dense projectile arrays.
    final count = projectiles.denseEntities.length;
    for (var pi = 0; pi < count; pi += 1) {
      final e = projectiles.denseEntities[pi];
      
      final ti = transforms.tryIndexOf(e);
      if (ti == null) continue;

      // Physics-driven projectiles (ballistic) are moved by the main physics
      // pipeline (GravitySystem + CollisionSystem). We only keep direction
      // in sync with velocity for hitbox orientation / rendering.
      if (projectiles.usePhysics[pi]) {
        final vx = transforms.velX[ti];
        final vy = transforms.velY[ti];
        final len2 = vx * vx + vy * vy;
        if (len2 > 1e-12) {
          final invLen = 1.0 / sqrt(len2);
          projectiles.dirX[pi] = vx * invLen;
          projectiles.dirY[pi] = vy * invLen;
        }
        continue;
      }

      // Calculate velocity from direction and speed.
      final vx = projectiles.dirX[pi] * projectiles.speedUnitsPerSecond[pi];
      final vy = projectiles.dirY[pi] * projectiles.speedUnitsPerSecond[pi];

      // Update Transform velocity (useful for other systems/debug).
      transforms.velX[ti] = vx;
      transforms.velY[ti] = vy;

      // Explicit Euler integration: pos += vel * dt
      // We do this here because projectiles lack a 'Body' component for simplicity
      // and thus aren't moved by the main physics solver.
      transforms.posX[ti] += vx * dt;
      transforms.posY[ti] += vy * dt;
    }
  }
}


===== FILE: lib/core/ecs/systems/projectile_world_collision_system.dart =====
import '../entity_id.dart';
import '../world.dart';

/// Despawns physics-driven projectiles that collided with the static world.
///
/// This is intended for ballistic projectiles (arrows, thrown axes) that use
/// [BodyStore] + [CollisionSystem] for ground/wall collision. When a collision
/// occurs, the projectile is removed immediately (same tick).
class ProjectileWorldCollisionSystem {
  final List<EntityId> _toDespawn = <EntityId>[];

  void step(EcsWorld world) {
    final projectiles = world.projectile;
    if (projectiles.denseEntities.isEmpty) return;

    final collisions = world.collision;
    if (collisions.denseEntities.isEmpty) return;

    _toDespawn.clear();
    for (var pi = 0; pi < projectiles.denseEntities.length; pi += 1) {
      if (!projectiles.usePhysics[pi]) continue;

      final p = projectiles.denseEntities[pi];
      final ci = collisions.tryIndexOf(p);
      if (ci == null) continue;

      if (collisions.grounded[ci] ||
          collisions.hitCeiling[ci] ||
          collisions.hitLeft[ci] ||
          collisions.hitRight[ci]) {
        _toDespawn.add(p);
      }
    }

    for (final p in _toDespawn) {
      world.destroyEntity(p);
    }
  }
}



===== FILE: lib/core/ecs/systems/resource_regen_system.dart =====
import '../world.dart';

/// Periodically regenerates Health, Mana, and Stamina for all entities.
///
/// **Responsibilities**:
/// - Iterates over all entities with [Health], [Mana], or [Stamina].
/// - Applies regeneration rates (`regenPerSecond`) scaled by `dtSeconds`.
/// - Clamps values to `[0, Max]`.
///
/// **Performance**:
/// - Uses direct dense array iteration (Structure of Arrays) for cache efficiency.
/// - Skips full resources and zero-regen entities early.
class ResourceRegenSystem {
  ResourceRegenSystem({required int tickHz}) : _tickHz = tickHz;

  final int _tickHz;

  void step(EcsWorld world) {
    _regenHealth(world);
    _regenMana(world);
    _regenStamina(world);
  }

  void _regenHealth(EcsWorld world) {
    final store = world.health;
    final deathState = world.deathState;
    final count = store.denseEntities.length;
    // Iterate contiguous arrays directly (SoA pattern).
    for (var i = 0; i < count; i += 1) {
      if (deathState.has(store.denseEntities[i])) continue;
      final max = store.hpMax[i];
      if (max <= 0) continue;
      
      final current = store.hp[i];
      if (current >= max) continue;
      
      final regen = store.regenPerSecond100[i];
      if (regen <= 0) continue;

      final accum = store.regenAccumulator[i] + regen;
      final delta = accum ~/ _tickHz;
      if (delta > 0) {
        final next = current + delta;
        store.hp[i] = next > max ? max : next;
      }
      store.regenAccumulator[i] = accum - (delta * _tickHz);
    }
  }

  void _regenMana(EcsWorld world) {
    final store = world.mana;
    final deathState = world.deathState;
    final count = store.denseEntities.length;
    for (var i = 0; i < count; i += 1) {
      if (deathState.has(store.denseEntities[i])) continue;
      final max = store.manaMax[i];
      if (max <= 0) continue;
      
      final current = store.mana[i];
      if (current >= max) continue;
      
      final regen = store.regenPerSecond100[i];
      if (regen <= 0) continue;

      final accum = store.regenAccumulator[i] + regen;
      final delta = accum ~/ _tickHz;
      if (delta > 0) {
        final next = current + delta;
        store.mana[i] = next > max ? max : next;
      }
      store.regenAccumulator[i] = accum - (delta * _tickHz);
    }
  }

  void _regenStamina(EcsWorld world) {
    final store = world.stamina;
    final deathState = world.deathState;
    final count = store.denseEntities.length;
    for (var i = 0; i < count; i += 1) {
      if (deathState.has(store.denseEntities[i])) continue;
      final max = store.staminaMax[i];
      if (max <= 0) continue;
      
      final current = store.stamina[i];
      if (current >= max) continue;
      
      final regen = store.regenPerSecond100[i];
      if (regen <= 0) continue;

      final accum = store.regenAccumulator[i] + regen;
      final delta = accum ~/ _tickHz;
      if (delta > 0) {
        final next = current + delta;
        store.stamina[i] = next > max ? max : next;
      }
      store.regenAccumulator[i] = accum - (delta * _tickHz);
    }
  }
}


===== FILE: lib/core/ecs/systems/restoration_item_system.dart =====
import '../entity_id.dart';
import '../world.dart';
import '../stores/restoration_item_store.dart';
import '../../tuning/restoration_item_tuning.dart';
import '../../util/fixed_math.dart';

/// Handles the lifecycle and collision of restoration pickups (Health/Mana/Stamina potions).
///
/// **Responsibilities**:
/// - Despawns items that fall too far behind the camera.
/// - Checks for collision with the Player.
/// - Applies restoration effects and despawns on pickup.
class RestorationItemSystem {
  final List<EntityId> _toDespawn = <EntityId>[];

  /// Executes the system logic for a single frame.
  ///
  /// - [player]: The valid [EntityId] of the local player character.
  /// - [cameraLeft]: The X coordinate of the camera's left edge (used for culling).
  /// - [tuning]: Configuration values for pickup ranges and restore amounts.
  void step(
    EcsWorld world, {
    required EntityId player,
    required double cameraLeft,
    required RestorationItemTuning tuning,
  }) {
    final items = world.restorationItem;
    // Early exit if no items exist to process.
    if (items.denseEntities.isEmpty) return;
    
    _toDespawn.clear();
    final despawnLimit = cameraLeft - tuning.despawnBehindCameraMargin;

    // -- Resolve Player AABB (Optimization) --
    // We cache the player's world-space bounds once per frame.
    final transforms = world.transform;
    final colliders = world.colliderAabb;

    final pTi = transforms.tryIndexOf(player);
    final pCi = colliders.tryIndexOf(player);
    
    // Bounds: Min/Max X/Y
    double pMinX = 0, pMaxX = 0, pMinY = 0, pMaxY = 0;
    bool playerActive = false;

    if (pTi != null && pCi != null) {
      playerActive = true;
      final cx = transforms.posX[pTi] + colliders.offsetX[pCi];
      final cy = transforms.posY[pTi] + colliders.offsetY[pCi];
      final hx = colliders.halfX[pCi];
      final hy = colliders.halfY[pCi];
      pMinX = cx - hx;
      pMaxX = cx + hx;
      pMinY = cy - hy;
      pMaxY = cy + hy;
    }

    // -- Iterate Items --
    final count = items.denseEntities.length;
    for (var ii = 0; ii < count; ii += 1) {
      final e = items.denseEntities[ii];
      
      final ti = transforms.tryIndexOf(e);
      // Skip items that are missing spatial components (malformed entities).
      if (ti == null) continue;
      
      final ci = colliders.tryIndexOf(e);
      if (ci == null) continue;

      final cx = transforms.posX[ti] + colliders.offsetX[ci];
      
      // 1. Despawn Logic (Garbage Collection)
      if (cx < despawnLimit) {
        _toDespawn.add(e);
        continue;
      }

      // 2. Collision Check (Pickup)
      if (playerActive) {
        final cy = transforms.posY[ti] + colliders.offsetY[ci];
        final hx = colliders.halfX[ci];
        final hy = colliders.halfY[ci];

        // AABB Overlap Logic:
        final overlaps = (cx - hx) < pMaxX && 
                         (cx + hx) > pMinX && 
                         (cy - hy) < pMaxY && 
                         (cy + hy) > pMinY;

        if (overlaps) {
          _applyRestore(
            world,
            player: player,
            stat: items.stat[ii],
            percentBp: tuning.restorePercentBp,
          );
          _toDespawn.add(e);
        }
      }
    }

    // Process all despawns in batch at the end of the frame.
    for (final e in _toDespawn) {
      world.destroyEntity(e);
    }
  }

  /// RESTORES a specific stat on the target [player].
  ///
  /// - [percent]: Percentage of MAX value to restore (0.0 to 1.0).
  /// - Scales based on the player's Max HP/Mana/Stamina.
  /// - Clamps to Max value (prevents overhealing).
  void _applyRestore(
    EcsWorld world, {
    required EntityId player,
    required RestorationStat stat,
    required int percentBp,
  }) {
    // Note: We use min/max checks to ensure we don't overheal or divide by zero.
    switch (stat) {
      case RestorationStat.health:
        final index = world.health.tryIndexOf(player);
        if (index != null) {
          final max = world.health.hpMax[index];
          if (max > 0) {
            final restore = (max * percentBp) ~/ bpScale;
            final next = world.health.hp[index] + restore;
            world.health.hp[index] = next > max ? max : next;
          }
        }
      case RestorationStat.mana:
        final index = world.mana.tryIndexOf(player);
        if (index != null) {
          final max = world.mana.manaMax[index];
          if (max > 0) {
            final restore = (max * percentBp) ~/ bpScale;
            final next = world.mana.mana[index] + restore;
            world.mana.mana[index] = next > max ? max : next;
          }
        }
      case RestorationStat.stamina:
        final index = world.stamina.tryIndexOf(player);
        if (index != null) {
          final max = world.stamina.staminaMax[index];
          if (max > 0) {
            final restore = (max * percentBp) ~/ bpScale;
            final next = world.stamina.stamina[index] + restore;
            world.stamina.stamina[index] =
                next > max ? max : next;
          }
        }
    }
  }
}


===== FILE: lib/core/ecs/systems/self_ability_system.dart =====
import '../../combat/status/status.dart';
import '../stores/self_intent_store.dart';
import '../world.dart';

/// Executes self abilities (parry, block, buffs) based on committed intents.
///
/// **Execution Only**:
/// - Reads committed intents (`tick == currentTick`).
/// - Queues self status profiles (buffs/restoration/other self effects).
/// - Does **not** deduct resources or start cooldowns.
class SelfAbilitySystem {
  void step(
    EcsWorld world, {
    required int currentTick,
    void Function(StatusRequest request)? queueStatus,
  }) {
    final intents = world.selfIntent;
    if (intents.denseEntities.isEmpty) return;

    final count = intents.denseEntities.length;
    for (var ii = 0; ii < count; ii += 1) {
      final executeTick = intents.tick[ii];

      if (executeTick != currentTick) continue;
      final target = intents.denseEntities[ii];
      if (world.deathState.has(target)) {
        _invalidateIntent(intents, ii);
        continue;
      }

      if (queueStatus != null) {
        final profileId = intents.selfStatusProfileId[ii];
        if (profileId != StatusProfileId.none) {
          queueStatus(StatusRequest(target: target, profileId: profileId));
        }
      }

      // Invalidate now to ensure no double-execution in same tick
      _invalidateIntent(intents, ii);
    }
  }

  void _invalidateIntent(SelfIntentStore intents, int index) {
    intents.tick[index] = -1;
    intents.commitTick[index] = -1;
  }
}


===== FILE: lib/core/ecs/systems/status_system.dart =====
import '../../combat/damage.dart';
import '../../combat/damage_type.dart';
import '../../combat/status/status.dart';
import '../../events/game_event.dart';
import '../../stats/character_stats_resolver.dart';
import '../../stats/resolved_stats_cache.dart';
import '../../util/tick_math.dart';
import '../../util/fixed_math.dart';
import '../../util/double_math.dart';
import '../../abilities/ability_def.dart' show AbilitySlot;
import '../entity_id.dart';
import '../stores/status/dot_store.dart';
import '../stores/status/drench_store.dart';
import '../stores/status/haste_store.dart';
import '../stores/status/resource_over_time_store.dart';
import '../stores/status/slow_store.dart';
import '../stores/status/vulnerable_store.dart';
import '../stores/status/weaken_store.dart';
import '../../combat/control_lock.dart';
import 'ability_interrupt.dart';
import '../world.dart';

typedef ResourcePulseCallback =
    void Function({
      required EntityId target,
      required StatusResourceType resourceType,
      required int restoredAmount100,
    });

/// Applies status effects and ticks active statuses.
class StatusSystem {
  StatusSystem({
    required int tickHz,
    StatusProfileCatalog profiles = const StatusProfileCatalog(),
    CharacterStatsResolver statsResolver = const CharacterStatsResolver(),
    ResolvedStatsCache? statsCache,
  }) : _tickHz = tickHz,
       _profiles = profiles,
       _statsCache = statsCache ?? ResolvedStatsCache(resolver: statsResolver);

  final int _tickHz;
  final StatusProfileCatalog _profiles;
  final ResolvedStatsCache _statsCache;

  final List<StatusRequest> _pending = <StatusRequest>[];
  final List<EntityId> _removeScratch = <EntityId>[];

  /// Current tick, set at the start of applyQueued.
  int _currentTick = 0;

  /// Queues a status profile to apply.
  void queue(StatusRequest request) {
    if (request.profileId == StatusProfileId.none) return;
    _pending.add(request);
  }

  /// Ticks existing statuses and queues DoT damage.
  void tickExisting(EcsWorld world, {ResourcePulseCallback? onResourcePulse}) {
    _tickDot(world);
    _tickResourceOverTime(world);
    _tickHaste(world);
    _tickSlow(world);
    _tickVulnerable(world);
    _tickWeaken(world);
    _tickDrench(world);
  }

  /// Applies queued statuses and refreshes derived modifiers.
  void applyQueued(
    EcsWorld world, {
    required int currentTick,
    ResourcePulseCallback? onResourcePulse,
  }) {
    _currentTick = currentTick;
    if (_pending.isNotEmpty) {
      _applyPending(world, onResourcePulse: onResourcePulse);
      _pending.clear();
    }
    _refreshMoveSpeed(world);
  }

  void _tickDot(EcsWorld world) {
    final dot = world.dot;
    if (dot.denseEntities.isEmpty) return;

    _removeScratch.clear();
    for (var i = 0; i < dot.denseEntities.length; i += 1) {
      final target = dot.denseEntities[i];
      if (world.deathState.has(target)) {
        _removeScratch.add(target);
        continue;
      }

      var channel = dot.damageTypes[i].length - 1;
      while (channel >= 0) {
        dot.ticksLeft[i][channel] -= 1;
        if (dot.ticksLeft[i][channel] <= 0) {
          dot.removeChannelAtEntityIndex(i, channel);
          channel -= 1;
          continue;
        }

        dot.periodTicksLeft[i][channel] -= 1;
        if (dot.periodTicksLeft[i][channel] <= 0) {
          dot.periodTicksLeft[i][channel] = dot.periodTicks[i][channel];
          final amount100 =
              (dot.dps100[i][channel] * dot.periodTicks[i][channel]) ~/ _tickHz;
          world.damageQueue.add(
            DamageRequest(
              target: target,
              amount100: amount100,
              damageType: dot.damageTypes[i][channel],
              sourceKind: DeathSourceKind.statusEffect,
            ),
          );
        }
        channel -= 1;
      }

      if (dot.hasNoChannelsEntityIndex(i)) {
        _removeScratch.add(target);
      }
    }
    for (final target in _removeScratch) {
      dot.removeEntity(target);
    }
  }

  void _tickResourceOverTime(EcsWorld world) {
    // Continuous restore is intentionally visual-pulse free.
    final resource = world.resourceOverTime;
    if (resource.denseEntities.isEmpty) return;

    _removeScratch.clear();
    for (var i = 0; i < resource.denseEntities.length; i += 1) {
      final target = resource.denseEntities[i];
      if (world.deathState.has(target)) {
        _removeScratch.add(target);
        continue;
      }

      var channel = resource.resourceTypes[i].length - 1;
      while (channel >= 0) {
        if (resource.ticksLeft[i][channel] <= 0) {
          resource.removeChannelAtEntityIndex(i, channel);
          channel -= 1;
          continue;
        }

        final totalTicks = resource.totalTicks[i][channel];
        final totalAmount100 = resource.totalAmount100[i][channel];
        if (totalTicks > 0 && totalAmount100 > 0) {
          final numerator =
              resource.accumulatorNumerator[i][channel] + totalAmount100;
          final delta = numerator ~/ totalTicks;
          resource.accumulatorNumerator[i][channel] =
              numerator - (delta * totalTicks);
          if (delta > 0) {
            _applyResourceAmount100(
              world,
              target: target,
              resourceType: resource.resourceTypes[i][channel],
              restoreAmount100: delta,
            );
          }
        }

        resource.ticksLeft[i][channel] -= 1;
        if (resource.ticksLeft[i][channel] <= 0) {
          resource.removeChannelAtEntityIndex(i, channel);
          channel -= 1;
          continue;
        }
        channel -= 1;
      }

      if (resource.hasNoChannelsEntityIndex(i)) {
        _removeScratch.add(target);
      }
    }
    for (final target in _removeScratch) {
      resource.removeEntity(target);
    }
  }

  void _tickSlow(EcsWorld world) {
    final slow = world.slow;
    if (slow.denseEntities.isEmpty) return;

    _removeScratch.clear();
    for (var i = 0; i < slow.denseEntities.length; i += 1) {
      final target = slow.denseEntities[i];
      if (world.deathState.has(target)) {
        _removeScratch.add(target);
        continue;
      }
      slow.ticksLeft[i] -= 1;
      if (slow.ticksLeft[i] <= 0) {
        _removeScratch.add(target);
      }
    }
    for (final target in _removeScratch) {
      slow.removeEntity(target);
    }
  }

  void _tickHaste(EcsWorld world) {
    final haste = world.haste;
    if (haste.denseEntities.isEmpty) return;

    _removeScratch.clear();
    for (var i = 0; i < haste.denseEntities.length; i += 1) {
      final target = haste.denseEntities[i];
      if (world.deathState.has(target)) {
        _removeScratch.add(target);
        continue;
      }
      haste.ticksLeft[i] -= 1;
      if (haste.ticksLeft[i] <= 0) {
        _removeScratch.add(target);
      }
    }
    for (final target in _removeScratch) {
      haste.removeEntity(target);
    }
  }

  void _applyPending(EcsWorld world, {ResourcePulseCallback? onResourcePulse}) {
    final resistance = world.damageResistance;
    final immunity = world.statusImmunity;
    final invuln = world.invulnerability;
    final resolvedStatsByTarget = <EntityId, ResolvedCharacterStats>{};

    for (final req in _pending) {
      if (world.deathState.has(req.target)) continue;
      if (!world.health.has(req.target)) continue;

      final ii = invuln.tryIndexOf(req.target);
      if (ii != null && invuln.ticksLeft[ii] > 0) continue;

      final profile = _profiles.get(req.profileId);
      if (profile.applications.isEmpty) continue;

      for (final app in profile.applications) {
        if (immunity.isImmune(req.target, app.type)) continue;

        var magnitude = app.magnitude;
        if (app.scaleByDamageType) {
          final baseTypedModBp = resistance.modBpForEntity(
            req.target,
            req.damageType,
          );
          final resolved = resolvedStatsByTarget.putIfAbsent(
            req.target,
            () => _statsCache.resolveForEntity(world, req.target),
          );
          final gearTypedModBp = resolved.incomingDamageModBpForDamageType(
            req.damageType,
          );
          final modBp = baseTypedModBp + gearTypedModBp;
          if (modBp > 0) {
            magnitude = applyBp(magnitude, modBp);
          }
        }
        if (magnitude <= 0) continue;

        switch (app.type) {
          case StatusEffectType.dot:
            final dotDamageType = app.dotDamageType;
            if (dotDamageType == null) {
              assert(
                false,
                'StatusEffectType.dot requires dotDamageType in StatusApplication.',
              );
              continue;
            }
            _applyDot(
              world,
              target: req.target,
              magnitude: magnitude,
              durationSeconds: app.durationSeconds,
              periodSeconds: app.periodSeconds,
              damageType: dotDamageType,
            );
          case StatusEffectType.resourceOverTime:
            final resourceType = app.resourceType;
            if (resourceType == null) {
              assert(
                false,
                'StatusEffectType.resourceOverTime requires resourceType in StatusApplication.',
              );
              continue;
            }
            _applyResourceOverTime(
              world,
              target: req.target,
              resourceType: resourceType,
              amountBp: magnitude,
              durationSeconds: app.durationSeconds,
              periodSeconds: app.periodSeconds,
              applyOnApply: app.applyOnApply,
              onResourcePulse: onResourcePulse,
            );
          case StatusEffectType.slow:
            _applySlow(world, req.target, magnitude, app.durationSeconds);
          case StatusEffectType.haste:
            _applyHaste(world, req.target, magnitude, app.durationSeconds);
          case StatusEffectType.stun:
            _applyStun(world, req.target, magnitude, app.durationSeconds);
          case StatusEffectType.vulnerable:
            _applyVulnerable(world, req.target, magnitude, app.durationSeconds);
          case StatusEffectType.weaken:
            _applyWeaken(world, req.target, magnitude, app.durationSeconds);
          case StatusEffectType.drench:
            _applyDrench(world, req.target, magnitude, app.durationSeconds);
          case StatusEffectType.silence:
            _applySilence(world, req.target, app.durationSeconds);
        }
      }
    }
  }

  void _applyStun(
    EcsWorld world,
    EntityId target,
    int magnitude,
    double durationSeconds,
  ) {
    // Stun requires statModifier for moveSpeedMul (and arguably any status effect target)
    if (!world.statModifier.has(target)) return;
    final durationTicks = ticksFromSecondsCeil(durationSeconds, _tickHz);
    if (durationTicks <= 0) return;

    // Add stun lock via ControlLockStore
    world.controlLock.addLock(
      target,
      LockFlag.stun,
      durationTicks,
      _currentTick,
    );

    // Hard cancel active intents to prevent ghost execution
    if (world.meleeIntent.has(target)) {
      world.meleeIntent.tick[world.meleeIntent.indexOf(target)] = -1;
    }
    if (world.projectileIntent.has(target)) {
      world.projectileIntent.tick[world.projectileIntent.indexOf(target)] = -1;
    }
    if (world.selfIntent.has(target)) {
      world.selfIntent.tick[world.selfIntent.indexOf(target)] = -1;
    }
    // Cancel dash if active
    final mi = world.movement.tryIndexOf(target);
    if (mi != null && world.movement.dashTicksLeft[mi] > 0) {
      world.movement.dashTicksLeft[mi] = 0;
    }
  }

  void _applySlow(
    EcsWorld world,
    EntityId target,
    int magnitude,
    double durationSeconds,
  ) {
    if (!world.statModifier.has(target)) return;
    final ticksLeft = ticksFromSecondsCeil(durationSeconds, _tickHz);
    if (ticksLeft <= 0) return;

    final slow = world.slow;
    final clamped = clampInt(magnitude, 0, 9000);
    final index = slow.tryIndexOf(target);
    if (index == null) {
      slow.add(target, SlowDef(ticksLeft: ticksLeft, magnitude: clamped));
    } else {
      final currentMagnitude = slow.magnitude[index];
      if (clamped > currentMagnitude) {
        slow.magnitude[index] = clamped;
        slow.ticksLeft[index] = ticksLeft;
      } else if (clamped == currentMagnitude) {
        if (ticksLeft > slow.ticksLeft[index]) {
          slow.ticksLeft[index] = ticksLeft;
        }
      }
    }
  }

  void _applyHaste(
    EcsWorld world,
    EntityId target,
    int magnitude,
    double durationSeconds,
  ) {
    if (!world.statModifier.has(target)) return;
    final ticksLeft = ticksFromSecondsCeil(durationSeconds, _tickHz);
    if (ticksLeft <= 0) return;

    final haste = world.haste;
    final clamped = clampInt(magnitude, 0, 20000);
    final index = haste.tryIndexOf(target);
    if (index == null) {
      haste.add(target, HasteDef(ticksLeft: ticksLeft, magnitude: clamped));
    } else {
      final currentMagnitude = haste.magnitude[index];
      if (clamped > currentMagnitude) {
        haste.magnitude[index] = clamped;
        haste.ticksLeft[index] = ticksLeft;
      } else if (clamped == currentMagnitude) {
        if (ticksLeft > haste.ticksLeft[index]) {
          haste.ticksLeft[index] = ticksLeft;
        }
      }
    }
  }

  void _applyVulnerable(
    EcsWorld world,
    EntityId target,
    int magnitude,
    double durationSeconds,
  ) {
    final ticksLeft = ticksFromSecondsCeil(durationSeconds, _tickHz);
    if (ticksLeft <= 0) return;

    final vulnerable = world.vulnerable;
    final clamped = clampInt(magnitude, 0, 9000);
    final index = vulnerable.tryIndexOf(target);
    if (index == null) {
      vulnerable.add(
        target,
        VulnerableDef(ticksLeft: ticksLeft, magnitude: clamped),
      );
    } else {
      final currentMagnitude = vulnerable.magnitude[index];
      if (clamped > currentMagnitude) {
        vulnerable.magnitude[index] = clamped;
        vulnerable.ticksLeft[index] = ticksLeft;
      } else if (clamped == currentMagnitude) {
        if (ticksLeft > vulnerable.ticksLeft[index]) {
          vulnerable.ticksLeft[index] = ticksLeft;
        }
      }
    }
  }

  void _applyWeaken(
    EcsWorld world,
    EntityId target,
    int magnitude,
    double durationSeconds,
  ) {
    final ticksLeft = ticksFromSecondsCeil(durationSeconds, _tickHz);
    if (ticksLeft <= 0) return;

    final weaken = world.weaken;
    final clamped = clampInt(magnitude, 0, 9000);
    final index = weaken.tryIndexOf(target);
    if (index == null) {
      weaken.add(target, WeakenDef(ticksLeft: ticksLeft, magnitude: clamped));
    } else {
      final currentMagnitude = weaken.magnitude[index];
      if (clamped > currentMagnitude) {
        weaken.magnitude[index] = clamped;
        weaken.ticksLeft[index] = ticksLeft;
      } else if (clamped == currentMagnitude) {
        if (ticksLeft > weaken.ticksLeft[index]) {
          weaken.ticksLeft[index] = ticksLeft;
        }
      }
    }
  }

  void _applyDrench(
    EcsWorld world,
    EntityId target,
    int magnitude,
    double durationSeconds,
  ) {
    final ticksLeft = ticksFromSecondsCeil(durationSeconds, _tickHz);
    if (ticksLeft <= 0) return;

    final drench = world.drench;
    final clamped = clampInt(magnitude, 0, 9000);
    final index = drench.tryIndexOf(target);
    if (index == null) {
      drench.add(target, DrenchDef(ticksLeft: ticksLeft, magnitude: clamped));
    } else {
      final currentMagnitude = drench.magnitude[index];
      if (clamped > currentMagnitude) {
        drench.magnitude[index] = clamped;
        drench.ticksLeft[index] = ticksLeft;
      } else if (clamped == currentMagnitude) {
        if (ticksLeft > drench.ticksLeft[index]) {
          drench.ticksLeft[index] = ticksLeft;
        }
      }
    }
  }

  void _applySilence(EcsWorld world, EntityId target, double durationSeconds) {
    final ticksLeft = ticksFromSecondsCeil(durationSeconds, _tickHz);
    if (ticksLeft <= 0) return;

    world.controlLock.addLock(target, LockFlag.cast, ticksLeft, _currentTick);

    // Silence only interrupts enemy casts and only while they are still in
    // windup. Active/recovery phases continue uninterrupted.
    if (!world.enemy.has(target)) return;
    final activeIndex = world.activeAbility.tryIndexOf(target);
    if (activeIndex == null) return;
    final abilityId = world.activeAbility.abilityId[activeIndex];
    if (abilityId == null || abilityId.isEmpty) return;
    if (world.activeAbility.slot[activeIndex] != AbilitySlot.projectile) return;
    final windupTicks = world.activeAbility.windupTicks[activeIndex];
    if (windupTicks <= 0) return;
    final elapsed = _currentTick - world.activeAbility.startTick[activeIndex];
    if (elapsed < 0 || elapsed >= windupTicks) return;

    AbilityInterrupt.clearActiveAndTransient(
      world,
      entity: target,
      startDeferredCooldown: true,
    );
  }

  void _applyDot(
    EcsWorld world, {
    required EntityId target,
    required int magnitude,
    required double durationSeconds,
    required double periodSeconds,
    required DamageType damageType,
  }) {
    final ticksLeft = ticksFromSecondsCeil(durationSeconds, _tickHz);
    if (ticksLeft <= 0) return;

    final periodTicks = periodSeconds <= 0.0
        ? 1
        : ticksFromSecondsCeil(periodSeconds, _tickHz);
    final dps100 = magnitude;

    final dot = world.dot;
    final index = dot.tryIndexOf(target);
    if (index == null) {
      dot.add(
        target,
        DotDef(
          damageType: damageType,
          ticksLeft: ticksLeft,
          periodTicks: periodTicks,
          dps100: dps100,
        ),
      );
      return;
    }

    final channelIndex = dot.channelIndexForEntityIndex(index, damageType);
    if (channelIndex == null) {
      dot.addChannel(
        target,
        DotDef(
          damageType: damageType,
          ticksLeft: ticksLeft,
          periodTicks: periodTicks,
          dps100: dps100,
        ),
      );
      return;
    }

    final currentDps = dot.dps100[index][channelIndex];
    if (dps100 > currentDps) {
      dot.setChannel(
        target,
        channelIndex,
        DotDef(
          damageType: damageType,
          ticksLeft: ticksLeft,
          periodTicks: periodTicks,
          dps100: dps100,
        ),
      );
      return;
    }

    if (dps100 == currentDps &&
        ticksLeft > dot.ticksLeft[index][channelIndex]) {
      dot.ticksLeft[index][channelIndex] = ticksLeft;
    }
  }

  void _applyResourceOverTime(
    EcsWorld world, {
    required EntityId target,
    required StatusResourceType resourceType,
    required int amountBp,
    required double durationSeconds,
    required double periodSeconds,
    required bool applyOnApply,
    ResourcePulseCallback? onResourcePulse,
  }) {
    if (periodSeconds <= 0.0) return;

    if (applyOnApply) {
      _applyResourcePulse(
        world,
        target: target,
        resourceType: resourceType,
        amountBp: amountBp,
        onResourcePulse: onResourcePulse,
      );
    }

    final ticksLeft = ticksFromSecondsCeil(durationSeconds, _tickHz);
    if (ticksLeft <= 0) return;
    final totalAmount100 = _resourceRestoreAmount100FromBp(
      world,
      target: target,
      resourceType: resourceType,
      amountBp: amountBp,
    );
    if (totalAmount100 <= 0) return;

    final rotDef = ResourceOverTimeDef(
      resourceType: resourceType,
      ticksLeft: ticksLeft,
      totalTicks: ticksLeft,
      totalAmount100: totalAmount100,
      amountBp: amountBp,
    );

    final resource = world.resourceOverTime;
    final index = resource.tryIndexOf(target);
    if (index == null) {
      resource.add(target, rotDef);
      return;
    }

    final channelIndex = resource.channelIndexForEntityIndex(
      index,
      resourceType,
    );
    if (channelIndex == null) {
      resource.addChannel(target, rotDef);
      return;
    }

    final currentAmountBp = resource.amountBp[index][channelIndex];
    if (amountBp > currentAmountBp) {
      resource.setChannel(target, channelIndex, rotDef);
      return;
    }

    if (amountBp == currentAmountBp &&
        ticksLeft > resource.ticksLeft[index][channelIndex]) {
      resource.setChannel(target, channelIndex, rotDef);
    }
  }

  void _applyResourcePulse(
    EcsWorld world, {
    required EntityId target,
    required StatusResourceType resourceType,
    required int amountBp,
    ResourcePulseCallback? onResourcePulse,
  }) {
    if (amountBp <= 0) return;

    final restoreAmount100 = _resourceRestoreAmount100FromBp(
      world,
      target: target,
      resourceType: resourceType,
      amountBp: amountBp,
    );
    _applyResourceAmount100(
      world,
      target: target,
      resourceType: resourceType,
      restoreAmount100: restoreAmount100,
      onResourcePulse: onResourcePulse,
    );
  }

  int _resourceRestoreAmount100FromBp(
    EcsWorld world, {
    required EntityId target,
    required StatusResourceType resourceType,
    required int amountBp,
  }) {
    final max = _resourceMax100(
      world,
      target: target,
      resourceType: resourceType,
    );
    if (max <= 0 || amountBp <= 0) return 0;
    return (max * amountBp) ~/ bpScale;
  }

  int _resourceMax100(
    EcsWorld world, {
    required EntityId target,
    required StatusResourceType resourceType,
  }) {
    switch (resourceType) {
      case StatusResourceType.health:
        final index = world.health.tryIndexOf(target);
        if (index == null) return 0;
        return world.health.hpMax[index];
      case StatusResourceType.mana:
        final index = world.mana.tryIndexOf(target);
        if (index == null) return 0;
        return world.mana.manaMax[index];
      case StatusResourceType.stamina:
        final index = world.stamina.tryIndexOf(target);
        if (index == null) return 0;
        return world.stamina.staminaMax[index];
    }
  }

  void _applyResourceAmount100(
    EcsWorld world, {
    required EntityId target,
    required StatusResourceType resourceType,
    required int restoreAmount100,
    ResourcePulseCallback? onResourcePulse,
  }) {
    if (restoreAmount100 <= 0) return;

    switch (resourceType) {
      case StatusResourceType.health:
        final index = world.health.tryIndexOf(target);
        if (index == null) return;
        final max = world.health.hpMax[index];
        if (max <= 0) return;
        final current = world.health.hp[index];
        final next = current + restoreAmount100;
        final clamped = next > max ? max : next;
        final applied = clamped - current;
        if (applied <= 0) return;
        world.health.hp[index] = clamped;
        onResourcePulse?.call(
          target: target,
          resourceType: resourceType,
          restoredAmount100: applied,
        );
      case StatusResourceType.mana:
        final index = world.mana.tryIndexOf(target);
        if (index == null) return;
        final max = world.mana.manaMax[index];
        if (max <= 0) return;
        final current = world.mana.mana[index];
        final next = current + restoreAmount100;
        final clamped = next > max ? max : next;
        final applied = clamped - current;
        if (applied <= 0) return;
        world.mana.mana[index] = clamped;
        onResourcePulse?.call(
          target: target,
          resourceType: resourceType,
          restoredAmount100: applied,
        );
      case StatusResourceType.stamina:
        final index = world.stamina.tryIndexOf(target);
        if (index == null) return;
        final max = world.stamina.staminaMax[index];
        if (max <= 0) return;
        final current = world.stamina.stamina[index];
        final next = current + restoreAmount100;
        final clamped = next > max ? max : next;
        final applied = clamped - current;
        if (applied <= 0) return;
        world.stamina.stamina[index] = clamped;
        onResourcePulse?.call(
          target: target,
          resourceType: resourceType,
          restoredAmount100: applied,
        );
    }
  }

  void _refreshMoveSpeed(EcsWorld world) {
    final mods = world.statModifier;
    if (mods.denseEntities.isEmpty) return;

    for (var i = 0; i < mods.denseEntities.length; i += 1) {
      mods.moveSpeedMul[i] = 1.0;
      mods.actionSpeedBp[i] = bpScale;
    }

    final slow = world.slow;
    if (slow.denseEntities.isNotEmpty) {
      for (var i = 0; i < slow.denseEntities.length; i += 1) {
        final target = slow.denseEntities[i];
        final mi = mods.tryIndexOf(target);
        if (mi == null) continue;
        final slowBp = slow.magnitude[i];
        mods.moveSpeedMul[mi] -= slowBp / bpScale;
      }
    }

    final haste = world.haste;
    if (haste.denseEntities.isNotEmpty) {
      for (var i = 0; i < haste.denseEntities.length; i += 1) {
        final target = haste.denseEntities[i];
        final mi = mods.tryIndexOf(target);
        if (mi == null) continue;
        final hasteBp = haste.magnitude[i];
        mods.moveSpeedMul[mi] += hasteBp / bpScale;
      }
    }

    final drench = world.drench;
    if (drench.denseEntities.isNotEmpty) {
      for (var i = 0; i < drench.denseEntities.length; i += 1) {
        final target = drench.denseEntities[i];
        final mi = mods.tryIndexOf(target);
        if (mi == null) continue;
        mods.actionSpeedBp[mi] -= drench.magnitude[i];
      }
    }

    for (var i = 0; i < mods.denseEntities.length; i += 1) {
      mods.moveSpeedMul[i] = clampDouble(mods.moveSpeedMul[i], 0.1, 2.0);
      mods.actionSpeedBp[i] = clampInt(mods.actionSpeedBp[i], 1000, 20000);
    }
  }

  void _tickVulnerable(EcsWorld world) {
    final vulnerable = world.vulnerable;
    if (vulnerable.denseEntities.isEmpty) return;

    _removeScratch.clear();
    for (var i = 0; i < vulnerable.denseEntities.length; i += 1) {
      final target = vulnerable.denseEntities[i];
      if (world.deathState.has(target)) {
        _removeScratch.add(target);
        continue;
      }
      vulnerable.ticksLeft[i] -= 1;
      if (vulnerable.ticksLeft[i] <= 0) {
        _removeScratch.add(target);
      }
    }
    for (final target in _removeScratch) {
      vulnerable.removeEntity(target);
    }
  }

  void _tickWeaken(EcsWorld world) {
    final weaken = world.weaken;
    if (weaken.denseEntities.isEmpty) return;

    _removeScratch.clear();
    for (var i = 0; i < weaken.denseEntities.length; i += 1) {
      final target = weaken.denseEntities[i];
      if (world.deathState.has(target)) {
        _removeScratch.add(target);
        continue;
      }
      weaken.ticksLeft[i] -= 1;
      if (weaken.ticksLeft[i] <= 0) {
        _removeScratch.add(target);
      }
    }
    for (final target in _removeScratch) {
      weaken.removeEntity(target);
    }
  }

  void _tickDrench(EcsWorld world) {
    final drench = world.drench;
    if (drench.denseEntities.isEmpty) return;

    _removeScratch.clear();
    for (var i = 0; i < drench.denseEntities.length; i += 1) {
      final target = drench.denseEntities[i];
      if (world.deathState.has(target)) {
        _removeScratch.add(target);
        continue;
      }
      drench.ticksLeft[i] -= 1;
      if (drench.ticksLeft[i] <= 0) {
        _removeScratch.add(target);
      }
    }
    for (final target in _removeScratch) {
      drench.removeEntity(target);
    }
  }
}


===== FILE: lib/core/ecs/world.dart =====
import 'entity_id.dart';
import 'sparse_set.dart';
import 'stores/body_store.dart';
import 'stores/collider_aabb_store.dart';
import 'stores/collision_state_store.dart';
import 'stores/cooldown_store.dart';
import 'stores/projectile_intent_store.dart';
import 'stores/self_intent_store.dart';
import 'stores/combat/creature_tag_store.dart';
import 'stores/combat/damage_resistance_store.dart';
import 'stores/combat/equipped_loadout_store.dart';
import 'stores/combat/resolved_stats_cache_store.dart';
import 'stores/combat/stat_modifier_store.dart';
import 'stores/combat/status_immunity_store.dart';
import 'stores/collectible_store.dart';
import 'stores/player/gravity_control_store.dart';
import 'stores/player/jump_state_store.dart';
import 'stores/enemies/flying_enemy_steering_store.dart';
import 'stores/faction_store.dart';
import 'stores/anim/anim_state_store.dart';
import 'stores/active_ability_state_store.dart';
import 'stores/ability_charge_state_store.dart';
import 'stores/ability_input_buffer_store.dart';
import 'stores/enemies/enemy_store.dart';
import 'stores/enemies/ground_enemy_chase_offset_store.dart';
import 'stores/enemies/engagement_intent_store.dart';
import 'stores/enemies/melee_engagement_store.dart';
import 'stores/enemies/nav_intent_store.dart';
import 'stores/health_store.dart';
import 'stores/hit_once_store.dart';
import 'stores/hitbox_store.dart';
import 'stores/death_state_store.dart';
import 'stores/player/invulnerability_store.dart';
import 'stores/player/last_damage_store.dart';
import 'stores/lifetime_store.dart';
import 'stores/mana_store.dart';
import 'stores/melee_intent_store.dart';
import 'stores/mobility_intent_store.dart';
import 'stores/mobility_impact_state_store.dart';
import 'stores/player/movement_store.dart';
import 'stores/player/player_input_store.dart';
import 'stores/projectile_store.dart';
import 'stores/restoration_item_store.dart';
import 'stores/status/dot_store.dart';
import 'stores/status/drench_store.dart';
import 'stores/status/haste_store.dart';
import 'stores/status/resource_over_time_store.dart';
import 'stores/status/slow_store.dart';
import 'stores/status/vulnerable_store.dart';
import 'stores/status/weaken_store.dart';
import 'stores/control_lock_store.dart';
import 'stores/damage_queue_store.dart';
import 'stores/parry_consume_store.dart';
import 'stores/riposte_store.dart';
import 'stores/projectile_item_origin_store.dart';
import 'stores/stamina_store.dart';
import 'stores/enemies/surface_nav_state_store.dart';
import 'stores/transform_store.dart';

/// Minimal Entity Component System (ECS) world container.
///
/// The [EcsWorld] is the central hub of the ECS architecture. It manages the
/// creation and destruction of entities ([EntityId]) and acts as a registry
/// for all Component Stores.
///
/// Design philosophy:
/// - **Structure-of-Arrays (SoA):** Data is stored in parallel arrays within each
///   [SparseSet] component store, rather than as objects on the entity.
/// - **Composition over Inheritance:** Game objects are defined by the collection
///   of components they possess.
/// - **Pooling:** Entity IDs are recycled to keep memory usage compact and predictable.
///
/// To add functionality to the game, Systems (logic) query this World for Entities
/// with specific components and operate on them.
class EcsWorld {
  /// Creates a new ECS World with an optional [seed] for deterministic behavior.
  EcsWorld({this.seed = 0});

  /// Seed used for deterministic RNG in the core, passed to components that need it.
  final int seed;

  /// Counter for generating new unique Entity IDs.
  EntityId _nextEntityId = 1;

  /// Pool of recycled Entity IDs available for reuse.
  final List<EntityId> _freeIds = <EntityId>[];

  /// Fast lookup set for recycled IDs to prevent double-freeing.
  final Set<EntityId> _freeIdsSet = <EntityId>{};

  /// Registry of all registered component stores.
  final List<SparseSet> _stores = <SparseSet>[];

  /// Helper to register a store with the world so it receives lifecycle events (like entity destruction).
  T _register<T extends SparseSet>(T store) {
    _stores.add(store);
    return store;
  }

  /// World-level damage request queue (shared across systems).
  final DamageQueueStore damageQueue = DamageQueueStore();

  /// Mobility impact hit-policy tracker keyed by source entity + activation.
  final MobilityImpactStateStore mobilityImpactState =
      MobilityImpactStateStore();

  /// Parry consumption tracker (per activation).
  final ParryConsumeStore parryConsume = ParryConsumeStore();

  // --- Component Stores ---
  // Each store manages a specific type of data for entities.

  /// Stores position (x, y) and velocity (vx, vy).
  late final TransformStore transform = _register(TransformStore());

  /// Helper components for handling user input events.
  late final PlayerInputStore playerInput = _register(PlayerInputStore());

  /// Buffered ability input for recovery-window handling.
  late final AbilityInputBufferStore abilityInputBuffer = _register(
    AbilityInputBufferStore(),
  );

  /// Authoritative slot hold duration tracking for charged commits.
  late final AbilityChargeStateStore abilityCharge = _register(
    AbilityChargeStateStore(),
  );

  /// Logic and state for movement, including facing direction.
  late final MovementStore movement = _register(MovementStore());

  /// Jump-specific runtime state (coyote, buffer, air jump usage).
  late final JumpStateStore jumpState = _register(JumpStateStore());

  /// Physics properties like mass, friction, and restitution.
  late final BodyStore body = _register(BodyStore());

  /// Axis-Aligned Bounding Box (AABB) for collision detection.
  late final ColliderAabbStore colliderAabb = _register(ColliderAabbStore());

  /// Runtime state of collisions (e.g., is grounded, wall contact).
  late final CollisionStateStore collision = _register(CollisionStateStore());

  /// Generic cooldown timer for abilities or actions.
  late final CooldownStore cooldown = _register(CooldownStore());

  /// Tracks the player's intent to fire a projectile item (spell or throw).
  late final ProjectileIntentStore projectileIntent = _register(
    ProjectileIntentStore(),
  );

  /// Tracks the intent to use a self ability (parry, block, buff).
  late final SelfIntentStore selfIntent = _register(SelfIntentStore());

  /// Creature classification tags (humanoid, demon, etc.).
  late final CreatureTagStore creatureTag = _register(CreatureTagStore());

  /// Marks an entity as a collectible item (e.g., coin, power-up).
  late final CollectibleStore collectible = _register(CollectibleStore());

  /// Defines an item that restores stats (health/mana) when collected.
  late final RestorationItemStore restorationItem = _register(
    RestorationItemStore(),
  );

  /// Allows an entity to control or defy gravity.
  late final GravityControlStore gravityControl = _register(
    GravityControlStore(),
  );

  /// Defines which faction (Player, Enemy, Neutral) an entity belongs to.
  late final FactionStore faction = _register(FactionStore());

  /// Manages Health Points (HP) and max HP.
  late final HealthStore health = _register(HealthStore());

  /// Damage resistance/vulnerability modifiers.
  late final DamageResistanceStore damageResistance = _register(
    DamageResistanceStore(),
  );

  /// Grants temporary invulnerability (i-frames).
  late final InvulnerabilityStore invulnerability = _register(
    InvulnerabilityStore(),
  );

  /// Records the last entity/source that dealt damage to this entity.
  late final LastDamageStore lastDamage = _register(LastDamageStore());

  /// Tracks per-entity death lifecycle state.
  late final DeathStateStore deathState = _register(DeathStateStore());

  /// Status immunities
  /// (dot, slow, stun, haste, vulnerable, weaken, drench, resource-over-time).
  late final StatusImmunityStore statusImmunity = _register(
    StatusImmunityStore(),
  );

  /// Manages Mana Points (MP) and max MP.
  late final ManaStore mana = _register(ManaStore());

  /// Tracks the player's intent to perform a melee strike.
  late final MeleeIntentStore meleeIntent = _register(MeleeIntentStore());

  /// Tracks the player's intent to perform a mobility action (dash/roll).
  late final MobilityIntentStore mobilityIntent = _register(
    MobilityIntentStore(),
  );

  /// Unified loadout store (single source of truth for all equipment).
  late final EquippedLoadoutStore equippedLoadout = _register(
    EquippedLoadoutStore(),
  );

  /// Cached loadout-derived resolved stats for hot-path systems.
  late final ResolvedStatsCacheStore resolvedStatsCache = _register(
    ResolvedStatsCacheStore(),
  );

  /// Derived runtime stat modifiers (e.g., slows).
  late final StatModifierStore statModifier = _register(StatModifierStore());

  /// Manages Stamina Points (SP) and max SP.
  late final StaminaStore stamina = _register(StaminaStore());

  /// One-shot bonus granted by parry, consumed on the next landed melee hit.
  late final RiposteStore riposte = _register(RiposteStore());

  /// Marks an entity as a projectile and defines its properties.
  late final ProjectileStore projectile = _register(ProjectileStore());

  /// Defines an area that deals damage or effects on contact.
  late final HitboxStore hitbox = _register(HitboxStore());

  /// Ensures a hitbox only affects a target once per interaction.
  late final HitOnceStore hitOnce = _register(HitOnceStore());

  /// Despawns entities after a set duration.
  late final LifetimeStore lifetime = _register(LifetimeStore());

  /// Active damage-over-time effects.
  late final DotStore dot = _register(DotStore());

  /// Active haste effects.
  late final HasteStore haste = _register(HasteStore());

  /// Active resource-over-time effects.
  late final ResourceOverTimeStore resourceOverTime = _register(
    ResourceOverTimeStore(),
  );

  /// Active slow effects.
  late final SlowStore slow = _register(SlowStore());

  /// Active vulnerability effects.
  late final VulnerableStore vulnerable = _register(VulnerableStore());

  /// Active outgoing-damage reduction effects.
  late final WeakenStore weaken = _register(WeakenStore());

  /// Active attack/cast speed reduction effects.
  late final DrenchStore drench = _register(DrenchStore());

  /// Control locks for ability/action gating (stun, movement locks, etc.).
  late final ControlLockStore controlLock = _register(ControlLockStore());

  /// Links a projectile back to its originating projectile item.
  late final ProjectileOriginStore projectileOrigin = _register(
    ProjectileOriginStore(),
  );

  /// State for ground enemies navigating terrain (jumping gaps/walls).
  late final SurfaceNavStateStore surfaceNav = _register(
    SurfaceNavStateStore(),
  );

  /// Identifies an entity as a specific type of enemy.
  late final EnemyStore enemy = _register(EnemyStore());

  /// Per-entity animation state computed by [AnimSystem].
  late final AnimStateStore animState = _register(AnimStateStore());

  /// Tracks the currently active ability for animation purposes.
  late final ActiveAbilityStateStore activeAbility = _register(
    ActiveAbilityStateStore(),
  );

  /// Steering behaviors for flying enemies.
  late final FlyingEnemySteeringStore flyingEnemySteering = _register(
    FlyingEnemySteeringStore(),
  );

  /// AI state for ground enemies to create offset chasing behaviors.
  late final GroundEnemyChaseOffsetStore groundEnemyChaseOffset = _register(
    GroundEnemyChaseOffsetStore(),
  );

  /// Navigation intent output for ground enemies.
  late final NavIntentStore navIntent = _register(NavIntentStore());

  /// Engagement intent output for melee enemies.
  late final EngagementIntentStore engagementIntent = _register(
    EngagementIntentStore(),
  );

  /// Engagement state for melee enemies (approach/engage/strike/recover).
  late final MeleeEngagementStore meleeEngagement = _register(
    MeleeEngagementStore(),
  );

  /// Allocates a new [EntityId].
  ///
  /// Prefers reusing ID from the free pool if available; otherwise increments the counter.
  EntityId createEntity() {
    if (_freeIds.isNotEmpty) {
      final id = _freeIds.removeLast();
      _freeIdsSet.remove(id);
      return id;
    }
    final id = _nextEntityId;
    _nextEntityId += 1;
    return id;
  }

  /// Destroys [entity], removing it from all component stores.
  ///
  /// The ID is returned to the free pool for future reuse.
  /// Does nothing if the entity is already destroyed/free.
  void destroyEntity(EntityId entity) {
    if (_freeIdsSet.contains(entity)) {
      return;
    }
    for (final store in _stores) {
      store.removeEntity(entity);
    }
    mobilityImpactState.removeEntity(entity);
    parryConsume.removeEntity(entity);
    _freeIds.add(entity);
    _freeIdsSet.add(entity);
  }
}


===== FILE: lib/core/enemies/death_behavior.dart =====
/// Enemy death behavior configuration (data-driven).
library;

/// Determines how an enemy transitions from "killed" to final despawn.
enum DeathBehavior {
  /// Start the death animation immediately on kill.
  instant,

  /// If killed mid-air, fall until grounded before starting the death animation.
  groundImpactThenDeath,
}

/// Runtime death phase for enemies that are waiting to despawn.
enum DeathPhase {
  none,
  fallingUntilGround,
  deathAnim,
}



===== FILE: lib/core/enemies/enemy_catalog.dart =====
import '../ecs/stores/body_store.dart';
import '../ecs/stores/collider_aabb_store.dart';
import '../ecs/stores/combat/creature_tag_store.dart';
import '../ecs/stores/combat/damage_resistance_store.dart';
import '../ecs/stores/combat/status_immunity_store.dart';
import '../ecs/stores/health_store.dart';
import '../ecs/stores/mana_store.dart';
import '../ecs/stores/stamina_store.dart';
import '../combat/creature_tag.dart';
import '../anim/anim_resolver.dart';
import '../contracts/render_anim_set_definition.dart';
import 'death_behavior.dart';
import '../projectiles/projectile_id.dart';
import '../snapshots/enums.dart';
import '../util/vec2.dart';
import 'enemy_id.dart';

// -----------------------------------------------------------------------------
// Unoco Demon render animation strip definitions (authoring-time)
// -----------------------------------------------------------------------------

const int _unocoAnimFrameWidth = 81;
const int _unocoAnimFrameHeight = 71;

const int _unocoAnimIdleFrames = 4;
const double _unocoAnimIdleStepSeconds = 0.12;

const int _unocoAnimStunFrames = 4;
const double _unocoAnimStunStepSeconds = 0.12;

const int _unocoAnimMoveFrames = 4;
const double _unocoAnimMoveStepSeconds = 0.12;

const int _unocoAnimHitFrames = 4;
const double _unocoAnimHitStepSeconds = 0.10;

const int _unocoAnimDeathFrames = 7;
const double _unocoAnimDeathStepSeconds = 0.12;

const double _unocoHitAnimSeconds =
    _unocoAnimHitFrames * _unocoAnimHitStepSeconds;
const double _unocoDeathAnimSeconds =
    _unocoAnimDeathFrames * _unocoAnimDeathStepSeconds;

const Map<AnimKey, int> _unocoAnimFrameCountsByKey = <AnimKey, int>{
  AnimKey.idle: _unocoAnimIdleFrames,
  AnimKey.stun: _unocoAnimStunFrames,
  AnimKey.run: _unocoAnimMoveFrames,
  AnimKey.hit: _unocoAnimHitFrames,
  AnimKey.death: _unocoAnimDeathFrames,
};

const Map<AnimKey, double> _unocoAnimStepTimeSecondsByKey = <AnimKey, double>{
  AnimKey.idle: _unocoAnimIdleStepSeconds,
  AnimKey.stun: _unocoAnimStunStepSeconds,
  AnimKey.run: _unocoAnimMoveStepSeconds,
  AnimKey.hit: _unocoAnimHitStepSeconds,
  AnimKey.death: _unocoAnimDeathStepSeconds,
};

const Map<AnimKey, String> _unocoAnimSourcesByKey = <AnimKey, String>{
  AnimKey.idle: 'entities/enemies/unoco/flying.png',
  AnimKey.stun: 'entities/enemies/unoco/stun.png',
  AnimKey.run: 'entities/enemies/unoco/flying.png',
  AnimKey.hit: 'entities/enemies/unoco/hit.png',
  AnimKey.death: 'entities/enemies/unoco/death.png',
};

const RenderAnimSetDefinition _unocoRenderAnim = RenderAnimSetDefinition(
  frameWidth: _unocoAnimFrameWidth,
  frameHeight: _unocoAnimFrameHeight,
  sourcesByKey: _unocoAnimSourcesByKey,
  frameCountsByKey: _unocoAnimFrameCountsByKey,
  stepTimeSecondsByKey: _unocoAnimStepTimeSecondsByKey,
);

const AnimProfile _unocoAnimProfile = AnimProfile(
  minMoveSpeed: 1.0,
  runSpeedThresholdX: 0.0,
  supportsWalk: false,
  supportsJumpFall: false,
  supportsStun: true,
  strikeAnimKey: AnimKey.idle,
);

// -----------------------------------------------------------------------------
// grojib (ground enemy) render animation sheet definitions (authoring-time)
// -----------------------------------------------------------------------------

const int _grojibAnimFrameWidth = 108;
const int _grojibAnimFrameHeight = 59;

const int _grojibAnimIdleFrames = 8;
const double _grojibAnimIdleStepSeconds = 0.14;

const int _grojibAnimStunFrames = 8;
const double _grojibAnimStunStepSeconds = 0.14;

const int _grojibAnimMoveFrames = 8;
const double _grojibAnimMoveStepSeconds = 0.08;

const int _grojibAnimWalkFrames = _grojibAnimMoveFrames;
const double _grojibAnimWalkStepSeconds = _grojibAnimMoveStepSeconds;

const int _grojibAnimHitFrames = 3;
const double _grojibAnimHitStepSeconds = 0.10;

const int _grojibAnimDeathFrames = 12;
const double _grojibAnimDeathStepSeconds = 0.12;

// The authored sheet has 20 columns on the strike row:
// - frames 1..8  = Strike
// - frames 9..20 = Strike2
// Core only exposes AnimKey.strike, so we treat the full row as one animation.
const int _grojibAnimStrikeFrames = 8;
const double _grojibAnimStrikeStepSeconds = 0.06;

const int _grojibAnimJumpFrames = 3;
const double _grojibAnimJumpStepSeconds = 0.10;

const int _grojibAnimFallFrames = 3;
const double _grojibAnimFallStepSeconds = 0.10;
const double _grojibHitAnimSeconds =
    _grojibAnimHitFrames * _grojibAnimHitStepSeconds;
const double _grojibDeathAnimSeconds =
    _grojibAnimDeathFrames * _grojibAnimDeathStepSeconds;

const Map<AnimKey, int> _grojibAnimFrameCountsByKey = <AnimKey, int>{
  AnimKey.idle: _grojibAnimIdleFrames,
  AnimKey.stun: _grojibAnimStunFrames,
  AnimKey.run: _grojibAnimMoveFrames,
  AnimKey.walk: _grojibAnimWalkFrames,
  AnimKey.strike: _grojibAnimStrikeFrames,
  AnimKey.hit: _grojibAnimHitFrames,
  AnimKey.death: _grojibAnimDeathFrames,
  AnimKey.jump: _grojibAnimJumpFrames,
  AnimKey.fall: _grojibAnimFallFrames,
};

const Map<AnimKey, double> _grojibAnimStepTimeSecondsByKey = <AnimKey, double>{
  AnimKey.idle: _grojibAnimIdleStepSeconds,
  AnimKey.stun: _grojibAnimStunStepSeconds,
  AnimKey.run: _grojibAnimMoveStepSeconds,
  AnimKey.walk: _grojibAnimWalkStepSeconds,
  AnimKey.strike: _grojibAnimStrikeStepSeconds,
  AnimKey.hit: _grojibAnimHitStepSeconds,
  AnimKey.death: _grojibAnimDeathStepSeconds,
  AnimKey.jump: _grojibAnimJumpStepSeconds,
  AnimKey.fall: _grojibAnimFallStepSeconds,
};

const String _grojibAnimSpriteSheetPath = 'entities/enemies/grojib/grojib.png';

const Map<AnimKey, String> _grojibAnimSourcesByKey = <AnimKey, String>{
  AnimKey.idle: _grojibAnimSpriteSheetPath,
  AnimKey.stun: _grojibAnimSpriteSheetPath,
  AnimKey.run: _grojibAnimSpriteSheetPath,
  AnimKey.walk: _grojibAnimSpriteSheetPath,
  AnimKey.strike: _grojibAnimSpriteSheetPath,
  AnimKey.hit: _grojibAnimSpriteSheetPath,
  AnimKey.death: _grojibAnimSpriteSheetPath,
  AnimKey.jump: _grojibAnimSpriteSheetPath,
  AnimKey.fall: _grojibAnimSpriteSheetPath,
};

const Map<AnimKey, int> _grojibAnimRowByKey = <AnimKey, int>{
  AnimKey.idle: 0,
  AnimKey.stun: 0,
  AnimKey.run: 1,
  AnimKey.walk: 1,
  AnimKey.strike: 2,
  AnimKey.hit: 3,
  AnimKey.death: 4,
  AnimKey.jump: 5,
  AnimKey.fall: 7,
};

const RenderAnimSetDefinition _grojibRenderAnim = RenderAnimSetDefinition(
  frameWidth: _grojibAnimFrameWidth,
  frameHeight: _grojibAnimFrameHeight,
  sourcesByKey: _grojibAnimSourcesByKey,
  rowByKey: _grojibAnimRowByKey,
  anchorInFramePx: Vec2(77, _grojibAnimFrameHeight * 0.5),
  frameCountsByKey: _grojibAnimFrameCountsByKey,
  stepTimeSecondsByKey: _grojibAnimStepTimeSecondsByKey,
);

const AnimProfile _grojibAnimProfile = AnimProfile(
  minMoveSpeed: 1.0,
  runSpeedThresholdX: 120.0,
  supportsStun: true,
);

/// Defines the base stats and physics properties for an enemy type.
///
/// This data is "static" (read-only) configuration used to initialize
/// the ECS components effectively when an enemy spawns.
class EnemyArchetype {
  const EnemyArchetype({
    required this.body,
    required this.collider,
    required this.health,
    required this.mana,
    required this.stamina,
    required this.renderAnim,
    required this.animProfile,
    required this.hitAnimSeconds,
    required this.deathAnimSeconds,
    this.deathBehavior = DeathBehavior.instant,
    this.primaryProjectileId,
    this.artFacingDir = Facing.left,
    this.tags = const CreatureTagDef(),
    this.resistance = const DamageResistanceDef(),
    this.statusImmunity = const StatusImmunityDef(),
  });

  /// Physics configuration (Gravity, Constraints, Kinematics).
  final BodyDef body;

  /// Hitbox size (Collision).
  final ColliderAabbDef collider;

  /// Vitals (HP, Mana, Stamina) configuration.
  final HealthDef health;
  final ManaDef mana;
  final StaminaDef stamina;

  /// Render-only animation metadata (strip paths, frame size, timing).
  final RenderAnimSetDefinition renderAnim;

  /// Core animation profile (movement thresholds and supported keys).
  final AnimProfile animProfile;

  /// Duration the hit animation should be visible (seconds).
  final double hitAnimSeconds;

  /// Duration the death animation should be visible (seconds).
  final double deathAnimSeconds;

  /// Behavior for death transition timing (instant vs ground impact).
  final DeathBehavior deathBehavior;

  /// Optional primary projectile item for this enemy.
  ///
  /// When present, the [EnemyCastSystem] will use this to write projectile intents.
  final ProjectileId? primaryProjectileId;

  /// Direction the authored art faces when not mirrored.
  ///
  /// Most sprites face right by default, but some packs are authored facing
  /// left. The renderer uses this to mirror correctly based on logical [Facing].
  final Facing artFacingDir;

  /// Broad tags used by combat rules and content filters.
  final CreatureTagDef tags;

  /// Resistance/vulnerability modifiers by damage type.
  final DamageResistanceDef resistance;

  /// Status effect immunities for this enemy.
  final StatusImmunityDef statusImmunity;
}

/// Central registry for Enemy Definitions.
///
/// **Usage**:
/// - Accessed by `EnemySpawnSystem` (or similar) to hydration entities.
/// - Decouples "What an enemy is" from "How to spawn it".
class EnemyCatalog {
  const EnemyCatalog();

  /// Returns the static archetype definition for a given [EnemyId].
  ///
  /// Note: The returned objects are `const` and allocation-light.
  EnemyArchetype get(EnemyId id) {
    switch (id) {
      case EnemyId.unocoDemon:
        return const EnemyArchetype(
          body: BodyDef(
            isKinematic: false,
            useGravity: false,
            gravityScale: 0.0,
            sideMask: BodyDef.sideNone,
            maxVelX: 800.0,
            maxVelY: 800.0,
          ),
          collider: ColliderAabbDef(halfX: 12.0, halfY: 12.0),
          health: HealthDef(hp: 2000, hpMax: 2000, regenPerSecond100: 50),
          mana: ManaDef(mana: 8000, manaMax: 8000, regenPerSecond100: 500),
          stamina: StaminaDef(stamina: 0, staminaMax: 0, regenPerSecond100: 0),
          renderAnim: _unocoRenderAnim,
          animProfile: _unocoAnimProfile,
          hitAnimSeconds: _unocoHitAnimSeconds,
          deathAnimSeconds: _unocoDeathAnimSeconds,
          deathBehavior: DeathBehavior.instant,
          primaryProjectileId: ProjectileId.fireBolt,
          artFacingDir: Facing.left,
          tags: CreatureTagDef(
            mask: CreatureTagMask.flying | CreatureTagMask.demon,
          ),
          resistance: DamageResistanceDef(fireBp: -5000, iceBp: 5000),
        );

      case EnemyId.grojib:
        return const EnemyArchetype(
          body: BodyDef(
            isKinematic: false,
            useGravity: true,
            ignoreCeilings: true,
            gravityScale: 1.0,
            sideMask: BodyDef.sideLeft | BodyDef.sideRight,
          ),
          collider: ColliderAabbDef(
            halfX: 25.0,
            halfY: 25.0,
            offsetX: 0.0,
            offsetY: 20.0,
          ),
          health: HealthDef(hp: 2000, hpMax: 2000, regenPerSecond100: 50),
          mana: ManaDef(mana: 0, manaMax: 0, regenPerSecond100: 0),
          stamina: StaminaDef(stamina: 0, staminaMax: 0, regenPerSecond100: 0),
          renderAnim: _grojibRenderAnim,
          animProfile: _grojibAnimProfile,
          hitAnimSeconds: _grojibHitAnimSeconds,
          deathAnimSeconds: _grojibDeathAnimSeconds,
          deathBehavior: DeathBehavior.groundImpactThenDeath,
          tags: CreatureTagDef(mask: CreatureTagMask.humanoid),
        );
    }
  }
}


===== FILE: lib/core/enemies/enemy_id.dart =====
/// Unique identifiers for enemy types.
///
/// **Usage**:
/// - Used for spawning via `SpawnSystem`.
/// - keys for `EnemyCatalog` lookup.
/// - Stable identifiers for networking/snapshots (protocol-stable).
enum EnemyId {
  /// A flying demon enemy that ignores gravity and casts spells.
  unocoDemon,

  /// A basic ground chasing enemy that is affected by gravity.
  grojib,
}



===== FILE: lib/core/enemies/enemy_killed_info.dart =====
library;

import '../snapshots/enums.dart';
import '../util/vec2.dart';
import 'enemy_id.dart';

/// Minimal data captured at the moment an enemy is killed.
///
/// Used to emit render/UI events (e.g. play a death animation) even though the
/// enemy entity is despawned immediately by Core.
class EnemyKilledInfo {
  const EnemyKilledInfo({
    required this.enemyId,
    required this.pos,
    required this.facing,
    required this.artFacingDir,
  });

  final EnemyId enemyId;
  final Vec2 pos;
  final Facing facing;
  final Facing artFacingDir;
}


===== FILE: lib/core/events/ability_events.dart =====
part of 'game_event.dart';

/// Why a hold-to-maintain ability ended automatically.
enum AbilityHoldEndReason {
  /// The authored max hold duration elapsed.
  timeout,

  /// Stamina was depleted while maintaining the hold.
  staminaDepleted,
}

/// Emitted when a hold-to-maintain ability auto-ends.
///
/// UI can use this for feedback (for example, vibration on timeout).
class AbilityHoldEndedEvent extends GameEvent {
  const AbilityHoldEndedEvent({
    required this.tick,
    required this.entity,
    required this.slot,
    required this.abilityId,
    required this.reason,
  });

  /// Simulation tick when the hold ended.
  final int tick;

  /// Entity that owned the hold ability.
  final int entity;

  /// Slot that sourced the ability.
  final AbilitySlot slot;

  /// Ability identifier that ended.
  final AbilityKey abilityId;

  /// Auto-end cause.
  final AbilityHoldEndReason reason;
}

/// Why a charged hold was canceled before commit.
enum AbilityChargeEndReason {
  /// The authored charge hold timeout elapsed.
  timeout,
}

/// Emitted when a charged hold is auto-canceled.
class AbilityChargeEndedEvent extends GameEvent {
  const AbilityChargeEndedEvent({
    required this.tick,
    required this.entity,
    required this.slot,
    required this.abilityId,
    required this.reason,
  });

  /// Simulation tick when the hold was canceled.
  final int tick;

  /// Entity that owned the charge hold.
  final int entity;

  /// Slot that sourced the ability.
  final AbilitySlot slot;

  /// Ability identifier whose hold was canceled.
  final AbilityKey abilityId;

  /// Auto-end cause.
  final AbilityChargeEndReason reason;
}


===== FILE: lib/core/events/enemy_events.dart =====
part of 'game_event.dart';

/// Emitted when an enemy is killed (HP reaches 0 and the entity despawns).
///
/// This exists because Core typically despawns dead enemies immediately, so the
/// renderer would otherwise have no chance to play a death animation.
class EnemyKilledEvent extends GameEvent {
  const EnemyKilledEvent({
    required this.tick,
    required this.enemyId,
    required this.pos,
    required this.facing,
    required this.artFacingDir,
  });

  /// Simulation tick when the kill occurred.
  final int tick;

  final EnemyId enemyId;
  final Vec2 pos;
  final Facing facing;
  final Facing artFacingDir;
}


===== FILE: lib/core/events/entity_visual_cue_coalescer.dart =====
import '../combat/damage_type.dart';
import '../combat/status/status.dart';
import '../ecs/entity_id.dart';
import 'game_event.dart';

/// Per-tick coalescer for entity visual cues.
///
/// This avoids render spam when multiple impacts resolve in the same tick by
/// keeping only one cue per `(entity, kind)` pair using the highest intensity.
class EntityVisualCueCoalescer {
  int _tick = -1;
  final Map<int, _EntityVisualCueAggregate> _byKey =
      <int, _EntityVisualCueAggregate>{};

  /// Starts a new aggregation window for [tick].
  void resetForTick(int tick) {
    _tick = tick;
    _byKey.clear();
  }

  /// Records a cue candidate for the active tick.
  void record({
    required int tick,
    required EntityId entityId,
    required EntityVisualCueKind kind,
    required int intensityBp,
    DamageType? damageType,
    StatusResourceType? resourceType,
  }) {
    if (_tick != tick) return;
    if (intensityBp <= 0) return;

    final key = _aggregateKey(entityId, kind);
    final existing = _byKey[key];
    if (existing == null) {
      _byKey[key] = _EntityVisualCueAggregate(
        entityId: entityId,
        kind: kind,
        intensityBp: intensityBp,
        damageType: damageType,
        resourceType: resourceType,
      );
      return;
    }

    if (intensityBp > existing.intensityBp) {
      existing.intensityBp = intensityBp;
      existing.damageType = damageType;
      existing.resourceType = resourceType;
    }
  }

  /// Emits coalesced events for the current tick.
  void emit(void Function(EntityVisualCueEvent event) sink) {
    if (_byKey.isEmpty) return;
    for (final aggregate in _byKey.values) {
      sink(
        EntityVisualCueEvent(
          tick: _tick,
          entityId: aggregate.entityId,
          kind: aggregate.kind,
          intensityBp: aggregate.intensityBp,
          damageType: aggregate.damageType,
          resourceType: aggregate.resourceType,
        ),
      );
    }
  }

  int _aggregateKey(int entityId, EntityVisualCueKind kind) {
    return (entityId << 3) ^ kind.index;
  }
}

class _EntityVisualCueAggregate {
  _EntityVisualCueAggregate({
    required this.entityId,
    required this.kind,
    required this.intensityBp,
    required this.damageType,
    required this.resourceType,
  });

  final int entityId;
  final EntityVisualCueKind kind;
  int intensityBp;
  DamageType? damageType;
  StatusResourceType? resourceType;
}


===== FILE: lib/core/events/feedback_events.dart =====
part of 'game_event.dart';

/// Emitted when the player takes a direct combat impact.
///
/// This event is intended for non-authoritative render/UI feedback (camera
/// shake, haptics, edge flash). It is not emitted for status-effect ticks.
class PlayerImpactFeedbackEvent extends GameEvent {
  const PlayerImpactFeedbackEvent({
    required this.tick,
    required this.amount100,
    required this.sourceKind,
  });

  /// Simulation tick when the impact occurred.
  final int tick;

  /// Final damage applied to the player in fixed-point units (`100 == 1.0`).
  final int amount100;

  /// Source category that produced the impact.
  final DeathSourceKind sourceKind;
}

/// Visual pulse categories consumed by the render layer.
enum EntityVisualCueKind { directHit, dotPulse, resourcePulse }

/// Coalesced, per-entity visual pulse emitted by Core.
///
/// This event is render-only and intentionally does not encode style (colors,
/// shader choice). The Game layer maps these semantics to visuals.
class EntityVisualCueEvent extends GameEvent {
  const EntityVisualCueEvent({
    required this.tick,
    required this.entityId,
    required this.kind,
    required this.intensityBp,
    this.damageType,
    this.resourceType,
  });

  /// Simulation tick when the cue was produced.
  final int tick;

  /// Entity receiving the visual cue.
  final int entityId;

  /// Cue semantics (hit pulse vs DoT pulse vs RoT pulse).
  final EntityVisualCueKind kind;

  /// Relative strength in basis points (`10000 == 1.0`).
  final int intensityBp;

  /// Damage type metadata for DoT pulses (optional).
  final DamageType? damageType;

  /// Resource type metadata for resource pulses (optional).
  final StatusResourceType? resourceType;
}


===== FILE: lib/core/events/game_event.dart =====
/// Core -> Render/UI event model.
///
/// **Architecture**:
/// - "Events" in this context are **transient side effects** emitted by the simulation.
/// - Examples: SFX triggers, Particle spawns, Run completion, Screen shake.
/// - They are distinct from "State" (Snapshots). State is continuous; Events are discrete.
///
/// **Usage**:
/// - Systems emit events into a queue.
/// - The GameController or UI layer consumes them (e.g., to play a sound or show a dialog).
/// - Events are fire-and-forget.
library;

import '../abilities/ability_def.dart';
import '../combat/damage_type.dart';
import '../combat/status/status.dart';
import '../enemies/enemy_id.dart';
import '../projectiles/projectile_id.dart';
import '../snapshots/enums.dart';
import '../util/vec2.dart';

part 'run_events.dart';
part 'enemy_events.dart';
part 'projectile_events.dart';
part 'ability_events.dart';
part 'feedback_events.dart';

/// Base sealed class for all simulation events.
sealed class GameEvent {
  const GameEvent();
}


===== FILE: lib/core/events/player_impact_feedback_gate.dart =====
import 'game_event.dart';

/// Coalesces and throttles player impact feedback events.
///
/// Rules:
/// - Only direct impacts should be recorded (status effect ticks are ignored).
/// - Multiple direct impacts in the same tick are coalesced into one event.
/// - At most one event can be emitted per second (`tickHz` ticks).
class PlayerImpactFeedbackGate {
  PlayerImpactFeedbackGate({required this.tickHz})
    : assert(tickHz > 0, 'tickHz must be > 0');

  final int tickHz;

  int _nextAllowedTick = 0;
  int _pendingTick = -1;
  int _pendingAmount100 = 0;
  DeathSourceKind _pendingSourceKind = DeathSourceKind.unknown;

  /// Records a damage application candidate for this tick.
  void recordAppliedDamage({
    required int tick,
    required bool playerTarget,
    required int appliedAmount100,
    required DeathSourceKind sourceKind,
  }) {
    if (!playerTarget) return;
    if (appliedAmount100 <= 0) return;
    if (sourceKind == DeathSourceKind.statusEffect) return;
    if (tick < _nextAllowedTick) return;

    if (_pendingTick != tick) {
      _pendingTick = tick;
      _pendingAmount100 = appliedAmount100;
      _pendingSourceKind = sourceKind;
      return;
    }

    if (appliedAmount100 > _pendingAmount100) {
      _pendingAmount100 = appliedAmount100;
      _pendingSourceKind = sourceKind;
    }
  }

  /// Emits the coalesced event for [tick], if any.
  PlayerImpactFeedbackEvent? flushTick(int tick) {
    if (_pendingTick != tick) return null;

    final event = PlayerImpactFeedbackEvent(
      tick: tick,
      amount100: _pendingAmount100,
      sourceKind: _pendingSourceKind,
    );
    _nextAllowedTick = tick + tickHz;
    _clearPending();
    return event;
  }

  void _clearPending() {
    _pendingTick = -1;
    _pendingAmount100 = 0;
    _pendingSourceKind = DeathSourceKind.unknown;
  }
}


===== FILE: lib/core/events/projectile_events.dart =====
part of 'game_event.dart';

/// Emitted when a projectile hits a damageable target.
///
/// Used by the renderer to spawn impact VFX even though the projectile entity
/// is despawned immediately in Core.
class ProjectileHitEvent extends GameEvent {
  const ProjectileHitEvent({
    required this.tick,
    required this.projectileId,
    required this.pos,
    required this.facing,
    required this.rotationRad,
    this.sourceProjectileId,
  });

  /// Simulation tick when the hit occurred.
  final int tick;

  final ProjectileId projectileId;
  final ProjectileId? sourceProjectileId;
  final Vec2 pos;
  final Facing facing;
  final double rotationRad;
}


===== FILE: lib/core/events/run_events.dart =====
part of 'game_event.dart';

/// The specific cause for a run ending.
enum RunEndReason {
  /// Player was too slow and scrolled off the screen.
  fellBehindCamera,

  /// Player fell into a death pit.
  fellIntoGap,

  /// HP reached 0 (combat death).
  playerDied,

  /// User manually exited the run.
  gaveUp,
}

/// Identifies the category of damage source that caused death.
enum DeathSourceKind { projectile, meleeHitbox, statusEffect, unknown }

/// Detailed context about what killed the player.
class DeathInfo {
  const DeathInfo({
    required this.kind,
    this.enemyId,
    this.projectileId,
    this.sourceProjectileId,
  });

  /// Category of the damage source.
  final DeathSourceKind kind;

  /// The [EnemyId] responsible (if applicable).
  final EnemyId? enemyId;

  /// The [ProjectileId] responsible (if applicable).
  final ProjectileId? projectileId;

  /// The [ProjectileId] responsible (if applicable).
  final ProjectileId? sourceProjectileId;
}

/// Aggregate statistics collected during a run.
class RunEndStats {
  const RunEndStats({
    required this.collectibles,
    required this.collectibleScore,
    required this.enemyKillCounts,
  });

  /// Total count of collectibles picked up.
  final int collectibles;

  /// Total score value of collectibles.
  final int collectibleScore;

  /// Kill counts per enemy type.
  ///
  /// **Ordering**: Indices strictly align with [EnemyId.values].
  /// `enemyKillCounts[i]` corresponds to the kills for the enemy at `EnemyId.values[i]`.
  final List<int> enemyKillCounts;
}

/// Event emitted when the game session terminates.
///
/// Contains all necessary data to display the "Game Over" screen.
class RunEndedEvent extends GameEvent {
  const RunEndedEvent({
    required this.runId,
    required this.tick,
    required this.distance,
    required this.reason,
    required this.stats,
    required this.goldEarned,
    this.deathInfo,
  });

  /// Unique identifier for this run session.
  final int runId;

  /// The tick on which the run ended.
  final int tick;

  /// Total distance traveled (meters/pixels).
  final double distance;

  /// Why the run ended (Death vs GiveUp).
  final RunEndReason reason;

  /// Performance stats.
  final RunEndStats stats;

  /// Gold earned for this run (derived from run stats).
  final int goldEarned;

  /// Details on the lethal hit (if applicable).
  final DeathInfo? deathInfo;
}


===== FILE: lib/core/game_core.dart =====
/// Authoritative, deterministic simulation layer (pure Dart).
///
/// This is the heart of the game—a pure Dart simulation that processes
/// tick-stamped commands, advances physics and AI, and produces immutable
/// snapshots for the renderer/UI. By keeping this layer Flutter/Flame-free,
/// we gain:
/// - **Testability**: Unit tests can run headless at any tick rate.
/// - **Determinism**: Same seed + commands = identical simulation.
/// - **Portability**: Core logic could run on a server for validation.
///
/// ## Architecture Overview
///
/// ```
/// Commands (from input layer)
///         ↓
///    GameCore.applyCommands()
///         ↓
///    GameCore.stepOneTick()
///         ↓
///    [Track streaming → Physics → AI → Combat → Cleanup]
///         ↓
///    GameStateSnapshot (to render layer)
/// ```
///
/// ## Module Dependencies
///
/// [GameCore] orchestrates three extracted modules:
/// - [TrackManager]: Procedural chunk generation, geometry lifecycle.
/// - [SpawnService]: Deterministic entity spawning (enemies, items).
/// - [SnapshotBuilder]: ECS → render snapshot conversion.
///
/// ## ECS System Execution Order
///
/// Systems run in a carefully ordered pipeline each tick:
/// 1. **Track streaming**: Spawn/cull chunks based on camera.
/// 2. **Cooldowns & invulnerability**: Decrement timers.
/// 3. **Enemy AI steering**: Path planning and movement intent.
/// 4. **Player input**: Resolve ability intents (including mobility).
/// 5. **Jump execution**: Apply coyote/buffer/air-jump rules.
/// 6. **Player movement**: Apply horizontal input to velocity.
/// 7. **Mobility execution**: Apply dash/roll state.
/// 8. **Gravity**: Apply gravity to non-kinematic bodies.
/// 9. **Collision**: Resolve static world collisions.
/// 10. **Pickups**: Collect items overlapping player.
/// 11. **Broadphase rebuild**: Update spatial grid for hit detection.
/// 12. **Projectile movement**: Advance existing projectiles.
/// 13. **Strike intents**: Enemies and player queue strikes.
/// 14. **Strike execution**: Spawn hitboxes/projectiles/self abilities.
/// 15. **Hitbox positioning**: Follow owner entities.
/// 16. **Hit resolution**: Detect overlaps, queue damage.
/// 17. **Mobility impacts**: Apply overlap effects from active mobility.
/// 18. **Status ticking**: Apply DoT ticks and queue damage.
/// 19. **Damage middleware**: Apply combat rule edits/cancellations.
/// 20. **Damage application**: Apply queued damage, set invulnerability.
/// 21. **Status application**: Apply on-hit status profiles.
/// 22. **Death handling**: Despawn dead entities, record kills.
/// 23. **Resource regen**: Regenerate mana/stamina.
/// 24. **Lifetime cleanup**: Remove expired entities.
///
/// ## Determinism Contract
///
/// Given identical inputs:
/// - Same [seed] parameter
/// - Same sequence of [Command]s with same tick stamps
/// - Same [tickHz]
///
/// The simulation will produce identical results across runs and platforms.
/// This is achieved by:
/// - Using [DeterministicRng] instead of `dart:math Random`
/// - Fixed-point-style tick math (no frame-rate-dependent dt accumulation)
/// - Deterministic iteration order (entity IDs, not hash-based)
library;

import 'dart:math';

import 'camera/autoscroll_camera.dart';
import 'abilities/ability_catalog.dart';
import 'abilities/ability_def.dart';
import 'abilities/forced_interrupt_policy.dart';
import 'accessories/accessory_catalog.dart';
import 'combat/middleware/parry_middleware.dart';
import 'combat/damage_type.dart';
import 'combat/status/status.dart';
import 'collision/static_world_geometry_index.dart';
import 'commands/command.dart';
import 'contracts/render_contract.dart';
import 'ecs/entity_factory.dart';
import 'ecs/entity_id.dart';
import 'ecs/spatial/broadphase_grid.dart';
import 'ecs/spatial/grid_index_2d.dart';
import 'ecs/stores/restoration_item_store.dart';
import 'ecs/stores/body_store.dart';
import 'ecs/systems/collectible_system.dart';
import 'ecs/systems/collision_system.dart';
import 'ecs/systems/cooldown_system.dart';
import 'ecs/systems/damage_middleware_system.dart';
import 'ecs/systems/damage_system.dart';
import 'ecs/systems/active_ability_phase_system.dart';
import 'ecs/systems/ability_charge_tracking_system.dart';
import 'ecs/systems/death_despawn_system.dart';
import 'ecs/systems/enemy_cast_system.dart';
import 'ecs/systems/enemy_death_state_system.dart';
import 'ecs/systems/enemy_engagement_system.dart';
import 'ecs/systems/flying_enemy_locomotion_system.dart';
import 'ecs/systems/ground_enemy_locomotion_system.dart';
import 'ecs/systems/enemy_navigation_system.dart';
import 'ecs/systems/gravity_system.dart';
import 'ecs/systems/health_despawn_system.dart';
import 'ecs/systems/hitbox_damage_system.dart';
import 'ecs/systems/hitbox_follow_owner_system.dart';
import 'ecs/systems/invulnerability_system.dart';
import 'ecs/systems/lifetime_system.dart';
import 'ecs/systems/melee_strike_system.dart';
import 'ecs/systems/ability_activation_system.dart';
import 'ecs/systems/hold_ability_system.dart';
import 'ecs/systems/mobility_system.dart';
import 'ecs/systems/mobility_impact_system.dart';
import 'ecs/systems/player_movement_system.dart';
import 'ecs/systems/jump_system.dart';
import 'ecs/systems/projectile_hit_system.dart';
import 'ecs/systems/projectile_system.dart';
import 'ecs/systems/projectile_world_collision_system.dart';
import 'ecs/systems/projectile_launch_system.dart';
import 'ecs/systems/resource_regen_system.dart';
import 'ecs/systems/restoration_item_system.dart';
import 'ecs/systems/self_ability_system.dart';
import 'ecs/systems/status_system.dart';
import 'ecs/systems/control_lock_system.dart';
import 'ecs/systems/anim/anim_system.dart';
import 'ecs/systems/enemy_cull_system.dart';
import 'ecs/systems/enemy_melee_system.dart';
import 'ecs/world.dart';
import 'enemies/enemy_catalog.dart';
import 'enemies/death_behavior.dart';
import 'enemies/enemy_id.dart';
import 'events/game_event.dart';
import 'events/entity_visual_cue_coalescer.dart';
import 'events/player_impact_feedback_gate.dart';
import 'levels/level_definition.dart';
import 'levels/level_id.dart';
import 'navigation/surface_graph_builder.dart';
import 'navigation/surface_navigator.dart';
import 'navigation/surface_pathfinder.dart';
import 'navigation/utils/jump_template.dart';
import 'navigation/utils/trajectory_predictor.dart';
import 'players/player_catalog.dart';
import 'players/player_character_definition.dart';
import 'projectiles/projectile_catalog.dart';
import 'spellBook/spell_book_catalog.dart';
import 'snapshots/enums.dart';
import 'snapshots/camera_snapshot.dart';
import 'snapshots/game_state_snapshot.dart';
import 'snapshot_builder.dart';
import 'loadout/loadout_validator.dart';
import 'spawn_service.dart';
import 'progression/run_rewards.dart';
import 'track_manager.dart';
import 'weapons/weapon_catalog.dart';
import 'stats/character_stats_resolver.dart';
import 'stats/resolved_stats_cache.dart';
import 'ecs/stores/combat/equipped_loadout_store.dart';
import 'ecs/stores/health_store.dart';
import 'ecs/stores/mana_store.dart';
import 'ecs/stores/stamina_store.dart';
import 'tuning/camera_tuning.dart';
import 'tuning/collectible_tuning.dart';
import 'tuning/flying_enemy_tuning.dart';
import 'tuning/ground_enemy_tuning.dart';
import 'tuning/navigation_tuning.dart';
import 'tuning/physics_tuning.dart';
import 'players/player_tuning.dart';
import 'tuning/restoration_item_tuning.dart';
import 'tuning/score_tuning.dart';
import 'tuning/spatial_grid_tuning.dart';
import 'tuning/track_tuning.dart';
import 'util/tick_math.dart';

// ─────────────────────────────────────────────────────────────────────────────
// GameCore - Main simulation coordinator
// ─────────────────────────────────────────────────────────────────────────────

/// Deterministic game simulation core.
///
/// This class is the central coordinator for the game simulation. It:
/// - Owns the [EcsWorld] and all ECS systems.
/// - Processes player [Command]s each tick.
/// - Steps physics, AI, and combat systems in order.
/// - Produces [GameStateSnapshot]s for the render layer.
/// - Emits [GameEvent]s for UI feedback (run ended, etc.).
class GameCore {
  /// Creates a new game simulation with the given configuration.
  ///
  /// Parameters:
  /// - [seed]: Master RNG seed for deterministic generation.
  /// - [runId]: Unique identifier for this run session (replay/ghost).
  /// - [tickHz]: Fixed tick rate (default 60). Higher = smoother but more CPU.
  /// - [levelDefinition]: Selected level configuration (required).
  /// - Catalogs: Entity archetype definitions (spells, enemies, etc.).
  GameCore({
    required int seed,
    int runId = 0,
    int tickHz = defaultTickHz,
    required LevelDefinition levelDefinition,
    required PlayerCharacterDefinition playerCharacter,
    EquippedLoadoutDef? equippedLoadoutOverride,
    ProjectileCatalog projectileCatalog = const ProjectileCatalog(),
    SpellBookCatalog spellBookCatalog = const SpellBookCatalog(),
    EnemyCatalog enemyCatalog = const EnemyCatalog(),
    WeaponCatalog weaponCatalog = const WeaponCatalog(),
    AccessoryCatalog accessoryCatalog = const AccessoryCatalog(),
  }) : this._fromLevel(
         seed: seed,
         runId: runId,
         tickHz: tickHz,
         levelDefinition: levelDefinition,
         projectileCatalog: projectileCatalog,
         spellBookCatalog: spellBookCatalog,
         enemyCatalog: enemyCatalog,
         playerCharacter: playerCharacter,
         weaponCatalog: weaponCatalog,
         accessoryCatalog: accessoryCatalog,
         equippedLoadoutOverride: equippedLoadoutOverride,
       );

  GameCore._fromLevel({
    required this.seed,
    required this.runId,
    required this.tickHz,
    required LevelDefinition levelDefinition,
    required ProjectileCatalog projectileCatalog,
    required SpellBookCatalog spellBookCatalog,
    required EnemyCatalog enemyCatalog,
    required PlayerCharacterDefinition playerCharacter,
    required WeaponCatalog weaponCatalog,
    required AccessoryCatalog accessoryCatalog,
    required EquippedLoadoutDef? equippedLoadoutOverride,
  }) : _levelDefinition = levelDefinition,
       _movement = MovementTuningDerived.from(
         playerCharacter.tuning.movement,
         tickHz: tickHz,
       ),
       _physicsTuning = levelDefinition.tuning.physics,
       _resourceTuning = ResourceTuningDerived.from(
         playerCharacter.tuning.resource,
       ),
       _abilities = AbilityTuningDerived.from(
         playerCharacter.tuning.ability,
         tickHz: tickHz,
       ),
       _animTuning = AnimTuningDerived.from(
         playerCharacter.tuning.anim,
         tickHz: tickHz,
       ),
       _combat = CombatTuningDerived.from(
         playerCharacter.tuning.combat,
         tickHz: tickHz,
       ),
       _unocoDemonTuning = UnocoDemonTuningDerived.from(
         levelDefinition.tuning.unocoDemon,
         tickHz: tickHz,
       ),
       _groundEnemyTuning = GroundEnemyTuningDerived.from(
         levelDefinition.tuning.groundEnemy,
         tickHz: tickHz,
       ),
       _navigationTuning = levelDefinition.tuning.navigation,
       _spatialGridTuning = levelDefinition.tuning.spatialGrid,
       _projectiles = projectileCatalog,
       _spellBooks = spellBookCatalog,
       _enemyCatalog = enemyCatalog,
       _playerCharacter = playerCharacter,
       _weapons = weaponCatalog,
       _accessories = accessoryCatalog,
       _statsResolver = CharacterStatsResolver(
         weapons: weaponCatalog,
         projectiles: projectileCatalog,
         spellBooks: spellBookCatalog,
         accessories: accessoryCatalog,
       ),
       _equippedLoadoutOverride = equippedLoadoutOverride,
       _scoreTuning = levelDefinition.tuning.score,
       _trackTuning = levelDefinition.tuning.track,
       _collectibleTuning = levelDefinition.tuning.collectible,
       _restorationItemTuning = levelDefinition.tuning.restorationItem {
    _initializeWorld(levelDefinition);
  }

  /// Common initialization shared by all constructors.
  void _initializeWorld(LevelDefinition levelDefinition) {
    // ─── Initialize ECS world and entity factory ───
    _world = EcsWorld(seed: seed);
    _entityFactory = EntityFactory(_world);

    // ─── Initialize all ECS systems ───
    _initializeSystems();

    // ─── Initialize autoscrolling camera ───
    _cameraTuning = CameraTuningDerived.from(
      levelDefinition.tuning.camera,
      movement: _movement,
    );
    _camera = AutoscrollCamera(
      viewWidth: virtualWidth.toDouble(),
      viewHeight: virtualHeight.toDouble(),
      tuning: _cameraTuning,
      initial: CameraState(
        centerX: virtualWidth * 0.5,
        targetX: virtualWidth * 0.5,
        centerY: levelDefinition.cameraCenterY,
        targetY: levelDefinition.cameraCenterY,
        speedX: 0.0,
      ),
    );

    // ─── Initialize spawn service (needs ECS + catalogs) ───
    _spawnService = SpawnService(
      world: _world,
      entityFactory: _entityFactory,
      enemyCatalog: _enemyCatalog,
      unocoDemonTuning: _unocoDemonTuning,
      movement: _movement,
      collectibleTuning: _collectibleTuning,
      restorationItemTuning: _restorationItemTuning,
      trackTuning: _trackTuning,
      seed: seed,
    );

    // ─── Spawn player entity (must happen before TrackManager) ───
    final effectiveGroundTopY = levelDefinition.groundTopY;
    _spawnPlayer(effectiveGroundTopY);

    // ─── Initialize track manager (needs player for callbacks) ───
    _trackManager = TrackManager(
      seed: seed,
      trackTuning: _trackTuning,
      collectibleTuning: _collectibleTuning,
      restorationItemTuning: _restorationItemTuning,
      baseGeometry: levelDefinition.staticWorldGeometry,
      surfaceGraphBuilder: _surfaceGraphBuilder,
      jumpTemplate: _groundEnemyJumpTemplate,
      enemyNavigationSystem: _enemyNavigationSystem,
      groundEnemyLocomotionSystem: _groundEnemyLocomotionSystem,
      spawnService: _spawnService,
      groundTopY: effectiveGroundTopY,
      patternPool: levelDefinition.patternPool,
      earlyPatternChunks: levelDefinition.earlyPatternChunks,
      noEnemyChunks: levelDefinition.noEnemyChunks,
    );

    // ─── Initialize snapshot builder (needs player entity ID) ───
    _snapshotBuilder = SnapshotBuilder(
      tickHz: tickHz,
      world: _world,
      player: _player,
      movement: _movement,
      abilities: _abilities,
      resources: _resourceTuning,
      enemyCatalog: _enemyCatalog,
      abilityCatalog: AbilityCatalog.shared,
      weaponCatalog: _weapons,
      projectileCatalog: _projectiles,
      spellBookCatalog: _spellBooks,
      loadoutValidator: LoadoutValidator(
        abilityCatalog: AbilityCatalog.shared,
        weaponCatalog: _weapons,
        projectileCatalog: _projectiles,
        spellBookCatalog: _spellBooks,
      ),
    );
  }

  /// Initializes all ECS systems.
  ///
  /// Systems are stateless processors that operate on component stores.
  /// They're created once at construction and reused every tick.
  void _initializeSystems() {
    const abilityCatalog = AbilityCatalog();
    const forcedInterruptPolicy = ForcedInterruptPolicy(
      abilities: abilityCatalog,
    );
    _resolvedStatsCache = ResolvedStatsCache(resolver: _statsResolver);

    // Core movement and physics.
    _movementSystem = PlayerMovementSystem(
      statsResolver: _statsResolver,
      statsCache: _resolvedStatsCache,
    );
    _jumpSystem = JumpSystem(abilities: abilityCatalog);
    _mobilitySystem = MobilitySystem();
    _collisionSystem = CollisionSystem();
    _cooldownSystem = CooldownSystem();
    _gravitySystem = GravitySystem();

    // Projectile lifecycle.
    _projectileSystem = ProjectileSystem();
    _projectileHitSystem = ProjectileHitSystem();
    _projectileWorldCollisionSystem = ProjectileWorldCollisionSystem();

    // Spatial partitioning for hit detection.
    _broadphaseGrid = BroadphaseGrid(
      index: GridIndex2D(cellSize: _spatialGridTuning.broadphaseCellSize),
    );

    // Hitbox management.
    _hitboxFollowOwnerSystem = HitboxFollowOwnerSystem();
    _lifetimeSystem = LifetimeSystem();

    // Damage pipeline.
    _invulnerabilitySystem = InvulnerabilitySystem();
    _damageMiddlewareSystem = DamageMiddlewareSystem(
      middlewares: [
        ParryMiddleware(
          abilityIds: const <AbilityKey>{
            'eloise.riposte_guard',
            'eloise.aegis_riposte',
            'eloise.shield_block',
          },
        ),
      ],
    );
    _damageSystem = DamageSystem(
      invulnerabilityTicksOnHit: _combat.invulnerabilityTicks,
      rngSeed: seed,
      statsResolver: _statsResolver,
      statsCache: _resolvedStatsCache,
      forcedInterruptPolicy: forcedInterruptPolicy,
    );
    _playerImpactFeedbackGate = PlayerImpactFeedbackGate(tickHz: tickHz);
    _entityVisualCueCoalescer = EntityVisualCueCoalescer();
    _statusSystem = StatusSystem(
      tickHz: tickHz,
      statsResolver: _statsResolver,
      statsCache: _resolvedStatsCache,
    );
    _controlLockSystem = ControlLockSystem();
    _activeAbilityPhaseSystem = ActiveAbilityPhaseSystem(
      forcedInterruptPolicy: forcedInterruptPolicy,
    );
    _abilityChargeTrackingSystem = AbilityChargeTrackingSystem(
      tickHz: tickHz,
      abilities: abilityCatalog,
    );
    _holdAbilitySystem = HoldAbilitySystem(
      tickHz: tickHz,
      abilities: abilityCatalog,
    );
    _healthDespawnSystem = HealthDespawnSystem();
    _enemyDeathStateSystem = EnemyDeathStateSystem(
      tickHz: tickHz,
      enemyCatalog: _enemyCatalog,
    );
    _deathDespawnSystem = DeathDespawnSystem();
    _enemyCullSystem = EnemyCullSystem();
    _animSystem = AnimSystem(
      tickHz: tickHz,
      enemyCatalog: _enemyCatalog,
      playerMovement: _movement,
      playerAnimTuning: _animTuning,
      abilities: abilityCatalog,
    );

    // Player combat (input → intents).
    _abilityActivationSystem = AbilityActivationSystem(
      tickHz: tickHz,
      inputBufferTicks: _abilities.inputBufferTicks,
      abilities: abilityCatalog,
      weapons: _weapons,
      projectiles: _projectiles,
      spellBooks: _spellBooks,
      accessories: _accessories,
      statsCache: _resolvedStatsCache,
    );
    _mobilityImpactSystem = MobilityImpactSystem(abilities: abilityCatalog);
    _hitboxDamageSystem = HitboxDamageSystem();

    // Pickup systems.
    _collectibleSystem = CollectibleSystem();
    _restorationItemSystem = RestorationItemSystem();
    _resourceRegenSystem = ResourceRegenSystem(tickHz: tickHz);

    // Projectile execution.
    _projectileLaunchSystem = ProjectileLaunchSystem(
      projectiles: _projectiles,
      tickHz: tickHz,
    );
    _selfAbilitySystem = SelfAbilitySystem();
    _meleeStrikeSystem = MeleeStrikeSystem();

    // Navigation infrastructure.
    _surfaceGraphBuilder = SurfaceGraphBuilder(
      surfaceGrid: GridIndex2D(cellSize: _spatialGridTuning.broadphaseCellSize),
      takeoffSampleMaxStep: _navigationTuning.takeoffSampleMaxStep,
    );
    final groundEnemyArchetype = _enemyCatalog.get(EnemyId.grojib);
    _groundEnemyJumpTemplate = JumpReachabilityTemplate.build(
      JumpProfile(
        jumpSpeed: _groundEnemyTuning.locomotion.jumpSpeed,
        gravityY: _physicsTuning.gravityY,
        maxAirTicks: _groundEnemyMaxAirTicks(),
        airSpeedX: _groundEnemyTuning.locomotion.speedX,
        dtSeconds: _movement.dtSeconds,
        agentHalfWidth: groundEnemyArchetype.collider.halfX,
        agentHalfHeight: groundEnemyArchetype.collider.halfY,
        collideCeilings: !groundEnemyArchetype.body.ignoreCeilings,
        collideLeftWalls:
            (groundEnemyArchetype.body.sideMask & BodyDef.sideLeft) != 0,
        collideRightWalls:
            (groundEnemyArchetype.body.sideMask & BodyDef.sideRight) != 0,
      ),
    );
    _surfacePathfinder = SurfacePathfinder(
      maxExpandedNodes: _navigationTuning.maxExpandedNodes,
      runSpeedX: _groundEnemyTuning.locomotion.speedX,
      edgePenaltySeconds: _navigationTuning.edgePenaltySeconds,
    );
    _surfaceNavigator = SurfaceNavigator(
      pathfinder: _surfacePathfinder,
      repathCooldownTicks: _navigationTuning.repathCooldownTicks,
      surfaceEps: _navigationTuning.surfaceEps,
      takeoffEps: max(
        _navigationTuning.takeoffEpsMin,
        _groundEnemyTuning.locomotion.stopDistanceX,
      ),
    );

    _enemyNavigationSystem = EnemyNavigationSystem(
      surfaceNavigator: _surfaceNavigator,
      trajectoryPredictor: TrajectoryPredictor(
        gravityY: _physicsTuning.gravityY,
        dtSeconds: _movement.dtSeconds,
        maxTicks: 120,
      ),
      chaseTargetDelayTicks:
          _groundEnemyTuning.navigation.chaseTargetDelayTicks,
    );
    _enemyEngagementSystem = EnemyEngagementSystem(
      groundEnemyTuning: _groundEnemyTuning,
    );
    _groundEnemyLocomotionSystem = GroundEnemyLocomotionSystem(
      groundEnemyTuning: _groundEnemyTuning,
    );
    _flyingEnemyLocomotionSystem = FlyingEnemyLocomotionSystem(
      unocoDemonTuning: _unocoDemonTuning,
    );
    _enemyCastSystem = EnemyCastSystem(
      unocoDemonTuning: _unocoDemonTuning,
      enemyCatalog: _enemyCatalog,
      projectiles: _projectiles,
      abilities: abilityCatalog,
    );
    _enemyMeleeSystem = EnemyMeleeSystem(groundEnemyTuning: _groundEnemyTuning);
  }

  /// Spawns the player entity at the start of a run.
  ///
  /// The player is positioned at [TrackTuning.playerStartX], standing on the
  /// ground. This must be called before [TrackManager] is created because
  /// track manager callbacks reference the player entity.
  void _spawnPlayer(double groundTopY) {
    _playerSpawnStartTick = tick;
    _playerDeathPhase = DeathPhase.none;
    _playerDeathStartTick = -1;

    final spawnX = _trackTuning.playerStartX;
    final playerArchetype = PlayerCatalogDerived.from(
      _playerCharacter.catalog,
      movement: _movement,
      resources: _resourceTuning,
    ).archetype;
    final playerCollider = playerArchetype.collider;

    // Position so collider bottom touches ground.
    final spawnY = groundTopY - (playerCollider.offsetY + playerCollider.halfY);
    final equippedLoadout =
        _equippedLoadoutOverride ??
        EquippedLoadoutDef(
          mask: playerArchetype.loadoutSlotMask,
          mainWeaponId: playerArchetype.weaponId,
          offhandWeaponId: playerArchetype.offhandWeaponId,
          projectileId: playerArchetype.projectileId,
          spellBookId: playerArchetype.spellBookId,
          projectileSlotSpellId: playerArchetype.projectileSlotSpellId,
          abilityPrimaryId: playerArchetype.abilityPrimaryId,
          abilitySecondaryId: playerArchetype.abilitySecondaryId,
          abilityProjectileId: playerArchetype.abilityProjectileId,
          abilitySpellId: playerArchetype.abilitySpellId,
          abilityMobilityId: playerArchetype.abilityMobilityId,
          abilityJumpId: playerArchetype.abilityJumpId,
        );

    final resolvedStats = _statsResolver.resolveLoadout(equippedLoadout);
    final scaledHealth = _scaleHealthDef(playerArchetype.health, resolvedStats);
    final scaledMana = _scaleManaDef(playerArchetype.mana, resolvedStats);
    final scaledStamina = _scaleStaminaDef(
      playerArchetype.stamina,
      resolvedStats,
    );

    _player = _entityFactory.createPlayer(
      posX: spawnX,
      posY: spawnY,
      velX: 0.0,
      velY: 0.0,
      facing: playerArchetype.facing,
      grounded: true,
      body: playerArchetype.body,
      collider: playerCollider,
      health: scaledHealth,
      mana: scaledMana,
      stamina: scaledStamina,
      tags: playerArchetype.tags,
      resistance: playerArchetype.resistance,
      statusImmunity: playerArchetype.statusImmunity,
      equippedLoadout: equippedLoadout,
    );
  }

  HealthDef _scaleHealthDef(HealthDef base, ResolvedCharacterStats stats) {
    final scaledMax = stats.applyHealthMaxBonus(base.hpMax);
    final scaledHp = stats.applyHealthMaxBonus(base.hp);
    return HealthDef(
      hp: scaledHp > scaledMax ? scaledMax : scaledHp,
      hpMax: scaledMax,
      regenPerSecond100: base.regenPerSecond100,
    );
  }

  ManaDef _scaleManaDef(ManaDef base, ResolvedCharacterStats stats) {
    final scaledMax = stats.applyManaMaxBonus(base.manaMax);
    final scaledCurrent = stats.applyManaMaxBonus(base.mana);
    return ManaDef(
      mana: scaledCurrent > scaledMax ? scaledMax : scaledCurrent,
      manaMax: scaledMax,
      regenPerSecond100: base.regenPerSecond100,
    );
  }

  StaminaDef _scaleStaminaDef(StaminaDef base, ResolvedCharacterStats stats) {
    final scaledMax = stats.applyStaminaMaxBonus(base.staminaMax);
    final scaledCurrent = stats.applyStaminaMaxBonus(base.stamina);
    return StaminaDef(
      stamina: scaledCurrent > scaledMax ? scaledMax : scaledCurrent,
      staminaMax: scaledMax,
      regenPerSecond100: base.regenPerSecond100,
    );
  }

  // ─────────────────────────────────────────────────────────────────────────
  // Fields
  // ─────────────────────────────────────────────────────────────────────────

  /// Master RNG seed for deterministic generation.
  ///
  /// The same seed produces identical track layouts, enemy spawns, and

  /// item placements across runs.
  final int seed;

  /// Unique identifier for this run session.
  final int runId;

  /// Fixed simulation tick frequency (ticks per second).
  ///
  /// Higher values = smoother physics but more CPU. Default is 60.
  final int tickHz;

  /// Core level configuration for this run.
  final LevelDefinition _levelDefinition;

  // ─── Derived Tunings ───
  // These are pre-computed from base tunings using tickHz.

  final MovementTuningDerived _movement;
  final PhysicsTuning _physicsTuning;
  final ResourceTuningDerived _resourceTuning;
  final AbilityTuningDerived _abilities;
  final AnimTuningDerived _animTuning;
  final CombatTuningDerived _combat;
  final UnocoDemonTuningDerived _unocoDemonTuning;
  final GroundEnemyTuningDerived _groundEnemyTuning;
  final NavigationTuning _navigationTuning;
  final SpatialGridTuning _spatialGridTuning;
  late final CameraTuningDerived _cameraTuning;
  final ScoreTuning _scoreTuning;
  final TrackTuning _trackTuning;
  final CollectibleTuning _collectibleTuning;
  final RestorationItemTuning _restorationItemTuning;

  // ─── Catalogs ───
  // Archetype definitions for entities.

  final ProjectileCatalog _projectiles;
  final SpellBookCatalog _spellBooks;
  final EnemyCatalog _enemyCatalog;
  final PlayerCharacterDefinition _playerCharacter;
  final WeaponCatalog _weapons;
  final AccessoryCatalog _accessories;
  final CharacterStatsResolver _statsResolver;
  late final ResolvedStatsCache _resolvedStatsCache;
  final EquippedLoadoutDef? _equippedLoadoutOverride;

  // ─── ECS Core ───

  /// The ECS world containing all component stores.
  late final EcsWorld _world;

  /// Factory for creating complex entities (player, enemies).
  late final EntityFactory _entityFactory;

  /// The player entity ID.
  late EntityId _player;

  // Pending game over delay for death animation.
  int _deathAnimTicksLeft = 0;
  RunEndReason? _pendingRunEndReason;
  DeathInfo? _pendingDeathInfo;
  DeathPhase _playerDeathPhase = DeathPhase.none;
  int _playerDeathStartTick = -1;
  int _playerSpawnStartTick = -1;

  // ─── ECS Systems ───
  // Stateless processors that operate on component stores.

  late final PlayerMovementSystem _movementSystem;
  late final JumpSystem _jumpSystem;
  late final MobilitySystem _mobilitySystem;
  late final CollisionSystem _collisionSystem;
  late final CooldownSystem _cooldownSystem;
  late final GravitySystem _gravitySystem;
  late final ProjectileSystem _projectileSystem;
  late final ProjectileHitSystem _projectileHitSystem;
  late final ProjectileWorldCollisionSystem _projectileWorldCollisionSystem;
  late final BroadphaseGrid _broadphaseGrid;
  late final HitboxFollowOwnerSystem _hitboxFollowOwnerSystem;
  late final CollectibleSystem _collectibleSystem;
  late final RestorationItemSystem _restorationItemSystem;
  late final LifetimeSystem _lifetimeSystem;
  late final InvulnerabilitySystem _invulnerabilitySystem;
  late final DamageMiddlewareSystem _damageMiddlewareSystem;
  late final DamageSystem _damageSystem;
  late final StatusSystem _statusSystem;
  late final ControlLockSystem _controlLockSystem;
  late final ActiveAbilityPhaseSystem _activeAbilityPhaseSystem;
  late final AbilityChargeTrackingSystem _abilityChargeTrackingSystem;
  late final HoldAbilitySystem _holdAbilitySystem;
  late final HealthDespawnSystem _healthDespawnSystem;
  late final EnemyDeathStateSystem _enemyDeathStateSystem;
  late final DeathDespawnSystem _deathDespawnSystem;
  late EnemyNavigationSystem _enemyNavigationSystem;
  late EnemyEngagementSystem _enemyEngagementSystem;
  late GroundEnemyLocomotionSystem _groundEnemyLocomotionSystem;
  late FlyingEnemyLocomotionSystem _flyingEnemyLocomotionSystem;
  late EnemyCastSystem _enemyCastSystem;
  late EnemyMeleeSystem _enemyMeleeSystem;
  late final SurfaceGraphBuilder _surfaceGraphBuilder;
  late final JumpReachabilityTemplate _groundEnemyJumpTemplate;
  late final SurfacePathfinder _surfacePathfinder;
  late final SurfaceNavigator _surfaceNavigator;
  late final AbilityActivationSystem _abilityActivationSystem;
  late final SelfAbilitySystem _selfAbilitySystem;
  late final MeleeStrikeSystem _meleeStrikeSystem;
  late final ProjectileLaunchSystem _projectileLaunchSystem;
  late final HitboxDamageSystem _hitboxDamageSystem;
  late final MobilityImpactSystem _mobilityImpactSystem;
  late final ResourceRegenSystem _resourceRegenSystem;
  late final AnimSystem _animSystem;
  late final EnemyCullSystem _enemyCullSystem;

  // ─── Modular Services ───
  // Extracted modules for specific responsibilities.

  /// Entity spawning with deterministic placement.
  late final SpawnService _spawnService;

  /// Track streaming, geometry lifecycle, navigation updates.
  late final TrackManager _trackManager;

  /// ECS → render snapshot conversion.
  late SnapshotBuilder _snapshotBuilder;

  // ─── Camera ───

  /// Autoscrolling camera that follows and pushes the player.
  late final AutoscrollCamera _camera;

  // ─── Event Queue ───

  /// Pending events to be consumed by UI (drained each frame).
  final List<GameEvent> _events = <GameEvent>[];
  late final PlayerImpactFeedbackGate _playerImpactFeedbackGate;
  late final EntityVisualCueCoalescer _entityVisualCueCoalescer;

  // ─── Scratch/Tracking State ───

  /// Scratch list for killed enemies (reused to avoid allocation).
  final List<EnemyId> _killedEnemiesScratch = <EnemyId>[];

  /// Kill counts per enemy type (indexed by [EnemyId.index]).
  final List<int> _enemyKillCounts = List<int>.filled(EnemyId.values.length, 0);

  // ─── Simulation State ───

  /// Current simulation tick (increments each [stepOneTick]).
  int tick = 0;

  /// Whether simulation is paused (commands still apply, time doesn't advance).
  bool paused = false;

  /// Whether the run has ended (simulation is frozen permanently).
  bool gameOver = false;

  /// Total distance traveled (world units, not meters).
  double distance = 0;

  /// Number of collectibles picked up this run.
  int collectibles = 0;

  /// Total score from collectibles.
  int collectibleScore = 0;

  // ─────────────────────────────────────────────────────────────────────────
  // Public Accessors
  // ─────────────────────────────────────────────────────────────────────────

  /// Level identifier for this run (stable across sessions).
  LevelId get levelId => _levelDefinition.id;

  /// Optional render theme identifier for this run.
  String? get themeId => _levelDefinition.themeId;

  /// Score tuning for UI display and leaderboard calculation.
  ScoreTuning get scoreTuning => _scoreTuning;

  /// Enemy catalog for render-side animation loading.
  EnemyCatalog get enemyCatalog => _enemyCatalog;

  /// Current static world geometry (base + streamed chunks).
  StaticWorldGeometry get staticWorldGeometry => _trackManager.staticGeometry;

  /// Player X position in world coordinates.
  double get playerPosX =>
      _world.transform.posX[_world.transform.indexOf(_player)];

  /// Player Y position in world coordinates.
  double get playerPosY =>
      _world.transform.posY[_world.transform.indexOf(_player)];

  /// Sets player position (for tests or teleportation).
  void setPlayerPosXY(double x, double y) =>
      _world.transform.setPosXY(_player, x, y);

  /// Player X velocity (positive = moving right).
  double get playerVelX =>
      _world.transform.velX[_world.transform.indexOf(_player)];

  /// Player Y velocity (positive = moving down).
  double get playerVelY =>
      _world.transform.velY[_world.transform.indexOf(_player)];

  /// Sets player velocity (for tests or knockback effects).
  void setPlayerVelXY(double x, double y) =>
      _world.transform.setVelXY(_player, x, y);

  /// Whether the player is currently on the ground.
  bool get playerGrounded =>
      _world.collision.grounded[_world.collision.indexOf(_player)];

  /// Player facing direction (left or right).
  Facing get playerFacing =>
      _world.movement.facing[_world.movement.indexOf(_player)];

  /// Sets player facing direction.
  set playerFacing(Facing value) {
    _world.movement.facing[_world.movement.indexOf(_player)] = value;
  }

  /// Remaining projectile cooldown ticks.
  /// Remaining projectile cooldown ticks.
  int get playerProjectileCooldownTicksLeft =>
      _world.cooldown.getTicksLeft(_player, CooldownGroup.projectile);

  /// Remaining melee strike cooldown ticks.
  int get playerMeleeCooldownTicksLeft =>
      _world.cooldown.getTicksLeft(_player, CooldownGroup.primary);

  // ─────────────────────────────────────────────────────────────────────────
  // Command Processing
  // ─────────────────────────────────────────────────────────────────────────

  /// Applies all commands scheduled for the current tick.
  ///
  /// Commands are the only way external code can influence the simulation.
  /// Each command type maps to a specific player input flag or value:
  ///
  /// - [MoveAxisCommand]: Sets horizontal movement axis (-1 to 1).
  /// - [JumpPressedCommand]: Triggers a jump attempt.
  /// - [DashPressedCommand]: Triggers a dash attempt.
  /// - [StrikePressedCommand]: Triggers an strike attempt.
  /// - [SecondaryPressedCommand]: Triggers an off-hand ability attempt.
  /// - [AimDirCommand]: Sets global aim direction.
  /// - [ProjectilePressedCommand]: Triggers the projectile slot attempt.
  /// - [SpellPressedCommand]: Triggers a spell-slot ability attempt.
  /// - [AbilitySlotHeldCommand]: Applies per-slot hold transitions for maintain
  ///   abilities (latched until the next transition command).
  ///
  /// Commands are processed before [stepOneTick] to ensure inputs are
  /// available when systems read them.
  void applyCommands(List<Command> commands) {
    // Reset all input flags to their default state.
    _world.playerInput.resetTickInputs(_player);
    final inputIndex = _world.playerInput.indexOf(_player);
    final movementIndex = _world.movement.indexOf(_player);

    for (final command in commands) {
      switch (command) {
        // Movement axis: -1 (left) to +1 (right).
        case MoveAxisCommand(:final axis):
          final clamped = axis.clamp(-1.0, 1.0);
          _world.playerInput.moveAxis[inputIndex] = clamped;
          // Update facing direction unless dashing (locked during dash).
          if (_world.movement.dashTicksLeft[movementIndex] == 0) {
            if (clamped < 0) {
              playerFacing = Facing.left;
            } else if (clamped > 0) {
              playerFacing = Facing.right;
            }
          }

        // Jump: Consumed by AbilityActivationSystem (mobility), executed by JumpSystem.
        case JumpPressedCommand():
          _world.playerInput.jumpPressed[inputIndex] = true;

        // Dash: Consumed by AbilityActivationSystem (mobility).
        case DashPressedCommand():
          _world.playerInput.dashPressed[inputIndex] = true;

        // Strike: Consumed by AbilityActivationSystem.
        case StrikePressedCommand():
          _world.playerInput.strikePressed[inputIndex] = true;
          _world.playerInput.hasAbilitySlotPressed[inputIndex] = true;
          _world.playerInput.lastAbilitySlotPressed[inputIndex] =
              AbilitySlot.primary;

        // Secondary: Consumed by AbilityActivationSystem.
        case SecondaryPressedCommand():
          _world.playerInput.secondaryPressed[inputIndex] = true;
          _world.playerInput.hasAbilitySlotPressed[inputIndex] = true;
          _world.playerInput.lastAbilitySlotPressed[inputIndex] =
              AbilitySlot.secondary;

        // Global aim: shared direction vector for ability commits.
        case AimDirCommand(:final x, :final y):
          _world.playerInput.aimDirX[inputIndex] = x;
          _world.playerInput.aimDirY[inputIndex] = y;

        // Clear aim: resets to no-aim state.
        case ClearAimDirCommand():
          _world.playerInput.aimDirX[inputIndex] = 0;
          _world.playerInput.aimDirY[inputIndex] = 0;

        // Projectile slot: unified input for spells or throws.
        case ProjectilePressedCommand():
          _world.playerInput.projectilePressed[inputIndex] = true;
          _world.playerInput.hasAbilitySlotPressed[inputIndex] = true;
          _world.playerInput.lastAbilitySlotPressed[inputIndex] =
              AbilitySlot.projectile;

        // Spell slot input.
        case SpellPressedCommand():
          _world.playerInput.spellPressed[inputIndex] = true;
          _world.playerInput.hasAbilitySlotPressed[inputIndex] = true;
          _world.playerInput.lastAbilitySlotPressed[inputIndex] =
              AbilitySlot.spell;

        // Per-slot hold transitions (latched until updated).
        case AbilitySlotHeldCommand(:final slot, :final held):
          _world.playerInput.setAbilitySlotHeld(_player, slot, held);
      }
    }
  }

  // ─────────────────────────────────────────────────────────────────────────
  // Simulation Tick
  // ─────────────────────────────────────────────────────────────────────────

  /// Advances the simulation by exactly one fixed tick.
  ///
  /// This is the main simulation loop. It executes all ECS systems in a
  /// carefully ordered pipeline to ensure correct behavior:
  ///
  /// 1. **Track streaming**: Generate/cull chunks, spawn enemies.
  /// 2. **Cooldowns**: Decrement ability and invulnerability timers.
  /// 3. **Enemy AI**: Compute paths and movement intentions.
  /// 4. **Ability upkeep + input**: Maintain hold abilities, then resolve new
  ///    ability intents (including mobility).
  /// 5. **Jump execution**: Apply coyote/buffer/air-jump rules.
  /// 6. **Player movement**: Apply horizontal input to velocity.
  /// 7. **Mobility execution**: Apply dash/roll state.
  /// 8. **Gravity**: Apply gravitational acceleration.
  /// 9. **Collision**: Resolve against static world geometry.
  /// 10. **Death checks**: Detect fall-into-gap and fell-behind-camera.
  /// 11. **Camera update**: Advance autoscroll position.
  /// 12. **Pickups**: Process collectible and restoration item collection.
  /// 13. **Broadphase**: Rebuild spatial grid for hit detection.
  /// 14. **Projectiles**: Move existing projectiles.
  /// 15. **Strike intents**: Queue enemy and player strikes.
  /// 16. **Strike execution**: Spawn hitboxes/projectiles/self abilities from intents.
  /// 17. **Hitbox positioning**: Update hitbox positions from owners.
  /// 18. **Hit detection**: Check projectile and hitbox overlaps.
  /// 19. **Mobility impacts**: Apply overlap effects from active mobility.
  /// 20. **Status ticking**: Apply DoT ticks and queue damage.
  /// 21. **Damage middleware**: Apply combat rule edits/cancellations.
  /// 22. **Damage application**: Apply queued damage events.
  /// 23. **Status application**: Apply on-hit status profiles.
  /// 24. **Death handling**: Despawn dead entities, record kills.
  /// 25. **Resource regen**: Regenerate mana and stamina.
  /// 26. **Animation**: Compute per-entity anim key + frame.
  /// 27. **Cleanup**: Remove entities past their lifetime.
  ///
  /// If the run ends during this tick (player death, fell into gap, etc.),
  /// a [RunEndedEvent] is emitted and the simulation freezes.
  void stepOneTick() {
    // Don't advance if paused or game already over.
    if (paused || gameOver) return;

    if (_deathAnimTicksLeft > 0) {
      tick += 1;
      // Update animations during death anim freeze.
      _animSystem.step(
        _world,
        player: _player,
        currentTick: tick,
        playerDeathPhase: _playerDeathPhase,
        playerDeathStartTick: _playerDeathStartTick,
        playerSpawnStartTick: _playerSpawnStartTick,
      );
      _deathAnimTicksLeft -= 1;
      if (_deathAnimTicksLeft <= 0) {
        _endRun(
          _pendingRunEndReason ?? RunEndReason.playerDied,
          deathInfo: _pendingDeathInfo,
        );
      }
      return;
    }

    tick += 1;

    // Cache ground Y once per tick (ground plane doesn't change mid-tick).
    final effectiveGroundTopY = _levelDefinition.groundTopY;

    // ─── Phase 1: World generation ───
    _stepTrackManager(effectiveGroundTopY);

    // ─── Phase 2: Timer decrements ───
    _cooldownSystem.step(_world);
    _invulnerabilitySystem.step(_world);

    // ─── Phase 2.5: Control lock refresh ───
    // Must run before any gameplay systems that check locks.
    _controlLockSystem.step(_world, currentTick: tick);

    // ─── Phase 2.75: Active ability phase update ───
    _activeAbilityPhaseSystem.step(_world, currentTick: tick);

    // ─── Phase 2.8: Authoritative charge tracking ───
    _abilityChargeTrackingSystem.step(
      _world,
      currentTick: tick,
      queueEvent: (event) => _events.add(event),
    );

    // ─── Phase 2.9: Hold ability maintenance ───
    _holdAbilitySystem.step(
      _world,
      currentTick: tick,
      queueEvent: (event) => _events.add(event),
    );

    // ─── Phase 3: AI, input, and movement ───
    _enemyNavigationSystem.step(_world, player: _player, currentTick: tick);
    _enemyEngagementSystem.step(_world, player: _player, currentTick: tick);
    _groundEnemyLocomotionSystem.step(
      _world,
      player: _player,
      dtSeconds: _movement.dtSeconds,
      currentTick: tick,
    );
    _flyingEnemyLocomotionSystem.step(
      _world,
      player: _player,
      groundTopY: effectiveGroundTopY,
      dtSeconds: _movement.dtSeconds,
      currentTick: tick,
    );

    _abilityActivationSystem.step(_world, player: _player, currentTick: tick);
    _jumpSystem.step(_world, _movement, currentTick: tick);
    _movementSystem.step(
      _world,
      _movement,
      currentTick: tick,
      fixedPointPilotEnabled: _physicsTuning.fixedPointPilot.enabled,
      fixedPointSubpixelScale: _physicsTuning.fixedPointPilot.subpixelScale,
    );
    _mobilitySystem.step(_world, _movement, currentTick: tick);
    _gravitySystem.step(_world, _movement, physics: _physicsTuning);
    _collisionSystem.step(
      _world,
      _movement,
      staticWorld: _trackManager.staticIndex,
      fixedPointPilotEnabled: _physicsTuning.fixedPointPilot.enabled,
      fixedPointSubpixelScale: _physicsTuning.fixedPointPilot.subpixelScale,
    );

    // ─── Phase 4: Distance tracking ───
    // Only count forward movement (positive X velocity).
    distance += max(0.0, playerVelX) * _movement.dtSeconds;

    // ─── Phase 5: Death condition checks ───
    if (_checkFellIntoGap(effectiveGroundTopY)) {
      _endRun(RunEndReason.fellIntoGap);
      return;
    }

    _camera.updateTick(
      dtSeconds: _movement.dtSeconds,
      playerRightX: _playerRightX(),
      playerY: _playerYOrNull(),
    );
    final cameraLeft = _camera.left();
    if (_checkFellBehindCamera(cameraLeft: cameraLeft)) {
      _endRun(RunEndReason.fellBehindCamera);
      return;
    }

    // ─── Phase 6: Pickup collection ───
    _collectibleSystem.step(
      _world,
      player: _player,
      cameraLeft: cameraLeft,
      tuning: _collectibleTuning,
      onCollected: (value) {
        collectibles += 1;
        collectibleScore += value;
      },
    );
    _restorationItemSystem.step(
      _world,
      player: _player,
      cameraLeft: cameraLeft,
      tuning: _restorationItemTuning,
    );

    // ─── Phase 7: Spatial grid rebuild ───
    // Must happen before hit detection to ensure accurate overlaps.
    _broadphaseGrid.rebuild(_world);

    // ─── Phase 8: Projectile movement ───
    // Move existing projectiles before spawning new ones.
    _projectileSystem.step(_world, _movement);

    // ─── Phase 9: Strike intent writing ───
    // Enemy intent writing only.
    // Player intents are written at commit-time in Phase 3 (AbilityActivationSystem),
    // then executed later via stamped executeTick. Keep ordering explicit for tie-breaks.
    _enemyCastSystem.step(_world, player: _player, currentTick: tick);
    _enemyMeleeSystem.step(_world, player: _player, currentTick: tick);

    // ─── Phase 10: Strike execution ───
    _selfAbilitySystem.step(
      _world,
      currentTick: tick,
      queueStatus: _statusSystem.queue,
    );
    // Convert intents into actual hitboxes/projectiles.
    // Self abilities first so buffs/blocks/i-frames can affect spawns & downstream combat deterministically.
    _meleeStrikeSystem.step(_world, currentTick: tick);
    _projectileLaunchSystem.step(_world, currentTick: tick);

    // ─── Phase 11: Hitbox positioning ───
    // Update hitbox transforms to follow their owner entities.
    _hitboxFollowOwnerSystem.step(_world);

    // ─── Phase 12: Hit resolution + mobility impacts ───
    // Detect overlaps and queue damage events.
    _projectileHitSystem.step(
      _world,
      _broadphaseGrid,
      currentTick: tick,
      queueHitEvent: (event) => _events.add(event),
    );
    _hitboxDamageSystem.step(_world, _broadphaseGrid, currentTick: tick);
    _mobilityImpactSystem.step(
      _world,
      _broadphaseGrid,
      currentTick: tick,
      queueStatus: _statusSystem.queue,
    );
    _projectileWorldCollisionSystem.step(_world);
    // ─── Phase 13: Status + damage ───
    _entityVisualCueCoalescer.resetForTick(tick);
    _statusSystem.tickExisting(
      _world,
      onResourcePulse:
          ({
            required EntityId target,
            required StatusResourceType resourceType,
            required int restoredAmount100,
          }) {
            _entityVisualCueCoalescer.record(
              tick: tick,
              entityId: target,
              kind: EntityVisualCueKind.resourcePulse,
              intensityBp: _resourcePulseIntensityBp(restoredAmount100),
              resourceType: resourceType,
            );
          },
    );
    _damageMiddlewareSystem.step(_world, currentTick: tick);
    _damageSystem.step(
      _world,
      currentTick: tick,
      queueStatus: _statusSystem.queue,
      onDamageApplied:
          ({
            required EntityId target,
            required int appliedAmount100,
            required DeathSourceKind sourceKind,
            required DamageType damageType,
          }) {
            _playerImpactFeedbackGate.recordAppliedDamage(
              tick: tick,
              playerTarget: target == _player,
              appliedAmount100: appliedAmount100,
              sourceKind: sourceKind,
            );
            final kind = sourceKind == DeathSourceKind.statusEffect
                ? EntityVisualCueKind.dotPulse
                : EntityVisualCueKind.directHit;
            _entityVisualCueCoalescer.record(
              tick: tick,
              entityId: target,
              kind: kind,
              intensityBp: _damagePulseIntensityBp(appliedAmount100),
              damageType: damageType,
            );
          },
    );
    final playerImpactEvent = _playerImpactFeedbackGate.flushTick(tick);
    if (playerImpactEvent != null) {
      _events.add(playerImpactEvent);
    }
    _statusSystem.applyQueued(
      _world,
      currentTick: tick,
      onResourcePulse:
          ({
            required EntityId target,
            required StatusResourceType resourceType,
            required int restoredAmount100,
          }) {
            _entityVisualCueCoalescer.record(
              tick: tick,
              entityId: target,
              kind: EntityVisualCueKind.resourcePulse,
              intensityBp: _resourcePulseIntensityBp(restoredAmount100),
              resourceType: resourceType,
            );
          },
    );
    _entityVisualCueCoalescer.emit((event) => _events.add(event));

    // ─── Phase 14: Death handling ───
    _killedEnemiesScratch.clear();
    _enemyCullSystem.step(
      _world,
      cameraLeft: cameraLeft,
      groundTopY: effectiveGroundTopY,
      tuning: _trackTuning,
    );
    _enemyDeathStateSystem.step(
      _world,
      currentTick: tick,
      outEnemiesKilled: _killedEnemiesScratch,
    );
    _deathDespawnSystem.step(_world, currentTick: tick);
    _healthDespawnSystem.step(_world, player: _player);
    if (_killedEnemiesScratch.isNotEmpty) {
      _recordEnemyKills(_killedEnemiesScratch);
    }
    if (_isPlayerDead()) {
      if (_deathAnimTicksLeft <= 0) {
        if (_playerDeathPhase == DeathPhase.none) {
          _playerDeathPhase = DeathPhase.deathAnim;
          // First death frame is rendered during the freeze tick immediately
          // after this gameplay tick.
          _playerDeathStartTick = tick + 1;
        }
        _pendingRunEndReason = RunEndReason.playerDied;
        _pendingDeathInfo = _buildDeathInfo();
        if (_animTuning.deathAnimTicks <= 0) {
          _endRun(_pendingRunEndReason!, deathInfo: _pendingDeathInfo);
        } else {
          _deathAnimTicksLeft = _animTuning.deathAnimTicks;
        }
      }
      return;
    }

    // ─── Phase 15: Resource regeneration ───
    _resourceRegenSystem.step(_world);

    // ─── Phase 16: Animation ───
    _animSystem.step(
      _world,
      player: _player,
      currentTick: tick,
      playerDeathPhase: _playerDeathPhase,
      playerDeathStartTick: _playerDeathStartTick,
      playerSpawnStartTick: _playerSpawnStartTick,
    );

    // ─── Phase 17: Cleanup ───
    _lifetimeSystem.step(_world);
  }

  /// Steps the track manager and handles enemy spawning callbacks.
  ///
  /// This is extracted from [stepOneTick] to keep the main loop readable.
  void _stepTrackManager(double effectiveGroundTopY) {
    _trackManager.step(
      currentTick: tick,
      cameraLeft: _camera.left(),
      cameraRight: _camera.right(),
      spawnEnemy: (enemyId, x) {
        // Route spawn requests to the appropriate SpawnService method.
        switch (enemyId) {
          case EnemyId.unocoDemon:
            _spawnService.spawnUnocoDemon(
              spawnX: x,
              groundTopY: effectiveGroundTopY,
            );
          case EnemyId.grojib:
            _spawnService.spawnGroundEnemy(
              spawnX: x,
              groundTopY: effectiveGroundTopY,
            );
        }
      },
      lowestResourceStat: _lowestResourceStat,
    );
  }

  // ─────────────────────────────────────────────────────────────────────────
  // Run End Handling
  // ─────────────────────────────────────────────────────────────────────────

  /// Ends the current run and emits a [RunEndedEvent].
  ///
  /// After this call, [gameOver] is true and [stepOneTick] will no-op.
  void _endRun(RunEndReason reason, {DeathInfo? deathInfo}) {
    gameOver = true;
    paused = true;
    final goldEarned = computeGoldEarned(collectiblesCollected: collectibles);
    _events.add(
      RunEndedEvent(
        runId: runId,
        tick: tick,
        distance: distance,
        reason: reason,
        stats: _buildRunEndStats(),
        goldEarned: goldEarned,
        deathInfo: deathInfo,
      ),
    );
  }

  /// Manually ends the run (e.g., from pause menu).
  ///
  /// Does nothing if the game is already over.
  void giveUp() {
    if (gameOver) return;
    _endRun(RunEndReason.gaveUp);
  }

  /// Records enemy kills for score calculation.
  void _recordEnemyKills(List<EnemyId> killedEnemies) {
    for (final enemyId in killedEnemies) {
      final index = enemyId.index;
      if (index >= 0 && index < _enemyKillCounts.length) {
        _enemyKillCounts[index] += 1;
      }
    }
  }

  /// Builds run statistics for the end-of-run event.
  RunEndStats _buildRunEndStats() => RunEndStats(
    collectibles: collectibles,
    collectibleScore: collectibleScore,
    enemyKillCounts: List<int>.unmodifiable(_enemyKillCounts),
  );

  /// Checks if the player's HP has reached zero.
  bool _isPlayerDead() {
    final hi = _world.health.tryIndexOf(_player);
    if (hi == null) return false;
    return _world.health.hp[hi] <= 0;
  }

  /// Builds death info for the run-ended event.
  ///
  /// This provides details about what killed the player (enemy type,
  /// projectile type, etc.) for death screen messaging.
  DeathInfo? _buildDeathInfo() {
    final li = _world.lastDamage.tryIndexOf(_player);
    if (li == null) return null;

    final kind = _world.lastDamage.kind[li];
    if (kind == DeathSourceKind.unknown) return null;

    return DeathInfo(
      kind: kind,
      enemyId: _world.lastDamage.hasEnemyId[li]
          ? _world.lastDamage.enemyId[li]
          : null,
      projectileId: _world.lastDamage.hasProjectileId[li]
          ? _world.lastDamage.projectileId[li]
          : null,
      sourceProjectileId: _world.lastDamage.hasSourceProjectileId[li]
          ? _world.lastDamage.sourceProjectileId[li]
          : null,
    );
  }

  // ─────────────────────────────────────────────────────────────────────────
  // Death Condition Checks
  // ─────────────────────────────────────────────────────────────────────────

  /// Checks if the player has fallen behind the camera's left edge.
  ///
  /// This is a "soft" death—the player can still be on solid ground but
  /// has failed to keep up with the autoscrolling camera.
  bool _checkFellBehindCamera({required double cameraLeft}) {
    final rightX = _playerRightX();
    if (rightX == null) return false;

    // Player's right edge must stay ahead of camera's left edge.
    return rightX < cameraLeft;
  }

  double? _playerRightX() {
    if (!(_world.transform.has(_player) && _world.colliderAabb.has(_player))) {
      return null;
    }
    final ti = _world.transform.indexOf(_player);
    final ai = _world.colliderAabb.indexOf(_player);
    final centerX = _world.transform.posX[ti] + _world.colliderAabb.offsetX[ai];
    return centerX + _world.colliderAabb.halfX[ai];
  }

  double? _playerYOrNull() {
    if (!_world.transform.has(_player)) return null;
    return _world.transform.posY[_world.transform.indexOf(_player)];
  }

  /// Checks if the player has fallen into a ground gap (pit).
  ///
  /// The kill threshold is set well below ground level to give visual
  /// feedback of falling before the death triggers. Configured via
  /// [TrackTuning.gapKillOffsetY].
  bool _checkFellIntoGap(double groundTopY) {
    if (!(_world.transform.has(_player) && _world.colliderAabb.has(_player))) {
      return false;
    }

    final ti = _world.transform.indexOf(_player);
    final ai = _world.colliderAabb.indexOf(_player);
    final bottomY =
        _world.transform.posY[ti] +
        _world.colliderAabb.offsetY[ai] +
        _world.colliderAabb.halfY[ai];

    return bottomY > groundTopY + _trackTuning.gapKillOffsetY;
  }

  // ─────────────────────────────────────────────────────────────────────────
  // Resource Helpers
  // ─────────────────────────────────────────────────────────────────────────

  /// Returns the player's most depleted resource stat.
  ///
  /// Used by restoration item spawning to bias item type toward what
  /// the player needs most. Compares ratios (current/max) to handle
  /// resources with different maximum values fairly.
  ///
  /// **Tie-breaking priority**: When ratios are equal, the first resource
  /// checked wins: health > mana > stamina. This is intentional—health
  /// is prioritized as the most critical survival resource.
  RestorationStat _lowestResourceStat() {
    final hi = _world.health.tryIndexOf(_player);
    final mi = _world.mana.tryIndexOf(_player);
    final si = _world.stamina.tryIndexOf(_player);
    if (hi == null || mi == null || si == null) {
      return RestorationStat.health;
    }

    // Start with health as baseline.
    var best = RestorationStat.health;
    var bestValue = _world.health.hp[hi];
    var bestMax = _world.health.hpMax[hi];

    // Compare mana ratio.
    final mana = _world.mana.mana[mi];
    final manaMax = _world.mana.manaMax[mi];
    if (_ratioLess(mana, manaMax, bestValue, bestMax)) {
      best = RestorationStat.mana;
      bestValue = mana;
      bestMax = manaMax;
    }

    // Compare stamina ratio.
    final stamina = _world.stamina.stamina[si];
    final staminaMax = _world.stamina.staminaMax[si];
    if (_ratioLess(stamina, staminaMax, bestValue, bestMax)) {
      best = RestorationStat.stamina;
    }

    return best;
  }

  /// Compares two ratios without division: (valueA / maxA) < (valueB / maxB).
  ///
  /// Cross-multiplies to avoid division: valueA * maxB < valueB * maxA.
  bool _ratioLess(int valueA, int maxA, int valueB, int maxB) {
    if (maxA <= 0) return false; // Invalid ratio A, can't be less.
    if (maxB <= 0) return true; // Invalid ratio B, A wins by default.
    return valueA * maxB < valueB * maxA;
  }

  /// Computes the maximum air time (in ticks) for ground enemy jumps.
  ///
  /// Based on projectile motion: time = 2 * jumpSpeed / gravity.
  /// Multiplied by 1.5 for safety margin (accounts for landing tolerance).
  int _groundEnemyMaxAirTicks() {
    final gravity = _physicsTuning.gravityY;
    if (gravity <= 0) {
      // No gravity means infinite air time; cap at 1 second.
      return ticksFromSecondsCeil(1.0, tickHz);
    }
    final jumpSpeed = _groundEnemyTuning.locomotion.jumpSpeed.abs();
    final baseAirSeconds = (2.0 * jumpSpeed) / gravity;
    return ticksFromSecondsCeil(baseAirSeconds * 1.5, tickHz);
  }

  int _damagePulseIntensityBp(int appliedAmount100) {
    if (appliedAmount100 <= 0) return 0;
    final scaled =
        (appliedAmount100 * _visualCueIntensityScaleBp) ~/
        _damagePulseMaxAmount100;
    return scaled.clamp(_damagePulseMinIntensityBp, _visualCueIntensityScaleBp);
  }

  int _resourcePulseIntensityBp(int restoredAmount100) {
    if (restoredAmount100 <= 0) return 0;
    final scaled =
        (restoredAmount100 * _visualCueIntensityScaleBp) ~/
        _resourcePulseMaxAmount100;
    return scaled.clamp(
      _resourcePulseMinIntensityBp,
      _visualCueIntensityScaleBp,
    );
  }

  static const int _visualCueIntensityScaleBp = 10000;
  static const int _damagePulseMaxAmount100 = 1500;
  static const int _resourcePulseMaxAmount100 = 1200;
  static const int _damagePulseMinIntensityBp = 1800;
  static const int _resourcePulseMinIntensityBp = 2000;

  // ─────────────────────────────────────────────────────────────────────────
  // Events & Snapshots
  // ─────────────────────────────────────────────────────────────────────────

  /// Drains and returns all pending game events.
  ///
  /// Events are produced during [stepOneTick] (e.g., [RunEndedEvent]).
  /// The UI layer should call this after each tick to process events.
  ///
  /// Returns an empty list if no events are pending (avoids allocation).
  List<GameEvent> drainEvents() {
    if (_events.isEmpty) return const <GameEvent>[];
    final drained = List<GameEvent>.unmodifiable(_events);
    _events.clear();
    return drained;
  }

  /// Builds an immutable snapshot for render/UI consumption.
  ///
  /// The snapshot contains everything needed to render a single frame:
  /// - Entity positions, velocities, and animations
  /// - Player HUD data (HP, mana, stamina, cooldowns)
  /// - Static geometry (platforms, ground surfaces, ground gaps)
  /// - Camera position
  ///
  /// Snapshots are immutable and safe to pass to async render code.
  GameStateSnapshot buildSnapshot() {
    return _snapshotBuilder.build(
      tick: tick,
      runId: runId,
      seed: seed,
      levelId: levelId,
      themeId: themeId,
      distance: distance,
      paused: paused,
      gameOver: gameOver,
      camera: CameraSnapshot(
        centerX: _camera.state.centerX,
        centerY: _camera.state.centerY,
        viewWidth: virtualWidth.toDouble(),
        viewHeight: virtualHeight.toDouble(),
      ),
      collectibles: collectibles,
      collectibleScore: collectibleScore,
      staticSolids: _trackManager.staticSolidsSnapshot,
      groundSurfaces: _trackManager.groundSurfacesSnapshot,
    );
  }
}


===== FILE: lib/core/levels/level_definition.dart =====
/// Data-first definition of a level configuration (Core-only).
library;

import '../collision/static_world_geometry.dart';
import '../track/chunk_pattern_pool.dart';
import '../tuning/core_tuning.dart';
import 'level_id.dart';
import 'level_world_constants.dart';

/// Core configuration for a single level.
///
/// This is pure data: no Flutter/Flame imports and no runtime side effects.
class LevelDefinition {
  LevelDefinition({
    required this.id,
    required this.patternPool,
    required this.staticWorldGeometry,
    this.tuning = const CoreTuning(),
    this.cameraCenterY = defaultLevelCameraCenterY,
    this.earlyPatternChunks = defaultEarlyPatternChunks,
    this.noEnemyChunks = defaultNoEnemyChunks,
    this.themeId,
  }) : assert(earlyPatternChunks >= 0),
       assert(noEnemyChunks >= 0),
       assert(
         staticWorldGeometry.groundPlane != null,
         'LevelDefinition.staticWorldGeometry.groundPlane must be set',
       ) {
    if (staticWorldGeometry.groundPlane == null) {
      throw StateError(
        'LevelDefinition($id) requires staticWorldGeometry.groundPlane',
      );
    }
  }

  /// Stable identifier for this level.
  final LevelId id;

  /// Core tuning overrides for this level.
  final CoreTuning tuning;

  /// Base collision geometry for the level (ground + fixed platforms).
  final StaticWorldGeometry staticWorldGeometry;

  /// World-space camera center Y for snapshot/render framing.
  final double cameraCenterY;

  /// Authoritative world-space ground top Y for gameplay and spawning.
  ///
  /// This is derived from [staticWorldGeometry.groundPlane] and is guaranteed
  /// to exist by constructor validation.
  double get groundTopY => staticWorldGeometry.groundPlane!.topY;

  /// Pattern pool used for procedural chunk generation.
  final ChunkPatternPool patternPool;

  /// Number of early chunks that use [patternPool.easyPatterns].
  final int earlyPatternChunks;

  /// Number of early chunks that suppress enemy spawns.
  final int noEnemyChunks;

  /// Optional render theme identifier (e.g., lookup key for assets).
  final String? themeId;

  /// Returns a copy with selected fields overridden.
  LevelDefinition copyWith({
    LevelId? id,
    CoreTuning? tuning,
    double? cameraCenterY,
    StaticWorldGeometry? staticWorldGeometry,
    ChunkPatternPool? patternPool,
    int? earlyPatternChunks,
    int? noEnemyChunks,
    String? themeId,
  }) {
    return LevelDefinition(
      id: id ?? this.id,
      patternPool: patternPool ?? this.patternPool,
      tuning: tuning ?? this.tuning,
      cameraCenterY: cameraCenterY ?? this.cameraCenterY,
      staticWorldGeometry: staticWorldGeometry ?? this.staticWorldGeometry,
      earlyPatternChunks: earlyPatternChunks ?? this.earlyPatternChunks,
      noEnemyChunks: noEnemyChunks ?? this.noEnemyChunks,
      themeId: themeId ?? this.themeId,
    );
  }
}


===== FILE: lib/core/levels/level_id.dart =====
/// Stable identifiers for level definitions.
///
/// Avoid renaming or reordering values; treat as protocol-stable.
enum LevelId { forest, field }


===== FILE: lib/core/levels/level_registry.dart =====
/// Registry for core level definitions.
library;

import '../collision/static_world_geometry.dart';
import '../track/chunk_pattern_pool.dart';
import '../track/chunk_patterns_library.dart';
import 'level_definition.dart';
import 'level_id.dart';
import 'level_world_constants.dart';

/// Default pattern pool (matches current behavior).
const ChunkPatternPool defaultPatternPool = ChunkPatternPool(
  easyPatterns: easyPatterns,
  allPatterns: allPatterns,
);

const StaticWorldGeometry _defaultBaseGeometry = StaticWorldGeometry(
  groundPlane: StaticGroundPlane(topY: defaultLevelGroundTopY),
);

/// Resolves level definitions by stable [LevelId].
class LevelRegistry {
  const LevelRegistry._();

  /// Returns the level definition for a given [LevelId].
  static LevelDefinition byId(LevelId id) {
    switch (id) {
      case LevelId.forest:
        return LevelDefinition(
          id: LevelId.forest,
          patternPool: defaultPatternPool,
          cameraCenterY: defaultLevelCameraCenterY,
          staticWorldGeometry: _defaultBaseGeometry,
          themeId: 'forest',
        );
      case LevelId.field:
        return LevelDefinition(
          id: LevelId.field,
          patternPool: defaultPatternPool,
          cameraCenterY: defaultLevelCameraCenterY,
          staticWorldGeometry: _defaultBaseGeometry,
          themeId: 'field',
        );
    }
  }
}


===== FILE: lib/core/levels/level_world_constants.dart =====
/// Shared level framing constants (Core-owned).
library;

import '../contracts/spatial_contract.dart';

/// Default gameplay ground top for runner levels.
const int defaultLevelGroundTopYInt = 220;

/// Default gameplay ground top in world units.
const double defaultLevelGroundTopY = defaultLevelGroundTopYInt * 1.0;

/// Default camera center Y in world units.
const double defaultLevelCameraCenterY = virtualCameraCenterY;


===== FILE: lib/core/loadout/loadout_issue.dart =====
import '../abilities/ability_def.dart';

/// The kind of issue found during loadout validation.
enum IssueKind {
  /// Ability is not allowed in this slot (checked against `allowedSlots`).
  slotNotAllowed,

  /// Equipped weapon definition does not match the slot's expected category.
  weaponCategoryMismatch,

  /// Equipped weapon (or effective weapon) lacks required weapon types.
  missingRequiredWeaponTypes,

  /// Ability requires an equipped weapon, but none is present.
  requiresEquippedWeapon,

  /// Two-handed primary weapon conflicts with a separately equipped off-hand item.
  twoHandedConflict,

  /// References a definition that does not exist in the catalog.
  catalogMissing,
}

/// A single validation error or warning for a loadout.
class LoadoutIssue {
  const LoadoutIssue({
    required this.slot,
    required this.kind,
    this.abilityId,
    this.weaponId,
    this.missingWeaponTypes = const {},
    this.message = '',
  });

  /// The slot where the issue occurred.
  final AbilitySlot slot;

  /// The specific kind of validation failure.
  final IssueKind kind;

  /// The ID of the ability involved, if known.
  final String? abilityId;

  /// The ID of the weapon involved, if known.
  final String? weaponId;

  /// If [kind] is [missingRequiredWeaponTypes], this set contains the missing types.
  final Set<WeaponType> missingWeaponTypes;

  /// A human-readable message describing the issue.
  final String message;

  @override
  String toString() {
    return 'LoadoutIssue($slot, $kind, ability:$abilityId, weapon:$weaponId, missingWeaponTypes:$missingWeaponTypes)';
  }
}


===== FILE: lib/core/loadout/loadout_validation_result.dart =====
import 'loadout_issue.dart';

/// Result of a full loadout validation pass.
class LoadoutValidationResult {
  const LoadoutValidationResult({
    required this.isValid,
    this.issues = const [],
  });

  /// A completely valid result with no issues.
  static const LoadoutValidationResult valid = LoadoutValidationResult(isValid: true);

  /// Creates an invalid result with a list of issues.
  factory LoadoutValidationResult.invalid(List<LoadoutIssue> issues) =>
      LoadoutValidationResult(isValid: false, issues: issues);

  /// Whether the loadout is considered valid and runnable.
  final bool isValid;

  /// List of issues found during validation.
  final List<LoadoutIssue> issues;
}


===== FILE: lib/core/loadout/loadout_validator.dart =====
import '../abilities/ability_catalog.dart';
import '../abilities/ability_def.dart';
import '../ecs/stores/combat/equipped_loadout_store.dart';
import '../projectiles/projectile_catalog.dart';
import '../projectiles/projectile_item_def.dart';
import '../projectiles/projectile_id.dart';
import '../spellBook/spell_book_catalog.dart';
import '../spellBook/spell_book_def.dart';
import '../spellBook/spell_book_id.dart';
import '../weapons/weapon_catalog.dart';
import '../weapons/weapon_category.dart';
import '../weapons/weapon_def.dart';
import '../weapons/weapon_id.dart';
import 'loadout_issue.dart';
import 'loadout_validation_result.dart';

/// Stateless validator for checking loadout legality.
class LoadoutValidator {
  const LoadoutValidator({
    required this.abilityCatalog,
    required this.weaponCatalog,
    required this.projectileCatalog,
    required this.spellBookCatalog,
  });

  final AbilityResolver abilityCatalog;
  final WeaponCatalog weaponCatalog;
  final ProjectileCatalog projectileCatalog;
  final SpellBookCatalog spellBookCatalog;

  /// Validates an entire loadout definition.
  LoadoutValidationResult validate(EquippedLoadoutDef loadout) {
    final issues = <LoadoutIssue>[];

    // 1. Resolve Weapons
    final mainWeapon = _resolveWeapon(
      loadout.mainWeaponId,
      WeaponCategory.primary,
      AbilitySlot.primary,
      issues,
    );

    final offhandWeapon = _resolveWeapon(
      loadout.offhandWeaponId,
      WeaponCategory.offHand,
      AbilitySlot.secondary,
      issues,
    );

    final projectile = _resolveProjectile(
      loadout.projectileId,
      AbilitySlot.projectile,
      issues,
    );

    final spellBook = _resolveSpellBook(loadout.spellBookId, issues);

    // 2. Derive Effective Weapons (Two-Handed Logic)
    final isTwoHanded = mainWeapon?.isTwoHanded ?? false;

    // Rule: Two-Handed weapon blocks separate secondary weapon
    if (isTwoHanded && offhandWeapon != null) {
      issues.add(
        LoadoutIssue(
          slot: AbilitySlot.secondary,
          kind: IssueKind.twoHandedConflict,
          weaponId: loadout.offhandWeaponId.toString(),
          message: 'Cannot equip off-hand weapon with two-handed primary.',
        ),
      );
    }

    // Effective weapons for gating
    final effectiveSecondaryWeapon = isTwoHanded ? mainWeapon : offhandWeapon;

    // 3. Validate Slots

    // Primary
    _validateSlot(
      issues: issues,
      abilityId: loadout.abilityPrimaryId,
      slot: AbilitySlot.primary,
      mainWeapon: mainWeapon,
      effectiveSecondaryWeapon: effectiveSecondaryWeapon,
      projectile: projectile,
      spellBook: spellBook,
      projectileSlotSpellId: loadout.projectileSlotSpellId,
    );

    // Secondary
    _validateSlot(
      issues: issues,
      abilityId: loadout.abilitySecondaryId,
      slot: AbilitySlot.secondary,
      mainWeapon: mainWeapon,
      effectiveSecondaryWeapon: effectiveSecondaryWeapon,
      projectile: projectile,
      spellBook: spellBook,
      projectileSlotSpellId: loadout.projectileSlotSpellId,
    );

    // Projectile
    _validateSlot(
      issues: issues,
      abilityId: loadout.abilityProjectileId,
      slot: AbilitySlot.projectile,
      mainWeapon: mainWeapon,
      effectiveSecondaryWeapon: effectiveSecondaryWeapon,
      projectile: projectile,
      spellBook: spellBook,
      projectileSlotSpellId: loadout.projectileSlotSpellId,
    );

    // Mobility (No weapon)
    _validateSlot(
      issues: issues,
      abilityId: loadout.abilityMobilityId,
      slot: AbilitySlot.mobility,
      mainWeapon: mainWeapon,
      effectiveSecondaryWeapon: effectiveSecondaryWeapon,
      projectile: projectile,
      spellBook: spellBook,
      projectileSlotSpellId: loadout.projectileSlotSpellId,
    );

    // Spell slot: payload gating is now driven by AbilityDef.payloadSource.
    _validateSlot(
      issues: issues,
      abilityId: loadout.abilitySpellId,
      slot: AbilitySlot.spell,
      mainWeapon: mainWeapon,
      effectiveSecondaryWeapon: effectiveSecondaryWeapon,
      projectile: projectile,
      spellBook: spellBook,
      projectileSlotSpellId: loadout.projectileSlotSpellId,
    );

    // Jump (Fixed slot, no weapon)
    _validateSlot(
      issues: issues,
      abilityId: loadout.abilityJumpId,
      slot: AbilitySlot.jump,
      mainWeapon: mainWeapon,
      effectiveSecondaryWeapon: effectiveSecondaryWeapon,
      projectile: projectile,
      spellBook: spellBook,
      projectileSlotSpellId: loadout.projectileSlotSpellId,
    );

    return LoadoutValidationResult(isValid: issues.isEmpty, issues: issues);
  }

  WeaponDef? _resolveWeapon(
    WeaponId id,
    WeaponCategory expectedCategory,
    AbilitySlot slot,
    List<LoadoutIssue> issues,
  ) {
    final weapon = weaponCatalog.tryGet(id);
    if (weapon == null) {
      // If we assume LoadoutStore always has valid defaults, this is a corruption/catalogMissing.
      // If we want to support "none", we'd need a specific ID for it or nullable field.
      // LoadoutDefs are non-nullable IDs.
      // So if tryGet fails, it's catalogMissing.
      issues.add(
        LoadoutIssue(
          slot: slot,
          kind: IssueKind.catalogMissing,
          weaponId: id.toString(),
          message: 'Weapon ID not found in catalog.',
        ),
      );
      return null;
    }

    if (weapon.category != expectedCategory) {
      issues.add(
        LoadoutIssue(
          slot: slot,
          kind: IssueKind.weaponCategoryMismatch,
          weaponId: id.toString(),
          message: 'Expected $expectedCategory, found ${weapon.category}.',
        ),
      );
      // Return null so we don't cascade category errors into type errors?
      // Or return weapon so we can still check types?
      // Returning weapon allows more checks, but might be noisy.
      // Let's return null to fail-fast on this slot's weapon.
      return null;
    }

    return weapon;
  }

  ProjectileItemDef? _resolveProjectile(
    ProjectileId id,
    AbilitySlot slot,
    List<LoadoutIssue> issues,
  ) {
    final item = projectileCatalog.tryGet(id);
    if (item == null) {
      issues.add(
        LoadoutIssue(
          slot: slot,
          kind: IssueKind.catalogMissing,
          weaponId: id.toString(),
          message: 'Projectile item ID not found in catalog.',
        ),
      );
      return null;
    }
    return item;
  }

  SpellBookDef? _resolveSpellBook(SpellBookId id, List<LoadoutIssue> issues) {
    final book = spellBookCatalog.tryGet(id);
    if (book == null) {
      issues.add(
        LoadoutIssue(
          slot: AbilitySlot.spell,
          kind: IssueKind.catalogMissing,
          weaponId: id.toString(),
          message: 'Spell book ID not found in catalog.',
        ),
      );
      return null;
    }
    return book;
  }

  void _validateSlot({
    required List<LoadoutIssue> issues,
    required AbilityKey abilityId,
    required AbilitySlot slot,
    required WeaponDef? mainWeapon,
    required WeaponDef? effectiveSecondaryWeapon,
    required ProjectileItemDef? projectile,
    required SpellBookDef? spellBook,
    required ProjectileId? projectileSlotSpellId,
  }) {
    final ability = abilityCatalog.resolve(abilityId);
    if (ability == null) {
      issues.add(
        LoadoutIssue(
          slot: slot,
          kind: IssueKind.catalogMissing,
          abilityId: abilityId,
          message: 'Ability ID not found in catalog.',
        ),
      );
      return;
    }

    final effectiveProjectile = _effectiveProjectilePayloadForSlot(
      issues: issues,
      slot: slot,
      fallbackProjectile: projectile,
      spellBook: spellBook,
      projectileSlotSpellId: projectileSlotSpellId,
    );

    final (hasWeapon, weaponType) = _payloadContextFor(
      ability,
      mainWeapon: mainWeapon,
      effectiveSecondaryWeapon: effectiveSecondaryWeapon,
      projectile: effectiveProjectile,
      spellBook: spellBook,
    );

    // 1. Slot Compatibility
    if (!ability.allowedSlots.contains(slot)) {
      issues.add(
        LoadoutIssue(
          slot: slot,
          kind: IssueKind.slotNotAllowed,
          abilityId: abilityId,
          message: 'Ability not allowed in $slot slot.',
        ),
      );
    }

    // 2. Weapon Presence
    if (ability.requiresEquippedWeapon && !hasWeapon) {
      issues.add(
        LoadoutIssue(
          slot: slot,
          kind: IssueKind.requiresEquippedWeapon,
          abilityId: abilityId,
          message: 'Ability requires an equipped weapon.',
        ),
      );
    }

    // 3. Weapon Type Gating
    if (ability.requiredWeaponTypes.isNotEmpty) {
      if (weaponType == null ||
          !ability.requiredWeaponTypes.contains(weaponType)) {
        issues.add(
          LoadoutIssue(
            slot: slot,
            kind: IssueKind.missingRequiredWeaponTypes,
            abilityId: abilityId,
            missingWeaponTypes: ability.requiredWeaponTypes,
            message:
                'Missing required weapon types: ${ability.requiredWeaponTypes.join(", ")}.',
          ),
        );
      }
    }

    // 4. Spellbook grant gating for spell-slot self-spells.
    if (slot == AbilitySlot.spell &&
        ability.payloadSource == AbilityPayloadSource.spellBook &&
        spellBook != null &&
        !spellBook.containsSpellAbility(ability.id)) {
      issues.add(
        LoadoutIssue(
          slot: slot,
          kind: IssueKind.catalogMissing,
          abilityId: ability.id,
          weaponId: spellBook.id.toString(),
          message: 'Selected spell is not granted by the spellbook.',
        ),
      );
    }
  }

  ProjectileItemDef? _effectiveProjectilePayloadForSlot({
    required List<LoadoutIssue> issues,
    required AbilitySlot slot,
    required ProjectileItemDef? fallbackProjectile,
    required SpellBookDef? spellBook,
    required ProjectileId? projectileSlotSpellId,
  }) {
    final selectedSpellId = switch (slot) {
      AbilitySlot.projectile => projectileSlotSpellId,
      AbilitySlot.primary ||
      AbilitySlot.secondary ||
      AbilitySlot.mobility ||
      AbilitySlot.spell ||
      AbilitySlot.jump => null,
    };
    if (selectedSpellId == null) {
      return fallbackProjectile;
    }

    final selectedSpell = projectileCatalog.tryGet(selectedSpellId);
    if (selectedSpell == null) {
      issues.add(
        LoadoutIssue(
          slot: slot,
          kind: IssueKind.catalogMissing,
          weaponId: selectedSpellId.toString(),
          message:
              'Selected projectile spell was not found in ProjectileCatalog.',
        ),
      );
      return fallbackProjectile;
    }

    if (selectedSpell.weaponType != WeaponType.projectileSpell) {
      issues.add(
        LoadoutIssue(
          slot: slot,
          kind: IssueKind.missingRequiredWeaponTypes,
          weaponId: selectedSpellId.toString(),
          missingWeaponTypes: const <WeaponType>{WeaponType.projectileSpell},
          message: 'Selected slot spell must be a projectile spell item.',
        ),
      );
      return fallbackProjectile;
    }

    if (spellBook == null ||
        !spellBook.containsProjectileSpell(selectedSpellId)) {
      issues.add(
        LoadoutIssue(
          slot: slot,
          kind: IssueKind.catalogMissing,
          weaponId: selectedSpellId.toString(),
          message:
              'Selected projectile spell is not granted by the equipped spellbook.',
        ),
      );
      return fallbackProjectile;
    }

    return selectedSpell;
  }

  (bool hasWeapon, WeaponType? weaponType) _payloadContextFor(
    AbilityDef ability, {
    required WeaponDef? mainWeapon,
    required WeaponDef? effectiveSecondaryWeapon,
    required ProjectileItemDef? projectile,
    required SpellBookDef? spellBook,
  }) {
    switch (ability.payloadSource) {
      case AbilityPayloadSource.none:
        return (false, null);
      case AbilityPayloadSource.primaryWeapon:
        return (mainWeapon != null, mainWeapon?.weaponType);
      case AbilityPayloadSource.secondaryWeapon:
        // effectiveSecondaryWeapon already applies two-handed mapping
        return (
          effectiveSecondaryWeapon != null,
          effectiveSecondaryWeapon?.weaponType,
        );
      case AbilityPayloadSource.projectile:
        return (projectile != null, projectile?.weaponType);
      case AbilityPayloadSource.spellBook:
        return (spellBook != null, spellBook?.weaponType);
    }
  }
}


===== FILE: lib/core/meta/equipped_gear.dart =====
import '../accessories/accessory_id.dart';
import '../projectiles/projectile_id.dart';
import '../spellBook/spell_book_id.dart';
import '../weapons/weapon_id.dart';

/// Canonical equipped gear set for one character profile.
///
/// This object is intentionally complete (all slots required) so consumers
/// never have to handle "missing slot" states during gameplay setup.
class EquippedGear {
  const EquippedGear({
    required this.mainWeaponId,
    required this.offhandWeaponId,
    required this.throwingWeaponId,
    required this.spellBookId,
    required this.accessoryId,
  });

  /// Equipped main-hand weapon.
  final WeaponId mainWeaponId;

  /// Equipped off-hand weapon.
  final WeaponId offhandWeaponId;

  /// Equipped throwing weapon.
  final ProjectileId throwingWeaponId;

  /// Equipped spellbook.
  final SpellBookId spellBookId;

  /// Equipped accessory.
  final AccessoryId accessoryId;

  /// Returns a copy with selected fields replaced.
  EquippedGear copyWith({
    WeaponId? mainWeaponId,
    WeaponId? offhandWeaponId,
    ProjectileId? throwingWeaponId,
    SpellBookId? spellBookId,
    AccessoryId? accessoryId,
  }) {
    return EquippedGear(
      mainWeaponId: mainWeaponId ?? this.mainWeaponId,
      offhandWeaponId: offhandWeaponId ?? this.offhandWeaponId,
      throwingWeaponId: throwingWeaponId ?? this.throwingWeaponId,
      spellBookId: spellBookId ?? this.spellBookId,
      accessoryId: accessoryId ?? this.accessoryId,
    );
  }

  /// Serializes equipped IDs using enum names for stable storage.
  Map<String, Object?> toJson() {
    return <String, Object?>{
      'mainWeaponId': mainWeaponId.name,
      'offhandWeaponId': offhandWeaponId.name,
      'throwingWeaponId': throwingWeaponId.name,
      'spellBookId': spellBookId.name,
      'accessoryId': accessoryId.name,
    };
  }

  /// Deserializes from persisted JSON with per-field fallback safety.
  ///
  /// Unknown/missing enum names keep the corresponding fallback value.
  static EquippedGear fromJson(
    Map<String, dynamic> json, {
    required EquippedGear fallback,
  }) {
    return EquippedGear(
      mainWeaponId: _enumFromName(
        WeaponId.values,
        json['mainWeaponId'] as String?,
        fallback.mainWeaponId,
      ),
      offhandWeaponId: _enumFromName(
        WeaponId.values,
        json['offhandWeaponId'] as String?,
        fallback.offhandWeaponId,
      ),
      throwingWeaponId: _enumFromName(
        ProjectileId.values,
        json['throwingWeaponId'] as String?,
        fallback.throwingWeaponId,
      ),
      spellBookId: _enumFromName(
        SpellBookId.values,
        json['spellBookId'] as String?,
        fallback.spellBookId,
      ),
      accessoryId: _enumFromName(
        AccessoryId.values,
        json['accessoryId'] as String?,
        fallback.accessoryId,
      ),
    );
  }
}

/// Safe enum lookup helper used by meta deserialization.
T _enumFromName<T extends Enum>(List<T> values, String? name, T fallback) {
  if (name == null) return fallback;
  for (final value in values) {
    if (value.name == name) return value;
  }
  return fallback;
}


===== FILE: lib/core/meta/gear_slot.dart =====
/// High-level equipment slots exposed by meta/loadout UI.
///
/// The values are stable and used by both persistence and picker routing.
enum GearSlot {
  /// Primary melee weapon slot.
  mainWeapon,

  /// Off-hand weapon slot (for example shields).
  offhandWeapon,

  /// Throwable/ranged weapon slot.
  throwingWeapon,

  /// Spellbook slot.
  spellBook,

  /// Accessory slot.
  accessory,
}


===== FILE: lib/core/meta/inventory_state.dart =====
import '../accessories/accessory_id.dart';
import '../projectiles/projectile_id.dart';
import '../spellBook/spell_book_id.dart';
import '../weapons/weapon_id.dart';

/// Unlocked gear inventory tracked by meta progression.
///
/// Sets are modeled per gear domain so slot/category validation can remain
/// explicit in [MetaService].
class InventoryState {
  const InventoryState({
    required this.unlockedWeaponIds,
    required this.unlockedThrowingWeaponIds,
    required this.unlockedSpellBookIds,
    required this.unlockedAccessoryIds,
  });

  /// Unlocked melee/off-hand weapon IDs.
  final Set<WeaponId> unlockedWeaponIds;

  /// Unlocked throwing-weapon IDs.
  final Set<ProjectileId> unlockedThrowingWeaponIds;

  /// Unlocked spellbook IDs.
  final Set<SpellBookId> unlockedSpellBookIds;

  /// Unlocked accessory IDs.
  final Set<AccessoryId> unlockedAccessoryIds;

  /// Returns a copy with optional unlocked-set replacements.
  InventoryState copyWith({
    Set<WeaponId>? unlockedWeaponIds,
    Set<ProjectileId>? unlockedThrowingWeaponIds,
    Set<SpellBookId>? unlockedSpellBookIds,
    Set<AccessoryId>? unlockedAccessoryIds,
  }) {
    return InventoryState(
      unlockedWeaponIds: unlockedWeaponIds ?? this.unlockedWeaponIds,
      unlockedThrowingWeaponIds:
          unlockedThrowingWeaponIds ?? this.unlockedThrowingWeaponIds,
      unlockedSpellBookIds: unlockedSpellBookIds ?? this.unlockedSpellBookIds,
      unlockedAccessoryIds: unlockedAccessoryIds ?? this.unlockedAccessoryIds,
    );
  }

  /// Serializes unlocked sets as enum-name arrays.
  Map<String, Object?> toJson() {
    return <String, Object?>{
      'weapons': unlockedWeaponIds.map((e) => e.name).toList(growable: false),
      'throwingWeapons': unlockedThrowingWeaponIds
          .map((e) => e.name)
          .toList(growable: false),
      'spellBooks': unlockedSpellBookIds
          .map((e) => e.name)
          .toList(growable: false),
      'accessories': unlockedAccessoryIds
          .map((e) => e.name)
          .toList(growable: false),
    };
  }

  /// Deserializes unlocked sets with per-domain fallback guards.
  static InventoryState fromJson(
    Map<String, dynamic> json, {
    required InventoryState fallback,
  }) {
    return InventoryState(
      unlockedWeaponIds: _readEnumSet(
        json['weapons'],
        WeaponId.values,
        fallback.unlockedWeaponIds,
      ),
      unlockedThrowingWeaponIds: _readEnumSet(
        json['throwingWeapons'],
        ProjectileId.values,
        fallback.unlockedThrowingWeaponIds,
      ),
      unlockedSpellBookIds: _readEnumSet(
        json['spellBooks'],
        SpellBookId.values,
        fallback.unlockedSpellBookIds,
      ),
      unlockedAccessoryIds: _readEnumSet(
        json['accessories'],
        AccessoryId.values,
        fallback.unlockedAccessoryIds,
      ),
    );
  }
}

/// Reads a set of enum names from dynamic JSON payload.
///
/// Returns [fallback] when the payload is absent/invalid, or when parsing
/// yields an empty set (to avoid clearing inventory on malformed data).
Set<T> _readEnumSet<T extends Enum>(
  Object? raw,
  List<T> values,
  Set<T> fallback,
) {
  if (raw is! List) return fallback;
  final result = <T>{};
  for (final item in raw) {
    if (item is! String) continue;
    for (final value in values) {
      if (value.name == item) {
        result.add(value);
        break;
      }
    }
  }
  return result.isEmpty ? fallback : result;
}


===== FILE: lib/core/meta/meta_defaults.dart =====
import '../accessories/accessory_id.dart';
import '../projectiles/projectile_id.dart';
import '../spellBook/spell_book_id.dart';
import '../weapons/weapon_id.dart';
import 'equipped_gear.dart';

/// Default gear IDs used for new profiles and normalization fallback.
///
/// Keep these IDs valid and unlocked in baseline inventory rules.
class MetaDefaults {
  const MetaDefaults._();

  /// Default main-hand weapon.
  static const WeaponId mainWeaponId = WeaponId.woodenSword;

  /// Default off-hand weapon.
  static const WeaponId offhandWeaponId = WeaponId.woodenShield;

  /// Default throwing weapon.
  static const ProjectileId throwingWeaponId = ProjectileId.throwingKnife;

  /// Default spellbook.
  static const SpellBookId spellBookId = SpellBookId.basicSpellBook;

  /// Default accessory.
  static const AccessoryId accessoryId = AccessoryId.speedBoots;

  /// Canonical default equipped set.
  static const EquippedGear equippedGear = EquippedGear(
    mainWeaponId: mainWeaponId,
    offhandWeaponId: offhandWeaponId,
    throwingWeaponId: throwingWeaponId,
    spellBookId: spellBookId,
    accessoryId: accessoryId,
  );
}


===== FILE: lib/core/meta/meta_service.dart =====
import '../accessories/accessory_catalog.dart';
import '../accessories/accessory_id.dart';
import '../abilities/ability_def.dart' show WeaponType;
import '../projectiles/projectile_catalog.dart';
import '../projectiles/projectile_id.dart';
import '../spellBook/spell_book_catalog.dart';
import '../spellBook/spell_book_id.dart';
import '../weapons/weapon_catalog.dart';
import '../weapons/weapon_category.dart';
import '../weapons/weapon_id.dart';
import 'equipped_gear.dart';
import 'gear_slot.dart';
import 'inventory_state.dart';
import 'meta_defaults.dart';
import 'meta_state.dart';
import '../players/player_character_definition.dart';

/// Slot candidate DTO consumed by gear picker UI.
///
/// [id] type depends on the queried [GearSlot].
class GearSlotCandidate {
  const GearSlotCandidate({required this.id, required this.isUnlocked});

  /// Typed gear id for the requested slot domain.
  final Object id;

  /// Whether this candidate is currently unlocked for use/equip.
  final bool isUnlocked;
}

/// Domain service for meta inventory, unlock rules, and equip validation.
class MetaService {
  /// Number of starting unlocks granted per catalog domain.
  static const int _startingUnlockedPerCatalog = 2;

  const MetaService({
    this.weapons = const WeaponCatalog(),
    this.projectiles = const ProjectileCatalog(),
    this.spellBooks = const SpellBookCatalog(),
    this.accessories = const AccessoryCatalog(),
  });

  /// Weapon catalog dependency.
  final WeaponCatalog weapons;

  /// Projectile item catalog dependency.
  final ProjectileCatalog projectiles;

  /// Spellbook catalog dependency.
  final SpellBookCatalog spellBooks;

  /// Accessory catalog dependency.
  final AccessoryCatalog accessories;

  /// Seeds initial inventory according to startup unlock policy.
  InventoryState seedAllUnlockedInventory() {
    return InventoryState(
      unlockedWeaponIds: _startingUnlockedWeaponIds(),
      unlockedThrowingWeaponIds: _startingUnlockedThrowingWeaponIds(),
      unlockedSpellBookIds: _startingUnlockedSpellBookIds(),
      unlockedAccessoryIds: _startingUnlockedAccessoryIds(),
    );
  }

  /// Returns starter unlocked main/off-hand weapon IDs.
  Set<WeaponId> _startingUnlockedWeaponIds() {
    final unlockedPrimaryWeapons = <WeaponId>[];
    final unlockedOffhandWeapons = <WeaponId>[];
    for (final id in WeaponId.values) {
      final def = weapons.tryGet(id);
      if (def == null) continue;
      switch (def.category) {
        case WeaponCategory.primary:
          unlockedPrimaryWeapons.add(id);
          break;
        case WeaponCategory.offHand:
          unlockedOffhandWeapons.add(id);
          break;
        case WeaponCategory.projectile:
          break;
      }
    }

    return <WeaponId>{
      ...unlockedPrimaryWeapons.take(_startingUnlockedPerCatalog),
      ...unlockedOffhandWeapons.take(_startingUnlockedPerCatalog),
    };
  }

  /// Returns starter unlocked throwing weapon IDs.
  Set<ProjectileId> _startingUnlockedThrowingWeaponIds() {
    final unlockedThrowingCandidates = <ProjectileId>[];
    for (final id in ProjectileId.values) {
      final def = projectiles.tryGet(id);
      if (def != null && def.weaponType == WeaponType.throwingWeapon) {
        unlockedThrowingCandidates.add(id);
      }
    }

    return unlockedThrowingCandidates.take(_startingUnlockedPerCatalog).toSet();
  }

  /// Returns starter unlocked spellbook IDs.
  Set<SpellBookId> _startingUnlockedSpellBookIds() {
    return SpellBookId.values.take(_startingUnlockedPerCatalog).toSet();
  }

  /// Returns starter unlocked accessory IDs.
  Set<AccessoryId> _startingUnlockedAccessoryIds() {
    return AccessoryId.values.take(_startingUnlockedPerCatalog).toSet();
  }

  /// Creates a new normalized meta state for first-time users.
  MetaState createNew() {
    return normalize(
      MetaState.seedAllUnlocked(inventory: seedAllUnlockedInventory()),
    );
  }

  /// Returns all candidates for [slot], including locked entries.
  List<GearSlotCandidate> candidatesForSlot(MetaState state, GearSlot slot) {
    return switch (slot) {
      GearSlot.mainWeapon => _weaponCandidatesForCategory(
        state,
        WeaponCategory.primary,
      ),
      GearSlot.offhandWeapon => _weaponCandidatesForCategory(
        state,
        WeaponCategory.offHand,
      ),
      GearSlot.throwingWeapon => _throwingWeaponCandidates(state),
      GearSlot.spellBook => _spellBookCandidates(state),
      GearSlot.accessory => _accessoryCandidates(state),
    };
  }

  /// Builds weapon candidates for [category] with unlock markers.
  List<GearSlotCandidate> _weaponCandidatesForCategory(
    MetaState state,
    WeaponCategory category,
  ) {
    final unlocked = state.inventory.unlockedWeaponIds;
    final result = <GearSlotCandidate>[];
    for (final id in WeaponId.values) {
      final def = weapons.tryGet(id);
      if (def == null || def.category != category) continue;
      result.add(GearSlotCandidate(id: id, isUnlocked: unlocked.contains(id)));
    }
    return result;
  }

  /// Builds throwing-weapon candidates only.
  List<GearSlotCandidate> _throwingWeaponCandidates(MetaState state) {
    final unlocked = state.inventory.unlockedThrowingWeaponIds;
    final result = <GearSlotCandidate>[];
    for (final id in ProjectileId.values) {
      final def = projectiles.tryGet(id);
      if (def == null || def.weaponType != WeaponType.throwingWeapon) {
        continue;
      }
      result.add(GearSlotCandidate(id: id, isUnlocked: unlocked.contains(id)));
    }
    return result;
  }

  /// Builds spellbook candidates with unlock markers.
  List<GearSlotCandidate> _spellBookCandidates(MetaState state) {
    final unlocked = state.inventory.unlockedSpellBookIds;
    return [
      for (final id in SpellBookId.values)
        GearSlotCandidate(id: id, isUnlocked: unlocked.contains(id)),
    ];
  }

  /// Builds accessory candidates with unlock markers.
  List<GearSlotCandidate> _accessoryCandidates(MetaState state) {
    final unlocked = state.inventory.unlockedAccessoryIds;
    return [
      for (final id in AccessoryId.values)
        GearSlotCandidate(id: id, isUnlocked: unlocked.contains(id)),
    ];
  }

  /// Normalizes persisted state to current rules and fallback guarantees.
  ///
  /// Enforces:
  /// - startup unlock ceilings per domain
  /// - default items always unlocked
  /// - equipped gear always valid and unlocked
  MetaState normalize(MetaState state) {
    var inventory = state.inventory;
    final allowedWeapons = _startingUnlockedWeaponIds();
    final allowedThrowingWeapons = _startingUnlockedThrowingWeaponIds();
    final allowedSpellBooks = _startingUnlockedSpellBookIds();
    final allowedAccessories = _startingUnlockedAccessoryIds();

    final unlockedWeapons = Set<WeaponId>.from(inventory.unlockedWeaponIds)
      ..removeWhere((id) => !allowedWeapons.contains(id))
      ..add(MetaDefaults.mainWeaponId)
      ..add(MetaDefaults.offhandWeaponId);
    final unlockedThrowing =
        Set<ProjectileId>.from(inventory.unlockedThrowingWeaponIds)
          ..removeWhere((id) => !allowedThrowingWeapons.contains(id))
          ..add(MetaDefaults.throwingWeaponId);
    final unlockedSpellBooks = Set<SpellBookId>.from(
      inventory.unlockedSpellBookIds,
    );
    unlockedSpellBooks
      ..removeWhere((id) => !allowedSpellBooks.contains(id))
      ..add(MetaDefaults.spellBookId);
    final unlockedAccessories =
        Set<AccessoryId>.from(inventory.unlockedAccessoryIds)
          ..removeWhere((id) => !allowedAccessories.contains(id))
          ..add(MetaDefaults.accessoryId);

    inventory = inventory.copyWith(
      unlockedWeaponIds: unlockedWeapons,
      unlockedThrowingWeaponIds: unlockedThrowing,
      unlockedSpellBookIds: unlockedSpellBooks,
      unlockedAccessoryIds: unlockedAccessories,
    );

    final equippedByCharacter = <PlayerCharacterId, EquippedGear>{};
    for (final id in PlayerCharacterId.values) {
      final gear = state.equippedFor(id);
      equippedByCharacter[id] = _normalizeEquipped(gear, inventory);
    }

    return state.copyWith(
      schemaVersion: MetaState.latestSchemaVersion,
      inventory: inventory,
      equippedByCharacter: equippedByCharacter,
    );
  }

  /// Validates and repairs a single character loadout against [inventory].
  EquippedGear _normalizeEquipped(EquippedGear gear, InventoryState inventory) {
    var mainWeaponId = gear.mainWeaponId;
    final mainDef = weapons.tryGet(mainWeaponId);
    if (mainDef == null ||
        mainDef.category != WeaponCategory.primary ||
        !inventory.unlockedWeaponIds.contains(mainWeaponId)) {
      mainWeaponId = MetaDefaults.mainWeaponId;
    }

    var offhandWeaponId = gear.offhandWeaponId;
    final offDef = weapons.tryGet(offhandWeaponId);
    if (offDef == null ||
        offDef.category != WeaponCategory.offHand ||
        !inventory.unlockedWeaponIds.contains(offhandWeaponId)) {
      offhandWeaponId = MetaDefaults.offhandWeaponId;
    }

    var throwingWeaponId = gear.throwingWeaponId;
    final throwingDef = projectiles.tryGet(throwingWeaponId);
    if (throwingDef == null ||
        throwingDef.weaponType != WeaponType.throwingWeapon ||
        !inventory.unlockedThrowingWeaponIds.contains(throwingWeaponId)) {
      throwingWeaponId = MetaDefaults.throwingWeaponId;
    }

    var spellBookId = gear.spellBookId;
    if (spellBooks.tryGet(spellBookId) == null ||
        !inventory.unlockedSpellBookIds.contains(spellBookId)) {
      spellBookId = MetaDefaults.spellBookId;
    }

    var accessoryId = gear.accessoryId;
    if (!inventory.unlockedAccessoryIds.contains(accessoryId)) {
      accessoryId = MetaDefaults.accessoryId;
    }

    return EquippedGear(
      mainWeaponId: mainWeaponId,
      offhandWeaponId: offhandWeaponId,
      throwingWeaponId: throwingWeaponId,
      spellBookId: spellBookId,
      accessoryId: accessoryId,
    );
  }

  /// Legacy helper: unlocked primary weapons only.
  List<WeaponId> unlockedMainWeapons(MetaState state) {
    final result = <WeaponId>[];
    for (final id in state.inventory.unlockedWeaponIds) {
      final def = weapons.tryGet(id);
      if (def != null && def.category == WeaponCategory.primary) {
        result.add(id);
      }
    }
    result.sort((a, b) => a.index.compareTo(b.index));
    return result;
  }

  /// Legacy helper: unlocked off-hand weapons only.
  List<WeaponId> unlockedOffhands(MetaState state) {
    final result = <WeaponId>[];
    for (final id in state.inventory.unlockedWeaponIds) {
      final def = weapons.tryGet(id);
      if (def != null && def.category == WeaponCategory.offHand) {
        result.add(id);
      }
    }
    result.sort((a, b) => a.index.compareTo(b.index));
    return result;
  }

  /// Legacy helper: unlocked throwing weapons only.
  List<ProjectileId> unlockedThrowingWeapons(MetaState state) {
    final result = state.inventory.unlockedThrowingWeaponIds.toList();
    result.sort((a, b) => a.index.compareTo(b.index));
    return result;
  }

  /// Legacy helper: unlocked spellbooks only.
  List<SpellBookId> unlockedSpellBooks(MetaState state) {
    final result = state.inventory.unlockedSpellBookIds.toList();
    result.sort((a, b) => a.index.compareTo(b.index));
    return result;
  }

  /// Legacy helper: unlocked accessories only.
  List<AccessoryId> unlockedAccessories(MetaState state) {
    final result = state.inventory.unlockedAccessoryIds.toList();
    result.sort((a, b) => a.index.compareTo(b.index));
    return result;
  }

  /// Attempts to equip [itemId] into [slot] for [characterId].
  ///
  /// Invalid item types/categories or locked items are ignored and return
  /// unchanged normalized state.
  MetaState equip(
    MetaState state, {
    required PlayerCharacterId characterId,
    required GearSlot slot,
    required Object itemId,
  }) {
    final normalized = normalize(state);
    final current = normalized.equippedFor(characterId);

    switch (slot) {
      case GearSlot.mainWeapon:
        if (itemId is! WeaponId) return normalized;
        final def = weapons.tryGet(itemId);
        if (def == null || def.category != WeaponCategory.primary) {
          return normalized;
        }
        if (!normalized.inventory.unlockedWeaponIds.contains(itemId)) {
          return normalized;
        }
        return normalized.setEquippedFor(
          characterId,
          current.copyWith(mainWeaponId: itemId),
        );
      case GearSlot.offhandWeapon:
        if (itemId is! WeaponId) return normalized;
        final def = weapons.tryGet(itemId);
        if (def == null || def.category != WeaponCategory.offHand) {
          return normalized;
        }
        if (!normalized.inventory.unlockedWeaponIds.contains(itemId)) {
          return normalized;
        }
        return normalized.setEquippedFor(
          characterId,
          current.copyWith(offhandWeaponId: itemId),
        );
      case GearSlot.throwingWeapon:
        if (itemId is! ProjectileId) return normalized;
        final def = projectiles.tryGet(itemId);
        if (def == null || def.weaponType != WeaponType.throwingWeapon) {
          return normalized;
        }
        if (!normalized.inventory.unlockedThrowingWeaponIds.contains(itemId)) {
          return normalized;
        }
        return normalized.setEquippedFor(
          characterId,
          current.copyWith(throwingWeaponId: itemId),
        );
      case GearSlot.spellBook:
        if (itemId is! SpellBookId) return normalized;
        if (spellBooks.tryGet(itemId) == null) return normalized;
        if (!normalized.inventory.unlockedSpellBookIds.contains(itemId)) {
          return normalized;
        }
        return normalized.setEquippedFor(
          characterId,
          current.copyWith(spellBookId: itemId),
        );
      case GearSlot.accessory:
        if (itemId is! AccessoryId) return normalized;
        if (!normalized.inventory.unlockedAccessoryIds.contains(itemId)) {
          return normalized;
        }
        return normalized.setEquippedFor(
          characterId,
          current.copyWith(accessoryId: itemId),
        );
    }
  }
}


===== FILE: lib/core/meta/meta_state.dart =====
import '../players/player_character_definition.dart';
import 'equipped_gear.dart';
import 'inventory_state.dart';
import 'meta_defaults.dart';

/// Persisted meta-progression state for gear inventory and loadouts.
class MetaState {
  const MetaState({
    required this.schemaVersion,
    required this.inventory,
    required this.equippedByCharacter,
  });

  /// Latest supported serialization schema.
  static const int latestSchemaVersion = 1;

  /// Serialized schema version of this instance.
  final int schemaVersion;

  /// Unlocked inventory sets across all gear domains.
  final InventoryState inventory;

  /// Equipped gear per playable character.
  final Map<PlayerCharacterId, EquippedGear> equippedByCharacter;

  /// Returns a copy with optional field replacements.
  MetaState copyWith({
    int? schemaVersion,
    InventoryState? inventory,
    Map<PlayerCharacterId, EquippedGear>? equippedByCharacter,
  }) {
    return MetaState(
      schemaVersion: schemaVersion ?? this.schemaVersion,
      inventory: inventory ?? this.inventory,
      equippedByCharacter: equippedByCharacter ?? this.equippedByCharacter,
    );
  }

  /// Reads equipped gear for [id], falling back to defaults when absent.
  EquippedGear equippedFor(PlayerCharacterId id) {
    return equippedByCharacter[id] ?? MetaDefaults.equippedGear;
  }

  /// Returns a copy with [gear] assigned to character [id].
  MetaState setEquippedFor(PlayerCharacterId id, EquippedGear gear) {
    final next = Map<PlayerCharacterId, EquippedGear>.from(equippedByCharacter);
    next[id] = gear;
    return copyWith(equippedByCharacter: next);
  }

  /// Serializes meta state as JSON-friendly maps/lists.
  Map<String, Object?> toJson() {
    return <String, Object?>{
      'schemaVersion': schemaVersion,
      'inventory': inventory.toJson(),
      'equippedByCharacter': <String, Object?>{
        for (final entry in equippedByCharacter.entries)
          entry.key.name: entry.value.toJson(),
      },
    };
  }

  /// Seeds a new state where all characters start with default equipped gear.
  static MetaState seedAllUnlocked({required InventoryState inventory}) {
    final equipped = <PlayerCharacterId, EquippedGear>{
      for (final id in PlayerCharacterId.values) id: MetaDefaults.equippedGear,
    };
    return MetaState(
      schemaVersion: latestSchemaVersion,
      inventory: inventory,
      equippedByCharacter: equipped,
    );
  }

  /// Deserializes from JSON with robust fallback behavior.
  ///
  /// Invalid/missing branches fall back to [fallback], then downstream
  /// normalization in [MetaService] enforces canonical invariants.
  static MetaState fromJson(
    Map<String, dynamic> json, {
    required MetaState fallback,
  }) {
    final schemaVersionRaw = json['schemaVersion'];
    final schemaVersion = schemaVersionRaw is int
        ? schemaVersionRaw
        : (schemaVersionRaw is num
              ? schemaVersionRaw.toInt()
              : fallback.schemaVersion);
    final inventoryRaw = json['inventory'];
    final inventory = inventoryRaw is Map<String, dynamic>
        ? InventoryState.fromJson(inventoryRaw, fallback: fallback.inventory)
        : (inventoryRaw is Map
              ? InventoryState.fromJson(
                  Map<String, dynamic>.from(inventoryRaw),
                  fallback: fallback.inventory,
                )
              : fallback.inventory);

    final equippedByCharacter = <PlayerCharacterId, EquippedGear>{};
    final equippedRaw = json['equippedByCharacter'];
    if (equippedRaw is Map) {
      for (final id in PlayerCharacterId.values) {
        final rawEntry = equippedRaw[id.name];
        if (rawEntry is Map<String, dynamic>) {
          equippedByCharacter[id] = EquippedGear.fromJson(
            rawEntry,
            fallback: MetaDefaults.equippedGear,
          );
        } else if (rawEntry is Map) {
          equippedByCharacter[id] = EquippedGear.fromJson(
            Map<String, dynamic>.from(rawEntry),
            fallback: MetaDefaults.equippedGear,
          );
        }
      }
    }

    // Ensure no character has an empty slot.
    for (final id in PlayerCharacterId.values) {
      equippedByCharacter.putIfAbsent(id, () => MetaDefaults.equippedGear);
    }

    return MetaState(
      schemaVersion: schemaVersion,
      inventory: inventory,
      equippedByCharacter: equippedByCharacter,
    );
  }
}


===== FILE: lib/core/navigation/REFACTOR_CHECKLIST.md =====
# Navigation Refactor Checklist

Date: 2026-02-20  
Scope: `lib/core/navigation/**` and direct runtime integrations that consume navigation outputs.

## Outcomes
- [x] NPC movement is fluid: no takeoff jitter, no repeated failed jumps, no ledge oscillation.
- [x] Navigation stays deterministic across identical seeds and inputs.
- [x] Core hot paths remain allocation-light and analyzer-clean.

## Phase 0: Baseline and Guardrails
- [x] Re-run and freeze current navigation test baseline.
- [x] Add a short note in PR/commit about expected behavior changes before starting migration.
- [x] Define test scenes for: narrow ledges, low ceilings, wall-blocked jumps, long surfaces, high-speed drop approach.

Acceptance criteria:
- [x] Existing navigation tests pass before refactor.
- [x] Refactor branch has explicit before/after expectations for changed behaviors.

## Phase 1: Contracts and Data Integrity
Target files: `surface_extractor.dart`, `types/surface_id.dart`, geometry ingest path.

- [x] Replace fixed `groundPieceStride` ID math with collision-safe encoding for `(localSegmentIndex, pieceIndex)`.
- [x] Add surface-ID uniqueness assert/check during extraction.
- [x] Enforce `groundSegments` contract at ingest: sorted, disjoint, and valid ranges.
- [x] Add/extend tests for ID uniqueness under heavy ground splitting.
- [x] Add signed round-trip tests for negative chunk indices in surface ID pack/unpack.

Acceptance criteria:
- [x] No ID collisions in stress tests.
- [x] Invalid authored/base `groundSegments` fail fast with clear error.
- [x] `surface_id` tests pass for `chunkIndex` in `-2, -1, 0, 1`.

## Phase 2: Standability Semantics Migration
Target files: `surface_navigator.dart`, `utils/trajectory_predictor.dart`.

- [x] Replace partial-overlap checks with standable-range checks (`xMin + halfWidth`, `xMax - halfWidth`).
- [x] Apply the same standability rule in both surface locator and landing predictor.
- [x] Remove temporary relaxed landing behavior once replacement is validated.
- [x] Add tests covering narrow surfaces and ledge-adjacent ownership stability.

Acceptance criteria:
- [x] Surface ownership does not flap near edges on stable inputs.
- [x] Trajectory prediction and navigator agree on standable surfaces.

## Phase 3: Drop Takeoff Robustness
Target files: `surface_navigator.dart`.

- [x] Add directional “at or past takeoff” logic for drop edges (matching jump robustness).
- [x] Keep commit direction active while approaching drop takeoff.
- [x] Add high-speed overshoot tests for both left and right drops.

Acceptance criteria:
- [x] No back-and-forth oscillation near drop ledges at high speed.
- [x] Drop execution remains deterministic and does not regress current commit behavior.

## Phase 4: Jump Edge Obstruction Validation
Target files: `surface_graph_builder.dart`, `utils/jump_template.dart` (or new helper).

- [x] Validate jump arc clearance against static blockers before emitting jump edges.
- [x] Reject edges blocked by ceilings/walls before landing.
- [x] Keep deterministic edge ordering after adding obstruction checks.
- [x] Add tests for blocked jumps (ceiling and side-wall cases).

Acceptance criteria:
- [x] Graph does not include physically impossible jump edges.
- [x] Enemies stop attempting jump edges that always fail at runtime collision.

## Phase 5: Position-Aware Pathfinding
Target files: `surface_pathfinder.dart` (+ tests).

- [x] Replace center-X approximation on intermediate surfaces with position-aware state/costing.
- [x] Ensure transition cost uses predecessor arrival position (or equivalent state anchor).
- [x] Preserve deterministic tie-break ordering for equal-cost alternatives.
- [x] Add tests for route choice where arrival X changes optimal next edge.

Acceptance criteria:
- [x] Paths no longer include avoidable backtracking caused by center-X approximation.
- [x] Deterministic path output is stable across repeated runs.

## Phase 6: Trajectory Predictor Quality and Performance
Target files: `utils/trajectory_predictor.dart`.

- [x] Add horizontal sweep (`prevX -> x`) when querying landing candidates.
- [x] Reuse candidate buffers to remove per-call allocations in hot path.
- [x] Add tests for high `velX` over thin platforms.

Acceptance criteria:
- [x] Predictor catches landings that were previously skipped at high horizontal speed.
- [x] No per-call list allocation in predictor hot path.

## Phase 7: Integration, Tuning, and Rollout
Target files: `enemy_navigation_system.dart`, `ground_enemy_locomotion_system.dart`, tuning docs/files as needed.

- [x] Re-tune `repathCooldownTicks`, `takeoffEps`, and related thresholds after behavior changes.
- [x] Validate interaction with jump snap velocity and commit direction in locomotion.
- [x] Run full nav-related tests plus targeted gameplay sanity checks.
- [x] Update `REVIEW.md` with completion status and residual risks.

Acceptance criteria:
- [x] NPC chase behavior is smoother in practical scenarios (jump chase, ledge chase, multi-platform pursuit).
- [x] No analyzer issues in touched files.
- [x] No deterministic regressions observed in repeated test runs.

## Definition of Done
- [x] All phase acceptance criteria are met.
- [x] Navigation-related tests pass.
- [x] `dart analyze lib/core/navigation` passes.
- [x] Updated documentation reflects final contracts and behavior.


===== FILE: lib/core/navigation/REVIEW.md =====
# Navigation Review (2026-02-20)

Scope: `lib/core/navigation/**` with runtime touchpoints in `lib/core/ecs/systems/enemy_navigation_system.dart` and `lib/core/ecs/systems/ground_enemy_locomotion_system.dart`.

Validation run:
- `flutter test test/core/jump_template_test.dart test/core/surface_extraction_test.dart test/core/surface_graph_builder_test.dart test/core/surface_navigator_commit_dir_inflight_test.dart test/core/surface_navigator_graph_version_test.dart test/core/surface_pathfinder_test.dart test/core/trajectory_predictor_test.dart` (all passed)
- `flutter test test/core/ground_enemy_locomotion_jump_snap_test.dart test/core/ground_enemy_jump_test.dart test/core/ground_enemy_gap_jump_test.dart test/core/ground_enemy_drop_test.dart test/core/ground_enemy_gap_multi_test.dart test/core/ground_enemy_obstacle_jump_test.dart test/core/ground_enemy_ignore_ceilings_test.dart test/core/surface_navigator_takeoff_and_standability_test.dart test/core/surface_navigator_commit_dir_inflight_test.dart test/core/surface_navigator_graph_version_test.dart test/core/surface_graph_builder_test.dart test/core/surface_pathfinder_test.dart test/core/trajectory_predictor_test.dart test/core/surface_extraction_test.dart test/core/surface_id_test.dart test/core/static_world_geometry_index_contract_test.dart` (all passed)
- `dart analyze lib/core/navigation` (no issues)
- `dart analyze lib/core/navigation lib/core/tuning/navigation_tuning.dart test/core/ground_enemy_locomotion_jump_snap_test.dart` (no issues)

## Clarifications (follow-up)
- Partial-overlap landing is confirmed as a temporary simplification, not a long-term target behavior.
- `groundSegments` should be guaranteed pre-split/disjoint by contract.
  - Streamed chunk generation already does this: `lib/core/track/chunk_builder.dart:102`.
  - Overlap/order is guarded in chunk generation: `lib/core/track/chunk_builder.dart:142`.
  - Core currently trusts provided segments when present: `lib/core/collision/static_world_geometry_index.dart:232`.
  - Query logic assumes sorted/disjoint segments: `lib/core/collision/static_world_geometry_index.dart:210`.
  - Base + streamed segments are concatenated directly: `lib/core/track_manager.dart:273`.

## Findings (ordered by severity)

### 1) High: Jump graph can emit physically impossible edges (ceiling/wall not validated)
Evidence:
- `lib/core/navigation/surface_graph_builder.dart:209`
- `lib/core/navigation/surface_graph_builder.dart:217`
- `lib/core/navigation/utils/jump_template.dart:164`

Why this hurts fluidity:
- Reachability is currently checked by `dy/dx` only, without obstacle clearance along the arc.
- NPCs can select jump edges that look valid in graph space but fail in runtime collision, causing repeated retries, stalls, and twitchy retarget behavior.

Recommended fix:
- Add arc collision validation during jump-edge generation (sampled swept collider against static tops/walls/ceilings).
- Reject edges whose trajectory intersects blocking geometry before landing.
- Add tests with overhead ceilings and side walls to ensure impossible jumps are never emitted.

### 2) High: A* cost model loses position context on intermediate surfaces
Evidence:
- `lib/core/navigation/surface_pathfinder.dart:169`
- `lib/core/navigation/surface_pathfinder.dart:180`

Why this hurts fluidity:
- After the first hop, run-to-takeoff cost is measured from `surface.centerX`, not from actual arrival position (`landingX`) of the previous edge.
- This can choose routes that are optimal in the abstract graph but require extra backtracking in execution, making NPC movement look indecisive.

Recommended fix:
- Upgrade search state from `surfaceIndex` to position-aware state (for example, `(surfaceIndex, anchorBucket)` or exact `arrivalX`).
- At minimum, carry predecessor `landingX` into transition-cost evaluation for neighbor scoring.

### 3) High: Ground segment ID generation can collide under heavy splitting
Evidence:
- `lib/core/navigation/surface_extractor.dart:38`
- `lib/core/navigation/surface_extractor.dart:116`

Why this hurts fluidity:
- Ground piece IDs are generated with a fixed stride (`localSegmentIndex * 1000 + i`).
- If a segment splits into many pieces, IDs can collide with other segments, which can corrupt `indexById` mapping and destabilize path/target lookups.

Recommended fix:
- Replace stride math with explicit bit packing of `(localSegmentIndex, pieceIndex)` into non-overlapping ranges.
- Add a debug assert that extracted surface IDs are unique per build.
- Reinforce the pre-split/disjoint `groundSegments` contract with ingest-time validation for authored/base geometry.

### 4) Medium: Drop takeoff logic is less robust than jump takeoff logic
Evidence:
- `lib/core/navigation/surface_navigator.dart:292`
- `lib/core/navigation/surface_navigator.dart:309`
- `lib/core/navigation/surface_navigator.dart:317`

Why this hurts fluidity:
- Jump activation supports “at or past takeoff” checks with commit direction.
- Drop activation still relies on symmetric distance-to-takeoff checks and does not apply commit direction during approach.
- At higher horizontal speeds this can produce overshoot and correction oscillation near ledges.

Recommended fix:
- Apply the same directional “past-takeoff” gate to drop edges.
- Keep commit direction enabled while approaching drop takeoff, not only after activation.

### 5) Medium: Surface detection and trajectory landing allow partial overlap instead of standable fit
Evidence:
- `lib/core/navigation/surface_navigator.dart:357`
- `lib/core/navigation/utils/trajectory_predictor.dart:173`

Why this hurts fluidity:
- Current checks accept any horizontal overlap, even if collider width does not fully fit on the surface.
- Near ledges and narrow platforms, this can flip surface ownership and landing predictions, leading to repath churn and jitter.

Recommended fix:
- Use standable range checks (`surface.xMin + halfWidth` to `surface.xMax - halfWidth`) consistently in locator and predictor.
- Because partial-overlap is temporary, migrate both call sites together and remove relaxed behavior once validated.

### 6) Medium: Trajectory predictor can miss thin platforms at high horizontal speed
Evidence:
- `lib/core/navigation/utils/trajectory_predictor.dart:112`
- `lib/core/navigation/utils/trajectory_predictor.dart:152`

Why this hurts fluidity:
- Landing queries sample only at current `x` each tick, with a vertical sweep, but no horizontal sweep between previous and current x.
- Fast lateral motion can skip narrow platforms in prediction, causing poor interception behavior.

Recommended fix:
- Sweep query AABB across both `prevX` and `x`, then resolve earliest valid crossing.
- Add tests for high `velX` with narrow platforms.

### 7) Medium: Hot-path allocation in trajectory prediction
Evidence:
- `lib/core/navigation/utils/trajectory_predictor.dart:104`

Why this hurts fluidity:
- `final candidates = <int>[];` allocates per prediction call.
- Enemy navigation runs every tick; repeated allocations increase GC pressure and can manifest as micro-stutter.

Recommended fix:
- Move candidate buffer to an instance field and clear/reuse it each call.

### 8) Low: Packed ID unpacking is incorrect for negative chunk indices
Evidence:
- `lib/core/navigation/types/surface_id.dart:48`
- `lib/core/navigation/types/surface_id.dart:50`

Why this matters:
- `unpackChunkIndex` returns unsigned values for negative chunks (`-1` becomes `4294967295`).
- This is currently low runtime impact because unpacking is rarely used, but it is a correctness bug in ID utilities.

Recommended fix:
- Sign-extend after unpack or use signed 32-bit decode helper.
- Add tests for `chunkIndex` values `-2`, `-1`, `0`, `1`.

## Current strengths
- Deterministic ordering/tie-break practices are consistently applied in graph build and pathfinding.
- Good baseline test coverage exists for extraction, graph build, pathfinding, navigator version invalidation, and trajectory prediction.
- Navigation data is cleanly separated from Flame/Flutter and stays in Core.

## Highest-value implementation order
1. Add jump arc obstruction validation in `SurfaceGraphBuilder` (Finding 1).
2. Make pathfinding position-aware (Finding 2).
3. Harden surface ownership/landing checks to require standable fit (Finding 5).
4. Improve drop activation robustness (Finding 4).
5. Clean up correctness/perf issues: ID collisions, predictor allocations, signed unpack (Findings 3, 7, 8).

## Suggested test additions
- Impossible jump rejection under ceiling/wall blockers.
- Position-aware routing preference tests (same surface, different arrivalX).
- Drop takeoff overshoot test at high speed.
- Standability-required surface locator and trajectory landing tests.
- Surface ID uniqueness test on heavily split ground segments.
- Negative chunk unpack round-trip tests.

## Refactor status (2026-02-20)
- Completed:
  - Ground ID safety + signed chunk unpack + provided `groundSegments` contract validation.
  - Standability migration for surface location and trajectory landing.
  - Drop takeoff robustness (directional past-takeoff + commit direction during approach).
  - Jump edge obstruction filtering (ceiling/wall blockers), with collision-capability flags on `JumpProfile`.
  - Position-aware intermediate path costs using predecessor `landingX`.
  - Trajectory predictor sweep/perf improvements.
  - Integration retune: reduced default replan cooldown to `12` ticks (~200 ms at 60 Hz), and raised baseline takeoff epsilon to `4.0` for non-overridden users.
  - Locomotion validation for jump snap + commit direction (`test/core/ground_enemy_locomotion_jump_snap_test.dart`).
- Post-plan follow-up (manual validation):
  - Run a live gameplay feel pass in the Flame scene (camera pressure + mixed enemy packs) to confirm no over-planning CPU spikes at higher concurrent enemy counts.

## Residual risks
- Retuned default `repathCooldownTicks` improves responsiveness but increases A* frequency; very high enemy counts may need per-level overrides.
- Automated tests validate deterministic behavior and edge handling; final subjective "naturalness" still requires manual feel-testing in play sessions.


===== FILE: lib/core/navigation/surface_extractor.dart =====
import '../collision/static_world_geometry.dart';
import 'types/nav_tolerances.dart';
import 'types/surface_id.dart';
import 'types/walk_surface.dart';

/// Extracts [WalkSurface]s from tile-based world geometry.
///
/// **Pipeline**:
/// 1. Collect top faces of solid tiles as raw segments.
/// 2. Process ground layer (explicit segments or infinite plane).
/// 3. Subtract blockers (solids/gaps) from ground.
/// 4. Sort and merge adjacent coplanar segments.
///
/// **ID Assignment**:
/// Each surface gets a unique ID via [packSurfaceId], encoding chunk and local
/// indices. This enables stable references across graph rebuilds.
class SurfaceExtractor {
  SurfaceExtractor({
    // Use a pixel-ish tolerance by default to avoid fragmenting surfaces due to
    // tiny seams (chunk boundaries, floating error, inclusive/exclusive edges).
    this.mergeEps = navSpatialEps,
    this.groundPadding = 1024.0,
  });

  /// Tolerance for merging adjacent segments (pixels).
  final double mergeEps;

  /// Horizontal padding beyond world bounds for ground plane fallback.
  final double groundPadding;

  /// Extracts walkable surfaces from [geometry].
  ///
  /// **Returns**: Unmodifiable list of [WalkSurface]s, sorted and merged.
  List<WalkSurface> extract(StaticWorldGeometry geometry) {
    final segments = <_SurfaceSegment>[];
    final nextGroundLocalIndexByChunk = <int, int>{};

    void reserveGroundLocalSpace(int chunkIndex, int localSolidIndex) {
      final candidateNext = localSolidIndex + 1;
      final currentNext = nextGroundLocalIndexByChunk[chunkIndex];
      if (currentNext == null || candidateNext > currentNext) {
        nextGroundLocalIndexByChunk[chunkIndex] = candidateNext;
      }
    }

    int allocateGroundLocalIndex(int chunkIndex) {
      final next = nextGroundLocalIndexByChunk[chunkIndex] ?? 0;
      nextGroundLocalIndexByChunk[chunkIndex] = next + 1;
      return next;
    }

    // -------------------------------------------------------------------------
    // Step 1: Collect solid top faces.
    // -------------------------------------------------------------------------
    var minX = double.infinity;
    var maxX = double.negativeInfinity;
    for (var i = 0; i < geometry.solids.length; i += 1) {
      final solid = geometry.solids[i];

      // Track world bounds for ground plane fallback.
      if (solid.minX < minX) minX = solid.minX;
      if (solid.maxX > maxX) maxX = solid.maxX;

      // Only include solids with a walkable top face.
      if ((solid.sides & StaticSolid.sideTop) == 0) continue;

      var localSolidIndex = solid.localSolidIndex;
      if (localSolidIndex < 0) {
        if (solid.chunkIndex != StaticSolid.noChunk) {
          throw StateError(
            'Chunk solid is missing a localSolidIndex; check track streamer.',
          );
        }
        // Non-chunk solid: use array index as fallback.
        localSolidIndex = i;
      }

      reserveGroundLocalSpace(solid.chunkIndex, localSolidIndex);

      final id = packSurfaceId(
        chunkIndex: solid.chunkIndex,
        localSolidIndex: localSolidIndex,
      );
      segments.add(
        _SurfaceSegment(
          id: id,
          xMin: solid.minX,
          xMax: solid.maxX,
          yTop: solid.minY,
        ),
      );
    }

    // -------------------------------------------------------------------------
    // Step 2: Process ground layer.
    // -------------------------------------------------------------------------
    if (geometry.groundSegments.isNotEmpty) {
      // Explicit ground segments (from level data).
      for (var gi = 0; gi < geometry.groundSegments.length; gi += 1) {
        final ground = geometry.groundSegments[gi];
        if (ground.localSegmentIndex < 0 &&
            ground.chunkIndex != StaticSolid.noChunk) {
          throw StateError(
            'Ground segment is missing a localSegmentIndex; check track streamer.',
          );
        }

        // Subtract solids that block the ground at this Y.
        final blockers = _collectGroundBlockers(
          geometry.solids,
          const <StaticGroundGap>[],
          ground.topY,
          mergeEps,
        );
        final groundSegments = _subtractRanges(
          ground.minX,
          ground.maxX,
          blockers,
          mergeEps,
        );

        // Create surface for each unblocked portion.
        for (var i = 0; i < groundSegments.length; i += 1) {
          final seg = groundSegments[i];
          final id = packSurfaceId(
            chunkIndex: ground.chunkIndex,
            localSolidIndex: allocateGroundLocalIndex(ground.chunkIndex),
          );
          segments.add(
            _SurfaceSegment(
              id: id,
              xMin: seg.min,
              xMax: seg.max,
              yTop: ground.topY,
            ),
          );
        }
      }
    } else {
      // Infinite ground plane fallback.
      final groundPlane = geometry.groundPlane;
      if (groundPlane != null) {
        final baseMinX = minX.isFinite ? minX : 0.0;
        final baseMaxX = maxX.isFinite ? maxX : 0.0;
        final groundMinX = baseMinX - groundPadding;
        final groundMaxX = baseMaxX + groundPadding;

        final blockers = _collectGroundBlockers(
          geometry.solids,
          geometry.groundGaps,
          groundPlane.topY,
          mergeEps,
        );
        final groundSegments = _subtractRanges(
          groundMinX,
          groundMaxX,
          blockers,
          mergeEps,
        );

        for (var i = 0; i < groundSegments.length; i += 1) {
          final seg = groundSegments[i];
          segments.add(
            _SurfaceSegment(
              id: packSurfaceId(
                chunkIndex: StaticSolid.groundChunk,
                localSolidIndex: allocateGroundLocalIndex(
                  StaticSolid.groundChunk,
                ),
              ),
              xMin: seg.min,
              xMax: seg.max,
              yTop: groundPlane.topY,
            ),
          );
        }
      }
    }

    if (segments.isEmpty) {
      return const <WalkSurface>[];
    }

    _assertUniqueSegmentIds(segments);

    // -------------------------------------------------------------------------
    // Step 3: Sort and merge adjacent coplanar segments.
    // -------------------------------------------------------------------------
    segments.sort(_compareSegments);

    final merged = <WalkSurface>[];
    var current = segments.first;
    for (var i = 1; i < segments.length; i += 1) {
      final next = segments[i];
      final sameY = (next.yTop - current.yTop).abs() <= mergeEps;
      final touches = next.xMin <= current.xMax + mergeEps;

      if (sameY && touches) {
        // Extend current segment to include next.
        if (next.xMax > current.xMax) {
          current = current.copyWith(xMax: next.xMax);
        }
      } else {
        // Flush current, start new segment.
        merged.add(
          WalkSurface(
            id: current.id,
            xMin: current.xMin,
            xMax: current.xMax,
            yTop: current.yTop,
          ),
        );
        current = next;
      }
    }

    // Flush final segment.
    merged.add(
      WalkSurface(
        id: current.id,
        xMin: current.xMin,
        xMax: current.xMax,
        yTop: current.yTop,
      ),
    );

    return List<WalkSurface>.unmodifiable(merged);
  }
}

// =============================================================================
// Internal types
// =============================================================================

/// Intermediate segment representation before merging.
class _SurfaceSegment {
  const _SurfaceSegment({
    required this.id,
    required this.xMin,
    required this.xMax,
    required this.yTop,
  });

  /// Packed surface ID (see [packSurfaceId]).
  final int id;

  /// Left edge X coordinate.
  final double xMin;

  /// Right edge X coordinate.
  final double xMax;

  /// Top Y coordinate (walking height).
  final double yTop;

  /// Creates a copy with modified [xMax] (used during merge).
  _SurfaceSegment copyWith({double? xMax}) {
    return _SurfaceSegment(
      id: id,
      xMin: xMin,
      xMax: xMax ?? this.xMax,
      yTop: yTop,
    );
  }
}

/// Mutable horizontal range (used for blocker collection).
class _Range {
  _Range(this.min, this.max);

  double min;
  double max;
}

// =============================================================================
// Helper functions
// =============================================================================

/// Collects horizontal ranges that block the ground at [groundTopY].
///
/// Includes:
/// - Solids with left/right walls touching ground Y.
/// - Explicit ground gaps.
///
/// Returns merged, sorted list of blocking ranges.
List<_Range> _collectGroundBlockers(
  List<StaticSolid> solids,
  List<StaticGroundGap> gaps,
  double groundTopY,
  double eps,
) {
  final blockers = <_Range>[];

  // Collect solids that intersect ground level and have vertical walls.
  for (final solid in solids) {
    final hasWalls =
        (solid.sides & (StaticSolid.sideLeft | StaticSolid.sideRight)) != 0;
    if (!hasWalls) continue;

    final touchesGround =
        solid.minY <= groundTopY + eps && solid.maxY >= groundTopY - eps;
    if (!touchesGround) continue;

    blockers.add(_Range(solid.minX, solid.maxX));
  }

  // Add explicit gaps.
  for (final gap in gaps) {
    blockers.add(_Range(gap.minX, gap.maxX));
  }

  if (blockers.isEmpty) return blockers;

  // Sort and merge overlapping blockers.
  blockers.sort((a, b) => a.min.compareTo(b.min));
  final merged = <_Range>[blockers.first];
  for (var i = 1; i < blockers.length; i += 1) {
    final current = blockers[i];
    final last = merged.last;
    if (current.min <= last.max + eps) {
      // Overlapping or adjacent—extend.
      if (current.max > last.max) {
        last.max = current.max;
      }
    } else {
      merged.add(_Range(current.min, current.max));
    }
  }

  return merged;
}

/// Subtracts [blockers] from range [min, max], returning unblocked segments.
///
/// **Algorithm**:
/// Walk left-to-right, emitting segments between blocker gaps.
List<_Range> _subtractRanges(
  double min,
  double max,
  List<_Range> blockers,
  double eps,
) {
  if (blockers.isEmpty) {
    return <_Range>[_Range(min, max)];
  }

  final segments = <_Range>[];
  var cursor = min;

  for (final blocker in blockers) {
    // Skip blockers entirely before our range.
    if (blocker.max <= min + eps) continue;
    // Stop if blocker starts after our range.
    if (blocker.min >= max - eps) break;

    // Clamp blocker to our range.
    final blockMin = blocker.min < min ? min : blocker.min;
    final blockMax = blocker.max > max ? max : blocker.max;

    // Emit segment before blocker (if any).
    if (blockMin > cursor + eps) {
      segments.add(_Range(cursor, blockMin));
    }

    // Advance cursor past blocker.
    if (blockMax > cursor) {
      cursor = blockMax;
    }
  }

  // Emit trailing segment (if any).
  if (cursor < max - eps) {
    segments.add(_Range(cursor, max));
  }

  return segments;
}

/// Comparison function for sorting segments (Y, then X, then ID).
int _compareSegments(_SurfaceSegment a, _SurfaceSegment b) {
  // Primary: Y ascending (lower platforms first in screen coords).
  if (a.yTop < b.yTop) return -1;
  if (a.yTop > b.yTop) return 1;
  // Secondary: X ascending.
  if (a.xMin < b.xMin) return -1;
  if (a.xMin > b.xMin) return 1;
  // Tertiary: Width ascending.
  if (a.xMax < b.xMax) return -1;
  if (a.xMax > b.xMax) return 1;
  // Final: ID for determinism.
  if (a.id < b.id) return -1;
  if (a.id > b.id) return 1;
  return 0;
}

/// Debug assertion to catch accidental surface-ID collisions in extraction.
void _assertUniqueSegmentIds(List<_SurfaceSegment> segments) {
  assert(() {
    final seen = <int>{};
    for (final segment in segments) {
      if (!seen.add(segment.id)) {
        throw StateError(
          'Duplicate surface ID detected during extraction: ${segment.id}.',
        );
      }
    }
    return true;
  }());
}


===== FILE: lib/core/navigation/surface_graph_builder.dart =====
import '../collision/static_world_geometry_index.dart';
import '../ecs/spatial/grid_index_2d.dart';
import 'utils/jump_template.dart';
import 'types/nav_tolerances.dart';
import 'surface_extractor.dart';
import 'types/surface_graph.dart';
import 'utils/surface_spatial_index.dart';
import 'types/walk_surface.dart';

/// Result of [SurfaceGraphBuilder.build].
class SurfaceGraphBuildResult {
  const SurfaceGraphBuildResult({
    required this.graph,
    required this.spatialIndex,
  });

  /// The navigation graph (surfaces + edges in CSR format).
  final SurfaceGraph graph;

  /// Spatial index for fast surface lookups during runtime navigation.
  final SurfaceSpatialIndex spatialIndex;
}

/// Builds a [SurfaceGraph] from world geometry and jump physics.
///
/// **Pipeline**:
/// 1. Extract [WalkSurface]s from tiles via [SurfaceExtractor].
/// 2. Build spatial index for candidate queries.
/// 3. For each surface, generate edges:
///    - **Drop edges**: Walk off ledge, fall to surface below.
///    - **Jump edges**: Sample takeoff points, find reachable surfaces.
/// 4. Pack into CSR (Compressed Sparse Row) format.
///
/// **Configuration**:
/// - [standableEps]: Tolerance for standable range calculations.
/// - [dropSampleOffset]: Nudge takeoff past ledge for drop edges.
/// - [takeoffSampleMaxStep]: Maximum spacing between takeoff samples.
class SurfaceGraphBuilder {
  SurfaceGraphBuilder({
    required GridIndex2D surfaceGrid,
    SurfaceExtractor? extractor,
    this.standableEps = navSpatialEps,
    this.dropSampleOffset = navSpatialEps,
    this.takeoffSampleMaxStep = 64.0,
  }) : _surfaceGrid = surfaceGrid,
       _extractor = extractor ?? SurfaceExtractor();

  /// Grid for spatial index bucket allocation.
  final GridIndex2D _surfaceGrid;

  /// Surface extractor (default: standard tile-based extraction).
  final SurfaceExtractor _extractor;

  /// Tolerance for standable range width check.
  final double standableEps;

  /// Offset past ledge for drop takeoff (ensures entity actually falls).
  final double dropSampleOffset;

  /// Maximum step between takeoff sample points.
  final double takeoffSampleMaxStep;

  /// Builds a navigation graph from world geometry.
  ///
  /// **Parameters**:
  /// - [geometry]: Static collision geometry (tile-based).
  /// - [jumpTemplate]: Precomputed jump arc for reachability queries.
  ///
  /// **Returns**: [SurfaceGraphBuildResult] with graph and spatial index.
  SurfaceGraphBuildResult build({
    required StaticWorldGeometry geometry,
    required JumpReachabilityTemplate jumpTemplate,
  }) {
    // -------------------------------------------------------------------------
    // Step 1: Extract surfaces and build spatial index.
    // -------------------------------------------------------------------------
    final surfaces = _extractor.extract(geometry);
    final spatialIndex = SurfaceSpatialIndex(index: _surfaceGrid);
    spatialIndex.rebuild(surfaces);
    final staticWorld = StaticWorldGeometryIndex.from(geometry);

    // Build surface ID → index lookup.
    final indexById = <int, int>{};
    for (var i = 0; i < surfaces.length; i += 1) {
      indexById[surfaces[i].id] = i;
    }

    // -------------------------------------------------------------------------
    // Step 2: Generate edges for each surface.
    // -------------------------------------------------------------------------
    final edges = <SurfaceEdge>[];
    final edgeOffsets = List<int>.filled(surfaces.length + 1, 0);
    final tempCandidates = <int>[];
    final solidQueryBuffer = <StaticSolid>[];

    for (var i = 0; i < surfaces.length; i += 1) {
      edgeOffsets[i] = edges.length;
      final from = surfaces[i];

      // Compute standable range (agent center positions that fit on surface).
      final standable = _standableRange(
        from,
        jumpTemplate.profile.agentHalfWidth,
        standableEps,
      );
      if (standable == null) {
        // Surface too narrow for agent.
        edgeOffsets[i + 1] = edges.length;
        continue;
      }

      // -----------------------------------------------------------------------
      // Step 2a: Generate drop edges (walk off ledge).
      // -----------------------------------------------------------------------
      final dropSamples = _dropSamples(standable.min, standable.max);
      final dropMid = (standable.min + standable.max) * 0.5;
      for (final dropX in dropSamples) {
        final landingIndex = _findFirstSurfaceBelow(
          surfaces,
          dropX,
          from.yTop,
          jumpTemplate.profile.agentHalfWidth,
          standableEps,
        );
        if (landingIndex == null) continue;

        final landingSurface = surfaces[landingIndex];
        final dy = landingSurface.yTop - from.yTop;
        final fallTicks = estimateFallTicks(
          dy: dy,
          gravityY: jumpTemplate.profile.gravityY,
          dtSeconds: jumpTemplate.profile.dtSeconds,
          maxTicks: jumpTemplate.profile.maxAirTicks,
        );

        // Nudge takeoff past ledge so agent actually walks off.
        final commitDirX = dropX <= dropMid ? -1 : 1;
        final takeoffX = dropX + (commitDirX * dropSampleOffset);

        final edge = SurfaceEdge(
          to: landingIndex,
          kind: SurfaceEdgeKind.drop,
          takeoffX: takeoffX,
          landingX: _clamp(
            dropX,
            landingSurface.xMin + jumpTemplate.profile.agentHalfWidth,
            landingSurface.xMax - jumpTemplate.profile.agentHalfWidth,
          ),
          commitDirX: commitDirX,
          travelTicks: fallTicks,
          cost: fallTicks * jumpTemplate.profile.dtSeconds,
        );
        edges.add(edge);
      }

      // -----------------------------------------------------------------------
      // Step 2b: Generate jump edges (sample takeoff points).
      // -----------------------------------------------------------------------
      final takeoffXs = _takeoffSamples(
        standable.min,
        standable.max,
        jumpTemplate.maxDx,
        takeoffSampleMaxStep,
      );

      for (final takeoffX in takeoffXs) {
        // Query reachable surfaces within jump arc bounding box.
        final minX = takeoffX - jumpTemplate.maxDx;
        final maxX = takeoffX + jumpTemplate.maxDx;
        final minY = from.yTop + jumpTemplate.minDy;
        final maxY = from.yTop + jumpTemplate.maxDy;

        spatialIndex.queryAabb(
          minX: minX,
          minY: minY,
          maxX: maxX,
          maxY: maxY,
          outSurfaceIndices: tempCandidates,
        );

        // Sort for deterministic edge ordering.
        tempCandidates.sort((a, b) => surfaces[a].id.compareTo(surfaces[b].id));

        for (final targetIndex in tempCandidates) {
          if (targetIndex == i) continue; // Skip self.
          final target = surfaces[targetIndex];

          // Safety net: avoid generating "micro-hop" jump edges between surfaces
          // that are effectively coplanar and contiguous. These should have
          // been merged by the extractor; emitting a jump here can cause AI to
          // do a weird hop on top of the same obstacle.
          final dy = target.yTop - from.yTop;
          final coplanar = dy.abs() <= navSpatialEps;
          if (coplanar) {
            final touchesOrOverlaps =
                target.xMin <= from.xMax + navSpatialEps &&
                target.xMax >= from.xMin - navSpatialEps;
            if (touchesOrOverlaps) {
              continue;
            }
          }

          final landing = _standableRange(
            target,
            jumpTemplate.profile.agentHalfWidth,
            standableEps,
          );
          if (landing == null) continue; // Target too narrow.

          // Check if jump arc can reach target surface.
          final dxMin = landing.min - takeoffX;
          final dxMax = landing.max - takeoffX;
          final landingTick = jumpTemplate.findFirstLanding(
            dy: dy,
            dxMin: dxMin,
            dxMax: dxMax,
          );
          if (landingTick == null) continue; // Not reachable.

          // Compute actual landing range (intersection of reach and surface).
          final reachMin = takeoffX - landingTick.maxDx;
          final reachMax = takeoffX + landingTick.maxDx;
          final low = reachMin > landing.min ? reachMin : landing.min;
          final high = reachMax < landing.max ? reachMax : landing.max;
          if (low > high + standableEps) continue; // No overlap.

          final landingX = (low + high) * 0.5; // Center of landing range.
          final commitDirX = landingX > takeoffX + navGeomEps
              ? 1
              : (landingX < takeoffX - navGeomEps ? -1 : 0);

          final blocked = _isJumpPathObstructed(
            staticWorld: staticWorld,
            jumpTemplate: jumpTemplate,
            takeoffX: takeoffX,
            landingX: landingX,
            startBottomY: from.yTop,
            landingTick: landingTick.tick,
            queryBuffer: solidQueryBuffer,
          );
          if (blocked) continue;

          final edge = SurfaceEdge(
            to: targetIndex,
            kind: SurfaceEdgeKind.jump,
            takeoffX: takeoffX,
            landingX: landingX,
            commitDirX: commitDirX,
            travelTicks: landingTick.tick,
            cost: landingTick.tick * jumpTemplate.profile.dtSeconds,
          );
          edges.add(edge);
        }
      }

      edgeOffsets[i + 1] = edges.length;
    }

    // -------------------------------------------------------------------------
    // Step 3: Pack into graph and return.
    // -------------------------------------------------------------------------
    return SurfaceGraphBuildResult(
      graph: SurfaceGraph(
        surfaces: surfaces,
        edgeOffsets: edgeOffsets,
        edges: edges,
        indexById: indexById,
      ),
      spatialIndex: spatialIndex,
    );
  }
}

// =============================================================================
// Helper types and functions
// =============================================================================

/// A horizontal range [min, max].
class _Range {
  const _Range(this.min, this.max);

  final double min;
  final double max;
}

/// Computes the standable X range for an agent on a surface.
///
/// The agent's center must be at least [halfWidth] from each edge.
/// Returns `null` if the surface is too narrow.
_Range? _standableRange(WalkSurface surface, double halfWidth, double eps) {
  // Allow a tiny support overhang to stay aligned with runtime collision,
  // which accepts partial horizontal overlap when landing.
  final min = surface.xMin + halfWidth - eps;
  final max = surface.xMax - halfWidth + eps;
  if (min > max + eps) return null;
  return _Range(min, max);
}

/// Generates takeoff sample points across a standable range.
///
/// - Returns [min, mid, max] for narrow surfaces.
/// - Returns evenly-spaced samples (at most [maxStep] apart) for wide surfaces.
/// - Deduplicates samples within [navGeomEps].
List<double> _takeoffSamples(
  double min,
  double max,
  double maxDx,
  double maxStep,
) {
  if (max <= min) {
    return <double>[min];
  }

  var step = maxDx;
  if (maxStep > 0 && step > maxStep) {
    step = maxStep;
  }

  // Narrow surface: just sample endpoints and midpoint.
  if (step <= navGeomEps || (max - min) <= step) {
    final mid = (min + max) * 0.5;
    return _dedupeSamples(<double>[min, mid, max]);
  }

  // Wide surface: evenly-spaced samples.
  final samples = <double>[];
  for (var x = min; x <= max; x += step) {
    samples.add(x);
  }
  // Ensure max is included.
  if ((max - samples.last).abs() > navGeomEps) {
    samples.add(max);
  }
  return _dedupeSamples(samples);
}

/// Generates drop sample points (only at ledge endpoints).
List<double> _dropSamples(double min, double max) {
  final samples = <double>[min, max];
  return _dedupeSamples(samples);
}

/// Removes duplicate samples within [eps] tolerance.
List<double> _dedupeSamples(List<double> samples, {double eps = navGeomEps}) {
  samples.sort();
  final deduped = <double>[];
  for (final s in samples) {
    if (deduped.isEmpty || (s - deduped.last).abs() > eps) {
      deduped.add(s);
    }
  }
  return deduped;
}

/// Finds the first (highest) surface directly below a point.
///
/// **Parameters**:
/// - [x]: Horizontal position to check.
/// - [fromY]: Starting Y (surfaces must be below this).
/// - [halfWidth]: Agent half-width for standability check.
///
/// **Returns**: Surface index, or `null` if no surface below.
int? _findFirstSurfaceBelow(
  List<WalkSurface> surfaces,
  double x,
  double fromY,
  double halfWidth,
  double eps,
) {
  int? bestIndex;
  double? bestY;

  for (var i = 0; i < surfaces.length; i += 1) {
    final s = surfaces[i];
    // Must be below starting point.
    if (s.yTop <= fromY) continue;
    // Must be standable at this X.
    final minX = s.xMin + halfWidth - eps;
    final maxX = s.xMax - halfWidth + eps;
    if (minX > maxX + eps) continue;
    if (x < minX || x > maxX) continue;

    // Prefer highest surface (lowest yTop).
    if (bestY == null || s.yTop < bestY) {
      bestY = s.yTop;
      bestIndex = i;
    } else if ((s.yTop - bestY).abs() < navTieEps) {
      // Tie-break by ID for determinism.
      if (s.id < surfaces[bestIndex!].id) {
        bestIndex = i;
      }
    }
  }

  return bestIndex;
}

/// Clamps [v] to the range [min, max].
double _clamp(double v, double min, double max) {
  if (v < min) return min;
  if (v > max) return max;
  return v;
}

/// Returns true when the jump path intersects blocking ceilings or walls.
///
/// This validates the specific takeoff/landing pair used for an emitted edge.
bool _isJumpPathObstructed({
  required StaticWorldGeometryIndex staticWorld,
  required JumpReachabilityTemplate jumpTemplate,
  required double takeoffX,
  required double landingX,
  required double startBottomY,
  required int landingTick,
  required List<StaticSolid> queryBuffer,
}) {
  if (landingTick <= 0) return false;

  final profile = jumpTemplate.profile;
  final halfWidth = profile.agentHalfWidth;
  final halfHeight = profile.effectiveHalfHeight;
  final totalTicks = landingTick.toDouble();
  const eps = navGeomEps;

  if (landingTick > jumpTemplate.samples.length) {
    return true;
  }

  for (var tick = 1; tick <= landingTick; tick += 1) {
    final sample = jumpTemplate.samples[tick - 1];
    final prevBottomY = startBottomY + sample.prevY;
    final bottomY = startBottomY + sample.y;
    final prevTopY = prevBottomY - (halfHeight * 2.0);
    final topY = bottomY - (halfHeight * 2.0);

    final prevT = (tick - 1) / totalTicks;
    final currT = tick / totalTicks;
    final prevX = takeoffX + (landingX - takeoffX) * prevT;
    final x = takeoffX + (landingX - takeoffX) * currT;

    final sweepMinX = (prevX < x ? prevX : x) - halfWidth;
    final sweepMaxX = (prevX > x ? prevX : x) + halfWidth;
    final sweepMinY = prevTopY < topY ? prevTopY : topY;
    final sweepMaxY = prevBottomY > bottomY ? prevBottomY : bottomY;

    // Ceiling collisions while traveling upward.
    if (profile.collideCeilings && topY < prevTopY - eps) {
      queryBuffer.clear();
      staticWorld.queryBottoms(sweepMinX + eps, sweepMaxX - eps, queryBuffer);
      for (final solid in queryBuffer) {
        final bottomYLine = solid.maxY;
        final crossesBottom =
            prevTopY >= bottomYLine - eps && topY <= bottomYLine + eps;
        if (!crossesBottom) continue;

        final overlapsX =
            sweepMaxX > solid.minX + eps && sweepMinX < solid.maxX - eps;
        if (!overlapsX) continue;

        return true;
      }
    }

    // Rightward wall collisions against left walls.
    if (profile.collideRightWalls && x > prevX + eps) {
      final prevRight = prevX + halfWidth;
      final right = x + halfWidth;
      queryBuffer.clear();
      staticWorld.queryLeftWalls(prevRight - eps, right + eps, queryBuffer);
      for (final solid in queryBuffer) {
        final overlapsY =
            sweepMaxY > solid.minY + eps && sweepMinY < solid.maxY - eps;
        if (!overlapsY) continue;

        final wallX = solid.minX;
        final crossesWall = prevRight <= wallX + eps && right >= wallX - eps;
        if (crossesWall) return true;
      }
    }

    // Leftward wall collisions against right walls.
    if (profile.collideLeftWalls && x < prevX - eps) {
      final prevLeft = prevX - halfWidth;
      final left = x - halfWidth;
      queryBuffer.clear();
      staticWorld.queryRightWalls(left - eps, prevLeft + eps, queryBuffer);
      for (final solid in queryBuffer) {
        final overlapsY =
            sweepMaxY > solid.minY + eps && sweepMinY < solid.maxY - eps;
        if (!overlapsY) continue;

        final wallX = solid.maxX;
        final crossesWall = prevLeft >= wallX - eps && left <= wallX + eps;
        if (crossesWall) return true;
      }
    }
  }

  return false;
}


===== FILE: lib/core/navigation/surface_navigator.dart =====
import '../ecs/stores/enemies/surface_nav_state_store.dart';
import 'types/nav_tolerances.dart';
import 'types/surface_graph.dart';
import 'types/surface_id.dart';
import 'surface_pathfinder.dart';
import 'utils/surface_spatial_index.dart';

/// Output of [SurfaceNavigator.update] indicating desired movement.
class SurfaceNavIntent {
  const SurfaceNavIntent({
    required this.desiredX,
    required this.jumpNow,
    required this.hasPlan,
    this.commitMoveDirX = 0,
  });

  /// Target X position the locomotion controller should move toward.
  final double desiredX;

  /// If `true`, the entity should jump this frame.
  final bool jumpNow;

  /// If `true`, a valid path exists (even if currently executing an edge).
  final bool hasPlan;

  /// Movement commit direction while approaching/executing an edge.
  ///
  /// When non-zero (-1 or +1), the locomotion controller should keep moving in
  /// this direction even if it would normally stop near `desiredX`, and it
  /// should not reverse direction due to tiny `desiredX` overshoots.
  ///
  /// This is primarily used to ensure drop edges actually leave the takeoff
  /// surface (walk past the ledge) instead of stopping "close enough".
  final int commitMoveDirX;
}

/// Runtime navigation controller for surface-graph-based AI movement.
///
/// **Responsibilities**:
/// 1. Track which surface the entity and target are standing on.
/// 2. Request paths via [SurfacePathfinder] when surfaces change.
/// 3. Execute path edges (walk to takeoff, jump/drop, land on destination).
/// 4. Return [SurfaceNavIntent] each tick for the locomotion controller.
///
/// **State Storage**:
/// Uses [SurfaceNavStateStore] (external SOA store) so multiple entities can
/// share a single [SurfaceNavigator] instance.
///
/// **Usage**:
/// ```dart
/// final intent = navigator.update(
///   navStore: store, navIndex: idx,
///   graph: graph, spatialIndex: index,
///   graphVersion: version,
///   entityX: e.x, entityBottomY: e.bottom, entityHalfWidth: e.hw,
///   entityGrounded: e.grounded,
///   targetX: t.x, targetBottomY: t.bottom, targetHalfWidth: t.hw,
///   targetGrounded: t.grounded,
/// );
/// // Use intent.desiredX, intent.jumpNow, intent.commitMoveDirX
/// ```
class SurfaceNavigator {
  SurfaceNavigator({
    required this.pathfinder,
    this.repathCooldownTicks = 12,
    this.surfaceEps = navSpatialEps,
    this.takeoffEps = 4.0,
  });

  /// Pathfinder used for A* queries.
  final SurfacePathfinder pathfinder;

  /// Minimum ticks between path recalculations (prevents thrashing).
  final int repathCooldownTicks;

  /// Vertical tolerance for surface detection (pixels).
  final double surfaceEps;

  /// Horizontal tolerance for reaching takeoff point (pixels).
  final double takeoffEps;

  /// Reusable buffer for spatial index queries.
  final List<int> _candidateBuffer = <int>[];

  /// Updates navigation state and returns movement intent for one entity.
  ///
  /// **Flow**:
  /// 1. Locate current and target surfaces via spatial index.
  /// 2. Invalidate path if graph version changed.
  /// 3. Repath if cooldown expired and surfaces are known.
  /// 4. If same surface, return direct movement to target.
  /// 5. Otherwise, execute next edge in path (approach → jump/drop → land).
  SurfaceNavIntent update({
    required SurfaceNavStateStore navStore,
    required int navIndex,
    required SurfaceGraph graph,
    required SurfaceSpatialIndex spatialIndex,
    required int graphVersion,
    required double entityX,
    required double entityBottomY,
    required double entityHalfWidth,
    required bool entityGrounded,
    required double targetX,
    required double targetBottomY,
    required double targetHalfWidth,
    required bool targetGrounded,
  }) {
    final prevCurrentId = navStore.currentSurfaceId[navIndex];
    final prevTargetId = navStore.targetSurfaceId[navIndex];
    final prevLastGroundId = navStore.lastGroundSurfaceId[navIndex];

    // -------------------------------------------------------------------------
    // Step 1: Locate surfaces.
    // -------------------------------------------------------------------------
    var currentSurfaceId = surfaceIdUnknown;
    if (entityGrounded) {
      final currentIndex = _locateSurfaceIndex(
        graph,
        spatialIndex,
        _candidateBuffer,
        entityX,
        entityBottomY,
        entityHalfWidth,
        surfaceEps,
      );
      currentSurfaceId = currentIndex == null
          ? surfaceIdUnknown
          : graph.surfaces[currentIndex].id;
    }

    var targetSurfaceId = prevTargetId;
    if (targetGrounded) {
      var targetIndex = _locateSurfaceIndex(
        graph,
        spatialIndex,
        _candidateBuffer,
        targetX,
        targetBottomY,
        targetHalfWidth,
        surfaceEps,
      );
      if (targetIndex == null && targetHalfWidth > 0.0) {
        // Target lookup is allowed to be edge-tolerant: if the full footprint
        // check fails (target near a ledge), still resolve a surface by center.
        // This keeps pathfinding active instead of falling back to no-plan
        // clamping on the wrong side of an obstacle.
        targetIndex = _locateSurfaceIndex(
          graph,
          spatialIndex,
          _candidateBuffer,
          targetX,
          targetBottomY,
          0.0,
          surfaceEps,
        );
      }
      targetSurfaceId = targetIndex == null
          ? surfaceIdUnknown
          : graph.surfaces[targetIndex].id;
    }

    // -------------------------------------------------------------------------
    // Step 2: Invalidate path on graph rebuild.
    // -------------------------------------------------------------------------
    if (navStore.graphVersion[navIndex] != graphVersion) {
      navStore.graphVersion[navIndex] = graphVersion;
      navStore.pathEdges[navIndex].clear();
      navStore.pathCursor[navIndex] = 0;
      navStore.activeEdgeIndex[navIndex] = -1;
      navStore.repathTicksLeft[navIndex] = 0;
      navStore.lastGroundSurfaceId[navIndex] = surfaceIdUnknown;
    }

    navStore.currentSurfaceId[navIndex] = currentSurfaceId;
    navStore.targetSurfaceId[navIndex] = targetSurfaceId;
    if (entityGrounded && currentSurfaceId != surfaceIdUnknown) {
      navStore.lastGroundSurfaceId[navIndex] = currentSurfaceId;
    } else if (prevLastGroundId != surfaceIdUnknown) {
      navStore.lastGroundSurfaceId[navIndex] = prevLastGroundId;
    }

    // Decrement repath cooldown.
    if (navStore.repathTicksLeft[navIndex] > 0) {
      navStore.repathTicksLeft[navIndex] -= 1;
    }

    final plan = navStore.pathEdges[navIndex];
    final surfaceChanged =
        currentSurfaceId != prevCurrentId || targetSurfaceId != prevTargetId;

    // Reset cooldown if either surface changed (allows immediate repath).
    if (surfaceChanged) {
      navStore.repathTicksLeft[navIndex] = 0;
    }

    // -------------------------------------------------------------------------
    // Step 3: Repath if needed.
    // -------------------------------------------------------------------------
    if (entityGrounded &&
        navStore.repathTicksLeft[navIndex] == 0 &&
        currentSurfaceId != surfaceIdUnknown &&
        targetSurfaceId != surfaceIdUnknown) {
      final startIndex = graph.indexOfSurfaceId(currentSurfaceId);
      final goalIndex = graph.indexOfSurfaceId(targetSurfaceId);
      if (startIndex != null && goalIndex != null) {
        final preferredDirX = _preferredDirectionX(
          entityX: entityX,
          targetX: targetX,
        );
        var found = false;
        if (preferredDirX != 0) {
          found = pathfinder.findPath(
            graph,
            startIndex: startIndex,
            goalIndex: goalIndex,
            outEdges: plan,
            startX: entityX,
            goalX: targetX,
            preferredDirectionX: preferredDirX,
            restrictToPreferredDirection: true,
          );
        }
        if (!found) {
          found = pathfinder.findPath(
            graph,
            startIndex: startIndex,
            goalIndex: goalIndex,
            outEdges: plan,
            startX: entityX,
            goalX: targetX,
          );
        }
        navStore.pathCursor[navIndex] = 0;
        navStore.activeEdgeIndex[navIndex] = -1;
        if (!found) {
          plan.clear();
        }
      }
      navStore.repathTicksLeft[navIndex] = repathCooldownTicks;
    }

    // -------------------------------------------------------------------------
    // Step 4: Same-surface shortcut.
    // -------------------------------------------------------------------------
    if (entityGrounded &&
        navStore.activeEdgeIndex[navIndex] < 0 &&
        currentSurfaceId != surfaceIdUnknown &&
        currentSurfaceId == targetSurfaceId) {
      plan.clear();
      navStore.pathCursor[navIndex] = 0;
      navStore.activeEdgeIndex[navIndex] = -1;
      return SurfaceNavIntent(
        desiredX: targetX,
        jumpNow: false,
        hasPlan: false,
      );
    }

    // -------------------------------------------------------------------------
    // Step 5: Execute path edges.
    // -------------------------------------------------------------------------
    final cursor = navStore.pathCursor[navIndex];
    if (plan.isEmpty || cursor >= plan.length) {
      navStore.activeEdgeIndex[navIndex] = -1;
      return SurfaceNavIntent(
        desiredX: targetX,
        jumpNow: false,
        hasPlan: false,
      );
    }

    final edgeIndex = plan[cursor];
    final edge = graph.edges[edgeIndex];

    // --- Executing an edge (mid-flight or post-takeoff) ---
    if (navStore.activeEdgeIndex[navIndex] >= 0) {
      // Check if we've landed on the destination surface.
      if (entityGrounded &&
          currentSurfaceId != surfaceIdUnknown &&
          currentSurfaceId == graph.surfaces[edge.to].id) {
        // Edge complete—advance cursor.
        navStore.activeEdgeIndex[navIndex] = -1;
        navStore.pathCursor[navIndex] = cursor + 1;
        return SurfaceNavIntent(
          desiredX: targetX,
          jumpNow: false,
          hasPlan: true,
        );
      }

      // Drop edge: keep walking toward ledge until we fall off.
      if (edge.kind == SurfaceEdgeKind.drop && entityGrounded) {
        return SurfaceNavIntent(
          desiredX: edge.takeoffX,
          jumpNow: false,
          hasPlan: true,
          commitMoveDirX: edge.commitDirX,
        );
      }

      // Drop edge in-flight: keep commit direction stable. (landingX can be
      // slightly behind the entity due to clamping, which would otherwise
      // cause a brief direction reversal.)
      if (edge.kind == SurfaceEdgeKind.drop) {
        return SurfaceNavIntent(
          desiredX: edge.landingX,
          jumpNow: false,
          hasPlan: true,
          commitMoveDirX: edge.commitDirX,
        );
      }

      // Jump edge in-flight: keep commit direction stable to avoid
      // air-turn reversals when landingX ends up slightly behind due to
      // overshoot or edge clamping.
      return SurfaceNavIntent(
        desiredX: edge.landingX,
        jumpNow: false,
        hasPlan: true,
        commitMoveDirX: edge.commitDirX,
      );
    }

    // --- Approaching takeoff point ---
    // With commit direction, allow activation when the entity is at OR past the
    // takeoff point in travel direction. This prevents overshoot oscillation.
    final dir = edge.commitDirX;
    final closeEnough = dir > 0
        ? entityX >= edge.takeoffX - takeoffEps
        : (dir < 0
              ? entityX <= edge.takeoffX + takeoffEps
              : (entityX - edge.takeoffX).abs() <= takeoffEps);
    if (entityGrounded && closeEnough) {
      // Initiate edge execution.
      navStore.activeEdgeIndex[navIndex] = edgeIndex;

      final jumpNow = edge.kind == SurfaceEdgeKind.jump;
      return SurfaceNavIntent(
        desiredX: edge.kind == SurfaceEdgeKind.drop
            ? edge.takeoffX
            : edge.landingX,
        jumpNow: jumpNow,
        hasPlan: true,
        commitMoveDirX: edge.commitDirX,
      );
    }

    // Walk toward takeoff point.
    // For jump edges, commit direction keeps the entity moving at full speed
    // through the takeoff instead of decelerating as it approaches.
    return SurfaceNavIntent(
      desiredX: edge.takeoffX,
      jumpNow: false,
      hasPlan: true,
      commitMoveDirX: edge.commitDirX,
    );
  }
}

int _preferredDirectionX({required double entityX, required double targetX}) {
  final dx = targetX - entityX;
  if (dx > navTieEps) return 1;
  if (dx < -navTieEps) return -1;
  return 0;
}

/// Finds the best surface index for a given entity footprint.
///
/// **Algorithm**:
/// 1. Query spatial index for candidate surfaces in AABB.
/// 2. Filter by horizontal overlap and vertical proximity.
/// 3. Prefer lowest yTop (highest platform). Tie-break by surface ID.
///
/// **Returns**: Surface index, or `null` if not standing on any surface.
int? _locateSurfaceIndex(
  SurfaceGraph graph,
  SurfaceSpatialIndex spatialIndex,
  List<int> candidates,
  double x,
  double bottomY,
  double halfWidth,
  double eps,
) {
  final minX = x - halfWidth;
  final maxX = x + halfWidth;
  final minY = bottomY - eps;
  final maxY = bottomY + eps;

  spatialIndex.queryAabb(
    minX: minX,
    minY: minY,
    maxX: maxX,
    maxY: maxY,
    outSurfaceIndices: candidates,
  );

  int? bestIndex;
  double? bestY;
  for (final i in candidates) {
    final s = graph.surfaces[i];
    // Allow tiny horizontal overhang tolerance to match runtime collision
    // support rules on narrow tops.
    final standableMinX = s.xMin + halfWidth - eps;
    final standableMaxX = s.xMax - halfWidth + eps;
    if (standableMinX > standableMaxX + eps) continue;
    // Entity center must be inside standable range.
    if (x < standableMinX - eps || x > standableMaxX + eps) continue;
    // Skip if too far vertically.
    if ((s.yTop - bottomY).abs() > eps) continue;

    // Prefer higher platform (lower yTop in screen coords).
    if (bestY == null || s.yTop < bestY) {
      bestY = s.yTop;
      bestIndex = i;
    } else if ((s.yTop - bestY).abs() <= eps) {
      // Tie-break by ID for determinism.
      if (s.id < graph.surfaces[bestIndex!].id) {
        bestIndex = i;
      }
    }
  }

  return bestIndex;
}


===== FILE: lib/core/navigation/surface_pathfinder.dart =====
import 'types/surface_graph.dart';
import 'types/nav_tolerances.dart';

/// A* pathfinder for surface-based navigation graphs.
///
/// **Algorithm**: Standard A* with:
/// - Admissible heuristic: straight-line horizontal distance / run speed.
/// - Edge costs: transition cost + run distance to takeoff + landing adjustment.
/// - Tie-breaking: lower g-score, then surface ID for determinism.
///
/// **Optimizations**:
/// - Generation-stamp pattern avoids clearing arrays between searches.
/// - Reusable working lists grow once, persist across queries.
/// - Linear open-list scan (adequate for small graphs; swap to binary heap
///   if graph size grows significantly).
///
/// **Usage**:
/// ```dart
/// final pathfinder = SurfacePathfinder(maxExpandedNodes: 500, runSpeedX: 200);
/// final edges = <int>[];
/// if (pathfinder.findPath(graph, startIndex: s, goalIndex: g, outEdges: edges)) {
///   // edges contains edge indices from start to goal.
/// }
/// ```
class SurfacePathfinder {
  SurfacePathfinder({
    required this.maxExpandedNodes,
    required this.runSpeedX,
    this.edgePenaltySeconds = 0.0,
  }) : assert(maxExpandedNodes > 0),
       assert(runSpeedX > 0),
       assert(edgePenaltySeconds >= 0.0);

  /// Maximum nodes to expand before giving up (prevents runaway searches).
  final int maxExpandedNodes;

  /// Horizontal run speed (pixels/second) for cost calculations.
  final double runSpeedX;

  /// Flat penalty added to every edge (discourages excessive transitions).
  final double edgePenaltySeconds;

  // ---------------------------------------------------------------------------
  // Working arrays (reused across searches via generation stamps).
  // ---------------------------------------------------------------------------

  /// Cost from start to each node (g-score).
  final List<double> _gScore = <double>[];

  /// Estimated total cost through each node (f = g + h).
  final List<double> _fScore = <double>[];

  /// Edge index used to reach each node (-1 = start or unvisited).
  final List<int> _cameFromEdge = <int>[];

  /// Predecessor node index (-1 = start or unvisited).
  final List<int> _cameFromNode = <int>[];

  /// Open set (nodes pending expansion).
  final List<int> _open = <int>[];

  /// 1 if node is in open set this search, 0 otherwise.
  final List<int> _openStamp = <int>[];

  /// Scratch space for path reconstruction.
  final List<int> _reconstruct = <int>[];

  /// Generation stamp per node (matches [_searchGeneration] if valid).
  final List<int> _nodeGenerations = <int>[];

  /// Incremented each search to invalidate stale node data.
  int _searchGeneration = 0;

  /// Finds a path from [startIndex] to [goalIndex] in [graph].
  ///
  /// **Parameters**:
  /// - [startIndex], [goalIndex]: Surface indices in [graph.surfaces].
  /// - [outEdges]: Receives ordered edge indices from start to goal.
  /// - [startX], [goalX]: Optional precise X positions for cost accuracy.
  /// - [preferredDirectionX]: Preferred horizontal edge direction (-1/0/+1).
  /// - [restrictToPreferredDirection]: When `true`, edges that explicitly move
  ///   opposite to [preferredDirectionX] are ignored.
  ///
  /// **Returns**: `true` if a path was found, `false` otherwise.
  bool findPath(
    SurfaceGraph graph, {
    required int startIndex,
    required int goalIndex,
    required List<int> outEdges,
    double? startX,
    double? goalX,
    int preferredDirectionX = 0,
    bool restrictToPreferredDirection = false,
  }) {
    assert(preferredDirectionX >= -1 && preferredDirectionX <= 1);
    outEdges.clear();
    if (startIndex == goalIndex) return true;

    _ensureSize(graph.surfaces.length);
    _searchGeneration += 1;

    // Initialize start node.
    _touch(startIndex);
    _open.clear();
    _open.add(startIndex);
    _openStamp[startIndex] = 1;
    _gScore[startIndex] = 0.0;
    _fScore[startIndex] = _heuristic(graph, startIndex, goalIndex);

    var expanded = 0;
    while (_open.isNotEmpty && expanded < maxExpandedNodes) {
      final current = _popBest(graph);
      if (current == goalIndex) {
        _reconstructPath(goalIndex, outEdges);
        return true;
      }

      expanded += 1;

      // Iterate outgoing edges (CSR format).
      final start = graph.edgeOffsets[current];
      final end = graph.edgeOffsets[current + 1];
      final originX = _originX(
        graph,
        current,
        startIndex: startIndex,
        startX: startX,
      );
      for (var ei = start; ei < end; ei += 1) {
        final edge = graph.edges[ei];
        if (restrictToPreferredDirection && preferredDirectionX != 0) {
          final edgeDirX = _edgeDirectionX(edge);
          if (edgeDirX != 0 && edgeDirX != preferredDirectionX) {
            continue;
          }
        }
        final neighbor = edge.to;
        _touch(neighbor);

        // Total edge cost: base + run-to-takeoff + landing adjustment + penalty.
        final edgeCost =
            edge.cost +
            _runCost(edge, originX: originX) +
            _goalLandingCost(
              edge,
              neighbor: neighbor,
              goalIndex: goalIndex,
              goalX: goalX,
            ) +
            edgePenaltySeconds;

        final tentative = _gScore[current] + edgeCost;
        if (tentative >= _gScore[neighbor]) continue;

        // Better path found—update neighbor.
        _cameFromEdge[neighbor] = ei;
        _cameFromNode[neighbor] = current;
        _gScore[neighbor] = tentative;
        _fScore[neighbor] = tentative + _heuristic(graph, neighbor, goalIndex);

        // Add to open set if not already present.
        if (_openStamp[neighbor] != 1) {
          _open.add(neighbor);
          _openStamp[neighbor] = 1;
        }
      }
    }

    return false; // No path found within expansion limit.
  }

  /// Admissible heuristic: horizontal distance / run speed.
  ///
  /// Ignores vertical distance (platforms can be reached by jumps/falls
  /// with minimal time penalty relative to horizontal travel).
  double _heuristic(SurfaceGraph graph, int from, int goal) {
    final dx = (graph.surfaces[goal].centerX - graph.surfaces[from].centerX)
        .abs();
    return dx / runSpeedX;
  }

  /// Effective horizontal origin used when leaving [nodeIndex].
  ///
  /// Uses predecessor landing position when available, so path costs reflect
  /// where the entity actually arrives on intermediate surfaces.
  double _originX(
    SurfaceGraph graph,
    int nodeIndex, {
    required int startIndex,
    required double? startX,
  }) {
    if (nodeIndex == startIndex && startX != null) {
      return startX;
    }
    final fromEdge = _cameFromEdge[nodeIndex];
    if (fromEdge >= 0) {
      return graph.edges[fromEdge].landingX;
    }
    return graph.surfaces[nodeIndex].centerX;
  }

  /// Cost to run from current position to edge takeoff point.
  double _runCost(SurfaceEdge edge, {required double originX}) {
    final dx = (edge.takeoffX - originX).abs();
    return dx / runSpeedX;
  }

  /// Resolved horizontal direction for an edge: -1, 0, or +1.
  int _edgeDirectionX(SurfaceEdge edge) {
    if (edge.commitDirX != 0) return edge.commitDirX;
    final dx = edge.landingX - edge.takeoffX;
    if (dx > 0.0) return 1;
    if (dx < 0.0) return -1;
    return 0;
  }

  /// Additional cost for landing distance to goal (only on final edge).
  double _goalLandingCost(
    SurfaceEdge edge, {
    required int neighbor,
    required int goalIndex,
    required double? goalX,
  }) {
    if (goalX == null) return 0.0;
    if (neighbor != goalIndex) return 0.0;
    final dx = (edge.landingX - goalX).abs();
    return dx / runSpeedX;
  }

  /// Extracts and removes the node with lowest f-score from [_open].
  ///
  /// Uses linear scan (O(n)) which is fine for small open sets.
  /// For larger graphs, consider a binary heap.
  int _popBest(SurfaceGraph graph) {
    var bestIndex = 0;
    var bestNode = _open[0];
    for (var i = 1; i < _open.length; i += 1) {
      final node = _open[i];
      if (_isBetter(graph, node, bestNode)) {
        bestIndex = i;
        bestNode = node;
      }
    }

    // Swap-remove: replace extracted element with last, then pop.
    final last = _open.removeLast();
    if (bestIndex < _open.length) {
      _open[bestIndex] = last;
    }
    _openStamp[bestNode] = 0;
    return bestNode;
  }

  /// Compares two nodes for priority (lower f-score wins).
  ///
  /// Tie-breaking order:
  /// 1. Lower f-score.
  /// 2. Lower g-score (prefer nodes closer to start).
  /// 3. Lower surface ID (determinism).
  bool _isBetter(SurfaceGraph graph, int a, int b) {
    final fa = _fScore[a];
    final fb = _fScore[b];
    if (fa < fb - navTieEps) return true;
    if (fa > fb + navTieEps) return false;
    final ga = _gScore[a];
    final gb = _gScore[b];
    if (ga < gb - navTieEps) return true;
    if (ga > gb + navTieEps) return false;
    return graph.surfaces[a].id < graph.surfaces[b].id;
  }

  /// Reconstructs path by walking [_cameFromEdge] back to start.
  ///
  /// Edges are collected in reverse order, then reversed into [outEdges].
  void _reconstructPath(int goalIndex, List<int> outEdges) {
    _reconstruct.clear();
    var current = goalIndex;
    while (_cameFromEdge[current] != -1) {
      _reconstruct.add(_cameFromEdge[current]);
      current = _cameFromNode[current];
    }
    // Reverse into output.
    for (var i = _reconstruct.length - 1; i >= 0; i -= 1) {
      outEdges.add(_reconstruct[i]);
    }
  }

  /// Grows working arrays to accommodate [count] nodes.
  void _ensureSize(int count) {
    while (_gScore.length < count) {
      _gScore.add(double.infinity);
      _fScore.add(double.infinity);
      _cameFromEdge.add(-1);
      _cameFromNode.add(-1);
      _openStamp.add(0);
      _nodeGenerations.add(0);
    }
  }

  /// Lazily initializes node data for the current search generation.
  ///
  /// Avoids O(n) clearing of all arrays between searches.
  void _touch(int index) {
    if (_nodeGenerations[index] != _searchGeneration) {
      _gScore[index] = double.infinity;
      _fScore[index] = double.infinity;
      _cameFromEdge[index] = -1;
      _cameFromNode[index] = -1;
      _openStamp[index] = 0;
      _nodeGenerations[index] = _searchGeneration;
    }
  }
}


===== FILE: lib/core/navigation/types/nav_tolerances.dart =====
/// Navigation-wide numeric tolerances.
///
/// **Design**:
/// - [navEps] is kept very small for geometric comparisons and deterministic
///   tie-breaking.
/// - [navSpatialEps] is intentionally larger to make runtime surface detection
///   robust against tiny simulation drift (world units are pixels).
///
/// **Warning**: Changing these values affects pathfinding determinism.
library;

/// Default epsilon for equality checks and tie-breaks (1e-6 world units).
const double navEps = 1e-6;

/// Epsilon for geometric equality checks (e.g., "are these two points the same?").
const double navGeomEps = navEps;

/// Epsilon for spatial queries (surface containment, overlap thickness).
const double navSpatialEps = 1.0;

/// Epsilon for deterministic tie-breaking in A* (f-cost and g-cost comparisons).
const double navTieEps = navEps;


===== FILE: lib/core/navigation/types/surface_graph.dart =====
import 'walk_surface.dart';

/// The type of transition between two surfaces.
enum SurfaceEdgeKind {
  /// An active jump (requires jump input).
  jump,
  
  /// A passive drop (walking off an edge).
  drop,
}

/// A directed edge in the navigation graph.
///
/// Represents a traversable connection from one [WalkSurface] to another.
class SurfaceEdge {
  const SurfaceEdge({
    required this.to,
    required this.kind,
    required this.takeoffX,
    required this.landingX,
    required this.commitDirX,
    required this.travelTicks,
    required this.cost,
  }) : assert(commitDirX >= -1 && commitDirX <= 1);

  /// Index of the destination surface in [SurfaceGraph.surfaces].
  final int to;
  
  /// Type of traversal (Jump or Drop).
  final SurfaceEdgeKind kind;
  
  /// World X coordinate where the entity leaves the source surface.
  final double takeoffX;
  
  /// World X coordinate where the entity lands on the destination surface.
  final double landingX;

  /// Movement commit direction while approaching/executing this edge.
  ///
  /// When non-zero (-1 or +1), the locomotion controller should keep moving in
  /// this direction when approaching the takeoff point and (for drops) while
  /// walking past the ledge to ensure the entity actually falls.
  ///
  /// **Design**:
  /// - For [SurfaceEdgeKind.drop], this is derived from which ledge is used.
  /// - For [SurfaceEdgeKind.jump], this is derived from `landingX - takeoffX`.
  final int commitDirX;
  
  /// Estimated travel time in simulation ticks.
  final int travelTicks;
  
  /// Pathfinding cost (typically based on time or distance).
  final double cost;
}

/// An immutable navigation graph built from [WalkSurface]s.
///
/// **Structure**:
/// - **Nodes**: [surfaces] (indexed 0..N-1).
/// - **Edges**: Stored in [edges], with [edgeOffsets] providing CSR-style indexing.
///
/// **CSR (Compressed Sparse Row) Format**:
/// - `edgeOffsets[i]` is the start index in [edges] for surface `i`.
/// - `edgeOffsets[i+1]` is the end index (exclusive).
/// - This allows O(1) lookup of outgoing edges for any surface.
class SurfaceGraph {
  SurfaceGraph({
    required List<WalkSurface> surfaces,
    required List<int> edgeOffsets,
    required List<SurfaceEdge> edges,
    required Map<int, int> indexById,
  })  : surfaces = List<WalkSurface>.unmodifiable(surfaces),
        edgeOffsets = List<int>.unmodifiable(edgeOffsets),
        edges = List<SurfaceEdge>.unmodifiable(edges),
        _indexById = Map<int, int>.unmodifiable(indexById);

  /// All walkable surfaces (graph nodes).
  final List<WalkSurface> surfaces;
  
  /// CSR row pointers into [edges]. Length = surfaces.length + 1.
  final List<int> edgeOffsets;
  
  /// All edges (graph arcs), grouped by source surface.
  final List<SurfaceEdge> edges;
  
  /// Lookup: Surface ID -> index in [surfaces].
  final Map<int, int> _indexById;

  /// Returns the index of a surface by its packed [id], or null if not found.
  int? indexOfSurfaceId(int id) => _indexById[id];

  /// Yields all outgoing edges from [surfaceIndex].
  Iterable<SurfaceEdge> edgesFor(int surfaceIndex) sync* {
    final start = edgeOffsets[surfaceIndex];
    final end = edgeOffsets[surfaceIndex + 1];
    for (var i = start; i < end; i += 1) {
      yield edges[i];
    }
  }
}


===== FILE: lib/core/navigation/types/surface_id.dart =====
/// Surface ID Packing Utilities.
///
/// Surfaces are identified by a 64-bit integer that encodes:
/// - **Chunk Index** (32 bits, high): Which level chunk the surface belongs to.
/// - **Local Solid Index** (30 bits): Index of the solid tile within the chunk.
/// - **Surface Kind** (2 bits, low): Top/Side/etc. (Currently only Top is used).
///
/// This encoding allows:
/// - Stable, deterministic IDs across save/load.
/// - Efficient Map/Set lookups.
/// - Lexicographic ordering by chunk then local index.
library;

/// The "Top" surface kind (entities stand on top of the solid).
const int surfaceKindTop = 0;

const int _signed32Min = -0x80000000;
const int _signed32Max = 0x7FFFFFFF;
const int _maxPackedLocalSolidIndex = 0x3FFFFFFF;

/// Sentinel value for "no surface" / invalid.
const int surfaceIdUnknown = -1;

/// Packs a surface identity into a stable, comparable 64-bit key.
///
/// **Bit Layout**:
/// ```
/// [63..32] chunkIndex (XOR'd with 0x80000000 to handle signed comparison)
/// [31..2]  localSolidIndex
/// [1..0]   surfaceKind
/// ```
int packSurfaceId({
  required int chunkIndex,
  required int localSolidIndex,
  int surfaceKind = surfaceKindTop,
}) {
  if (chunkIndex < _signed32Min || chunkIndex > _signed32Max) {
    throw ArgumentError.value(
      chunkIndex,
      'chunkIndex',
      'must fit in signed 32-bit range',
    );
  }
  if (localSolidIndex < 0) {
    throw ArgumentError.value(
      localSolidIndex,
      'localSolidIndex',
      'must be >= 0',
    );
  }
  if (localSolidIndex > _maxPackedLocalSolidIndex) {
    throw ArgumentError.value(
      localSolidIndex,
      'localSolidIndex',
      'must be <= $_maxPackedLocalSolidIndex (30-bit)',
    );
  }
  if (surfaceKind < 0 || surfaceKind > 0x3) {
    throw ArgumentError.value(surfaceKind, 'surfaceKind', 'must fit in 2 bits');
  }
  // XOR with sign bit to make signed chunkIndex sort correctly as unsigned.
  final chunk = ((chunkIndex & 0xFFFFFFFF) ^ 0x80000000) & 0xFFFFFFFF;
  // Pack localSolidIndex and surfaceKind into lower 32 bits.
  final local = ((localSolidIndex << 2) | (surfaceKind & 0x3)) & 0xFFFFFFFF;
  return (chunk << 32) | local;
}

/// Extracts the chunk index from a packed [surfaceId].
int unpackChunkIndex(int surfaceId) {
  final chunk = (surfaceId >> 32) & 0xFFFFFFFF;
  final signed = (chunk ^ 0x80000000) & 0xFFFFFFFF;
  return (signed & 0x80000000) != 0 ? signed - 0x100000000 : signed;
}

/// Extracts the local solid index from a packed [surfaceId].
int unpackLocalSolidIndex(int surfaceId) {
  final local = surfaceId & 0xFFFFFFFF;
  return local >> 2;
}

/// Extracts the surface kind (Top/Side) from a packed [surfaceId].
int unpackSurfaceKind(int surfaceId) {
  return surfaceId & 0x3;
}


===== FILE: lib/core/navigation/types/walk_surface.dart =====
/// Represents a horizontal walkable platform segment in world space.
///
/// **Geometry**:
/// - A 1D segment along the X-axis at a fixed Y height ([yTop]).
/// - Defined by [[xMin], [xMax]] (inclusive bounds).
///
/// **Usage**:
/// - Used by the navigation system to represent ground/platforms.
/// - Entities can stand on this surface if their X is within [xMin, xMax].
class WalkSurface {
  const WalkSurface({
    required this.id,
    required this.xMin,
    required this.xMax,
    required this.yTop,
  }) : assert(xMax >= xMin);

  /// Unique identifier (packed via [packSurfaceId]).
  final int id;

  /// Left edge of the walkable segment (inclusive).
  final double xMin;
  
  /// Right edge of the walkable segment (inclusive).
  final double xMax;

  /// World-space Y coordinate of the top surface (where entities stand).
  final double yTop;

  /// Horizontal center of the surface.
  double get centerX => (xMin + xMax) * 0.5;
  
  /// Width of the walkable segment.
  double get width => xMax - xMin;
}



===== FILE: lib/core/navigation/utils/jump_template.dart =====
import '../types/nav_tolerances.dart';

/// Physics parameters for simulating a jump arc.
///
/// Used to precompute reachability templates for AI pathfinding.
class JumpProfile {
  const JumpProfile({
    required this.jumpSpeed,
    required this.gravityY,
    required this.maxAirTicks,
    required this.airSpeedX,
    required this.dtSeconds,
    required this.agentHalfWidth,
    this.agentHalfHeight,
    this.collideCeilings = true,
    this.collideLeftWalls = true,
    this.collideRightWalls = true,
  }) : assert(maxAirTicks > 0),
       assert(dtSeconds > 0),
       assert(agentHalfWidth > 0.0),
       assert(agentHalfHeight == null || agentHalfHeight > 0.0);

  /// Instantaneous vertical speed at jump start (negative = upward).
  final double jumpSpeed;

  /// Gravity acceleration (positive = downward, e.g., 980 for ~10m/s²).
  final double gravityY;

  /// Fixed timestep in seconds (e.g., 1/60 for 60Hz).
  final double dtSeconds;

  /// Maximum ticks to simulate (limits arc length for performance).
  final int maxAirTicks;

  /// Assumed constant horizontal speed while airborne.
  final double airSpeedX;

  /// Agent's collider half-width (for landing overlap calculations).
  final double agentHalfWidth;

  /// Agent's collider half-height for jump obstruction checks.
  ///
  /// If not provided, [agentHalfWidth] is used.
  final double? agentHalfHeight;

  /// Whether jump arc validation should treat ceiling bottoms as blocking.
  final bool collideCeilings;

  /// Whether jump arc validation should treat left-side body collisions as active.
  final bool collideLeftWalls;

  /// Whether jump arc validation should treat right-side body collisions as active.
  final bool collideRightWalls;

  /// Effective half-height used by jump obstruction checks.
  double get effectiveHalfHeight => agentHalfHeight ?? agentHalfWidth;
}

/// A single sample point along a precomputed jump arc.
class JumpSample {
  const JumpSample({
    required this.tick,
    required this.prevY,
    required this.y,
    required this.velY,
    required this.maxDx,
  });

  /// Tick number (1-based, 0 = takeoff).
  final int tick;

  /// Y position at the end of the previous tick.
  final double prevY;

  /// Y position at the end of this tick.
  final double y;

  /// Vertical velocity at the end of this tick.
  final double velY;

  /// Maximum horizontal displacement reachable by this tick.
  final double maxDx;
}

/// Result of a successful landing query.
class JumpLanding {
  const JumpLanding({required this.tick, required this.maxDx});

  /// Tick at which landing occurs.
  final int tick;

  /// Maximum horizontal reach at landing time.
  final double maxDx;
}

/// Precomputed jump arc template for reachability queries.
///
/// **Usage**:
/// - Built once from a [JumpProfile] (at startup or when physics change).
/// - Queried during graph construction to find valid jump edges.
///
/// **Physics**:
/// - Uses semi-implicit Euler integration: `vel += g*dt`, then `pos += vel*dt`.
/// - Matches the runtime physics in [GravitySystem].
class JumpReachabilityTemplate {
  JumpReachabilityTemplate._({
    required this.profile,
    required this.samples,
    required this.minDy,
    required this.maxDy,
    required this.maxDx,
  });

  /// The physics profile used to build this template.
  final JumpProfile profile;

  /// Sampled arc positions (tick 1 to maxAirTicks).
  final List<JumpSample> samples;

  /// Lowest Y offset reached (negative = above origin).
  final double minDy;

  /// Highest Y offset reached (positive = below origin, after fall).
  final double maxDy;

  /// Maximum horizontal distance reachable.
  final double maxDx;

  /// Builds a reachability template by simulating [profile.maxAirTicks] of flight.
  factory JumpReachabilityTemplate.build(JumpProfile profile) {
    final samples = <JumpSample>[];

    var y = 0.0;
    var velY = -profile.jumpSpeed; // Negative = upward
    final dt = profile.dtSeconds;
    var minDy = 0.0;
    var maxDy = 0.0;
    var maxDxOverall = 0.0;

    for (var tick = 1; tick <= profile.maxAirTicks; tick += 1) {
      final prevY = y;

      // Semi-implicit Euler: update velocity first, then position.
      velY += profile.gravityY * dt;
      y += velY * dt;

      // Horizontal reach increases linearly with time.
      final maxDx = profile.airSpeedX * dt * tick;

      // Track bounding box.
      if (y < minDy) minDy = y;
      if (y > maxDy) maxDy = y;
      if (maxDx > maxDxOverall) maxDxOverall = maxDx;

      samples.add(
        JumpSample(tick: tick, prevY: prevY, y: y, velY: velY, maxDx: maxDx),
      );
    }

    return JumpReachabilityTemplate._(
      profile: profile,
      samples: List<JumpSample>.unmodifiable(samples),
      minDy: minDy,
      maxDy: maxDy,
      maxDx: maxDxOverall,
    );
  }

  /// Finds the earliest tick at which a jump can land at vertical offset [dy].
  ///
  /// **Parameters**:
  /// - [dy]: Target vertical offset (positive = below takeoff, negative = above).
  /// - [dxMin], [dxMax]: Required horizontal range for a valid landing.
  ///
  /// **Returns**: [JumpLanding] if reachable, null otherwise.
  ///
  /// **Logic**:
  /// 1. Skip ascending samples (velY < 0).
  /// 2. Check if [dy] is crossed between prevY and y.
  /// 3. Check if horizontal range overlaps [dxMin, dxMax].
  JumpLanding? findFirstLanding({
    required double dy,
    required double dxMin,
    required double dxMax,
    double eps = navGeomEps,
  }) {
    if (dxMin > dxMax) return null;

    for (final sample in samples) {
      // Only consider descending phase.
      if (sample.velY < 0) continue;

      // Check vertical crossing: prevY <= dy <= y (with tolerance).
      final crosses = (sample.prevY <= dy + eps) && (sample.y >= dy - eps);
      if (!crosses) continue;

      // Check horizontal reachability.
      final maxDx = sample.maxDx;
      if (dxMin > maxDx + eps) continue; // Target too far right.
      if (dxMax < -maxDx - eps) continue; // Target too far left.

      return JumpLanding(tick: sample.tick, maxDx: maxDx);
    }

    return null;
  }
}

/// Estimates the number of ticks to fall a given vertical distance.
///
/// Used for "drop" edges (walking off a ledge without jumping).
///
/// **Parameters**:
/// - [dy]: Distance to fall (positive = downward).
/// - [gravityY]: Gravity acceleration.
/// - [dtSeconds]: Timestep.
/// - [maxTicks]: Upper bound to prevent infinite loops.
int estimateFallTicks({
  required double dy,
  required double gravityY,
  required double dtSeconds,
  required int maxTicks,
}) {
  if (dy <= 0) return 0;

  var y = 0.0;
  var velY = 0.0;

  for (var tick = 1; tick <= maxTicks; tick += 1) {
    velY += gravityY * dtSeconds;
    y += velY * dtSeconds;
    if (y >= dy) return tick;
  }

  return maxTicks;
}


===== FILE: lib/core/navigation/utils/surface_spatial_index.dart =====
import '../../ecs/spatial/grid_index_2d.dart';
import '../types/nav_tolerances.dart';
import '../types/walk_surface.dart';

/// Spatial hash grid for fast AABB queries against [WalkSurface]s.
///
/// **Purpose**:
/// - Given an AABB (e.g., entity bounds), quickly find all surfaces that might overlap.
/// - Avoids O(N) linear scans over all surfaces.
///
/// **Design**:
/// - Uses a uniform grid (via [GridIndex2D]) to bucket surfaces by cell.
/// - Surfaces spanning multiple cells are inserted into each overlapping cell.
/// - A stamp-based deduplication prevents returning the same surface twice per query.
///
/// **Lifecycle**:
/// - Call [rebuild] when static geometry changes (e.g., new chunk loaded).
/// - Call [queryAabb] during gameplay (e.g., to find surfaces under an entity).
class SurfaceSpatialIndex {
  SurfaceSpatialIndex({
    required GridIndex2D index,
    this.surfaceThickness = navSpatialEps,
  }) : _index = index;

  /// The underlying grid coordinate system.
  final GridIndex2D _index;
  
  /// Vertical thickness added above/below each surface for overlap tests.
  final double surfaceThickness;

  /// Cell key -> list of surface indices in that cell.
  final Map<int, List<int>> _buckets = <int, List<int>>{};
  
  /// Keys of all currently populated buckets (for fast clearing).
  final List<int> _activeKeys = <int>[];
  
  /// Pool of reusable bucket lists (reduces GC pressure).
  final List<List<int>> _bucketPool = <List<int>>[];

  /// Stamp-based deduplication: `_seenStampBySurface[i] == _stamp` means already seen.
  final List<int> _seenStampBySurface = <int>[];
  int _stamp = 0;
  int _surfaceCount = 0;

  /// Rebuilds the spatial index from a new set of surfaces.
  ///
  /// **Performance**: O(S * C) where S = surfaces, C = avg cells per surface.
  void rebuild(List<WalkSurface> surfaces) {
    // Return all active buckets to the pool.
    for (var i = 0; i < _activeKeys.length; i += 1) {
      final key = _activeKeys[i];
      final bucket = _buckets.remove(key);
      if (bucket == null) continue;
      bucket.clear();
      _bucketPool.add(bucket);
    }
    _activeKeys.clear();

    _surfaceCount = surfaces.length;
    if (surfaces.isEmpty) return;

    // Insert each surface into all cells it overlaps.
    for (var si = 0; si < surfaces.length; si += 1) {
      final surface = surfaces[si];
      
      // Surface AABB: horizontal span + thin vertical slab.
      final minX = surface.xMin;
      final maxX = surface.xMax;
      final minY = surface.yTop - surfaceThickness;
      final maxY = surface.yTop + surfaceThickness;

      // Convert to cell coordinates.
      final minCx = _index.worldToCellX(minX);
      final maxCx = _index.worldToCellX(maxX);
      final minCy = _index.worldToCellY(minY);
      final maxCy = _index.worldToCellY(maxY);

      // Insert surface index into each overlapping cell.
      for (var cellY = minCy; cellY <= maxCy; cellY += 1) {
        for (var cellX = minCx; cellX <= maxCx; cellX += 1) {
          final key = _index.cellKey(cellX, cellY);
          var bucket = _buckets[key];
          if (bucket == null) {
            // Reuse pooled bucket or allocate new.
            bucket = _bucketPool.isNotEmpty ? _bucketPool.removeLast() : <int>[];
            _buckets[key] = bucket;
            _activeKeys.add(key);
          }
          bucket.add(si);
        }
      }
    }
  }

  /// Finds all surfaces overlapping the given AABB.
  ///
  /// Results are written to [outSurfaceIndices] (cleared first).
  /// Each surface index appears at most once (deduplicated via stamp).
  ///
  /// **Performance**: O(C * B) where C = cells in query, B = avg bucket size.
  void queryAabb({
    required double minX,
    required double minY,
    required double maxX,
    required double maxY,
    required List<int> outSurfaceIndices,
  }) {
    outSurfaceIndices.clear();
    if (_activeKeys.isEmpty) return;

    // Advance the deduplication stamp.
    _stamp += 1;
    if (_stamp == 0x7FFFFFFF) {
      // Overflow protection: reset all stamps.
      for (var i = 0; i < _seenStampBySurface.length; i += 1) {
        _seenStampBySurface[i] = 0;
      }
      _stamp = 1;
    }

    // Determine cell range for query AABB.
    final minCx = _index.worldToCellX(minX);
    final maxCx = _index.worldToCellX(maxX);
    final minCy = _index.worldToCellY(minY);
    final maxCy = _index.worldToCellY(maxY);

    // Ensure stamp array is large enough.
    if (_seenStampBySurface.length < _surfaceCount) {
      final missing = _surfaceCount - _seenStampBySurface.length;
      for (var i = 0; i < missing; i += 1) {
        _seenStampBySurface.add(0);
      }
    }

    // Iterate all cells in query range.
    for (var cellY = minCy; cellY <= maxCy; cellY += 1) {
      for (var cellX = minCx; cellX <= maxCx; cellX += 1) {
        final key = _index.cellKey(cellX, cellY);
        final bucket = _buckets[key];
        if (bucket == null || bucket.isEmpty) continue;

        // Add each unseen surface to results.
        for (var bi = 0; bi < bucket.length; bi += 1) {
          final surfaceIndex = bucket[bi];
          if (_seenStampBySurface[surfaceIndex] == _stamp) continue;
          _seenStampBySurface[surfaceIndex] = _stamp;
          outSurfaceIndices.add(surfaceIndex);
        }
      }
    }
  }
}


===== FILE: lib/core/navigation/utils/trajectory_predictor.dart =====
import '../types/surface_graph.dart';
import '../types/nav_tolerances.dart';
import 'surface_spatial_index.dart';

/// Prediction result for where an airborne entity will land.
class LandingPrediction {
  const LandingPrediction({
    required this.x,
    required this.bottomY,
    required this.surfaceIndex,
    required this.ticksToLand,
  });

  /// Predicted X position at landing.
  final double x;

  /// Predicted bottom Y position at landing (on surface).
  final double bottomY;

  /// Index of the surface in [SurfaceGraph.surfaces] where landing occurs.
  final int surfaceIndex;

  /// Number of ticks until landing.
  final int ticksToLand;
}

/// Predicts where an airborne entity will land.
///
/// **Purpose**:
/// Used by ground enemy AI to anticipate where an airborne player will land,
/// enabling pathfinding toward the predicted landing spot instead of the
/// player's current (airborne) position.
///
/// **Algorithm**:
/// Simulates the entity's trajectory tick-by-tick using semi-implicit Euler
/// integration (matching [GravitySystem]), checking for surface intersections
/// at each step.
///
/// **Usage**:
/// ```dart
/// final predictor = TrajectoryPredictor(
///   gravityY: physics.gravityY,
///   dtSeconds: movement.dtSeconds,
///   maxTicks: 120,
/// );
///
/// final prediction = predictor.predictLanding(
///   startX: playerX,
///   startBottomY: playerBottomY,
///   velX: playerVelX,
///   velY: playerVelY,
///   graph: surfaceGraph,
///   spatialIndex: surfaceSpatialIndex,
///   entityHalfWidth: playerHalfX,
/// );
/// ```
class TrajectoryPredictor {
  TrajectoryPredictor({
    required this.gravityY,
    required this.dtSeconds,
    required this.maxTicks,
  });

  /// Gravity acceleration (positive = downward).
  final double gravityY;

  /// Fixed timestep in seconds.
  final double dtSeconds;

  /// Maximum ticks to simulate before giving up.
  final int maxTicks;

  /// Reused candidate buffer for spatial queries (avoids per-call allocation).
  final List<int> _candidateBuffer = <int>[];

  /// Predicts landing position for an airborne entity.
  ///
  /// **Parameters**:
  /// - [startX], [startBottomY]: Current position (bottom of collider).
  /// - [velX], [velY]: Current velocity.
  /// - [graph]: Surface graph for landing candidates.
  /// - [spatialIndex]: Spatial index for fast surface queries.
  /// - [entityHalfWidth]: Half-width of the entity collider.
  ///
  /// **Returns**: [LandingPrediction] if a valid landing is found, null otherwise.
  ///
  /// **Edge Cases**:
  /// - Returns null if entity is moving upward and never descends (shouldn't happen with gravity).
  /// - Returns null if no surface intersects the trajectory within [maxTicks].
  /// - Returns the FIRST valid landing (earliest tick) if multiple surfaces are crossed.
  LandingPrediction? predictLanding({
    required double startX,
    required double startBottomY,
    required double velX,
    required double velY,
    required SurfaceGraph graph,
    required SurfaceSpatialIndex spatialIndex,
    required double entityHalfWidth,
  }) {
    if (graph.surfaces.isEmpty) return null;

    var x = startX;
    var y = startBottomY;
    var vy = velY;
    final dt = dtSeconds;

    for (var tick = 1; tick <= maxTicks; tick += 1) {
      final prevX = x;
      final prevY = y;

      // Semi-implicit Euler (matches GravitySystem).
      vy += gravityY * dt;
      y += vy * dt;
      x += velX * dt;

      // Only check for landing when descending (vy > 0 means moving downward).
      if (vy <= 0) continue;

      // Check if we crossed any surface between prevY and y.
      final landing = _findLandingSurface(
        graph: graph,
        spatialIndex: spatialIndex,
        candidates: _candidateBuffer,
        prevX: prevX,
        x: x,
        prevY: prevY,
        y: y,
        entityHalfWidth: entityHalfWidth,
        tick: tick,
      );

      if (landing != null) {
        return landing;
      }
    }

    return null;
  }

  /// Checks if the trajectory crossed a valid landing surface this tick.
  LandingPrediction? _findLandingSurface({
    required SurfaceGraph graph,
    required SurfaceSpatialIndex spatialIndex,
    required List<int> candidates,
    required double prevX,
    required double x,
    required double prevY,
    required double y,
    required double entityHalfWidth,
    required int tick,
  }) {
    // Query surfaces in the swept AABB traversed this tick.
    final minX = (prevX < x ? prevX : x) - entityHalfWidth;
    final maxX = (prevX > x ? prevX : x) + entityHalfWidth;
    final minY = prevY < y ? prevY : y;
    final maxY = prevY > y ? prevY : y;

    spatialIndex.queryAabb(
      minX: minX,
      minY: minY,
      maxX: maxX,
      maxY: maxY,
      outSurfaceIndices: candidates,
    );

    if (candidates.isEmpty) return null;

    // Find the highest surface (lowest yTop) that we crossed.
    // This handles cases where trajectory passes through multiple surfaces.
    int? bestIndex;
    double? bestYTop;
    double? bestLandingX;
    final dyStep = y - prevY;
    if (dyStep == 0.0) return null;

    for (final surfaceIndex in candidates) {
      final surface = graph.surfaces[surfaceIndex];

      // Check vertical crossing: prevY was above (or at) surface, y is at or below.
      // We want surfaces where prevY <= yTop <= y (crossed from above).
      final yTop = surface.yTop;
      if (prevY > yTop) continue; // Started below surface, can't land on it.
      if (y < yTop) continue; // Ended above surface, haven't reached it yet.

      // Interpolate horizontal position at the exact crossing time.
      final t = (yTop - prevY) / dyStep;
      final landingX = prevX + (x - prevX) * t;

      // Check standability at landing X.
      // Allow tiny horizontal overhang tolerance to stay consistent with
      // runtime collision support checks on narrow tops.
      final standableMinX = surface.xMin + entityHalfWidth - navSpatialEps;
      final standableMaxX = surface.xMax - entityHalfWidth + navSpatialEps;
      if (standableMinX > standableMaxX) continue;
      if (landingX < standableMinX || landingX > standableMaxX) continue;

      // Valid landing candidate. Prefer highest surface (lowest yTop).
      if (bestYTop == null || yTop < bestYTop) {
        bestYTop = yTop;
        bestIndex = surfaceIndex;
        bestLandingX = landingX;
      }
    }

    if (bestIndex == null) return null;

    return LandingPrediction(
      x: bestLandingX!,
      bottomY: bestYTop!,
      surfaceIndex: bestIndex,
      ticksToLand: tick,
    );
  }
}


===== FILE: lib/core/pickups/pickup_render_catalog.dart =====
import '../contracts/render_anim_set_definition.dart';
import '../snapshots/entity_render_snapshot.dart';
import '../snapshots/enums.dart';

const int _frameW = 16;
const int _frameH = 16;
const int _frames = 12;
const double _stepSeconds = 0.08;

const Map<AnimKey, int> _frameCountsByKey = <AnimKey, int>{
  AnimKey.idle: _frames,
};

const Map<AnimKey, double> _stepTimeSecondsByKey = <AnimKey, double>{
  AnimKey.idle: _stepSeconds,
};

RenderAnimSetDefinition _rowFromSheet({
  required String assetPath,
  required int row,
}) {
  return RenderAnimSetDefinition(
    frameWidth: _frameW,
    frameHeight: _frameH,
    sourcesByKey: <AnimKey, String>{AnimKey.idle: assetPath},
    frameCountsByKey: _frameCountsByKey,
    stepTimeSecondsByKey: _stepTimeSecondsByKey,
    rowByKey: <AnimKey, int>{AnimKey.idle: row},
  );
}

class PickupRenderCatalog {
  const PickupRenderCatalog();

  RenderAnimSetDefinition get(int pickupVariant) {
    switch (pickupVariant) {
      case PickupVariant.collectible:
        return _rowFromSheet(
          assetPath: 'entities/collectibles/coins.png',
          row: 0,
        );
      case PickupVariant.restorationHealth:
        return _rowFromSheet(
          assetPath: 'entities/regenerationItems/gems.png',
          row: 0,
        );
      case PickupVariant.restorationMana:
        return _rowFromSheet(
          assetPath: 'entities/regenerationItems/gems.png',
          row: 1,
        );
      case PickupVariant.restorationStamina:
        return _rowFromSheet(
          assetPath: 'entities/regenerationItems/gems.png',
          row: 2,
        );
      default:
        throw StateError(
          'No render animation defined for pickupVariant=$pickupVariant.',
        );
    }
  }
}


===== FILE: lib/core/players/characters/eloise.dart =====
library;

import 'package:rpg_runner/core/spellBook/spell_book_id.dart';

import '../../ecs/stores/body_store.dart';
import '../../ecs/stores/combat/creature_tag_store.dart';
import '../../ecs/stores/combat/damage_resistance_store.dart';
import '../../ecs/stores/combat/equipped_loadout_store.dart';
import '../../ecs/stores/combat/status_immunity_store.dart';
import '../../combat/creature_tag.dart';
import '../../snapshots/enums.dart';
import '../../projectiles/projectile_id.dart';
import '../../weapons/weapon_id.dart';
import '../player_character_definition.dart';
import '../player_catalog.dart';
import '../player_tuning.dart';
import '../../contracts/render_anim_set_definition.dart';

/// Baseline character definition: Éloïse.
///
/// All current "default player" values in v0 are treated as belonging to Éloïse.

// -----------------------------------------------------------------------------
// Éloïse render animation strip definitions (authoring-time)
// -----------------------------------------------------------------------------

const int eloiseAnimFrameWidth = 100;
const int eloiseAnimFrameHeight = 64;

const int eloiseAnimIdleFrames = 4;
const double eloiseAnimIdleStepSeconds = 0.14;

const int eloiseAnimStunFrames = 4;
const double eloiseAnimStunStepSeconds = 0.14;

const int eloiseAnimRunFrames = 7;
const double eloiseAnimRunStepSeconds = 0.08;

const int eloiseAnimWalkFrames = 7;
const double eloiseAnimWalkStepSeconds = 0.16;

const int eloiseAnimJumpFrames = 6;
const double eloiseAnimJumpStepSeconds = 0.10;

const int eloiseAnimFallFrames = 3;
const double eloiseAnimFallStepSeconds = 0.10;

const int eloiseAnimStrikeFrames = 6;
const double eloiseAnimStrikeStepSeconds = 0.06;

const int eloiseAnimBackStrikeFrames = 5;
const double eloiseAnimBackStrikeStepSeconds = 0.08;

const int eloiseAnimParryFrames = 6;
const double eloiseAnimParryStepSeconds = 0.06;

const int eloiseAnimCastFrames = 5;
const double eloiseAnimCastStepSeconds = 0.08;

const int eloiseAnimRangedFrames = eloiseAnimCastFrames;
const double eloiseAnimRangedStepSeconds = eloiseAnimCastStepSeconds;

// Shield bash should match sword strike tempo (6 frames x 0.06s).
const int eloiseAnimShieldBashFrames = eloiseAnimStrikeFrames;
const double eloiseAnimShieldBashStepSeconds = eloiseAnimStrikeStepSeconds;

// Shield block is authored as its own strip: 7 frames x ~0.052s ~= 0.364s.
// Keep it close to parry/strike total duration (~0.36s) for consistent gameplay timing.
const int eloiseAnimShieldBlockFrames = 7;
const double eloiseAnimShieldBlockStepSeconds = 0.052;

const int eloiseAnimDashFrames = 4;
const double eloiseAnimDashStepSeconds = 0.05;

const int eloiseAnimRollFrames = 10;
const double eloiseAnimRollStepSeconds = 0.01;

const int eloiseAnimHitFrames = 4;
const double eloiseAnimHitStepSeconds = 0.10;

const int eloiseAnimDeathFrames = 6;
const double eloiseAnimDeathStepSeconds = 0.12;

// Spawn reuses idle timing/frames until a dedicated strip exists.
const int eloiseAnimSpawnFrames = eloiseAnimIdleFrames;
const double eloiseAnimSpawnStepSeconds = eloiseAnimIdleStepSeconds;

const Map<AnimKey, int> eloiseAnimFrameCountsByKey = <AnimKey, int>{
  AnimKey.idle: eloiseAnimIdleFrames,
  AnimKey.stun: eloiseAnimStunFrames,
  AnimKey.run: eloiseAnimRunFrames,
  AnimKey.jump: eloiseAnimJumpFrames,
  AnimKey.fall: eloiseAnimFallFrames,
  AnimKey.strike: eloiseAnimStrikeFrames,
  AnimKey.backStrike: eloiseAnimBackStrikeFrames,
  AnimKey.parry: eloiseAnimParryFrames,
  AnimKey.cast: eloiseAnimCastFrames,
  AnimKey.ranged: eloiseAnimRangedFrames,
  AnimKey.shieldBash: eloiseAnimShieldBashFrames,
  AnimKey.shieldBlock: eloiseAnimShieldBlockFrames,
  AnimKey.dash: eloiseAnimDashFrames,
  AnimKey.roll: eloiseAnimRollFrames,
  AnimKey.hit: eloiseAnimHitFrames,
  AnimKey.death: eloiseAnimDeathFrames,
  AnimKey.spawn: eloiseAnimSpawnFrames,
  AnimKey.walk: eloiseAnimWalkFrames,
};

const Map<AnimKey, double> eloiseAnimStepTimeSecondsByKey = <AnimKey, double>{
  AnimKey.idle: eloiseAnimIdleStepSeconds,
  AnimKey.stun: eloiseAnimStunStepSeconds,
  AnimKey.run: eloiseAnimRunStepSeconds,
  AnimKey.jump: eloiseAnimJumpStepSeconds,
  AnimKey.fall: eloiseAnimFallStepSeconds,
  AnimKey.strike: eloiseAnimStrikeStepSeconds,
  AnimKey.backStrike: eloiseAnimBackStrikeStepSeconds,
  AnimKey.parry: eloiseAnimParryStepSeconds,
  AnimKey.cast: eloiseAnimCastStepSeconds,
  AnimKey.ranged: eloiseAnimRangedStepSeconds,
  AnimKey.shieldBash: eloiseAnimShieldBashStepSeconds,
  AnimKey.shieldBlock: eloiseAnimShieldBlockStepSeconds,
  AnimKey.dash: eloiseAnimDashStepSeconds,
  AnimKey.roll: eloiseAnimRollStepSeconds,
  AnimKey.hit: eloiseAnimHitStepSeconds,
  AnimKey.death: eloiseAnimDeathStepSeconds,
  AnimKey.spawn: eloiseAnimSpawnStepSeconds,
  AnimKey.walk: eloiseAnimWalkStepSeconds,
};

const Map<AnimKey, String> eloiseAnimSourcesByKey = <AnimKey, String>{
  AnimKey.idle: 'entities/player/idle.png',
  AnimKey.stun: 'entities/player/stun.png',
  AnimKey.run: 'entities/player/move.png',
  AnimKey.jump: 'entities/player/jump.png',
  AnimKey.fall: 'entities/player/fall.png',
  AnimKey.strike: 'entities/player/strike.png',
  AnimKey.backStrike: 'entities/player/back_strike.png',
  AnimKey.parry: 'entities/player/parry.png',
  AnimKey.cast: 'entities/player/cast.png',
  AnimKey.ranged: 'entities/player/cast.png',
  AnimKey.shieldBash: 'entities/player/shield_bash.png',
  AnimKey.shieldBlock: 'entities/player/shield_block.png',
  AnimKey.dash: 'entities/player/dash.png',
  AnimKey.roll: 'entities/player/roll.png',
  AnimKey.hit: 'entities/player/hit.png',
  AnimKey.death: 'entities/player/death.png',
  AnimKey.spawn: 'entities/player/idle.png',
  AnimKey.walk: 'entities/player/walk.png',
};

const RenderAnimSetDefinition eloiseRenderAnim = RenderAnimSetDefinition(
  frameWidth: eloiseAnimFrameWidth,
  frameHeight: eloiseAnimFrameHeight,
  sourcesByKey: eloiseAnimSourcesByKey,
  frameCountsByKey: eloiseAnimFrameCountsByKey,
  stepTimeSecondsByKey: eloiseAnimStepTimeSecondsByKey,
);

// -----------------------------------------------------------------------------
// Éloïse authored Core values (single-file source of truth)
// -----------------------------------------------------------------------------

const PlayerCatalog eloiseCatalog = PlayerCatalog(
  bodyTemplate: BodyDef(
    isKinematic: false,
    useGravity: true,
    ignoreCeilings: false,
    topOnlyGround: true,
    gravityScale: 1.0,
    sideMask: BodyDef.sideLeft | BodyDef.sideRight,
  ),
  colliderWidth: 22.0,
  colliderHeight: 46.0,
  colliderOffsetX: 0.0,
  colliderOffsetY: 0.0,
  tags: CreatureTagDef(mask: CreatureTagMask.humanoid),
  resistance: DamageResistanceDef(),
  statusImmunity: StatusImmunityDef(),
  loadoutSlotMask: LoadoutSlotMask.all,
  weaponId: WeaponId.woodenSword,
  offhandWeaponId: WeaponId.woodenShield,
  projectileId: ProjectileId.throwingKnife,
  spellBookId: SpellBookId.basicSpellBook,
  projectileSlotSpellId: ProjectileId.fireBolt,
  abilityPrimaryId: 'eloise.bloodletter_slash',
  abilitySecondaryId: 'eloise.aegis_riposte',
  abilityProjectileId: 'eloise.quick_shot',
  abilitySpellId: 'eloise.arcane_haste',
  abilityMobilityId: 'eloise.dash',
  abilityJumpId: 'eloise.jump',
  facing: Facing.right,
);

const PlayerTuning eloiseTuning = PlayerTuning(
  movement: MovementTuning(
    maxSpeedX: 200,
    accelerationX: 600,
    decelerationX: 400,
    minMoveSpeed: 5,
    runSpeedThresholdX: 120,
    maxVelX: 1500,
    maxVelY: 1500,
    jumpSpeed: 500,
    coyoteTimeSeconds: 0.10,
    jumpBufferSeconds: 0.12,
    dashDurationSeconds: 0.20,
    dashCooldownSeconds: 2.0,
  ),
  resource: ResourceTuning(
    playerHpMax: 100,
    playerHpRegenPerSecond: 0.5,
    playerManaMax: 100,
    playerManaRegenPerSecond: 2.0,
    playerStaminaMax: 100,
    playerStaminaRegenPerSecond: 1.0,
    jumpStaminaCost: 2,
    dashStaminaCost: 2,
  ),
  ability: AbilityTuning(
    castCooldownSeconds: 0.25,
    meleeCooldownSeconds: 0.30,
    meleeActiveSeconds: 0.10,
    meleeStaminaCost: 5.0,
    meleeDamage: 15.0,
    meleeHitboxSizeX: 32.0,
    meleeHitboxSizeY: 32.0,
  ),
  // Keep these windows in sync with Éloïse's render strips above.
  anim: AnimTuning(
    hitAnimSeconds: eloiseAnimHitFrames * eloiseAnimHitStepSeconds,
    deathAnimSeconds: eloiseAnimDeathFrames * eloiseAnimDeathStepSeconds,
    spawnAnimSeconds: eloiseAnimSpawnFrames * eloiseAnimSpawnStepSeconds,
  ),
  combat: CombatTuning(invulnerabilitySeconds: 0.25),
);

const PlayerCharacterDefinition eloiseCharacter = PlayerCharacterDefinition(
  id: PlayerCharacterId.eloise,
  displayName: 'Éloïse',
  renderAnim: eloiseRenderAnim,
  catalog: eloiseCatalog,
  tuning: eloiseTuning,
);


===== FILE: lib/core/players/characters/eloise_wip.dart =====
library;

import 'eloise.dart';
import '../player_character_definition.dart';

const PlayerCharacterDefinition eloiseWipCharacter = PlayerCharacterDefinition(
  id: PlayerCharacterId.eloiseWip,
  displayName: 'Éloïse (WIP)',
  renderAnim: eloiseRenderAnim,
  catalog: eloiseCatalog,
  tuning: eloiseTuning,
);


===== FILE: lib/core/players/player_archetype.dart =====
import '../ecs/stores/body_store.dart';
import '../ecs/stores/collider_aabb_store.dart';
import '../ecs/stores/combat/creature_tag_store.dart';
import '../ecs/stores/combat/damage_resistance_store.dart';
import '../ecs/stores/combat/equipped_loadout_store.dart';
import '../ecs/stores/combat/status_immunity_store.dart';
import '../ecs/stores/health_store.dart';
import '../ecs/stores/mana_store.dart';
import '../ecs/stores/stamina_store.dart';
import '../snapshots/enums.dart';
import '../projectiles/projectile_id.dart';
import '../spellBook/spell_book_id.dart';
import '../weapons/weapon_id.dart';
import '../abilities/ability_def.dart';

/// Fully-resolved player configuration used to spawn the player entity.
///
/// **Purpose**:
/// Contains all the component definitions needed to instantiate a player
/// entity in the ECS world. Unlike [PlayerCatalog], which holds authoring-time
/// templates, this class holds final, tick-rate-independent values ready for
/// entity creation.
///
/// **Lifecycle**:
/// 1. [PlayerCatalog] defines base templates (physics flags, default facing).
/// 2. [PlayerCatalogDerived.from] merges templates with tuning data to produce
///    a [PlayerArchetype].
/// 3. [EntityFactory.createPlayer] uses the archetype to add components..
class PlayerArchetype {
  const PlayerArchetype({
    required this.collider,
    required this.body,
    required this.health,
    required this.mana,
    required this.stamina,
    required this.tags,
    required this.resistance,
    required this.statusImmunity,
    required this.loadoutSlotMask,
    required this.weaponId,
    required this.offhandWeaponId,
    required this.projectileId,
    required this.spellBookId,
    required this.projectileSlotSpellId,
    required this.abilityPrimaryId,
    required this.abilitySecondaryId,
    required this.abilityProjectileId,
    required this.abilitySpellId,
    required this.abilityMobilityId,
    required this.abilityJumpId,
    required this.facing,
  });

  /// AABB collider definition (half-extents and offset).
  ///
  /// Determines the player's collision bounds for physics and hit detection.
  /// Typically derived from [PlayerCatalog.colliderWidth] and
  /// [PlayerCatalog.colliderHeight].
  final ColliderAabbDef collider;

  /// Physics body configuration (gravity, kinematic flags, velocity clamps).
  ///
  /// Controls how the player interacts with the physics simulation:
  /// - `useGravity`: Whether gravity affects the player.
  /// - `maxVelX/maxVelY`: Velocity clamps from movement tuning.
  /// - `sideMask`: Which collision sides are active.
  final BodyDef body;

  /// Health pool definition (current HP, max HP, regeneration rate).
  ///
  /// Values derived from [ResourceTuning.playerHpMax] and related fields.
  final HealthDef health;

  /// Mana pool definition (current mana, max mana, regeneration rate).
  ///
  /// Used for projectile abilities. Values from [ResourceTuning.playerManaMax].
  final ManaDef mana;

  /// Stamina pool definition (current stamina, max stamina, regeneration rate).
  ///
  /// Used for abilities like dash. Values from [ResourceTuning.playerStaminaMax].
  final StaminaDef stamina;

  /// Broad tags used by combat rules and content filters.
  final CreatureTagDef tags;

  /// Resistance/vulnerability modifiers by damage type.
  final DamageResistanceDef resistance;

  /// Status effect immunities for the player.
  final StatusImmunityDef statusImmunity;

  /// Bitmask of enabled loadout slots (see [LoadoutSlotMask]).
  final int loadoutSlotMask;

  /// Equipped weapon used for melee strikes.
  final WeaponId weaponId;

  /// Equipped off-hand weapon or shield.
  final WeaponId offhandWeaponId;

  /// Equipped projectile item used for thrown/ballistic projectiles.
  final ProjectileId projectileId;

  /// Equipped spell book used for spell payloads.
  final SpellBookId spellBookId;

  /// Optional spell selection used by projectile-slot projectile abilities.
  final ProjectileId? projectileSlotSpellId;

  /// Equipped ability IDs (loadout defaults).
  final AbilityKey abilityPrimaryId;
  final AbilityKey abilitySecondaryId;
  final AbilityKey abilityProjectileId;
  final AbilityKey abilitySpellId;
  final AbilityKey abilityMobilityId;
  final AbilityKey abilityJumpId;

  /// Initial facing direction when the player spawns.
  ///
  /// Affects sprite rendering and directional abilities.
  final Facing facing;
}


===== FILE: lib/core/players/player_catalog.dart =====
import '../ecs/stores/body_store.dart';
import '../ecs/stores/collider_aabb_store.dart';
import '../ecs/stores/combat/creature_tag_store.dart';
import '../ecs/stores/combat/damage_resistance_store.dart';
import '../ecs/stores/combat/equipped_loadout_store.dart';
import '../ecs/stores/combat/status_immunity_store.dart';
import '../ecs/stores/health_store.dart';
import '../ecs/stores/mana_store.dart';
import '../ecs/stores/stamina_store.dart';
import '../snapshots/enums.dart';
import 'player_tuning.dart';
import '../projectiles/projectile_id.dart';
import '../spellBook/spell_book_id.dart';
import '../weapons/weapon_id.dart';
import 'player_archetype.dart';
import '../abilities/ability_def.dart';

/// Authoring-time configuration for the player entity.
///
/// **Purpose**:
/// Defines the base template for player physics and spawn behavior. This class
/// holds values that are independent of tick rate or specific tuning numbers,
/// focusing on structural configuration (what physics flags to use, etc.).
///
/// **Relationship to Tuning**:
/// - [PlayerCatalog]: Structural config (physics flags, collision sides).
/// - [MovementTuning]: Numeric movement values (speed, collider size, velocity clamps).
/// - [ResourceTuning]: Numeric resource values (HP, mana, stamina).
///
/// The [PlayerCatalogDerived.from] factory merges all three to produce a
/// complete [PlayerArchetype] ready for entity creation.
class PlayerCatalog {
  const PlayerCatalog({
    required this.bodyTemplate,
    required this.colliderWidth,
    required this.colliderHeight,
    required this.colliderOffsetX,
    required this.colliderOffsetY,
    required this.tags,
    required this.resistance,
    required this.statusImmunity,
    required this.loadoutSlotMask,
    required this.weaponId,
    required this.offhandWeaponId,
    required this.projectileId,
    required this.spellBookId,
    required this.projectileSlotSpellId,
    required this.abilityPrimaryId,
    required this.abilitySecondaryId,
    required this.abilityProjectileId,
    required this.abilitySpellId,
    required this.abilityMobilityId,
    required this.abilityJumpId,
    required this.facing,
  });

  /// Template for how the player participates in physics.
  ///
  /// **Fields used from template**:
  /// - `isKinematic`: False for player (affected by forces).
  /// - `useGravity`: True (player falls).
  /// - `ignoreCeilings`: False (player collides with ceilings).
  /// - `topOnlyGround`: True (only collide with top of ground, not sides).
  /// - `gravityScale`: 1.0 (normal gravity).
  /// - `sideMask`: Left + Right (collide with walls on both sides).
  ///
  /// **Fields filled from [MovementTuning] during derivation**:
  /// - `maxVelX`: Horizontal velocity clamp.
  /// - `maxVelY`: Vertical velocity clamp.
  ///
  /// This split ensures movement tuning remains the single source of truth
  /// for velocity limits.
  final BodyDef bodyTemplate;

  /// Player collision AABB size (full extents) in world units.
  ///
  /// Core uses center-based AABBs, so `halfX = width * 0.5` and
  /// `halfY = height * 0.5`.
  final double colliderWidth;
  final double colliderHeight;

  /// Optional collider center offset from entity `Transform.pos`.
  final double colliderOffsetX;
  final double colliderOffsetY;

  double get colliderHalfX => colliderWidth * 0.5;
  double get colliderHalfY => colliderHeight * 0.5;
  double get colliderMaxHalfExtent =>
      colliderHalfX > colliderHalfY ? colliderHalfX : colliderHalfY;

  /// Broad tags used by combat rules and content filters.
  final CreatureTagDef tags;

  /// Resistance/vulnerability modifiers by damage type.
  final DamageResistanceDef resistance;

  /// Status effect immunities for the player.
  final StatusImmunityDef statusImmunity;

  /// Bitmask of enabled loadout slots (see [LoadoutSlotMask]).
  final int loadoutSlotMask;

  /// Default equipped weapon at spawn time.
  final WeaponId weaponId;

  /// Default equipped off-hand weapon or shield at spawn time.
  final WeaponId offhandWeaponId;

  /// Default equipped projectile item at spawn time.
  final ProjectileId projectileId;

  /// Default equipped spell book at spawn time.
  final SpellBookId spellBookId;

  /// Optional spell selection used by projectile-slot projectile abilities.
  final ProjectileId? projectileSlotSpellId;

  /// Default equipped ability IDs at spawn time.
  final AbilityKey abilityPrimaryId;
  final AbilityKey abilitySecondaryId;
  final AbilityKey abilityProjectileId;
  final AbilityKey abilitySpellId;
  final AbilityKey abilityMobilityId;
  final AbilityKey abilityJumpId;

  /// Default facing direction at spawn time.
  ///
  /// Determines initial sprite orientation and directional ability targeting.
  final Facing facing;
}

/// Derived player configuration with tick-rate-resolved values.
///
/// **Purpose**:
/// Combines [PlayerCatalog] templates with [MovementTuning] and [ResourceTuning]
/// to produce a complete [PlayerArchetype]. This is the "compiled" form of
/// player configuration, ready for entity creation.
///
/// **Why a Separate Class?**:
/// - Tuning values may be tick-rate dependent (e.g., regen per second → per tick).
/// - Collider size comes from movement tuning, not catalog.
/// - Resource pools (HP, mana, stamina) come from resource tuning.
/// - Keeping derivation explicit makes dependencies clear and testable.
///
/// **Lifecycle**:
/// Created once at game initialization, stored in [GameCore], used whenever
/// the player needs to be spawned or respawned.
class PlayerCatalogDerived {
  const PlayerCatalogDerived._({required this.archetype});

  /// Creates a derived catalog by merging base config with tuning data.
  ///
  /// **Parameters**:
  /// - [base]: The authoring-time catalog with physics flags.
  /// - [movement]: Movement tuning for collider size and velocity clamps.
  /// - [resources]: Resource tuning for HP, mana, and stamina pools.
  ///
  /// **Derivation Logic**:
  /// 1. Copy physics flags from [base.bodyTemplate].
  /// 2. Fill `maxVelX`/`maxVelY` from [movement].
  /// 3. Create AABB collider from [base].
  /// 4. Create resource pools from [resources].
  /// 5. Bundle everything into a [PlayerArchetype].
  factory PlayerCatalogDerived.from(
    PlayerCatalog base, {
    required MovementTuningDerived movement,
    required ResourceTuningDerived resources,
  }) {
    // Merge body template with velocity clamps from movement tuning.
    final body = BodyDef(
      enabled: base.bodyTemplate.enabled,
      isKinematic: base.bodyTemplate.isKinematic,
      useGravity: base.bodyTemplate.useGravity,
      ignoreCeilings: base.bodyTemplate.ignoreCeilings,
      topOnlyGround: base.bodyTemplate.topOnlyGround,
      gravityScale: base.bodyTemplate.gravityScale,
      maxVelX: movement.base.maxVelX,
      maxVelY: movement.base.maxVelY,
      sideMask: base.bodyTemplate.sideMask,
    );

    // AABB collider from catalog.
    final collider = ColliderAabbDef(
      halfX: base.colliderHalfX,
      halfY: base.colliderHalfY,
      offsetX: base.colliderOffsetX,
      offsetY: base.colliderOffsetY,
    );

    // Resource pools from resource tuning.
    final health = HealthDef(
      hp: resources.playerHpMax100,
      hpMax: resources.playerHpMax100,
      regenPerSecond100: resources.playerHpRegenPerSecond100,
    );
    final mana = ManaDef(
      mana: resources.playerManaMax100,
      manaMax: resources.playerManaMax100,
      regenPerSecond100: resources.playerManaRegenPerSecond100,
    );
    final stamina = StaminaDef(
      stamina: resources.playerStaminaMax100,
      staminaMax: resources.playerStaminaMax100,
      regenPerSecond100: resources.playerStaminaRegenPerSecond100,
    );

    return PlayerCatalogDerived._(
      archetype: PlayerArchetype(
        collider: collider,
        body: body,
        health: health,
        mana: mana,
        stamina: stamina,
        tags: base.tags,
        resistance: base.resistance,
        statusImmunity: base.statusImmunity,
        loadoutSlotMask: base.loadoutSlotMask,
        weaponId: base.weaponId,
        offhandWeaponId: base.offhandWeaponId,
        projectileId: base.projectileId,
        spellBookId: base.spellBookId,
        projectileSlotSpellId: base.projectileSlotSpellId,
        abilityPrimaryId: base.abilityPrimaryId,
        abilitySecondaryId: base.abilitySecondaryId,
        abilityProjectileId: base.abilityProjectileId,
        abilitySpellId: base.abilitySpellId,
        abilityMobilityId: base.abilityMobilityId,
        abilityJumpId: base.abilityJumpId,
        facing: base.facing,
      ),
    );
  }

  /// The fully-resolved player archetype ready for entity creation.
  ///
  /// Use this with [EntityFactory.createPlayer] to spawn the player entity.
  final PlayerArchetype archetype;
}


===== FILE: lib/core/players/player_character_definition.dart =====
library;

import '../contracts/render_anim_set_definition.dart';
import '../snapshots/enums.dart';
import 'player_tuning.dart';
import 'player_catalog.dart';

enum PlayerCharacterId { eloise, eloiseWip }

class PlayerCharacterDefinition {
  const PlayerCharacterDefinition({
    required this.id,
    required this.displayName,
    required this.renderAnim,
    required this.catalog,
    this.tuning = const PlayerTuning(),
  });

  final PlayerCharacterId id;
  final String displayName;

  /// Render-only animation metadata (strip paths, frame size, timing).
  ///
  /// Core owns the timing numbers so render strips and deterministic animation
  /// windows can stay in sync, but the renderer remains the only layer that
  /// loads assets.
  final RenderAnimSetDefinition renderAnim;

  /// Structural player configuration (collider size/offset, physics flags, etc.).
  final PlayerCatalog catalog;

  /// Per-character numeric tuning bundle.
  final PlayerTuning tuning;

  PlayerCharacterDefinition copyWith({
    String? displayName,
    RenderAnimSetDefinition? renderAnim,
    PlayerCatalog? catalog,
    PlayerTuning? tuning,
  }) {
    return PlayerCharacterDefinition(
      id: id,
      displayName: displayName ?? this.displayName,
      renderAnim: renderAnim ?? this.renderAnim,
      catalog: catalog ?? this.catalog,
      tuning: tuning ?? this.tuning,
    );
  }

  /// Debug-only validation for authoring-time character definitions.
  ///
  /// This is intended to fail fast during development when a new character is
  /// added with incomplete render strip metadata or invalid collider sizes.
  ///
  /// In release builds, asserts are stripped and this becomes a no-op.
  void assertValid() {
    assert(() {
      if (displayName.trim().isEmpty) {
        throw StateError(
          'PlayerCharacterDefinition($id) has empty displayName',
        );
      }

      // Catalog invariants.
      if (!catalog.colliderWidth.isFinite ||
          !catalog.colliderHeight.isFinite ||
          catalog.colliderWidth <= 0 ||
          catalog.colliderHeight <= 0) {
        throw StateError(
          'PlayerCharacterDefinition($id) has invalid collider size '
          '(width=${catalog.colliderWidth}, height=${catalog.colliderHeight})',
        );
      }
      if (!catalog.colliderOffsetX.isFinite ||
          !catalog.colliderOffsetY.isFinite) {
        throw StateError(
          'PlayerCharacterDefinition($id) has non-finite collider offsets '
          '(x=${catalog.colliderOffsetX}, y=${catalog.colliderOffsetY})',
        );
      }

      // Render anim invariants.
      if (renderAnim.frameWidth <= 0 || renderAnim.frameHeight <= 0) {
        throw StateError(
          'PlayerCharacterDefinition($id) has invalid render frame size '
          '(${renderAnim.frameWidth}x${renderAnim.frameHeight})',
        );
      }
      if (!renderAnim.sourcesByKey.containsKey(AnimKey.idle)) {
        throw StateError(
          'PlayerCharacterDefinition($id) renderAnim.sourcesByKey must include AnimKey.idle',
        );
      }
      if (!renderAnim.frameCountsByKey.containsKey(AnimKey.idle)) {
        throw StateError(
          'PlayerCharacterDefinition($id) renderAnim.frameCountsByKey must include AnimKey.idle',
        );
      }
      if (!renderAnim.stepTimeSecondsByKey.containsKey(AnimKey.idle)) {
        throw StateError(
          'PlayerCharacterDefinition($id) renderAnim.stepTimeSecondsByKey must include AnimKey.idle',
        );
      }

      for (final entry in renderAnim.sourcesByKey.entries) {
        final key = entry.key;
        final path = entry.value;
        if (path.trim().isEmpty) {
          throw StateError(
            'PlayerCharacterDefinition($id) renderAnim.sourcesByKey[$key] is empty',
          );
        }

        // Frame counts / step times are allowed to be omitted per-key; render
        // falls back to the `idle` values in that case. If a value is provided
        // for the key, validate it.
        final count = renderAnim.frameCountsByKey[key];
        if (count != null && count <= 0) {
          throw StateError(
            'PlayerCharacterDefinition($id) renderAnim.frameCountsByKey[$key] must be > 0 (got $count)',
          );
        }
        final seconds = renderAnim.stepTimeSecondsByKey[key];
        if (seconds != null && (!seconds.isFinite || seconds <= 0)) {
          throw StateError(
            'PlayerCharacterDefinition($id) renderAnim.stepTimeSecondsByKey[$key] must be > 0 (got $seconds)',
          );
        }
      }

      for (final entry in renderAnim.frameCountsByKey.entries) {
        final key = entry.key;
        final count = entry.value;
        if (count <= 0) {
          throw StateError(
            'PlayerCharacterDefinition($id) renderAnim.frameCountsByKey[$key] must be > 0 (got $count)',
          );
        }
        if (key != AnimKey.idle && !renderAnim.sourcesByKey.containsKey(key)) {
          throw StateError(
            'PlayerCharacterDefinition($id) renderAnim.frameCountsByKey[$key] has no matching sourcesByKey entry',
          );
        }
      }

      for (final entry in renderAnim.stepTimeSecondsByKey.entries) {
        final key = entry.key;
        final seconds = entry.value;
        if (!seconds.isFinite || seconds <= 0) {
          throw StateError(
            'PlayerCharacterDefinition($id) renderAnim.stepTimeSecondsByKey[$key] must be > 0 (got $seconds)',
          );
        }
        if (key != AnimKey.idle && !renderAnim.sourcesByKey.containsKey(key)) {
          throw StateError(
            'PlayerCharacterDefinition($id) renderAnim.stepTimeSecondsByKey[$key] has no matching sourcesByKey entry',
          );
        }
      }

      for (final entry in renderAnim.rowByKey.entries) {
        final key = entry.key;
        final row = entry.value;
        if (row < 0) {
          throw StateError(
            'PlayerCharacterDefinition($id) renderAnim.rowByKey[$key] must be >= 0 (got $row)',
          );
        }
        if (!renderAnim.sourcesByKey.containsKey(key)) {
          throw StateError(
            'PlayerCharacterDefinition($id) renderAnim.rowByKey[$key] has no matching sourcesByKey entry',
          );
        }
        if (!renderAnim.frameCountsByKey.containsKey(key)) {
          throw StateError(
            'PlayerCharacterDefinition($id) renderAnim.rowByKey[$key] has no matching frameCountsByKey entry',
          );
        }
      }

      for (final entry in renderAnim.frameStartByKey.entries) {
        final key = entry.key;
        final start = entry.value;
        if (start < 0) {
          throw StateError(
            'PlayerCharacterDefinition($id) renderAnim.frameStartByKey[$key] must be >= 0 (got $start)',
          );
        }
        if (!renderAnim.sourcesByKey.containsKey(key)) {
          throw StateError(
            'PlayerCharacterDefinition($id) renderAnim.frameStartByKey[$key] has no matching sourcesByKey entry',
          );
        }
        if (!renderAnim.frameCountsByKey.containsKey(key)) {
          throw StateError(
            'PlayerCharacterDefinition($id) renderAnim.frameStartByKey[$key] has no matching frameCountsByKey entry',
          );
        }
      }

      final anchor = renderAnim.anchorInFramePx;
      if (anchor != null) {
        if (!anchor.x.isFinite || !anchor.y.isFinite) {
          throw StateError(
            'PlayerCharacterDefinition($id) renderAnim.anchorInFramePx must be finite (got $anchor)',
          );
        }
        if (anchor.x < 0 ||
            anchor.x > renderAnim.frameWidth ||
            anchor.y < 0 ||
            anchor.y > renderAnim.frameHeight) {
          throw StateError(
            'PlayerCharacterDefinition($id) renderAnim.anchorInFramePx must be within the frame '
            '(0..${renderAnim.frameWidth}, 0..${renderAnim.frameHeight}). Got $anchor',
          );
        }
      }

      // Tuning invariants (only basic sanity checks here).
      if (!tuning.anim.hitAnimSeconds.isFinite ||
          !tuning.anim.deathAnimSeconds.isFinite ||
          !tuning.anim.spawnAnimSeconds.isFinite) {
        throw StateError(
          'PlayerCharacterDefinition($id) has non-finite AnimTuning seconds',
        );
      }

      return true;
    }());
  }
}


===== FILE: lib/core/players/player_character_registry.dart =====
library;

import 'characters/eloise.dart';
import 'characters/eloise_wip.dart';
import 'player_character_definition.dart';

class PlayerCharacterRegistry {
  const PlayerCharacterRegistry._();

  static const PlayerCharacterDefinition eloise = eloiseCharacter;
  static const PlayerCharacterDefinition eloiseWip = eloiseWipCharacter;

  static const List<PlayerCharacterDefinition> all = [eloise, eloiseWip];

  static final Map<PlayerCharacterId, PlayerCharacterDefinition> byId =
      _buildById(all);

  static PlayerCharacterDefinition resolve(PlayerCharacterId id) {
    final def = byId[id];
    if (def == null) {
      throw StateError('Unknown PlayerCharacterId $id');
    }
    return def;
  }

  static Map<PlayerCharacterId, PlayerCharacterDefinition> _buildById(
    List<PlayerCharacterDefinition> defs,
  ) {
    assert(() {
      for (final d in defs) {
        d.assertValid();
      }
      return true;
    }());

    final map = <PlayerCharacterId, PlayerCharacterDefinition>{};
    for (final d in defs) {
      final existing = map[d.id];
      if (existing != null) {
        throw StateError('Duplicate PlayerCharacterId ${d.id} in registry');
      }
      map[d.id] = d;
    }
    return map;
  }
}


===== FILE: lib/core/players/player_tuning.dart =====
/// Player tuning (single-file source of truth).
///
/// This module intentionally centralizes all player-specific tuning:
/// movement + resources + abilities + combat + animation (and derived/cache
/// variants). This keeps per-character definitions DRY: they can reference a
/// single import and override only what differs.
library;

import '../snapshots/enums.dart';
import '../util/tick_math.dart';
import '../util/fixed_math.dart';
import '../tuning/utils/anim_tuning.dart' as anim_utils;

// ─────────────────────────────────────────────────────────────────────────────
// Player animation strip definitions (frame counts / step times) live in
// character files (e.g. `lib/core/players/characters/eloise.dart`).
// ─────────────────────────────────────────────────────────────────────────────

// Keep [AnimTuning] windows in sync with the selected character's strips.

// ─────────────────────────────────────────────────────────────────────────────
// Player movement tuning (author in seconds, applied per fixed tick)
// ─────────────────────────────────────────────────────────────────────────────

const int defaultTickHz = 60;

class MovementTuning {
  const MovementTuning({
    this.maxSpeedX = 200,
    this.accelerationX = 600,
    this.decelerationX = 400,
    this.minMoveSpeed = 5,
    this.runSpeedThresholdX = 60,
    this.maxVelX = 1500,
    this.maxVelY = 1500,
    this.jumpSpeed = 500,
    this.coyoteTimeSeconds = 0.10,
    this.jumpBufferSeconds = 0.12,
    this.dashDurationSeconds = 0.20,
    this.dashCooldownSeconds = 2.0,
  });

  final double maxSpeedX;
  final double accelerationX;
  final double decelerationX;
  final double minMoveSpeed;
  final double runSpeedThresholdX;

  final double maxVelX;
  final double maxVelY;

  final double jumpSpeed;

  final double coyoteTimeSeconds;
  final double jumpBufferSeconds;

  final double dashDurationSeconds;
  final double dashCooldownSeconds;
}

class MovementTuningDerived {
  const MovementTuningDerived._({
    required this.tickHz,
    required this.dtSeconds,
    required this.base,
    required this.coyoteTicks,
    required this.jumpBufferTicks,
    required this.dashDurationTicks,
    required this.dashCooldownTicks,
  });

  factory MovementTuningDerived.from(
    MovementTuning base, {
    required int tickHz,
  }) {
    if (tickHz <= 0) {
      throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
    }
    return MovementTuningDerived._(
      tickHz: tickHz,
      dtSeconds: 1.0 / tickHz,
      base: base,
      coyoteTicks: ticksFromSecondsCeil(base.coyoteTimeSeconds, tickHz),
      jumpBufferTicks: ticksFromSecondsCeil(base.jumpBufferSeconds, tickHz),
      dashDurationTicks: ticksFromSecondsCeil(base.dashDurationSeconds, tickHz),
      dashCooldownTicks: ticksFromSecondsCeil(base.dashCooldownSeconds, tickHz),
    );
  }

  final int tickHz;
  final double dtSeconds;
  final MovementTuning base;

  final int coyoteTicks;
  final int jumpBufferTicks;
  final int dashDurationTicks;
  final int dashCooldownTicks;
}

// ─────────────────────────────────────────────────────────────────────────────
// Player resources tuning (hp/mana/stamina + regen + costs)
// ─────────────────────────────────────────────────────────────────────────────

class ResourceTuning {
  const ResourceTuning({
    this.playerHpMax = 100,
    this.playerHpRegenPerSecond = 0.5,
    this.playerManaMax = 100,
    this.playerManaRegenPerSecond = 2.0,
    this.playerStaminaMax = 100,
    this.playerStaminaRegenPerSecond = 1.0,
    this.jumpStaminaCost = 2,
    this.dashStaminaCost = 2,
  });

  final double playerHpMax;
  final double playerHpRegenPerSecond;

  final double playerManaMax;
  final double playerManaRegenPerSecond;

  final double playerStaminaMax;
  final double playerStaminaRegenPerSecond;

  final double jumpStaminaCost;
  final double dashStaminaCost;
}

class ResourceTuningDerived {
  const ResourceTuningDerived({
    required this.playerHpMax100,
    required this.playerHpRegenPerSecond100,
    required this.playerManaMax100,
    required this.playerManaRegenPerSecond100,
    required this.playerStaminaMax100,
    required this.playerStaminaRegenPerSecond100,
    required this.jumpStaminaCost100,
    required this.dashStaminaCost100,
  });

  factory ResourceTuningDerived.from(ResourceTuning base) {
    return ResourceTuningDerived(
      playerHpMax100: toFixed100(base.playerHpMax),
      playerHpRegenPerSecond100: toFixed100(base.playerHpRegenPerSecond),
      playerManaMax100: toFixed100(base.playerManaMax),
      playerManaRegenPerSecond100: toFixed100(base.playerManaRegenPerSecond),
      playerStaminaMax100: toFixed100(base.playerStaminaMax),
      playerStaminaRegenPerSecond100: toFixed100(
        base.playerStaminaRegenPerSecond,
      ),
      jumpStaminaCost100: toFixed100(base.jumpStaminaCost),
      dashStaminaCost100: toFixed100(base.dashStaminaCost),
    );
  }

  /// Fixed-point: 100 = 1.0
  final int playerHpMax100;
  final int playerHpRegenPerSecond100;
  final int playerManaMax100;
  final int playerManaRegenPerSecond100;
  final int playerStaminaMax100;
  final int playerStaminaRegenPerSecond100;
  final int jumpStaminaCost100;
  final int dashStaminaCost100;
}

// ─────────────────────────────────────────────────────────────────────────────
// Player ability tuning (cast, melee)
// ─────────────────────────────────────────────────────────────────────────────

class AbilityTuning {
  const AbilityTuning({
    this.castCooldownSeconds = 0.25,
    this.meleeCooldownSeconds = 0.30,
    this.meleeActiveSeconds = 0.10,
    this.meleeStaminaCost = 5.0,
    this.meleeDamage = 15.0,
    this.meleeHitboxSizeX = 32.0,
    this.meleeHitboxSizeY = 16.0,
    this.inputBufferSeconds = 0.15,
  });

  final double castCooldownSeconds;
  final double meleeCooldownSeconds;
  final double meleeActiveSeconds;

  final double meleeStaminaCost;
  final double meleeDamage;

  final double meleeHitboxSizeX;
  final double meleeHitboxSizeY;
  final double inputBufferSeconds;
}

class AbilityTuningDerived {
  const AbilityTuningDerived._({
    required this.tickHz,
    required this.base,
    required this.castCooldownTicks,
    required this.meleeCooldownTicks,
    required this.meleeActiveTicks,
    required this.inputBufferTicks,
  });

  factory AbilityTuningDerived.from(AbilityTuning base, {required int tickHz}) {
    if (tickHz <= 0) {
      throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
    }

    return AbilityTuningDerived._(
      tickHz: tickHz,
      base: base,
      castCooldownTicks: ticksFromSecondsCeil(base.castCooldownSeconds, tickHz),
      meleeCooldownTicks: ticksFromSecondsCeil(
        base.meleeCooldownSeconds,
        tickHz,
      ),
      meleeActiveTicks: ticksFromSecondsCeil(base.meleeActiveSeconds, tickHz),
      inputBufferTicks: ticksFromSecondsCeil(base.inputBufferSeconds, tickHz),
    );
  }

  final int tickHz;
  final AbilityTuning base;

  final int castCooldownTicks;
  final int meleeCooldownTicks;
  final int meleeActiveTicks;
  final int inputBufferTicks;
}

// ─────────────────────────────────────────────────────────────────────────────
// Player combat tuning (invulnerability)
// ─────────────────────────────────────────────────────────────────────────────

class CombatTuning {
  const CombatTuning({this.invulnerabilitySeconds = 0.25});

  final double invulnerabilitySeconds;
}

class CombatTuningDerived {
  const CombatTuningDerived._({
    required this.tickHz,
    required this.base,
    required this.invulnerabilityTicks,
  });

  factory CombatTuningDerived.from(CombatTuning base, {required int tickHz}) {
    if (tickHz <= 0) {
      throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
    }

    return CombatTuningDerived._(
      tickHz: tickHz,
      base: base,
      invulnerabilityTicks: ticksFromSecondsCeil(
        base.invulnerabilitySeconds,
        tickHz,
      ),
    );
  }

  final int tickHz;
  final CombatTuning base;

  final int invulnerabilityTicks;
}

// ─────────────────────────────────────────────────────────────────────────────
// Player animation tuning (timing windows)
// ─────────────────────────────────────────────────────────────────────────────

class AnimTuning {
  const AnimTuning({
    this.hitAnimSeconds = 0.40,
    this.deathAnimSeconds = 0.72,
    this.spawnAnimSeconds = 0.56,
  });

  static AnimTuning fromStripFrames({
    required Map<AnimKey, int> frameCounts,
    required Map<AnimKey, double> stepTimeSecondsByKey,
  }) {
    return AnimTuning(
      hitAnimSeconds: anim_utils.secondsForKey(
        key: AnimKey.hit,
        frameCounts: frameCounts,
        stepTimeSecondsByKey: stepTimeSecondsByKey,
      ),
      deathAnimSeconds: anim_utils.secondsForKey(
        key: AnimKey.death,
        frameCounts: frameCounts,
        stepTimeSecondsByKey: stepTimeSecondsByKey,
      ),
      spawnAnimSeconds: anim_utils.secondsForKey(
        key: AnimKey.spawn,
        frameCounts: frameCounts,
        stepTimeSecondsByKey: stepTimeSecondsByKey,
      ),
    );
  }

  final double hitAnimSeconds;
  final double deathAnimSeconds;
  final double spawnAnimSeconds;
}

class AnimTuningDerived {
  const AnimTuningDerived._({
    required this.tickHz,
    required this.base,
    required this.hitAnimTicks,
    required this.deathAnimTicks,
    required this.spawnAnimTicks,
  });

  factory AnimTuningDerived.from(AnimTuning base, {required int tickHz}) {
    if (tickHz <= 0) {
      throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
    }

    return AnimTuningDerived._(
      tickHz: tickHz,
      base: base,
      hitAnimTicks: ticksFromSecondsCeil(base.hitAnimSeconds, tickHz),
      deathAnimTicks: ticksFromSecondsCeil(base.deathAnimSeconds, tickHz),
      spawnAnimTicks: ticksFromSecondsCeil(base.spawnAnimSeconds, tickHz),
    );
  }

  final int tickHz;
  final AnimTuning base;

  final int hitAnimTicks;
  final int deathAnimTicks;
  final int spawnAnimTicks;
}

// ─────────────────────────────────────────────────────────────────────────────
// Player tuning bundle + derived compiler (composition)
// ─────────────────────────────────────────────────────────────────────────────

class PlayerTuning {
  const PlayerTuning({
    this.movement = const MovementTuning(),
    this.resource = const ResourceTuning(),
    this.ability = const AbilityTuning(),
    this.anim = const AnimTuning(),
    this.combat = const CombatTuning(),
  });

  final MovementTuning movement;
  final ResourceTuning resource;
  final AbilityTuning ability;
  final AnimTuning anim;
  final CombatTuning combat;

  PlayerTuning copyWith({
    MovementTuning? movement,
    ResourceTuning? resource,
    AbilityTuning? ability,
    AnimTuning? anim,
    CombatTuning? combat,
  }) {
    return PlayerTuning(
      movement: movement ?? this.movement,
      resource: resource ?? this.resource,
      ability: ability ?? this.ability,
      anim: anim ?? this.anim,
      combat: combat ?? this.combat,
    );
  }
}

class PlayerTuningDerived {
  const PlayerTuningDerived({
    required this.movement,
    required this.ability,
    required this.anim,
    required this.combat,
    required this.resource,
  });

  final MovementTuningDerived movement;
  final AbilityTuningDerived ability;
  final AnimTuningDerived anim;
  final CombatTuningDerived combat;
  final ResourceTuningDerived resource;
}

class PlayerTuningCompiler {
  const PlayerTuningCompiler({required this.tickHz});

  final int tickHz;

  PlayerTuningDerived compile(PlayerTuning base) {
    return PlayerTuningDerived(
      movement: MovementTuningDerived.from(base.movement, tickHz: tickHz),
      ability: AbilityTuningDerived.from(base.ability, tickHz: tickHz),
      anim: AnimTuningDerived.from(base.anim, tickHz: tickHz),
      combat: CombatTuningDerived.from(base.combat, tickHz: tickHz),
      resource: ResourceTuningDerived.from(base.resource),
    );
  }
}


===== FILE: lib/core/progression/run_rewards.dart =====
/// Reward computation for completed runs.
///
/// Keep this module pure and deterministic so reward rules can evolve
/// without touching UI or render layers.
int computeGoldEarned({required int collectiblesCollected}) {
  return collectiblesCollected;
}


===== FILE: lib/core/projectiles/projectile_catalog.dart =====
import '../abilities/ability_def.dart' show WeaponType;
import '../combat/damage_type.dart';
import '../combat/status/status.dart';
import '../projectiles/projectile_id.dart';
import '../weapons/weapon_proc.dart';
import 'projectile_item_def.dart';

/// Lookup table for projectile slot items (spells + throwing weapons).
class ProjectileCatalog {
  const ProjectileCatalog();

  ProjectileItemDef get(ProjectileId id) {
    switch (id) {
      case ProjectileId.unknown:
        throw ArgumentError.value(
          id,
          'id',
          'ProjectileId.unknown has no catalog entry.',
        );

      // Spells
      case ProjectileId.iceBolt:
        return const ProjectileItemDef(
          id: ProjectileId.iceBolt,
          weaponType: WeaponType.projectileSpell,
          speedUnitsPerSecond: 600.0,
          lifetimeSeconds: 1.3,
          colliderSizeX: 18.0,
          colliderSizeY: 8.0,
          originOffset: 30.0,
          damageType: DamageType.ice,
          procs: <WeaponProc>[
            WeaponProc(
              hook: ProcHook.onHit,
              statusProfileId: StatusProfileId.slowOnHit,
            ),
          ],
        );
      case ProjectileId.fireBolt:
        return const ProjectileItemDef(
          id: ProjectileId.fireBolt,
          weaponType: WeaponType.projectileSpell,
          speedUnitsPerSecond: 600.0,
          lifetimeSeconds: 1.3,
          colliderSizeX: 18.0,
          colliderSizeY: 8.0,
          originOffset: 30.0,
          damageType: DamageType.fire,
          procs: <WeaponProc>[
            WeaponProc(
              hook: ProcHook.onHit,
              statusProfileId: StatusProfileId.burnOnHit,
            ),
          ],
        );
      case ProjectileId.acidBolt:
        return const ProjectileItemDef(
          id: ProjectileId.acidBolt,
          weaponType: WeaponType.projectileSpell,
          speedUnitsPerSecond: 500.0,
          lifetimeSeconds: 1.3,
          colliderSizeX: 18.0,
          colliderSizeY: 8.0,
          originOffset: 30.0,
          damageType: DamageType.acid,
          procs: <WeaponProc>[
            WeaponProc(
              hook: ProcHook.onHit,
              statusProfileId: StatusProfileId.acidOnHit,
            ),
          ],
        );
      case ProjectileId.darkBolt:
        return const ProjectileItemDef(
          id: ProjectileId.darkBolt,
          weaponType: WeaponType.projectileSpell,
          speedUnitsPerSecond: 550.0,
          lifetimeSeconds: 1.3,
          colliderSizeX: 18.0,
          colliderSizeY: 8.0,
          originOffset: 30.0,
          damageType: DamageType.dark,
          procs: <WeaponProc>[
            WeaponProc(
              hook: ProcHook.onHit,
              statusProfileId: StatusProfileId.weakenOnHit,
            ),
          ],
        );
      case ProjectileId.earthBolt:
        return const ProjectileItemDef(
          id: ProjectileId.earthBolt,
          weaponType: WeaponType.projectileSpell,
          speedUnitsPerSecond: 500.0,
          lifetimeSeconds: 1.3,
          colliderSizeX: 18.0,
          colliderSizeY: 8.0,
          originOffset: 30.0,
          damageType: DamageType.earth,
          procs: <WeaponProc>[
            WeaponProc(
              hook: ProcHook.onHit,
              statusProfileId: StatusProfileId.stunOnHit,
            ),
          ],
        );
      case ProjectileId.holyBolt:
        return const ProjectileItemDef(
          id: ProjectileId.holyBolt,
          weaponType: WeaponType.projectileSpell,
          speedUnitsPerSecond: 550.0,
          lifetimeSeconds: 1.3,
          colliderSizeX: 18.0,
          colliderSizeY: 8.0,
          originOffset: 30.0,
          damageType: DamageType.holy,
          procs: <WeaponProc>[
            WeaponProc(
              hook: ProcHook.onHit,
              statusProfileId: StatusProfileId.silenceOnHit,
            ),
          ],
        );
      case ProjectileId.waterBolt:
        return const ProjectileItemDef(
          id: ProjectileId.waterBolt,
          weaponType: WeaponType.projectileSpell,
          speedUnitsPerSecond: 550.0,
          lifetimeSeconds: 1.3,
          colliderSizeX: 18.0,
          colliderSizeY: 8.0,
          originOffset: 22.0,
          damageType: DamageType.water,
          procs: <WeaponProc>[
            WeaponProc(
              hook: ProcHook.onHit,
              statusProfileId: StatusProfileId.drenchOnHit,
            ),
          ],
        );
      case ProjectileId.thunderBolt:
        return const ProjectileItemDef(
          id: ProjectileId.thunderBolt,
          weaponType: WeaponType.projectileSpell,
          speedUnitsPerSecond: 650.0,
          lifetimeSeconds: 1.3,
          colliderSizeX: 18.0,
          colliderSizeY: 8.0,
          originOffset: 30.0,
          damageType: DamageType.thunder,
          procs: <WeaponProc>[
            WeaponProc(
              hook: ProcHook.onHit,
              statusProfileId: StatusProfileId.stunOnHit,
            ),
          ],
        );

      // Throwing weapons
      case ProjectileId.throwingKnife:
        return const ProjectileItemDef(
          id: ProjectileId.throwingKnife,
          weaponType: WeaponType.throwingWeapon,
          speedUnitsPerSecond: 600.0,
          lifetimeSeconds: 3.0,
          colliderSizeX: 18.0,
          colliderSizeY: 8.0,
          originOffset: 30.0,
          ballistic: true,
          gravityScale: 0.6,
          damageType: DamageType.physical,
        );
      case ProjectileId.throwingAxe:
        return const ProjectileItemDef(
          id: ProjectileId.throwingAxe,
          weaponType: WeaponType.throwingWeapon,
          speedUnitsPerSecond: 600.0,
          lifetimeSeconds: 3.0,
          colliderSizeX: 18.0,
          colliderSizeY: 8.0,
          originOffset: 30.0,
          ballistic: true,
          gravityScale: 0.7,
          damageType: DamageType.physical,
        );
    }
  }

  ProjectileItemDef? tryGet(ProjectileId id) {
    try {
      return get(id);
    } catch (_) {
      return null;
    }
  }
}


===== FILE: lib/core/projectiles/projectile_id.dart =====
/// Identifies a projectile type for catalog lookup and rendering.
///
/// Each ID maps to a projectile item entry and determines visual appearance
/// in the renderer.
enum ProjectileId {
  /// Sentinel value for uninitialized/placeholder projectile slots.
  unknown,

  /// Player's primary ranged strike. Fast, short-lived.
  iceBolt,

  /// Player's fire spell projectile. Medium speed and lifetime.
  fireBolt,

  /// Player's acid spell projectile. Medium speed and lifetime.
  acidBolt,

  /// Player's dark spell projectile. Medium speed and short lifetime.
  darkBolt,

  /// Player's earth spell projectile. Medium speed and lifetime.
  earthBolt,

  /// Player's holy spell projectile. Medium speed and lifetime.
  holyBolt,

  /// Player's water spell projectile. Medium speed and lifetime.
  waterBolt,

  /// Enemy ranged strike. Slower but longer range.
  thunderBolt,

  /// Physical throwing axe projectile (ballistic).
  throwingAxe,

  /// Physical throwing knife projectile (ballistic).
  throwingKnife,
}


===== FILE: lib/core/projectiles/projectile_item_def.dart =====
import '../abilities/ability_def.dart' show WeaponType;
import '../combat/damage_type.dart';
import '../projectiles/projectile_id.dart';
import '../weapons/weapon_proc.dart';
import '../stats/gear_stat_bonuses.dart';

/// Unified data definition for projectile slot items (spells + throwing weapons).
class ProjectileItemDef {
  const ProjectileItemDef({
    required this.id,
    required this.weaponType,
    required this.speedUnitsPerSecond,
    required this.lifetimeSeconds,
    required this.colliderSizeX,
    required this.colliderSizeY,
    this.originOffset = 0.0,
    this.ballistic = false,
    this.gravityScale = 1.0,
    this.damageType = DamageType.physical,
    this.procs = const <WeaponProc>[],
    this.stats = const GearStatBonuses(),
  });

  final ProjectileId id;
  final WeaponType weaponType;

  final double speedUnitsPerSecond;
  final double lifetimeSeconds;
  final double colliderSizeX;
  final double colliderSizeY;
  final double originOffset;
  final bool ballistic;
  final double gravityScale;

  final DamageType damageType;
  final List<WeaponProc> procs;
  final GearStatBonuses stats;
}


===== FILE: lib/core/projectiles/projectile_render_catalog.dart =====
import '../contracts/render_anim_set_definition.dart';
import '../snapshots/enums.dart';
import 'projectile_id.dart';

// -----------------------------------------------------------------------------
// Ice Bolt render animation strip definitions (authoring-time)
// -----------------------------------------------------------------------------

const int _iceBoltFrameWidth = 48;
const int _iceBoltFrameHeight = 32;

const int _iceBoltStartFrames = 3;
const int _iceBoltRepeatFrames = 10;
const int _iceBoltHitFrames = 8;

const double _iceBoltStartStepSeconds = 0.06;
const double _iceBoltRepeatStepSeconds = 0.06;
const double _iceBoltHitStepSeconds = 0.06;

const Map<AnimKey, int> _iceBoltFrameCountsByKey = <AnimKey, int>{
  AnimKey.spawn: _iceBoltStartFrames,
  AnimKey.idle: _iceBoltRepeatFrames,
  AnimKey.hit: _iceBoltHitFrames,
};

const Map<AnimKey, double> _iceBoltStepTimeSecondsByKey = <AnimKey, double>{
  AnimKey.spawn: _iceBoltStartStepSeconds,
  AnimKey.idle: _iceBoltRepeatStepSeconds,
  AnimKey.hit: _iceBoltHitStepSeconds,
};

const Map<AnimKey, String> _iceBoltSourcesByKey = <AnimKey, String>{
  AnimKey.spawn: 'entities/spells/ice/bolt/start.png',
  AnimKey.idle: 'entities/spells/ice/bolt/repeatable.png',
  AnimKey.hit: 'entities/spells/ice/bolt/hit.png',
};

const RenderAnimSetDefinition _iceBoltRenderAnim = RenderAnimSetDefinition(
  frameWidth: _iceBoltFrameWidth,
  frameHeight: _iceBoltFrameHeight,
  sourcesByKey: _iceBoltSourcesByKey,
  frameCountsByKey: _iceBoltFrameCountsByKey,
  stepTimeSecondsByKey: _iceBoltStepTimeSecondsByKey,
);

// -----------------------------------------------------------------------------
// Thunder Bolt render animation strip definitions (authoring-time)
// -----------------------------------------------------------------------------

const int _thunderBoltFrameWidth = 32;
const int _thunderBoltFrameHeight = 32;

const int _thunderBoltStartFrames = 5;
const int _thunderBoltRepeatFrames = 5;
const int _thunderBoltHitFrames = 6;

const double _thunderBoltStartStepSeconds = 0.06;
const double _thunderBoltRepeatStepSeconds = 0.06;
const double _thunderBoltHitStepSeconds = 0.06;

const Map<AnimKey, int> _thunderBoltFrameCountsByKey = <AnimKey, int>{
  AnimKey.spawn: _thunderBoltStartFrames,
  AnimKey.idle: _thunderBoltRepeatFrames,
  AnimKey.hit: _thunderBoltHitFrames,
};

const Map<AnimKey, double> _thunderBoltStepTimeSecondsByKey = <AnimKey, double>{
  AnimKey.spawn: _thunderBoltStartStepSeconds,
  AnimKey.idle: _thunderBoltRepeatStepSeconds,
  AnimKey.hit: _thunderBoltHitStepSeconds,
};

const Map<AnimKey, String> _thunderBoltSourcesByKey = <AnimKey, String>{
  AnimKey.spawn: 'entities/spells/thunder/bolt/start.png',
  AnimKey.idle: 'entities/spells/thunder/bolt/repeatable.png',
  AnimKey.hit: 'entities/spells/thunder/bolt/hit.png',
};

const RenderAnimSetDefinition _thunderBoltRenderAnim = RenderAnimSetDefinition(
  frameWidth: _thunderBoltFrameWidth,
  frameHeight: _thunderBoltFrameHeight,
  sourcesByKey: _thunderBoltSourcesByKey,
  frameCountsByKey: _thunderBoltFrameCountsByKey,
  stepTimeSecondsByKey: _thunderBoltStepTimeSecondsByKey,
);

// -----------------------------------------------------------------------------
// Fire Bolt render animation strip definitions (authoring-time)
// -----------------------------------------------------------------------------

const int _fireBoltFrameWidth = 48;
const int _fireBoltFrameHeight = 48;

const int _fireBoltStartFrames = 4;
const int _fireBoltHitFrames = 6;

const double _fireBoltStartStepSeconds = 0.06;
const double _fireBoltIdleStepSeconds = 0.06;
const double _fireBoltHitStepSeconds = 0.06;

const Map<AnimKey, int> _fireBoltFrameCountsByKey = <AnimKey, int>{
  AnimKey.spawn: _fireBoltStartFrames,
  AnimKey.idle: _fireBoltStartFrames,
  AnimKey.hit: _fireBoltHitFrames,
};

const Map<AnimKey, int> _fireBoltFrameStartByKey = <AnimKey, int>{
  AnimKey.spawn: 0,
  AnimKey.idle: 0,
  AnimKey.hit: 5,
};

const Map<AnimKey, double> _fireBoltStepTimeSecondsByKey = <AnimKey, double>{
  AnimKey.spawn: _fireBoltStartStepSeconds,
  AnimKey.idle: _fireBoltIdleStepSeconds,
  AnimKey.hit: _fireBoltHitStepSeconds,
};

const Map<AnimKey, String> _fireBoltSourcesByKey = <AnimKey, String>{
  AnimKey.spawn: 'entities/spells/fire/bolt/spriteSheet.png',
  AnimKey.idle: 'entities/spells/fire/bolt/spriteSheet.png',
  AnimKey.hit: 'entities/spells/fire/bolt/spriteSheet.png',
};

const RenderAnimSetDefinition _fireBoltRenderAnim = RenderAnimSetDefinition(
  frameWidth: _fireBoltFrameWidth,
  frameHeight: _fireBoltFrameHeight,
  sourcesByKey: _fireBoltSourcesByKey,
  frameStartByKey: _fireBoltFrameStartByKey,
  frameCountsByKey: _fireBoltFrameCountsByKey,
  stepTimeSecondsByKey: _fireBoltStepTimeSecondsByKey,
);

// -----------------------------------------------------------------------------
// Acid Bolt render animation strip definitions (authoring-time)
// -----------------------------------------------------------------------------

const int _acidBoltFrameWidth = 32;
const int _acidBoltFrameHeight = 32;

const int _acidBoltStartFrames = 10;
const int _acidBoltHitFrames = 6;

const double _acidBoltStartStepSeconds = 0.06;
const double _acidBoltIdleStepSeconds = 0.06;
const double _acidBoltHitStepSeconds = 0.06;

const Map<AnimKey, int> _acidBoltFrameCountsByKey = <AnimKey, int>{
  AnimKey.spawn: _acidBoltStartFrames,
  AnimKey.idle: _acidBoltStartFrames,
  AnimKey.hit: _acidBoltHitFrames,
};

const Map<AnimKey, int> _acidBoltFrameStartByKey = <AnimKey, int>{
  AnimKey.spawn: 0,
  AnimKey.idle: 0,
  AnimKey.hit: 10,
};

const Map<AnimKey, double> _acidBoltStepTimeSecondsByKey = <AnimKey, double>{
  AnimKey.spawn: _acidBoltStartStepSeconds,
  AnimKey.idle: _acidBoltIdleStepSeconds,
  AnimKey.hit: _acidBoltHitStepSeconds,
};

const Map<AnimKey, String> _acidBoltSourcesByKey = <AnimKey, String>{
  AnimKey.spawn: 'entities/spells/acid/bolt/spriteSheet.png',
  AnimKey.idle: 'entities/spells/acid/bolt/spriteSheet.png',
  AnimKey.hit: 'entities/spells/acid/bolt/spriteSheet.png',
};

const RenderAnimSetDefinition _acidBoltRenderAnim = RenderAnimSetDefinition(
  frameWidth: _acidBoltFrameWidth,
  frameHeight: _acidBoltFrameHeight,
  sourcesByKey: _acidBoltSourcesByKey,
  frameStartByKey: _acidBoltFrameStartByKey,
  frameCountsByKey: _acidBoltFrameCountsByKey,
  stepTimeSecondsByKey: _acidBoltStepTimeSecondsByKey,
);

// -----------------------------------------------------------------------------
// Dark Bolt render animation strip definitions (authoring-time)
// -----------------------------------------------------------------------------

const int _darkBoltFrameWidth = 40;
const int _darkBoltFrameHeight = 32;

const int _darkBoltStartFrames = 10;
const int _darkBoltIdleFrames = 10;
const int _darkBoltHitFrames = 6;

const double _darkBoltStartStepSeconds = 0.06;
const double _darkBoltIdleStepSeconds = 0.06;
const double _darkBoltHitStepSeconds = 0.06;

const Map<AnimKey, int> _darkBoltFrameCountsByKey = <AnimKey, int>{
  AnimKey.spawn: _darkBoltStartFrames,
  AnimKey.idle: _darkBoltIdleFrames,
  AnimKey.hit: _darkBoltHitFrames,
};

const Map<AnimKey, int> _darkBoltRowByKey = <AnimKey, int>{
  AnimKey.spawn: 0,
  AnimKey.idle: 0,
  AnimKey.hit: 1,
};

const Map<AnimKey, double> _darkBoltStepTimeSecondsByKey = <AnimKey, double>{
  AnimKey.spawn: _darkBoltStartStepSeconds,
  AnimKey.idle: _darkBoltIdleStepSeconds,
  AnimKey.hit: _darkBoltHitStepSeconds,
};

const Map<AnimKey, String> _darkBoltSourcesByKey = <AnimKey, String>{
  AnimKey.spawn: 'entities/spells/dark/bolt/spriteSheet.png',
  AnimKey.idle: 'entities/spells/dark/bolt/spriteSheet.png',
  AnimKey.hit: 'entities/spells/dark/bolt/spriteSheet.png',
};

const RenderAnimSetDefinition _darkBoltRenderAnim = RenderAnimSetDefinition(
  frameWidth: _darkBoltFrameWidth,
  frameHeight: _darkBoltFrameHeight,
  sourcesByKey: _darkBoltSourcesByKey,
  rowByKey: _darkBoltRowByKey,
  frameCountsByKey: _darkBoltFrameCountsByKey,
  stepTimeSecondsByKey: _darkBoltStepTimeSecondsByKey,
);

// -----------------------------------------------------------------------------
// Earth Bolt render animation strip definitions (authoring-time)
// -----------------------------------------------------------------------------

const int _earthBoltFrameWidth = 48;
const int _earthBoltFrameHeight = 32;

const int _earthBoltStartFrames = 6;
const int _earthBoltIdleFrames = 6;
const int _earthBoltHitFrames = 4;

const double _earthBoltStartStepSeconds = 0.06;
const double _earthBoltIdleStepSeconds = 0.06;
const double _earthBoltHitStepSeconds = 0.06;

const Map<AnimKey, int> _earthBoltFrameCountsByKey = <AnimKey, int>{
  AnimKey.spawn: _earthBoltStartFrames,
  AnimKey.idle: _earthBoltIdleFrames,
  AnimKey.hit: _earthBoltHitFrames,
};

const Map<AnimKey, int> _earthBoltRowByKey = <AnimKey, int>{
  AnimKey.spawn: 0,
  AnimKey.idle: 0,
  AnimKey.hit: 1,
};

const Map<AnimKey, double> _earthBoltStepTimeSecondsByKey = <AnimKey, double>{
  AnimKey.spawn: _earthBoltStartStepSeconds,
  AnimKey.idle: _earthBoltIdleStepSeconds,
  AnimKey.hit: _earthBoltHitStepSeconds,
};

const Map<AnimKey, String> _earthBoltSourcesByKey = <AnimKey, String>{
  AnimKey.spawn: 'entities/spells/earth/bolt/spriteSheet.png',
  AnimKey.idle: 'entities/spells/earth/bolt/spriteSheet.png',
  AnimKey.hit: 'entities/spells/earth/bolt/spriteSheet.png',
};

const RenderAnimSetDefinition _earthBoltRenderAnim = RenderAnimSetDefinition(
  frameWidth: _earthBoltFrameWidth,
  frameHeight: _earthBoltFrameHeight,
  sourcesByKey: _earthBoltSourcesByKey,
  rowByKey: _earthBoltRowByKey,
  frameCountsByKey: _earthBoltFrameCountsByKey,
  stepTimeSecondsByKey: _earthBoltStepTimeSecondsByKey,
);

// -----------------------------------------------------------------------------
// Holy Bolt render animation strip definitions (authoring-time)
// -----------------------------------------------------------------------------

const int _holyBoltFrameWidth = 32;
const int _holyBoltFrameHeight = 32;

const int _holyBoltStartFrames = 2;
const int _holyBoltIdleFrames = 8;
const int _holyBoltHitFrames = 6;

const double _holyBoltStartStepSeconds = 0.06;
const double _holyBoltIdleStepSeconds = 0.06;
const double _holyBoltHitStepSeconds = 0.06;

const Map<AnimKey, int> _holyBoltFrameCountsByKey = <AnimKey, int>{
  AnimKey.spawn: _holyBoltStartFrames,
  AnimKey.idle: _holyBoltIdleFrames,
  AnimKey.hit: _holyBoltHitFrames,
};

const Map<AnimKey, double> _holyBoltStepTimeSecondsByKey = <AnimKey, double>{
  AnimKey.spawn: _holyBoltStartStepSeconds,
  AnimKey.idle: _holyBoltIdleStepSeconds,
  AnimKey.hit: _holyBoltHitStepSeconds,
};

const Map<AnimKey, String> _holyBoltSourcesByKey = <AnimKey, String>{
  AnimKey.spawn: 'entities/spells/holy/bolt/start.png',
  AnimKey.idle: 'entities/spells/holy/bolt/repeatable.png',
  AnimKey.hit: 'entities/spells/holy/bolt/hit.png',
};

const RenderAnimSetDefinition _holyBoltRenderAnim = RenderAnimSetDefinition(
  frameWidth: _holyBoltFrameWidth,
  frameHeight: _holyBoltFrameHeight,
  sourcesByKey: _holyBoltSourcesByKey,
  frameCountsByKey: _holyBoltFrameCountsByKey,
  stepTimeSecondsByKey: _holyBoltStepTimeSecondsByKey,
);

// -----------------------------------------------------------------------------
// Water Bolt render animation strip definitions (authoring-time)
// -----------------------------------------------------------------------------

const int _waterBoltFrameWidth = 64;
const int _waterBoltFrameHeight = 64;

const int _waterBoltSpawnFrames = 5;
const int _waterBoltIdleFrames = 16;
const int _waterBoltHitFrames = 15;

const double _waterBoltSpawnStepSeconds = 0.01;
const double _waterBoltIdleStepSeconds = 0.03;
const double _waterBoltHitStepSeconds = 0.03;

const Map<AnimKey, int> _waterBoltFrameCountsByKey = <AnimKey, int>{
  AnimKey.spawn: _waterBoltSpawnFrames,
  AnimKey.idle: _waterBoltIdleFrames,
  AnimKey.hit: _waterBoltHitFrames,
};

const Map<AnimKey, int> _waterBoltRowByKey = <AnimKey, int>{
  AnimKey.spawn: 0,
  AnimKey.idle: 1,
  AnimKey.hit: 0,
};

const Map<AnimKey, int> _waterBoltFrameStartByKey = <AnimKey, int>{
  AnimKey.spawn: 0,
  AnimKey.idle: 0,
  AnimKey.hit: 0,
};

const Map<AnimKey, int> _waterBoltGridColumnsByKey = <AnimKey, int>{
  AnimKey.spawn: 5,
  AnimKey.idle: 5,
  AnimKey.hit: 4,
};

const Map<AnimKey, double> _waterBoltStepTimeSecondsByKey = <AnimKey, double>{
  AnimKey.spawn: _waterBoltSpawnStepSeconds,
  AnimKey.idle: _waterBoltIdleStepSeconds,
  AnimKey.hit: _waterBoltHitStepSeconds,
};

const Map<AnimKey, String> _waterBoltSourcesByKey = <AnimKey, String>{
  AnimKey.spawn: 'entities/spells/water/bolt/start_and_repeatable.png',
  AnimKey.idle: 'entities/spells/water/bolt/start_and_repeatable.png',
  AnimKey.hit: 'entities/spells/water/bolt/hit.png',
};

const RenderAnimSetDefinition _waterBoltRenderAnim = RenderAnimSetDefinition(
  frameWidth: _waterBoltFrameWidth,
  frameHeight: _waterBoltFrameHeight,
  sourcesByKey: _waterBoltSourcesByKey,
  rowByKey: _waterBoltRowByKey,
  frameStartByKey: _waterBoltFrameStartByKey,
  gridColumnsByKey: _waterBoltGridColumnsByKey,
  frameCountsByKey: _waterBoltFrameCountsByKey,
  stepTimeSecondsByKey: _waterBoltStepTimeSecondsByKey,
);

// -----------------------------------------------------------------------------
// Throwing Axe render animation strip definitions (authoring-time)
// -----------------------------------------------------------------------------

const int _throwingAxeFrameWidth = 32;
const int _throwingAxeFrameHeight = 32;

const int _throwingAxeFrames = 1;
const double _throwingAxeStepSeconds = 0.10;

const Map<AnimKey, int> _throwingAxeFrameCountsByKey = <AnimKey, int>{
  AnimKey.idle: _throwingAxeFrames,
};

const Map<AnimKey, double> _throwingAxeStepTimeSecondsByKey = <AnimKey, double>{
  AnimKey.idle: _throwingAxeStepSeconds,
};

const Map<AnimKey, String> _throwingAxeSourcesByKey = <AnimKey, String>{
  AnimKey.idle: 'weapons/throwingWeapons/throwingAxe.png',
};

const RenderAnimSetDefinition _throwingAxeRenderAnim = RenderAnimSetDefinition(
  frameWidth: _throwingAxeFrameWidth,
  frameHeight: _throwingAxeFrameHeight,
  sourcesByKey: _throwingAxeSourcesByKey,
  frameCountsByKey: _throwingAxeFrameCountsByKey,
  stepTimeSecondsByKey: _throwingAxeStepTimeSecondsByKey,
);

// -----------------------------------------------------------------------------
// Throwing Axe render animation strip definitions (authoring-time)
// -----------------------------------------------------------------------------

const int _throwingKnifeFrameWidth = 32;
const int _throwingKnifeFrameHeight = 32;

const int _throwingKnifeFrames = 1;
const double _throwingKnifeStepSeconds = 0.10;

const Map<AnimKey, int> _throwingKnifeFrameCountsByKey = <AnimKey, int>{
  AnimKey.idle: _throwingKnifeFrames,
};

const Map<AnimKey, double> _throwingKnifeStepTimeSecondsByKey =
    <AnimKey, double>{AnimKey.idle: _throwingKnifeStepSeconds};

const Map<AnimKey, String> _throwingKnifeSourcesByKey = <AnimKey, String>{
  AnimKey.idle: 'weapons/throwingWeapons/throwingKnife.png',
};

const RenderAnimSetDefinition _throwingKnifeRenderAnim =
    RenderAnimSetDefinition(
      frameWidth: _throwingKnifeFrameWidth,
      frameHeight: _throwingKnifeFrameHeight,
      sourcesByKey: _throwingKnifeSourcesByKey,
      frameCountsByKey: _throwingKnifeFrameCountsByKey,
      stepTimeSecondsByKey: _throwingKnifeStepTimeSecondsByKey,
    );

/// Lookup table for projectile render animation definitions.
///
/// Core owns the animation timing and frame metadata. The renderer uses this
/// catalog to load assets and drive deterministic animation frames.
class ProjectileRenderCatalog {
  const ProjectileRenderCatalog();

  RenderAnimSetDefinition get(ProjectileId id) {
    switch (id) {
      case ProjectileId.unknown:
        throw ArgumentError.value(
          id,
          'id',
          'ProjectileId.unknown has no render catalog entry.',
        );
      case ProjectileId.iceBolt:
        return _iceBoltRenderAnim;
      case ProjectileId.thunderBolt:
        return _thunderBoltRenderAnim;
      case ProjectileId.fireBolt:
        return _fireBoltRenderAnim;
      case ProjectileId.acidBolt:
        return _acidBoltRenderAnim;
      case ProjectileId.darkBolt:
        return _darkBoltRenderAnim;
      case ProjectileId.earthBolt:
        return _earthBoltRenderAnim;
      case ProjectileId.holyBolt:
        return _holyBoltRenderAnim;
      case ProjectileId.waterBolt:
        return _waterBoltRenderAnim;
      case ProjectileId.throwingAxe:
        return _throwingAxeRenderAnim;
      case ProjectileId.throwingKnife:
        return _throwingKnifeRenderAnim;
    }
  }
}


===== FILE: lib/core/projectiles/spawn_projectile_item.dart =====
/// Projectile spawning utilities for projectile slot items.
library;

import 'dart:math';

import '../combat/damage_type.dart';
import '../combat/faction.dart';
import '../ecs/entity_id.dart';
import '../ecs/stores/body_store.dart';
import '../ecs/stores/collider_aabb_store.dart';
import '../ecs/stores/lifetime_store.dart';
import '../ecs/stores/projectile_item_origin_store.dart';
import '../ecs/stores/projectile_store.dart';
import '../ecs/world.dart';
import '../projectiles/projectile_item_def.dart';
import '../projectiles/projectile_id.dart';
import '../util/tick_math.dart';
import '../weapons/weapon_proc.dart';

const _dirEps2 = 1e-12;

({double x, double y}) _normalizeDirOrFallback(
  double x,
  double y, {
  required double fallbackX,
  required double fallbackY,
}) {
  final len2 = x * x + y * y;
  if (len2 <= _dirEps2) {
    final fbLen2 = fallbackX * fallbackX + fallbackY * fallbackY;
    if (fbLen2 <= _dirEps2) {
      return (x: 1.0, y: 0.0);
    }
    final invLen = 1.0 / sqrt(fbLen2);
    return (x: fallbackX * invLen, y: fallbackY * invLen);
  }

  final invLen = 1.0 / sqrt(len2);
  return (x: x * invLen, y: y * invLen);
}

EntityId spawnProjectileFromCaster(
  EcsWorld world, {
  required int tickHz,
  required ProjectileId projectileId,
  required ProjectileItemDef projectile,
  required Faction faction,
  required EntityId owner,
  required double casterX,
  required double casterY,
  required double originOffset,
  required double dirX,
  required double dirY,
  required double fallbackDirX,
  required double fallbackDirY,
  required int damage100,
  required int critChanceBp,
  required DamageType damageType,
  List<WeaponProc> procs = const <WeaponProc>[],
  bool pierce = false,
  int maxPierceHits = 1,
  required bool ballistic,
  required double gravityScale,
  double speedScale = 1.0,
}) {
  final safeSpeedScale = speedScale <= 0 ? 0.01 : speedScale;
  final speedUnitsPerSecond = projectile.speedUnitsPerSecond * safeSpeedScale;
  final resolvedMaxPierceHits = max(1, maxPierceHits);

  final dir = _normalizeDirOrFallback(
    dirX,
    dirY,
    fallbackX: fallbackDirX,
    fallbackY: fallbackDirY,
  );

  final originX = casterX + dir.x * originOffset;
  final originY = casterY + dir.y * originOffset;

  final entity = world.createEntity();

  final initialVelX = ballistic ? dir.x * speedUnitsPerSecond : 0.0;
  final initialVelY = ballistic ? dir.y * speedUnitsPerSecond : 0.0;

  world.transform.add(
    entity,
    posX: originX,
    posY: originY,
    velX: initialVelX,
    velY: initialVelY,
  );

  world.projectile.add(
    entity,
    ProjectileEntityDef(
      projectileId: projectileId,
      faction: faction,
      owner: owner,
      dirX: dir.x,
      dirY: dir.y,
      speedUnitsPerSecond: speedUnitsPerSecond,
      damage100: damage100,
      critChanceBp: critChanceBp,
      damageType: damageType,
      procs: procs,
      pierce: pierce,
      maxPierceHits: resolvedMaxPierceHits,
      usePhysics: ballistic,
    ),
  );

  world.hitOnce.add(entity);

  world.projectileOrigin.add(
    entity,
    ProjectileOriginDef(projectileId: projectileId),
  );

  world.lifetime.add(
    entity,
    LifetimeDef(
      ticksLeft: ticksFromSecondsCeil(projectile.lifetimeSeconds, tickHz),
    ),
  );

  world.colliderAabb.add(
    entity,
    ColliderAabbDef(
      halfX: projectile.colliderSizeX * 0.5,
      halfY: projectile.colliderSizeY * 0.5,
    ),
  );

  if (ballistic) {
    world.body.add(
      entity,
      BodyDef(
        isKinematic: false,
        useGravity: true,
        gravityScale: gravityScale,
        sideMask: BodyDef.sideLeft | BodyDef.sideRight,
      ),
    );
    world.collision.add(entity);
  }

  return entity;
}


===== FILE: lib/core/scoring/run_score_breakdown.dart =====
import '../enemies/enemy_id.dart';
import '../tuning/score_tuning.dart';

/// Categories of score contributions shown in the end-of-run breakdown.
enum RunScoreRowKind {
  /// Points earned from distance traveled.
  distance,

  /// Points earned from survival time.
  time,

  /// Points earned from collected items.
  collectibles,

  /// Points earned from killing enemies (one row per enemy type).
  enemyKill,
}

/// A single line item in the score breakdown UI.
///
/// Each row shows a category, a count (e.g., meters, seconds, kills),
/// and the points contributed by that category.
class RunScoreRow {
  const RunScoreRow({
    required this.kind,
    required this.count,
    required this.points,
    this.enemyId,
  });

  /// Row category (distance/time/collectibles/enemy kills).
  final RunScoreRowKind kind;

  /// Quantity displayed (meters, seconds, collectible count, or kill count).
  final int count;

  /// Total points contributed by this row.
  final int points;

  /// For [RunScoreRowKind.enemyKill] rows, identifies the enemy type.
  final EnemyId? enemyId;
}

/// Complete score breakdown for a finished run.
///
/// Contains itemized rows and the computed total. Used by the game-over UI
/// to display how the player earned their score.
class RunScoreBreakdown {
  const RunScoreBreakdown({required this.rows, required this.totalPoints});

  /// Itemized score contributions (distance, time, collectibles, enemy kills).
  final List<RunScoreRow> rows;

  /// Sum of all row points.
  final int totalPoints;
}

/// Computes the score breakdown for a completed run.
///
/// Converts raw game stats (ticks, distance units, kill counts) into
/// player-facing values (meters, seconds) and calculates points using
/// [ScoreTuning] multipliers.
RunScoreBreakdown buildRunScoreBreakdown({
  required int tick,
  required double distanceUnits,
  required int collectibles,
  required int collectibleScore,
  required List<int> enemyKillCounts,
  required ScoreTuning tuning,
  required int tickHz,
  int unitsPerMeter = kWorldUnitsPerMeter,
}) {
  // Convert internal units to player-facing values.
  final meters = unitsPerMeter <= 0
      ? 0
      : (distanceUnits / unitsPerMeter).floor();
  final timeSeconds = tickHz <= 0 ? 0 : tick ~/ tickHz;

  final rows = <RunScoreRow>[
    RunScoreRow(
      kind: RunScoreRowKind.distance,
      count: meters,
      points: meters * tuning.distanceScorePerMeter,
    ),
    RunScoreRow(
      kind: RunScoreRowKind.time,
      count: timeSeconds,
      points: timeSeconds * tuning.timeScorePerSecond,
    ),
    RunScoreRow(
      kind: RunScoreRowKind.collectibles,
      count: collectibles,
      points: collectibleScore,
    ),
  ];

  // Add a row for each enemy type with at least one kill.
  for (final enemyId in EnemyId.values) {
    final index = enemyId.index;
    final kills = index < enemyKillCounts.length ? enemyKillCounts[index] : 0;
    if (kills <= 0) continue;
    rows.add(
      RunScoreRow(
        kind: RunScoreRowKind.enemyKill,
        count: kills,
        points: kills * _enemyKillScore(tuning, enemyId),
        enemyId: enemyId,
      ),
    );
  }

  // Sum all rows for total.
  var totalPoints = 0;
  for (final row in rows) {
    totalPoints += row.points;
  }

  return RunScoreBreakdown(
    rows: List<RunScoreRow>.unmodifiable(rows),
    totalPoints: totalPoints,
  );
}

/// Returns the point value for killing one enemy of [enemyId] type.
int _enemyKillScore(ScoreTuning tuning, EnemyId enemyId) {
  switch (enemyId) {
    case EnemyId.grojib:
      return tuning.groundEnemyKillScore;
    case EnemyId.unocoDemon:
      return tuning.unocoDemonKillScore;
  }
}


===== FILE: lib/core/snapshot_builder.dart =====
/// Builds immutable render snapshots from ECS world state.
///
/// This module decouples snapshot construction from simulation logic,
/// providing a clean separation between the game's internal state (ECS)
/// and the data consumed by the rendering layer.
///
/// All methods are pure readers—no side effects on [EcsWorld].
///
/// ## Architecture
///
/// The render layer never reads ECS directly. Instead, [GameCore] calls
/// [SnapshotBuilder.build] once per tick to produce a [GameStateSnapshot],
/// which is an immutable, self-contained description of everything needed
/// to draw a single frame.
///
/// ## Key Types
///
/// - [SnapshotBuilder] — Stateful builder holding ECS and tuning references.
/// - [GameStateSnapshot] — Complete frame data (entities, HUD, geometry).
/// - [EntityRenderSnapshot] — Per-entity render info (position, animation, etc.).
/// - [PlayerHudSnapshot] — Player resource bars, cooldowns, affordability flags.
library;

import 'dart:math';

import 'ecs/entity_id.dart';
import 'ecs/world.dart';
import 'ecs/stores/combat/equipped_loadout_store.dart';
import 'ecs/stores/restoration_item_store.dart';
import 'levels/level_id.dart';
import 'enemies/enemy_catalog.dart';
import 'snapshots/enums.dart';
import 'snapshots/camera_snapshot.dart';
import 'snapshots/entity_render_snapshot.dart';
import 'snapshots/game_state_snapshot.dart';
import 'snapshots/ground_surface_snapshot.dart';
import 'snapshots/player_hud_snapshot.dart';
import 'snapshots/static_solid_snapshot.dart';
import 'players/player_tuning.dart';
import 'util/vec2.dart';
import 'abilities/ability_catalog.dart';
import 'abilities/ability_def.dart';
import 'abilities/effective_ability_cost.dart';
import 'combat/control_lock.dart';
import 'util/fixed_math.dart';
import 'util/tick_math.dart';
import 'loadout/loadout_validator.dart';
import 'projectiles/projectile_catalog.dart';
import 'spellBook/spell_book_catalog.dart';
import 'weapons/weapon_catalog.dart';

// ─────────────────────────────────────────────────────────────────────────────
// SnapshotBuilder
// ─────────────────────────────────────────────────────────────────────────────

/// Constructs [GameStateSnapshot] instances from ECS world state.
///
/// Holds references to the ECS world and all tuning data needed to compute
/// derived values (e.g., cooldown progress, affordability flags).
///
/// Usage:
/// ```dart
/// final builder = SnapshotBuilder(world: ..., player: ..., ...);
/// final snapshot = builder.build(tick: 42, ...);
/// ```
class SnapshotBuilder {
  /// Creates a snapshot builder with the given dependencies.
  ///
  /// - [tickHz]: Fixed tick rate for converting seconds to ticks.
  /// - [world]: The ECS world containing all entity component data.
  /// - [player]: Entity ID of the player (used to query player-specific stores).
  /// - [movement]: Derived movement tuning (dash cooldown ticks, etc.).
  /// - [abilities]: Derived ability tuning (melee/cast cooldown ticks).
  /// - [resources]: Resource costs (jump/dash stamina, etc.).
  /// - [enemyCatalog]: Enemy catalog for render metadata (hit windows, art facing).
  SnapshotBuilder({
    required this.tickHz,
    required this.world,
    required this.player,
    required this.movement,
    required this.abilities,
    required this.resources,
    required this.enemyCatalog,
    this.abilityCatalog = AbilityCatalog.shared,
    required this.weaponCatalog,
    required this.projectileCatalog,
    required this.spellBookCatalog,
    required LoadoutValidator loadoutValidator,
  }) : _loadoutValidator = loadoutValidator;

  /// Tick rate (ticks per second) for converting seconds to ticks.
  final int tickHz;

  /// The ECS world containing all game entity data.
  final EcsWorld world;

  /// Entity ID of the player character.
  final EntityId player;

  /// Derived movement tuning (pre-computed tick-based values).
  final MovementTuningDerived movement;

  /// Derived ability tuning (cooldown durations in ticks).
  final AbilityTuningDerived abilities;

  /// Resource tuning (stamina/mana costs for actions).
  final ResourceTuningDerived resources;

  /// Enemy catalog for render metadata (art facing direction).
  final EnemyCatalog enemyCatalog;
  final AbilityResolver abilityCatalog;
  final WeaponCatalog weaponCatalog;
  final ProjectileCatalog projectileCatalog;
  final SpellBookCatalog spellBookCatalog;

  final LoadoutValidator _loadoutValidator;

  // ───────────────────────────────────────────────────────────────────────────
  // Public API
  // ───────────────────────────────────────────────────────────────────────────

  /// Builds a complete [GameStateSnapshot] for the current tick.
  ///
  /// This method reads from multiple ECS component stores to assemble:
  /// - Player state (position, velocity, animation, facing direction)
  /// - HUD data (HP, mana, stamina, cooldowns, affordability)
  /// - All entity render snapshots (player, enemies, projectiles, pickups)
  /// - Static geometry (platforms, ground gaps)
  ///
  /// Parameters:
  /// - [tick]: Current simulation tick number.
  /// - [runId]: Unique identifier for this run session.
  /// - [seed]: RNG seed for this run (stored for replay/debug).
  /// - [levelId]: Level identifier for this run (stored for replay/debug).
  /// - [themeId]: Optional render theme identifier (stored for debug/UI).
  /// - [distance]: Total distance traveled (world units).
  /// - [paused]: Whether the game is currently paused.
  /// - [gameOver]: Whether the run has ended.
  /// - [camera]: Camera framing (world-space center + viewport dimensions).
  /// - [collectibles]: Number of collectibles picked up this run.
  /// - [collectibleScore]: Total score from collectibles.
  /// - [staticSolids]: Pre-built list of platform snapshots.
  /// - [groundSurfaces]: Pre-built list of walkable ground surface snapshots.
  GameStateSnapshot build({
    required int tick,
    required int runId,
    required int seed,
    required LevelId levelId,
    required String? themeId,
    required double distance,
    required bool paused,
    required bool gameOver,
    required CameraSnapshot camera,
    required int collectibles,
    required int collectibleScore,
    required List<StaticSolidSnapshot> staticSolids,
    required List<GroundSurfaceSnapshot> groundSurfaces,
  }) {
    // ─── Query player component indices ───
    final mi = world.movement.indexOf(player);
    final onGround = world.collision.grounded[world.collision.indexOf(player)];
    final jumpStateIndex = world.jumpState.tryIndexOf(player);
    final hi = world.health.indexOf(player);
    final mai = world.mana.indexOf(player);
    final si = world.stamina.indexOf(player);

    final li = world.equippedLoadout.indexOf(player);

    // ─── Read current resource values ───
    final stamina = world.stamina.stamina[si];
    final mana = world.mana.mana[mai];
    final hp100 = world.health.hp[hi];
    final loadout = world.equippedLoadout;
    final loadoutMask = loadout.mask[li];
    final loadoutDef = EquippedLoadoutDef(
      mask: loadoutMask,
      mainWeaponId: loadout.mainWeaponId[li],
      offhandWeaponId: loadout.offhandWeaponId[li],
      projectileId: loadout.projectileId[li],
      spellBookId: loadout.spellBookId[li],
      projectileSlotSpellId: loadout.projectileSlotSpellId[li],
      accessoryId: loadout.accessoryId[li],
      abilityPrimaryId: loadout.abilityPrimaryId[li],
      abilitySecondaryId: loadout.abilitySecondaryId[li],
      abilityProjectileId: loadout.abilityProjectileId[li],
      abilitySpellId: loadout.abilitySpellId[li],
      abilityMobilityId: loadout.abilityMobilityId[li],
      abilityJumpId: loadout.abilityJumpId[li],
    );

    final invalidSlots = <AbilitySlot>{};
    final validation = _loadoutValidator.validate(loadoutDef);
    for (final issue in validation.issues) {
      invalidSlots.add(issue.slot);
    }

    final meleeSlotValid = !invalidSlots.contains(AbilitySlot.primary);
    final secondarySlotValid = !invalidSlots.contains(AbilitySlot.secondary);
    final projectileSlotValid = !invalidSlots.contains(AbilitySlot.projectile);
    final mobilitySlotValid = !invalidSlots.contains(AbilitySlot.mobility);
    final spellSlotValid = !invalidSlots.contains(AbilitySlot.spell);
    final jumpSlotValid = !invalidSlots.contains(AbilitySlot.jump);

    final projectileAbilityId = loadout.abilityProjectileId[li];
    final projectileAbility = abilityCatalog.resolve(projectileAbilityId);
    final projectileCost = _resolveAbilityCostForSlot(
      ability: projectileAbility,
      slot: AbilitySlot.projectile,
      loadoutIndex: li,
    );
    final projectileManaCost = projectileCost.manaCost100;
    final projectileStaminaCost = projectileCost.staminaCost100;
    final hasProjectileSlot = (loadoutMask & LoadoutSlotMask.projectile) != 0;

    final mobilityAbilityId = loadout.abilityMobilityId[li];
    final mobilityAbility = abilityCatalog.resolve(mobilityAbilityId);
    final mobilityCost = _resolveAbilityCostForSlot(
      ability: mobilityAbility,
      slot: AbilitySlot.mobility,
      loadoutIndex: li,
    );
    final mobilityManaCost = mobilityAbility == null
        ? 0
        : mobilityCost.manaCost100;
    final mobilityStaminaCost = mobilityAbility == null
        ? resources.dashStaminaCost100
        : mobilityCost.staminaCost100;

    final jumpAbilityId = loadout.abilityJumpId[li];
    final jumpAbility = abilityCatalog.resolve(jumpAbilityId);
    final jumpCost = _resolveAbilityCostForSlot(
      ability: jumpAbility,
      slot: AbilitySlot.jump,
      loadoutIndex: li,
    );
    final jumpAirCost = jumpAbility?.airJumpCost ?? AbilityResourceCost.zero;
    final jumpManaCost = jumpAbility == null ? 0 : jumpCost.manaCost100;
    final jumpStaminaCost = jumpAbility == null
        ? resources.jumpStaminaCost100
        : jumpCost.staminaCost100;
    final canGroundJumpNow =
        onGround ||
        (jumpStateIndex != null &&
            world.jumpState.coyoteTicksLeft[jumpStateIndex] > 0);
    final airJumpsUsed = jumpStateIndex == null
        ? 0
        : world.jumpState.airJumpsUsed[jumpStateIndex];
    final canAirJumpNow =
        !canGroundJumpNow && airJumpsUsed < (jumpAbility?.maxAirJumps ?? 0);
    final canAffordGroundJump =
        stamina >= jumpStaminaCost &&
        mana >= jumpManaCost &&
        _canAffordHealthCost(hp100, jumpCost.healthCost100);
    final canAffordAirJump =
        stamina >= jumpAirCost.staminaCost100 &&
        mana >= jumpAirCost.manaCost100 &&
        _canAffordHealthCost(hp100, jumpAirCost.healthCost100);

    final meleeAbilityId = loadout.abilityPrimaryId[li];
    final meleeAbility = abilityCatalog.resolve(meleeAbilityId);
    final meleeCost = _resolveAbilityCostForSlot(
      ability: meleeAbility,
      slot: AbilitySlot.primary,
      loadoutIndex: li,
    );
    final meleeManaCost = meleeAbility == null ? 0 : meleeCost.manaCost100;
    final meleeStaminaCost = meleeAbility == null
        ? toFixed100(abilities.base.meleeStaminaCost)
        : meleeCost.staminaCost100;

    final secondaryAbilityId = loadout.abilitySecondaryId[li];
    final secondaryAbility = abilityCatalog.resolve(secondaryAbilityId);
    final secondaryCost = _resolveAbilityCostForSlot(
      ability: secondaryAbility,
      slot: AbilitySlot.secondary,
      loadoutIndex: li,
    );
    final secondaryManaCost = secondaryAbility == null
        ? 0
        : secondaryCost.manaCost100;
    final secondaryStaminaCost = secondaryAbility == null
        ? toFixed100(abilities.base.meleeStaminaCost)
        : secondaryCost.staminaCost100;

    final spellAbilityId = loadout.abilitySpellId[li];
    final spellAbility = abilityCatalog.resolve(spellAbilityId);
    final spellCost = _resolveAbilityCostForSlot(
      ability: spellAbility,
      slot: AbilitySlot.spell,
      loadoutIndex: li,
    );
    final spellManaCost = spellCost.manaCost100;
    final spellStaminaCost = spellCost.staminaCost100;

    final meleeInputMode = _inputModeFor(meleeAbility);
    final secondaryInputMode = _inputModeFor(secondaryAbility);
    final projectileInputMode = _inputModeFor(projectileAbility);
    final mobilityInputMode = _inputModeFor(mobilityAbility);

    final chargePreview = _resolveHudChargePreview(
      player: player,
      meleeAbility: meleeAbility,
      secondaryAbility: secondaryAbility,
      projectileAbility: projectileAbility,
      mobilityAbility: mobilityAbility,
    );
    // ─── Compute affordability flags ───
    // These tell the UI whether action buttons should appear enabled.
    final canAffordJump = canGroundJumpNow
        ? canAffordGroundJump
        : (canAirJumpNow ? canAffordAirJump : false);
    final canAffordMobility =
        stamina >= mobilityStaminaCost &&
        mana >= mobilityManaCost &&
        _canAffordHealthCost(hp100, mobilityCost.healthCost100);
    final canAffordMelee =
        stamina >= meleeStaminaCost &&
        mana >= meleeManaCost &&
        _canAffordHealthCost(hp100, meleeCost.healthCost100);

    final hasSecondarySlot = (loadoutMask & LoadoutSlotMask.offHand) != 0;
    final canAffordSecondary =
        hasSecondarySlot &&
        stamina >= secondaryStaminaCost &&
        mana >= secondaryManaCost &&
        _canAffordHealthCost(hp100, secondaryCost.healthCost100);

    final canAffordProjectile =
        hasProjectileSlot &&
        stamina >= projectileStaminaCost &&
        mana >= projectileManaCost &&
        _canAffordHealthCost(hp100, projectileCost.healthCost100);

    final canAffordSpell =
        spellAbility != null &&
        stamina >= spellStaminaCost &&
        mana >= spellManaCost &&
        _canAffordHealthCost(hp100, spellCost.healthCost100);

    // ─── Read cooldown timers ───
    final cooldownTicksLeft = List<int>.filled(kMaxCooldownGroups, 0);
    final cooldownTicksTotal = List<int>.filled(kMaxCooldownGroups, 0);

    // Populate current ticks from store.
    for (var g = 0; g < kMaxCooldownGroups; g++) {
      cooldownTicksLeft[g] = world.cooldown.getTicksLeft(player, g);
    }

    // Populate totals for active ability slots.
    // Primary (Melee)
    cooldownTicksTotal[CooldownGroup.primary] = meleeAbility == null
        ? abilities.meleeCooldownTicks
        : _scaleAbilityTicks(meleeAbility.cooldownTicks);

    // Secondary (Off-hand)
    cooldownTicksTotal[CooldownGroup.secondary] = secondaryAbility == null
        ? abilities.meleeCooldownTicks
        : _scaleAbilityTicks(secondaryAbility.cooldownTicks);

    // Projectile
    cooldownTicksTotal[CooldownGroup.projectile] = projectileAbility == null
        ? abilities.castCooldownTicks
        : _scaleAbilityTicks(projectileAbility.cooldownTicks);

    // Mobility
    cooldownTicksTotal[CooldownGroup.mobility] = mobilityAbility == null
        ? movement.dashCooldownTicks
        : _scaleAbilityTicks(mobilityAbility.cooldownTicks);

    // Spell slot (Utility)
    cooldownTicksTotal[CooldownGroup.spell0] = spellAbility == null
        ? 0
        : _scaleAbilityTicks(spellAbility.cooldownTicks);

    cooldownTicksTotal[CooldownGroup.jump] = jumpAbility == null
        ? 0
        : _scaleAbilityTicks(jumpAbility.cooldownTicks);

    // ─── Read player transform ───
    final ti = world.transform.indexOf(player);
    final playerPosX = world.transform.posX[ti];
    final playerPosY = world.transform.posY[ti];
    final playerVelX = world.transform.velX[ti];
    final playerVelY = world.transform.velY[ti];
    final playerFacing = world.movement.facing[mi];
    final animState = world.animState;
    final AnimKey anim;
    final int playerAnimFrame;
    if (animState.has(player)) {
      final ai = animState.indexOf(player);
      anim = animState.anim[ai];
      playerAnimFrame = animState.animFrame[ai];
    } else {
      anim = AnimKey.idle;
      playerAnimFrame = tick;
    }

    final playerPos = Vec2(playerPosX, playerPosY);
    final playerVel = Vec2(playerVelX, playerVelY);
    final playerLastDamageTick = world.lastDamage.has(player)
        ? world.lastDamage.tick[world.lastDamage.indexOf(player)]
        : -1;

    Vec2? playerSize;
    if (world.colliderAabb.has(player)) {
      final aabbi = world.colliderAabb.indexOf(player);
      playerSize = Vec2(
        world.colliderAabb.halfX[aabbi] * 2,
        world.colliderAabb.halfY[aabbi] * 2,
      );
    }

    // ─── Build entity list (player first) ───
    final entities = <EntityRenderSnapshot>[
      EntityRenderSnapshot(
        id: player,
        kind: EntityKind.player,
        pos: playerPos,
        vel: playerVel,
        size: playerSize,
        facing: playerFacing,
        anim: anim,
        grounded: onGround,
        animFrame: playerAnimFrame,
        statusVisualMask: _statusVisualMaskForEntity(player, tick: tick),
      ),
    ];

    // Append all other renderable entities.
    _addProjectiles(entities, tick: tick);
    _addHitboxes(entities, tick: tick);
    _addCollectibles(entities, tick: tick);
    _addRestorationItems(entities, tick: tick);
    _addEnemies(entities, tick: tick);

    // ─── Assemble final snapshot ───
    return GameStateSnapshot(
      tick: tick,
      runId: runId,
      seed: seed,
      levelId: levelId,
      themeId: themeId,
      distance: distance,
      paused: paused,
      gameOver: gameOver,
      camera: camera,
      hud: PlayerHudSnapshot(
        hp: fromFixed100(world.health.hp[hi]),
        hpMax: fromFixed100(world.health.hpMax[hi]),
        mana: fromFixed100(mana),
        manaMax: fromFixed100(world.mana.manaMax[mai]),
        stamina: fromFixed100(stamina),
        staminaMax: fromFixed100(world.stamina.staminaMax[si]),
        meleeSlotValid: meleeSlotValid,
        secondarySlotValid: secondarySlotValid,
        projectileSlotValid: projectileSlotValid,
        mobilitySlotValid: mobilitySlotValid,
        spellSlotValid: spellSlotValid,
        jumpSlotValid: jumpSlotValid,
        canAffordJump: canAffordJump,
        canAffordMobility: canAffordMobility,
        canAffordMelee: canAffordMelee,
        canAffordSecondary: canAffordSecondary,
        canAffordProjectile: canAffordProjectile,
        canAffordSpell: canAffordSpell,
        cooldownTicksLeft: cooldownTicksLeft,
        cooldownTicksTotal: cooldownTicksTotal,
        meleeInputMode: meleeInputMode,
        secondaryInputMode: secondaryInputMode,
        projectileInputMode: projectileInputMode,
        mobilityInputMode: mobilityInputMode,
        chargeEnabled: chargePreview.enabled,
        chargeHalfTicks: chargePreview.halfTicks,
        chargeFullTicks: chargePreview.fullTicks,
        chargeActive: chargePreview.active,
        chargeTicks: chargePreview.ticks,
        chargeTier: chargePreview.tier,
        lastDamageTick: playerLastDamageTick,
        collectibles: collectibles,
        collectibleScore: collectibleScore,
      ),
      entities: entities,
      staticSolids: staticSolids,
      groundSurfaces: groundSurfaces,
    );
  }

  int _scaleAbilityTicks(int ticks) {
    if (ticks <= 0) return 0;
    if (tickHz == _abilityTickHz) return ticks;
    final seconds = ticks / _abilityTickHz;
    return ticksFromSecondsCeil(seconds, tickHz);
  }

  AbilityInputMode _inputModeFor(AbilityDef? ability) {
    if (ability == null) return AbilityInputMode.tap;
    return switch (ability.inputLifecycle) {
      AbilityInputLifecycle.tap => AbilityInputMode.tap,
      AbilityInputLifecycle.holdRelease =>
        _requiresAimGesture(ability.targetingModel)
            ? AbilityInputMode.holdAimRelease
            : AbilityInputMode.holdRelease,
      AbilityInputLifecycle.holdMaintain => AbilityInputMode.holdMaintain,
    };
  }

  bool _requiresAimGesture(TargetingModel targetingModel) {
    return switch (targetingModel) {
      TargetingModel.none || TargetingModel.homing => false,
      TargetingModel.directional ||
      TargetingModel.aimed ||
      TargetingModel.aimedLine ||
      TargetingModel.aimedCharge ||
      TargetingModel.groundTarget => true,
    };
  }

  _HudChargePreview _resolveHudChargePreview({
    required EntityId player,
    required AbilityDef? meleeAbility,
    required AbilityDef? secondaryAbility,
    required AbilityDef? projectileAbility,
    required AbilityDef? mobilityAbility,
  }) {
    final bySlot = <AbilitySlot, AbilityDef?>{
      AbilitySlot.primary: meleeAbility,
      AbilitySlot.secondary: secondaryAbility,
      AbilitySlot.projectile: projectileAbility,
      AbilitySlot.mobility: mobilityAbility,
    };
    final thresholdsBySlot = <AbilitySlot, _ChargeThresholds>{};
    for (final entry in bySlot.entries) {
      final ability = entry.value;
      if (!_supportsTieredCharge(ability)) continue;
      final fullTicks = _chargeFullThresholdTicks(ability!);
      final halfTicks = _chargeHalfThresholdTicks(ability, fullTicks);
      thresholdsBySlot[entry.key] = _ChargeThresholds(
        halfTicks: halfTicks,
        fullTicks: fullTicks,
      );
    }
    if (thresholdsBySlot.isEmpty) return const _HudChargePreview.disabled();

    AbilitySlot? activeSlot;
    var chargeTicks = 0;
    if (world.abilityCharge.has(player)) {
      final charge = world.abilityCharge;
      final chargeIndex = charge.indexOf(player);
      for (final slot in _chargePreviewSlotPriority) {
        final thresholds = thresholdsBySlot[slot];
        if (thresholds == null) continue;
        if (!charge.slotHeld(player, slot)) continue;
        activeSlot = slot;
        final slotOffset = charge.slotOffsetForDenseIndex(chargeIndex, slot);
        chargeTicks = charge.currentHoldTicksBySlot[slotOffset];
        if (chargeTicks < 0) chargeTicks = 0;
        break;
      }
    }

    final selectedSlot =
        activeSlot ?? _firstSlotByPriority(thresholdsBySlot.keys);
    final selectedThresholds = thresholdsBySlot[selectedSlot]!;
    var chargeTier = 0;
    if (activeSlot != null) {
      if (selectedThresholds.fullTicks > 0 &&
          chargeTicks >= selectedThresholds.fullTicks) {
        chargeTier = 2;
      } else if (selectedThresholds.halfTicks > 0 &&
          chargeTicks >= selectedThresholds.halfTicks) {
        chargeTier = 1;
      }
    }

    return _HudChargePreview(
      enabled: true,
      halfTicks: selectedThresholds.halfTicks,
      fullTicks: selectedThresholds.fullTicks,
      active: activeSlot != null,
      ticks: chargeTicks,
      tier: chargeTier,
    );
  }

  AbilitySlot _firstSlotByPriority(Iterable<AbilitySlot> slots) {
    final set = slots is Set<AbilitySlot> ? slots : slots.toSet();
    for (final slot in _chargePreviewSlotPriority) {
      if (set.contains(slot)) return slot;
    }
    // Fallback; should be unreachable with non-empty input.
    return AbilitySlot.projectile;
  }

  bool _supportsTieredCharge(AbilityDef? ability) {
    return ability != null && ability.chargeProfile != null;
  }

  int _chargeFullThresholdTicks(AbilityDef ability) {
    final profile = ability.chargeProfile;
    if (profile == null || profile.tiers.isEmpty) return 0;
    return _scaleAbilityTicks(profile.tiers.last.minHoldTicks60);
  }

  int _chargeHalfThresholdTicks(AbilityDef ability, int fullThresholdTicks) {
    final profile = ability.chargeProfile;
    if (profile == null) return max(1, fullThresholdTicks ~/ 2);
    for (final tier in profile.tiers) {
      if (tier.minHoldTicks60 <= 0) continue;
      final threshold = _scaleAbilityTicks(tier.minHoldTicks60);
      if (threshold > 0) return threshold;
    }
    return max(1, fullThresholdTicks ~/ 2);
  }

  AbilityResourceCost _resolveAbilityCostForSlot({
    required AbilityDef? ability,
    required AbilitySlot slot,
    required int loadoutIndex,
  }) {
    if (ability == null) return AbilityResourceCost.zero;
    return resolveEffectiveAbilityCostForSlot(
      ability: ability,
      loadout: world.equippedLoadout,
      loadoutIndex: loadoutIndex,
      slot: slot,
      weapons: weaponCatalog,
      projectiles: projectileCatalog,
      spellBooks: spellBookCatalog,
    );
  }

  bool _canAffordHealthCost(int hp100, int healthCost100) {
    if (healthCost100 <= 0) return true;
    return hp100 - healthCost100 >= _minCommitHp100;
  }

  static const int _abilityTickHz = 60;
  static const int _minCommitHp100 = 1;
  static const List<AbilitySlot> _chargePreviewSlotPriority = <AbilitySlot>[
    AbilitySlot.projectile,
    AbilitySlot.primary,
    AbilitySlot.secondary,
    AbilitySlot.mobility,
  ];

  // ───────────────────────────────────────────────────────────────────────────
  // Private Entity Collectors
  // ───────────────────────────────────────────────────────────────────────────

  int _statusVisualMaskForEntity(EntityId entity, {required int tick}) {
    var mask = EntityStatusVisualMask.none;

    final slowIndex = world.slow.tryIndexOf(entity);
    if (slowIndex != null && world.slow.ticksLeft[slowIndex] > 0) {
      mask |= EntityStatusVisualMask.slow;
    }

    final hasteIndex = world.haste.tryIndexOf(entity);
    if (hasteIndex != null && world.haste.ticksLeft[hasteIndex] > 0) {
      mask |= EntityStatusVisualMask.haste;
    }

    final vulnerableIndex = world.vulnerable.tryIndexOf(entity);
    if (vulnerableIndex != null &&
        world.vulnerable.ticksLeft[vulnerableIndex] > 0) {
      mask |= EntityStatusVisualMask.vulnerable;
    }

    final weakenIndex = world.weaken.tryIndexOf(entity);
    if (weakenIndex != null && world.weaken.ticksLeft[weakenIndex] > 0) {
      mask |= EntityStatusVisualMask.weaken;
    }

    final drenchIndex = world.drench.tryIndexOf(entity);
    if (drenchIndex != null && world.drench.ticksLeft[drenchIndex] > 0) {
      mask |= EntityStatusVisualMask.drench;
    }

    if (world.controlLock.isStunned(entity, tick)) {
      mask |= EntityStatusVisualMask.stun;
    }
    if (world.controlLock.isLocked(entity, LockFlag.cast, tick)) {
      mask |= EntityStatusVisualMask.silence;
    }

    return mask;
  }

  /// Appends projectile entity snapshots to [entities].
  ///
  /// Iterates the projectile component store and creates render snapshots
  /// with position, velocity, facing direction, and rotation angle.
  void _addProjectiles(
    List<EntityRenderSnapshot> entities, {
    required int tick,
  }) {
    final projectileStore = world.projectile;
    for (var pi = 0; pi < projectileStore.denseEntities.length; pi += 1) {
      final e = projectileStore.denseEntities[pi];
      if (!world.transform.has(e)) continue;
      final ti = world.transform.indexOf(e);

      final projectileId = projectileStore.projectileId[pi];
      Vec2? colliderSize;
      if (world.colliderAabb.has(e)) {
        final aabbi = world.colliderAabb.indexOf(e);
        colliderSize = Vec2(
          world.colliderAabb.halfX[aabbi] * 2,
          world.colliderAabb.halfY[aabbi] * 2,
        );
      }

      // Compute facing and rotation from direction vector.
      final dirX = projectileStore.dirX[pi];
      final dirY = projectileStore.dirY[pi];
      final facing = dirX >= 0 ? Facing.right : Facing.left;
      final rotationRad = atan2(dirY, dirX);

      entities.add(
        EntityRenderSnapshot(
          id: e,
          kind: EntityKind.projectile,
          pos: Vec2(world.transform.posX[ti], world.transform.posY[ti]),
          vel: Vec2(world.transform.velX[ti], world.transform.velY[ti]),
          size: colliderSize,
          projectileId: projectileId,
          facing: facing,
          rotationRad: rotationRad,
          anim: AnimKey.idle,
          grounded: false,
          animFrame: tick,
        ),
      );
    }
  }

  /// Appends active hitbox (melee strike) snapshots to [entities].
  ///
  /// Hitboxes are short-lived trigger volumes spawned by melee strikes.
  /// They render as debug overlays or strike effects.
  void _addHitboxes(List<EntityRenderSnapshot> entities, {required int tick}) {
    final hitboxes = world.hitbox;
    for (var hi = 0; hi < hitboxes.denseEntities.length; hi += 1) {
      final e = hitboxes.denseEntities[hi];
      if (!world.transform.has(e)) continue;
      final ti = world.transform.indexOf(e);

      // Hitbox size is stored as half-extents; double for full size.
      final size = Vec2(hitboxes.halfX[hi] * 2, hitboxes.halfY[hi] * 2);
      final dirX = hitboxes.dirX[hi];
      final dirY = hitboxes.dirY[hi];
      final facing = dirX >= 0 ? Facing.right : Facing.left;
      final rotationRad = atan2(dirY, dirX);

      entities.add(
        EntityRenderSnapshot(
          id: e,
          kind: EntityKind.trigger,
          pos: Vec2(world.transform.posX[ti], world.transform.posY[ti]),
          size: size,
          facing: facing,
          rotationRad: rotationRad,
          anim: AnimKey.hit,
          grounded: false,
          animFrame: tick,
        ),
      );
    }
  }

  /// Appends collectible (score pickup) snapshots to [entities].
  ///
  /// Collectibles are small pickups that grant score when collected.
  void _addCollectibles(
    List<EntityRenderSnapshot> entities, {
    required int tick,
  }) {
    final collectiblesStore = world.collectible;
    for (var ci = 0; ci < collectiblesStore.denseEntities.length; ci += 1) {
      final e = collectiblesStore.denseEntities[ci];
      if (!world.transform.has(e)) continue;
      final ti = world.transform.indexOf(e);

      // Size comes from AABB collider if present.
      Vec2? size;
      if (world.colliderAabb.has(e)) {
        final aabbi = world.colliderAabb.indexOf(e);
        size = Vec2(
          world.colliderAabb.halfX[aabbi] * 2,
          world.colliderAabb.halfY[aabbi] * 2,
        );
      }

      entities.add(
        EntityRenderSnapshot(
          id: e,
          kind: EntityKind.pickup,
          pos: Vec2(world.transform.posX[ti], world.transform.posY[ti]),
          size: size,
          facing: Facing.right,
          pickupVariant: PickupVariant.collectible,
          rotationRad: pi * 0.25, // 45° tilt for visual interest
          anim: AnimKey.idle,
          grounded: false,
          animFrame: tick,
        ),
      );
    }
  }

  /// Appends restoration item (health/mana/stamina orb) snapshots to [entities].
  ///
  /// Restoration items restore a specific resource when picked up.
  /// The [pickupVariant] field tells the renderer which sprite to use.
  void _addRestorationItems(
    List<EntityRenderSnapshot> entities, {
    required int tick,
  }) {
    final restorationStore = world.restorationItem;
    for (var ri = 0; ri < restorationStore.denseEntities.length; ri += 1) {
      final e = restorationStore.denseEntities[ri];
      if (!world.transform.has(e)) continue;
      final ti = world.transform.indexOf(e);

      Vec2? size;
      if (world.colliderAabb.has(e)) {
        final aabbi = world.colliderAabb.indexOf(e);
        size = Vec2(
          world.colliderAabb.halfX[aabbi] * 2,
          world.colliderAabb.halfY[aabbi] * 2,
        );
      }

      // Map restoration stat enum to pickup variant for rendering.
      final stat = restorationStore.stat[ri];
      int variant;
      switch (stat) {
        case RestorationStat.health:
          variant = PickupVariant.restorationHealth;
        case RestorationStat.mana:
          variant = PickupVariant.restorationMana;
        case RestorationStat.stamina:
          variant = PickupVariant.restorationStamina;
      }

      entities.add(
        EntityRenderSnapshot(
          id: e,
          kind: EntityKind.pickup,
          pos: Vec2(world.transform.posX[ti], world.transform.posY[ti]),
          size: size,
          facing: Facing.right,
          pickupVariant: variant,
          rotationRad: pi * 0.25,
          anim: AnimKey.idle,
          grounded: false,
          animFrame: tick,
        ),
      );
    }
  }

  /// Appends enemy entity snapshots to [entities].
  ///
  /// Enemies have position, velocity, facing direction, and grounded state.
  /// Animation is read from [AnimStateStore], pre-computed by [AnimSystem].
  void _addEnemies(List<EntityRenderSnapshot> entities, {required int tick}) {
    final enemies = world.enemy;
    final animStore = world.animState;

    for (var ei = 0; ei < enemies.denseEntities.length; ei += 1) {
      final e = enemies.denseEntities[ei];
      if (!world.transform.has(e)) continue;
      final ti = world.transform.indexOf(e);
      final enemyId = enemies.enemyId[ei];
      final enemyArchetype = enemyCatalog.get(enemyId);

      Vec2? size;
      if (world.colliderAabb.has(e)) {
        final aabbi = world.colliderAabb.indexOf(e);
        size = Vec2(
          world.colliderAabb.halfX[aabbi] * 2,
          world.colliderAabb.halfY[aabbi] * 2,
        );
      }

      final grounded = world.collision.has(e)
          ? world.collision.grounded[world.collision.indexOf(e)]
          : false;

      // Read pre-computed animation from AnimStateStore.
      final AnimKey anim;
      final int animFrame;
      if (animStore.has(e)) {
        final ai = animStore.indexOf(e);
        anim = animStore.anim[ai];
        animFrame = animStore.animFrame[ai];
      } else {
        // Fallback if no anim component (shouldn't happen).
        anim = AnimKey.idle;
        animFrame = tick;
      }

      entities.add(
        EntityRenderSnapshot(
          id: e,
          kind: EntityKind.enemy,
          pos: Vec2(world.transform.posX[ti], world.transform.posY[ti]),
          vel: Vec2(world.transform.velX[ti], world.transform.velY[ti]),
          size: size,
          enemyId: enemyId,
          facing: enemies.facing[ei],
          artFacingDir: enemyArchetype.artFacingDir,
          anim: anim,
          grounded: grounded,
          animFrame: animFrame,
          statusVisualMask: _statusVisualMaskForEntity(e, tick: tick),
        ),
      );
    }
  }
}

class _ChargeThresholds {
  const _ChargeThresholds({required this.halfTicks, required this.fullTicks});

  final int halfTicks;
  final int fullTicks;
}

class _HudChargePreview {
  const _HudChargePreview({
    required this.enabled,
    required this.halfTicks,
    required this.fullTicks,
    required this.active,
    required this.ticks,
    required this.tier,
  });

  const _HudChargePreview.disabled()
    : enabled = false,
      halfTicks = 0,
      fullTicks = 0,
      active = false,
      ticks = 0,
      tier = 0;

  final bool enabled;
  final int halfTicks;
  final int fullTicks;
  final bool active;
  final int ticks;
  final int tier;
}


===== FILE: lib/core/snapshots/camera_snapshot.dart =====
/// Immutable camera data exported by Core for renderer/UI consumption.
///
/// This snapshot describes camera framing in world units and is the preferred
/// camera contract over legacy scalar fields.
class CameraSnapshot {
  const CameraSnapshot({
    required this.centerX,
    required this.centerY,
    required this.viewWidth,
    required this.viewHeight,
  }) : assert(viewWidth > 0),
       assert(viewHeight > 0);

  /// Camera center in world coordinates.
  final double centerX;
  final double centerY;

  /// Viewport dimensions in world units.
  final double viewWidth;
  final double viewHeight;

  double get left => centerX - viewWidth * 0.5;
  double get right => centerX + viewWidth * 0.5;
  double get top => centerY - viewHeight * 0.5;
  double get bottom => centerY + viewHeight * 0.5;
}


===== FILE: lib/core/snapshots/entity_render_snapshot.dart =====
/// Renderer-facing entity data extracted from Core at the end of each tick.
///
/// This is a read-only, serializable view of entity state. It intentionally
/// hides internal ECS storage details and provides only what the renderer needs.
library;

import '../enemies/enemy_id.dart';
import '../util/vec2.dart';
import '../projectiles/projectile_id.dart';
import 'enums.dart';

/// Render-only snapshot of a single entity.
///
/// Created by [GameCore] after each simulation tick. Contains position,
/// animation state, and optional metadata for specialized rendering.
class EntityRenderSnapshot {
  const EntityRenderSnapshot({
    required this.id,
    required this.kind,
    required this.pos,
    required this.facing,
    required this.anim,
    required this.grounded,
    this.artFacingDir,
    this.vel,
    this.size,
    this.enemyId,
    this.projectileId,
    this.pickupVariant,
    this.z,
    this.rotationRad = 0.0,
    this.animFrame,
    this.statusVisualMask = EntityStatusVisualMask.none,
  });

  /// Stable entity identifier (protocol-stable).
  final int id;

  /// Broad entity classification for choosing visuals/behavior.
  final EntityKind kind;

  /// World position in virtual pixels.
  final Vec2 pos;

  /// Optional world velocity (useful for facing/animation).
  final Vec2? vel;

  /// Optional full extents in world units (virtual pixels).
  ///
  /// Render-only hint for placeholder shapes (e.g. projectile rectangles).
  final Vec2? size;

  /// Optional enemy archetype id (set when [kind] is [EntityKind.enemy]).
  final EnemyId? enemyId;

  /// Optional projectile archetype id (set when [kind] is [EntityKind.projectile]).
  final ProjectileId? projectileId;

  /// Optional pickup variant for render-only pickup styling.
  final int? pickupVariant;

  /// Optional sort key for render ordering.
  final double? z;

  /// Optional rotation (radians) for rendering orientation.
  final double rotationRad;

  /// Facing direction for choosing sprites/poses.
  final Facing facing;

  /// Direction the authored art faces when not mirrored.
  ///
  /// When null, render should assume `Facing.right`.
  final Facing? artFacingDir;

  /// Whether the entity is grounded at the end of the tick.
  ///
  /// This is authoritative collision state from Core (do not infer from anim).
  final bool grounded;

  /// Logical animation selection (renderer maps to assets).
  final AnimKey anim;

  /// Optional frame hint for deterministic animation in replays/networking.
  final int? animFrame;

  /// Bitmask of always-on status visuals for this entity.
  final int statusVisualMask;
}

/// Bitmask flags for persistent status visuals.
abstract class EntityStatusVisualMask {
  static const int none = 0;
  static const int slow = 1 << 0;
  static const int haste = 1 << 1;
  static const int vulnerable = 1 << 2;
  static const int weaken = 1 << 3;
  static const int drench = 1 << 4;
  static const int stun = 1 << 5;
  static const int silence = 1 << 6;
}

/// Variant codes for pickup rendering.
///
/// Maps to visual styles (colors, icons) in the renderer.
abstract class PickupVariant {
  static const int collectible = 0;
  static const int restorationHealth = 1;
  static const int restorationMana = 2;
  static const int restorationStamina = 3;
}


===== FILE: lib/core/snapshots/enums.dart =====
/// Protocol-stable enums used by snapshots and the Core→Renderer contract.
///
/// **Stability**: These enums may become part of the network protocol for
/// replays or multiplayer. Avoid renaming or reordering values.
///
/// **Scope**: These are "logical" game concepts, not tied to specific
/// textures or asset names. The renderer maps them to visuals.
library;

/// Logical animation state for entity rendering.
///
/// The renderer maps these to sprite sheets or animation clips.
enum AnimKey {
  idle,
  stun,
  run,
  jump,
  fall,
  hit,
  cast,
  death,
  spawn,
  strike,
  dash,
  walk,
  backStrike,
  parry,
  ranged,
  roll,
  shieldBash,
  shieldBlock,
}

/// Broad entity classification for rendering and (future) networking.
///
/// Used to select visual style, collision layer, and render order.
enum EntityKind { player, enemy, projectile, obstacle, pickup, hazard, trigger }

/// Horizontal facing direction for sprites and directional abilities.
enum Facing { left, right }

/// Input interaction mode for an ability slot.
enum AbilityInputMode {
  /// Instant commit on press.
  tap,

  /// Hold to aim, commit on release.
  holdAimRelease,

  /// Hold button down to maintain; release to end.
  holdMaintain,

  /// Hold button down, commit on release (no directional aim gesture).
  holdRelease,
}


===== FILE: lib/core/snapshots/game_state_snapshot.dart =====
/// Immutable snapshot of game state for rendering and UI.
///
/// Built by [GameCore] after each fixed simulation tick. This is the primary
/// contract between Core and the Flame/Flutter layer—treat as read-only.
library;

import '../levels/level_id.dart';
import 'camera_snapshot.dart';
import 'entity_render_snapshot.dart';
import 'enums.dart';
import 'ground_surface_snapshot.dart';
import 'player_hud_snapshot.dart';
import 'static_solid_snapshot.dart';

/// Complete game state snapshot at a specific simulation tick.
///
/// Contains everything the renderer and UI need: camera position, HUD data,
/// entity list, and static geometry.
class GameStateSnapshot {
  const GameStateSnapshot({
    required this.tick,
    required this.runId,
    required this.seed,
    required this.levelId,
    required this.themeId,
    required this.distance,
    required this.paused,
    required this.gameOver,
    required this.camera,
    required this.hud,
    required this.entities,
    required this.staticSolids,
    required this.groundSurfaces,
  });

  /// Current simulation tick.
  final int tick;

  /// Unique identifier for this run session.
  final int runId;

  /// Seed used for deterministic generation/RNG.
  final int seed;

  /// Level identifier for this run (stable across sessions).
  final LevelId levelId;

  /// Optional render theme identifier for this run.
  ///
  /// This is Core-owned metadata (pure data) that the renderer can map to
  /// asset paths and visuals without importing any Core gameplay logic.
  final String? themeId;

  /// Distance progressed in the run.
  final double distance;

  /// Whether the simulation is currently paused.
  final bool paused;

  /// Whether the run has ended (simulation is frozen).
  final bool gameOver;

  /// Camera snapshot used for rendering this frame.
  final CameraSnapshot camera;

  /// HUD-only player stats.
  final PlayerHudSnapshot hud;

  /// Render-only entity list for the current tick.
  final List<EntityRenderSnapshot> entities;

  /// Render-only static collision geometry (platforms/obstacles) for this run.
  final List<StaticSolidSnapshot> staticSolids;

  /// Render-only walkable ground surfaces for this run.
  final List<GroundSurfaceSnapshot> groundSurfaces;

  /// Returns the player entity snapshot, or `null` if not found.
  ///
  /// Convenience getter to avoid duplicating player-lookup logic across
  /// rendering components.
  EntityRenderSnapshot? get playerEntity {
    for (final e in entities) {
      if (e.kind == EntityKind.player) return e;
    }
    return null;
  }
}


===== FILE: lib/core/snapshots/ground_surface_snapshot.dart =====
/// Renderer-facing snapshot for one walkable ground surface span.
///
/// This is a read-only projection of Core-authored geometry. The authoritative
/// collision model remains in `StaticWorldGeometryIndex`.
class GroundSurfaceSnapshot {
  const GroundSurfaceSnapshot({
    required this.minX,
    required this.maxX,
    required this.topY,
    required this.chunkIndex,
    required this.localSegmentIndex,
  }) : assert(maxX >= minX);

  /// Left world-space bound of the walkable span.
  final double minX;

  /// Right world-space bound of the walkable span.
  final double maxX;

  /// World-space Y of the walkable top surface.
  final double topY;

  /// Owning streamed chunk index, or `StaticSolid.groundChunk` for base ground.
  final int chunkIndex;

  /// Stable local index within the source chunk/list.
  final int localSegmentIndex;
}


===== FILE: lib/core/snapshots/player_hud_snapshot.dart =====
/// HUD-only player data extracted from Core.
///
/// Separated from entity snapshots so the UI can render player stats
/// (HP bars, cooldowns, etc.) without scanning all entities.
library;

import 'enums.dart';

class PlayerHudSnapshot {
  const PlayerHudSnapshot({
    required this.hp,
    required this.hpMax,
    required this.mana,
    required this.manaMax,
    required this.stamina,
    required this.staminaMax,
    required this.meleeSlotValid,
    required this.secondarySlotValid,
    required this.projectileSlotValid,
    required this.mobilitySlotValid,
    required this.spellSlotValid,
    required this.jumpSlotValid,
    required this.canAffordJump,
    required this.canAffordMobility,
    required this.canAffordMelee,
    required this.canAffordSecondary,
    required this.canAffordProjectile,
    required this.canAffordSpell,
    required this.cooldownTicksLeft,
    required this.cooldownTicksTotal,
    required this.meleeInputMode,
    required this.secondaryInputMode,
    required this.projectileInputMode,
    required this.mobilityInputMode,
    required this.chargeEnabled,
    required this.chargeHalfTicks,
    required this.chargeFullTicks,
    required this.chargeActive,
    required this.chargeTicks,
    required this.chargeTier,
    required this.lastDamageTick,
    required this.collectibles,
    required this.collectibleScore,
  });

  /// Current health.
  final double hp;

  /// Maximum health.
  final double hpMax;

  /// Current mana (resource for spells).
  final double mana;

  /// Maximum mana.
  final double manaMax;

  /// Current stamina (resource for physical actions like jump/dash).
  final double stamina;

  /// Maximum stamina.
  final double staminaMax;

  /// Whether the primary slot ability is valid for the current loadout.
  final bool meleeSlotValid;

  /// Whether the secondary slot ability is valid for the current loadout.
  final bool secondarySlotValid;

  /// Whether the projectile slot ability is valid for the current loadout.
  final bool projectileSlotValid;

  /// Whether the mobility slot ability is valid for the current loadout.
  final bool mobilitySlotValid;

  /// Whether the spell slot ability is valid for the current loadout.
  final bool spellSlotValid;

  /// Whether the jump slot ability is valid for the current loadout.
  final bool jumpSlotValid;

  /// Whether stamina is sufficient for jumping.
  final bool canAffordJump;

  /// Whether stamina is sufficient for the equipped mobility ability.
  final bool canAffordMobility;

  /// Whether stamina is sufficient for melee.
  final bool canAffordMelee;

  /// Whether resources are sufficient for the equipped secondary/off-hand ability.
  final bool canAffordSecondary;

  /// Whether resources are sufficient for the equipped projectile ability.
  final bool canAffordProjectile;

  /// Whether resources are sufficient for the equipped spell slot ability.
  final bool canAffordSpell;

  /// Remaining cooldown ticks for each CooldownGroup.
  final List<int> cooldownTicksLeft;

  /// Total cooldown ticks for each CooldownGroup.
  final List<int> cooldownTicksTotal;

  /// Input interaction mode for melee slot.
  final AbilityInputMode meleeInputMode;

  /// Input interaction mode for secondary slot.
  final AbilityInputMode secondaryInputMode;

  /// Input interaction mode for projectile slot.
  final AbilityInputMode projectileInputMode;

  /// Input interaction mode for mobility slot.
  final AbilityInputMode mobilityInputMode;

  /// Whether at least one equipped slot supports tiered charge.
  final bool chargeEnabled;

  /// Charge hold threshold for half tier (runtime ticks).
  final int chargeHalfTicks;

  /// Charge hold threshold for full tier (runtime ticks).
  final int chargeFullTicks;

  /// Whether a charge hold is currently active in Core state.
  final bool chargeActive;

  /// Current hold duration in runtime ticks for the active charge slot.
  final int chargeTicks;

  /// Current charge tier bucket from Core (0/1/2).
  final int chargeTier;

  /// Tick when this player most recently took non-zero damage (-1 if never).
  final int lastDamageTick;

  /// Collected collectibles.
  final int collectibles;

  /// Score value earned from collectibles.
  final int collectibleScore;
}


===== FILE: lib/core/snapshots/static_solid_snapshot.dart =====
/// Renderer-facing snapshot for one piece of static collision geometry.
///
/// This is a read-only view for rendering/debug overlays. Authoritative
/// collision still lives in Core using `StaticWorldGeometry`.
class StaticSolidSnapshot {
  const StaticSolidSnapshot({
    required this.minX,
    required this.minY,
    required this.maxX,
    required this.maxY,
    required this.sides,
    required this.oneWayTop,
  });

  final double minX;
  final double minY;
  final double maxX;
  final double maxY;

  /// Bitmask of enabled faces.
  final int sides;

  /// Whether the top face behaves as one-way (platform).
  final bool oneWayTop;
}



===== FILE: lib/core/spawn_service.dart =====
/// Entity spawning service for GameCore.
///
/// Centralizes all entity creation logic (enemies, collectibles, restoration
/// items) with deterministic placement algorithms. Determinism is critical
/// for replay consistency—given the same seed and chunk index, the same
/// entities spawn at the same positions.
///
/// ## Architecture
///
/// [SpawnService] is owned by [GameCore] and called during:
/// - **Enemy spawning**: When the spawn horizon advances, enemies are placed
///   at fixed X offsets ahead of the camera.
/// - **Chunk generation**: When [TrackManager] streams new chunks,
///   collectibles and restoration items are procedurally scattered.
///
/// ## Determinism Strategy
///
/// All RNG operations use [seedFrom] and [nextUint32] from the deterministic
/// RNG module. Each spawn type uses a unique salt (e.g., `0xC011EC7` for
/// collectibles) XOR'd with the chunk index to ensure:
/// - Same seed + chunk → same spawn pattern
/// - Different chunks → independent sequences
/// - Different spawn types → no correlation
///
/// ## Placement Algorithm
///
/// For collectibles and restoration items:
/// 1. Compute valid X range (chunk bounds minus edge margins).
/// 2. Generate random X, snap to grid.
/// 3. Query the [SurfaceGraph] for the highest platform at that X.
/// 4. Place item above the surface with clearance.
/// 5. Reject if overlapping solids or existing entities.
/// 6. Retry up to `maxAttempts` times.
library;

import 'abilities/ability_def.dart';
import 'ecs/entity_id.dart';
import 'ecs/entity_factory.dart';
import 'ecs/hit/aabb_hit_utils.dart';
import 'ecs/stores/body_store.dart';
import 'ecs/stores/collider_aabb_store.dart';
import 'ecs/stores/collectible_store.dart';
import 'ecs/stores/restoration_item_store.dart';
import 'ecs/world.dart';
import 'enemies/enemy_catalog.dart';
import 'enemies/enemy_id.dart';
import 'navigation/types/nav_tolerances.dart';
import 'navigation/types/surface_graph.dart';
import 'navigation/utils/surface_spatial_index.dart';
import 'snapshots/enums.dart';
import 'tuning/collectible_tuning.dart';
import 'tuning/flying_enemy_tuning.dart';
import 'players/player_tuning.dart';
import 'tuning/restoration_item_tuning.dart';
import 'tuning/track_tuning.dart';
import 'util/deterministic_rng.dart';

// ─────────────────────────────────────────────────────────────────────────────
// RNG Salt Constants
// ─────────────────────────────────────────────────────────────────────────────

/// RNG salt for collectible spawn positions ("COLLECT" in hex-speak).
const int _collectibleSalt = 0xC011EC7;

/// RNG salt for restoration item spawn phase offset ("ALTESAT" - alternate stat).
const int _restorationPhaseSalt = 0xA17E5A7;

/// RNG salt for restoration item spawn positions ("ASTALL" - a stall/restore).
const int _restorationSpawnSalt = 0xA57A11;

// ─────────────────────────────────────────────────────────────────────────────
// SpawnService
// ─────────────────────────────────────────────────────────────────────────────

/// Service for spawning game entities with deterministic, seeded placement.
///
/// Handles creation of:
/// - **Flying enemies**: Hover above ground, cast projectiles.
/// - **Ground enemies**: Walk on platforms, chase player.
/// - **Collectibles**: Score pickups scattered across chunks.
/// - **Restoration items**: Health/mana/stamina orbs on periodic chunks.
///
/// Usage:
/// ```dart
/// final spawner = SpawnService(world: ..., seed: 42, ...);
/// spawner.setSurfaceGraph(graph: navGraph, spatialIndex: index);
/// spawner.spawnUnocoDemon(spawnX: 500, groundTopY: 0);
/// spawner.spawnCollectiblesForChunk(chunkIndex: 3, ...);
/// ```
class SpawnService {
  /// Creates a spawn service with the given dependencies.
  ///
  /// - [world]: ECS world for entity creation and component access.
  /// - [entityFactory]: Factory for creating complex entities (enemies).
  /// - [enemyCatalog]: Archetype definitions for enemy types.
  /// - [unocoDemonTuning]: Flying enemy hover offset and cooldowns.
  /// - [movement]: Movement tuning for ground enemy velocity limits.
  /// - [collectibleTuning]: Spawn density, spacing, and margins.
  /// - [restorationItemTuning]: Spawn frequency and item sizing.
  /// - [trackTuning]: Chunk dimensions and grid snap settings.
  /// - [seed]: Master RNG seed for deterministic spawning.
  SpawnService({
    required EcsWorld world,
    required EntityFactory entityFactory,
    required EnemyCatalog enemyCatalog,
    required UnocoDemonTuningDerived unocoDemonTuning,
    required MovementTuningDerived movement,
    required CollectibleTuning collectibleTuning,
    required RestorationItemTuning restorationItemTuning,
    required TrackTuning trackTuning,
    required int seed,
  }) : _world = world,
       _entityFactory = entityFactory,
       _enemyCatalog = enemyCatalog,
       _unocoDemonTuning = unocoDemonTuning,
       _movement = movement,
       _collectibleTuning = collectibleTuning,
       _restorationItemTuning = restorationItemTuning,
       _trackTuning = trackTuning,
       _seed = seed;

  // ─── Dependencies ───
  final EcsWorld _world;
  final EntityFactory _entityFactory;
  final EnemyCatalog _enemyCatalog;
  final UnocoDemonTuningDerived _unocoDemonTuning;
  final MovementTuningDerived _movement;
  final CollectibleTuning _collectibleTuning;
  final RestorationItemTuning _restorationItemTuning;
  final TrackTuning _trackTuning;
  final int _seed;

  // ─── Scratch buffers (reused to avoid allocation) ───

  /// X positions of collectibles spawned in the current chunk (for spacing).
  final List<double> _collectibleSpawnXs = <double>[];

  /// Surface indices returned by spatial queries.
  final List<int> _surfaceQueryCandidates = <int>[];

  // ─── Surface graph state (updated by TrackManager) ───
  SurfaceGraph? _surfaceGraph;
  SurfaceSpatialIndex? _surfaceSpatialIndex;
  double _surfaceMinY = 0.0;
  double _surfaceMaxY = 0.0;

  // ───────────────────────────────────────────────────────────────────────────
  // Surface Graph Management
  // ───────────────────────────────────────────────────────────────────────────

  /// Updates the navigation surface graph for item placement queries.
  ///
  /// Called by [TrackManager] whenever the track geometry changes.
  /// The surface graph provides platform positions for placing items
  /// "on top of" surfaces rather than floating in mid-air.
  ///
  /// Also caches the Y-axis bounds for efficient spatial queries.
  void setSurfaceGraph({
    required SurfaceGraph? graph,
    required SurfaceSpatialIndex? spatialIndex,
  }) {
    _surfaceGraph = graph;
    _surfaceSpatialIndex = spatialIndex;
    _surfaceMinY = 0.0;
    _surfaceMaxY = 0.0;

    // Pre-compute Y bounds to avoid repeated iteration during queries.
    if (graph != null && graph.surfaces.isNotEmpty) {
      var minY = graph.surfaces.first.yTop;
      var maxY = minY;
      for (var i = 1; i < graph.surfaces.length; i += 1) {
        final y = graph.surfaces[i].yTop;
        if (y < minY) minY = y;
        if (y > maxY) maxY = y;
      }
      _surfaceMinY = minY;
      _surfaceMaxY = maxY;
    }
  }

  // ───────────────────────────────────────────────────────────────────────────
  // Enemy Spawning
  // ───────────────────────────────────────────────────────────────────────────

  /// Spawns the Unoco Demon at [spawnX], hovering above [groundTopY].
  ///
  /// Flying enemies are placed at a fixed vertical offset above the ground
  /// (defined by [UnocoDemonTuning.unocoDemonHoverOffsetY]). They don't
  /// use gravity and will begin AI behavior on the next tick.
  ///
  /// The enemy's cast cooldown is pre-set to avoid immediate projectile
  /// spam on the spawn tick—this keeps early-game pacing predictable.
  ///
  /// Returns the [EntityId] of the newly created enemy.
  EntityId spawnUnocoDemon({
    required double spawnX,
    required double groundTopY,
  }) {
    final archetype = _enemyCatalog.get(EnemyId.unocoDemon);
    final unocoDemon = _entityFactory.createEnemy(
      enemyId: EnemyId.unocoDemon,
      posX: spawnX,
      posY: groundTopY - _unocoDemonTuning.base.unocoDemonHoverOffsetY,
      velX: 0.0,
      velY: 0.0,
      facing: Facing.left,
      body: archetype.body,
      collider: archetype.collider,
      health: archetype.health,
      mana: archetype.mana,
      stamina: archetype.stamina,
      tags: archetype.tags,
      resistance: archetype.resistance,
      statusImmunity: archetype.statusImmunity,
    );

    // Pre-set cooldown to prevent immediate casting on spawn tick.
    // This ensures consistent early-game difficulty across runs.
    _world.cooldown.setTicksLeft(
      unocoDemon,
      CooldownGroup.projectile,
      _unocoDemonTuning.unocoDemonCastCooldownTicks,
    );

    return unocoDemon;
  }

  /// Spawns a ground enemy at [spawnX], standing on [groundTopY].
  ///
  /// Ground enemies use gravity and collision. Their Y position is
  /// computed so their collider's bottom edge rests on the ground surface.
  ///
  /// The enemy inherits movement velocity limits from [MovementTuning]
  /// to ensure consistent chase behavior relative to player speed.
  ///
  /// Returns the [EntityId] of the newly created enemy.
  EntityId spawnGroundEnemy({
    required double spawnX,
    required double groundTopY,
  }) {
    final archetype = _enemyCatalog.get(EnemyId.grojib);

    // Position so collider bottom touches ground.
    return _entityFactory.createEnemy(
      enemyId: EnemyId.grojib,
      posX: spawnX,
      posY:
          groundTopY - (archetype.collider.offsetY + archetype.collider.halfY),
      velX: 0.0,
      velY: 0.0,
      facing: Facing.left,
      body: BodyDef(
        enabled: archetype.body.enabled,
        isKinematic: archetype.body.isKinematic,
        useGravity: archetype.body.useGravity,
        ignoreCeilings: archetype.body.ignoreCeilings,
        topOnlyGround: archetype.body.topOnlyGround,
        gravityScale: archetype.body.gravityScale,
        maxVelX: _movement.base.maxVelX,
        maxVelY: _movement.base.maxVelY,
        sideMask: archetype.body.sideMask,
      ),
      collider: archetype.collider,
      health: archetype.health,
      mana: archetype.mana,
      stamina: archetype.stamina,
      tags: archetype.tags,
      resistance: archetype.resistance,
      statusImmunity: archetype.statusImmunity,
    );
  }

  // ───────────────────────────────────────────────────────────────────────────
  // Collectible & Restoration Item Spawning
  // ───────────────────────────────────────────────────────────────────────────

  /// Spawns a single collectible at the given world position.
  ///
  /// Collectibles are stationary pickups that grant score when touched.
  /// They have an AABB collider for overlap detection but no physics body.
  ///
  /// Prefer [spawnCollectiblesForChunk] for procedural placement.
  EntityId spawnCollectibleAt(double x, double y) {
    final half = _collectibleTuning.collectibleSize * 0.5;
    final entity = _world.createEntity();
    _world.transform.add(entity, posX: x, posY: y, velX: 0.0, velY: 0.0);
    _world.colliderAabb.add(entity, ColliderAabbDef(halfX: half, halfY: half));
    _world.collectible.add(
      entity,
      CollectibleDef(value: _collectibleTuning.valuePerCollectible),
    );
    return entity;
  }

  /// Spawns a restoration item at the given world position.
  ///
  /// Restoration items restore the specified [stat] (health, mana, or
  /// stamina) when collected. Like collectibles, they're stationary with
  /// an AABB collider.
  ///
  /// Prefer [spawnRestorationItemForChunk] for procedural placement.
  EntityId spawnRestorationItemAt(double x, double y, RestorationStat stat) {
    final half = _restorationItemTuning.itemSize * 0.5;
    final entity = _world.createEntity();
    _world.transform.add(entity, posX: x, posY: y, velX: 0.0, velY: 0.0);
    _world.colliderAabb.add(entity, ColliderAabbDef(halfX: half, halfY: half));
    _world.restorationItem.add(entity, RestorationItemDef(stat: stat));
    return entity;
  }

  /// Spawns collectibles for a track chunk using deterministic placement.
  ///
  /// This method:
  /// 1. Skips if collectibles are disabled or chunk is too early.
  /// 2. Determines spawn count from RNG (between min and max per chunk).
  /// 3. For each collectible, picks a random X within chunk bounds.
  /// 4. Snaps X to grid and enforces minimum spacing between items.
  /// 5. Queries the highest surface at that X for vertical placement.
  /// 6. Rejects positions overlapping platforms or existing items.
  ///
  /// The RNG is seeded with `seed XOR chunkIndex XOR 0xC011EC7` to ensure
  /// deterministic but unique sequences per chunk.
  void spawnCollectiblesForChunk({
    required int chunkIndex,
    required double chunkStartX,
    required List<StaticSolid> solids,
  }) {
    final tuning = _collectibleTuning;

    // ─── Early-out checks ───
    if (!tuning.enabled) return;
    if (chunkIndex < tuning.spawnStartChunkIndex) return;
    if (tuning.maxPerChunk <= 0) return;

    final graph = _surfaceGraph;
    final spatialIndex = _surfaceSpatialIndex;
    if (graph == null || spatialIndex == null || graph.surfaces.isEmpty) {
      return;
    }

    // ─── Compute valid X range ───
    final minX = chunkStartX + tuning.chunkEdgeMarginX;
    final maxX =
        chunkStartX + _trackTuning.chunkWidth - tuning.chunkEdgeMarginX;
    if (maxX <= minX) return;

    // ─── Initialize RNG and determine target count ───
    var rngState = seedFrom(_seed, chunkIndex ^ _collectibleSalt);
    rngState = nextUint32(rngState);
    final countRange = tuning.maxPerChunk - tuning.minPerChunk + 1;
    final targetCount = tuning.minPerChunk + (rngState % countRange);
    if (targetCount <= 0) return;

    // ─── Spawn loop with rejection sampling ───
    _collectibleSpawnXs.clear();
    final halfSize = tuning.collectibleSize * 0.5;
    final maxAttempts = tuning.maxAttemptsPerChunk;

    for (
      var attempt = 0;
      attempt < maxAttempts && _collectibleSpawnXs.length < targetCount;
      attempt += 1
    ) {
      // Generate candidate X position.
      rngState = nextUint32(rngState);
      var x = rangeDouble(rngState, minX, maxX);
      x = _snapToGrid(x, _trackTuning.gridSnap);
      if (x < minX || x > maxX) continue;

      // Enforce minimum spacing from already-spawned collectibles.
      if (tuning.minSpacingX > 0.0) {
        var spaced = true;
        for (final prevX in _collectibleSpawnXs) {
          if ((prevX - x).abs() < tuning.minSpacingX) {
            spaced = false;
            break;
          }
        }
        if (!spaced) continue;
      }

      // Find surface Y and compute item center position.
      final surfaceY = _highestSurfaceYAtX(x);
      if (surfaceY == null) continue;
      final centerY = surfaceY - tuning.surfaceClearanceY - halfSize;

      // Reject if overlapping static geometry.
      if (_overlapsAnySolid(
        centerX: x,
        centerY: centerY,
        halfSize: halfSize,
        margin: tuning.noSpawnMargin,
        solids: solids,
      )) {
        continue;
      }

      // Success—spawn and record position.
      spawnCollectibleAt(x, centerY);
      _collectibleSpawnXs.add(x);
    }
  }

  /// Spawns a restoration item for a chunk if eligible.
  ///
  /// Restoration items spawn on a periodic schedule (e.g., every N chunks)
  /// with a phase offset derived from the seed to avoid predictable timing.
  ///
  /// The item type is determined by [lowestResourceStat], which should
  /// return the player's most depleted resource (health, mana, or stamina).
  ///
  /// Placement follows the same rejection-sampling algorithm as collectibles,
  /// with an additional check to avoid overlapping existing collectibles.
  void spawnRestorationItemForChunk({
    required int chunkIndex,
    required double chunkStartX,
    required List<StaticSolid> solids,
    required RestorationStat Function() lowestResourceStat,
  }) {
    final tuning = _restorationItemTuning;

    // ─── Early-out checks ───
    if (!tuning.enabled) return;
    if (chunkIndex < tuning.spawnStartChunkIndex) return;
    if (tuning.spawnEveryChunks <= 0) return;

    // ─── Periodic spawn check (with seeded phase offset) ───
    final phase =
        seedFrom(_seed, _restorationPhaseSalt) % tuning.spawnEveryChunks;
    if ((chunkIndex - phase) % tuning.spawnEveryChunks != 0) return;

    final graph = _surfaceGraph;
    final spatialIndex = _surfaceSpatialIndex;
    if (graph == null || spatialIndex == null || graph.surfaces.isEmpty) {
      return;
    }

    // ─── Compute valid X range ───
    final minX = chunkStartX + tuning.chunkEdgeMarginX;
    final maxX =
        chunkStartX + _trackTuning.chunkWidth - tuning.chunkEdgeMarginX;
    if (maxX <= minX) return;

    // ─── Determine which stat to restore ───
    final stat = lowestResourceStat();

    // ─── Spawn with rejection sampling ───
    var rngState = seedFrom(_seed, chunkIndex ^ _restorationSpawnSalt);
    final halfSize = tuning.itemSize * 0.5;

    for (var attempt = 0; attempt < tuning.maxAttemptsPerSpawn; attempt += 1) {
      rngState = nextUint32(rngState);
      var x = rangeDouble(rngState, minX, maxX);
      x = _snapToGrid(x, _trackTuning.gridSnap);
      if (x < minX || x > maxX) continue;

      final surfaceY = _highestSurfaceYAtX(x);
      if (surfaceY == null) continue;
      final centerY = surfaceY - tuning.surfaceClearanceY - halfSize;

      // Reject if overlapping static geometry.
      if (_overlapsAnySolid(
        centerX: x,
        centerY: centerY,
        halfSize: halfSize,
        margin: tuning.noSpawnMargin,
        solids: solids,
      )) {
        continue;
      }

      // Reject if overlapping existing collectibles.
      if (_overlapsAnyCollectible(
        centerX: x,
        centerY: centerY,
        halfSize: halfSize,
        margin: tuning.noSpawnMargin,
      )) {
        continue;
      }

      // Success—spawn and exit.
      spawnRestorationItemAt(x, centerY, stat);
      return;
    }
  }

  // ───────────────────────────────────────────────────────────────────────────
  // Private Helpers
  // ───────────────────────────────────────────────────────────────────────────

  /// Snaps [x] to the nearest multiple of [grid].
  ///
  /// Grid snapping ensures items align visually with the track's tile grid,
  /// avoiding sub-pixel positioning artifacts.
  double _snapToGrid(double x, double grid) {
    if (grid <= 0) return x;
    return (x / grid).roundToDouble() * grid;
  }

  /// Returns the Y coordinate of the highest surface at [x], or null if none.
  ///
  /// Uses the [SurfaceSpatialIndex] for efficient lookup, then filters
  /// candidates to find the topmost platform. Ties are broken by surface ID
  /// for determinism.
  double? _highestSurfaceYAtX(double x) {
    final graph = _surfaceGraph;
    final spatialIndex = _surfaceSpatialIndex;
    if (graph == null || spatialIndex == null || graph.surfaces.isEmpty) {
      return null;
    }

    // Query all surfaces that might contain X.
    final minY = _surfaceMinY - navSpatialEps;
    final maxY = _surfaceMaxY + navSpatialEps;
    _surfaceQueryCandidates.clear();
    spatialIndex.queryAabb(
      minX: x - navSpatialEps,
      minY: minY,
      maxX: x + navSpatialEps,
      maxY: maxY,
      outSurfaceIndices: _surfaceQueryCandidates,
    );

    // Find highest (smallest Y in screen coords) surface containing X.
    double? bestY;
    int? bestId;
    for (final i in _surfaceQueryCandidates) {
      final s = graph.surfaces[i];
      if (x < s.xMin - navGeomEps || x > s.xMax + navGeomEps) continue;

      // Prefer lower Y (higher on screen). Break ties by ID for determinism.
      if (bestY == null || s.yTop < bestY - navTieEps) {
        bestY = s.yTop;
        bestId = s.id;
      } else if ((s.yTop - bestY).abs() <= navTieEps && s.id < bestId!) {
        bestY = s.yTop;
        bestId = s.id;
      }
    }

    return bestY;
  }

  /// Checks if an AABB centered at ([centerX], [centerY]) overlaps any solid.
  ///
  /// The AABB is expanded by [margin] to prevent items from spawning too
  /// close to platform edges.
  bool _overlapsAnySolid({
    required double centerX,
    required double centerY,
    required double halfSize,
    required double margin,
    required List<StaticSolid> solids,
  }) {
    if (solids.isEmpty) return false;

    // Expand bounds by half-size and margin.
    final minX = centerX - halfSize - margin;
    final maxX = centerX + halfSize + margin;
    final minY = centerY - halfSize - margin;
    final maxY = centerY + halfSize + margin;

    for (final solid in solids) {
      final overlaps = aabbOverlapsMinMax(
        aMinX: minX,
        aMaxX: maxX,
        aMinY: minY,
        aMaxY: maxY,
        bMinX: solid.minX,
        bMaxX: solid.maxX,
        bMinY: solid.minY,
        bMaxY: solid.maxY,
      );
      if (overlaps) return true;
    }
    return false;
  }

  /// Checks if an AABB overlaps any existing collectible entity.
  ///
  /// Used by restoration item spawning to avoid stacking pickups.
  bool _overlapsAnyCollectible({
    required double centerX,
    required double centerY,
    required double halfSize,
    required double margin,
  }) {
    final collectibles = _world.collectible;
    if (collectibles.denseEntities.isEmpty) return false;

    final minX = centerX - halfSize - margin;
    final maxX = centerX + halfSize + margin;
    final minY = centerY - halfSize - margin;
    final maxY = centerY + halfSize + margin;

    for (var ci = 0; ci < collectibles.denseEntities.length; ci += 1) {
      final e = collectibles.denseEntities[ci];
      if (!(_world.transform.has(e) && _world.colliderAabb.has(e))) continue;

      // Read collectible's world-space AABB.
      final ti = _world.transform.indexOf(e);
      final ai = _world.colliderAabb.indexOf(e);
      final cx = _world.transform.posX[ti] + _world.colliderAabb.offsetX[ai];
      final cy = _world.transform.posY[ti] + _world.colliderAabb.offsetY[ai];

      final overlaps = aabbOverlapsMinMax(
        aMinX: minX,
        aMaxX: maxX,
        aMinY: minY,
        aMaxY: maxY,
        bMinX: cx - _world.colliderAabb.halfX[ai],
        bMaxX: cx + _world.colliderAabb.halfX[ai],
        bMinY: cy - _world.colliderAabb.halfY[ai],
        bMaxY: cy + _world.colliderAabb.halfY[ai],
      );
      if (overlaps) return true;
    }

    return false;
  }
}

// ─────────────────────────────────────────────────────────────────────────────
// Supporting Types
// ─────────────────────────────────────────────────────────────────────────────

/// Axis-aligned bounding box for static world geometry.
///
/// Used by [SpawnService] for overlap rejection during item placement.
/// Re-exported here to avoid circular imports with collision module.
typedef StaticSolid = ({double minX, double maxX, double minY, double maxY});


===== FILE: lib/core/spellBook/spell_book_catalog.dart =====
import '../abilities/ability_def.dart' show AbilityKey;
import '../stats/gear_stat_bonuses.dart';
import '../projectiles/projectile_id.dart';
import 'spell_book_def.dart';
import 'spell_book_id.dart';

/// Lookup table for spell books.
class SpellBookCatalog {
  const SpellBookCatalog();

  static const List<ProjectileId> _basicProjectileSpells = <ProjectileId>[
    ProjectileId.fireBolt,
    ProjectileId.acidBolt,
    ProjectileId.darkBolt,
    ProjectileId.earthBolt,
    ProjectileId.holyBolt,
    ProjectileId.waterBolt,
  ];

  static const List<ProjectileId> _solidProjectileSpells = <ProjectileId>[
    ProjectileId.iceBolt,
    ProjectileId.fireBolt,
    ProjectileId.acidBolt,
    ProjectileId.darkBolt,
    ProjectileId.earthBolt,
    ProjectileId.holyBolt,
    ProjectileId.waterBolt,
    ProjectileId.thunderBolt,
  ];

  static const List<ProjectileId> _allProjectileSpells = <ProjectileId>[
    ProjectileId.iceBolt,
    ProjectileId.fireBolt,
    ProjectileId.acidBolt,
    ProjectileId.darkBolt,
    ProjectileId.earthBolt,
    ProjectileId.holyBolt,
    ProjectileId.waterBolt,
    ProjectileId.thunderBolt,
  ];

  static const List<AbilityKey> _basicSpellSlotAbilities = <AbilityKey>[
    'eloise.arcane_haste',
  ];

  static const List<AbilityKey> _solidSpellSlotAbilities = <AbilityKey>[
    'eloise.arcane_haste',
    'eloise.vital_surge',
    'eloise.mana_infusion',
    'eloise.second_wind',
  ];

  static const List<AbilityKey> _allSpellSlotAbilities = <AbilityKey>[
    'eloise.arcane_haste',
    'eloise.vital_surge',
    'eloise.mana_infusion',
    'eloise.second_wind',
  ];

  SpellBookDef get(SpellBookId id) {
    switch (id) {
      case SpellBookId.basicSpellBook:
        return const SpellBookDef(
          id: SpellBookId.basicSpellBook,
          projectileSpellIds: _basicProjectileSpells,
          spellAbilityIds: _basicSpellSlotAbilities,
          stats: GearStatBonuses(powerBonusBp: -100), // -1% Damage
        );
      case SpellBookId.solidSpellBook:
        return const SpellBookDef(
          id: SpellBookId.solidSpellBook,
          projectileSpellIds: _solidProjectileSpells,
          spellAbilityIds: _solidSpellSlotAbilities,
          stats: GearStatBonuses(powerBonusBp: 100), // +1% Damage
        );
      case SpellBookId.epicSpellBook:
        return const SpellBookDef(
          id: SpellBookId.epicSpellBook,
          projectileSpellIds: _allProjectileSpells,
          spellAbilityIds: _allSpellSlotAbilities,
          stats: GearStatBonuses(powerBonusBp: 200), // +2% Damage
        );
    }
  }

  SpellBookDef? tryGet(SpellBookId id) {
    try {
      return get(id);
    } catch (_) {
      return null;
    }
  }
}


===== FILE: lib/core/spellBook/spell_book_def.dart =====
import '../abilities/ability_def.dart' show AbilityKey, WeaponType;
import '../combat/damage_type.dart';
import '../projectiles/projectile_id.dart';
import '../weapons/weapon_proc.dart';
import '../stats/gear_stat_bonuses.dart';
import 'spell_book_id.dart';

/// Data definition for spell books (spell payload providers).
class SpellBookDef {
  const SpellBookDef({
    required this.id,
    this.weaponType = WeaponType.projectileSpell,
    this.projectileSpellIds = const <ProjectileId>[],
    this.spellAbilityIds = const <AbilityKey>[],
    this.stats = const GearStatBonuses(),
    this.damageType,
    this.procs = const <WeaponProc>[],
  });

  final SpellBookId id;
  final WeaponType weaponType;
  final List<ProjectileId> projectileSpellIds;
  final List<AbilityKey> spellAbilityIds;
  final GearStatBonuses stats;
  final DamageType? damageType;
  final List<WeaponProc> procs;

  /// True when this spellbook grants access to the requested projectile spell.
  bool containsProjectileSpell(ProjectileId id) {
    return projectileSpellIds.contains(id);
  }

  /// True when this spellbook grants access to the requested spell-slot spell.
  bool containsSpellAbility(AbilityKey id) {
    return spellAbilityIds.contains(id);
  }
}


===== FILE: lib/core/spellBook/spell_book_id.dart =====
/// Stable identifiers for spell books (spell payload providers).
///
/// Spell books are separate from projectile items (throwing weapons).
enum SpellBookId { basicSpellBook, solidSpellBook, epicSpellBook }


===== FILE: lib/core/stats/character_stat_id.dart =====
/// Canonical stat identifiers for the V1 character stat model.
enum CharacterStatId {
  health,
  mana,
  stamina,
  defense,
  power,
  moveSpeed,
  cooldownReduction,
  critChance,
  physicalResistance,
  fireResistance,
  iceResistance,
  thunderResistance,
  bleedResistance,
}

/// Stable metadata for stat display and future localization mapping.
class CharacterStatDescriptor {
  const CharacterStatDescriptor({
    required this.id,
    required this.displayName,
    required this.localizationKey,
  });

  final CharacterStatId id;
  final String displayName;
  final String localizationKey;
}

const List<CharacterStatDescriptor> kCharacterStatDescriptors =
    <CharacterStatDescriptor>[
      CharacterStatDescriptor(
        id: CharacterStatId.health,
        displayName: 'Health',
        localizationKey: 'gear.stat.health',
      ),
      CharacterStatDescriptor(
        id: CharacterStatId.mana,
        displayName: 'Mana',
        localizationKey: 'gear.stat.mana',
      ),
      CharacterStatDescriptor(
        id: CharacterStatId.stamina,
        displayName: 'Stamina',
        localizationKey: 'gear.stat.stamina',
      ),
      CharacterStatDescriptor(
        id: CharacterStatId.defense,
        displayName: 'Defense',
        localizationKey: 'gear.stat.defense',
      ),
      CharacterStatDescriptor(
        id: CharacterStatId.power,
        displayName: 'Power',
        localizationKey: 'gear.stat.power',
      ),
      CharacterStatDescriptor(
        id: CharacterStatId.moveSpeed,
        displayName: 'Move Speed',
        localizationKey: 'gear.stat.move_speed',
      ),
      CharacterStatDescriptor(
        id: CharacterStatId.cooldownReduction,
        displayName: 'CDR',
        localizationKey: 'gear.stat.cooldown_reduction',
      ),
      CharacterStatDescriptor(
        id: CharacterStatId.critChance,
        displayName: 'Crit Chance',
        localizationKey: 'gear.stat.crit_chance',
      ),
      CharacterStatDescriptor(
        id: CharacterStatId.physicalResistance,
        displayName: 'Physical Resist',
        localizationKey: 'gear.stat.physical_resistance',
      ),
      CharacterStatDescriptor(
        id: CharacterStatId.fireResistance,
        displayName: 'Fire Resist',
        localizationKey: 'gear.stat.fire_resistance',
      ),
      CharacterStatDescriptor(
        id: CharacterStatId.iceResistance,
        displayName: 'Ice Resist',
        localizationKey: 'gear.stat.ice_resistance',
      ),
      CharacterStatDescriptor(
        id: CharacterStatId.thunderResistance,
        displayName: 'Thunder Resist',
        localizationKey: 'gear.stat.thunder_resistance',
      ),
      CharacterStatDescriptor(
        id: CharacterStatId.bleedResistance,
        displayName: 'Bleed Resist',
        localizationKey: 'gear.stat.bleed_resistance',
      ),
    ];

CharacterStatDescriptor characterStatDescriptor(CharacterStatId id) {
  for (final descriptor in kCharacterStatDescriptors) {
    if (descriptor.id == id) return descriptor;
  }
  throw ArgumentError('Missing descriptor for $id');
}


===== FILE: lib/core/stats/character_stats_resolver.dart =====
import '../accessories/accessory_catalog.dart';
import '../accessories/accessory_id.dart';
import '../combat/damage_type.dart';
import '../ecs/stores/combat/equipped_loadout_store.dart';
import '../projectiles/projectile_catalog.dart';
import '../projectiles/projectile_id.dart';
import '../spellBook/spell_book_catalog.dart';
import '../spellBook/spell_book_id.dart';
import '../util/fixed_math.dart';
import '../weapons/weapon_catalog.dart';
import '../weapons/weapon_id.dart';
import 'gear_stat_bonuses.dart';

/// Clamp values for the V1 character stat model.
class CharacterStatCaps {
  const CharacterStatCaps._();

  static const int maxDefenseBp = 7500;
  static const int minDefenseBp = -9000;

  static const int maxPowerBp = 10000;
  static const int minPowerBp = -9000;

  static const int maxGlobalPowerBp = 10000;
  static const int minGlobalPowerBp = -9000;

  static const int maxMoveSpeedBp = 5000;
  static const int minMoveSpeedBp = -9000;

  static const int maxCooldownReductionBp = 5000;
  static const int minCooldownReductionBp = -5000;

  static const int maxCritChanceBp = 6000;
  static const int maxGlobalCritChanceBp = 6000;

  static const int minResourceBonusBp = -9000;
  static const int maxResourceBonusBp = 20000;

  static const int minTypedResistanceBp = -9000;
  static const int maxTypedResistanceBp = 7500;
}

/// Immutable, clamped stat bundle used by runtime systems.
class ResolvedCharacterStats {
  const ResolvedCharacterStats({required this.bonuses});

  final GearStatBonuses bonuses;

  int get healthBonusBp => bonuses.healthBonusBp;
  int get manaBonusBp => bonuses.manaBonusBp;
  int get staminaBonusBp => bonuses.staminaBonusBp;
  int get defenseBonusBp => bonuses.defenseBonusBp;
  int get globalPowerBonusBp => bonuses.globalPowerBonusBp;
  int get globalCritChanceBonusBp => bonuses.globalCritChanceBonusBp;
  int get powerBonusBp => bonuses.powerBonusBp;
  int get moveSpeedBonusBp => bonuses.moveSpeedBonusBp;
  int get cooldownReductionBp => bonuses.cooldownReductionBp;
  int get critChanceBonusBp => bonuses.critChanceBonusBp;
  int get physicalResistanceBp => bonuses.physicalResistanceBp;
  int get fireResistanceBp => bonuses.fireResistanceBp;
  int get iceResistanceBp => bonuses.iceResistanceBp;
  int get waterResistanceBp => bonuses.waterResistanceBp;
  int get thunderResistanceBp => bonuses.thunderResistanceBp;
  int get acidResistanceBp => bonuses.acidResistanceBp;
  int get darkResistanceBp => bonuses.darkResistanceBp;
  int get bleedResistanceBp => bonuses.bleedResistanceBp;
  int get earthResistanceBp => bonuses.earthResistanceBp;
  int get holyResistanceBp => bonuses.holyResistanceBp;

  double get moveSpeedMultiplier => (bpScale + moveSpeedBonusBp) / bpScale;

  int applyHealthMaxBonus(int base100) => applyBp(base100, healthBonusBp);
  int applyManaMaxBonus(int base100) => applyBp(base100, manaBonusBp);
  int applyStaminaMaxBonus(int base100) => applyBp(base100, staminaBonusBp);

  /// Applies global incoming damage reduction (defense) only.
  int applyDefense(int incomingDamage100) {
    final next = applyBp(incomingDamage100, -defenseBonusBp);
    return next < 0 ? 0 : next;
  }

  /// Applies global outgoing damage scaling only.
  int applyGlobalPower(int outgoingDamage100) {
    final next = applyBp(outgoingDamage100, globalPowerBonusBp);
    return next < 0 ? 0 : next;
  }

  /// Backward-compatible alias for global outgoing power scaling.
  int applyPower(int outgoingDamage100) {
    return applyGlobalPower(outgoingDamage100);
  }

  int applyCooldownReduction(int baseTicks) {
    if (baseTicks <= 0) return 0;
    final effectiveScaleBp = bpScale - cooldownReductionBp;
    final scaled =
        (baseTicks * effectiveScaleBp + bpScale - 1) ~/ bpScale; // ceil div
    if (scaled < 0) return 0;
    return scaled;
  }

  /// Returns typed resistance in basis points where positive means mitigation.
  int resistanceBpForDamageType(DamageType type) {
    switch (type) {
      case DamageType.physical:
        return physicalResistanceBp;
      case DamageType.fire:
        return fireResistanceBp;
      case DamageType.ice:
        return iceResistanceBp;
      case DamageType.water:
        return waterResistanceBp;
      case DamageType.thunder:
        return thunderResistanceBp;
      case DamageType.acid:
        return acidResistanceBp;
      case DamageType.dark:
        return darkResistanceBp;
      case DamageType.bleed:
        return bleedResistanceBp;
      case DamageType.earth:
        return earthResistanceBp;
      case DamageType.holy:
        return holyResistanceBp;
    }
  }

  /// Returns incoming-damage modifier bp compatible with DamageResistanceStore.
  /// Positive resistance reduces incoming damage, so sign is inverted.
  int incomingDamageModBpForDamageType(DamageType type) {
    return -resistanceBpForDamageType(type);
  }
}

/// Pure resolver that maps equipped items to runtime-ready stat totals.
///
/// This is intentionally Core-only and deterministic. It has no UI/runtime
/// side effects and can be reused by both gameplay systems and UI presenters.
class CharacterStatsResolver {
  const CharacterStatsResolver({
    this.weapons = const WeaponCatalog(),
    this.projectiles = const ProjectileCatalog(),
    this.spellBooks = const SpellBookCatalog(),
    this.accessories = const AccessoryCatalog(),
  });

  final WeaponCatalog weapons;
  final ProjectileCatalog projectiles;
  final SpellBookCatalog spellBooks;
  final AccessoryCatalog accessories;

  ResolvedCharacterStats resolveLoadout(EquippedLoadoutDef loadout) {
    return resolveEquipped(
      mask: loadout.mask,
      mainWeaponId: loadout.mainWeaponId,
      offhandWeaponId: loadout.offhandWeaponId,
      projectileId: loadout.projectileId,
      spellBookId: loadout.spellBookId,
      accessoryId: loadout.accessoryId,
    );
  }

  ResolvedCharacterStats resolveEquipped({
    required int mask,
    required WeaponId mainWeaponId,
    required WeaponId offhandWeaponId,
    required ProjectileId projectileId,
    required SpellBookId spellBookId,
    required AccessoryId accessoryId,
  }) {
    final mainWeapon = weapons.get(mainWeaponId);
    GearStatBonuses total = mainWeapon.stats;

    final hasOffhand = (mask & LoadoutSlotMask.offHand) != 0;
    if (hasOffhand && !mainWeapon.isTwoHanded) {
      total += weapons.get(offhandWeaponId).stats;
    }

    final hasProjectile = (mask & LoadoutSlotMask.projectile) != 0;
    if (hasProjectile) {
      total += projectiles.get(projectileId).stats;
      total += spellBooks.get(spellBookId).stats;
    }

    total += accessories.get(accessoryId).stats;

    return ResolvedCharacterStats(bonuses: _clamp(total));
  }

  GearStatBonuses _clamp(GearStatBonuses input) {
    return GearStatBonuses(
      healthBonusBp: _clampInt(
        input.healthBonusBp,
        CharacterStatCaps.minResourceBonusBp,
        CharacterStatCaps.maxResourceBonusBp,
      ),
      manaBonusBp: _clampInt(
        input.manaBonusBp,
        CharacterStatCaps.minResourceBonusBp,
        CharacterStatCaps.maxResourceBonusBp,
      ),
      staminaBonusBp: _clampInt(
        input.staminaBonusBp,
        CharacterStatCaps.minResourceBonusBp,
        CharacterStatCaps.maxResourceBonusBp,
      ),
      defenseBonusBp: _clampInt(
        input.defenseBonusBp,
        CharacterStatCaps.minDefenseBp,
        CharacterStatCaps.maxDefenseBp,
      ),
      globalPowerBonusBp: _clampInt(
        input.globalPowerBonusBp,
        CharacterStatCaps.minGlobalPowerBp,
        CharacterStatCaps.maxGlobalPowerBp,
      ),
      globalCritChanceBonusBp: _clampInt(
        input.globalCritChanceBonusBp,
        0,
        CharacterStatCaps.maxGlobalCritChanceBp,
      ),
      powerBonusBp: _clampInt(
        input.powerBonusBp,
        CharacterStatCaps.minPowerBp,
        CharacterStatCaps.maxPowerBp,
      ),
      moveSpeedBonusBp: _clampInt(
        input.moveSpeedBonusBp,
        CharacterStatCaps.minMoveSpeedBp,
        CharacterStatCaps.maxMoveSpeedBp,
      ),
      cooldownReductionBp: _clampInt(
        input.cooldownReductionBp,
        CharacterStatCaps.minCooldownReductionBp,
        CharacterStatCaps.maxCooldownReductionBp,
      ),
      critChanceBonusBp: _clampInt(
        input.critChanceBonusBp,
        0,
        CharacterStatCaps.maxCritChanceBp,
      ),
      physicalResistanceBp: _clampInt(
        input.physicalResistanceBp,
        CharacterStatCaps.minTypedResistanceBp,
        CharacterStatCaps.maxTypedResistanceBp,
      ),
      fireResistanceBp: _clampInt(
        input.fireResistanceBp,
        CharacterStatCaps.minTypedResistanceBp,
        CharacterStatCaps.maxTypedResistanceBp,
      ),
      iceResistanceBp: _clampInt(
        input.iceResistanceBp,
        CharacterStatCaps.minTypedResistanceBp,
        CharacterStatCaps.maxTypedResistanceBp,
      ),
      waterResistanceBp: _clampInt(
        input.waterResistanceBp,
        CharacterStatCaps.minTypedResistanceBp,
        CharacterStatCaps.maxTypedResistanceBp,
      ),
      thunderResistanceBp: _clampInt(
        input.thunderResistanceBp,
        CharacterStatCaps.minTypedResistanceBp,
        CharacterStatCaps.maxTypedResistanceBp,
      ),
      acidResistanceBp: _clampInt(
        input.acidResistanceBp,
        CharacterStatCaps.minTypedResistanceBp,
        CharacterStatCaps.maxTypedResistanceBp,
      ),
      darkResistanceBp: _clampInt(
        input.darkResistanceBp,
        CharacterStatCaps.minTypedResistanceBp,
        CharacterStatCaps.maxTypedResistanceBp,
      ),
      bleedResistanceBp: _clampInt(
        input.bleedResistanceBp,
        CharacterStatCaps.minTypedResistanceBp,
        CharacterStatCaps.maxTypedResistanceBp,
      ),
      earthResistanceBp: _clampInt(
        input.earthResistanceBp,
        CharacterStatCaps.minTypedResistanceBp,
        CharacterStatCaps.maxTypedResistanceBp,
      ),
      holyResistanceBp: _clampInt(
        input.holyResistanceBp,
        CharacterStatCaps.minTypedResistanceBp,
        CharacterStatCaps.maxTypedResistanceBp,
      ),
      critDamageBonusBp: input.critDamageBonusBp,
      rangeScalarPercent: input.rangeScalarPercent,
    );
  }

  int _clampInt(int value, int minValue, int maxValue) {
    if (value < minValue) return minValue;
    if (value > maxValue) return maxValue;
    return value;
  }
}


===== FILE: lib/core/stats/gear_stat_bonuses.dart =====
/// Unified stat contribution payload emitted by all gear domains.
///
/// All values are fixed-point compatible and deterministic:
/// - basis points (bp): `100 = 1%`
/// - fixed-100 values: `100 = 1.0` (legacy aliases still accepted)
class GearStatBonuses {
  const GearStatBonuses({
    int healthBonusBp = 0,
    int? hpBonus100,
    int manaBonusBp = 0,
    int? manaBonus100,
    int staminaBonusBp = 0,
    int? staminaBonus100,
    this.defenseBonusBp = 0,
    this.globalPowerBonusBp = 0,
    this.globalCritChanceBonusBp = 0,
    this.powerBonusBp = 0,
    this.moveSpeedBonusBp = 0,
    this.cooldownReductionBp = 0,
    this.critChanceBonusBp = 0,
    this.physicalResistanceBp = 0,
    this.fireResistanceBp = 0,
    this.iceResistanceBp = 0,
    this.waterResistanceBp = 0,
    this.thunderResistanceBp = 0,
    this.acidResistanceBp = 0,
    this.darkResistanceBp = 0,
    this.bleedResistanceBp = 0,
    this.earthResistanceBp = 0,
    this.holyResistanceBp = 0,
    // Legacy/non-V1 fields kept for compatibility during migration.
    this.critDamageBonusBp = 0,
    this.rangeScalarPercent = 100,
  }) : healthBonusBp = hpBonus100 ?? healthBonusBp,
       manaBonusBp = manaBonus100 ?? manaBonusBp,
       staminaBonusBp = staminaBonus100 ?? staminaBonusBp,
       assert(rangeScalarPercent > 0, 'rangeScalarPercent must be > 0');

  static const GearStatBonuses zero = GearStatBonuses();

  /// Basis points (100 = 1%).
  final int healthBonusBp;

  /// Basis points (100 = 1%).
  final int manaBonusBp;

  /// Basis points (100 = 1%).
  final int staminaBonusBp;

  /// Basis points (100 = 1%).
  ///
  /// Positive values reduce incoming damage globally.
  final int defenseBonusBp;

  /// Basis points (100 = 1%).
  ///
  /// Positive values increase outgoing damage for all payload sources.
  final int globalPowerBonusBp;

  /// Basis points (100 = 1%).
  ///
  /// Positive values increase crit chance for all payload sources.
  final int globalCritChanceBonusBp;

  /// Basis points (100 = 1%).
  ///
  /// Positive values increase outgoing damage for the selected payload source.
  final int powerBonusBp;

  /// Basis points (100 = 1%).
  final int moveSpeedBonusBp;

  /// Basis points (100 = 1%).
  final int cooldownReductionBp;

  /// Basis points (100 = 1%).
  ///
  /// Positive values increase crit chance for the selected payload source.
  final int critChanceBonusBp;

  /// Basis points (100 = 1%).
  ///
  /// Positive values reduce physical damage taken.
  final int physicalResistanceBp;

  /// Basis points (100 = 1%).
  ///
  /// Positive values reduce fire damage taken.
  final int fireResistanceBp;

  /// Basis points (100 = 1%).
  ///
  /// Positive values reduce ice damage taken.
  final int iceResistanceBp;

  /// Basis points (100 = 1%).
  ///
  /// Positive values reduce water damage taken.
  final int waterResistanceBp;

  /// Basis points (100 = 1%).
  ///
  /// Positive values reduce thunder damage taken.
  final int thunderResistanceBp;

  /// Basis points (100 = 1%).
  ///
  /// Positive values reduce acid damage taken.
  final int acidResistanceBp;

  /// Basis points (100 = 1%).
  ///
  /// Positive values reduce dark damage taken.
  final int darkResistanceBp;

  /// Basis points (100 = 1%).
  ///
  /// Positive values reduce bleed damage taken.
  final int bleedResistanceBp;

  /// Basis points (100 = 1%).
  ///
  /// Positive values reduce earth damage taken.
  final int earthResistanceBp;

  /// Basis points (100 = 1%).
  ///
  /// Positive values reduce holy damage taken.
  final int holyResistanceBp;

  /// Legacy field (not part of V1 core stat set).
  final int critDamageBonusBp;

  /// Legacy field (not part of V1 core stat set), `100 = unchanged`.
  final int rangeScalarPercent;

  /// Legacy alias retained to minimize migration surface.
  int get hpBonus100 => healthBonusBp;

  /// Legacy alias retained to minimize migration surface.
  int get manaBonus100 => manaBonusBp;

  /// Legacy alias retained to minimize migration surface.
  int get staminaBonus100 => staminaBonusBp;

  bool get isZero =>
      healthBonusBp == 0 &&
      manaBonusBp == 0 &&
      staminaBonusBp == 0 &&
      defenseBonusBp == 0 &&
      globalPowerBonusBp == 0 &&
      globalCritChanceBonusBp == 0 &&
      powerBonusBp == 0 &&
      moveSpeedBonusBp == 0 &&
      cooldownReductionBp == 0 &&
      critChanceBonusBp == 0 &&
      physicalResistanceBp == 0 &&
      fireResistanceBp == 0 &&
      iceResistanceBp == 0 &&
      waterResistanceBp == 0 &&
      thunderResistanceBp == 0 &&
      acidResistanceBp == 0 &&
      darkResistanceBp == 0 &&
      bleedResistanceBp == 0 &&
      earthResistanceBp == 0 &&
      holyResistanceBp == 0 &&
      critDamageBonusBp == 0 &&
      rangeScalarPercent == 100;

  GearStatBonuses operator +(GearStatBonuses other) {
    return GearStatBonuses(
      healthBonusBp: healthBonusBp + other.healthBonusBp,
      manaBonusBp: manaBonusBp + other.manaBonusBp,
      staminaBonusBp: staminaBonusBp + other.staminaBonusBp,
      defenseBonusBp: defenseBonusBp + other.defenseBonusBp,
      globalPowerBonusBp: globalPowerBonusBp + other.globalPowerBonusBp,
      globalCritChanceBonusBp:
          globalCritChanceBonusBp + other.globalCritChanceBonusBp,
      powerBonusBp: powerBonusBp + other.powerBonusBp,
      moveSpeedBonusBp: moveSpeedBonusBp + other.moveSpeedBonusBp,
      cooldownReductionBp: cooldownReductionBp + other.cooldownReductionBp,
      critChanceBonusBp: critChanceBonusBp + other.critChanceBonusBp,
      physicalResistanceBp: physicalResistanceBp + other.physicalResistanceBp,
      fireResistanceBp: fireResistanceBp + other.fireResistanceBp,
      iceResistanceBp: iceResistanceBp + other.iceResistanceBp,
      waterResistanceBp: waterResistanceBp + other.waterResistanceBp,
      thunderResistanceBp: thunderResistanceBp + other.thunderResistanceBp,
      acidResistanceBp: acidResistanceBp + other.acidResistanceBp,
      darkResistanceBp: darkResistanceBp + other.darkResistanceBp,
      bleedResistanceBp: bleedResistanceBp + other.bleedResistanceBp,
      earthResistanceBp: earthResistanceBp + other.earthResistanceBp,
      holyResistanceBp: holyResistanceBp + other.holyResistanceBp,
      critDamageBonusBp: critDamageBonusBp + other.critDamageBonusBp,
      rangeScalarPercent:
          (rangeScalarPercent * other.rangeScalarPercent) ~/ 100,
    );
  }
}


===== FILE: lib/core/stats/resolved_stats_cache.dart =====
import '../ecs/entity_id.dart';
import '../ecs/world.dart';
import 'character_stats_resolver.dart';
import 'gear_stat_bonuses.dart';

/// Resolves and caches loadout-derived stats per entity.
///
/// Cache entries are invalidated lazily by comparing current loadout fields
/// against the cached snapshot in [ResolvedStatsCacheStore].
class ResolvedStatsCache {
  const ResolvedStatsCache({
    CharacterStatsResolver resolver = const CharacterStatsResolver(),
  }) : _resolver = resolver;

  static const ResolvedCharacterStats neutral = ResolvedCharacterStats(
    bonuses: GearStatBonuses.zero,
  );

  final CharacterStatsResolver _resolver;

  /// Returns cached stats for [entity], recomputing only if loadout changed.
  ///
  /// Entities without `EquippedLoadoutStore` return neutral stats.
  ResolvedCharacterStats resolveForEntity(EcsWorld world, EntityId entity) {
    final loadout = world.equippedLoadout;
    final li = loadout.tryIndexOf(entity);
    if (li == null) return neutral;

    final currentMask = loadout.mask[li];
    final currentMainWeaponId = loadout.mainWeaponId[li];
    final currentOffhandWeaponId = loadout.offhandWeaponId[li];
    final currentProjectileId = loadout.projectileId[li];
    final currentSpellBookId = loadout.spellBookId[li];
    final currentAccessoryId = loadout.accessoryId[li];

    final cache = world.resolvedStatsCache;
    final ci = cache.tryIndexOf(entity);
    if (ci != null &&
        cache.matchesLoadout(
          cacheIndex: ci,
          mask: currentMask,
          mainWeaponId: currentMainWeaponId,
          offhandWeaponId: currentOffhandWeaponId,
          projectileId: currentProjectileId,
          spellBookId: currentSpellBookId,
          accessoryId: currentAccessoryId,
        )) {
      return cache.stats[ci];
    }

    final resolved = _resolver.resolveEquipped(
      mask: currentMask,
      mainWeaponId: currentMainWeaponId,
      offhandWeaponId: currentOffhandWeaponId,
      projectileId: currentProjectileId,
      spellBookId: currentSpellBookId,
      accessoryId: currentAccessoryId,
    );
    cache.setForEntity(
      entity,
      mask: currentMask,
      mainWeaponId: currentMainWeaponId,
      offhandWeaponId: currentOffhandWeaponId,
      projectileId: currentProjectileId,
      spellBookId: currentSpellBookId,
      accessoryId: currentAccessoryId,
      stats: resolved,
    );
    return resolved;
  }
}


===== FILE: lib/core/track/chunk_builder.dart =====
/// Chunk geometry builder functions for track streaming.
///
/// Converts chunk-relative pattern definitions into world-space collision
/// geometry ([StaticSolid], [StaticGroundSegment], [StaticGroundGap]).
library;

import '../collision/static_world_geometry.dart';
import 'chunk_pattern.dart';

/// Result of building ground geometry from a chunk pattern.
class GroundBuildResult {
  const GroundBuildResult({
    required this.segments,
    required this.gaps,
  });

  /// Walkable ground spans (between gaps).
  final List<StaticGroundSegment> segments;

  /// Pit/gap spans.
  final List<StaticGroundGap> gaps;
}

/// Converts pattern platforms/obstacles into world-space [StaticSolid]s.
///
/// [pattern] - The chunk pattern containing platforms and obstacles.
/// [chunkStartX] - World X where this chunk begins.
/// [chunkIndex] - Sequential chunk number for tagging solids.
/// [groundTopY] - World Y of the ground surface.
/// [chunkWidth] - Width of a chunk (for bounds checking).
/// [gridSnap] - Grid snap value (for alignment checking).
List<StaticSolid> buildSolids(
  ChunkPattern pattern, {
  required double chunkStartX,
  required int chunkIndex,
  required double groundTopY,
  required double chunkWidth,
  required double gridSnap,
}) {
  // Preserve author ordering for determinism.
  final solids = <StaticSolid>[];
  var localSolidIndex = 0;

  // ── Platforms (one-way top) ──
  for (final p in pattern.platforms) {
    assert(
      _withinChunk(p.x, p.width, chunkWidth),
      'Platform out of chunk bounds: ${pattern.name}',
    );
    assert(
      _snapped(p.x, gridSnap) &&
          _snapped(p.width, gridSnap) &&
          _snapped(p.aboveGroundTop, gridSnap),
      'Platform not snapped to grid: ${pattern.name}',
    );
    final topY = groundTopY - p.aboveGroundTop;
    solids.add(
      StaticSolid(
        minX: chunkStartX + p.x,
        minY: topY,
        maxX: chunkStartX + p.x + p.width,
        maxY: topY + p.thickness,
        sides: StaticSolid.sideTop,
        oneWayTop: true,
        chunkIndex: chunkIndex,
        localSolidIndex: localSolidIndex,
      ),
    );
    localSolidIndex += 1;
  }

  // ── Obstacles (solid on all sides) ──
  for (final o in pattern.obstacles) {
    assert(
      _withinChunk(o.x, o.width, chunkWidth),
      'Obstacle out of chunk bounds: ${pattern.name}',
    );
    assert(
      _snapped(o.x, gridSnap) &&
          _snapped(o.width, gridSnap) &&
          _snapped(o.height, gridSnap),
      'Obstacle not snapped to grid: ${pattern.name}',
    );
    solids.add(
      StaticSolid(
        minX: chunkStartX + o.x,
        minY: groundTopY - o.height,
        maxX: chunkStartX + o.x + o.width,
        maxY: groundTopY,
        sides: StaticSolid.sideAll,
        oneWayTop: false,
        chunkIndex: chunkIndex,
        localSolidIndex: localSolidIndex,
      ),
    );
    localSolidIndex += 1;
  }

  return solids;
}

/// Builds ground segments by splitting at gap positions.
///
/// Gaps are sorted by X, then segments fill the remaining spans.
///
/// [pattern] - The chunk pattern containing ground gaps.
/// [chunkStartX] - World X where this chunk begins.
/// [chunkIndex] - Sequential chunk number for tagging segments.
/// [groundTopY] - World Y of the ground surface.
/// [chunkWidth] - Width of a chunk.
/// [gridSnap] - Grid snap value (for alignment checking).
GroundBuildResult buildGroundSegments(
  ChunkPattern pattern, {
  required double chunkStartX,
  required int chunkIndex,
  required double groundTopY,
  required double chunkWidth,
  required double gridSnap,
}) {
  // Sort gaps left-to-right for sequential processing.
  final orderedGaps = List<GapRel>.from(pattern.groundGaps);
  if (orderedGaps.isNotEmpty) {
    orderedGaps.sort((a, b) => a.x.compareTo(b.x));
  }

  final segments = <StaticGroundSegment>[];
  final gaps = <StaticGroundGap>[];
  var cursor = 0.0; // Tracks end of last segment/gap.
  var localSegmentIndex = 0;
  var lastGapEnd = -1.0; // For overlap assertion.

  for (final gap in orderedGaps) {
    assert(
      _withinChunk(gap.x, gap.width, chunkWidth),
      'Ground gap out of chunk bounds: ${pattern.name}',
    );
    assert(
      _snapped(gap.x, gridSnap) && _snapped(gap.width, gridSnap),
      'Ground gap not snapped to grid: ${pattern.name}',
    );
    assert(
      gap.x >= lastGapEnd - 1e-6,
      'Ground gap overlaps previous: ${pattern.name}',
    );

    final gapStart = gap.x;
    final gapEnd = gap.x + gap.width;

    // Emit segment from cursor to gap start (if non-empty).
    if (gapStart > cursor + 1e-6) {
      segments.add(
        StaticGroundSegment(
          minX: chunkStartX + cursor,
          maxX: chunkStartX + gapStart,
          topY: groundTopY,
          chunkIndex: chunkIndex,
          localSegmentIndex: localSegmentIndex,
        ),
      );
      localSegmentIndex += 1;
    }

    // Record gap for collision/rendering.
    gaps.add(
      StaticGroundGap(
        minX: chunkStartX + gapStart,
        maxX: chunkStartX + gapEnd,
      ),
    );

    // Advance cursor past gap.
    cursor = gapEnd > cursor ? gapEnd : cursor;
    lastGapEnd = gapEnd;
  }

  // Emit trailing segment from last gap to chunk end.
  if (cursor < chunkWidth - 1e-6) {
    segments.add(
      StaticGroundSegment(
        minX: chunkStartX + cursor,
        maxX: chunkStartX + chunkWidth,
        topY: groundTopY,
        chunkIndex: chunkIndex,
        localSegmentIndex: localSegmentIndex,
      ),
    );
  }

  return GroundBuildResult(segments: segments, gaps: gaps);
}

/// Checks if a span [x, x+width] fits within [0, chunkWidth].
bool _withinChunk(double x, double width, double chunkWidth) {
  return x >= 0.0 && (x + width) <= chunkWidth;
}

/// Checks if a value is snapped to the grid.
bool _snapped(double v, double gridSnap) {
  final snapped = (v / gridSnap).roundToDouble() * gridSnap;
  return (v - snapped).abs() < 1e-9;
}


===== FILE: lib/core/track/chunk_pattern.dart =====
/// Chunk pattern data structures for track streaming.
///
/// Defines the authored building blocks (platforms, obstacles, gaps, spawns)
/// used to compose procedural track chunks.
library;

import '../enemies/enemy_id.dart';

/// Authored chunk template defining platforms, obstacles, gaps, and spawns.
///
/// All coordinates are chunk-relative (x in `[0, chunkWidth)`).
/// Heights are expressed as "above ground top" so patterns are ground-agnostic.
class ChunkPattern {
  const ChunkPattern({
    required this.name,
    this.platforms = const <PlatformRel>[],
    this.obstacles = const <ObstacleRel>[],
    this.groundGaps = const <GapRel>[],
    this.spawnMarkers = const <SpawnMarker>[],
  });

  /// Human-readable identifier for debugging/logging.
  final String name;

  /// One-way platforms the player can jump through.
  final List<PlatformRel> platforms;

  /// Solid obstacles the player must jump over.
  final List<ObstacleRel> obstacles;

  /// Holes in the ground (pit hazards or visual breaks).
  final List<GapRel> groundGaps;

  /// Probabilistic enemy spawn points.
  final List<SpawnMarker> spawnMarkers;
}

/// Chunk-relative platform definition (one-way top surface).
class PlatformRel {
  const PlatformRel({
    required this.x,
    required this.width,
    required this.aboveGroundTop,
    required this.thickness,
  }) : assert(width > 0),
       assert(thickness > 0),
       assert(aboveGroundTop > 0);

  /// Left edge offset from chunk start.
  final double x;

  /// Horizontal extent.
  final double width;

  /// Vertical offset above ground (positive = higher).
  final double aboveGroundTop;

  /// Platform thickness (visual/collision depth).
  final double thickness;
}

/// Chunk-relative obstacle definition (solid on all sides).
class ObstacleRel {
  const ObstacleRel({
    required this.x,
    required this.width,
    required this.height,
  }) : assert(width > 0),
       assert(height > 0);

  /// Left edge offset from chunk start.
  final double x;

  /// Horizontal extent.
  final double width;

  /// Vertical extent (sits on ground, extends upward).
  final double height;
}

/// Chunk-relative ground gap (pit hazard).
class GapRel {
  const GapRel({
    required this.x,
    required this.width,
  }) : assert(width > 0);

  /// Left edge offset from chunk start.
  final double x;

  /// Horizontal extent of the gap.
  final double width;
}

/// Chunk-relative enemy spawn marker with probabilistic activation.
class SpawnMarker {
  const SpawnMarker({
    required this.enemyId,
    required this.x,
    required this.chancePercent,
    required this.salt,
  }) : assert(chancePercent >= 0),
       assert(chancePercent <= 100);

  /// Enemy type to spawn.
  final EnemyId enemyId;

  /// Spawn X offset from chunk start.
  final double x;

  /// Probability [0–100] that this marker activates.
  final int chancePercent;

  /// Extra entropy to differentiate markers with same position.
  final int salt;
}


===== FILE: lib/core/track/chunk_pattern_pool.dart =====
/// Groups pattern pools used for procedural track generation.
library;

import 'chunk_pattern.dart';

/// Default count of early chunks that draw from the "easy" pool.
const int defaultEarlyPatternChunks = 3;

/// Default count of early chunks that suppress enemy spawns.
const int defaultNoEnemyChunks = 3;

/// Pattern pools for early vs full difficulty.
class ChunkPatternPool {
  const ChunkPatternPool({
    required this.easyPatterns,
    required this.allPatterns,
  });

  /// Simpler patterns for early chunks.
  final List<ChunkPattern> easyPatterns;

  /// Full pattern pool used after early chunks.
  final List<ChunkPattern> allPatterns;
}


===== FILE: lib/core/track/chunk_patterns_library.dart =====
/// Pre-authored chunk pattern library for track streaming.
///
/// Notes:
/// - All coordinates are relative to the chunk start (x in [0, chunkWidth)).
/// - Y is expressed as "above ground top" (so 48 means 48 units above ground).
/// - Values are authored on a 16-unit grid for stability.
library;

import '../enemies/enemy_id.dart';
import 'chunk_pattern.dart';

/// Standard platform thickness (visual/collision depth).
const double kPlatformThickness = 16.0;

/// Shorthand for [kPlatformThickness] in pattern definitions.
const double _t = kPlatformThickness;

/// Simpler patterns for early-game chunks (default early window).
///
/// These give the player breathing room before harder patterns appear.
const List<ChunkPattern> easyPatterns = <ChunkPattern>[
  ChunkPattern(
    name: 'recovery-flat',
    platforms: <PlatformRel>[],
    obstacles: <ObstacleRel>[],
    groundGaps: <GapRel>[],
    spawnMarkers: <SpawnMarker>[],
  ),
  ChunkPattern(
    name: 'single-low-platform',
    platforms: <PlatformRel>[
      PlatformRel(x: 160, width: 160, aboveGroundTop: 48, thickness: _t),
    ],
    obstacles: <ObstacleRel>[],
    groundGaps: <GapRel>[GapRel(x: 64, width: 96)],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
        enemyId: EnemyId.unocoDemon,
        x: 240,
        chancePercent: 100,
        salt: 0x11,
      ),
    ],
  ),
  ChunkPattern(
    name: 'two-low-platforms',
    platforms: <PlatformRel>[
      PlatformRel(x: 64, width: 144, aboveGroundTop: 48, thickness: _t),
      PlatformRel(x: 272, width: 144, aboveGroundTop: 64, thickness: _t),
    ],
    obstacles: <ObstacleRel>[],
    groundGaps: <GapRel>[],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
        enemyId: EnemyId.grojib,
        x: 448,
        chancePercent: 10,
        salt: 0x12,
      ),
    ],
  ),
];

/// Full pattern pool for later chunks (index >= 3).
///
/// Includes [easyPatterns] plus more challenging layouts.
const List<ChunkPattern> allPatterns = <ChunkPattern>[
  // ── Recovery / breathers ──
  ...easyPatterns,

  // ── Platforming ──
  ChunkPattern(
    name: 'staggered-mid-platforms',
    platforms: <PlatformRel>[
      PlatformRel(x: 48, width: 160, aboveGroundTop: 64, thickness: _t),
      PlatformRel(x: 256, width: 160, aboveGroundTop: 96, thickness: _t),
    ],
    groundGaps: <GapRel>[GapRel(x: 240, width: 128)],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
        enemyId: EnemyId.unocoDemon,
        x: 352,
        chancePercent: 17,
        salt: 0x01,
      ),
    ],
  ),
  ChunkPattern(
    name: 'triple-runner-platforms',
    platforms: <PlatformRel>[
      PlatformRel(x: 32, width: 128, aboveGroundTop: 48, thickness: _t),
      PlatformRel(x: 192, width: 128, aboveGroundTop: 80, thickness: _t),
      PlatformRel(x: 352, width: 96, aboveGroundTop: 64, thickness: _t),
    ],
    groundGaps: <GapRel>[],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
        enemyId: EnemyId.unocoDemon,
        x: 288,
        chancePercent: 15,
        salt: 0x02,
      ),
    ],
  ),
  ChunkPattern(
    name: 'high-platform-over-obstacle',
    platforms: <PlatformRel>[
      PlatformRel(x: 224, width: 192, aboveGroundTop: 112, thickness: _t),
    ],
    obstacles: <ObstacleRel>[ObstacleRel(x: 128, width: 48, height: 64)],
    groundGaps: <GapRel>[GapRel(x: 176, width: 96)],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
        enemyId: EnemyId.grojib,
        x: 320,
        chancePercent: 22,
        salt: 0x03,
      ),
    ],
  ),

  // ── Obstacles (ground blocks that force a jump/dash) ──
  ChunkPattern(
    name: 'single-block',
    obstacles: <ObstacleRel>[ObstacleRel(x: 224, width: 48, height: 64)],
    groundGaps: <GapRel>[GapRel(x: 128, width: 96)],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
        enemyId: EnemyId.grojib,
        x: 320,
        chancePercent: 17,
        salt: 0x04,
      ),
    ],
  ),
  ChunkPattern(
    name: 'double-blocks',
    obstacles: <ObstacleRel>[
      ObstacleRel(x: 160, width: 32, height: 48),
      ObstacleRel(x: 288, width: 48, height: 64),
    ],
    groundGaps: <GapRel>[],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
        enemyId: EnemyId.unocoDemon,
        x: 96,
        chancePercent: 12,
        salt: 0x05,
      ),
      SpawnMarker(
        enemyId: EnemyId.grojib,
        x: 352,
        chancePercent: 15,
        salt: 0x06,
      ),
    ],
  ),
  ChunkPattern(
    name: 'low-staircase-platforms',
    platforms: <PlatformRel>[
      PlatformRel(x: 48, width: 128, aboveGroundTop: 48, thickness: _t),
      PlatformRel(x: 208, width: 128, aboveGroundTop: 64, thickness: _t),
      PlatformRel(x: 368, width: 128, aboveGroundTop: 80, thickness: _t),
    ],
    groundGaps: <GapRel>[GapRel(x: 304, width: 96)],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
        enemyId: EnemyId.grojib,
        x: 112,
        chancePercent: 15,
        salt: 0x07,
      ),
      SpawnMarker(
        enemyId: EnemyId.unocoDemon,
        x: 320,
        chancePercent: 15,
        salt: 0x08,
      ),
    ],
  ),
  ChunkPattern(
    name: 'wide-platform-gap',
    platforms: <PlatformRel>[
      PlatformRel(x: 32, width: 192, aboveGroundTop: 64, thickness: _t),
      PlatformRel(x: 288, width: 192, aboveGroundTop: 64, thickness: _t),
    ],
    groundGaps: <GapRel>[],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
        enemyId: EnemyId.unocoDemon,
        x: 192,
        chancePercent: 17,
        salt: 0x09,
      ),
      SpawnMarker(
        enemyId: EnemyId.grojib,
        x: 448,
        chancePercent: 15,
        salt: 0x0A,
      ),
    ],
  ),
  ChunkPattern(
    name: 'double-obstacle-lane',
    obstacles: <ObstacleRel>[
      ObstacleRel(x: 144, width: 48, height: 64),
      ObstacleRel(x: 336, width: 48, height: 64),
    ],
    groundGaps: <GapRel>[],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
        enemyId: EnemyId.grojib,
        x: 256,
        chancePercent: 17,
        salt: 0x0B,
      ),
      SpawnMarker(
        enemyId: EnemyId.unocoDemon,
        x: 80,
        chancePercent: 12,
        salt: 0x0C,
      ),
    ],
  ),
  ChunkPattern(
    name: 'mid-platform-overhang',
    platforms: <PlatformRel>[
      PlatformRel(x: 96, width: 160, aboveGroundTop: 96, thickness: _t),
      PlatformRel(x: 384, width: 128, aboveGroundTop: 64, thickness: _t),
    ],
    obstacles: <ObstacleRel>[ObstacleRel(x: 320, width: 64, height: 80)],
    groundGaps: <GapRel>[],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
        enemyId: EnemyId.unocoDemon,
        x: 176,
        chancePercent: 15,
        salt: 0x0D,
      ),
      SpawnMarker(
        enemyId: EnemyId.grojib,
        x: 448,
        chancePercent: 15,
        salt: 0x0E,
      ),
    ],
  ),
  ChunkPattern(
    name: 'tight-platforms',
    platforms: <PlatformRel>[
      PlatformRel(x: 32, width: 96, aboveGroundTop: 80, thickness: _t),
      PlatformRel(x: 160, width: 96, aboveGroundTop: 96, thickness: _t),
      PlatformRel(x: 288, width: 96, aboveGroundTop: 80, thickness: _t),
    ],
    obstacles: <ObstacleRel>[ObstacleRel(x: 448, width: 48, height: 64)],
    groundGaps: <GapRel>[GapRel(x: 112, width: 128)],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
        enemyId: EnemyId.unocoDemon,
        x: 240,
        chancePercent: 15,
        salt: 0x0F,
      ),
      SpawnMarker(
        enemyId: EnemyId.grojib,
        x: 480,
        chancePercent: 12,
        salt: 0x10,
      ),
    ],
  ),

  // ── Ground gaps ──
  ChunkPattern(
    name: 'ground-gap-small',
    groundGaps: <GapRel>[GapRel(x: 256, width: 64)],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
        enemyId: EnemyId.grojib,
        x: 160,
        chancePercent: 12,
        salt: 0x21,
      ),
      SpawnMarker(
        enemyId: EnemyId.unocoDemon,
        x: 416,
        chancePercent: 12,
        salt: 0x22,
      ),
    ],
  ),
  ChunkPattern(
    name: 'ground-gap-wide',
    groundGaps: <GapRel>[GapRel(x: 224, width: 128)],
    spawnMarkers: <SpawnMarker>[
      SpawnMarker(
        enemyId: EnemyId.unocoDemon,
        x: 96,
        chancePercent: 12,
        salt: 0x23,
      ),
      SpawnMarker(
        enemyId: EnemyId.grojib,
        x: 480,
        chancePercent: 12,
        salt: 0x24,
      ),
    ],
  ),
];


===== FILE: lib/core/track/track_streamer.dart =====
/// Infinite-runner track streaming system.
///
/// Procedurally generates level geometry (platforms, obstacles, ground gaps)
/// and enemy spawn points by selecting from a pool of pre-authored chunk
/// patterns. Uses deterministic RNG so runs are reproducible given the same
/// seed.
library;

import '../collision/static_world_geometry.dart';
import '../enemies/enemy_id.dart';
import '../tuning/track_tuning.dart';
import '../util/deterministic_rng.dart' show mix32;
import 'chunk_builder.dart';
import 'chunk_pattern.dart';
import 'chunk_pattern_pool.dart';

/// Callback to spawn an enemy at a world X position.
typedef SpawnEnemy = void Function(EnemyId enemyId, double x);

/// Metadata for a newly spawned chunk, returned by [TrackStreamer.step].
class TrackSpawnedChunk {
  const TrackSpawnedChunk({
    required this.index,
    required this.startX,
    required this.patternName,
  });

  /// Sequential chunk number (0 = first chunk).
  final int index;

  /// World X coordinate where this chunk begins.
  final double startX;

  /// Pattern identifier used to generate this chunk.
  final String patternName;
}

/// Result of a single [TrackStreamer.step] call.
class TrackStreamStepResult {
  const TrackStreamStepResult({
    required this.changed,
    required this.spawnedChunks,
  });

  /// True if geometry lists were rebuilt (chunk spawned or culled).
  final bool changed;

  /// Chunks created this step (empty on steady-state frames).
  final List<TrackSpawnedChunk> spawnedChunks;
}

/// Streams procedural track chunks based on camera position.
///
/// Call [step] each frame with the current camera bounds. The streamer:
/// 1. Spawns new chunks ahead of the camera (within [TrackTuning.spawnAheadMargin]).
/// 2. Culls old chunks behind the camera (beyond [TrackTuning.cullBehindMargin]).
/// 3. Rebuilds [dynamicSolids], [dynamicGroundSegments], [dynamicGroundGaps].
///
/// Pattern selection is deterministic given [seed] and chunk index.
class TrackStreamer {
  /// Creates a streamer seeded for deterministic generation.
  TrackStreamer({
    required this.seed,
    required this.tuning,
    required this.groundTopY,
    required this.patterns,
    required this.earlyPatternChunks,
    required this.noEnemyChunks,
  }) : _nextChunkIndex = 0,
       _nextChunkStartX = 0.0;

  /// RNG seed for pattern selection and spawn rolls.
  final int seed;

  /// Tuning parameters (chunk width, margins, grid snap).
  final TrackTuning tuning;

  /// World Y of the ground surface (platforms offset from this).
  final double groundTopY;

  /// Pattern pools for early vs full difficulty.
  final ChunkPatternPool patterns;

  /// Number of early chunks that use [patterns.easyPatterns].
  final int earlyPatternChunks;

  /// Number of early chunks that suppress enemy spawns.
  final int noEnemyChunks;

  int _nextChunkIndex;
  double _nextChunkStartX;

  final List<_ActiveChunk> _active = <_ActiveChunk>[];
  List<StaticSolid> _dynamicSolids = const <StaticSolid>[];
  List<StaticGroundSegment> _dynamicGroundSegments =
      const <StaticGroundSegment>[];
  List<StaticGroundGap> _dynamicGroundGaps = const <StaticGroundGap>[];

  /// Current streamed solids (excluding any caller-provided base solids).
  List<StaticSolid> get dynamicSolids => _dynamicSolids;

  /// Current streamed ground segments (excluding any base segments).
  List<StaticGroundSegment> get dynamicGroundSegments => _dynamicGroundSegments;

  /// Current streamed ground gaps (excluding any base gaps).
  List<StaticGroundGap> get dynamicGroundGaps => _dynamicGroundGaps;

  /// Advances chunk streaming based on the current camera bounds.
  ///
  /// Returns a step result (spawned chunks + whether geometry changed).
  TrackStreamStepResult step({
    required double cameraLeft,
    required double cameraRight,
    required SpawnEnemy spawnEnemy,
  }) {
    // Streaming disabled – return no-op.
    if (!tuning.enabled) {
      return const TrackStreamStepResult(
        changed: false,
        spawnedChunks: <TrackSpawnedChunk>[],
      );
    }

    var changed = false;
    final spawnedChunks = <TrackSpawnedChunk>[];

    // ── Spawn new chunks ahead of the camera ──
    final spawnLimitX = cameraRight + tuning.spawnAheadMargin;
    while (_nextChunkStartX <= spawnLimitX) {
      final chunkIndex = _nextChunkIndex;
      final startX = _nextChunkStartX;
      final endX = startX + tuning.chunkWidth;

      // Select pattern deterministically from seed + index.
      final pattern = _patternFor(seed, chunkIndex);

      // Build geometry from pattern.
      final solids = buildSolids(
        pattern,
        chunkStartX: startX,
        chunkIndex: chunkIndex,
        groundTopY: groundTopY,
        chunkWidth: tuning.chunkWidth,
        gridSnap: tuning.gridSnap,
      );
      final ground = buildGroundSegments(
        pattern,
        chunkStartX: startX,
        chunkIndex: chunkIndex,
        groundTopY: groundTopY,
        chunkWidth: tuning.chunkWidth,
        gridSnap: tuning.gridSnap,
      );

      // Track active chunk.
      _active.add(
        _ActiveChunk(
          index: chunkIndex,
          startX: startX,
          endX: endX,
          solids: solids,
          groundSegments: ground.segments,
          groundGaps: ground.gaps,
        ),
      );
      spawnedChunks.add(
        TrackSpawnedChunk(
          index: chunkIndex,
          startX: startX,
          patternName: pattern.name,
        ),
      );

      // Roll for enemy spawns.
      _spawnEnemiesForChunk(
        pattern,
        chunkIndex,
        chunkStartX: startX,
        spawnEnemy: spawnEnemy,
      );

      _nextChunkIndex += 1;
      _nextChunkStartX += tuning.chunkWidth;
      changed = true;
    }

    // ── Cull old chunks behind the camera ──
    final cullLimitX = cameraLeft - tuning.cullBehindMargin;
    while (_active.isNotEmpty && _active.first.endX < cullLimitX) {
      _active.removeAt(0); // O(n) but chunk count is small (~3-5).
      changed = true;
    }

    // ── Rebuild flattened geometry lists if anything changed ──
    if (changed) {
      final rebuilt = <StaticSolid>[];
      final rebuiltGroundSegments = <StaticGroundSegment>[];
      final rebuiltGroundGaps = <StaticGroundGap>[];
      for (final c in _active) {
        rebuilt.addAll(c.solids);
        rebuiltGroundSegments.addAll(c.groundSegments);
        rebuiltGroundGaps.addAll(c.groundGaps);
      }
      _dynamicSolids = List<StaticSolid>.unmodifiable(rebuilt);
      _dynamicGroundSegments = List<StaticGroundSegment>.unmodifiable(
        rebuiltGroundSegments,
      );
      _dynamicGroundGaps = List<StaticGroundGap>.unmodifiable(
        rebuiltGroundGaps,
      );
    }

    return TrackStreamStepResult(
      changed: changed,
      spawnedChunks: List<TrackSpawnedChunk>.unmodifiable(spawnedChunks),
    );
  }

  /// Rolls for enemy spawns defined in [pattern].
  ///
  /// Uses deterministic RNG keyed by seed, chunk index, and marker salt.
  void _spawnEnemiesForChunk(
    ChunkPattern pattern,
    int chunkIndex, {
    required double chunkStartX,
    required SpawnEnemy spawnEnemy,
  }) {
    // Early-game safety: keep first few chunks enemy-free.
    if (chunkIndex < noEnemyChunks) return;

    for (var i = 0; i < pattern.spawnMarkers.length; i += 1) {
      final m = pattern.spawnMarkers[i];

      // Deterministic roll: hash(seed, chunkIndex, markerIndex, salt).
      final roll = mix32(
        seed ^ (chunkIndex * 0x9e3779b9) ^ (i * 0x85ebca6b) ^ m.salt,
      );
      if ((roll % 100) >= m.chancePercent) continue;

      final x = chunkStartX + m.x;
      spawnEnemy(m.enemyId, x);
    }
  }

  /// Selects a chunk pattern deterministically from [seed] and [chunkIndex].
  ///
  /// Early chunks draw from [patterns.easyPatterns]; later chunks use full pool.
  ChunkPattern _patternFor(int seed, int chunkIndex) {
    final isEarly = chunkIndex < earlyPatternChunks;
    final pool = isEarly ? patterns.easyPatterns : patterns.allPatterns;
    // MurmurHash-style mix for uniform distribution.
    final h = mix32(seed ^ (chunkIndex * 0x9e3779b9) ^ 0x27d4eb2d);
    final idx = h % pool.length;
    return pool[idx];
  }
}

/// Tracks a spawned chunk's geometry while it's within camera culling bounds.
class _ActiveChunk {
  const _ActiveChunk({
    required this.index,
    required this.startX,
    required this.endX,
    required this.solids,
    required this.groundSegments,
    required this.groundGaps,
  });

  /// Sequential chunk number.
  final int index;

  /// World X where chunk begins.
  final double startX;

  /// World X where chunk ends (startX + chunkWidth).
  final double endX;

  /// Platforms and obstacles in this chunk.
  final List<StaticSolid> solids;

  /// Walkable ground spans.
  final List<StaticGroundSegment> groundSegments;

  /// Holes in the ground.
  final List<StaticGroundGap> groundGaps;
}


===== FILE: lib/core/track_manager.dart =====
/// Track streaming and geometry lifecycle management.
///
/// This module handles the procedural generation of track chunks as the
/// player progresses, maintaining both collision geometry and navigation
/// data for enemy AI.
///
/// ## Architecture
///
/// [TrackManager] is owned by [GameCore] and orchestrates:
/// - **Track streaming**: [TrackStreamer] spawns/culls chunks based on camera.
/// - **Collision geometry**: Merges base geometry with streamed chunks.
/// - **Surface graph**: Rebuilds navigation data when geometry changes.
/// - **Item spawning**: Delegates to [SpawnService] for new chunks.
///
/// ## Geometry Lifecycle
///
/// ```
/// Camera moves right
///        ↓
/// TrackStreamer.step() detects chunk spawn/cull needed
///        ↓
/// TrackManager merges base + dynamic geometry
///        ↓
/// StaticWorldGeometryIndex rebuilt (collision)
///        ↓
/// SurfaceGraphBuilder.build() (navigation)
///        ↓
/// SpawnService + enemy navigation systems receive new graphs
/// ```
///
/// ## Chunk Spawning Flow
///
/// When a new chunk enters the horizon:
/// 1. [TrackStreamer] generates platforms and enemy spawn points.
/// 2. [TrackManager] merges the new solids into collision geometry.
/// 3. Collectibles and restoration items are placed via [SpawnService].
/// 4. Surface graph is rebuilt so enemies can navigate new platforms.
library;

import 'collision/static_world_geometry_index.dart';
import 'ecs/stores/restoration_item_store.dart' show RestorationStat;
import 'ecs/systems/ground_enemy_locomotion_system.dart';
import 'ecs/systems/enemy_navigation_system.dart';
import 'enemies/enemy_id.dart';
import 'navigation/surface_graph_builder.dart';
import 'navigation/utils/jump_template.dart';
import 'snapshots/ground_surface_snapshot.dart';
import 'snapshots/static_solid_snapshot.dart';
import 'spawn_service.dart' hide StaticSolid;
import 'track/chunk_pattern_pool.dart';
import 'track/track_streamer.dart';
import 'tuning/collectible_tuning.dart';
import 'tuning/restoration_item_tuning.dart';
import 'tuning/track_tuning.dart';

// ─────────────────────────────────────────────────────────────────────────────
// Types
// ─────────────────────────────────────────────────────────────────────────────

/// Callback invoked when a chunk's enemy spawn point enters the horizon.
///
/// - [enemyId]: The type of enemy to spawn (ground or flying).
/// - [x]: The world X coordinate for the spawn.
typedef SpawnEnemyCallback = void Function(EnemyId enemyId, double x);

/// Result of a single [TrackManager.step] call.
///
/// Used by [GameCore] to decide whether to update render snapshots.
class TrackStepResult {
  const TrackStepResult({required this.geometryChanged});

  /// Whether static geometry was updated this step.
  ///
  /// When true, collision indices, surface graphs, and render snapshots
  /// have all been regenerated.
  final bool geometryChanged;
}

// ─────────────────────────────────────────────────────────────────────────────
// TrackManager
// ─────────────────────────────────────────────────────────────────────────────

/// Manages track streaming, collision geometry, and navigation graph updates.
///
/// Responsibilities:
/// - Steps [TrackStreamer] each tick to spawn/cull chunks.
/// - Merges base level geometry with dynamically streamed platforms.
/// - Rebuilds [StaticWorldGeometryIndex] for collision detection.
/// - Rebuilds [SurfaceGraph] for enemy pathfinding.
/// - Triggers collectible/item spawning for new chunks.
///
/// Usage:
/// ```dart
/// final manager = TrackManager(seed: 42, ...);
/// final result = manager.step(
///   currentTick: tick,
///   cameraLeft: cam.left,
///   cameraRight: cam.right,
///   spawnEnemy: (id, x) => spawner.spawn(id, x),
///   lowestResourceStat: () => player.lowestStat,
/// );
/// if (result.geometryChanged) {
///   // Update render snapshots
/// }
/// ```
class TrackManager {
  /// Creates a track manager with the given dependencies.
  ///
  /// - [seed]: Master RNG seed for deterministic chunk generation.
  /// - [trackTuning]: Chunk dimensions, spawn horizons, platform density.
  /// - [collectibleTuning]: Collectible spawn parameters.
  /// - [restorationItemTuning]: Restoration item spawn parameters.
  /// - [baseGeometry]: Static level geometry (ground plane, initial platforms).
  /// - [surfaceGraphBuilder]: Builder for navigation surface graphs.
  /// - [jumpTemplate]: Precomputed jump reachability for pathfinding.
  /// - [enemyNavigationSystem]: Ground enemy navigation (receives graph updates).
  /// - [groundEnemyLocomotionSystem]: Ground locomotion (receives graph updates).
  /// - [spawnService]: Entity spawner (receives surface graph updates).
  /// - [groundTopY]: Y coordinate of the ground surface (for spawning).
  /// - [patternPool]: Chunk pattern pools for procedural generation.
  /// - [earlyPatternChunks]: Number of early chunks using easy patterns.
  /// - [noEnemyChunks]: Number of early chunks that suppress enemy spawns.
  TrackManager({
    required int seed,
    required TrackTuning trackTuning,
    required CollectibleTuning collectibleTuning,
    required RestorationItemTuning restorationItemTuning,
    required StaticWorldGeometry baseGeometry,
    required SurfaceGraphBuilder surfaceGraphBuilder,
    required JumpReachabilityTemplate jumpTemplate,
    required EnemyNavigationSystem enemyNavigationSystem,
    required GroundEnemyLocomotionSystem groundEnemyLocomotionSystem,
    required SpawnService spawnService,
    required double groundTopY,
    required ChunkPatternPool patternPool,
    int earlyPatternChunks = defaultEarlyPatternChunks,
    int noEnemyChunks = defaultNoEnemyChunks,
  }) : _trackTuning = trackTuning,
       _collectibleTuning = collectibleTuning,
       _restorationItemTuning = restorationItemTuning,
       _baseGeometry = baseGeometry,
       _surfaceGraphBuilder = surfaceGraphBuilder,
       _jumpTemplate = jumpTemplate,
       _enemyNavigationSystem = enemyNavigationSystem,
       _groundEnemyLocomotionSystem = groundEnemyLocomotionSystem,
       _spawnService = spawnService,
       _patternPool = patternPool,
       _earlyPatternChunks = earlyPatternChunks,
       _noEnemyChunks = noEnemyChunks {
    // Initialize geometry state from base level.
    _staticGeometry = baseGeometry;
    _staticIndex = StaticWorldGeometryIndex.from(baseGeometry);
    _staticSolidsSnapshot = _buildStaticSolidsSnapshot(baseGeometry);
    _groundSurfacesSnapshot = _buildGroundSurfacesSnapshot(_staticIndex);

    // Create track streamer if procedural generation is enabled.
    if (_trackTuning.enabled) {
      _trackStreamer = TrackStreamer(
        seed: seed,
        tuning: _trackTuning,
        groundTopY: groundTopY,
        patterns: _patternPool,
        earlyPatternChunks: _earlyPatternChunks,
        noEnemyChunks: _noEnemyChunks,
      );
    }

    // Build initial surface graph for enemy navigation.
    _rebuildSurfaceGraph();
  }

  // ─── Dependencies ───
  final TrackTuning _trackTuning;
  final CollectibleTuning _collectibleTuning;
  final RestorationItemTuning _restorationItemTuning;
  final StaticWorldGeometry _baseGeometry;
  final SurfaceGraphBuilder _surfaceGraphBuilder;
  final JumpReachabilityTemplate _jumpTemplate;
  final EnemyNavigationSystem _enemyNavigationSystem;
  final GroundEnemyLocomotionSystem _groundEnemyLocomotionSystem;
  final SpawnService _spawnService;
  final ChunkPatternPool _patternPool;
  final int _earlyPatternChunks;
  final int _noEnemyChunks;

  // ─── Runtime State ───

  /// The track streamer (null if procedural generation is disabled).
  TrackStreamer? _trackStreamer;

  /// Version counter for surface graph rebuilds (for cache invalidation).
  int _surfaceGraphVersion = 0;

  /// Current merged geometry (base + streamed chunks).
  late StaticWorldGeometry _staticGeometry;

  /// Spatial index for broadphase collision queries.
  late StaticWorldGeometryIndex _staticIndex;

  /// Immutable snapshot of solids for the render layer.
  late List<StaticSolidSnapshot> _staticSolidsSnapshot;

  /// Immutable snapshot of walkable ground surfaces for the render layer.
  late List<GroundSurfaceSnapshot> _groundSurfacesSnapshot;

  // ───────────────────────────────────────────────────────────────────────────
  // Public API
  // ───────────────────────────────────────────────────────────────────────────

  /// Current static world geometry (base + streamed chunks).
  ///
  /// Used by physics systems for collision resolution.
  StaticWorldGeometry get staticGeometry => _staticGeometry;

  /// Spatial index for efficient collision queries.
  ///
  /// Rebuilt whenever geometry changes.
  StaticWorldGeometryIndex get staticIndex => _staticIndex;

  /// Immutable snapshot of static solids for rendering.
  ///
  /// Contains platform AABBs, side masks, and one-way flags.
  List<StaticSolidSnapshot> get staticSolidsSnapshot => _staticSolidsSnapshot;

  /// Immutable snapshot of walkable ground surfaces for rendering.
  List<GroundSurfaceSnapshot> get groundSurfacesSnapshot =>
      _groundSurfacesSnapshot;

  /// Advances the track streamer and updates geometry if needed.
  ///
  /// This method should be called once per tick with the current camera
  /// bounds. It handles:
  /// 1. Chunk spawning/culling based on camera position.
  /// 2. Geometry merging and index rebuilding.
  /// 3. Surface graph updates for enemy AI.
  /// 4. Collectible and restoration item spawning.
  ///
  /// Parameters:
  /// - [cameraLeft], [cameraRight]: Camera X bounds for horizon calculation.
  /// - [spawnEnemy]: Callback invoked for each enemy spawn point in new chunks.
  /// - [lowestResourceStat]: Returns player's lowest resource for item type selection.
  ///
  /// Returns a [TrackStepResult] indicating whether geometry changed.
  TrackStepResult step({
    required int currentTick,
    required double cameraLeft,
    required double cameraRight,
    required SpawnEnemyCallback spawnEnemy,
    required RestorationStat Function() lowestResourceStat,
  }) {
    final streamer = _trackStreamer;
    if (streamer == null) {
      // Procedural generation disabled—geometry never changes.
      return const TrackStepResult(geometryChanged: false);
    }

    // Step the streamer to spawn/cull chunks based on camera position.
    final result = streamer.step(
      cameraLeft: cameraLeft,
      cameraRight: cameraRight,
      spawnEnemy: spawnEnemy,
    );

    if (!result.changed) {
      // No chunks spawned or culled—nothing to update.
      return const TrackStepResult(geometryChanged: false);
    }

    // ─── Merge base geometry with streamed chunks ───
    final combinedSolids = <StaticSolid>[
      ..._baseGeometry.solids,
      ...streamer.dynamicSolids,
    ];
    final combinedSegments = <StaticGroundSegment>[
      ..._baseGeometry.groundSegments,
      ...streamer.dynamicGroundSegments,
    ];
    final combinedGaps = <StaticGroundGap>[
      ..._baseGeometry.groundGaps,
      ...streamer.dynamicGroundGaps,
    ];

    // Apply the new combined geometry (rebuilds index, snapshots, nav graph).
    _setStaticGeometry(
      StaticWorldGeometry(
        groundPlane: _baseGeometry.groundPlane,
        groundSegments: List<StaticGroundSegment>.unmodifiable(
          combinedSegments,
        ),
        solids: List<StaticSolid>.unmodifiable(combinedSolids),
        groundGaps: List<StaticGroundGap>.unmodifiable(combinedGaps),
      ),
    );

    // ─── Spawn items for newly created chunks ───
    if (result.spawnedChunks.isNotEmpty) {
      // Convert geometry to spawn-friendly format (avoids import cycles).
      final solidsForSpawn = _staticGeometry.solids
          .map((s) => (minX: s.minX, maxX: s.maxX, minY: s.minY, maxY: s.maxY))
          .toList();

      for (final chunk in result.spawnedChunks) {
        // Spawn collectibles if enabled.
        if (_collectibleTuning.enabled) {
          _spawnService.spawnCollectiblesForChunk(
            chunkIndex: chunk.index,
            chunkStartX: chunk.startX,
            solids: solidsForSpawn,
          );
        }

        // Spawn restoration items if enabled.
        if (_restorationItemTuning.enabled) {
          _spawnService.spawnRestorationItemForChunk(
            chunkIndex: chunk.index,
            chunkStartX: chunk.startX,
            solids: solidsForSpawn,
            lowestResourceStat: lowestResourceStat,
          );
        }
      }
    }

    return const TrackStepResult(geometryChanged: true);
  }

  // ───────────────────────────────────────────────────────────────────────────
  // Private Helpers
  // ───────────────────────────────────────────────────────────────────────────

  /// Applies new static geometry, rebuilding all derived data structures.
  ///
  /// This is the single point of geometry mutation. It ensures that the
  /// collision index, render snapshots, and navigation graph stay in sync.
  void _setStaticGeometry(StaticWorldGeometry geometry) {
    _staticGeometry = geometry;
    _staticIndex = StaticWorldGeometryIndex.from(geometry);
    _staticSolidsSnapshot = _buildStaticSolidsSnapshot(geometry);
    _groundSurfacesSnapshot = _buildGroundSurfacesSnapshot(_staticIndex);
    _rebuildSurfaceGraph();
  }

  /// Rebuilds the navigation surface graph and distributes it to consumers.
  ///
  /// The surface graph is used by:
  /// - [SpawnService]: To place items "on top of" platforms.
  /// - [EnemyNavigationSystem]: To compute jump/walk paths to the player.
  /// - [GroundEnemyLocomotionSystem]: To snap jump velocity on active edges.
  ///
  /// A version counter is incremented each rebuild so consumers can
  /// invalidate cached paths.
  void _rebuildSurfaceGraph() {
    _surfaceGraphVersion += 1;
    final result = _surfaceGraphBuilder.build(
      geometry: _staticGeometry,
      jumpTemplate: _jumpTemplate,
    );

    // Distribute new graph to spawn service.
    _spawnService.setSurfaceGraph(
      graph: result.graph,
      spatialIndex: result.spatialIndex,
    );

    // Distribute new graph to enemy AI system.
    _enemyNavigationSystem.setSurfaceGraph(
      graph: result.graph,
      spatialIndex: result.spatialIndex,
      graphVersion: _surfaceGraphVersion,
    );
    _groundEnemyLocomotionSystem.setSurfaceGraph(graph: result.graph);
  }

  /// Builds an immutable list of [StaticSolidSnapshot] from geometry.
  ///
  /// Converts internal collision representation to render-friendly format.
  static List<StaticSolidSnapshot> _buildStaticSolidsSnapshot(
    StaticWorldGeometry geometry,
  ) {
    return List<StaticSolidSnapshot>.unmodifiable(
      geometry.solids.map(
        (s) => StaticSolidSnapshot(
          minX: s.minX,
          minY: s.minY,
          maxX: s.maxX,
          maxY: s.maxY,
          sides: s.sides,
          oneWayTop: s.oneWayTop,
        ),
      ),
    );
  }

  /// Builds an immutable list of [GroundSurfaceSnapshot] from indexed geometry.
  ///
  /// Uses [StaticWorldGeometryIndex.groundSegments] so both explicit authored
  /// segments and derived plane-minus-gap segments are represented consistently.
  static List<GroundSurfaceSnapshot> _buildGroundSurfacesSnapshot(
    StaticWorldGeometryIndex index,
  ) {
    if (index.groundSegments.isEmpty) {
      return const <GroundSurfaceSnapshot>[];
    }
    return List<GroundSurfaceSnapshot>.unmodifiable(
      index.groundSegments.map(
        (segment) => GroundSurfaceSnapshot(
          minX: segment.minX,
          maxX: segment.maxX,
          topY: segment.topY,
          chunkIndex: segment.chunkIndex,
          localSegmentIndex: segment.localSegmentIndex,
        ),
      ),
    );
  }
}


===== FILE: lib/core/tuning/camera_tuning.dart =====
/// Camera auto-scroll and follow tuning.
library;

import 'dart:math';

import '../players/player_tuning.dart';

/// Vertical camera behavior mode.
enum CameraVerticalMode {
  /// Keep camera Y fixed at the authored level default.
  lockY,

  /// Follow player Y with smoothing/dead-zone.
  followPlayer,
}

class CameraTuning {
  const CameraTuning({
    this.speedLagMulX = 1.0,
    this.accelX = 1200.0,
    this.followThresholdRatio = 0.5,
    this.catchupLerp = 8.0,
    this.targetCatchupLerp = 2.5,
    this.verticalMode = CameraVerticalMode.lockY,
    this.verticalCatchupLerp = 8.0,
    this.verticalTargetCatchupLerp = 6.0,
    this.verticalDeadZone = 6.0,
  }) : assert(followThresholdRatio >= 0.0 && followThresholdRatio <= 1.0);

  /// Baseline auto-scroll lags behind `MovementTuning.maxSpeedX` by this multiplier.
  final double speedLagMulX;

  /// Acceleration used to ease camera speed toward its target speed.
  final double accelX;

  /// Threshold ratio measured from the left edge of the viewport.
  ///
  /// Threshold formula in world coordinates:
  /// `thresholdX = cameraLeft + followThresholdRatio * viewWidth`.
  ///
  /// Runner-typical guidance:
  /// - `0.45-0.65`: balanced pull-forward behavior.
  /// - closer to `0.0`: camera is pulled earlier.
  /// - closer to `1.0`: camera is pulled later.
  final double followThresholdRatio;

  /// Smoothing for camera center toward its target (per-second).
  final double catchupLerp;

  /// Smoothing for camera target toward player (per-second).
  final double targetCatchupLerp;

  /// Vertical camera behavior mode.
  final CameraVerticalMode verticalMode;

  /// Smoothing for camera center Y toward target Y (per-second).
  final double verticalCatchupLerp;

  /// Smoothing for camera target Y toward player Y (per-second).
  final double verticalTargetCatchupLerp;

  /// Dead-zone around target Y where no vertical retarget occurs.
  final double verticalDeadZone;
}

class CameraTuningDerived {
  const CameraTuningDerived({
    required this.targetSpeedX,
    required this.accelX,
    required this.followThresholdRatio,
    required this.catchupLerp,
    required this.targetCatchupLerp,
    required this.verticalMode,
    required this.verticalCatchupLerp,
    required this.verticalTargetCatchupLerp,
    required this.verticalDeadZone,
  });

  factory CameraTuningDerived.from(
    CameraTuning tuning, {
    required MovementTuningDerived movement,
  }) {
    final targetSpeedX = max(
      0.0,
      movement.base.maxSpeedX * tuning.speedLagMulX,
    );
    return CameraTuningDerived(
      targetSpeedX: targetSpeedX,
      accelX: tuning.accelX,
      followThresholdRatio: tuning.followThresholdRatio,
      catchupLerp: tuning.catchupLerp,
      targetCatchupLerp: tuning.targetCatchupLerp,
      verticalMode: tuning.verticalMode,
      verticalCatchupLerp: tuning.verticalCatchupLerp,
      verticalTargetCatchupLerp: tuning.verticalTargetCatchupLerp,
      verticalDeadZone: tuning.verticalDeadZone,
    );
  }

  final double targetSpeedX;
  final double accelX;
  final double followThresholdRatio;
  final double catchupLerp;
  final double targetCatchupLerp;
  final CameraVerticalMode verticalMode;
  final double verticalCatchupLerp;
  final double verticalTargetCatchupLerp;
  final double verticalDeadZone;
}


===== FILE: lib/core/tuning/collectible_tuning.dart =====
/// Collectible spawning and value configuration.
class CollectibleTuning {
  const CollectibleTuning({
    this.enabled = true,
    this.minPerChunk = 1,
    this.maxPerChunk = 2,
    this.spawnStartChunkIndex = 2,
    this.collectibleSize = 16.0,
    this.surfaceClearanceY = 10.0,
    this.noSpawnMargin = 2.0,
    this.minSpacingX = 80.0,
    this.chunkEdgeMarginX = 32.0,
    this.maxAttemptsPerChunk = 40,
    this.despawnBehindCameraMargin = 900.0,
    this.valuePerCollectible = 50,
  }) : assert(maxPerChunk >= minPerChunk);

  /// Master toggle for collectible spawning.
  final bool enabled;

  /// Min collectibles spawned per chunk.
  final int minPerChunk;

  /// Max collectibles spawned per chunk.
  final int maxPerChunk;

  /// First chunk index where collectibles can spawn.
  final int spawnStartChunkIndex;

  /// Collision/render size (world units).
  final double collectibleSize;

  /// Vertical clearance above surface (world units).
  final double surfaceClearanceY;

  /// Margin from surface edges to avoid clipping (world units).
  final double noSpawnMargin;

  /// Minimum horizontal spacing between collectibles (world units).
  final double minSpacingX;

  /// Margin from chunk edges (world units).
  final double chunkEdgeMarginX;

  /// Max placement attempts before giving up.
  final int maxAttemptsPerChunk;

  /// Distance behind camera before despawn (world units).
  final double despawnBehindCameraMargin;

  /// Score value per collectible.
  final int valuePerCollectible;
}


===== FILE: lib/core/tuning/core_tuning.dart =====
/// Aggregate tuning configuration for the game simulation core.
///
/// This class bundles all tuning parameters into a single object, simplifying
/// the [GameCore] constructor API. All fields have sensible defaults, so you
/// only need to override what you want to customize.

library;

import 'camera_tuning.dart';
import 'collectible_tuning.dart';
import 'flying_enemy_tuning.dart';
import 'ground_enemy_tuning.dart';
import 'navigation_tuning.dart';
import 'physics_tuning.dart';
import 'restoration_item_tuning.dart';
import 'score_tuning.dart';
import 'spatial_grid_tuning.dart';
import 'track_tuning.dart';

/// Aggregate container for all game simulation tuning parameters.
///
/// Provides a cleaner API than passing 15+ individual tuning objects to
/// [GameCore]. All fields default to their respective tuning class defaults.
class CoreTuning {
  /// Creates a core tuning configuration with optional overrides.
  ///
  /// Any parameter not specified uses its default value.
  const CoreTuning({
    this.physics = const PhysicsTuning(),
    this.unocoDemon = const UnocoDemonTuning(),
    this.groundEnemy = const GroundEnemyTuning(),
    this.navigation = const NavigationTuning(),
    this.spatialGrid = const SpatialGridTuning(),
    this.camera = const CameraTuning(),
    this.track = const TrackTuning(),
    this.collectible = const CollectibleTuning(),
    this.restorationItem = const RestorationItemTuning(),
    this.score = const ScoreTuning(),
  });

  /// Physics constants (gravity, etc.).
  final PhysicsTuning physics;

  /// Flying enemy AI and spawn parameters.
  final UnocoDemonTuning unocoDemon;

  /// Ground enemy AI and movement parameters.
  final GroundEnemyTuning groundEnemy;

  /// Pathfinding and navigation parameters.
  final NavigationTuning navigation;

  /// Spatial partitioning grid settings.
  final SpatialGridTuning spatialGrid;

  /// Camera behavior (autoscroll, smoothing).
  final CameraTuning camera;

  /// Track streaming and chunk generation.
  final TrackTuning track;

  /// Collectible spawn density and placement.
  final CollectibleTuning collectible;

  /// Restoration item spawn frequency and sizing.
  final RestorationItemTuning restorationItem;

  /// Score calculation parameters.
  final ScoreTuning score;
}


===== FILE: lib/core/tuning/flying_enemy_tuning.dart =====
/// Flying enemy AI tuning (steering, strikes).
library;

import '../util/tick_math.dart';

class UnocoDemonTuning {
  const UnocoDemonTuning({
    this.unocoDemonHoverOffsetY = 150.0,
    this.unocoDemonDesiredRangeMin = 50.0,
    this.unocoDemonDesiredRangeMax = 90.0,
    this.unocoDemonDesiredRangeHoldMinSeconds = 0.60,
    this.unocoDemonDesiredRangeHoldMaxSeconds = 1.40,
    this.unocoDemonHoldSlack = 20.0,
    this.unocoDemonMaxSpeedX = 300.0,
    this.unocoDemonSlowRadiusX = 80.0,
    this.unocoDemonAccelX = 600.0,
    this.unocoDemonDecelX = 400.0,
    this.unocoDemonMinHeightAboveGround = 60.0,
    this.unocoDemonMaxHeightAboveGround = 180.0,
    this.unocoDemonFlightTargetHoldMinSeconds = 1.5,
    this.unocoDemonFlightTargetHoldMaxSeconds = 3.0,
    this.unocoDemonMaxSpeedY = 300.0,
    this.unocoDemonVerticalKp = 4.0,
    this.unocoDemonVerticalDeadzone = 20.0,
    this.unocoDemonAimLeadMinSeconds = 0.08,
    this.unocoDemonAimLeadMaxSeconds = 0.40,
    this.unocoDemonCastCooldownSeconds = 2.5,
    this.unocoDemonCastOriginOffset = 20.0,
  });

  // ── Steering ──

  /// Vertical offset above player when hovering (world units).
  final double unocoDemonHoverOffsetY;

  /// Min horizontal range to maintain from player (world units).
  final double unocoDemonDesiredRangeMin;

  /// Max horizontal range to maintain from player (world units).
  final double unocoDemonDesiredRangeMax;

  /// Min time to hold a desired range before picking new (seconds).
  final double unocoDemonDesiredRangeHoldMinSeconds;

  /// Max time to hold a desired range (seconds).
  final double unocoDemonDesiredRangeHoldMaxSeconds;

  /// Slack distance before recalculating position (world units).
  final double unocoDemonHoldSlack;

  /// Max horizontal speed (world units/sec).
  final double unocoDemonMaxSpeedX;

  /// Distance from target where decel starts (world units).
  final double unocoDemonSlowRadiusX;

  /// Horizontal acceleration (world units/sec²).
  final double unocoDemonAccelX;

  /// Horizontal deceleration (world units/sec²).
  final double unocoDemonDecelX;

  /// Min height above ground (world units).
  final double unocoDemonMinHeightAboveGround;

  /// Max height above ground (world units).
  final double unocoDemonMaxHeightAboveGround;

  /// Min time to hold a flight target (seconds).
  final double unocoDemonFlightTargetHoldMinSeconds;

  /// Max time to hold a flight target (seconds).
  final double unocoDemonFlightTargetHoldMaxSeconds;

  /// Max vertical speed (world units/sec).
  final double unocoDemonMaxSpeedY;

  /// Proportional gain for vertical steering.
  final double unocoDemonVerticalKp;

  /// Deadzone for vertical error (world units).
  final double unocoDemonVerticalDeadzone;

  // ── Strikes ──

  /// Min lead time when aiming at player (seconds).
  final double unocoDemonAimLeadMinSeconds;

  /// Max lead time when aiming at player (seconds).
  final double unocoDemonAimLeadMaxSeconds;

  /// Cooldown between casts (seconds).
  final double unocoDemonCastCooldownSeconds;

  /// Projectile spawn offset from center (world units).
  final double unocoDemonCastOriginOffset;
}

class UnocoDemonTuningDerived {
  const UnocoDemonTuningDerived._({
    required this.tickHz,
    required this.base,
    required this.unocoDemonCastCooldownTicks,
  });

  factory UnocoDemonTuningDerived.from(
    UnocoDemonTuning base, {
    required int tickHz,
  }) {
    if (tickHz <= 0) {
      throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
    }

    return UnocoDemonTuningDerived._(
      tickHz: tickHz,
      base: base,
      unocoDemonCastCooldownTicks: ticksFromSecondsCeil(
        base.unocoDemonCastCooldownSeconds,
        tickHz,
      ),
    );
  }

  final int tickHz;
  final UnocoDemonTuning base;

  final int unocoDemonCastCooldownTicks;
}


===== FILE: lib/core/tuning/ground_enemy_tuning.dart =====
/// Ground enemy AI tuning grouped by navigation/engagement/locomotion/combat.
library;

import '../util/tick_math.dart';

class GroundEnemyTuning {
  const GroundEnemyTuning({
    this.navigation = const GroundEnemyNavigationTuning(),
    this.engagement = const GroundEnemyEngagementTuning(),
    this.locomotion = const GroundEnemyLocomotionTuning(),
    this.combat = const GroundEnemyCombatTuning(),
  });

  final GroundEnemyNavigationTuning navigation;
  final GroundEnemyEngagementTuning engagement;
  final GroundEnemyLocomotionTuning locomotion;
  final GroundEnemyCombatTuning combat;
}

/// Navigation tuning (chase offset + speed variance).
class GroundEnemyNavigationTuning {
  const GroundEnemyNavigationTuning({
    this.chaseOffsetMaxX = 18.0,
    this.chaseOffsetMinAbsX = 6.0,
    this.chaseOffsetMeleeX = 3.0,
    this.chaseSpeedScaleMin = 0.92,
    this.chaseSpeedScaleMax = 1.08,
    this.chaseTargetDelayTicks = 6,
  });

  /// Max random chase offset from player (world units).
  final double chaseOffsetMaxX;

  /// Min absolute chase offset (prevents clumping).
  final double chaseOffsetMinAbsX;

  /// Chase offset when in melee range (world units).
  final double chaseOffsetMeleeX;

  /// Min speed scale for chase variance.
  final double chaseSpeedScaleMin;

  /// Max speed scale for chase variance.
  final double chaseSpeedScaleMax;

  /// Fixed reaction delay (in simulation ticks) applied to chase targeting.
  ///
  /// The navigation system will chase the player's (or predicted) target X from
  /// `delayTicks` ago, producing a deterministic "reaction time" feel.
  ///
  /// Example: At 60 Hz, `6` ticks ≈ 100ms.
  final int chaseTargetDelayTicks;
}

/// Engagement tuning (slot selection + melee state movement).
class GroundEnemyEngagementTuning {
  const GroundEnemyEngagementTuning({
    this.meleeEngageBufferX = 4.0,
    this.meleeEngageHysteresisX = 2.0,
    this.meleeArriveSlowRadiusX = 12.0,
    this.meleeStrikeSpeedMul = 0.25,
    this.meleeRecoverSpeedMul = 0.5,
  });

  /// Extra buffer beyond melee range to enter engage state.
  final double meleeEngageBufferX;

  /// Hysteresis added to engage buffer for disengage threshold.
  final double meleeEngageHysteresisX;

  /// Radius within which arrival steering slows to zero.
  final double meleeArriveSlowRadiusX;

  /// Speed multiplier during strike state.
  final double meleeStrikeSpeedMul;

  /// Speed multiplier during recover state.
  final double meleeRecoverSpeedMul;
}

/// Locomotion tuning (movement + jump).
class GroundEnemyLocomotionTuning {
  const GroundEnemyLocomotionTuning({
    this.speedX = 300.0,
    this.stopDistanceX = 6.0,
    this.accelX = 600.0,
    this.decelX = 400.0,
    this.jumpSpeed = 500.0,
  });

  /// Target horizontal speed (world units/sec).
  final double speedX;

  /// Distance at which enemy stops chasing (world units).
  final double stopDistanceX;

  /// Horizontal acceleration (world units/sec^2).
  final double accelX;

  /// Horizontal deceleration (world units/sec^2).
  final double decelX;

  /// Jump velocity (world units/sec, positive = upward).
  final double jumpSpeed;
}

/// Combat tuning (melee timing + damage).
class GroundEnemyCombatTuning {
  const GroundEnemyCombatTuning({
    this.meleeRangeX = 52.0,
    this.meleeCooldownSeconds = 1.0,
    this.meleeActiveSeconds = 0.10,
    this.meleeAnimSeconds = 0.60,
    this.meleeWindupSeconds = 0.18,
    this.meleeDamage = 5.0,
    this.meleeHitboxSizeX = 56.0,
    this.meleeHitboxSizeY = 32.0,
  });

  /// Horizontal range to trigger melee strike (world units).
  final double meleeRangeX;

  /// Cooldown between melee strikes (seconds).
  final double meleeCooldownSeconds;

  /// Duration melee hitbox is active (seconds).
  final double meleeActiveSeconds;

  /// Duration the melee strike animation should be visible (seconds).
  ///
  /// This can be longer than [meleeActiveSeconds] since the hitbox
  /// window is often only a subset of the full animation.
  final double meleeAnimSeconds;

  /// Telegraph window before the melee hitbox becomes active (seconds).
  ///
  /// This delays hitbox spawn relative to the start of the strike animation.
  final double meleeWindupSeconds;

  /// Damage dealt by melee strike.
  final double meleeDamage;

  /// Melee hitbox width (world units).
  final double meleeHitboxSizeX;

  /// Melee hitbox height (world units).
  final double meleeHitboxSizeY;
}

class GroundEnemyTuningDerived {
  const GroundEnemyTuningDerived._({
    required this.tickHz,
    required this.base,
    required this.navigation,
    required this.engagement,
    required this.locomotion,
    required this.combat,
  });

  factory GroundEnemyTuningDerived.from(
    GroundEnemyTuning base, {
    required int tickHz,
  }) {
    if (tickHz <= 0) {
      throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
    }

    final combat = base.combat;
    final engagement = base.engagement;

    final meleeStandOffX = () {
      final desired = combat.meleeHitboxSizeX * (2.0 / 3.0);
      if (desired.isNaN || desired.isInfinite) return 0.0;
      final clampedToRange = desired > combat.meleeRangeX
          ? combat.meleeRangeX
          : desired;
      return clampedToRange < 0.0 ? 0.0 : clampedToRange;
    }();

    return GroundEnemyTuningDerived._(
      tickHz: tickHz,
      base: base,
      navigation: base.navigation,
      engagement: GroundEnemyEngagementTuningDerived(
        meleeEngageBufferX: engagement.meleeEngageBufferX,
        meleeEngageHysteresisX: engagement.meleeEngageHysteresisX,
        meleeArriveSlowRadiusX: engagement.meleeArriveSlowRadiusX,
        meleeStrikeSpeedMul: engagement.meleeStrikeSpeedMul,
        meleeRecoverSpeedMul: engagement.meleeRecoverSpeedMul,
        meleeStandOffX: meleeStandOffX,
      ),
      locomotion: base.locomotion,
      combat: () {
        final meleeCooldownTicks = ticksFromSecondsCeil(
          combat.meleeCooldownSeconds,
          tickHz,
        );
        final meleeActiveTicks = ticksFromSecondsCeil(
          combat.meleeActiveSeconds,
          tickHz,
        );
        final meleeAnimTicks = ticksFromSecondsCeil(
          combat.meleeAnimSeconds,
          tickHz,
        );
        final rawWindupTicks = ticksFromSecondsCeil(
          combat.meleeWindupSeconds,
          tickHz,
        );
        // Ensure the hit tick occurs while the strike animation is still visible.
        final maxWindupTicks = meleeAnimTicks > 0 ? meleeAnimTicks - 1 : 0;
        final meleeWindupTicks = rawWindupTicks > maxWindupTicks
            ? maxWindupTicks
            : rawWindupTicks;
        return GroundEnemyCombatTuningDerived(
          meleeRangeX: combat.meleeRangeX,
          meleeCooldownSeconds: combat.meleeCooldownSeconds,
          meleeActiveSeconds: combat.meleeActiveSeconds,
          meleeAnimSeconds: combat.meleeAnimSeconds,
          meleeWindupSeconds: combat.meleeWindupSeconds,
          meleeDamage: combat.meleeDamage,
          meleeHitboxSizeX: combat.meleeHitboxSizeX,
          meleeHitboxSizeY: combat.meleeHitboxSizeY,
          meleeCooldownTicks: meleeCooldownTicks,
          meleeActiveTicks: meleeActiveTicks,
          meleeAnimTicks: meleeAnimTicks,
          meleeWindupTicks: meleeWindupTicks,
        );
      }(),
    );
  }

  final int tickHz;
  final GroundEnemyTuning base;
  final GroundEnemyNavigationTuning navigation;
  final GroundEnemyEngagementTuningDerived engagement;
  final GroundEnemyLocomotionTuning locomotion;
  final GroundEnemyCombatTuningDerived combat;
}

class GroundEnemyEngagementTuningDerived extends GroundEnemyEngagementTuning {
  const GroundEnemyEngagementTuningDerived({
    required super.meleeEngageBufferX,
    required super.meleeEngageHysteresisX,
    required super.meleeArriveSlowRadiusX,
    required super.meleeStrikeSpeedMul,
    required super.meleeRecoverSpeedMul,
    required this.meleeStandOffX,
  });

  /// Stand-off target used in engage/strike/recover phases.
  ///
  /// Derived from [GroundEnemyCombatTuning.meleeHitboxSizeX] so the player
  /// sits well within the hitbox when the enemy is at its preferred slot.
  final double meleeStandOffX;
}

class GroundEnemyCombatTuningDerived extends GroundEnemyCombatTuning {
  const GroundEnemyCombatTuningDerived({
    required super.meleeRangeX,
    required super.meleeCooldownSeconds,
    required super.meleeActiveSeconds,
    required super.meleeAnimSeconds,
    required super.meleeWindupSeconds,
    required super.meleeDamage,
    required super.meleeHitboxSizeX,
    required super.meleeHitboxSizeY,
    required this.meleeCooldownTicks,
    required this.meleeActiveTicks,
    required this.meleeAnimTicks,
    required this.meleeWindupTicks,
  });

  final int meleeCooldownTicks;
  final int meleeActiveTicks;
  final int meleeAnimTicks;
  final int meleeWindupTicks;
}


===== FILE: lib/core/tuning/navigation_tuning.dart =====
/// Navigation tuning for surface-graph based AI.
///
/// This is intentionally separate from movement/combat tunings:
/// - movement tuning controls the player's physical feel
/// - enemy tuning controls per-enemy locomotion abilities
/// - navigation tuning controls pathfinding + graph build tradeoffs
library;
import '../navigation/types/nav_tolerances.dart';

class NavigationTuning {
  const NavigationTuning({
    this.repathCooldownTicks = 12,
    this.maxExpandedNodes = 128,
    this.edgePenaltySeconds = 0.05,
    this.surfaceEps = navSpatialEps,
    this.takeoffEpsMin = 4.0,
    this.takeoffSampleMaxStep = 64.0,
  }) : assert(repathCooldownTicks >= 0),
       assert(maxExpandedNodes > 0),
       assert(edgePenaltySeconds >= 0.0),
       assert(surfaceEps > 0.0),
       assert(takeoffEpsMin >= 0.0),
       assert(takeoffSampleMaxStep > 0.0);

  /// Throttle replans per entity to avoid per-tick A* on mobile.
  ///
  /// Default `12` ticks is ~200 ms at 60 Hz: responsive enough for pursuit
  /// changes while still avoiding per-frame replanning churn.
  final int repathCooldownTicks;

  /// Hard cap on A* node expansions (fail fast deterministically).
  final int maxExpandedNodes;

  /// Small per-edge penalty that biases toward fewer hops when costs tie.
  final double edgePenaltySeconds;

  /// Vertical tolerance when locating the current/target surface (world units).
  final double surfaceEps;

  /// Minimum horizontal tolerance for "close enough to takeoff" (world units).
  ///
  /// The actual takeoff epsilon can be increased by the locomotion controller
  /// (e.g. tied to an enemy's stop distance) to avoid "stops too early to jump".
  /// Default `4` units gives stable jump/drop triggering for slower movers
  /// that do not override this with a larger stop distance.
  final double takeoffEpsMin;

  /// Maximum step between takeoff samples on long surfaces (world units).
  final double takeoffSampleMaxStep;
}


===== FILE: lib/core/tuning/physics_tuning.dart =====
/// Global physics tuning for the Core simulation.
///
/// This is intentionally separate from movement/ability/combat tunings so it can
/// evolve into per-level/biome physics profiles later (e.g. low-gravity zones).
class FixedPointPilotTuning {
  const FixedPointPilotTuning({
    this.enabled = false,
    this.subpixelScale = 1024,
  }) : assert(subpixelScale > 0);

  /// Enables fixed-point quantization in selected motion/collision paths.
  final bool enabled;

  /// Quantization scale for world units when pilot mode is enabled.
  final int subpixelScale;
}

class PhysicsTuning {
  const PhysicsTuning({
    this.gravityY = 1200,
    this.fixedPointPilot = const FixedPointPilotTuning(),
  });

  /// Gravity acceleration (positive is downward), in world units / second^2.
  final double gravityY;

  /// Optional fixed-point pilot configuration (default-off).
  final FixedPointPilotTuning fixedPointPilot;
}



===== FILE: lib/core/tuning/restoration_item_tuning.dart =====
/// Restoration item spawning and restore configuration.
class RestorationItemTuning {
  const RestorationItemTuning({
    this.enabled = true,
    this.spawnEveryChunks = 16,
    this.spawnStartChunkIndex = 2,
    this.restorePercentBp = 3000,
    this.itemSize = 16.0,
    this.surfaceClearanceY = 10.0,
    this.noSpawnMargin = 2.0,
    this.chunkEdgeMarginX = 32.0,
    this.maxAttemptsPerSpawn = 40,
    this.despawnBehindCameraMargin = 900.0,
  });

  /// Master toggle for restoration item spawning.
  final bool enabled;

  /// Spawn one item every N chunks.
  final int spawnEveryChunks;

  /// First chunk index where items can spawn.
  final int spawnStartChunkIndex;

  /// Fraction of max HP/mana/stamina restored in basis points (100 = 1%).
  final int restorePercentBp;

  /// Collision/render size (world units).
  final double itemSize;

  /// Vertical clearance above surface (world units).
  final double surfaceClearanceY;

  /// Margin from surface edges (world units).
  final double noSpawnMargin;

  /// Margin from chunk edges (world units).
  final double chunkEdgeMarginX;

  /// Max placement attempts before giving up.
  final int maxAttemptsPerSpawn;

  /// Distance behind camera before despawn (world units).
  final double despawnBehindCameraMargin;
}


===== FILE: lib/core/tuning/score_tuning.dart =====
/// Scoring tuning (points per time, distance, kills).
library;

/// World units per meter (used for distance→score conversion).
const int kWorldUnitsPerMeter = 50;

class ScoreTuning {
  const ScoreTuning({
    this.timeScorePerSecond = 5,
    this.distanceScorePerMeter = 5,
    this.groundEnemyKillScore = 100,
    this.unocoDemonKillScore = 150,
  }) : assert(timeScorePerSecond >= 0),
       assert(distanceScorePerMeter >= 0),
       assert(groundEnemyKillScore >= 0),
       assert(unocoDemonKillScore >= 0);

  /// Points per real-time second survived (implemented deterministically via tickHz).
  final int timeScorePerSecond;

  /// Points per whole meter traveled (50 world units = 1 meter).
  final int distanceScorePerMeter;

  /// Points for killing an enemy (by type).
  final int groundEnemyKillScore;
  final int unocoDemonKillScore;
}


===== FILE: lib/core/tuning/spatial_grid_tuning.dart =====
/// Simulation tuning/config for grid-based spatial indexing (broadphase now,
/// navigation later).
///
/// Keep this separate from combat tuning: broadphase is a physics/simulation
/// concern, not a combat rule.
class SpatialGridTuning {
  const SpatialGridTuning({
    this.broadphaseCellSize = 32.0,
  });

  /// Default broadphase cell size for dynamic AABB queries.
  ///
  /// With current collider sizes (player ~16x16, enemies ~24x24), `32.0`
  /// keeps candidate sets small while keeping grid math cheap.
  final double broadphaseCellSize;
}



===== FILE: lib/core/tuning/track_tuning.dart =====
/// Track streaming / deterministic chunk spawning configuration.
///
/// This is simulation config (Core), not combat/ability tuning.
class TrackTuning {
  const TrackTuning({
    this.enabled = true,
    this.chunkWidth = 600.0,
    this.spawnAheadMargin = 600.0,
    this.cullBehindMargin = 600.0,
    this.enemyCullBelowGroundOffsetY = 300.0,
    this.gridSnap = 16.0,
    this.playerStartX = 300.0,
    this.gapKillOffsetY = 400.0,
  }) : assert(chunkWidth > 0),
       assert(spawnAheadMargin >= 0),
       assert(cullBehindMargin >= 0),
       assert(enemyCullBelowGroundOffsetY >= 0),
       assert(gridSnap > 0),
       assert(playerStartX >= 0),
       assert(gapKillOffsetY >= 0);

  /// If false, no chunk streaming is performed (static world only).
  final bool enabled;

  /// Width of a chunk in world units.
  final double chunkWidth;

  /// Spawn chunks while `cameraRight + spawnAheadMargin >= nextChunkStartX`.
  final double spawnAheadMargin;

  /// Cull chunks while `chunkEndX < cameraLeft - cullBehindMargin`.
  final double cullBehindMargin;

  /// Enemies are despawned if their bottom falls this far below groundTopY.
  final double enemyCullBelowGroundOffsetY;

  /// Authoring grid snap for chunk patterns (world units).
  final double gridSnap;

  /// Player spawn X position at run start (world units).
  final double playerStartX;

  /// How far below ground the player must fall before death triggers.
  ///
  /// Set high enough to give visual feedback of falling into the gap
  /// before the death screen appears.
  final double gapKillOffsetY;
}


===== FILE: lib/core/tuning/utils/anim_tuning.dart =====
/// Animation tuning helper utilities (Core-owned, deterministic).
///
/// This module is intentionally generic so it can be reused by player/enemy
/// tuning without taking a dependency on any specific character system.
library;

/// Computes a recommended duration for a strip based on frame count and step time.
double secondsForStrip({
  required int frameCount,
  required double stepTimeSeconds,
}) {
  if (frameCount <= 0 || stepTimeSeconds <= 0) return 0.0;
  return frameCount * stepTimeSeconds;
}

/// Computes strip duration for a specific [key] from tuning maps.
///
/// Works with any key type (enums, ints, strings) to keep it reusable.
double secondsForKey<K>({
  required K key,
  required Map<K, int> frameCounts,
  required Map<K, double> stepTimeSecondsByKey,
  int defaultFrameCount = 1,
  double defaultStepTimeSeconds = 0.10,
}) {
  final frames = frameCounts[key] ?? defaultFrameCount;
  final step = stepTimeSecondsByKey[key] ?? defaultStepTimeSeconds;
  return secondsForStrip(frameCount: frames, stepTimeSeconds: step);
}



===== FILE: lib/core/util/deterministic_rng.dart =====
/// Deterministic random number generation utilities.
///
/// Provides seedable, reproducible pseudo-random numbers for procedural
/// generation. Uses Xorshift32 (fast, small state) with MurmurHash3 mixing
/// for seed avalanche. All functions are pure and tick-deterministic.
library;

/// Bitmask for 32-bit unsigned integer operations.
const int _mask32 = 0xffffffff;

/// Fallback seed when mixing produces zero (Xorshift32 degenerates on zero).
const int _nonZeroSeed = 0x6d2b79f5;

/// MurmurHash3 finalizer-style bit mixer.
///
/// Produces a well-distributed 32-bit hash from any integer input.
/// Used to "avalanche" seed bits before RNG initialization.
int mix32(int x) {
  var v = x & _mask32;
  v ^= (v >> 16);
  v = (v * 0x7feb352d) & _mask32;
  v ^= (v >> 15);
  v = (v * 0x846ca68b) & _mask32;
  v ^= (v >> 16);
  return v & _mask32;
}

/// Derives a non-zero 32-bit RNG state from [seed] and [salt].
///
/// XORs seed with salt, then mixes. Guarantees non-zero output to
/// prevent Xorshift32 from degenerating into a constant sequence.
int seedFrom(int seed, int salt) {
  final mixed = mix32(seed ^ salt);
  return mixed == 0 ? _nonZeroSeed : mixed;
}

/// Advances [state] by one Xorshift32 step, returning the new state.
///
/// The returned value serves as both the next state and the random output.
/// Period: 2³²−1. Passes most statistical tests for game use.
int nextUint32(int state) {
  var x = state & _mask32;
  if (x == 0) x = _nonZeroSeed; // Guard against degenerate zero state.
  x ^= (x << 13) & _mask32;
  x ^= (x >> 17);
  x ^= (x << 5) & _mask32;
  return x & _mask32;
}

/// Converts a 32-bit unsigned [value] to a double in \[0, 1\].
///
/// Uses simple division for uniform distribution. Inclusive on both ends.
double uint32ToUnitDouble(int value) {
  return (value & _mask32) / _mask32;
}

/// Maps a 32-bit unsigned [value] to a double in \[[min], [max]\].
///
/// Automatically swaps [min]/[max] if inverted. Distribution is uniform.
double rangeDouble(int value, double min, double max) {
  final lo = min <= max ? min : max;
  final hi = min <= max ? max : min;
  return lo + (hi - lo) * uint32ToUnitDouble(value);
}


===== FILE: lib/core/util/double_math.dart =====
/// Floating-point math helpers.
///
/// Supplements `dart:math` with common operations not in the standard library.
library;

import 'dart:math';

/// Clamps [v] to the range \[[lo], [hi]\].
///
/// Returns [lo] if `v < lo`, [hi] if `v > hi`, otherwise [v].
double clampDouble(double v, double lo, double hi) => max(lo, min(hi, v));



===== FILE: lib/core/util/fixed_math.dart =====
/// Fixed-point math helpers for deterministic simulation.
///
/// Units:
/// - Fixed100: 100 = 1.00
/// - Basis Points (bp): 100 = 1%, 10000 = 100%
library;

import 'dart:math';

const int fixedScale = 100;
const int bpScale = 10000;

/// Default subpixel scale for the fixed-point physics pilot.
///
/// `1024` means positions/velocities are quantized to 1/1024 world units.
const int defaultPhysicsSubpixelScale = 1024;

/// Converts a double to fixed-point (100 = 1.0).
int toFixed100(double value) => (value * fixedScale).round();

/// Converts a double to basis points (100 = 1%).
int toBp(double value) => (value * bpScale).round();

/// Converts fixed-point (100 = 1.0) to double.
double fromFixed100(int value) => value / fixedScale;

/// Quantizes a floating-point value to a fixed [scale] grid.
double quantizeToScale(double value, int scale) {
  assert(scale > 0);
  return (value * scale).round() / scale;
}

/// Integrates `position += velocity * dt` using deterministic fixed-point math.
///
/// [velocityPerSecond] is in world units per second.
/// [tickHz] is the fixed simulation tick rate.
double integratePerTickFixed({
  required double position,
  required double velocityPerSecond,
  required int tickHz,
  required int scale,
}) {
  assert(tickHz > 0);
  assert(scale > 0);
  final posScaled = (position * scale).round();
  final velScaled = (velocityPerSecond * scale).round();
  final deltaScaled = _divideRoundNearest(velScaled, tickHz);
  return (posScaled + deltaScaled) / scale;
}

/// Computes per-tick velocity delta from acceleration using fixed-point math.
///
/// [accelerationPerSecondSq] is in world units per second squared.
double accelerationDeltaPerTickFixed({
  required double accelerationPerSecondSq,
  required int tickHz,
  required int scale,
}) {
  assert(tickHz > 0);
  assert(scale > 0);
  final accelScaled = (accelerationPerSecondSq * scale).round();
  final deltaScaled = _divideRoundNearest(accelScaled, tickHz);
  return deltaScaled / scale;
}

/// Clamps [v] to the range [lo, hi].
int clampInt(int v, int lo, int hi) => max(lo, min(hi, v));

/// Scales [value] by a basis-point modifier.
///
/// Example: value=1000, bonusBp=2000 (+20%) -> 1200.
int applyBp(int value, int bonusBp) =>
    (value * (bpScale + bonusBp)) ~/ bpScale;

int _divideRoundNearest(int numerator, int denominator) {
  assert(denominator > 0);
  final half = denominator ~/ 2;
  if (numerator >= 0) {
    return (numerator + half) ~/ denominator;
  }
  return -((-numerator + half) ~/ denominator);
}



===== FILE: lib/core/util/smoothing.dart =====
/// Smoothing utilities for frame-rate-independent interpolation.
///
/// Provides exponential smoothing factors that behave consistently
/// regardless of tick rate, useful for camera follow, UI animations, etc.
library;

import 'dart:math';

/// Returns an exponential smoothing factor α in \[0, 1\].
///
/// Given responsiveness [k] (1/seconds) and tick duration [dtSeconds],
/// computes `α = 1 − e^(−k·dt)`. Use as: `value += α * (target − value)`.
///
/// Matches the common pattern: `alpha = 1 - exp(-k * dt)`.
double expSmoothingFactor(double k, double dtSeconds) {
  if (k <= 0) return 0.0;
  if (dtSeconds <= 0) return 0.0;
  return 1.0 - exp(-k * dtSeconds);
}



===== FILE: lib/core/util/tick_math.dart =====
/// Tick/time conversion utilities.
///
/// Bridges between author-friendly seconds and simulation tick counts.
library;

import 'dart:math';

/// Converts [seconds] to tick count at [tickHz], rounding up.
///
/// Rules:
/// - `seconds <= 0` => `0` ticks
/// - otherwise `max(1, ceil(seconds * tickHz))`
int ticksFromSecondsCeil(double seconds, int tickHz) {
  if (tickHz <= 0) {
    throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
  }
  if (seconds <= 0) return 0;
  return max(1, (seconds * tickHz).ceil());
}



===== FILE: lib/core/util/vec2.dart =====
/// Minimal 2D vector type for Core ↔ UI data transfer.
///
/// Immutable, allocation-light, pure Dart. Used in snapshots and events.
/// Internal systems prefer raw `double` fields for hot loops.
library;

/// Immutable 2D vector with [x] and [y] coordinates.
class Vec2 {
  /// Creates a new immutable vector at ([x], [y]).
  const Vec2(this.x, this.y);

  /// Zero vector (0, 0).
  static const Vec2 zero = Vec2(0, 0);

  /// X coordinate (Horizontal), usually in world units/pixels.
  final double x;

  /// Y coordinate (Vertical), usually in world units/pixels.
  final double y;

  /// Returns a new [Vec2] with [x] replaced by [value].
  Vec2 withX(double value) => Vec2(value, y);

  /// Returns a new [Vec2] with [y] replaced by [value].
  Vec2 withY(double value) => Vec2(x, value);

  /// Component-wise Addition.
  Vec2 operator +(Vec2 other) => Vec2(x + other.x, y + other.y);

  /// Component-wise Subtraction.
  Vec2 operator -(Vec2 other) => Vec2(x - other.x, y - other.y);

  /// Scalar Multiplication.
  Vec2 scale(double factor) => Vec2(x * factor, y * factor);

  @override
  String toString() => 'Vec2(${x.toStringAsFixed(2)}, ${y.toStringAsFixed(2)})';
  
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Vec2 &&
          runtimeType == other.runtimeType &&
          x == other.x &&
          y == other.y;

  @override
  int get hashCode => x.hashCode ^ y.hashCode;
}


===== FILE: lib/core/util/velocity_math.dart =====
/// Velocity ramping utilities.
///
/// Helpers for smoothly accelerating/decelerating toward a target speed,
/// used by player and enemy movement systems.
library;

/// Ramps [current] velocity toward [desired] using asymmetric accel/decel.
///
/// - Accelerates at [accelPerSecond] when moving toward non-zero [desired].
/// - Decelerates at [decelPerSecond] when [desired] is zero.
/// - Snaps to zero if `|current| <= minStopSpeed` and `desired == 0`.
///
/// Returns the updated velocity after [dtSeconds].
double applyAccelDecel({
  required double current,
  required double desired,
  required double dtSeconds,
  required double accelPerSecond,
  required double decelPerSecond,
  double minStopSpeed = 0.0,
}) {
  if (dtSeconds <= 0.0) return current;
  if (desired == 0.0 && current.abs() <= minStopSpeed) return 0.0;

  final accel = desired == 0.0 ? decelPerSecond : accelPerSecond;
  final maxDelta = accel * dtSeconds;
  final delta = desired - current;
  if (delta.abs() > maxDelta) {
    return current + (delta > 0.0 ? maxDelta : -maxDelta);
  }
  return desired;
}


===== FILE: lib/core/weapons/weapon_catalog.dart =====
import '../abilities/ability_def.dart' show WeaponType;
import 'weapon_category.dart';
import 'weapon_def.dart';
import 'weapon_id.dart';
import '../stats/gear_stat_bonuses.dart';

/// Lookup table for weapon definitions.
///
/// Similar to [ProjectileCatalog], but for melee weapons.
class WeaponCatalog {
  const WeaponCatalog();

  WeaponDef get(WeaponId id) {
    switch (id) {
      case WeaponId.woodenSword:
        return const WeaponDef(
          id: WeaponId.woodenSword,
          category: WeaponCategory.primary,
          weaponType: WeaponType.oneHandedSword,
          stats: GearStatBonuses(powerBonusBp: -100), // -1% Damage
        );
      case WeaponId.basicSword:
        return const WeaponDef(
          id: WeaponId.basicSword,
          category: WeaponCategory.primary,
          weaponType: WeaponType.oneHandedSword,
          stats: GearStatBonuses(powerBonusBp: 100), // +1% Damage
        );
      case WeaponId.solidSword:
        return const WeaponDef(
          id: WeaponId.solidSword,
          category: WeaponCategory.primary,
          weaponType: WeaponType.oneHandedSword,
          stats: GearStatBonuses(powerBonusBp: 200), // +2% Damage
        );
      case WeaponId.woodenShield:
        return const WeaponDef(
          id: WeaponId.woodenShield,
          category: WeaponCategory.offHand,
          weaponType: WeaponType.shield,
          stats: GearStatBonuses(powerBonusBp: -100), // -1% Damage
        );
      case WeaponId.basicShield:
        return const WeaponDef(
          id: WeaponId.basicShield,
          category: WeaponCategory.offHand,
          weaponType: WeaponType.shield,
          stats: GearStatBonuses(powerBonusBp: 100), // +1% Damage (existing)
        );
      case WeaponId.solidShield:
        return const WeaponDef(
          id: WeaponId.solidShield,
          category: WeaponCategory.offHand,
          weaponType: WeaponType.shield,
          stats: GearStatBonuses(powerBonusBp: 200), // +2% Damage
        );
    }
  }

  WeaponDef? tryGet(WeaponId id) {
    try {
      return get(id);
    } catch (_) {
      return null;
    }
  }
}


===== FILE: lib/core/weapons/weapon_category.dart =====
/// Equipment slot category for weapons.
///
/// This determines which equipment slot(s) a weapon occupies,
/// not which ability slots it can power.
enum WeaponCategory {
  /// Main hand weapons (swords, axes, spears).
  primary,

  /// Off-hand equipment (shields, daggers, torches).
  offHand,

  /// Throwing weapons (knives, axes).
  projectile,
}


===== FILE: lib/core/weapons/weapon_def.dart =====
import '../abilities/ability_def.dart' show WeaponType;
import '../combat/damage_type.dart';
import 'weapon_category.dart';
import 'weapon_id.dart';
import 'weapon_proc.dart';
import '../stats/gear_stat_bonuses.dart';

/// Static, data-first definition for a melee weapon.
///
/// Weapon definitions are queried by [WeaponId] and used by intent writers
/// (e.g. [AbilityActivationSystem]) to fill combat metadata like damage type and
/// on-hit status profiles.
class WeaponDef {
  const WeaponDef({
    required this.id,
    required this.category,
    required this.weaponType,
    this.damageType = DamageType.physical,
    this.procs = const [],
    this.stats = const GearStatBonuses(),
    this.isTwoHanded = false,
  });

  final WeaponId id;

  /// Equipment slot category (primary/offHand/projectile).
  final WeaponCategory category;

  /// Visual/functional family (used for ability gating).
  final WeaponType weaponType;

  /// Default damage type applied to hits.
  final DamageType damageType;

  /// New, extensible proc list (Phase 2+).
  final List<WeaponProc> procs;

  /// Passive stats provided by this weapon (future use).
  final GearStatBonuses stats;

  /// If true, occupies both Primary + Secondary equipment slots.
  /// Enforcement is equip-time validation (Phase 3/4).
  final bool isTwoHanded;
}


===== FILE: lib/core/weapons/weapon_id.dart =====
/// Stable identifiers for melee weapons.
///
/// These IDs are intended to be deterministic and allocation-light, similar to
/// projectile item IDs used for the projectile slot.
enum WeaponId {
  /// Default starter weapon.
  woodenSword,
  basicSword,
  solidSword,
  woodenShield,
  basicShield,
  solidShield,
}


===== FILE: lib/core/weapons/weapon_proc.dart =====
import '../combat/status/status.dart';

/// Hook points where weapon procs can trigger.
enum ProcHook {
  onHit,
  onBlock,
  onKill,
  onCrit,
}

/// A single proc effect that can be attached to a weapon.
///
/// When the specified [hook] triggers, there's a [chance] to apply
/// the status effect defined by [statusProfileId].
class WeaponProc {
  const WeaponProc({
    required this.hook,
    required this.statusProfileId,
    this.chanceBp = 10000,
  }) : assert(chanceBp >= 0 && chanceBp <= 10000, 'chanceBp must be in [0..10000]');

  /// When this proc can trigger.
  final ProcHook hook;

  /// The status effect profile to apply.
  final StatusProfileId statusProfileId;

  /// Probability of triggering in Basis Points (100 = 1%, 10000 = 100%).
  final int chanceBp;
}



===== FILE: lib/firebase_options.dart =====
// File generated by FlutterFire CLI.
// ignore_for_file: type=lint
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'firebase_options.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        return ios;
      case TargetPlatform.macOS:
        return macos;
      case TargetPlatform.windows:
        return windows;
      case TargetPlatform.linux:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static const FirebaseOptions web = FirebaseOptions(
    apiKey: 'AIzaSyBVf_cQ5Xj15s_ZngbkeDXAokYCSCR8P7Y',
    appId: '1:964001571974:web:97acd9d8974e215dd81d07',
    messagingSenderId: '964001571974',
    projectId: 'rpg-runner-d7add',
    authDomain: 'rpg-runner-d7add.firebaseapp.com',
    storageBucket: 'rpg-runner-d7add.firebasestorage.app',
    measurementId: 'G-86SWFBNW26',
  );

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyB_RE8QyjyVnoBQ-H59DCIbGbc39faaixA',
    appId: '1:964001571974:android:d48582bc9cde8cf2d81d07',
    messagingSenderId: '964001571974',
    projectId: 'rpg-runner-d7add',
    storageBucket: 'rpg-runner-d7add.firebasestorage.app',
  );

  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: 'AIzaSyCFNb8YfiG8TULypJb6t5c_obcSKxOTpk4',
    appId: '1:964001571974:ios:84c6faf57baaa0f4d81d07',
    messagingSenderId: '964001571974',
    projectId: 'rpg-runner-d7add',
    storageBucket: 'rpg-runner-d7add.firebasestorage.app',
    iosBundleId: 'com.example.rpgRunner',
  );

  static const FirebaseOptions macos = FirebaseOptions(
    apiKey: 'AIzaSyCFNb8YfiG8TULypJb6t5c_obcSKxOTpk4',
    appId: '1:964001571974:ios:84c6faf57baaa0f4d81d07',
    messagingSenderId: '964001571974',
    projectId: 'rpg-runner-d7add',
    storageBucket: 'rpg-runner-d7add.firebasestorage.app',
    iosBundleId: 'com.example.rpgRunner',
  );

  static const FirebaseOptions windows = FirebaseOptions(
    apiKey: 'AIzaSyBVf_cQ5Xj15s_ZngbkeDXAokYCSCR8P7Y',
    appId: '1:964001571974:web:2f0915a1e04e6c16d81d07',
    messagingSenderId: '964001571974',
    projectId: 'rpg-runner-d7add',
    authDomain: 'rpg-runner-d7add.firebaseapp.com',
    storageBucket: 'rpg-runner-d7add.firebasestorage.app',
    measurementId: 'G-XPENVW9P9L',
  );

}

===== FILE: lib/game/AGENTS.md =====
# AGENTS.md - Game Layer

Instructions for AI coding agents working in the **Game** rendering layer (`lib/game/`).

## Game Layer Responsibility

The Game layer is responsible for **visuals only**. It uses the Flame game engine to render the game state produced by Core.

**Critical rule:** Game layer is **never authoritative** for gameplay logic, collision, or state management. All gameplay truth lives in Core.

## Core Snapshot Consumption

### Read-Only Contract

- The Game layer receives `GameStateSnapshot` objects from Core
- **Treat snapshots as read-only** - never mutate snapshot data
- Never simulate or extrapolate gameplay logic in the Game layer

### Interpolation Pattern

For smooth visuals, interpolate between snapshots:

```dart
void render(GameStateSnapshot prevSnapshot, 
            GameStateSnapshot currSnapshot, 
            double alpha) {
  // alpha ranges from 0.0 (prevSnapshot) to 1.0 (currSnapshot)
  
  final prevPos = prevSnapshot.entities[id].position;
  final currPos = currSnapshot.entities[id].position;
  
  final renderPos = prevPos.lerp(currPos, alpha);
  
  // Update sprite position
  sprite.position = renderPos;
}
```

**Rules:**
- Use `prevSnapshot` and `currSnapshot` for interpolation
- `alpha` is the interpolation factor (0.0 to 1.0)
- **Never simulate** - only interpolate between known states
- Never predict future positions or run physics in Game layer

## Flame Component Patterns

### Entity View Components

Entity view components are Flame components that visualize Core entities:

```dart
class PlayerView extends PositionComponent {
  final int entityId;
  
  void update(GameStateSnapshot snapshot, double alpha) {
    // Read entity data from snapshot
    final entity = snapshot.entities[entityId];
    
    // Update visual representation
    position = entity.position;
    animationState = entity.animationState;
  }
}
```

### Component Organization

- **Entity views** (`lib/game/components/`) - Visual representations of Core entities
- **Camera management** - Viewport, camera follow, shake effects
- **Parallax backgrounds** - Multi-layer scrolling backgrounds
- **VFX** - Visual effects (particles, explosions, trails)
- **Debug visualization** (`lib/game/debug/`) - Collision boxes, debug overlays

## World & Camera Rules

### Virtual Resolution

- Pick one **virtual resolution** (world units == virtual pixels)
- Example: 320×180, 640×360, or 1920×1080 depending on art style
- All Core coordinates use this virtual resolution

### Integer Scaling + Letterboxing

- Use **integer scaling** to avoid fractional pixels (prevents shimmering)
- Add **letterboxing** (black bars) when aspect ratio doesn't match
- No fractional scaling - sprite pixels must be crisp

### Pixel Snapping

- Snap camera position to integer pixels inside the scaled viewport
- Snap entity render positions to integer pixels
- This prevents sub-pixel jitter in pixel-art games

```dart
// Example pixel snapping
final snappedX = (position.x).floor().toDouble();
final snappedY = (position.y).floor().toDouble();
sprite.position = Vector2(snappedX, snappedY);
```

## Asset Management

### Per-Scene Loading

- Assets are loaded **per scene**, not at boot
- Load assets when entering a game route/level
- Unload assets when leaving the route/level

**Example:**
```dart
class LevelScene {
  Future<void> load() async {
    await images.load('level1/background.png');
    await images.load('level1/tileset.png');
    // ... load level-specific assets
  }
  
  void unload() {
    images.clear();
  }
}
```

### No Loading During Gameplay

- **Never load assets during active gameplay**
- Load all required assets during a loading screen
- Preload critical assets before gameplay starts
- Use asset pools for frequently spawned entities

## Input Handling

### Convert Input to Commands

The Game layer can receive input (e.g., from Flame's input system), but it must **convert input to Commands** and send them to the controller.

```dart
@override
void onTapDown(TapDownEvent event) {
  // Convert Flame input to Core command
  final command = JumpCommand(
    tickNumber: controller.currentTick,
    playerId: 0,
  );
  
  // Send to controller
  controller.enqueueCommand(command);
}
```

**Rules:**
- Never modify Core state directly from input handlers
- Always use the Command pattern
- Let Core process commands during its tick execution

## Game Events

Game layer consumes `GameEvent` objects from Core to trigger visual/audio effects:

```dart
void handleEvents(List<GameEvent> events) {
  for (final event in events) {
    switch (event) {
      case HitEvent(:final position, :final damage):
        spawnHitVFX(position, damage);
        playSFX('hit.wav');
        break;
        
      case ScreenShakeEvent(:final intensity, :final duration):
        cameraShake(intensity, duration);
        break;
        
      // ... handle other event types
    }
  }
}
```

**Event types:**
- Spawn/despawn events → Create/remove entity views
- Hit/damage events → Spawn VFX, play sounds
- Screen shake events → Apply camera effects
- Reward events → Display score popups, notifications

## Flame API Preferences

### Use Flame for Render Concerns

Flame provides excellent tools for rendering. Use them:

- **Camera components** - `CameraComponent`, `Viewport`, camera follow
- **Parallax rendering** - `ParallaxComponent` for scrolling backgrounds
- **Effects** - `MoveEffect`, `ScaleEffect`, `OpacityEffect`, etc.
- **Sprite animations** - `SpriteAnimationComponent`
- **Particles** - `ParticleSystemComponent` for VFX

### Don't Use Flame for Gameplay

Flame also provides gameplay-adjacent features that we **do not use**:

- ❌ **Flame collision system** - Core handles all collision authoritatively
- ❌ **Flame physics** - Core handles all physics
- ❌ **Flame game loop timing** - Core uses fixed ticks, not Flame's variable dt

## Common Game Subsystems

- **GameController** (`lib/game/game_controller.dart`) - Bridges UI, Game, and Core
- **RunnerFlameGame** (`lib/game/runner_flame_game.dart`) - Main Flame game instance
- **Components** (`lib/game/components/`) - Entity views and visual components
- **Input** (`lib/game/input/`) - Input handling and command conversion
- **Themes** (`lib/game/themes/`) - Visual themes and color schemes
- **Debug** (`lib/game/debug/`) - Debug visualization and tools

## What NOT to Do in Game Layer

- ❌ **Do not simulate gameplay** - that's Core's job
- ❌ **Do not use Flame collision as gameplay truth** - Core is authoritative
- ❌ **Do not mutate Core state** - send Commands instead
- ❌ **Do not mutate snapshots** - they are read-only
- ❌ **Do not load assets during gameplay** - preload everything
- ❌ **Do not use variable dt for gameplay** - Core uses fixed ticks

## Best Practices

✅ **Interpolate for smooth visuals** using prev/curr snapshots
✅ **Use Flame components** for camera, parallax, effects
✅ **Convert input to Commands** before sending to Core
✅ **Consume events** to trigger VFX and SFX
✅ **Load assets per-scene** and unload when done
✅ **Snap positions** for pixel-perfect rendering

---

**For cross-layer architecture and general rules**, see [lib/AGENTS.md](file:///c:/dev/rpg_runner/lib/AGENTS.md).


===== FILE: lib/game/components/aim_ray_component.dart =====
import 'package:flame/components.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/widgets.dart';

import '../../core/snapshots/entity_render_snapshot.dart';
import '../../core/snapshots/enums.dart';
import '../game_controller.dart';
import '../input/aim_preview.dart';

/// Renders a visual "aim ray" or laser sight extending from the player.
///
/// Reacts to [AimPreviewState] to show the player where their projectile
/// or ability will land.
class AimRayComponent extends Component {
  AimRayComponent({
    required this.controller,
    required this.preview,
    required this.length,
    this.playerRenderPos,
    Paint? paint,
    this.drawWhenNoAim = true,
  }) : _paint =
           paint ??
           (Paint()
             ..color = const Color.fromARGB(255, 120, 165, 236)
             ..strokeWidth = 2
             ..strokeCap = StrokeCap.round);

  /// Provides access to the game state (player position).
  final GameController controller;

  /// Reactive state for the current aim direction/status.
  final ValueListenable<AimPreviewState> preview;

  /// Length of the ray in world units (pixels).
  final double length;

  /// Optional rendered player position (already snapped for pixel-perfect render).
  ///
  /// When provided, the ray origin uses this position instead of the raw
  /// snapshot value to avoid 1px drift when render interpolation/snapping is
  /// enabled.
  final ValueGetter<Vector2>? playerRenderPos;

  /// Whether to draw a "straight ahead" ray even when the player hasn't
  /// explicitly dragged to aim (fallback to player facing).
  final bool drawWhenNoAim;

  final Paint _paint;

  @override
  void render(Canvas canvas) {
    final state = preview.value;
    if (!state.active) return;
    if (!state.hasAim && !drawWhenNoAim) return;

    final player = controller.snapshot.playerEntity;
    if (player == null) return;

    final (dirX, dirY) = _resolveDir(state, player);
    final rendered = playerRenderPos?.call();
    final startX = rendered?.x ?? player.pos.x;
    final startY = rendered?.y ?? player.pos.y;
    final endX = startX + dirX * length;
    final endY = startY + dirY * length;

    canvas.drawLine(Offset(startX, startY), Offset(endX, endY), _paint);
  }

  /// Determines the ray direction.
  ///
  /// Uses the explicit aim if available; otherwise falls back to the player's
  /// current facing direction.
  (double, double) _resolveDir(
    AimPreviewState state,
    EntityRenderSnapshot player,
  ) {
    if (state.hasAim) {
      return (state.dirX, state.dirY);
    }
    final facing = player.facing;
    return (facing == Facing.right ? 1.0 : -1.0, 0.0);
  }
}


===== FILE: lib/game/components/enemies/enemy_render_registry.dart =====
/// Enemy render registry and loaders (render layer only).
library;

import 'package:flame/cache.dart';
import 'package:flame/components.dart';

import '../../../core/contracts/render_anim_set_definition.dart';
import '../../../core/enemies/enemy_catalog.dart';
import '../../../core/enemies/enemy_id.dart';
import '../../../core/snapshots/enums.dart';
import '../sprite_anim/deterministic_anim_view_component.dart';
import '../sprite_anim/sprite_anim_set.dart';
import '../sprite_anim/strip_animation_loader.dart';

typedef EnemyAnimLoader =
    Future<SpriteAnimSet> Function(
      Images images, {
      required RenderAnimSetDefinition renderAnim,
      required Set<AnimKey> oneShotKeys,
    });

typedef EnemyViewFactory =
    DeterministicAnimViewComponent Function(
      SpriteAnimSet animSet,
      Vector2 renderScale,
    );

enum EnemyDeathAnimPolicy { spawn, none }

const Set<AnimKey> _defaultEnemyOneShotKeys = <AnimKey>{
  AnimKey.strike,
  AnimKey.hit,
  AnimKey.death,
};

DeterministicAnimViewComponent _defaultEnemyViewFactory(
  SpriteAnimSet animSet,
  Vector2 renderScale,
) {
  return DeterministicAnimViewComponent(
    animSet: animSet,
    renderSize: Vector2(animSet.frameSize.x, animSet.frameSize.y),
    renderScale: renderScale,
  );
}

class EnemyRenderEntry {
  EnemyRenderEntry({
    required this.id,
    required this.renderScale,
    this.deathAnimPolicy = EnemyDeathAnimPolicy.spawn,
    this.oneShotKeys = _defaultEnemyOneShotKeys,
    this.loader = loadAnimSetFromDefinition,
    this.viewFactory = _defaultEnemyViewFactory,
  });

  final EnemyId id;
  final Vector2 renderScale;
  final EnemyDeathAnimPolicy deathAnimPolicy;
  final Set<AnimKey> oneShotKeys;
  final EnemyAnimLoader loader;
  final EnemyViewFactory viewFactory;

  SpriteAnimSet? _animSet;
  bool _hasAssets = true;

  bool get hasAssets => _hasAssets;

  bool get isLoaded => _animSet != null;

  bool get isRenderable => _hasAssets && _animSet != null;

  SpriteAnimSet get animSet {
    final value = _animSet;
    if (value == null) {
      throw StateError('EnemyRenderEntry($id) has not been loaded yet.');
    }
    return value;
  }

  Future<void> load(
    Images images, {
    required RenderAnimSetDefinition renderAnim,
  }) async {
    final idlePath = renderAnim.sourcesByKey[AnimKey.idle];
    if (idlePath == null || idlePath.trim().isEmpty) {
      _hasAssets = false;
      _animSet = null;
      return;
    }
    _animSet = await loader(
      images,
      renderAnim: renderAnim,
      oneShotKeys: oneShotKeys,
    );
  }
}

/// Render registry for enemies (EnemyId -> render wiring).
class EnemyRenderRegistry {
  EnemyRenderRegistry({EnemyCatalog enemyCatalog = const EnemyCatalog()})
    : _enemyCatalog = enemyCatalog;

  final EnemyCatalog _enemyCatalog;

  final Map<EnemyId, EnemyRenderEntry> _entries = <EnemyId, EnemyRenderEntry>{
    EnemyId.unocoDemon: EnemyRenderEntry(
      id: EnemyId.unocoDemon,
      renderScale: Vector2.all(0.5),
    ),
    EnemyId.grojib: EnemyRenderEntry(
      id: EnemyId.grojib,
      renderScale: Vector2.all(1.5),
    ),
  };

  EnemyRenderEntry? entryFor(EnemyId id) {
    final entry = _entries[id];
    if (entry == null || !entry.isRenderable) return null;
    return entry;
  }

  Future<void> load(Images images) async {
    for (final entry in _entries.values) {
      final renderAnim = _enemyCatalog.get(entry.id).renderAnim;
      await entry.load(images, renderAnim: renderAnim);
    }
  }
}


===== FILE: lib/game/components/ground_band_parallax_foreground_component.dart =====
import 'dart:ui' as ui;

import 'package:flame/components.dart';
import 'package:flame/game.dart';
import 'package:flutter/painting.dart';

import '../game_controller.dart';
import '../spatial/world_view_transform.dart';
import '../util/math_util.dart';
import 'ground_surface_layout.dart';
import 'pixel_parallax_backdrop_component.dart';

/// Renders parallax foreground layers clipped to ground surface bands.
///
/// This keeps foreground coverage aligned with authoritative Core ground spans,
/// so foreground and floor share the same gaps.
class GroundBandParallaxForegroundComponent extends Component
    with HasGameReference<FlameGame> {
  GroundBandParallaxForegroundComponent({
    required this.controller,
    required this.virtualWidth,
    required this.virtualHeight,
    required this.layers,
    required this.bandFillDepthProvider,
    this.snapScrollToPixels = true,
  });

  /// Snapshot provider.
  final GameController controller;

  /// Fixed virtual viewport width.
  final int virtualWidth;

  /// Fixed virtual viewport height.
  final int virtualHeight;

  /// Foreground layer specifications, rendered in order.
  final List<PixelParallaxLayerSpec> layers;

  /// Provides the same band depth used by ground rendering.
  final double Function() bandFillDepthProvider;

  /// If true, scroll offsets are rounded to whole pixels for crisp rendering.
  final bool snapScrollToPixels;

  late final List<ui.Image> _images;
  late final List<double> _scroll;
  double? _prevCameraLeftX;

  final Paint _paint = Paint()..filterQuality = FilterQuality.none;

  @override
  Future<void> onLoad() async {
    await super.onLoad();
    _images = await Future.wait(
      layers.map((layer) => game.images.load(layer.assetPath)),
    );
    _scroll = List<double>.filled(layers.length, 0.0);
  }

  @override
  void update(double dt) {
    super.update(dt);

    final viewWidth = virtualWidth.toDouble();
    final camX = -game.camera.viewfinder.transform.offset.x;
    final cameraLeftX = camX - viewWidth * 0.5;

    final prev = _prevCameraLeftX;
    _prevCameraLeftX = cameraLeftX;
    if (prev == null) return;

    final delta = cameraLeftX - prev;
    if (delta == 0.0) return;

    for (var i = 0; i < layers.length; i++) {
      _scroll[i] += delta * layers[i].parallaxFactor;
      _scroll[i] = positiveModDouble(_scroll[i], _images[i].width.toDouble());
    }
  }

  @override
  void render(ui.Canvas canvas) {
    super.render(canvas);

    if (layers.isEmpty) return;
    final surfaces = controller.snapshot.groundSurfaces;
    if (surfaces.isEmpty) return;

    final fillDepth = bandFillDepthProvider();
    if (fillDepth <= 0.0 || !fillDepth.isFinite) return;

    final camX = -game.camera.viewfinder.transform.offset.x;
    final camY = -game.camera.viewfinder.transform.offset.y;
    final transform = WorldViewTransform(
      cameraCenterX: camX,
      cameraCenterY: camY,
      viewWidth: virtualWidth.toDouble(),
      viewHeight: virtualHeight.toDouble(),
    );
    final visibleRect = ui.Rect.fromLTRB(
      transform.viewLeftX,
      transform.viewTopY,
      transform.viewRightX,
      transform.viewBottomY,
    );

    final bands = GroundSurfaceLayout.buildVisibleBands(
      surfaces: surfaces,
      visibleWorldRect: visibleRect,
      fillDepth: fillDepth,
    );
    if (bands.isEmpty) return;

    canvas.save();
    canvas.clipRect(
      ui.Rect.fromLTWH(
        0.0,
        0.0,
        virtualWidth.toDouble(),
        virtualHeight.toDouble(),
      ),
    );

    for (final band in bands) {
      final topY = roundToPixels(transform.worldToViewY(band.topY));
      final bottomY = roundToPixels(transform.worldToViewY(band.bottomY));
      if (bottomY <= topY) continue;

      final clipMinX = roundToPixels(transform.worldToViewX(band.minX));
      final clipMaxX = roundToPixels(transform.worldToViewX(band.maxX));
      if (clipMaxX <= clipMinX) continue;

      canvas.save();
      canvas.clipRect(ui.Rect.fromLTRB(clipMinX, topY, clipMaxX, bottomY));

      for (var i = 0; i < layers.length; i++) {
        final image = _images[i];
        final imageW = image.width;
        final imageH = image.height;
        final y = bottomY - imageH.toDouble();

        final scroll = snapScrollToPixels
            ? roundToPixels(_scroll[i])
            : _scroll[i];
        final offsetPx = -scroll;
        final startX = positiveModDouble(offsetPx, imageW.toDouble());

        for (var x = startX - imageW; x < virtualWidth; x += imageW) {
          canvas.drawImage(image, ui.Offset(x, y), _paint);
        }
      }

      canvas.restore();
    }

    canvas.restore();
  }
}


===== FILE: lib/game/components/ground_surface_component.dart =====
import 'dart:ui' as ui;

import 'package:flame/components.dart';
import 'package:flame/game.dart';
import 'package:flutter/painting.dart';

import '../game_controller.dart';
import '../spatial/world_view_transform.dart';
import '../util/math_util.dart';
import 'ground_surface_layout.dart';

/// Renders Core-authored ground surfaces using a tiled texture material.
///
/// This component consumes `snapshot.groundSurfaces` and aligns the visual top
/// edge to authoritative surface `topY`. Collision/geometry remains Core-owned.
class GroundSurfaceComponent extends Component
    with HasGameReference<FlameGame> {
  GroundSurfaceComponent({
    required this.assetPath,
    required this.controller,
    required this.virtualWidth,
    required this.virtualHeight,
  });

  /// Path to the ground texture asset used as material fill.
  final String assetPath;

  /// Snapshot provider.
  final GameController controller;

  /// Fixed virtual viewport width.
  final int virtualWidth;

  /// Fixed virtual viewport height.
  final int virtualHeight;

  late final ui.Image _image;
  late final ui.Rect _materialSrcRect;
  double _materialHeight = _fallbackMaterialHeight;

  final Paint _paint = Paint()..filterQuality = FilterQuality.none;

  static const int _alphaOpaqueThreshold = 1;
  static const double _rowCoverageThreshold = 0.20;
  static const double _fallbackMaterialHeight = 16.0;

  /// Effective ground material height used for band fill.
  ///
  /// Exposed so other render-only components can align visuals with the same
  /// authored band depth.
  double get materialHeight => _materialHeight;

  @override
  Future<void> onLoad() async {
    await super.onLoad();
    _image = await game.images.load(assetPath);
    final materialTopY = await _detectMaterialTopRow(_image);
    final srcHeight = (_image.height - materialTopY).toDouble().clamp(
      1.0,
      _image.height.toDouble(),
    );
    _materialSrcRect = ui.Rect.fromLTWH(
      0.0,
      materialTopY.toDouble(),
      _image.width.toDouble(),
      srcHeight,
    );
    _materialHeight = _materialSrcRect.height;
  }

  @override
  void render(ui.Canvas canvas) {
    super.render(canvas);

    final surfaces = controller.snapshot.groundSurfaces;
    if (surfaces.isEmpty) return;

    final camX = -game.camera.viewfinder.transform.offset.x;
    final camY = -game.camera.viewfinder.transform.offset.y;
    final transform = WorldViewTransform(
      cameraCenterX: camX,
      cameraCenterY: camY,
      viewWidth: virtualWidth.toDouble(),
      viewHeight: virtualHeight.toDouble(),
    );
    final visibleRect = ui.Rect.fromLTRB(
      transform.viewLeftX,
      transform.viewTopY,
      transform.viewRightX,
      transform.viewBottomY,
    );

    final bands = GroundSurfaceLayout.buildVisibleBands(
      surfaces: surfaces,
      visibleWorldRect: visibleRect,
      fillDepth: _materialHeight,
    );
    if (bands.isEmpty) return;

    final tileWidth = _image.width;
    final viewClipRect = ui.Rect.fromLTWH(
      0.0,
      0.0,
      virtualWidth.toDouble(),
      virtualHeight.toDouble(),
    );

    canvas.save();
    canvas.clipRect(viewClipRect);

    for (final band in bands) {
      final topY = roundToPixels(transform.worldToViewY(band.topY));
      final bottomY = roundToPixels(transform.worldToViewY(band.bottomY));
      if (bottomY <= topY) continue;

      final clipMinX = roundToPixels(transform.worldToViewX(band.minX));
      final clipMaxX = roundToPixels(transform.worldToViewX(band.maxX));
      if (clipMaxX <= clipMinX) continue;

      final startTile = floorDivInt(band.minX.floor(), tileWidth) - 1;
      final endTile = floorDivInt(band.maxX.ceil(), tileWidth) + 1;

      canvas.save();
      canvas.clipRect(ui.Rect.fromLTRB(clipMinX, topY, clipMaxX, bottomY));

      for (var tile = startTile; tile <= endTile; tile += 1) {
        final tileWorldX = (tile * tileWidth).toDouble();
        final tileViewX = roundToPixels(transform.worldToViewX(tileWorldX));
        final dstRect = ui.Rect.fromLTRB(
          tileViewX,
          topY,
          tileViewX + tileWidth,
          bottomY,
        );
        canvas.drawImageRect(_image, _materialSrcRect, dstRect, _paint);
      }

      canvas.restore();
    }

    canvas.restore();
  }

  Future<int> _detectMaterialTopRow(ui.Image image) async {
    final bytes = await image.toByteData(format: ui.ImageByteFormat.rawRgba);
    if (bytes == null) return _fallbackMaterialTopRow(image.height);

    final rgba = bytes.buffer.asUint8List();
    final width = image.width;
    final height = image.height;
    final minOpaquePixels = (width * _rowCoverageThreshold).ceil();
    int? firstOpaqueRow;
    for (var y = 0; y < height; y += 1) {
      final rowOffset = y * width * 4;
      var opaqueCount = 0;
      for (var x = 0; x < width; x += 1) {
        final alpha = rgba[rowOffset + x * 4 + 3];
        if (alpha >= _alphaOpaqueThreshold) {
          firstOpaqueRow ??= y;
          opaqueCount += 1;
          if (opaqueCount >= minOpaquePixels) {
            return y;
          }
        }
      }
    }

    if (firstOpaqueRow != null) return firstOpaqueRow;
    return _fallbackMaterialTopRow(height);
  }

  int _fallbackMaterialTopRow(int imageHeight) {
    final fallbackTop = (imageHeight - _fallbackMaterialHeight).floor();
    if (fallbackTop <= 0) return 0;
    if (fallbackTop >= imageHeight) return imageHeight - 1;
    return fallbackTop;
  }
}


===== FILE: lib/game/components/ground_surface_layout.dart =====
import 'dart:ui' as ui;

import '../../core/snapshots/ground_surface_snapshot.dart';

/// Visible render span for one ground surface.
class GroundSurfaceRenderBand {
  const GroundSurfaceRenderBand({
    required this.minX,
    required this.maxX,
    required this.topY,
    required this.bottomY,
  }) : assert(maxX >= minX),
       assert(bottomY >= topY);

  final double minX;
  final double maxX;
  final double topY;
  final double bottomY;
}

/// Layout helpers for geometry-driven ground rendering.
class GroundSurfaceLayout {
  const GroundSurfaceLayout._();

  /// Builds clipped, finite world-space render bands from ground surfaces.
  ///
  /// - Surface X spans are clamped to [visibleWorldRect.left/right].
  /// - Infinite surfaces are converted into finite visible spans.
  /// - Surfaces outside vertical visibility are omitted.
  static List<GroundSurfaceRenderBand> buildVisibleBands({
    required List<GroundSurfaceSnapshot> surfaces,
    required ui.Rect visibleWorldRect,
    required double fillDepth,
  }) {
    if (surfaces.isEmpty || fillDepth <= 0.0) {
      return const <GroundSurfaceRenderBand>[];
    }

    final visibleLeft = visibleWorldRect.left;
    final visibleRight = visibleWorldRect.right;
    final visibleTop = visibleWorldRect.top;
    final visibleBottom = visibleWorldRect.bottom;
    final out = <GroundSurfaceRenderBand>[];

    for (final surface in surfaces) {
      var minX = surface.minX;
      var maxX = surface.maxX;

      if (!minX.isFinite) minX = visibleLeft;
      if (!maxX.isFinite) maxX = visibleRight;
      if (minX < visibleLeft) minX = visibleLeft;
      if (maxX > visibleRight) maxX = visibleRight;
      if (maxX <= minX) continue;

      final topY = surface.topY;
      final bottomY = topY + fillDepth;
      if (bottomY <= visibleTop || topY >= visibleBottom) continue;

      out.add(
        GroundSurfaceRenderBand(
          minX: minX,
          maxX: maxX,
          topY: topY,
          bottomY: bottomY,
        ),
      );
    }

    return out;
  }
}


===== FILE: lib/game/components/pickups/pickup_render_registry.dart =====
/// Pickup render registry and loaders (render layer only).
library;

import 'package:flame/cache.dart';
import 'package:flame/components.dart';

import '../../../core/contracts/render_anim_set_definition.dart';
import '../../../core/pickups/pickup_render_catalog.dart';
import '../../../core/snapshots/entity_render_snapshot.dart';
import '../../../core/snapshots/enums.dart';
import '../sprite_anim/deterministic_anim_view_component.dart';
import '../sprite_anim/sprite_anim_set.dart';
import '../sprite_anim/strip_animation_loader.dart';

typedef PickupAnimLoader =
    Future<SpriteAnimSet> Function(
      Images images, {
      required RenderAnimSetDefinition renderAnim,
      required Set<AnimKey> oneShotKeys,
    });

typedef PickupViewFactory =
    DeterministicAnimViewComponent Function(
      SpriteAnimSet animSet,
      Vector2 renderScale,
    );

DeterministicAnimViewComponent _defaultPickupViewFactory(
  SpriteAnimSet animSet,
  Vector2 renderScale,
) {
  return DeterministicAnimViewComponent(
    animSet: animSet,
    renderSize: Vector2(animSet.frameSize.x, animSet.frameSize.y),
    renderScale: renderScale,
    respectFacing: false,
  );
}

class PickupRenderEntry {
  PickupRenderEntry({
    required this.variant,
    required this.renderScale,
    this.oneShotKeys = const <AnimKey>{},
    this.loader = loadAnimSetFromDefinition,
    this.viewFactory = _defaultPickupViewFactory,
  });

  final int variant;
  final Vector2 renderScale;
  final Set<AnimKey> oneShotKeys;
  final PickupAnimLoader loader;
  final PickupViewFactory viewFactory;

  SpriteAnimSet? _animSet;

  bool get isLoaded => _animSet != null;

  SpriteAnimSet get animSet {
    final value = _animSet;
    if (value == null) {
      throw StateError('PickupRenderEntry($variant) has not been loaded yet.');
    }
    return value;
  }

  Future<void> load(
    Images images, {
    required RenderAnimSetDefinition renderAnim,
  }) async {
    _animSet = await loader(
      images,
      renderAnim: renderAnim,
      oneShotKeys: oneShotKeys,
    );
  }
}

/// Render registry for pickups (PickupVariant -> render wiring).
class PickupRenderRegistry {
  PickupRenderRegistry({
    PickupRenderCatalog catalog = const PickupRenderCatalog(),
  }) : _catalog = catalog;

  final PickupRenderCatalog _catalog;

  // 16px art scaled to match Core collider sizes.
  static final Vector2 _collectibleScale = Vector2.all(1.0);
  static final Vector2 _restorationScale = Vector2.all(1.0);

  final Map<int, PickupRenderEntry> _entries = <int, PickupRenderEntry>{
    // Collectible coin.
    PickupVariant.collectible: PickupRenderEntry(
      variant: PickupVariant.collectible,
      renderScale: _collectibleScale,
    ),
    // Restoration gems.
    PickupVariant.restorationHealth: PickupRenderEntry(
      variant: PickupVariant.restorationHealth,
      renderScale: _restorationScale,
    ),
    PickupVariant.restorationMana: PickupRenderEntry(
      variant: PickupVariant.restorationMana,
      renderScale: _restorationScale,
    ),
    PickupVariant.restorationStamina: PickupRenderEntry(
      variant: PickupVariant.restorationStamina,
      renderScale: _restorationScale,
    ),
  };

  PickupRenderEntry entryForVariant(int variant) {
    final entry = _entries[variant];
    if (entry == null) {
      throw StateError(
        'No pickup render entry registered for variant=$variant.',
      );
    }
    return entry;
  }

  Future<void> load(Images images) async {
    for (final entry in _entries.values) {
      final renderAnim = _catalog.get(entry.variant);
      await entry.load(images, renderAnim: renderAnim);
    }
  }
}


===== FILE: lib/game/components/pixel_parallax_backdrop_component.dart =====
// Renders a multi-layer parallax background for pixel-art games.
//
// Each layer scrolls at a fraction of the camera movement (controlled by
// `parallaxFactor`), creating depth. Layers are rendered in order, so
// earlier layers appear behind later ones.
//
// The component uses a fixed "virtual" viewport size to maintain pixel-perfect
// rendering regardless of actual screen resolution. Images are tiled horizontally
// and bottom-aligned within the viewport.
import 'dart:ui' as ui;
import 'package:flame/components.dart';
import 'package:flame/game.dart';
import 'package:flutter/painting.dart';
import '../util/math_util.dart';

/// Renders a pixel-perfect, multi-layer parallax background.
///
/// Layers are defined via [PixelParallaxLayerSpec] and rendered back-to-front.
/// Each layer's scroll position is determined by its [PixelParallaxLayerSpec.parallaxFactor]:
/// - `0.0` = static (doesn't move with camera)
/// - `1.0` = moves 1:1 with camera (no parallax effect)
/// - Values between create the classic parallax depth illusion
class PixelParallaxBackdropComponent extends Component
    with HasGameReference<FlameGame> {
  PixelParallaxBackdropComponent({
    required this.virtualWidth,
    required this.virtualHeight,
    required this.layers,
    this.snapScrollToPixels = true,
    this.layerBottomAnchorYProvider,
  });

  /// Width of the virtual viewport in pixels.
  final int virtualWidth;

  /// Height of the virtual viewport in pixels.
  final int virtualHeight;

  /// Layer specifications, rendered in order (index 0 = backmost).
  final List<PixelParallaxLayerSpec> layers;

  /// If true, scroll offsets are rounded to whole pixels for crisp rendering.
  final bool snapScrollToPixels;

  /// Optional runtime provider for the vertical bottom anchor (in view-space).
  ///
  /// When unset, layers are anchored to the viewport bottom (legacy behavior).
  final double Function()? layerBottomAnchorYProvider;

  /// Loaded images for each layer (parallel to [layers]).
  late final List<ui.Image> _images;

  /// Previous frame's camera X position (for delta calculation).
  double? _prevCameraLeftX;

  /// Accumulated scroll offset for each layer (in pixels).
  late final List<double> _scroll;

  /// Paint configured for nearest-neighbor (pixel-perfect) filtering.
  final Paint _paint = Paint()..filterQuality = FilterQuality.none;

  @override
  Future<void> onLoad() async {
    await super.onLoad();
    _images = await Future.wait(
      layers.map((layer) => game.images.load(layer.assetPath)),
    );
    _scroll = List<double>.filled(layers.length, 0);
  }

  /// Updates scroll offsets based on camera movement.
  ///
  /// Each layer's scroll is incremented by `cameraDelta * parallaxFactor`,
  /// then wrapped to avoid floating-point overflow on long play sessions.
  @override
  void update(double dt) {
    super.update(dt);

    final viewWidth = virtualWidth.toDouble();
    final camX = -game.camera.viewfinder.transform.offset.x;
    final cameraLeftX = camX - viewWidth * 0.5;

    final prev = _prevCameraLeftX;
    _prevCameraLeftX = cameraLeftX;
    if (prev == null) return; // First frame: just record position, skip scroll.

    final delta = cameraLeftX - prev;
    if (delta == 0) return; // No camera movement, nothing to update.

    for (var i = 0; i < layers.length; i++) {
      _scroll[i] += delta * layers[i].parallaxFactor;
      // Wrap scroll to [0, imageWidth) to prevent overflow.
      _scroll[i] = positiveModDouble(_scroll[i], _images[i].width.toDouble());
    }
  }

  /// Renders all parallax layers, back-to-front.
  ///
  /// Each layer is horizontally tiled and bottom-aligned within the virtual
  /// viewport. The viewport is clipped to prevent overdraw outside bounds.
  @override
  void render(ui.Canvas canvas) {
    super.render(canvas);

    final viewWidth = virtualWidth;
    final viewHeight = virtualHeight;
    final bottomAnchorY = layerBottomAnchorYProvider?.call();

    canvas.save();
    canvas.clipRect(
      ui.Rect.fromLTWH(0, 0, viewWidth.toDouble(), viewHeight.toDouble()),
    );

    for (var i = 0; i < layers.length; i++) {
      final image = _images[i];

      final imageW = image.width;
      final imageH = image.height;
      final y = resolveLayerTopY(
        viewHeight: viewHeight,
        imageHeight: imageH,
        bottomAnchorY: bottomAnchorY,
      );

      // Optionally snap to whole pixels for crisp pixel-art rendering.
      final scroll = snapScrollToPixels
          ? roundToPixels(_scroll[i])
          : _scroll[i];
      final offsetPx = -scroll;
      final startX = positiveModDouble(offsetPx, imageW.toDouble());

      // Tile the image across the viewport width.
      for (var x = startX - imageW; x < viewWidth; x += imageW) {
        canvas.drawImage(image, ui.Offset(x, y), _paint);
      }
    }

    canvas.restore();
  }

  /// Computes top Y for a layer from an optional bottom anchor.
  static double resolveLayerTopY({
    required int viewHeight,
    required int imageHeight,
    required double? bottomAnchorY,
  }) {
    final resolvedBottom = bottomAnchorY;
    if (resolvedBottom == null || !resolvedBottom.isFinite) {
      return (viewHeight - imageHeight).toDouble();
    }
    return resolvedBottom - imageHeight;
  }
}

/// Configuration for a single parallax layer.
class PixelParallaxLayerSpec {
  const PixelParallaxLayerSpec({
    required this.assetPath,
    required this.parallaxFactor,
  });

  /// Path to the layer image (relative to assets/images/).
  final String assetPath;

  /// How much this layer scrolls relative to camera movement.
  ///
  /// - `0.0`: Layer is static (sky, distant mountains).
  /// - `0.5`: Layer moves at half camera speed (mid-ground).
  /// - `1.0`: Layer moves 1:1 with camera (no parallax, foreground).
  final double parallaxFactor;
}


===== FILE: lib/game/components/player/player_animations.dart =====
/// Player animation loading utilities (render layer only).
///
/// Loads horizontal sprite-strip animations from `assets/images/entities/player/`.
library;

import 'package:flame/cache.dart';

import '../../../core/contracts/render_anim_set_definition.dart';
import '../../../core/snapshots/enums.dart';
import '../sprite_anim/sprite_anim_set.dart';
import '../sprite_anim/strip_animation_loader.dart';

Future<SpriteAnimSet> loadPlayerAnimations(
  Images images, {
  required RenderAnimSetDefinition renderAnim,
}) async {
  final oneShotKeys = <AnimKey>{
    AnimKey.strike,
    AnimKey.backStrike,
    AnimKey.cast,
    AnimKey.ranged,
    AnimKey.dash,
    AnimKey.hit,
    AnimKey.death,
  };
  return loadAnimSetFromDefinition(
    images,
    renderAnim: renderAnim,
    oneShotKeys: oneShotKeys,
  );
}


===== FILE: lib/game/components/player/player_view_component.dart =====
/// Player render component driven purely by Core snapshots.
library;

import 'package:flame/components.dart';

import '../../../core/snapshots/enums.dart';
import '../sprite_anim/deterministic_anim_view_component.dart';
import '../sprite_anim/sprite_anim_set.dart';

class PlayerViewComponent extends DeterministicAnimViewComponent {
  PlayerViewComponent({
    required SpriteAnimSet animationSet,
    Vector2? renderSize,
    super.renderScale,
    super.feedbackTuning,
  }) : super(
         animSet: animationSet,
         initial: AnimKey.idle,
         renderSize:
             renderSize ??
             Vector2(animationSet.frameSize.x, animationSet.frameSize.y),
         fallbackResolver: (desired) {
           // Allow directional variants to fall back to their base animation key.
           if (desired == AnimKey.backStrike &&
               !animationSet.animations.containsKey(AnimKey.backStrike) &&
               animationSet.animations.containsKey(AnimKey.strike)) {
             return AnimKey.strike;
           }
           if (desired == AnimKey.ranged &&
               !animationSet.animations.containsKey(AnimKey.ranged) &&
               animationSet.animations.containsKey(AnimKey.cast)) {
             return AnimKey.cast;
           }
           return desired;
         },
       );
}


===== FILE: lib/game/components/projectiles/projectile_render_registry.dart =====
/// Projectile render registry and loaders (render layer only).
library;

import 'dart:math';

import 'package:flame/cache.dart';
import 'package:flame/components.dart';

import '../../../core/contracts/render_anim_set_definition.dart';
import '../../../core/projectiles/projectile_id.dart';
import '../../../core/projectiles/projectile_render_catalog.dart';
import '../../../core/snapshots/enums.dart';
import '../sprite_anim/deterministic_anim_view_component.dart';
import '../sprite_anim/sprite_anim_set.dart';
import '../sprite_anim/strip_animation_loader.dart';

typedef ProjectileAnimLoader =
    Future<SpriteAnimSet> Function(
      Images images, {
      required RenderAnimSetDefinition renderAnim,
      required Set<AnimKey> oneShotKeys,
    });

typedef ProjectileViewFactory =
    DeterministicAnimViewComponent Function(
      SpriteAnimSet animSet,
      Vector2 renderScale,
    );

const Set<AnimKey> _defaultProjectileOneShotKeys = <AnimKey>{
  AnimKey.spawn,
  AnimKey.hit,
};

DeterministicAnimViewComponent _defaultProjectileViewFactory(
  SpriteAnimSet animSet,
  Vector2 renderScale,
) {
  return DeterministicAnimViewComponent(
    animSet: animSet,
    renderSize: Vector2(animSet.frameSize.x, animSet.frameSize.y),
    renderScale: renderScale,
    respectFacing: false,
  );
}

class ProjectileRenderEntry {
  ProjectileRenderEntry({
    required this.id,
    required this.renderScale,
    this.oneShotKeys = _defaultProjectileOneShotKeys,
    this.loader = loadAnimSetFromDefinition,
    this.viewFactory = _defaultProjectileViewFactory,
    this.spinSpeedRadPerSecond = 0.0,
  });

  final ProjectileId id;
  final Vector2 renderScale;
  final Set<AnimKey> oneShotKeys;
  final ProjectileAnimLoader loader;
  final ProjectileViewFactory viewFactory;
  final double spinSpeedRadPerSecond;

  SpriteAnimSet? _animSet;
  bool _hasAssets = true;
  final Map<int, int> _spawnAnimTicksCache = <int, int>{};

  bool get hasAssets => _hasAssets;

  bool get isLoaded => _animSet != null;

  bool get isRenderable => _hasAssets && _animSet != null;

  SpriteAnimSet get animSet {
    final value = _animSet;
    if (value == null) {
      throw StateError('ProjectileRenderEntry($id) has not been loaded yet.');
    }
    return value;
  }

  int spawnAnimTicks(int tickHz) {
    final cached = _spawnAnimTicksCache[tickHz];
    if (cached != null) return cached;

    final set = _animSet;
    if (set == null) return 0;
    final anim = set.animations[AnimKey.spawn];
    if (anim == null) return 0;
    final frameCount = anim.frames.length;
    if (frameCount <= 1) return 0;

    final ticksPerFrame = set.ticksPerFrameFor(AnimKey.spawn, tickHz);
    final totalTicks = ticksPerFrame * frameCount;
    _spawnAnimTicksCache[tickHz] = totalTicks;
    return totalTicks;
  }

  Future<void> load(
    Images images, {
    required RenderAnimSetDefinition renderAnim,
  }) async {
    final idlePath = renderAnim.sourcesByKey[AnimKey.idle];
    if (idlePath == null || idlePath.trim().isEmpty) {
      _hasAssets = false;
      _animSet = null;
      return;
    }
    _animSet = await loader(
      images,
      renderAnim: renderAnim,
      oneShotKeys: oneShotKeys,
    );
  }
}

/// Render registry for projectiles (ProjectileId -> render wiring).
class ProjectileRenderRegistry {
  ProjectileRenderRegistry({
    ProjectileRenderCatalog projectileCatalog = const ProjectileRenderCatalog(),
  }) : _projectileCatalog = projectileCatalog;

  final ProjectileRenderCatalog _projectileCatalog;

  static const double _throwingAxeSpinRps = 6.0;
  static const double _throwingKnifeSpinRps = 7.0;

  final Map<ProjectileId, ProjectileRenderEntry> _entries =
      <ProjectileId, ProjectileRenderEntry>{
        ProjectileId.iceBolt: ProjectileRenderEntry(
          id: ProjectileId.iceBolt,
          renderScale: Vector2.all(1.0),
        ),
        ProjectileId.thunderBolt: ProjectileRenderEntry(
          id: ProjectileId.thunderBolt,
          renderScale: Vector2.all(1.0),
        ),
        ProjectileId.fireBolt: ProjectileRenderEntry(
          id: ProjectileId.fireBolt,
          renderScale: Vector2.all(1.0),
        ),
        ProjectileId.acidBolt: ProjectileRenderEntry(
          id: ProjectileId.acidBolt,
          renderScale: Vector2.all(1.0),
        ),
        ProjectileId.darkBolt: ProjectileRenderEntry(
          id: ProjectileId.darkBolt,
          renderScale: Vector2.all(1.0),
        ),
        ProjectileId.earthBolt: ProjectileRenderEntry(
          id: ProjectileId.earthBolt,
          renderScale: Vector2.all(1.0),
        ),
        ProjectileId.holyBolt: ProjectileRenderEntry(
          id: ProjectileId.holyBolt,
          renderScale: Vector2.all(1.0),
        ),
        ProjectileId.waterBolt: ProjectileRenderEntry(
          id: ProjectileId.waterBolt,
          renderScale: Vector2.all(0.5),
        ),
        ProjectileId.throwingAxe: ProjectileRenderEntry(
          id: ProjectileId.throwingAxe,
          renderScale: Vector2.all(1.0),
          spinSpeedRadPerSecond: _throwingAxeSpinRps * 2.0 * pi,
        ),
        ProjectileId.throwingKnife: ProjectileRenderEntry(
          id: ProjectileId.throwingKnife,
          renderScale: Vector2.all(1.0),
          spinSpeedRadPerSecond: _throwingKnifeSpinRps * 2.0 * pi,
        ),
      };

  ProjectileRenderEntry? entryFor(ProjectileId id) {
    final entry = _entries[id];
    if (entry == null || !entry.isRenderable) return null;
    return entry;
  }

  Future<void> load(Images images) async {
    for (final entry in _entries.values) {
      final renderAnim = _projectileCatalog.get(entry.id);
      await entry.load(images, renderAnim: renderAnim);
    }
  }
}


===== FILE: lib/game/components/sprite_anim/deterministic_anim_view_component.dart =====
/// Generic deterministic sprite animation component driven by Core snapshots.
library;

import 'dart:math' as dart_math;

import 'package:flame/components.dart';
import 'package:flutter/widgets.dart';

import '../../../core/snapshots/entity_render_snapshot.dart';
import '../../../core/snapshots/enums.dart';
import '../../tuning/combat_feedback_tuning.dart';
import 'sprite_anim_set.dart';
import '../../util/math_util.dart' as math;

typedef AnimKeyFallbackResolver = AnimKey Function(AnimKey desired);

class DeterministicAnimViewComponent
    extends SpriteAnimationGroupComponent<AnimKey> {
  DeterministicAnimViewComponent({
    required SpriteAnimSet animSet,
    AnimKey initial = AnimKey.idle,
    AnimKeyFallbackResolver? fallbackResolver,
    Vector2? renderSize,
    Vector2? renderScale,
    bool respectFacing = true,
    CombatFeedbackTuning feedbackTuning = const CombatFeedbackTuning(),
  }) : _animSet = animSet,
       _availableAnimations = animSet.animations,
       _oneShotKeys = animSet.oneShotKeys,
       _fallbackResolver = fallbackResolver,
       _baseScale = renderScale?.clone() ?? Vector2.all(1.0),
       _feedbackTuning = feedbackTuning,
       _respectFacing = respectFacing,
       super(
         animations: animSet.animations,
         current: initial,
         size: renderSize ?? Vector2(animSet.frameSize.x, animSet.frameSize.y),
         scale: renderScale?.clone() ?? Vector2.all(1.0),
         anchor: animSet.anchor,
         paint: Paint()..filterQuality = FilterQuality.none,
       ) {
    // We drive animation frames deterministically from `EntityRenderSnapshot.animFrame`.
    playing = false;
    _dotPulseColor = feedbackTuning.dotFallbackColor;
    _resourcePulseColor = feedbackTuning.resourceFallbackColor;
  }

  final SpriteAnimSet _animSet;
  final Map<AnimKey, SpriteAnimation> _availableAnimations;
  final Set<AnimKey> _oneShotKeys;
  final AnimKeyFallbackResolver? _fallbackResolver;
  final Vector2 _baseScale;
  CombatFeedbackTuning _feedbackTuning;
  final bool _respectFacing;
  int _statusVisualMask = EntityStatusVisualMask.none;
  double _directHitFlashSeconds = 0.0;
  double _directHitFlashDurationSeconds = 0.0;
  double _directHitFlashStrength = 0.0;
  double _dotPulseSeconds = 0.0;
  double _dotPulseDurationSeconds = 0.0;
  double _dotPulseStrength = 0.0;
  Color _dotPulseColor = const Color(0xFFFFFFFF);
  double _resourcePulseSeconds = 0.0;
  double _resourcePulseDurationSeconds = 0.0;
  double _resourcePulseStrength = 0.0;
  Color _resourcePulseColor = const Color(0xFFFFFFFF);

  /// Updates render feedback tuning at runtime.
  void setFeedbackTuning(CombatFeedbackTuning tuning) {
    _feedbackTuning = tuning;
  }

  /// Sets persistent status visuals for this entity.
  void setStatusVisualMask(int mask) {
    _statusVisualMask = mask;
  }

  /// Triggers a white impact flash.
  void triggerDirectHitFlash({double intensity01 = 1.0}) {
    final intensity = intensity01.clamp(0.0, 1.0);
    if (intensity <= 0.0) return;
    _directHitFlashDurationSeconds = _feedbackTuning.directHitPulse
        .durationForIntensity(intensity);
    _directHitFlashSeconds = _directHitFlashDurationSeconds;
    _directHitFlashStrength = _feedbackTuning.directHitPulse.alphaForIntensity(
      intensity,
    );
  }

  /// Triggers a DoT pulse flash.
  void triggerDotPulse({required Color color, double intensity01 = 1.0}) {
    final intensity = intensity01.clamp(0.0, 1.0);
    if (intensity <= 0.0) return;
    _dotPulseColor = color;
    _dotPulseDurationSeconds = _feedbackTuning.dotPulse.durationForIntensity(
      intensity,
    );
    _dotPulseSeconds = _dotPulseDurationSeconds;
    _dotPulseStrength = _feedbackTuning.dotPulse.alphaForIntensity(intensity);
  }

  /// Triggers a resource-over-time pulse flash.
  void triggerResourcePulse({required Color color, double intensity01 = 1.0}) {
    final intensity = intensity01.clamp(0.0, 1.0);
    if (intensity <= 0.0) return;
    _resourcePulseColor = color;
    _resourcePulseDurationSeconds = _feedbackTuning.resourcePulse
        .durationForIntensity(intensity);
    _resourcePulseSeconds = _resourcePulseDurationSeconds;
    _resourcePulseStrength = _feedbackTuning.resourcePulse.alphaForIntensity(
      intensity,
    );
  }

  void applySnapshot(
    EntityRenderSnapshot e, {
    required int tickHz,
    Vector2? pos,
    AnimKey? overrideAnim,
    int? overrideAnimFrame,
  }) {
    if (pos != null) {
      position.setFrom(pos);
    } else {
      position.setValues(
        math.roundToPixels(e.pos.x),
        math.roundToPixels(e.pos.y),
      );
    }

    var next = overrideAnim ?? e.anim;
    if (_fallbackResolver != null) {
      next = _fallbackResolver(next);
    }
    if (!_availableAnimations.containsKey(next)) {
      next = AnimKey.idle;
    }
    if (current != next) {
      current = next;
    }

    if (_respectFacing) {
      final artFacing = e.artFacingDir ?? Facing.right;
      final sign = e.facing == artFacing ? 1.0 : -1.0;
      final desiredScaleX = _baseScale.x * sign;
      if (scale.x != desiredScaleX || scale.y != _baseScale.y) {
        scale.setValues(desiredScaleX, _baseScale.y);
      }
    } else if (scale.x != _baseScale.x || scale.y != _baseScale.y) {
      scale.setValues(_baseScale.x, _baseScale.y);
    }

    final frameHint = overrideAnimFrame ?? e.animFrame;
    if (frameHint == null) return;

    final ticker = animationTicker;
    final anim = animation;
    if (ticker == null || anim == null) return;

    final framesLen = anim.frames.length;
    if (framesLen <= 1) return;

    final currentKey = current ?? AnimKey.idle;
    final ticksPerFrame = _animSet.ticksPerFrameFor(currentKey, tickHz);
    final rawIndex = frameHint ~/ ticksPerFrame;
    final index = _oneShotKeys.contains(currentKey)
        ? rawIndex.clamp(0, framesLen - 1).toInt()
        : rawIndex % framesLen;
    ticker.currentIndex = index;
  }

  @override
  void update(double dt) {
    _directHitFlashSeconds = dart_math.max(0.0, _directHitFlashSeconds - dt);
    _dotPulseSeconds = dart_math.max(0.0, _dotPulseSeconds - dt);
    _resourcePulseSeconds = dart_math.max(0.0, _resourcePulseSeconds - dt);
    _applyVisualTint();
    super.update(dt);
  }

  void _applyVisualTint() {
    double weightedRed = 0.0;
    double weightedGreen = 0.0;
    double weightedBlue = 0.0;
    double totalWeight = 0.0;
    double totalAlpha = 0.0;

    void addTint(Color color, double alpha) {
      if (alpha <= 0.0) return;
      weightedRed += color.r * alpha;
      weightedGreen += color.g * alpha;
      weightedBlue += color.b * alpha;
      totalWeight += alpha;
      totalAlpha += alpha;
    }

    final statusOverlay = _statusOverlayForMask(_statusVisualMask);
    addTint(statusOverlay.$1, statusOverlay.$2);

    if (_dotPulseSeconds > 0.0 && _dotPulseDurationSeconds > 0.0) {
      final t = (_dotPulseSeconds / _dotPulseDurationSeconds).clamp(0.0, 1.0);
      addTint(
        _dotPulseColor,
        _dotPulseStrength *
            _fadeWeight(t, _feedbackTuning.dotPulse.fadeExponent),
      );
    }
    if (_resourcePulseSeconds > 0.0 && _resourcePulseDurationSeconds > 0.0) {
      final t = (_resourcePulseSeconds / _resourcePulseDurationSeconds).clamp(
        0.0,
        1.0,
      );
      addTint(
        _resourcePulseColor,
        _resourcePulseStrength *
            _fadeWeight(t, _feedbackTuning.resourcePulse.fadeExponent),
      );
    }
    if (_directHitFlashSeconds > 0.0 && _directHitFlashDurationSeconds > 0.0) {
      final t = (_directHitFlashSeconds / _directHitFlashDurationSeconds).clamp(
        0.0,
        1.0,
      );
      addTint(
        _feedbackTuning.directHitColor,
        _directHitFlashStrength *
            _fadeWeight(t, _feedbackTuning.directHitPulse.fadeExponent),
      );
    }

    if (totalWeight <= 0.0 || totalAlpha <= 0.0) {
      paint.colorFilter = null;
      return;
    }

    final red = _channel255(weightedRed / totalWeight);
    final green = _channel255(weightedGreen / totalWeight);
    final blue = _channel255(weightedBlue / totalWeight);
    final alpha = totalAlpha.clamp(0.0, 1.0);
    final color = Color.fromARGB((alpha * 255.0).round(), red, green, blue);
    paint.colorFilter = ColorFilter.mode(color, BlendMode.srcATop);
  }

  (Color, double) _statusOverlayForMask(int mask) {
    if (mask == EntityStatusVisualMask.none) {
      return (const Color(0xFFFFFFFF), 0.0);
    }

    var weightedRed = 0.0;
    var weightedGreen = 0.0;
    var weightedBlue = 0.0;
    var count = 0;

    void addForBit(int bit) {
      final color = _feedbackTuning.statusColorByMaskBit[bit];
      if (color == null) return;
      weightedRed += color.r;
      weightedGreen += color.g;
      weightedBlue += color.b;
      count += 1;
    }

    if ((mask & EntityStatusVisualMask.slow) != 0) {
      addForBit(EntityStatusVisualMask.slow);
    }
    if ((mask & EntityStatusVisualMask.haste) != 0) {
      addForBit(EntityStatusVisualMask.haste);
    }
    if ((mask & EntityStatusVisualMask.vulnerable) != 0) {
      addForBit(EntityStatusVisualMask.vulnerable);
    }
    if ((mask & EntityStatusVisualMask.weaken) != 0) {
      addForBit(EntityStatusVisualMask.weaken);
    }
    if ((mask & EntityStatusVisualMask.drench) != 0) {
      addForBit(EntityStatusVisualMask.drench);
    }
    if ((mask & EntityStatusVisualMask.stun) != 0) {
      addForBit(EntityStatusVisualMask.stun);
    }
    if ((mask & EntityStatusVisualMask.silence) != 0) {
      addForBit(EntityStatusVisualMask.silence);
    }

    if (count == 0) {
      return (const Color(0xFFFFFFFF), 0.0);
    }

    final red = _channel255(weightedRed / count);
    final green = _channel255(weightedGreen / count);
    final blue = _channel255(weightedBlue / count);
    final alpha =
        (_feedbackTuning.statusBaseAlpha +
                ((count - 1) * _feedbackTuning.statusAdditionalAlphaPerEffect))
            .clamp(0.0, _feedbackTuning.statusMaxAlpha);
    return (Color.fromARGB(255, red, green, blue), alpha);
  }

  double _fadeWeight(double value, double exponent) {
    if (value <= 0.0) return 0.0;
    if (value >= 1.0) return 1.0;
    return dart_math.pow(value, exponent).toDouble();
  }

  int _channel255(double value01) {
    final scaled = (value01 * 255.0).round();
    if (scaled < 0) return 0;
    if (scaled > 255) return 255;
    return scaled;
  }
}


===== FILE: lib/game/components/sprite_anim/sprite_anim_set.dart =====
/// Shared render-side sprite animation bundle.
library;

import 'dart:math';

import 'package:flame/components.dart';

import '../../../core/snapshots/enums.dart';

class SpriteAnimSet {
  SpriteAnimSet({
    required this.animations,
    required this.stepTimeSecondsByKey,
    required this.oneShotKeys,
    required this.frameSize,
    this.anchor = Anchor.center,
  });

  final Map<AnimKey, SpriteAnimation> animations;
  final Map<AnimKey, double> stepTimeSecondsByKey;
  final Set<AnimKey> oneShotKeys;

  /// Source frame size inside each horizontal strip image.
  final Vector2 frameSize;

  /// Anchor used by view components when rendering this animation set.
  ///
  /// Defaults to `Anchor.center`.
  final Anchor anchor;

  final Map<int, Map<AnimKey, int>> _ticksPerFrameCache =
      <int, Map<AnimKey, int>>{};

  int ticksPerFrameFor(AnimKey key, int tickHz) {
    final cache = _ticksPerFrameCache.putIfAbsent(
      tickHz,
      () => <AnimKey, int>{},
    );
    final existing = cache[key];
    if (existing != null) return existing;

    final stepSeconds =
        stepTimeSecondsByKey[key] ?? stepTimeSecondsByKey[AnimKey.idle] ?? 0.10;
    final ticks = max(1, (stepSeconds * tickHz).round());
    cache[key] = ticks;
    return ticks;
  }
}


===== FILE: lib/game/components/sprite_anim/strip_animation_loader.dart =====
/// Shared sprite-strip animation loader utilities (render layer only).
library;

import 'dart:ui';

import 'package:flame/cache.dart';
import 'package:flame/components.dart';

import '../../../core/contracts/render_anim_set_definition.dart';
import '../../../core/snapshots/enums.dart';
import '../../../core/util/vec2.dart';
import 'sprite_anim_set.dart';

Future<SpriteAnimSet> loadStripAnimations(
  Images images, {
  required int frameWidth,
  required int frameHeight,
  required Map<AnimKey, String> sourcesByKey,
  Map<AnimKey, int> rowByKey = const <AnimKey, int>{},
  Vec2? anchorInFramePx,
  Map<AnimKey, int> frameStartByKey = const <AnimKey, int>{},
  Map<AnimKey, int> gridColumnsByKey = const <AnimKey, int>{},
  required Map<AnimKey, int> frameCountsByKey,
  required Map<AnimKey, double> stepTimeSecondsByKey,
  required Set<AnimKey> oneShotKeys,
}) async {
  final frameSize = Vector2(frameWidth.toDouble(), frameHeight.toDouble());

  final anchor = switch (anchorInFramePx) {
    null => Anchor.center,
    final a => () {
      assert(
        a.x >= 0 && a.x <= frameWidth,
        'anchorInFramePx.x must be in [0, $frameWidth] (got ${a.x}).',
      );
      assert(
        a.y >= 0 && a.y <= frameHeight,
        'anchorInFramePx.y must be in [0, $frameHeight] (got ${a.y}).',
      );
      return Anchor(a.x / frameWidth, a.y / frameHeight);
    }(),
  };

  final keysByPath = <String, List<AnimKey>>{};
  for (final entry in sourcesByKey.entries) {
    keysByPath.putIfAbsent(entry.value, () => <AnimKey>[]).add(entry.key);
  }

  // Load each unique path once (Images also caches globally, but this keeps the
  // loader itself allocation-light and predictable).
  final imagesByPath = <String, Image>{};
  for (final path in keysByPath.keys) {
    imagesByPath[path] = await images.load(path);
  }

  final animations = <AnimKey, SpriteAnimation>{};
  for (final entry in sourcesByKey.entries) {
    final key = entry.key;
    final path = entry.value;
    final img = imagesByPath[path]!;

    final stepTime =
        stepTimeSecondsByKey[key] ?? stepTimeSecondsByKey[AnimKey.idle] ?? 0.1;
    final frameCount =
        frameCountsByKey[key] ?? frameCountsByKey[AnimKey.idle] ?? 1;
    final row = rowByKey[key] ?? 0;
    final startFrame = frameStartByKey[key] ?? 0;
    final gridColumns = gridColumnsByKey[key];

    assert(
      startFrame >= 0,
      'frameStartByKey[$key] must be >= 0 (got $startFrame).',
    );
    assert(
      gridColumns == null || gridColumns > 0,
      'gridColumnsByKey[$key] must be > 0 when provided.',
    );

    final sprites = List<Sprite>.generate(frameCount, (i) {
      final frameIndex = startFrame + i;
      final col = gridColumns == null ? frameIndex : frameIndex % gridColumns;
      final rowOffset = gridColumns == null ? 0 : frameIndex ~/ gridColumns;
      return Sprite(
        img,
        srcPosition: Vector2(
          frameWidth.toDouble() * col,
          frameHeight.toDouble() * (row + rowOffset),
        ),
        srcSize: frameSize,
      );
    });

    animations[key] = SpriteAnimation.spriteList(
      sprites,
      stepTime: stepTime,
      loop: !oneShotKeys.contains(key),
    );
  }

  return SpriteAnimSet(
    animations: animations,
    stepTimeSecondsByKey: stepTimeSecondsByKey,
    oneShotKeys: oneShotKeys,
    frameSize: frameSize,
    anchor: anchor,
  );
}

Future<SpriteAnimSet> loadAnimSetFromDefinition(
  Images images, {
  required RenderAnimSetDefinition renderAnim,
  required Set<AnimKey> oneShotKeys,
}) async {
  final animSet = await loadStripAnimations(
    images,
    frameWidth: renderAnim.frameWidth,
    frameHeight: renderAnim.frameHeight,
    sourcesByKey: renderAnim.sourcesByKey,
    rowByKey: renderAnim.rowByKey,
    anchorInFramePx: renderAnim.anchorInFramePx,
    frameStartByKey: renderAnim.frameStartByKey,
    gridColumnsByKey: renderAnim.gridColumnsByKey,
    frameCountsByKey: renderAnim.frameCountsByKey,
    stepTimeSecondsByKey: renderAnim.stepTimeSecondsByKey,
    oneShotKeys: oneShotKeys,
  );

  // Default spawn to idle when no dedicated strip exists.
  animSet.animations[AnimKey.spawn] ??= animSet.animations[AnimKey.idle]!;

  return animSet;
}


===== FILE: lib/game/debug/debug_aabb_overlay.dart =====
/// Reusable helper for syncing AABB debug overlays from Core snapshots.
library;

import 'package:flame/components.dart';
import 'package:flutter/widgets.dart';

import '../../core/snapshots/entity_render_snapshot.dart';
import '../util/math_util.dart' as math;

void syncDebugAabbOverlays({
  required Iterable<EntityRenderSnapshot> entities,
  required bool enabled,
  required Component parent,
  required Map<int, RectangleComponent> pool,
  required int priority,
  required Paint paint,
  bool Function(EntityRenderSnapshot e)? include,
  Map<int, EntityRenderSnapshot>? prevById,
  double Function(EntityRenderSnapshot e)? offsetXFor,
  double Function(EntityRenderSnapshot e)? offsetYFor,
  double alpha = 1.0,
  Vector2? cameraCenter,
}) {
  if (!enabled) {
    if (pool.isEmpty) return;
    for (final view in pool.values) {
      view.removeFromParent();
    }
    pool.clear();
    return;
  }

  final seen = <int>{};

  for (final e in entities) {
    if (include != null && !include(e)) continue;
    final size = e.size;
    if (size == null) continue;

    seen.add(e.id);

    var view = pool[e.id];
    if (view == null) {
      view = RectangleComponent(
        size: Vector2(size.x, size.y),
        anchor: Anchor.center,
        paint: paint,
      )..priority = priority;
      pool[e.id] = view;
      parent.add(view);
    } else {
      view.size.setValues(size.x, size.y);
    }

    final prev = prevById == null ? null : prevById[e.id];
    final prevPos = prev?.pos ?? e.pos;
    final prevOffsetX = offsetXFor?.call(prev ?? e) ?? 0.0;
    final prevOffsetY = offsetYFor?.call(prev ?? e) ?? 0.0;
    final offsetX = offsetXFor?.call(e) ?? 0.0;
    final offsetY = offsetYFor?.call(e) ?? 0.0;
    final worldX = math.lerpDouble(
      prevPos.x + prevOffsetX,
      e.pos.x + offsetX,
      alpha,
    );
    final worldY = math.lerpDouble(
      prevPos.y + prevOffsetY,
      e.pos.y + offsetY,
      alpha,
    );
    if (cameraCenter == null) {
      view.position.setValues(
        math.roundToPixels(worldX),
        math.roundToPixels(worldY),
      );
    } else {
      view.position.setValues(
        math.snapWorldToPixelsInCameraSpace1d(worldX, cameraCenter.x),
        math.snapWorldToPixelsInCameraSpace1d(worldY, cameraCenter.y),
      );
    }
  }

  if (pool.isEmpty) return;
  final toRemove = <int>[];
  for (final id in pool.keys) {
    if (!seen.contains(id)) toRemove.add(id);
  }
  for (final id in toRemove) {
    pool.remove(id)?.removeFromParent();
  }
}


===== FILE: lib/game/debug/render_debug_flags.dart =====
/// Render-layer debug flags.
///
/// Kept in `lib/game/**` so Core remains pure/deterministic and unaware of
/// any debug drawing concerns.
library;

import 'package:flutter/foundation.dart';

abstract class RenderDebugFlags {
  /// Draws collision AABB overlays for "actor" entities (player + enemies).
  ///
  /// Default is `false` even in debug builds; toggle locally when needed.
  static bool drawActorHitboxes = false;

  /// Convenience for enabling all render debug overlays in debug/profile
  /// builds while keeping release builds clean.
  static bool get canUseRenderDebug => !kReleaseMode;
}



===== FILE: lib/game/game_controller.dart =====
// Bridge between Core simulation and the Flutter/Flame runtime.
//
// Responsibilities:
// - Owns the `GameCore` instance
// - Queues tick-stamped input commands
// - Runs a fixed-tick simulation loop using an accumulator
// - Exposes (`prevSnapshot`, `snapshot`, `alpha`) for render interpolation
// - Buffers transient `GameEvent`s for Render/UI to consume
import 'dart:math';

import 'package:flutter/foundation.dart';

import '../core/abilities/ability_def.dart';
import '../core/commands/command.dart';
import '../core/enemies/enemy_catalog.dart';
import '../core/events/game_event.dart';
import '../core/game_core.dart';
import '../core/snapshots/game_state_snapshot.dart';
import '../core/tuning/score_tuning.dart';
import 'tick_input_frame.dart';

typedef GameEventListener = void Function(GameEvent event);

/// Owns the simulation clock and provides a stable interface to UI/renderer.
class GameController extends ChangeNotifier {
  GameController({required GameCore core, this.tickHz = 60, this.inputLead = 1})
    : _core = core {
    if (tickHz <= 0) {
      throw ArgumentError.value(tickHz, 'tickHz', 'must be > 0');
    }
    if (inputLead < 1) {
      throw ArgumentError.value(inputLead, 'inputLead', 'must be >= 1');
    }
    if (tickHz != _core.tickHz) {
      throw ArgumentError(
        'GameController.tickHz ($tickHz) must match GameCore.tickHz (${_core.tickHz}).',
      );
    }
    _curr = _core.buildSnapshot();
    _prev = _curr;
  }

  final GameCore _core;

  /// Fixed simulation tick frequency.
  final int tickHz;

  /// How many ticks ahead local input is scheduled by default.
  ///
  /// `1` means "next tick".
  final int inputLead;

  /// Buffered commands keyed by their target tick.
  final Map<int, TickInputFrame> _inputsByTick = <int, TickInputFrame>{};

  /// Scratch buffer for building command lists without allocation.
  final List<Command> _commandScratch = <Command>[];

  /// Fallback input frame for ticks with no buffered commands.
  final TickInputFrame _frameScratch = TickInputFrame();

  /// Buffered transient events produced by the core.
  final List<GameEvent> _events = <GameEvent>[];

  /// Optional event listeners (render/UI side-effects).
  ///
  /// Listeners are invoked for every event emitted by Core, before events are
  /// buffered into [_events].
  final List<GameEventListener> _eventListeners = <GameEventListener>[];

  /// The most recent [RunEndedEvent], if any.
  ///
  /// Stored separately so UI can access it after events are drained.
  RunEndedEvent? lastRunEndedEvent;

  late GameStateSnapshot _prev;
  late GameStateSnapshot _curr;

  /// Accumulated time for fixed-tick simulation.
  double _accumulatorSeconds = 0;

  /// Current simulation tick (authoritative).
  int get tick => _core.tick;

  ScoreTuning get scoreTuning => _core.scoreTuning;

  EnemyCatalog get enemyCatalog => _core.enemyCatalog;

  /// Latest snapshot produced by the core.
  GameStateSnapshot get snapshot => _curr;

  /// Previous snapshot (used for render interpolation).
  GameStateSnapshot get prevSnapshot => _prev;

  /// Interpolation factor between `prevSnapshot` and `snapshot` for rendering.
  double get alpha {
    final dtTick = 1.0 / tickHz;
    return (_accumulatorSeconds / dtTick).clamp(0, 1);
  }

  /// Enqueues a command to be applied at its declared tick.
  void enqueue(Command command) {
    final frame = _inputsByTick.putIfAbsent(
      command.tick,
      () => TickInputFrame(),
    );
    frame.apply(command);
  }

  /// Helper to schedule a command for the next tick (plus `inputLead`).
  void enqueueForNextTick(Command Function(int tick) factory) {
    enqueue(factory(tick + inputLead));
  }

  /// Drains and clears all buffered transient events.
  List<GameEvent> drainEvents() {
    if (_events.isEmpty) return const <GameEvent>[];
    final drained = List<GameEvent>.unmodifiable(_events);
    _events.clear();
    return drained;
  }

  /// Registers a callback to observe transient [GameEvent]s.
  ///
  /// This is useful for render-only effects (e.g. death animations) that should
  /// not require draining the shared event buffer.
  void addEventListener(GameEventListener listener) {
    if (_eventListeners.contains(listener)) return;
    _eventListeners.add(listener);
  }

  void removeEventListener(GameEventListener listener) {
    _eventListeners.remove(listener);
  }

  /// Pauses/unpauses the simulation.
  void setPaused(bool value) {
    if (_core.paused == value) return;
    _core.paused = value;
    _accumulatorSeconds = 0;
    _prev = _core.buildSnapshot();
    _curr = _prev;
    notifyListeners();
  }

  /// Permanently stops this controller for the current session.
  ///
  /// Use this when leaving the mini-game route (dispose), NOT for backgrounding
  /// (that's what [setPaused] is for).
  ///
  /// What it does:
  /// - pauses the core
  /// - clears queued commands (prevents "stuck input" on next mount)
  /// - clears buffered transient events
  /// - resets interpolation state (accumulator + snapshots)
  void shutdown() {
    // Pause regardless of current state (do NOT early-return like setPaused()).
    _core.paused = true;

    // Drop any in-flight fixed-tick accumulation.
    _accumulatorSeconds = 0;

    // Kill transient buffers so nothing leaks across sessions.
    _inputsByTick.clear();
    _events.clear();

    // Make snapshots consistent with the paused state.
    _curr = _core.buildSnapshot();
    _prev = _curr;
    lastRunEndedEvent = null;
    notifyListeners();
  }

  /// Ends the current run early (player quit).
  ///
  /// Triggers a [RunEndedEvent] with the current score and resets interpolation.
  void giveUp() {
    if (_core.gameOver) return;
    _core.giveUp();
    _accumulatorSeconds = 0;

    _collectCoreEvents();

    _prev = _core.buildSnapshot();
    _curr = _prev;
    notifyListeners();
  }

  /// Advances the simulation clock based on a variable frame delta.
  ///
  /// This uses an accumulator to execute a fixed number of simulation ticks.
  /// [dtSeconds] is clamped to [dtFrameMaxSeconds] (default 100ms) to avoid
  /// "spiral of death" when the app resumes from background or after a lag spike.
  void advanceFrame(double dtSeconds, {double dtFrameMaxSeconds = 0.1}) {
    if (dtSeconds.isNaN || dtSeconds.isInfinite) return;
    if (_core.paused) {
      _accumulatorSeconds = 0;
      return;
    }

    final clamped = max(0.0, min(dtSeconds, dtFrameMaxSeconds));
    _accumulatorSeconds += clamped;

    final dtTick = 1.0 / tickHz;
    var didStep = false;

    while (_accumulatorSeconds >= dtTick) {
      if (_core.paused) {
        _accumulatorSeconds = 0;
        break;
      }
      final nextTick = _core.tick + 1;
      final input = _inputsByTick.remove(nextTick) ?? _frameScratch;
      _applyTickInput(nextTick, input);
      _core.stepOneTick();

      _collectCoreEvents();

      _prev = _curr;
      _curr = _core.buildSnapshot();
      _accumulatorSeconds -= dtTick;
      didStep = true;

      // If the core became paused during the tick (e.g. game over), stop consuming
      // accumulator to avoid an infinite loop.
      if (_core.paused) {
        _accumulatorSeconds = 0;
        break;
      }
    }
    if (didStep) {
      notifyListeners();
    }
  }

  /// Drains events from the core and buffers them for UI consumption.
  ///
  /// Also captures [RunEndedEvent] into [lastRunEndedEvent] for easy access.
  void _collectCoreEvents() {
    final newEvents = _core.drainEvents();
    for (final event in newEvents) {
      if (event is RunEndedEvent) {
        lastRunEndedEvent = event;
      }
      if (_eventListeners.isNotEmpty) {
        for (final listener in _eventListeners) {
          listener(event);
        }
      }
    }
    if (newEvents.isNotEmpty) {
      _events.addAll(newEvents);
    }
  }

  /// Converts a [TickInputFrame] into [Command]s and applies them to the core.
  ///
  /// Uses [_commandScratch] to avoid allocating a new list each tick.
  /// Only non-default values are sent (e.g., zero axis is skipped since the
  /// core treats absence of input as no movement).
  void _applyTickInput(int tick, TickInputFrame input) {
    _commandScratch.clear();

    final axis = input.moveAxis;
    if (axis != 0) {
      _commandScratch.add(MoveAxisCommand(tick: tick, axis: axis));
    }

    if (input.aimDirSet) {
      _commandScratch.add(
        AimDirCommand(tick: tick, x: input.aimDirX, y: input.aimDirY),
      );
    }
    if (input.jumpPressed) {
      _commandScratch.add(JumpPressedCommand(tick: tick));
    }
    if (input.dashPressed) {
      _commandScratch.add(DashPressedCommand(tick: tick));
    }
    if (input.strikePressed) {
      _commandScratch.add(StrikePressedCommand(tick: tick));
    }
    if (input.projectilePressed) {
      _commandScratch.add(ProjectilePressedCommand(tick: tick));
    }
    if (input.secondaryPressed) {
      _commandScratch.add(SecondaryPressedCommand(tick: tick));
    }
    if (input.spellPressed) {
      _commandScratch.add(SpellPressedCommand(tick: tick));
    }
    final heldChangedMask = input.abilitySlotHeldChangedMask;
    if (heldChangedMask != 0) {
      for (final slot in AbilitySlot.values) {
        final bit = 1 << slot.index;
        if ((heldChangedMask & bit) == 0) continue;
        final held = (input.abilitySlotHeldValueMask & bit) != 0;
        _commandScratch.add(
          AbilitySlotHeldCommand(tick: tick, slot: slot, held: held),
        );
      }
    }

    _core.applyCommands(_commandScratch);

    // If this is a scratch fallback, it will be reset by the next use anyway.
    // For frames stored in the map we drop the instance after remove().
    input.reset();
  }
}


===== FILE: lib/game/input/aim_preview.dart =====
// Observable aim preview state for the UI layer.
//
// Provides reactive state so that UI widgets (e.g., aim indicators, arrows)
// can listen and update when the player begins aiming, moves the aim direction,
// or releases aim input. This decouples the input router from the rendering layer.
import 'package:flutter/foundation.dart';

/// Immutable snapshot of the current aim preview state.
///
/// - [active]: Whether the player is currently in aiming mode (e.g., touch held).
/// - [hasAim]: Whether a valid aim direction has been determined.
/// - [dirX], [dirY]: The normalized aim direction vector (only meaningful when [hasAim] is true).
class AimPreviewState {
  const AimPreviewState({
    required this.active,
    required this.hasAim,
    required this.dirX,
    required this.dirY,
  });

  /// True when the player is actively aiming (e.g., dragging on the cast button).
  final bool active;

  /// True when a valid direction has been established (drag exceeds dead zone).
  final bool hasAim;

  /// Horizontal component of the normalized aim direction.
  final double dirX;

  /// Vertical component of the normalized aim direction.
  final double dirY;

  /// Default state when the player is not aiming.
  static const AimPreviewState inactive = AimPreviewState(
    active: false,
    hasAim: false,
    dirX: 0,
    dirY: 0,
  );
}

/// Reactive model for aim preview state.
///
/// Extends [ValueNotifier] so UI widgets can listen for changes via
/// [ValueListenableBuilder] or similar patterns. The input layer updates this
/// model as the player interacts with aim controls, and the UI layer consumes
/// it to render visual feedback (e.g., directional arrow, aim reticle).
class AimPreviewModel extends ValueNotifier<AimPreviewState> {
  /// Creates an [AimPreviewModel] initialized to the inactive state.
  AimPreviewModel() : super(AimPreviewState.inactive);

  /// Called when the player starts an aiming gesture (e.g., touch down on cast button).
  ///
  /// Sets [active] to true but [hasAim] remains false until a direction is established.
  void begin() {
    value = const AimPreviewState(
      active: true,
      hasAim: false,
      dirX: 0,
      dirY: 0,
    );
  }

  /// Updates the aim direction during an active aiming gesture.
  ///
  /// [x] and [y] should be the normalized direction vector.
  /// Sets both [active] and [hasAim] to true.
  void updateAim(double x, double y) {
    value = AimPreviewState(active: true, hasAim: true, dirX: x, dirY: y);
  }

  /// Clears the aim direction while keeping the aiming gesture active.
  ///
  /// Used when the drag returns inside the dead zone—player is still touching
  /// but hasn't committed to a direction yet.
  void clearAim() {
    value = const AimPreviewState(
      active: true,
      hasAim: false,
      dirX: 0,
      dirY: 0,
    );
  }

  /// Called when the player ends the aiming gesture (e.g., touch up).
  ///
  /// Resets the model to the fully inactive state.
  void end() {
    value = AimPreviewState.inactive;
  }
}


===== FILE: lib/game/input/aim_quantizer.dart =====
// Utility for quantizing aim direction values.
//
// Quantization reduces floating-point precision to avoid scheduling redundant
// aim commands when the direction changes by negligible amounts. This improves
// determinism and reduces command spam in the input queue.

/// Quantizes aim direction components to a fixed precision.
///
/// By rounding to 1/256 increments, tiny floating-point variations (e.g., from
/// touch jitter) are collapsed into stable values. This ensures:
/// - Fewer redundant [AimDirCommand] commands.
/// - Consistent behavior across frames when the aim direction is nearly unchanged.
class AimQuantizer {
  /// Private constructor to prevent instantiation; all methods are static.
  const AimQuantizer._();

  /// Quantization scale factor (256 levels per unit).
  ///
  /// Chosen to provide ~0.4% precision, which is imperceptible to players
  /// but sufficient to filter out floating-point noise.
  static const double _aimQuantizeScale = 256.0;

  /// Returns [value] rounded to the nearest 1/256 increment.
  ///
  /// Returns 0 unchanged to preserve exact zero (no aim bias).
  static double quantize(double value) {
    if (value == 0) return 0;
    return (value * _aimQuantizeScale).roundToDouble() / _aimQuantizeScale;
  }
}


===== FILE: lib/game/input/runner_input_router.dart =====
import 'dart:math';

import '../../core/abilities/ability_def.dart';
import '../../core/commands/command.dart';
import '../game_controller.dart';
import 'aim_quantizer.dart';

/// Shared input scheduler for multiple input sources (touch + keyboard + mouse).
///
/// - Holds the current continuous inputs (move axis, aim).
/// - Schedules them into the GameController for upcoming ticks so Core receives
///   tick-stamped Commands.
/// - Schedules edge-triggered presses and slot-hold transitions for the next tick.
///
/// The router distinguishes between:
/// - **Continuous inputs** (movement axis, aim directions): pumped each frame via
///   [pumpHeldInputs], scheduling commands for upcoming ticks.
/// - **Slot hold edges** (start/release): emitted once on transition and then
///   latched in Core until the opposite edge arrives.
/// - **Edge-triggered inputs** (jump, dash, strike, projectile): one-shot events
///   scheduled immediately for the next tick via [pressJump], [pressDash], etc.
class RunnerInputRouter {
  /// Creates a router bound to the given [controller].
  RunnerInputRouter({required this.controller});

  /// The game controller that receives scheduled commands.
  final GameController controller;

  /// Input buffering window in seconds.
  ///
  /// This determines how far ahead continuous inputs (move, aim) are scheduled
  /// to smooth over frame rate hitches.
  static const double _inputBufferSeconds = 0.1;

  // ─────────────────────────────────────────────────────────────────────────
  // Movement axis state
  // ─────────────────────────────────────────────────────────────────────────

  /// Current horizontal movement axis in [-1, 1]. Set by touch/keyboard input.
  double _moveAxis = 0;

  /// Last axis value that was scheduled, used to detect changes.
  double _lastScheduledAxis = 0;

  /// Highest tick for which axis commands have been enqueued.
  int _axisScheduledThroughTick = 0;

  // ─────────────────────────────────────────────────────────────────────────
  // Global aim state
  // ─────────────────────────────────────────────────────────────────────────

  final _AimInputChannel _aim = _AimInputChannel();
  int _heldAbilitySlotMask = 0;

  // ─────────────────────────────────────────────────────────────────────────
  // Public setters for continuous inputs
  // ─────────────────────────────────────────────────────────────────────────

  /// Sets the horizontal movement axis (clamped to [-1, 1]).
  ///
  /// Called by joystick or keyboard handlers. The value is held until changed
  /// and pumped to the controller each frame via [pumpHeldInputs].
  void setMoveAxis(double axis) {
    _moveAxis = axis.clamp(-1.0, 1.0);
  }

  /// Sets the global aim direction (should be normalized or near-normalized).
  ///
  /// The direction is quantized to reduce floating-point noise. If the quantized
  /// value matches the current aim, the call is a no-op to avoid redundant updates.
  void setAimDir(double x, double y) => _aim.set(x, y);

  /// Clears the global aim direction.
  ///
  /// Called when the player releases the aim input. Subsequent [pumpHeldInputs]
  /// calls will schedule [ClearAimDirCommand] for upcoming ticks.
  void clearAimDir() => _aim.clear();

  // ─────────────────────────────────────────────────────────────────────────
  // Edge-triggered (one-shot) input methods
  // ─────────────────────────────────────────────────────────────────────────

  /// Schedules a jump press for the next tick.
  void pressJump() =>
      controller.enqueueForNextTick((tick) => JumpPressedCommand(tick: tick));

  /// Schedules a dash press for the next tick.
  void pressDash() =>
      controller.enqueueForNextTick((tick) => DashPressedCommand(tick: tick));

  /// Schedules a melee strike press for the next tick.
  void pressStrike() =>
      controller.enqueueForNextTick((tick) => StrikePressedCommand(tick: tick));

  /// Schedules a projectile slot press for the next tick.
  void pressProjectile() => controller.enqueueForNextTick(
    (tick) => ProjectilePressedCommand(tick: tick),
  );

  /// Schedules a secondary-slot press for the next tick.
  void pressSecondary() => controller.enqueueForNextTick(
    (tick) => SecondaryPressedCommand(tick: tick),
  );

  /// Schedules a spell-slot press for the next tick.
  void pressSpell() =>
      controller.enqueueForNextTick((tick) => SpellPressedCommand(tick: tick));

  /// Starts holding the primary slot and commits it on the next tick.
  void startPrimaryHold() {
    if (!_startExclusiveAbilitySlotHold(AbilitySlot.primary)) return;
    final tick = controller.tick + controller.inputLead;
    controller.enqueue(StrikePressedCommand(tick: tick));
  }

  /// Releases the primary slot hold.
  void endPrimaryHold() {
    if (!_setAbilitySlotHold(AbilitySlot.primary, false)) return;
    final tick = controller.tick + controller.inputLead;
    controller.enqueue(
      AbilitySlotHeldCommand(
        tick: tick,
        slot: AbilitySlot.primary,
        held: false,
      ),
    );
  }

  /// Starts holding the secondary slot and commits it on the next tick.
  void startSecondaryHold() {
    if (!_startExclusiveAbilitySlotHold(AbilitySlot.secondary)) return;
    final tick = controller.tick + controller.inputLead;
    controller.enqueue(SecondaryPressedCommand(tick: tick));
  }

  /// Releases the secondary slot hold.
  void endSecondaryHold() {
    if (!_setAbilitySlotHold(AbilitySlot.secondary, false)) return;
    final tick = controller.tick + controller.inputLead;
    controller.enqueue(
      AbilitySlotHeldCommand(
        tick: tick,
        slot: AbilitySlot.secondary,
        held: false,
      ),
    );
  }

  /// Starts holding the mobility slot and commits it on the next tick.
  void startMobilityHold() {
    if (!_startExclusiveAbilitySlotHold(AbilitySlot.mobility)) return;
    final tick = controller.tick + controller.inputLead;
    controller.enqueue(DashPressedCommand(tick: tick));
  }

  /// Releases the mobility slot hold.
  void endMobilityHold() {
    if (!_setAbilitySlotHold(AbilitySlot.mobility, false)) return;
    final tick = controller.tick + controller.inputLead;
    controller.enqueue(
      AbilitySlotHeldCommand(
        tick: tick,
        slot: AbilitySlot.mobility,
        held: false,
      ),
    );
  }

  /// Starts holding [slot] without committing the slot action.
  void startAbilitySlotHold(AbilitySlot slot) {
    _startExclusiveAbilitySlotHold(slot);
  }

  /// Releases [slot] hold state without committing the slot action.
  void endAbilitySlotHold(AbilitySlot slot) {
    if (!_setAbilitySlotHold(slot, false)) return;
    final tick = controller.tick + controller.inputLead;
    controller.enqueue(
      AbilitySlotHeldCommand(tick: tick, slot: slot, held: false),
    );
  }

  // ─────────────────────────────────────────────────────────────────────────
  // Combined action methods (aim + action in a single tick)
  // ─────────────────────────────────────────────────────────────────────────

  /// Presses projectile on the next tick and ensures the global aim direction
  /// is set for the same tick.
  void pressProjectileWithAim() {
    commitProjectileWithAim(clearAim: false);
  }

  /// Commits projectile on the next tick using the current aim dir (if set).
  ///
  /// When [clearAim] is true, clear commands are delayed until after the commit
  /// tick to avoid overwriting the aimed shot.
  void commitProjectileWithAim({required bool clearAim}) {
    final tick = controller.tick + controller.inputLead;
    final hadAim = _aim.isSet;
    if (hadAim) {
      controller.enqueue(AimDirCommand(tick: tick, x: _aim.x, y: _aim.y));
    }

    controller.enqueue(ProjectilePressedCommand(tick: tick));

    if (clearAim) {
      _aim.clear();
      if (hadAim) {
        // Prevent immediate clear command from overwriting the aim we just committed
        _aim.blockClearThrough(tick);
      }
    }
  }

  /// Commits a melee strike on the next tick using the current aim dir.
  void commitMeleeStrike() {
    final tick = controller.tick + controller.inputLead;
    final hadAim = _aim.isSet;
    if (hadAim) {
      controller.enqueue(AimDirCommand(tick: tick, x: _aim.x, y: _aim.y));
    } else {
      controller.enqueue(ClearAimDirCommand(tick: tick));
    }
    controller.enqueue(StrikePressedCommand(tick: tick));

    // Clear aim after commit (release behavior).
    _aim.clear();
    if (hadAim) {
      _aim.blockClearThrough(tick);
    }
  }

  /// Commits the secondary slot on the next tick using the current aim dir.
  void commitSecondaryStrike() {
    final tick = controller.tick + controller.inputLead;
    final hadAim = _aim.isSet;
    if (hadAim) {
      controller.enqueue(AimDirCommand(tick: tick, x: _aim.x, y: _aim.y));
    } else {
      controller.enqueue(ClearAimDirCommand(tick: tick));
    }
    controller.enqueue(SecondaryPressedCommand(tick: tick));

    // Clear aim after commit (release behavior).
    _aim.clear();
    if (hadAim) {
      _aim.blockClearThrough(tick);
    }
  }

  /// Commits mobility on the next tick using the current aim dir (if set).
  void commitMobilityWithAim({required bool clearAim}) {
    final tick = controller.tick + controller.inputLead;
    final hadAim = _aim.isSet;
    if (hadAim) {
      controller.enqueue(AimDirCommand(tick: tick, x: _aim.x, y: _aim.y));
    }

    controller.enqueue(DashPressedCommand(tick: tick));

    if (clearAim) {
      _aim.clear();
      if (hadAim) {
        _aim.blockClearThrough(tick);
      }
    }
  }

  // ─────────────────────────────────────────────────────────────────────────
  // Frame pump: schedule continuous inputs for upcoming ticks
  // ─────────────────────────────────────────────────────────────────────────

  /// Schedules the current held inputs across upcoming ticks.
  ///
  /// This method should be called once per frame, before `controller.advanceFrame(dt)`,
  /// to ensure that continuous inputs (movement and aim) are scheduled
  /// far enough ahead that the simulation always has input data available.
  ///
  /// The scheduling window extends `inputLead + maxTicksPerFrame` ticks into the
  /// future to handle variable frame rates without input starvation.
  void pumpHeldInputs() {
    // 1. Movement: enqueue MoveAxisCommand for upcoming ticks (or overwrite if axis changed).
    _scheduleHeldMoveAxis();

    // 2. Global aim: enqueue aim direction or clear commands for upcoming ticks.
    _aim.schedule(
      controller,
      _inputBufferSeconds,
      (t, x, y) => AimDirCommand(tick: t, x: x, y: y),
      (t) => ClearAimDirCommand(tick: t),
    );
  }

  /// Schedules [MoveAxisCommand]s for upcoming ticks based on the current axis value.
  ///
  /// Detects axis changes and re-schedules to overwrite any already-buffered ticks.
  void _scheduleHeldMoveAxis() {
    final axis = _moveAxis;

    if (axis == 0 && _lastScheduledAxis == 0) {
      // No held axis and nothing to override.
      _axisScheduledThroughTick = controller.tick;
      return;
    }

    if (axis != _lastScheduledAxis) {
      // Axis changed (including to 0); reschedule to overwrite any already
      // buffered ticks.
      _axisScheduledThroughTick = controller.tick;
      _lastScheduledAxis = axis;
    }

    final maxTicksPerFrame = (controller.tickHz * _inputBufferSeconds).ceil();
    final targetMaxTick =
        controller.tick + controller.inputLead + maxTicksPerFrame;

    final startTick = max(controller.tick + 1, _axisScheduledThroughTick + 1);
    for (var t = startTick; t <= targetMaxTick; t += 1) {
      controller.enqueue(MoveAxisCommand(tick: t, axis: axis));
    }
    _axisScheduledThroughTick = targetMaxTick;
  }

  bool _setAbilitySlotHold(AbilitySlot slot, bool held) {
    final bit = 1 << slot.index;
    final currentlyHeld = (_heldAbilitySlotMask & bit) != 0;
    if (currentlyHeld == held) return false;
    if (held) {
      // Only one held slot at a time; latest hold wins.
      _heldAbilitySlotMask = bit;
    } else {
      _heldAbilitySlotMask &= ~bit;
    }
    return true;
  }

  bool _startExclusiveAbilitySlotHold(AbilitySlot slot) {
    final previousMask = _heldAbilitySlotMask;
    if (!_setAbilitySlotHold(slot, true)) return false;

    final tick = controller.tick + controller.inputLead;

    // Emit release edges for previously held slots so same-tick transitions
    // preserve latest-hold-wins even after frame aggregation.
    for (final other in AbilitySlot.values) {
      if (other == slot) continue;
      final bit = 1 << other.index;
      if ((previousMask & bit) == 0) continue;
      controller.enqueue(
        AbilitySlotHeldCommand(tick: tick, slot: other, held: false),
      );
    }

    controller.enqueue(
      AbilitySlotHeldCommand(tick: tick, slot: slot, held: true),
    );
    return true;
  }
}

/// Helper class that owns one global aim channel and its scheduling state.
class _AimInputChannel {
  /// Whether an aim direction is currently set.
  bool isSet = false;

  /// The X component of the current aim direction (quantized).
  double x = 0;

  /// The Y component of the current aim direction (quantized).
  double y = 0;

  // -- Scheduling State --

  /// Whether the aim was set during the last schedule pass.
  bool _lastScheduledSet = false;

  /// The X component scheduled during the last pass.
  double _lastScheduledX = 0;

  /// The Y component scheduled during the last pass.
  double _lastScheduledY = 0;

  /// The highest tick for which we have already scheduled aim commands.
  int _scheduledThroughTick = 0;

  /// Tick through which clear commands are blocked.
  ///
  /// This is used when a commit action uses the aim, and we want
  /// to ensure the subsequent clear command doesn't overwrite it in the same tick.
  int _clearBlockedThroughTick = 0;

  /// Updates the aim direction.
  void set(double rawX, double rawY) {
    final qx = AimQuantizer.quantize(rawX);
    final qy = AimQuantizer.quantize(rawY);

    if (isSet && qx == x && qy == y) {
      return;
    }

    isSet = true;
    x = qx;
    y = qy;
  }

  /// Clears the aim direction.
  void clear() {
    isSet = false;
    x = 0;
    y = 0;
  }

  /// Prevents `Clear...Command` from being scheduled up to and including [tick].
  void blockClearThrough(int tick) {
    _clearBlockedThroughTick = max(_clearBlockedThroughTick, tick);
  }

  /// Schedules aim or clear commands for upcoming ticks.
  ///
  /// [bufferSeconds] determines how far ahead to schedule.
  /// [createAimCmd] factory for aim command construction.
  /// [createClearCmd] factory for the specific clear command.
  void schedule(
    GameController controller,
    double bufferSeconds,
    Command Function(int tick, double x, double y) createAimCmd,
    Command Function(int tick) createClearCmd,
  ) {
    if (!isSet && !_lastScheduledSet) {
      // No held aim and nothing to override.
      _scheduledThroughTick = controller.tick;
      return;
    }

    if (isSet != _lastScheduledSet) {
      // Aim active state changed; force reschedule from current tick to overwrite buffers.
      _scheduledThroughTick = controller.tick;
      _lastScheduledSet = isSet;
      _lastScheduledX = x;
      _lastScheduledY = y;
    }

    if (isSet && (x != _lastScheduledX || y != _lastScheduledY)) {
      // Vector changed; force reschedule from current tick.
      _scheduledThroughTick = controller.tick;
      _lastScheduledX = x;
      _lastScheduledY = y;
    }

    final maxTicksPerFrame = (controller.tickHz * bufferSeconds).ceil();
    final targetMaxTick =
        controller.tick + controller.inputLead + maxTicksPerFrame;

    var startTick = max(controller.tick + 1, _scheduledThroughTick + 1);

    // If we are clearing aim, ensure we don't overwrite a committed action tick.
    if (!isSet) {
      startTick = max(startTick, _clearBlockedThroughTick + 1);
    }

    for (var t = startTick; t <= targetMaxTick; t += 1) {
      if (isSet) {
        controller.enqueue(createAimCmd(t, x, y));
      } else {
        controller.enqueue(createClearCmd(t));
      }
    }
    _scheduledThroughTick = targetMaxTick;
  }
}


===== FILE: lib/game/runner_flame_game.dart =====
// Flame rendering layer for the runner (Milestone 0 placeholder).
//
// Reads the latest `GameStateSnapshot` from `GameController` each frame and
// renders a minimal representation (a player dot + debug text). This file is
// intentionally tiny and non-authoritative: gameplay truth lives in Core.
import 'dart:math' as dart_math;

import 'package:flame/components.dart';
import 'package:flame/game.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/widgets.dart';

import '../core/contracts/render_contract.dart';
import '../core/events/game_event.dart';
import '../core/players/player_character_definition.dart';
import '../core/snapshots/entity_render_snapshot.dart';
import '../core/snapshots/enums.dart';
import '../core/snapshots/static_solid_snapshot.dart';
import 'debug/debug_aabb_overlay.dart';
import 'debug/render_debug_flags.dart';
import 'components/player/player_animations.dart';
import 'components/player/player_view_component.dart';
import 'components/enemies/enemy_render_registry.dart';
import 'components/pickups/pickup_render_registry.dart';
import 'components/projectiles/projectile_render_registry.dart';
import 'components/sprite_anim/deterministic_anim_view_component.dart';
import 'components/ground_surface_component.dart';
import 'components/ground_band_parallax_foreground_component.dart';
import 'tuning/player_render_tuning.dart';
import 'tuning/combat_feedback_tuning.dart';
import 'input/runner_input_router.dart';
import 'input/aim_preview.dart';
import 'components/pixel_parallax_backdrop_component.dart';
import 'components/aim_ray_component.dart';
import 'game_controller.dart';
import 'spatial/world_view_transform.dart';
import 'themes/parallax_theme_registry.dart';
import 'util/math_util.dart' as math;

// ─────────────────────────────────────────────────────────────────────────────
// Render priorities
// ─────────────────────────────────────────────────────────────────────────────

const _priorityBackgroundParallax = -30;
const _priorityTemporaryFloorMask = -25;
const _priorityGroundTiles = -20;
const _priorityForegroundParallax = -10;
const _priorityStaticSolids = -5;
const _priorityPlayer = -3;
const _priorityEnemies = -2;
const _priorityProjectiles = -1;
const _priorityCollectibles = -1;
const _priorityHitboxes = 1;
const _priorityActorHitboxes = 2;
const _priorityProjectileAimRay = 5;
const _priorityMeleeAimRay = 6;
const PlayerRenderTuning _playerRenderTuning = PlayerRenderTuning();
const _damageForMaxShake100 = 1500;
const _visualCueIntensityScaleBp = 10000;

enum RunLoadPhase {
  start,
  themeResolved,
  parallaxMounted,
  playerAnimationsLoaded,
  registriesLoaded,
  worldReady,
}

@immutable
class RunLoadState {
  const RunLoadState({required this.phase, required this.progress});

  final RunLoadPhase phase;
  final double progress;

  static const RunLoadState initial = RunLoadState(
    phase: RunLoadPhase.start,
    progress: 0.0,
  );
}

/// Minimal Flame `Game` that renders from snapshots.
class RunnerFlameGame extends FlameGame {
  RunnerFlameGame({
    required this.controller,
    required this.input,
    required this.projectileAimPreview,
    required this.meleeAimPreview,
    required this.playerCharacter,
    CombatFeedbackTuning combatFeedbackTuning = const CombatFeedbackTuning(),
  }) : _enemyRenderRegistry = EnemyRenderRegistry(
         enemyCatalog: controller.enemyCatalog,
       ),
       _combatFeedbackTuning = combatFeedbackTuning,
       _projectileRenderRegistry = ProjectileRenderRegistry(),
       _pickupRenderRegistry = PickupRenderRegistry(),
       super(
         camera: CameraComponent.withFixedResolution(
           width: virtualWidth.toDouble(),
           height: virtualHeight.toDouble(),
         ),
       );

  /// Bridge/controller that owns the simulation and produces snapshots.
  final GameController controller;

  /// Input scheduler/aggregator (touch + keyboard + mouse).
  final RunnerInputRouter input;

  /// UI-driven aim preview (render-only).
  final ValueListenable<AimPreviewState> projectileAimPreview;
  final ValueListenable<AimPreviewState> meleeAimPreview;

  /// The selected player character definition for this run (render-only usage).
  final PlayerCharacterDefinition playerCharacter;

  /// UI-facing load progress for the run route.
  final ValueNotifier<RunLoadState> loadState = ValueNotifier<RunLoadState>(
    RunLoadState.initial,
  );

  late final PlayerViewComponent _player;
  late final GroundSurfaceComponent _groundSurface;
  final EnemyRenderRegistry _enemyRenderRegistry;
  final ProjectileRenderRegistry _projectileRenderRegistry;
  final PickupRenderRegistry _pickupRenderRegistry;
  final CombatFeedbackTuning _combatFeedbackTuning;
  final List<RectangleComponent> _staticSolids = <RectangleComponent>[];
  List<StaticSolidSnapshot>? _lastStaticSolidsSnapshot;

  /// Entity view pools, keyed by entity ID.
  final Map<int, DeterministicAnimViewComponent> _projectileAnimViews =
      <int, DeterministicAnimViewComponent>{};
  final Map<int, DeterministicAnimViewComponent> _pickupAnimViews =
      <int, DeterministicAnimViewComponent>{};
  final Map<int, DeterministicAnimViewComponent> _enemies =
      <int, DeterministicAnimViewComponent>{};
  final Map<int, RectangleComponent> _hitboxes = <int, RectangleComponent>{};
  final Map<int, RectangleComponent> _actorHitboxes =
      <int, RectangleComponent>{};

  final Paint _hitboxPaint = Paint()..color = const Color(0x66EF4444);
  final Paint _actorHitboxPaint = Paint()
    ..color = const Color(0xFF22C55E)
    ..style = PaintingStyle.stroke
    ..strokeWidth = 1.0;

  final Map<int, EntityRenderSnapshot> _prevEntitiesById =
      <int, EntityRenderSnapshot>{};
  final Map<int, int> _projectileSpawnTicks = <int, int>{};
  final Set<int> _seenIdsScratch = <int>{};
  final List<int> _toRemoveScratch = <int>[];
  final _CameraShakeController _cameraShake = _CameraShakeController();
  final Vector2 _cameraBaseCenterScratch = Vector2.zero();
  final Vector2 _cameraShakeOffsetScratch = Vector2.zero();
  final Vector2 _cameraCenterScratch = Vector2.zero();
  final Vector2 _snapScratch = Vector2.zero();
  final List<ProjectileHitEvent> _pendingProjectileHitEvents =
      <ProjectileHitEvent>[];
  final List<EntityVisualCueEvent> _pendingEntityVisualCueEvents =
      <EntityVisualCueEvent>[];

  @override
  Future<void> onLoad() async {
    await super.onLoad();
    assert(() {
      playerCharacter.assertValid();
      return true;
    }());
    controller.addEventListener(_handleGameEvent);
    final theme = ParallaxThemeRegistry.forThemeId(controller.snapshot.themeId);
    _setLoadState(RunLoadPhase.themeResolved, 0.15);

    // Background parallax layers (sky, distant mountains, etc.)
    camera.backdrop.add(
      PixelParallaxBackdropComponent(
        virtualWidth: virtualWidth,
        virtualHeight: virtualHeight,
        snapScrollToPixels: false,
        layers: theme.backgroundLayers,
        layerBottomAnchorYProvider: _parallaxLayerBottomAnchorY,
      )..priority = _priorityBackgroundParallax,
    );

    camera.backdrop.add(
      _TemporaryFloorMaskComponent(
        controller: controller,
        virtualWidth: virtualWidth,
        virtualHeight: virtualHeight,
      )..priority = _priorityTemporaryFloorMask,
    );

    _groundSurface = GroundSurfaceComponent(
      assetPath: theme.groundLayerAsset,
      controller: controller,
      virtualWidth: virtualWidth,
      virtualHeight: virtualHeight,
    )..priority = _priorityGroundTiles;
    camera.backdrop.add(_groundSurface);

    // Foreground parallax layers (grass, bushes, etc.)
    camera.backdrop.add(
      GroundBandParallaxForegroundComponent(
        controller: controller,
        virtualWidth: virtualWidth,
        virtualHeight: virtualHeight,
        layers: theme.foregroundLayers,
        bandFillDepthProvider: () => _groundSurface.materialHeight,
        snapScrollToPixels: false,
      )..priority = _priorityForegroundParallax,
    );
    _setLoadState(RunLoadPhase.parallaxMounted, 0.35);

    final playerAnimations = await loadPlayerAnimations(
      images,
      renderAnim: playerCharacter.renderAnim,
    );
    _setLoadState(RunLoadPhase.playerAnimationsLoaded, 0.55);
    await _enemyRenderRegistry.load(images);
    await _projectileRenderRegistry.load(images);
    await _pickupRenderRegistry.load(images);
    _setLoadState(RunLoadPhase.registriesLoaded, 0.8);
    _player = PlayerViewComponent(
      animationSet: playerAnimations,
      renderScale: Vector2.all(_playerRenderTuning.scale),
      feedbackTuning: _combatFeedbackTuning,
    )..priority = _priorityPlayer;
    world.add(_player);

    world.add(
      AimRayComponent(
        controller: controller,
        preview: projectileAimPreview,
        length: projectileAimRayLength,
        playerRenderPos: () => _player.position,
        drawWhenNoAim: false,
      )..priority = _priorityProjectileAimRay,
    );

    world.add(
      AimRayComponent(
        controller: controller,
        preview: meleeAimPreview,
        length: meleeAimRayLength,
        playerRenderPos: () => _player.position,
        drawWhenNoAim: false,
        paint: Paint()
          ..color = const Color(0xFFDC4440)
          ..strokeWidth = 2
          ..strokeCap = StrokeCap.round,
      )..priority = _priorityMeleeAimRay,
    );

    _mountStaticSolids(controller.snapshot.staticSolids);
    _lastStaticSolidsSnapshot = controller.snapshot.staticSolids;
    _setLoadState(RunLoadPhase.worldReady, 1.0);
  }

  @override
  void update(double dt) {
    final snapshot = controller.snapshot;
    if (!snapshot.paused && !snapshot.gameOver) {
      input.pumpHeldInputs();
    }

    // Step the deterministic core using the frame delta, then render the newest
    // snapshot. This order is critical: Flame components (parallax, etc.) read
    // the camera during their own update(), so Core + camera + view sync must
    // run BEFORE super.update(dt).
    controller.advanceFrame(dt);

    final prevSnapshot = controller.prevSnapshot;
    final currSnapshot = controller.snapshot;
    final alpha = controller.alpha;

    _prevEntitiesById.clear();
    for (final e in prevSnapshot.entities) {
      _prevEntitiesById[e.id] = e;
    }

    final camX = math.lerpDouble(
      prevSnapshot.camera.centerX,
      currSnapshot.camera.centerX,
      alpha,
    );
    final camY = math.lerpDouble(
      prevSnapshot.camera.centerY,
      currSnapshot.camera.centerY,
      alpha,
    );
    _cameraBaseCenterScratch.setValues(camX, camY);
    _cameraShake.sample(dt, _cameraShakeOffsetScratch);
    _cameraCenterScratch.setValues(
      _cameraBaseCenterScratch.x + _cameraShakeOffsetScratch.x,
      _cameraBaseCenterScratch.y + _cameraShakeOffsetScratch.y,
    );
    camera.viewfinder.position = _cameraCenterScratch;

    _syncStaticSolids(currSnapshot.staticSolids);
    _snapStaticSolids(
      currSnapshot.staticSolids,
      cameraCenter: _cameraCenterScratch,
    );

    final player = currSnapshot.playerEntity;
    if (player != null) {
      final prev = _prevEntitiesById[player.id] ?? player;
      final worldX = math.lerpDouble(prev.pos.x, player.pos.x, alpha);
      final worldY = math.lerpDouble(prev.pos.y, player.pos.y, alpha);
      _snapScratch.setValues(
        math.snapWorldToPixelsInCameraSpace1d(worldX, _cameraCenterScratch.x),
        math.snapWorldToPixelsInCameraSpace1d(worldY, _cameraCenterScratch.y),
      );
      _player.applySnapshot(
        player,
        tickHz: controller.tickHz,
        pos: _snapScratch,
      );
      _player.setStatusVisualMask(player.statusVisualMask);
    }

    _syncEnemies(
      currSnapshot.entities,
      prevById: _prevEntitiesById,
      alpha: alpha,
      cameraCenter: _cameraCenterScratch,
    );
    _flushPendingEntityVisualCueEvents(playerEntityId: player?.id);
    _syncProjectiles(
      currSnapshot.entities,
      prevById: _prevEntitiesById,
      alpha: alpha,
      cameraCenter: _cameraCenterScratch,
      tick: currSnapshot.tick,
    );
    _syncCollectibles(
      currSnapshot.entities,
      prevById: _prevEntitiesById,
      alpha: alpha,
      cameraCenter: _cameraCenterScratch,
    );
    final drawHitboxes =
        RenderDebugFlags.canUseRenderDebug &&
        RenderDebugFlags.drawActorHitboxes;
    if (drawHitboxes) {
      _syncHitboxes(
        currSnapshot.entities,
        prevById: _prevEntitiesById,
        alpha: alpha,
        cameraCenter: _cameraCenterScratch,
      );
    } else if (_hitboxes.isNotEmpty) {
      for (final view in _hitboxes.values) {
        view.removeFromParent();
      }
      _hitboxes.clear();
    }
    syncDebugAabbOverlays(
      entities: currSnapshot.entities,
      enabled:
          RenderDebugFlags.canUseRenderDebug &&
          RenderDebugFlags.drawActorHitboxes,
      parent: world,
      pool: _actorHitboxes,
      priority: _priorityActorHitboxes,
      paint: _actorHitboxPaint,
      include: (e) => e.kind == EntityKind.player || e.kind == EntityKind.enemy,
      prevById: _prevEntitiesById,
      offsetXFor: (e) {
        switch (e.kind) {
          case EntityKind.player:
            return playerCharacter.catalog.colliderOffsetX;
          case EntityKind.enemy:
            final enemyId = e.enemyId;
            if (enemyId == null) return 0.0;
            return controller.enemyCatalog.get(enemyId).collider.offsetX;
          default:
            return 0.0;
        }
      },
      offsetYFor: (e) {
        switch (e.kind) {
          case EntityKind.player:
            return playerCharacter.catalog.colliderOffsetY;
          case EntityKind.enemy:
            final enemyId = e.enemyId;
            if (enemyId == null) return 0.0;
            return controller.enemyCatalog.get(enemyId).collider.offsetY;
          default:
            return 0.0;
        }
      },
      alpha: alpha,
      cameraCenter: _cameraCenterScratch,
    );

    _flushPendingProjectileHitEvents(cameraCenter: _cameraCenterScratch);

    super.update(dt);
  }

  /// Mounts static solid rectangles into the world.
  ///
  /// Called once on load and whenever the static solids list changes.
  /// One-way platforms are rendered with a green tint, solid platforms with
  /// purple.
  void _mountStaticSolids(List<StaticSolidSnapshot> solids) {
    if (solids.isEmpty) return;

    for (final solid in solids) {
      final color = solid.oneWayTop
          ? const Color(0x6648BB78) // green-ish translucent
          : const Color(0x668B5CF6); // purple translucent

      final rect = RectangleComponent(
        position: Vector2(solid.minX, solid.minY),
        size: Vector2(solid.maxX - solid.minX, solid.maxY - solid.minY),
        paint: Paint()..color = color,
      );
      rect.priority = _priorityStaticSolids;
      _staticSolids.add(rect);
      world.add(rect);
    }
  }

  /// Synchronizes enemy view components with the snapshot.
  ///
  /// Creates view components for new enemies, updates existing ones, and
  /// removes components for despawned enemies.
  void _syncEnemies(
    List<EntityRenderSnapshot> entities, {
    required Map<int, EntityRenderSnapshot> prevById,
    required double alpha,
    required Vector2 cameraCenter,
  }) {
    final seen = _seenIdsScratch..clear();

    for (final e in entities) {
      if (e.kind != EntityKind.enemy) continue;

      final entry = e.enemyId == null
          ? null
          : _enemyRenderRegistry.entryFor(e.enemyId!);
      if (entry == null) {
        _enemies.remove(e.id)?.removeFromParent();
        continue;
      }

      seen.add(e.id);

      var view = _enemies[e.id];
      if (view == null) {
        view = entry.viewFactory(entry.animSet, entry.renderScale)
          ..priority = _priorityEnemies;
        view.setFeedbackTuning(_combatFeedbackTuning);
        _enemies[e.id] = view;
        world.add(view);
      }

      final prev = prevById[e.id] ?? e;
      final worldX = math.lerpDouble(prev.pos.x, e.pos.x, alpha);
      final worldY = math.lerpDouble(prev.pos.y, e.pos.y, alpha);
      final snappedX = math.snapWorldToPixelsInCameraSpace1d(
        worldX,
        cameraCenter.x,
      );
      final snappedY = math.snapWorldToPixelsInCameraSpace1d(
        worldY,
        cameraCenter.y,
      );

      _snapScratch.setValues(snappedX, snappedY);
      view.applySnapshot(e, tickHz: controller.tickHz, pos: _snapScratch);
      view.setStatusVisualMask(e.statusVisualMask);
    }

    if (_enemies.isEmpty) return;
    final toRemove = _toRemoveScratch..clear();
    for (final id in _enemies.keys) {
      if (!seen.contains(id)) toRemove.add(id);
    }
    for (final id in toRemove) {
      _enemies.remove(id)?.removeFromParent();
    }
  }

  void _handleGameEvent(GameEvent event) {
    if (event is PlayerImpactFeedbackEvent) {
      _cameraShake.trigger(
        intensity01: _shakeIntensityFromDamage100(event.amount100),
      );
      return;
    }
    if (event is EntityVisualCueEvent) {
      _pendingEntityVisualCueEvents.add(event);
      return;
    }
    if (event is ProjectileHitEvent) {
      _pendingProjectileHitEvents.add(event);
    }
  }

  double _shakeIntensityFromDamage100(int amount100) {
    if (amount100 <= 0) return 0.0;
    final normalized = (amount100 / _damageForMaxShake100).clamp(0.0, 1.0);
    return dart_math.sqrt(normalized);
  }

  void _flushPendingEntityVisualCueEvents({required int? playerEntityId}) {
    if (_pendingEntityVisualCueEvents.isEmpty) return;

    for (final event in _pendingEntityVisualCueEvents) {
      final intensity01 = _visualCueIntensity01(event.intensityBp);
      if (intensity01 <= 0.0) continue;

      final DeterministicAnimViewComponent? view;
      if (playerEntityId != null && event.entityId == playerEntityId) {
        view = _player;
      } else {
        view = _enemies[event.entityId];
      }
      if (view == null) continue;

      switch (event.kind) {
        case EntityVisualCueKind.directHit:
          view.triggerDirectHitFlash(intensity01: intensity01);
        case EntityVisualCueKind.dotPulse:
          view.triggerDotPulse(
            color: _combatFeedbackTuning.dotColorFor(event.damageType),
            intensity01: intensity01,
          );
        case EntityVisualCueKind.resourcePulse:
          view.triggerResourcePulse(
            color: _combatFeedbackTuning.resourceColorFor(event.resourceType),
            intensity01: intensity01,
          );
      }
    }

    _pendingEntityVisualCueEvents.clear();
  }

  double _visualCueIntensity01(int intensityBp) {
    if (intensityBp <= 0) return 0.0;
    return (intensityBp / _visualCueIntensityScaleBp).clamp(0.0, 1.0);
  }

  void _flushPendingProjectileHitEvents({required Vector2 cameraCenter}) {
    if (_pendingProjectileHitEvents.isEmpty) return;

    for (final event in _pendingProjectileHitEvents) {
      final entry = _projectileRenderRegistry.entryFor(event.projectileId);
      if (entry == null) continue;

      final hitAnim = entry.animSet.animations[AnimKey.hit];
      if (hitAnim == null) continue;

      final component = _CameraSpaceSnappedSpriteAnimationComponent(
        animation: hitAnim,
        size: entry.animSet.frameSize.clone(),
        worldPosX: event.pos.x,
        worldPosY: event.pos.y,
        anchor: entry.animSet.anchor,
        paint: Paint()..filterQuality = FilterQuality.none,
        removeOnFinish: true,
      )..priority = _priorityProjectiles;

      component.scale.setValues(entry.renderScale.x, entry.renderScale.y);
      component.angle = event.rotationRad;
      component.snapToCamera(cameraCenter);
      world.add(component);
    }

    _pendingProjectileHitEvents.clear();
  }

  /// Synchronizes projectile view components with the snapshot.
  ///
  /// Creates rectangle components for new projectiles, updates position/size
  /// for existing ones, and removes components for despawned projectiles.
  void _syncProjectiles(
    List<EntityRenderSnapshot> entities, {
    required Map<int, EntityRenderSnapshot> prevById,
    required double alpha,
    required Vector2 cameraCenter,
    required int tick,
  }) {
    final seen = _seenIdsScratch..clear();

    for (final e in entities) {
      if (e.kind != EntityKind.projectile) continue;
      seen.add(e.id);

      final projectileId = e.projectileId;
      final entry = projectileId == null
          ? null
          : _projectileRenderRegistry.entryFor(projectileId);

      if (entry != null) {
        var view = _projectileAnimViews[e.id];
        if (view == null) {
          view = entry.viewFactory(entry.animSet, entry.renderScale);
          view.priority = _priorityProjectiles;
          _projectileAnimViews[e.id] = view;
          _projectileSpawnTicks[e.id] = tick;
          world.add(view);
        }

        final prev = prevById[e.id] ?? e;
        final worldX = math.lerpDouble(prev.pos.x, e.pos.x, alpha);
        final worldY = math.lerpDouble(prev.pos.y, e.pos.y, alpha);
        _snapScratch.setValues(
          math.snapWorldToPixelsInCameraSpace1d(worldX, cameraCenter.x),
          math.snapWorldToPixelsInCameraSpace1d(worldY, cameraCenter.y),
        );

        final spawnTick = _projectileSpawnTicks[e.id] ?? tick;
        final startTicks = entry.spawnAnimTicks(controller.tickHz);
        final ageTicks = tick - spawnTick;
        final animOverride =
            startTicks > 0 && ageTicks >= 0 && ageTicks < startTicks
            ? AnimKey.spawn
            : AnimKey.idle;
        final overrideAnimFrame = animOverride == AnimKey.spawn
            ? ageTicks
            : null;

        view.applySnapshot(
          e,
          tickHz: controller.tickHz,
          pos: _snapScratch,
          overrideAnim: animOverride,
          overrideAnimFrame: overrideAnimFrame,
        );
        final spinSpeed = entry.spinSpeedRadPerSecond;
        if (spinSpeed == 0.0) {
          view.angle = e.rotationRad;
        } else {
          final spinSeconds = (ageTicks.toDouble() + alpha) / controller.tickHz;
          view.angle = e.rotationRad + spinSpeed * spinSeconds;
        }
      } else {
        // No fallback rendering for unknown/unregistered projectiles.
        //
        // If the projectile exists in Core but has no render wiring (or assets),
        // we simply avoid rendering it rather than using placeholder rectangles.
        _projectileAnimViews.remove(e.id)?.removeFromParent();
        _projectileSpawnTicks.remove(e.id);
      }
    }

    if (_projectileAnimViews.isNotEmpty) {
      final toRemove = _toRemoveScratch..clear();
      for (final id in _projectileAnimViews.keys) {
        if (!seen.contains(id)) toRemove.add(id);
      }
      for (final id in toRemove) {
        _projectileAnimViews.remove(id)?.removeFromParent();
        _projectileSpawnTicks.remove(id);
      }
    }
  }

  /// Synchronizes collectible/pickup view components with the snapshot.
  ///
  /// Creates deterministic animation components for pickups and removes
  /// components for collected pickups.
  void _syncCollectibles(
    List<EntityRenderSnapshot> entities, {
    required Map<int, EntityRenderSnapshot> prevById,
    required double alpha,
    required Vector2 cameraCenter,
  }) {
    final seen = _seenIdsScratch..clear();

    for (final e in entities) {
      if (e.kind != EntityKind.pickup) continue;
      seen.add(e.id);

      final variant = e.pickupVariant ?? PickupVariant.collectible;
      final entry = _pickupRenderRegistry.entryForVariant(variant);

      var view = _pickupAnimViews[e.id];
      if (view == null) {
        view = entry.viewFactory(entry.animSet, entry.renderScale);
        view.priority = _priorityCollectibles;
        _pickupAnimViews[e.id] = view;
        world.add(view);
      }

      final prev = prevById[e.id] ?? e;
      final worldX = math.lerpDouble(prev.pos.x, e.pos.x, alpha);
      final worldY = math.lerpDouble(prev.pos.y, e.pos.y, alpha);
      _snapScratch.setValues(
        math.snapWorldToPixelsInCameraSpace1d(worldX, cameraCenter.x),
        math.snapWorldToPixelsInCameraSpace1d(worldY, cameraCenter.y),
      );
      view.applySnapshot(e, tickHz: controller.tickHz, pos: _snapScratch);
      view.angle = e.rotationRad;
    }

    if (_pickupAnimViews.isEmpty) return;
    final toRemove = _toRemoveScratch..clear();
    for (final id in _pickupAnimViews.keys) {
      if (!seen.contains(id)) toRemove.add(id);
    }
    for (final id in toRemove) {
      _pickupAnimViews.remove(id)?.removeFromParent();
    }
  }

  /// Synchronizes trigger/hitbox view components with the snapshot.
  ///
  /// Creates translucent red rectangle components for new triggers, updates
  /// position/size for existing ones, and removes components for despawned
  /// triggers.
  void _syncHitboxes(
    List<EntityRenderSnapshot> entities, {
    required Map<int, EntityRenderSnapshot> prevById,
    required double alpha,
    required Vector2 cameraCenter,
  }) {
    final seen = _seenIdsScratch..clear();

    for (final e in entities) {
      if (e.kind != EntityKind.trigger) continue;
      seen.add(e.id);

      var view = _hitboxes[e.id];
      if (view == null) {
        final size = e.size;
        view = RectangleComponent(
          size: Vector2(size?.x ?? 8.0, size?.y ?? 8.0),
          anchor: Anchor.center,
          paint: _hitboxPaint,
        );
        view.priority = _priorityHitboxes;
        _hitboxes[e.id] = view;
        world.add(view);
      } else {
        final size = e.size;
        if (size != null) {
          view.size.setValues(size.x, size.y);
        }
      }

      final prev = prevById[e.id] ?? e;
      final worldX = math.lerpDouble(prev.pos.x, e.pos.x, alpha);
      final worldY = math.lerpDouble(prev.pos.y, e.pos.y, alpha);
      view.position.setValues(
        math.snapWorldToPixelsInCameraSpace1d(worldX, cameraCenter.x),
        math.snapWorldToPixelsInCameraSpace1d(worldY, cameraCenter.y),
      );
    }

    if (_hitboxes.isEmpty) return;
    final toRemove = _toRemoveScratch..clear();
    for (final id in _hitboxes.keys) {
      if (!seen.contains(id)) toRemove.add(id);
    }
    for (final id in toRemove) {
      _hitboxes.remove(id)?.removeFromParent();
    }
  }

  /// Synchronizes static solid views with the snapshot.
  ///
  /// Uses identity comparison as a cheap version check since Core rebuilds
  /// the list only when geometry actually changes (spawn/cull).
  void _syncStaticSolids(List<StaticSolidSnapshot> solids) {
    // Core rebuilds the list only when geometry changes (spawn/cull),
    // so identity check is a cheap "version" check.
    if (identical(solids, _lastStaticSolidsSnapshot)) return;
    _lastStaticSolidsSnapshot = solids;

    for (final c in _staticSolids) {
      c.removeFromParent();
    }
    _staticSolids.clear();

    _mountStaticSolids(solids);
  }

  void _snapStaticSolids(
    List<StaticSolidSnapshot> solids, {
    required Vector2 cameraCenter,
  }) {
    if (solids.isEmpty) return;
    if (_staticSolids.length != solids.length) return;
    final transform = WorldViewTransform(
      cameraCenterX: cameraCenter.x,
      cameraCenterY: cameraCenter.y,
      viewWidth: virtualWidth.toDouble(),
      viewHeight: virtualHeight.toDouble(),
    );

    for (var i = 0; i < solids.length; i++) {
      final solid = solids[i];
      final view = _staticSolids[i];
      view.position.setValues(
        math.snapWorldToPixelsInViewX(solid.minX, transform),
        math.snapWorldToPixelsInViewY(solid.minY, transform),
      );
    }
  }

  @override
  void onRemove() {
    controller.removeEventListener(_handleGameEvent);
    images.clearCache();
    super.onRemove();
  }

  @override
  void onDispose() {
    loadState.dispose();
    super.onDispose();
  }

  void _setLoadState(RunLoadPhase phase, double progress) {
    final clamped = progress.clamp(0.0, 1.0);
    loadState.value = RunLoadState(phase: phase, progress: clamped);
  }

  /// Bottom anchor for parallax layers, aligned to the visible ground top.
  double _parallaxLayerBottomAnchorY() {
    final surfaces = controller.snapshot.groundSurfaces;
    if (surfaces.isEmpty) {
      return virtualHeight.toDouble();
    }

    var floorTopY = surfaces.first.topY;
    for (final surface in surfaces) {
      if (surface.topY > floorTopY) {
        floorTopY = surface.topY;
      }
    }

    final cameraCenter = camera.viewfinder.position;
    final transform = WorldViewTransform(
      cameraCenterX: cameraCenter.x,
      cameraCenterY: cameraCenter.y,
      viewWidth: virtualWidth.toDouble(),
      viewHeight: virtualHeight.toDouble(),
    );
    return math.roundToPixels(transform.worldToViewY(floorTopY));
  }
}

/// Lightweight procedural camera shake.
///
/// The shake is additive to the authoritative camera center from Core.
class _CameraShakeController {
  double _elapsedSeconds = 0.0;
  double _durationSeconds = 0.0;
  double _amplitudePixels = 0.0;
  double _seedPhase = 0.0;

  void trigger({required double intensity01}) {
    final clamped = intensity01.clamp(0.0, 1.0);
    if (clamped <= 0.0) return;

    _durationSeconds = _lerp(0.12, 0.24, clamped);
    _amplitudePixels = _lerp(1.5, 5.5, clamped);
    _elapsedSeconds = 0.0;
    _seedPhase += dart_math.pi * 0.31;
  }

  void sample(double dtSeconds, Vector2 out) {
    if (_durationSeconds <= 0.0 || _elapsedSeconds >= _durationSeconds) {
      out.setZero();
      return;
    }

    _elapsedSeconds += dtSeconds;
    if (_elapsedSeconds >= _durationSeconds) {
      out.setZero();
      return;
    }

    final t = _elapsedSeconds / _durationSeconds;
    final damper = (1.0 - t) * (1.0 - t);
    final angle = _seedPhase + (_elapsedSeconds * _oscillationRadPerSecond);
    out.setValues(
      dart_math.sin(angle) * _amplitudePixels * damper,
      dart_math.cos(angle * 1.73) * (_amplitudePixels * 0.65) * damper,
    );
  }

  static const double _oscillationRadPerSecond = 44.0 * 2.0 * dart_math.pi;

  double _lerp(double min, double max, double t) => min + (max - min) * t;
}

/// Temporary black backdrop mask from floor level downward.
///
/// Keep this local and disposable: delete this class and the one mount call in
/// `onLoad` when no longer needed.
class _TemporaryFloorMaskComponent extends Component
    with HasGameReference<FlameGame> {
  _TemporaryFloorMaskComponent({
    required this.controller,
    required this.virtualWidth,
    required this.virtualHeight,
  });

  final GameController controller;
  final int virtualWidth;
  final int virtualHeight;

  final Paint _paint = Paint()..color = const Color(0xFF000000);

  @override
  void render(Canvas canvas) {
    super.render(canvas);

    final surfaces = controller.snapshot.groundSurfaces;
    if (surfaces.isEmpty) return;

    // Use the lowest visible ground top so the mask starts at floor level.
    var floorTopY = surfaces.first.topY;
    for (final surface in surfaces) {
      if (surface.topY > floorTopY) {
        floorTopY = surface.topY;
      }
    }

    final camX = -game.camera.viewfinder.transform.offset.x;
    final camY = -game.camera.viewfinder.transform.offset.y;
    final transform = WorldViewTransform(
      cameraCenterX: camX,
      cameraCenterY: camY,
      viewWidth: virtualWidth.toDouble(),
      viewHeight: virtualHeight.toDouble(),
    );

    final maskTopY = math.roundToPixels(transform.worldToViewY(floorTopY));
    final clampedTopY = maskTopY.clamp(0.0, virtualHeight.toDouble());
    if (clampedTopY >= virtualHeight.toDouble()) return;

    canvas.drawRect(
      Rect.fromLTWH(
        0.0,
        clampedTopY,
        virtualWidth.toDouble(),
        virtualHeight.toDouble() - clampedTopY,
      ),
      _paint,
    );
  }
}

class _CameraSpaceSnappedSpriteAnimationComponent
    extends SpriteAnimationComponent
    with HasGameReference<FlameGame> {
  _CameraSpaceSnappedSpriteAnimationComponent({
    required SpriteAnimation super.animation,
    required Vector2 super.size,
    required this.worldPosX,
    required this.worldPosY,
    super.anchor = Anchor.center,
    super.paint,
    super.removeOnFinish,
  });

  final double worldPosX;
  final double worldPosY;

  void snapToCamera(Vector2 cameraCenter) {
    position.setValues(
      math.snapWorldToPixelsInCameraSpace1d(worldPosX, cameraCenter.x),
      math.snapWorldToPixelsInCameraSpace1d(worldPosY, cameraCenter.y),
    );
  }

  @override
  void update(double dt) {
    snapToCamera(game.camera.viewfinder.position);
    super.update(dt);
  }
}


===== FILE: lib/game/spatial/world_view_transform.dart =====
/// Stateless world<->view transform helpers.
///
/// Current runner rendering assumes an axis-aligned camera without rotation.
/// These helpers make that mapping explicit and reusable.
library;

class WorldViewTransform {
  const WorldViewTransform({
    required this.cameraCenterX,
    required this.cameraCenterY,
    required this.viewWidth,
    required this.viewHeight,
  }) : assert(viewWidth > 0),
       assert(viewHeight > 0);

  /// Camera center in world coordinates.
  final double cameraCenterX;
  final double cameraCenterY;

  /// Viewport size in world/view units.
  final double viewWidth;
  final double viewHeight;

  /// Left edge of the viewport in world coordinates.
  double get viewLeftX => cameraCenterX - viewWidth * 0.5;

  /// Right edge of the viewport in world coordinates.
  double get viewRightX => cameraCenterX + viewWidth * 0.5;

  /// Top edge of the viewport in world coordinates.
  double get viewTopY => cameraCenterY - viewHeight * 0.5;

  /// Bottom edge of the viewport in world coordinates.
  double get viewBottomY => cameraCenterY + viewHeight * 0.5;

  /// Converts a world X coordinate to view-space X.
  double worldToViewX(double worldX) => worldX - viewLeftX;

  /// Converts a world Y coordinate to view-space Y.
  double worldToViewY(double worldY) => worldY - viewTopY;

  /// Converts a view-space X coordinate to world X.
  double viewToWorldX(double viewX) => viewLeftX + viewX;

  /// Converts a view-space Y coordinate to world Y.
  double viewToWorldY(double viewY) => viewTopY + viewY;
}


===== FILE: lib/game/themes/parallax_theme.dart =====
/// Render-layer parallax theme configuration.
library;

import '../components/pixel_parallax_backdrop_component.dart';

class ParallaxTheme {
  const ParallaxTheme({
    required this.backgroundLayers,
    required this.groundLayerAsset,
    required this.foregroundLayers,
  });

  final List<PixelParallaxLayerSpec> backgroundLayers;
  final String groundLayerAsset;
  final List<PixelParallaxLayerSpec> foregroundLayers;
}



===== FILE: lib/game/themes/parallax_theme_registry.dart =====
/// Render-layer mapping of Core theme IDs to concrete parallax assets.
library;

import 'parallax_theme.dart';
import '../components/pixel_parallax_backdrop_component.dart';

/// Returns the [ParallaxTheme] for a given Core `themeId`.
///
/// Unknown or null theme IDs fall back to the default theme.
class ParallaxThemeRegistry {
  const ParallaxThemeRegistry._();

  static ParallaxTheme forThemeId(String? themeId) {
    switch (themeId) {
      case 'field':
        return _field;
      case 'forest':
        return _forest;
      default:
        return _field;
    }
  }
}

const ParallaxTheme _field = ParallaxTheme(
  backgroundLayers: <PixelParallaxLayerSpec>[
    PixelParallaxLayerSpec(
      assetPath: 'parallax/field/Field Layer 01.png',
      parallaxFactor: 0.10,
    ),
    PixelParallaxLayerSpec(
      assetPath: 'parallax/field/Field Layer 02.png',
      parallaxFactor: 0.15,
    ),
    PixelParallaxLayerSpec(
      assetPath: 'parallax/field/Field Layer 03.png',
      parallaxFactor: 0.20,
    ),
    PixelParallaxLayerSpec(
      assetPath: 'parallax/field/Field Layer 04.png',
      parallaxFactor: 0.30,
    ),
    PixelParallaxLayerSpec(
      assetPath: 'parallax/field/Field Layer 05.png',
      parallaxFactor: 0.40,
    ),
    PixelParallaxLayerSpec(
      assetPath: 'parallax/field/Field Layer 06.png',
      parallaxFactor: 0.50,
    ),
    PixelParallaxLayerSpec(
      assetPath: 'parallax/field/Field Layer 07.png',
      parallaxFactor: 0.60,
    ),
    PixelParallaxLayerSpec(
      assetPath: 'parallax/field/Field Layer 08.png',
      parallaxFactor: 0.70,
    ),
  ],
  groundLayerAsset: 'parallax/field/Field Layer 09.png',
  foregroundLayers: <PixelParallaxLayerSpec>[
    PixelParallaxLayerSpec(
      assetPath: 'parallax/field/Field Layer 10.png',
      parallaxFactor: 1.0,
    ),
  ],
);

const ParallaxTheme _forest = ParallaxTheme(
  backgroundLayers: <PixelParallaxLayerSpec>[
    PixelParallaxLayerSpec(
      assetPath: 'parallax/forest/Forest Layer 01.png',
      parallaxFactor: 0.10,
    ),
    PixelParallaxLayerSpec(
      assetPath: 'parallax/forest/Forest Layer 02.png',
      parallaxFactor: 0.20,
    ),
    PixelParallaxLayerSpec(
      assetPath: 'parallax/forest/Forest Layer 03.png',
      parallaxFactor: 0.30,
    ),
  ],
  groundLayerAsset: 'parallax/forest/Forest Layer 04.png',
  foregroundLayers: <PixelParallaxLayerSpec>[
    PixelParallaxLayerSpec(
      assetPath: 'parallax/forest/Forest Layer 05.png',
      parallaxFactor: 1.0,
    ),
  ],
);

===== FILE: lib/game/tick_input_frame.dart =====
// Aggregated input state for a single simulation tick.
//
// The game schedules input commands ahead of time (via RunnerInputRouter).
// Multiple commands may target the same tick, so this class merges them into
// a single coherent state that the simulation consumes.
import '../core/commands/command.dart';

/// Aggregated per-tick input for the simulation.
///
/// This replaces `List<Command>` buffering for a given tick to avoid duplicate
/// commands (e.g., multiple [MoveAxisCommand]s for the same tick). Instead of
/// storing a list, we collapse commands into their final values.
///
/// **Usage pattern:**
/// 1. [GameController] creates one [TickInputFrame] per buffered tick.
/// 2. As commands arrive, [apply] merges them into the frame.
/// 3. When the tick executes, the simulation reads the aggregated state.
/// 4. After use, [reset] clears the frame for potential reuse.
class TickInputFrame {
  // ─────────────────────────────────────────────────────────────────────────
  // Movement
  // ─────────────────────────────────────────────────────────────────────────

  /// Horizontal movement axis in [-1, 1]. Last [MoveAxisCommand] wins.
  double moveAxis = 0;

  // ─────────────────────────────────────────────────────────────────────────
  // Edge-triggered actions (one-shot per tick)
  // ─────────────────────────────────────────────────────────────────────────

  /// True if jump was pressed this tick.
  bool jumpPressed = false;

  /// True if dash was pressed this tick.
  bool dashPressed = false;

  /// True if melee strike was pressed this tick.
  bool strikePressed = false;

  /// True if projectile slot was pressed this tick.
  bool projectilePressed = false;

  /// True if secondary slot was pressed this tick.
  bool secondaryPressed = false;

  /// True if spell slot was pressed this tick.
  bool spellPressed = false;

  /// Bitmask of slot hold changes authored for this tick.
  ///
  /// Bit `1 << slot.index` indicates that [AbilitySlotHeldCommand] was
  /// provided for that slot in this frame.
  int abilitySlotHeldChangedMask = 0;

  /// Bitmask of slot held values for changed slots.
  ///
  /// For any bit set in [abilitySlotHeldChangedMask], this mask stores whether
  /// the slot should be held (`1`) or released (`0`).
  int abilitySlotHeldValueMask = 0;

  // ─────────────────────────────────────────────────────────────────────────
  // Global aim direction
  // ─────────────────────────────────────────────────────────────────────────

  /// Whether an aim direction is set for this tick.
  bool aimDirSet = false;

  /// Aim X component (only valid if [aimDirSet] is true).
  double aimDirX = 0;

  /// Aim Y component (only valid if [aimDirSet] is true).
  double aimDirY = 0;

  // ─────────────────────────────────────────────────────────────────────────
  /// Applies a [Command] to this frame, merging it with existing state.
  ///
  /// For continuous inputs (move axis, aim), later commands overwrite earlier ones.
  /// Slot hold edges are merged as bitmasks where later commands for the same
  /// slot overwrite earlier ones.
  /// For edge-triggered inputs (jump, dash, strike, projectile), any press sets the flag.
  void apply(Command command) {
    switch (command) {
      case MoveAxisCommand(:final axis):
        moveAxis = axis.clamp(-1.0, 1.0);
      case JumpPressedCommand():
        jumpPressed = true;
      case DashPressedCommand():
        dashPressed = true;
      case StrikePressedCommand():
        strikePressed = true;
      case AimDirCommand(:final x, :final y):
        aimDirSet = true;
        aimDirX = x;
        aimDirY = y;
      case ClearAimDirCommand():
        aimDirSet = false;
        aimDirX = 0;
        aimDirY = 0;
      case ProjectilePressedCommand():
        projectilePressed = true;
      case SecondaryPressedCommand():
        secondaryPressed = true;
      case SpellPressedCommand():
        spellPressed = true;
      case AbilitySlotHeldCommand(:final slot, :final held):
        final bit = 1 << slot.index;
        abilitySlotHeldChangedMask |= bit;
        if (held) {
          abilitySlotHeldValueMask |= bit;
        } else {
          abilitySlotHeldValueMask &= ~bit;
        }
    }
  }

  /// Resets all fields to their default (idle) state.
  ///
  /// Call this to reuse the frame for a new tick without allocating a new object.
  void reset() {
    moveAxis = 0;
    jumpPressed = false;
    dashPressed = false;
    strikePressed = false;
    aimDirSet = false;
    aimDirX = 0;
    aimDirY = 0;
    projectilePressed = false;
    secondaryPressed = false;
    spellPressed = false;
    abilitySlotHeldChangedMask = 0;
    abilitySlotHeldValueMask = 0;
  }
}


===== FILE: lib/game/tuning/combat_feedback_tuning.dart =====
/// Render-layer tuning for combat hit/status feedback colors and pulse timing.
library;

import 'package:flutter/widgets.dart';

import '../../core/combat/damage_type.dart';
import '../../core/combat/status/status.dart';
import '../../core/snapshots/entity_render_snapshot.dart';

@immutable
class FeedbackPulseTuning {
  const FeedbackPulseTuning({
    required this.minDurationSeconds,
    required this.maxDurationSeconds,
    required this.minAlpha,
    required this.maxAlpha,
    this.fadeExponent = 2.0,
  });

  final double minDurationSeconds;
  final double maxDurationSeconds;
  final double minAlpha;
  final double maxAlpha;
  final double fadeExponent;

  double durationForIntensity(double intensity01) {
    final t = intensity01.clamp(0.0, 1.0);
    return minDurationSeconds + ((maxDurationSeconds - minDurationSeconds) * t);
  }

  double alphaForIntensity(double intensity01) {
    final t = intensity01.clamp(0.0, 1.0);
    return minAlpha + ((maxAlpha - minAlpha) * t);
  }
}

@immutable
class CombatFeedbackTuning {
  const CombatFeedbackTuning({
    this.directHitColor = const Color(0xFFFFFFFF),
    this.directHitPulse = const FeedbackPulseTuning(
      minDurationSeconds: 0.14,
      maxDurationSeconds: 0.22,
      minAlpha: 0.35,
      maxAlpha: 0.65,
      fadeExponent: 2.0,
    ),
    this.dotPulse = const FeedbackPulseTuning(
      minDurationSeconds: 0.14,
      maxDurationSeconds: 0.22,
      minAlpha: 0.35,
      maxAlpha: 0.65,
      fadeExponent: 2.0,
    ),
    this.resourcePulse = const FeedbackPulseTuning(
      minDurationSeconds: 0.14,
      maxDurationSeconds: 0.22,
      minAlpha: 0.35,
      maxAlpha: 0.65,
      fadeExponent: 2.0,
    ),
    this.dotFallbackColor = const Color(0xFFE5E7EB),
    this.resourceFallbackColor = const Color(0xFFE5E7EB),
    this.dotColorByDamageType = _defaultDotColorByDamageType,
    this.resourceColorByType = _defaultResourceColorByType,
    this.statusColorByMaskBit = _defaultStatusColorByMaskBit,
    this.statusBaseAlpha = 0.35,
    this.statusAdditionalAlphaPerEffect = 0.025,
    this.statusMaxAlpha = 0.45,
  });

  final Color directHitColor;
  final FeedbackPulseTuning directHitPulse;
  final FeedbackPulseTuning dotPulse;
  final FeedbackPulseTuning resourcePulse;

  final Color dotFallbackColor;
  final Color resourceFallbackColor;
  final Map<DamageType, Color> dotColorByDamageType;
  final Map<StatusResourceType, Color> resourceColorByType;

  final Map<int, Color> statusColorByMaskBit;
  final double statusBaseAlpha;
  final double statusAdditionalAlphaPerEffect;
  final double statusMaxAlpha;

  Color dotColorFor(DamageType? damageType) {
    if (damageType == null) return dotFallbackColor;
    return dotColorByDamageType[damageType] ?? dotFallbackColor;
  }

  Color resourceColorFor(StatusResourceType? resourceType) {
    if (resourceType == null) return resourceFallbackColor;
    return resourceColorByType[resourceType] ?? resourceFallbackColor;
  }

  static const Map<DamageType, Color> _defaultDotColorByDamageType =
      <DamageType, Color>{
        DamageType.fire: Color(0xFFFF7A3D),
        DamageType.ice: Color(0xFF7DD3FC),
        DamageType.water: Color(0xFF38BDF8),
        DamageType.thunder: Color(0xFFFACC15),
        DamageType.acid: Color(0xFF84CC16),
        DamageType.dark: Color(0xFF8B5CF6),
        DamageType.bleed: Color(0xFFEF4444),
        DamageType.earth: Color(0xFFC08457),
        DamageType.holy: Color(0xFFFDE68A),
        DamageType.physical: Color(0xFFE5E7EB),
      };

  static const Map<StatusResourceType, Color> _defaultResourceColorByType =
      <StatusResourceType, Color>{
        StatusResourceType.health: Color(0xFF22C55E),
        StatusResourceType.mana: Color(0xFF3B82F6),
        StatusResourceType.stamina: Color(0xFFF59E0B),
      };

  static const Map<int, Color> _defaultStatusColorByMaskBit = <int, Color>{
    EntityStatusVisualMask.slow: Color(0xFF67E8F9),
    EntityStatusVisualMask.haste: Color(0xFF86EFAC),
    EntityStatusVisualMask.vulnerable: Color(0xFFF472B6),
    EntityStatusVisualMask.weaken: Color(0xFFF59E0B),
    EntityStatusVisualMask.drench: Color(0xFF60A5FA),
    EntityStatusVisualMask.stun: Color(0xFFEAB308),
    EntityStatusVisualMask.silence: Color(0xFFA78BFA),
  };
}


===== FILE: lib/game/tuning/player_render_tuning.dart =====
/// Render-layer tuning for player sprite presentation.
library;

import 'package:flutter/foundation.dart';

@immutable
class PlayerRenderTuning {
  const PlayerRenderTuning({
    this.scale = 0.75,
  });

  /// Uniform scale applied to the 100x64 sprite frames.
  final double scale;
}


===== FILE: lib/game/util/math_util.dart =====
// Math utilities for the game layer.
//
// Provides helper functions for common math operations that Dart's standard
// library doesn't handle correctly for game use cases (e.g., negative modulo,
// floor division with negative numbers).

import 'package:flame/components.dart';

import '../../core/util/vec2.dart';
import '../spatial/world_view_transform.dart';

/// Returns `value % mod`, always in the range `[0, mod)`.
///
/// Dart's `%` operator can return negative results for negative [value];
/// this function corrects that.
double positiveModDouble(double value, double mod) {
  if (mod <= 0) throw ArgumentError.value(mod, 'mod', 'must be > 0');
  final r = value % mod;
  return r < 0 ? r + mod : r;
}

/// Integer floor division that correctly handles negative dividends.
///
/// Dart's `~/` operator truncates toward zero, which gives incorrect results
/// for negative numbers when you want true floor division (toward -∞).
///
/// Example: `-1 ~/ 16` returns `0`, but `floorDivInt(-1, 16)` returns `-1`.
int floorDivInt(int a, int b) {
  if (b <= 0) throw ArgumentError.value(b, 'b', 'must be > 0');
  if (a >= 0) return a ~/ b;
  return -(((-a) + b - 1) ~/ b);
}

double lerpDouble(double a, double b, double t) => a + (b - a) * t;

Vec2 lerpVec2(Vec2 a, Vec2 b, double t) =>
    Vec2(lerpDouble(a.x, b.x, t), lerpDouble(a.y, b.y, t));

double roundToPixels(double value) => value.roundToDouble();

/// Snaps a world coordinate to integer pixels in camera space.
///
/// Keeps [camera] fractional and rounds only the screen-space delta
/// (`world - camera`) to the nearest pixel.
double snapWorldToPixelsInCameraSpace1d(double world, double camera) =>
    camera + roundToPixels(world - camera);

/// Convenience 2D version of [snapWorldToPixelsInCameraSpace1d].
Vector2 snapWorldToPixelsInCameraSpace(Vec2 world, Vector2 camera) => Vector2(
  snapWorldToPixelsInCameraSpace1d(world.x, camera.x),
  snapWorldToPixelsInCameraSpace1d(world.y, camera.y),
);

/// Snaps a world X coordinate using an explicit [WorldViewTransform].
double snapWorldToPixelsInViewX(double worldX, WorldViewTransform transform) =>
    transform.viewToWorldX(roundToPixels(transform.worldToViewX(worldX)));

/// Snaps a world Y coordinate using an explicit [WorldViewTransform].
double snapWorldToPixelsInViewY(double worldY, WorldViewTransform transform) =>
    transform.viewToWorldY(roundToPixels(transform.worldToViewY(worldY)));


===== FILE: lib/main.dart =====
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:firebase_core/firebase_core.dart';

import 'firebase_options.dart';
import 'ui/app/ui_app.dart';

/// Production app entry point for the rpg-runner game.
///
/// The runner can also be embedded in other Flutter apps via
/// `RunnerGameWidget` / `createRunnerGameRoute` (see `lib/runner.dart`).
/// Embedding apps should initialize Firebase (and any other services) themselves.
Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // Lock to landscape orientation
  await SystemChrome.setPreferredOrientations([
    DeviceOrientation.landscapeLeft,
    DeviceOrientation.landscapeRight,
  ]);

  // Hide status bar and navigation bar (immersive fullscreen)
  // Note: Also re-applied in MenuScaffold to handle navigation edge cases
  await SystemChrome.setEnabledSystemUIMode(SystemUiMode.immersiveSticky);

  await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);
  runApp(const UiApp());
}


===== FILE: lib/runner.dart =====
// Public entrypoint ("barrel file") for embedding the runner in a host app.
//
// Host apps should import only this file:
// `import 'package:rpg_runner/runner.dart';`
//
// This keeps the public API stable while allowing internal folders/files to
// evolve without breaking downstream imports.
export 'core/levels/level_id.dart';
export 'core/players/player_character_definition.dart';
export 'core/players/player_character_registry.dart';
export 'ui/runner_game_route.dart';
export 'ui/runner_game_widget.dart';


===== FILE: lib/ui/AGENTS.md =====
# AGENTS.md - UI Layer

Instructions for AI coding agents working in the **UI** layer (`lib/ui/`).

## UI Layer Responsibility

The UI layer is responsible for **Flutter widgets**: menus, overlays, navigation, settings, and HUD elements.

**Critical rule:** UI **never modifies gameplay state directly**. It sends **Commands** to the game controller.

## House Style (Clean UI Code)

Default conventions in this repo aim for **clean, theme-driven, low-surface-area widgets**.

### Component Theming

- Use `ThemeExtension` for global tokens (`UiTokens`) and for component themes (e.g. `UiButtonTheme`, `UiHubTheme`).
- **Do not add component-specific sizing/colors to `UiTokens`**. If something is specific to a component, it belongs in that component’s theme extension.
- Prefer a single “resolved spec” object for components (e.g. `resolveSpec(...) → UiButtonSpec`) to keep widget build methods small and avoid scattered lookups / local “resolved*” variables.

### Component APIs

- Expose **semantic inputs only** (`variant`, `size`, `enabled`, callbacks, ids). Avoid ad-hoc styling knobs (`width/height/padding/textStyle/colors`) unless explicitly requested.
- Prefer enums (`Variant`, `Size`) + theme-defined presets (width/height/typography/padding) over per-call overrides.
- If the user asks for “theme”, “cleanup”, or “make it consistent”, assume it’s OK to do the full refactor in one pass: add the theme extension, migrate all call sites, and delete the legacy tokens/params.

### Modern Flutter APIs

- Use `WidgetState` / `WidgetStateProperty` (not `MaterialState*`).
- Use `Color.withValues(alpha: …)` (not `withOpacity`).

### System UI

- Avoid calling `SystemChrome` inside widget `build` methods.
- Prefer app-level orchestration (route observer / lifecycle) for global fullscreen behavior.
- Use `ScopedSystemUiMode` only when a behavior truly needs to be scoped to a subtree/route.

## Command Pattern

### Sending Commands to Core

UI interacts with Core gameplay through the Command pattern:

```dart
class PauseButton extends StatelessWidget {
  final GameController controller;
  
  @override
  Widget build(BuildContext context) {
    return IconButton(
      icon: Icon(Icons.pause),
      onPressed: () {
        // Send command to Core
        controller.enqueueCommand(
          PauseCommand(tickNumber: controller.currentTick)
        );
      },
    );
  }
}
```

**Rules:**
- Never access Core state directly
- Never mutate gameplay state from UI code
- Always use Commands for gameplay interactions
- Examples: pause, resume, level selection, ability activation

### Command Examples

Common UI → Core command patterns:

- **Level selection** → `LoadLevelCommand(levelId: 'level_2')`
- **Pause/Resume** → `PauseCommand()` / `ResumeCommand()`
- **Settings changes** → `UpdateSettingsCommand(volume: 0.8)`
- **Player actions** → Typically from Game input, but UI can also send them (e.g., virtual buttons)

## Widget Organization

### HUD Components

HUD (Heads-Up Display) elements are overlays that show game state:

- **Health bars** (`lib/ui/hud/`) - Display player health from snapshots
- **Score display** - Show current score, combo, multiplier
- **Progress indicators** - Level progress, distance traveled
- **Ability cooldowns** - Visual timers for abilities
- **Mini-map** (if applicable) - Simplified world view

**Pattern:**
```dart
class HealthBar extends StatelessWidget {
  final GameStateSnapshot snapshot;
  
  @override
  Widget build(BuildContext context) {
    final health = snapshot.player.health;
    final maxHealth = snapshot.player.maxHealth;
    
    return LinearProgressIndicator(
      value: health / maxHealth,
      backgroundColor: Colors.red[900],
      valueColor: AlwaysStoppedAnimation(Colors.red),
    );
  }
}
```

### Menu Screens

Menu screens for navigation and settings:

- **Play hub + setup** (`lib/ui/pages/`) - Start run, setup, meta routes
- **Pause menu** - Resume, restart, quit to menu
- **Game over screen** - Score, retry, quit
- **Level selection** - Choose which level to play
- **Settings** - Audio, graphics, controls

### Controls

Input widgets that send commands:

- **Virtual joystick** (`lib/ui/controls/`) - Directional input
- **Action buttons** - Jump, strike, ability buttons
- **Touch zones** - Swipe gestures, tap-to-jump areas

## State Management

### UI State vs Gameplay State

**Separation of concerns:**

- **Gameplay state** - Lives in Core, authoritative, deterministic
- **UI state** - Lives in UI layer, ephemeral, non-deterministic
  - Examples: menu visibility, animation states, selected options

### RunnerGameUIState

UI-specific state management:

```dart
class RunnerGameUIState {
  bool isPaused = false;
  bool isMenuOpen = false;
  String? selectedLevel;
  
  // UI state only - not part of Core
}
```

**Rules:**
- Keep UI state separate from gameplay state
- UI state can be mutable and non-deterministic
- Gameplay state must go through Core and Commands

### Scoped State

Use scoped state management (`lib/ui/scoped/`) for widgets that need shared UI state without affecting Core:

- Provider/InheritedWidget patterns for UI state
- Never use for gameplay state
- Keep scope narrow (menu-level, screen-level)

## Embedding Contract

### Public API

The game is embeddable via a stable public API:

- **`lib/runner.dart`** - Public entry point, exports main widgets/routes
- **`RunnerGameWidget`** - Main game widget component
- **`RunnerGameRoute`** - Flutter route for navigation

**Usage:**
```dart
// In another app
import 'package:rpg_runner/runner.dart';

Navigator.push(
  context,
  MaterialPageRoute(
    builder: (context) => RunnerGameWidget(levelId: LevelId.field),
  ),
);
```

### Dev Host

- **`lib/main.dart`** - Development host/demo app only
- Treat as a development harness, not part of the public API
- Safe to modify for development/testing without affecting embedding

## Viewport Integration

### Letterboxing & Safe Areas

UI overlays must respect the game viewport:

```dart
class GameOverlay extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return SafeArea(
      child: Stack(
        children: [
          // Game viewport (rendered by Flame)
          GameWidget(),
          
          // UI overlay (respects safe areas)
          Positioned(
            top: 16,
            left: 16,
            child: HealthBar(),
          ),
        ],
      ),
    );
  }
}
```

**Rules:**
- Use `SafeArea` to avoid notches/system UI
- Position HUD elements outside the game viewport if needed
- Respect letterboxing (black bars) in layout
- Don't cover critical gameplay areas with UI

## Snapshot Consumption

UI can read snapshots for display purposes:

```dart
class ScoreDisplay extends StatelessWidget {
  final GameStateSnapshot snapshot;
  
  @override
  Widget build(BuildContext context) {
    return Text(
      'Score: ${snapshot.score}',
      style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
    );
  }
}
```

**Rules:**
- Read snapshot data for display only
- Never mutate snapshots
- Never simulate or extrapolate gameplay from snapshots in UI

## Level Selection

Level selection is a UI concern that sends commands to Core:

```dart
class LevelSelectScreen extends StatelessWidget {
  final GameController controller;
  
  @override
  Widget build(BuildContext context) {
    return ListView(
      children: [
        LevelButton(
          levelId: 'level_1',
          onTap: () {
            controller.enqueueCommand(
              LoadLevelCommand(levelId: 'level_1')
            );
            Navigator.push(context, GameRoute());
          },
        ),
        // ... more levels
      ],
    );
  }
}
```

**Pattern:**
- Display level metadata (name, preview, locked state)
- Send `LoadLevelCommand` when level is selected
- Navigate to game route after command is sent
- Core handles actual level loading deterministically

## Common UI Subsystems

- **Controls** (`lib/ui/controls/`) - Input widgets (joystick, buttons)
- **HUD** (`lib/ui/hud/`) - In-game overlays (health, score, progress)
- **Assets** (`lib/ui/assets/`) - UI preview asset lifecycle (hub/run cache + warmup)
- **App** (`lib/ui/app/`) - App shell, routes, navigation
- **Bootstrap** (`lib/ui/bootstrap/`) - Loader + startup tasks
- **State** (`lib/ui/state/`) - Menu selection state + persistence
- **Pages** (`lib/ui/pages/`) - Menu/meta screens (hub, setup, meta, lab)
- **Levels** (`lib/ui/levels/`) - Level selection UI
- **Leaderboard** (`lib/ui/leaderboard/`) - Score display and rankings
- **Scoped** (`lib/ui/scoped/`) - Scoped state management
- **Viewport** (`lib/ui/viewport/`) - Viewport and safe area management

## What NOT to Do in UI Layer

- ❌ **Do not modify gameplay state directly** - use Commands
- ❌ **Do not simulate gameplay** - that's Core's job
- ❌ **Do not access Core internals** - use snapshots and commands
- ❌ **Do not mix UI state with gameplay state** - keep them separate
- ❌ **Do not mutate snapshots** - they are read-only

## Best Practices

✅ **Send Commands** for all gameplay interactions
✅ **Read snapshots** for display purposes only
✅ **Separate concerns** - UI state vs gameplay state
✅ **Respect viewport** - use SafeArea and letterboxing
✅ **Keep embedding API stable** - `lib/runner.dart` is public
✅ **Use Flutter best practices** - StatelessWidget, composition, etc.

---

**For cross-layer architecture and general rules**, see [lib/AGENTS.md](file:///c:/dev/rpg_runner/lib/AGENTS.md).


===== FILE: lib/ui/app/ui_app.dart =====
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:provider/provider.dart';

import '../assets/ui_asset_lifecycle.dart';
import '../levels/level_id_ui.dart';
import '../state/app_state.dart';
import '../theme/ui_button_theme.dart';
import '../theme/ui_hub_theme.dart';
import '../theme/ui_icon_button_theme.dart';
import '../theme/ui_inline_edit_text_theme.dart';
import '../theme/ui_inline_icon_button_theme.dart';
import '../theme/ui_leaderboard_theme.dart';
import '../theme/ui_segmented_control_theme.dart';
import '../theme/ui_tokens.dart';
import 'ui_router.dart';
import 'ui_routes.dart';

class UiApp extends StatefulWidget {
  const UiApp({super.key});

  @override
  State<UiApp> createState() => _UiAppState();
}

class _UiAppState extends State<UiApp> with WidgetsBindingObserver {
  final GlobalKey<NavigatorState> _navigatorKey = GlobalKey<NavigatorState>();
  late final _UiRouteObserver _routeObserver = _UiRouteObserver(
    onRouteChanged: _handleRouteChanged,
  );

  String? _currentRouteName;
  bool _hasSeenRoute = false;
  bool _resumeInFlight = false;

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
    _applyGlobalSystemUiMode();
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    super.dispose();
  }

  void _applyGlobalSystemUiMode() {
    // Apply immediately, then again after the current frame to win races with
    // route disposal/restore behavior that can re-enable system UI.
    unawaited(
      SystemChrome.setEnabledSystemUIMode(SystemUiMode.immersiveSticky),
    );
    WidgetsBinding.instance.addPostFrameCallback((_) {
      unawaited(
        SystemChrome.setEnabledSystemUIMode(SystemUiMode.immersiveSticky),
      );
    });
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    super.didChangeAppLifecycleState(state);
    if (state == AppLifecycleState.resumed) {
      _applyGlobalSystemUiMode();
      _showResumeLoader();
    }
  }

  @override
  void didChangeMetrics() {
    super.didChangeMetrics();
    // Keyboard/system-bar transitions can re-enable system UI (especially on
    // Android). Re-apply immersive mode after window metrics change.
    _applyGlobalSystemUiMode();
  }

  void _handleRouteChanged(
    _UiRouteChange change,
    Route<dynamic>? route,
    Route<dynamic>? previousRoute,
  ) {
    _hasSeenRoute = true;
    if (change == _UiRouteChange.pop || change == _UiRouteChange.remove) {
      _currentRouteName = previousRoute?.settings.name;
    } else {
      _currentRouteName = route?.settings.name;
    }

    if (change == _UiRouteChange.pop && route?.settings.name == UiRoutes.run) {
      _purgeRunCaches();
    }

    _applyGlobalSystemUiMode();

    if (_currentRouteName == UiRoutes.hub) {
      unawaited(_warmHubSelection());
    }
  }

  Future<void> _warmHubSelection() async {
    final ctx = _navigatorKey.currentContext;
    if (ctx == null) return;
    final appState = Provider.of<AppState>(ctx, listen: false);
    final lifecycle = Provider.of<UiAssetLifecycle>(ctx, listen: false);
    final selection = appState.selection;
    await lifecycle.warmHubSelection(
      themeId: selection.selectedLevelId.themeId,
      characterId: selection.selectedCharacterId,
      context: ctx,
    );
  }

  void _purgeRunCaches() {
    final ctx = _navigatorKey.currentContext;
    if (ctx == null) return;
    final lifecycle = Provider.of<UiAssetLifecycle>(ctx, listen: false);
    lifecycle.purgeRunCaches();
  }

  void _showResumeLoader() {
    if (_resumeInFlight) return;
    if (!_hasSeenRoute || _currentRouteName == UiRoutes.loader) {
      return;
    }
    final navigator = _navigatorKey.currentState;
    if (navigator == null) return;

    _resumeInFlight = true;
    navigator
        .pushNamed(UiRoutes.loader, arguments: const LoaderArgs(isResume: true))
        .whenComplete(() {
          _resumeInFlight = false;
        });
  }

  @override
  Widget build(BuildContext context) {
    return MultiProvider(
      providers: [
        ChangeNotifierProvider(create: (_) => AppState()),
        Provider<UiAssetLifecycle>(
          create: (_) => UiAssetLifecycle(),
          dispose: (_, lifecycle) => lifecycle.dispose(),
        ),
      ],
      child: MaterialApp(
        title: 'rpg-runner',
        debugShowCheckedModeBanner: false,
        theme: ThemeData(
          colorScheme:
              ColorScheme.fromSeed(
                seedColor: UiBrandPalette.steelBlueBackground,
                brightness: Brightness.dark,
              ).copyWith(
                surface: UiBrandPalette.cardBackground,
                onSurface: UiBrandPalette.steelBlueForeground,
                outline: UiBrandPalette.wornGoldOutline,
              ),
          scaffoldBackgroundColor: UiBrandPalette.baseBackground,
          canvasColor: UiBrandPalette.cardBackground,
          dividerColor: UiBrandPalette.wornGoldOutline,
          appBarTheme: const AppBarTheme(
            backgroundColor: UiBrandPalette.baseBackground,
            foregroundColor: UiBrandPalette.steelBlueForeground,
            iconTheme: IconThemeData(color: UiBrandPalette.steelBlueForeground),
            titleTextStyle: TextStyle(
              fontFamily: 'CrimsonText',
              fontSize: 20,
              fontWeight: FontWeight.w600,
              color: UiBrandPalette.steelBlueForeground,
            ),
          ),
          textSelectionTheme: const TextSelectionThemeData(
            cursorColor: UiBrandPalette.wornGoldInsetBorder,
            selectionColor: UiBrandPalette.wornGoldGlow,
            selectionHandleColor: UiBrandPalette.wornGoldInsetBorder,
          ),
          fontFamily: 'CrimsonText',
          useMaterial3: true,
          extensions: const [
            UiTokens.standard,
            UiHubTheme.standard,
            UiButtonTheme.standard,
            UiIconButtonTheme.standard,
            UiInlineIconButtonTheme.standard,
            UiInlineEditTextTheme.standard,
            UiSegmentedControlTheme.standard,
            UiLeaderboardTheme.standard,
          ],
        ),
        navigatorKey: _navigatorKey,
        initialRoute: UiRoutes.brandSplash,
        onGenerateRoute: UiRouter.onGenerateRoute,
        navigatorObservers: [_routeObserver],
      ),
    );
  }
}

class _UiRouteObserver extends NavigatorObserver {
  _UiRouteObserver({required this.onRouteChanged});

  final void Function(
    _UiRouteChange change,
    Route<dynamic>? route,
    Route<dynamic>? previousRoute,
  )
  onRouteChanged;

  void _update(
    _UiRouteChange change,
    Route<dynamic>? route,
    Route<dynamic>? previousRoute,
  ) {
    onRouteChanged(change, route, previousRoute);
  }

  @override
  void didPush(Route<dynamic> route, Route<dynamic>? previousRoute) {
    super.didPush(route, previousRoute);
    _update(_UiRouteChange.push, route, previousRoute);
  }

  @override
  void didPop(Route<dynamic> route, Route<dynamic>? previousRoute) {
    super.didPop(route, previousRoute);
    _update(_UiRouteChange.pop, route, previousRoute);
  }

  @override
  void didReplace({Route<dynamic>? newRoute, Route<dynamic>? oldRoute}) {
    super.didReplace(newRoute: newRoute, oldRoute: oldRoute);
    _update(_UiRouteChange.replace, newRoute, oldRoute);
  }

  @override
  void didRemove(Route<dynamic> route, Route<dynamic>? previousRoute) {
    super.didRemove(route, previousRoute);
    _update(_UiRouteChange.remove, route, previousRoute);
  }
}

enum _UiRouteChange { push, pop, replace, remove }


===== FILE: lib/ui/app/ui_router.dart =====
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import '../bootstrap/loader_page.dart';
import '../bootstrap/brand_splash_screen.dart';
import '../pages/hub/play_hub_page.dart';
import '../pages/leaderboards/leaderboards_page.dart';
import '../pages/lab/loadout_lab_page.dart';
import '../pages/meta/credits_page.dart';
import '../pages/meta/town_page.dart';
import '../pages/meta/support_page.dart';
import '../pages/meta/library_page.dart';
import '../pages/meta/options_page.dart';
import '../pages/meta/messages_page.dart';
import '../pages/profile/profile_page.dart';
import '../pages/selectLevel/level_setup_page.dart';
import '../pages/selectCharacter/loadout_setup_page.dart';
import '../bootstrap/profile_name_setup_page.dart';
import '../runner_game_route.dart';
import 'ui_routes.dart';

class UiRouter {
  const UiRouter._();

  static Route<dynamic> onGenerateRoute(RouteSettings settings) {
    switch (settings.name) {
      case UiRoutes.brandSplash:
        return MaterialPageRoute<void>(
          settings: settings,
          builder: (_) => const BrandSplashScreen(),
        );
      case UiRoutes.loader:
        final args = settings.arguments is LoaderArgs
            ? settings.arguments as LoaderArgs
            : const LoaderArgs();
        return MaterialPageRoute<void>(
          settings: settings,
          builder: (_) => LoaderPage(args: args),
        );
      case UiRoutes.hub:
        return MaterialPageRoute<void>(
          settings: settings,
          builder: (_) => const PlayHubPage(),
        );
      case UiRoutes.setupLevel:
        return MaterialPageRoute<void>(
          settings: settings,
          builder: (_) => const LevelSetupPage(),
        );
      case UiRoutes.setupLoadout:
        return MaterialPageRoute<void>(
          settings: settings,
          builder: (_) => const LoadoutSetupPage(),
        );
      case UiRoutes.setupProfileName:
        return MaterialPageRoute<void>(
          settings: settings,
          builder: (_) => const ProfileNameSetupPage(),
        );
      case UiRoutes.profile:
        return MaterialPageRoute<void>(
          settings: settings,
          builder: (_) => const ProfilePage(),
        );
      case UiRoutes.loadoutLab:
        return MaterialPageRoute<void>(
          settings: settings,
          builder: (_) => const LoadoutLabPage(),
        );
      case UiRoutes.leaderboards:
        return MaterialPageRoute<void>(
          settings: settings,
          builder: (_) => const LeaderboardsPage(),
        );
      case UiRoutes.options:
        return MaterialPageRoute<void>(
          settings: settings,
          builder: (_) => const OptionsPage(),
        );
      case UiRoutes.library:
        return MaterialPageRoute<void>(
          settings: settings,
          builder: (_) => const LibraryPage(),
        );
      case UiRoutes.town:
        return MaterialPageRoute<void>(
          settings: settings,
          builder: (_) => const TownPage(),
        );
      case UiRoutes.support:
        return MaterialPageRoute<void>(
          settings: settings,
          builder: (_) => const SupportPage(),
        );
      case UiRoutes.messages:
        return MaterialPageRoute<void>(
          settings: settings,
          builder: (_) => const MessagesPage(),
        );
      case UiRoutes.credits:
        return MaterialPageRoute<void>(
          settings: settings,
          builder: (_) => const CreditsPage(),
        );
      case UiRoutes.run:
        final args = settings.arguments;
        if (args is RunStartArgs) {
          return createRunnerGameRoute(
            runId: args.runId,
            seed: args.seed,
            levelId: args.levelId,
            playerCharacterId: args.playerCharacterId,
            runType: args.runType,
            equippedLoadout: args.equippedLoadout,
            settings: settings,
            restoreOrientations: const [
              DeviceOrientation.landscapeLeft,
              DeviceOrientation.landscapeRight,
            ],
            restoreSystemUiMode: SystemUiMode.immersiveSticky,
          );
        }
        return MaterialPageRoute<void>(
          settings: settings,
          builder: (_) => const PlayHubPage(),
        );
      default:
        return MaterialPageRoute<void>(
          settings: settings,
          builder: (_) => const PlayHubPage(),
        );
    }
  }
}


===== FILE: lib/ui/app/ui_routes.dart =====
import '../../core/levels/level_id.dart';
import '../../core/players/player_character_definition.dart';
import '../../core/ecs/stores/combat/equipped_loadout_store.dart';
import '../state/selection_state.dart';

class UiRoutes {
  const UiRoutes._();

  static const String brandSplash = '/brand_splash';
  static const String loader = '/loader';
  static const String hub = '/hub';
  static const String setupProfileName = '/setup/profile-name';
  static const String setupLevel = '/setup/level';
  static const String setupLoadout = '/setup/loadout';
  static const String profile = '/profile';
  static const String loadoutLab = '/lab';
  static const String leaderboards = '/leaderboards';
  static const String options = '/meta/options';
  static const String library = '/meta/library';
  static const String town = '/meta/town';
  static const String messages = '/meta/messages';
  static const String support = '/meta/support';
  static const String credits = '/credits';
  static const String run = '/run';
}

class LoaderArgs {
  const LoaderArgs({this.isResume = false});

  final bool isResume;
}

class RunStartArgs {
  const RunStartArgs({
    required this.runId,
    required this.seed,
    required this.levelId,
    required this.playerCharacterId,
    required this.runType,
    required this.equippedLoadout,
  });

  final int runId;
  final int seed;
  final LevelId levelId;
  final PlayerCharacterId playerCharacterId;
  final RunType runType;
  final EquippedLoadoutDef equippedLoadout;
}


===== FILE: lib/ui/assets/asset_scopes.dart =====
/// Asset lifetimes scoped to UI usage.
enum AssetScope {
  /// Menu/hub previews that can persist between routes.
  hub,

  /// Run-specific assets that should be purged on exit.
  run,
}


===== FILE: lib/ui/assets/lru_cache.dart =====
import 'dart:collection';

typedef EvictCallback<V> = void Function(V value);

/// Small, allocation-light LRU cache with optional eviction callback.
class LruCache<K, V> {
  LruCache({required int maxEntries, this.onEvict})
      : _maxEntries = maxEntries < 0 ? 0 : maxEntries;

  final int _maxEntries;
  final EvictCallback<V>? onEvict;
  final LinkedHashMap<K, V> _map = LinkedHashMap<K, V>();

  int get length => _map.length;

  Iterable<V> get values => _map.values;

  V? get(K key) {
    final value = _map.remove(key);
    if (value == null) return null;
    _map[key] = value;
    return value;
  }

  void put(K key, V value) {
    final existing = _map.remove(key);
    if (existing != null && !identical(existing, value)) {
      onEvict?.call(existing);
    }
    _map[key] = value;
    trim();
  }

  bool containsKey(K key) => _map.containsKey(key);

  void remove(K key) {
    final value = _map.remove(key);
    if (value != null) {
      onEvict?.call(value);
    }
  }

  void clear() {
    if (onEvict != null) {
      for (final value in _map.values) {
        onEvict!(value);
      }
    }
    _map.clear();
  }

  void trim() {
    if (_maxEntries <= 0) {
      clear();
      return;
    }
    while (_map.length > _maxEntries) {
      final entry = _map.entries.first;
      _map.remove(entry.key);
      onEvict?.call(entry.value);
    }
  }
}


===== FILE: lib/ui/assets/ui_asset_lifecycle.dart =====
import 'package:flame/cache.dart';
import 'package:flame/components.dart';
import 'package:flutter/widgets.dart';

import '../../core/players/player_character_definition.dart';
import '../../core/players/player_character_registry.dart';
import '../../core/snapshots/enums.dart';
import '../../game/components/player/player_animations.dart';
import '../../game/themes/parallax_theme_registry.dart';
import 'asset_scopes.dart';
import 'lru_cache.dart';

class IdleAnimBundle {
  const IdleAnimBundle({required this.animation, required this.anchor});

  final SpriteAnimation animation;
  final Anchor anchor;
}

class UiAssetLifecycle {
  UiAssetLifecycle({
    int maxHubThemes = 8,
    int maxHubCharacters = 4,
    int maxRunThemes = 0,
    int maxRunCharacters = 0,
  }) : _hubParallaxCache = LruCache<String, List<AssetImage>>(
         maxEntries: maxHubThemes,
         onEvict: _evictParallaxLayers,
       ),
       _runParallaxCache = LruCache<String, List<AssetImage>>(
         maxEntries: maxRunThemes,
         onEvict: _evictParallaxLayers,
       ),
       _hubIdleCache = LruCache<PlayerCharacterId, IdleAnimBundle>(
         maxEntries: maxHubCharacters,
       ),
       _runIdleCache = LruCache<PlayerCharacterId, IdleAnimBundle>(
         maxEntries: maxRunCharacters,
       );

  final Images _idleImages = Images();

  final LruCache<String, List<AssetImage>> _hubParallaxCache;
  final LruCache<String, List<AssetImage>> _runParallaxCache;
  final LruCache<PlayerCharacterId, IdleAnimBundle> _hubIdleCache;
  final LruCache<PlayerCharacterId, IdleAnimBundle> _runIdleCache;

  final Map<PlayerCharacterId, Future<IdleAnimBundle>> _hubIdleInFlight =
      <PlayerCharacterId, Future<IdleAnimBundle>>{};
  final Map<PlayerCharacterId, Future<IdleAnimBundle>> _runIdleInFlight =
      <PlayerCharacterId, Future<IdleAnimBundle>>{};

  final Map<AssetImage, Future<void>> _parallaxPrecacheInFlight =
      <AssetImage, Future<void>>{};

  Future<IdleAnimBundle> getIdle(
    PlayerCharacterId id, {
    AssetScope scope = AssetScope.hub,
  }) {
    final cache = _idleCacheFor(scope);
    final cached = cache.get(id);
    if (cached != null) return Future.value(cached);

    final inFlight = _idleInFlightFor(scope);
    final existing = inFlight[id];
    if (existing != null) return existing;

    final future = _loadIdleBundle(id)
        .then((bundle) {
          cache.put(id, bundle);
          inFlight.remove(id);
          return bundle;
        })
        .catchError((error, stackTrace) {
          inFlight.remove(id);
          return Future<IdleAnimBundle>.error(error, stackTrace);
        });

    inFlight[id] = future;
    return future;
  }

  Future<List<AssetImage>> getParallaxLayers(
    String? themeId, {
    AssetScope scope = AssetScope.hub,
  }) async {
    final cache = _parallaxCacheFor(scope);
    final key = _cacheKeyForTheme(themeId);
    final cached = cache.get(key);
    if (cached != null) return cached;

    final built = _buildParallaxLayers(themeId);
    cache.put(key, built);
    return built;
  }

  Future<void> precacheParallaxLayers(
    List<AssetImage> layers,
    BuildContext context,
  ) async {
    if (layers.isEmpty) return;
    final futures = <Future<void>>[];
    for (final provider in layers) {
      futures.add(_precacheImageOnce(provider, context));
    }
    await Future.wait(futures);
  }

  Future<void> warmHubSelection({
    required String? themeId,
    required PlayerCharacterId characterId,
    required BuildContext context,
  }) async {
    try {
      final layers = await getParallaxLayers(themeId, scope: AssetScope.hub);
      if (!context.mounted) return;
      await Future.wait([
        getIdle(characterId, scope: AssetScope.hub),
        precacheParallaxLayers(layers, context),
      ]);
      trimHubCaches();
    } catch (_) {
      // Best-effort warmup.
    }
  }

  void trimHubCaches() {
    _hubParallaxCache.trim();
    _hubIdleCache.trim();
  }

  void purgeRunCaches() {
    _runParallaxCache.clear();
    _runIdleCache.clear();
    _runIdleInFlight.clear();
  }

  void purgeAll() {
    _hubParallaxCache.clear();
    _runParallaxCache.clear();
    _hubIdleCache.clear();
    _runIdleCache.clear();
    _hubIdleInFlight.clear();
    _runIdleInFlight.clear();
    _parallaxPrecacheInFlight.clear();
    _idleImages.clearCache();
  }

  void dispose() => purgeAll();

  LruCache<String, List<AssetImage>> _parallaxCacheFor(AssetScope scope) {
    return scope == AssetScope.run ? _runParallaxCache : _hubParallaxCache;
  }

  LruCache<PlayerCharacterId, IdleAnimBundle> _idleCacheFor(AssetScope scope) {
    return scope == AssetScope.run ? _runIdleCache : _hubIdleCache;
  }

  Map<PlayerCharacterId, Future<IdleAnimBundle>> _idleInFlightFor(
    AssetScope scope,
  ) {
    return scope == AssetScope.run ? _runIdleInFlight : _hubIdleInFlight;
  }

  Future<IdleAnimBundle> _loadIdleBundle(PlayerCharacterId characterId) async {
    final def = PlayerCharacterRegistry.resolve(characterId);
    final animSet = await loadPlayerAnimations(
      _idleImages,
      renderAnim: def.renderAnim,
    );
    final idle = animSet.animations[AnimKey.idle];
    if (idle == null) {
      throw StateError('Missing idle animation for $characterId');
    }
    return IdleAnimBundle(animation: idle, anchor: animSet.anchor);
  }

  static String _cacheKeyForTheme(String? themeId) {
    return themeId ?? '__null__';
  }

  static List<AssetImage> _buildParallaxLayers(String? themeId) {
    final theme = ParallaxThemeRegistry.forThemeId(themeId);

    AssetImage img(String relToImagesFolder) =>
        AssetImage('assets/images/$relToImagesFolder');

    return <AssetImage>[
      for (final layer in theme.backgroundLayers) img(layer.assetPath),
      img(theme.groundLayerAsset),
      for (final layer in theme.foregroundLayers) img(layer.assetPath),
    ];
  }

  Future<void> _precacheImageOnce(AssetImage provider, BuildContext context) {
    final existing = _parallaxPrecacheInFlight[provider];
    if (existing != null) return existing;

    final future = precacheImage(provider, context)
        .catchError((_) {})
        .whenComplete(() {
          _parallaxPrecacheInFlight.remove(provider);
        });

    _parallaxPrecacheInFlight[provider] = future;
    return future;
  }

  static void _evictParallaxLayers(List<AssetImage> layers) {
    final cache = PaintingBinding.instance.imageCache;
    for (final provider in layers) {
      cache.evict(provider);
    }
  }
}


===== FILE: lib/ui/bootstrap/app_bootstrapper.dart =====
import '../state/app_state.dart';

class BootstrapResult {
  const BootstrapResult._({required this.ok, this.error, this.stackTrace});

  final bool ok;
  final Object? error;
  final StackTrace? stackTrace;

  static const BootstrapResult success = BootstrapResult._(ok: true);

  factory BootstrapResult.failure(Object error, StackTrace stackTrace) {
    return BootstrapResult._(ok: false, error: error, stackTrace: stackTrace);
  }
}

class AppBootstrapper {
  const AppBootstrapper();

  Future<BootstrapResult> run(AppState appState, {required bool force}) async {
    try {
      await appState.bootstrap(force: force);
      return BootstrapResult.success;
    } catch (error, stackTrace) {
      return BootstrapResult.failure(error, stackTrace);
    }
  }
}


===== FILE: lib/ui/bootstrap/brand_splash_screen.dart =====
import 'dart:async';

import 'package:flutter/material.dart';

import '../app/ui_routes.dart';
import '../theme/ui_tokens.dart';

class BrandSplashScreen extends StatefulWidget {
  const BrandSplashScreen({super.key});

  @override
  State<BrandSplashScreen> createState() => _BrandSplashScreenState();
}

class _BrandSplashScreenState extends State<BrandSplashScreen> {
  @override
  void initState() {
    super.initState();
    // Wait for 1.8 seconds, then navigate to the loader.
    Timer(const Duration(milliseconds: 1800), () {
      if (mounted) {
        Navigator.pushReplacementNamed(context, UiRoutes.loader);
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    final ui = context.ui;
    return Scaffold(
      backgroundColor: ui.colors.background,
      body: Center(
        child: Text(
          'Luxis Games',
          style: ui.text.display.copyWith(
            fontSize: 36,
            fontWeight: FontWeight.w700,
            letterSpacing: 0.6,
          ),
        ),
      ),
    );
  }
}


===== FILE: lib/ui/bootstrap/loader_content.dart =====
import 'package:flutter/material.dart';

import '../theme/ui_tokens.dart';

/// Shared loading visual used by bootstrap + run loading.
class LoaderContent extends StatelessWidget {
  const LoaderContent({
    super.key,
    this.title = 'The Long Run',
    this.subtitle = 'Lothringen',
    this.loadingMessage = 'Loading...',
    this.errorMessage,
    this.onContinue,
  });

  final String title;
  final String subtitle;
  final String loadingMessage;
  final String? errorMessage;
  final VoidCallback? onContinue;

  bool get _hasError => errorMessage != null;

  @override
  Widget build(BuildContext context) {
    final ui = context.ui;
    final titleColor = ui.colors.textPrimary;
    final mutedTextColor = ui.colors.textMuted;
    return Column(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        Text(
          subtitle,
          style: TextStyle(
            fontFamily: 'Cinzel',
            fontSize: 24,
            fontWeight: FontWeight.w700,
            color: titleColor,
            letterSpacing: 2,
          ),
        ),
        Text(
          title,
          // Game title style only used here.
          style: TextStyle(
            fontFamily: 'Cinzel',
            fontSize: 36,
            fontWeight: FontWeight.w700,
            color: titleColor,
            letterSpacing: 2,
          ),
        ),
        SizedBox(height: ui.space.lg),
        if (!_hasError) ...[
          CircularProgressIndicator(color: ui.colors.textPrimary),
          SizedBox(height: ui.space.md),
          Text(
            loadingMessage,
            style: ui.text.body.copyWith(color: mutedTextColor),
          ),
        ],
        if (_hasError) ...[
          Text(
            'Bootstrap failed',
            style: ui.text.body.copyWith(
              color: ui.colors.danger,
              fontSize: 16,
              fontWeight: FontWeight.w600,
            ),
          ),
          SizedBox(height: ui.space.xs),
          Text(
            errorMessage!,
            textAlign: TextAlign.center,
            style: ui.text.body.copyWith(color: mutedTextColor),
          ),
          if (onContinue != null) ...[
            SizedBox(height: ui.space.md),
            FilledButton(
              onPressed: onContinue,
              child: const Text('Continue with defaults'),
            ),
          ],
        ],
      ],
    );
  }
}


===== FILE: lib/ui/bootstrap/loader_page.dart =====
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

import '../app/ui_routes.dart';
import '../components/menu_layout.dart';
import '../components/menu_scaffold.dart';
import '../state/app_state.dart';
import '../state/profile_flag_keys.dart';
import 'app_bootstrapper.dart';
import 'loader_content.dart';

class LoaderPage extends StatefulWidget {
  const LoaderPage({
    super.key,
    required this.args,
    this.bootstrapper = const AppBootstrapper(),
  });

  final LoaderArgs args;
  final AppBootstrapper bootstrapper;

  @override
  State<LoaderPage> createState() => _LoaderPageState();
}

class _LoaderPageState extends State<LoaderPage> {
  BootstrapResult? _result;
  bool _starting = false;

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _startBootstrap();
    });
  }

  Future<void> _startBootstrap() async {
    if (_starting) return;
    _starting = true;
    final appState = context.read<AppState>();
    // Ensure the loading screen is visible for at least 2 seconds on cold start.
    // On resume, don't enforce an artificial minimum duration.
    final minWait =
        widget.args.isResume
            ? Future<void>.value()
            : Future<void>.delayed(const Duration(seconds: 2));
    final bootstrap = widget.bootstrapper.run(
      appState,
      force: widget.args.isResume,
    );

    final result = await bootstrap;
    await minWait;
    if (!mounted) return;
    setState(() {
      _result = result;
    });
    if (result.ok) {
      _complete();
    }
  }

  void _complete() {
    final navigator = Navigator.of(context);
    if (widget.args.isResume && navigator.canPop()) {
      navigator.pop();
      return;
    }

    final appState = context.read<AppState>();
    final completed =
        appState.profile.flags[ProfileFlagKeys.namePromptCompleted] == true;

    if (!widget.args.isResume && !completed) {
      navigator.pushReplacementNamed(UiRoutes.setupProfileName);
      return;
    }

    navigator.pushReplacementNamed(UiRoutes.hub);
  }

  void _continueWithDefaults() {
    final appState = context.read<AppState>();
    appState.applyDefaults();
    _complete();
  }

  @override
  Widget build(BuildContext context) {
    final hasError = _result != null && !_result!.ok;

    return MenuScaffold(
      showAppBar: false,
      child: MenuLayout(
        alignment: Alignment.center,
        scrollable: false,
        child: hasError
            ? LoaderContent(
                errorMessage: '${_result!.error}',
                onContinue: _continueWithDefaults,
              )
            : const LoaderContent(),
      ),
    );
  }
}


===== FILE: lib/ui/bootstrap/profile_name_setup_page.dart =====
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

import '../app/ui_routes.dart';
import '../components/app_button.dart';
import '../components/menu_layout.dart';
import '../components/menu_scaffold.dart';
import '../profile/display_name_policy.dart';
import '../state/app_state.dart';
import '../state/profile_flag_keys.dart';
import '../theme/ui_tokens.dart';

class ProfileNameSetupPage extends StatefulWidget {
  const ProfileNameSetupPage({super.key});

  @override
  State<ProfileNameSetupPage> createState() => _ProfileNameSetupPageState();
}

class _ProfileNameSetupPageState extends State<ProfileNameSetupPage> {
  final _controller = TextEditingController();
  final _policy = const DisplayNamePolicy();

  String? _error;
  bool _saving = false;

  @override
  void initState() {
    super.initState();
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  Future<void> _complete({required bool skipped}) async {
    if (_saving) return;
    setState(() => _saving = true);

    final appState = context.read<AppState>();
    final nowMs = DateTime.now().millisecondsSinceEpoch;

    await appState.updateProfile((p) {
      final flags = Map<String, bool>.from(p.flags);
      flags[ProfileFlagKeys.namePromptCompleted] = true;

      if (skipped) {
        return p.copyWith(flags: flags);
      }

      final raw = _controller.text;
      final shouldSetCooldown = p.displayName.isNotEmpty;
      return p.copyWith(
        displayName: raw.trim(),
        displayNameLastChangedAtMs: shouldSetCooldown
            ? nowMs
            : p.displayNameLastChangedAtMs,
        flags: flags,
      );
    });

    if (!mounted) return;
    Navigator.of(context).pushReplacementNamed(UiRoutes.hub);
  }

  Future<void> _confirm() async {
    final err = _policy.validate(_controller.text);
    if (err != null) {
      setState(() => _error = err);
      return;
    }
    await _complete(skipped: false);
  }

  @override
  Widget build(BuildContext context) {
    final ui = context.ui;
    return MenuScaffold(
      showAppBar: false,
      child: MenuLayout(
        child: Center(
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 520),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Text(
                  'Choose your name',
                  style: ui.text.title.copyWith(
                    fontSize: 28,
                    fontWeight: FontWeight.w700,
                  ),
                ),
                SizedBox(height: ui.space.xs),
                Text(
                  'This is optional. You can change it later in Profile.',
                  style: ui.text.body.copyWith(color: ui.colors.textMuted),
                  textAlign: TextAlign.center,
                ),
                SizedBox(height: ui.space.lg),
                TextField(
                  controller: _controller,
                  style: ui.text.body.copyWith(color: ui.colors.textPrimary),
                  decoration: InputDecoration(
                    labelText: 'Display name',
                    labelStyle: ui.text.caption.copyWith(
                      color: ui.colors.textMuted,
                    ),
                    errorText: _error,
                    filled: true,
                    fillColor: ui.colors.cardBackground.withValues(alpha: 0.8),
                    enabledBorder: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(ui.radii.md),
                      borderSide: BorderSide(color: ui.colors.outline),
                    ),
                    focusedBorder: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(ui.radii.md),
                      borderSide: BorderSide(color: ui.colors.outlineStrong),
                    ),
                    border: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(ui.radii.md),
                    ),
                  ),
                  onChanged: (_) => setState(() => _error = null),
                ),
                SizedBox(height: ui.space.md + ui.space.xxs),
                Row(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    AppButton(
                      label: 'Skip',
                      size: AppButtonSize.xs,
                      variant: AppButtonVariant.secondary,
                      onPressed: _saving
                          ? null
                          : () => _complete(skipped: true),
                    ),
                    SizedBox(width: ui.space.sm),
                    AppButton(
                      label: 'Confirm',
                      size: AppButtonSize.md,
                      onPressed: _saving ? null : _confirm,
                    ),
                  ],
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}


===== FILE: lib/ui/components/ability_placeholder_icon.dart =====
import 'package:flutter/material.dart';

import '../theme/ui_tokens.dart';

/// Neutral placeholder icon for abilities while dedicated art is not available.
///
/// The icon intentionally stays minimal: transparent fill, thin border, and
/// a short text label (typically 1-3 characters).
class AbilityPlaceholderIcon extends StatelessWidget {
  const AbilityPlaceholderIcon({
    super.key,
    required this.label,
    this.size = 22,
    this.emphasis = false,
    this.enabled = true,
  });

  final String label;
  final double size;
  final bool emphasis;
  final bool enabled;

  @override
  Widget build(BuildContext context) {
    final ui = context.ui;
    final borderColor = emphasis
        ? ui.colors.accentStrong
        : ui.colors.outline.withValues(alpha: enabled ? 0.65 : 0.35);
    final textColor = enabled
        ? ui.colors.textPrimary
        : ui.colors.textMuted.withValues(alpha: 0.75);
    final radius = (size * 0.28).clamp(4.0, 8.0);

    return SizedBox.square(
      dimension: size,
      child: DecoratedBox(
        decoration: BoxDecoration(
          color: Colors.transparent,
          borderRadius: BorderRadius.circular(radius),
          border: Border.all(color: borderColor, width: 1),
        ),
        child: Center(
          child: Text(
            label,
            style: ui.text.caption.copyWith(
              color: textColor,
              fontSize: (size * 0.34).clamp(8.0, 11.0),
              fontWeight: FontWeight.w700,
              letterSpacing: 0.2,
              height: 1.0,
            ),
            maxLines: 1,
            overflow: TextOverflow.clip,
          ),
        ),
      ),
    );
  }
}


===== FILE: lib/ui/components/app_button.dart =====
import 'dart:math' as math;

import 'package:flutter/material.dart';

export '../theme/ui_button_theme.dart' show AppButtonSize, AppButtonVariant;

import '../theme/ui_button_theme.dart';
import '../theme/ui_tokens.dart';

class AppButton extends StatefulWidget {
  const AppButton({
    super.key,
    required this.label,
    required this.onPressed,
    this.variant = AppButtonVariant.primary,
    this.size = AppButtonSize.md,
  });

  final String label;
  final VoidCallback? onPressed;
  final AppButtonVariant variant;
  final AppButtonSize size;

  @override
  State<AppButton> createState() => _AppButtonState();
}

class _AppButtonState extends State<AppButton> {
  static const Duration _stateAnimationDuration = Duration(milliseconds: 120);

  bool _hovered = false;
  bool _pressed = false;
  bool _focused = false;

  void _setHovered(bool value) {
    if (_hovered == value) return;
    setState(() => _hovered = value);
  }

  void _setPressed(bool value) {
    if (_pressed == value) return;
    setState(() => _pressed = value);
  }

  void _setFocused(bool value) {
    if (_focused == value) return;
    setState(() => _focused = value);
  }

  Color _blendOver({
    required Color base,
    required Color overlay,
    required double alpha,
  }) {
    if (alpha <= 0) return base;
    return Color.alphaBlend(overlay.withValues(alpha: alpha), base);
  }

  Color _resolveSurfaceColor({
    required Color base,
    required Color foreground,
    required UiButtonTheme buttons,
    required bool enabled,
  }) {
    if (!enabled) {
      return base.withValues(alpha: buttons.disabledBackgroundAlpha);
    }

    var color = base;
    if (_pressed) {
      color = _blendOver(
        base: color,
        overlay: UiBrandPalette.black,
        alpha: buttons.pressedOverlayAlpha + 0.08,
      );
    } else {
      if (_hovered) {
        color = _blendOver(
          base: color,
          overlay: foreground,
          alpha: buttons.hoverOverlayAlpha + 0.04,
        );
      }
      if (_focused) {
        color = _blendOver(base: color, overlay: foreground, alpha: 0.08);
      }
    }
    return color;
  }

  Color _resolveBorderColor({
    required Color base,
    required Color foreground,
    required UiButtonTheme buttons,
    required bool enabled,
  }) {
    if (!enabled) {
      return base.withValues(alpha: buttons.disabledBorderAlpha);
    }
    if (_pressed) {
      return _blendOver(base: base, overlay: UiBrandPalette.black, alpha: 0.1);
    }
    if (_hovered || _focused) {
      return _blendOver(base: base, overlay: foreground, alpha: 0.12);
    }
    return base;
  }

  @override
  Widget build(BuildContext context) {
    final ui = context.ui;
    final buttons = context.buttons;

    final spec = buttons.resolveSpec(
      ui: ui,
      variant: widget.variant,
      size: widget.size,
    );
    final enabled = widget.onPressed != null;
    final outerRadius = BorderRadius.circular(ui.radii.sm);
    final bevelInset = math.max(1.0, ui.sizes.borderWidth);
    final innerRadius = BorderRadius.circular(
      math.max(0.0, ui.radii.sm - bevelInset),
    );
    final contentRadius = BorderRadius.circular(
      math.max(0.0, ui.radii.sm - bevelInset - 1),
    );

    final outerTop = _resolveSurfaceColor(
      base: spec.surfaceTop,
      foreground: spec.foreground,
      buttons: buttons,
      enabled: enabled,
    );
    final outerBottom = _resolveSurfaceColor(
      base: spec.surfaceBottom,
      foreground: spec.foreground,
      buttons: buttons,
      enabled: enabled,
    );
    final innerTop = _resolveSurfaceColor(
      base: spec.insetTop,
      foreground: spec.foreground,
      buttons: buttons,
      enabled: enabled,
    );
    final innerBottom = _resolveSurfaceColor(
      base: spec.insetBottom,
      foreground: spec.foreground,
      buttons: buttons,
      enabled: enabled,
    );
    final outerBorder = _resolveBorderColor(
      base: spec.border,
      foreground: spec.foreground,
      buttons: buttons,
      enabled: enabled,
    );
    final innerBorder = _resolveBorderColor(
      base: spec.insetBorder,
      foreground: spec.foreground,
      buttons: buttons,
      enabled: enabled,
    );
    final textColor = enabled
        ? spec.foreground
        : spec.foreground.withValues(alpha: buttons.disabledForegroundAlpha);
    final textStyle = spec.textStyle.copyWith(
      color: textColor,
      height: 1,
      shadows: [
        Shadow(
          color: UiBrandPalette.black.withValues(alpha: enabled ? 0.65 : 0.4),
          blurRadius: _pressed ? 1 : 2.5,
          offset: Offset(0, _pressed ? 0.5 : 1.2),
        ),
      ],
    );
    final textStrutStyle = StrutStyle(
      fontFamily: textStyle.fontFamily,
      fontSize: textStyle.fontSize,
      fontWeight: textStyle.fontWeight,
      height: textStyle.height,
      forceStrutHeight: true,
    );
    final pressedOffset = enabled && _pressed ? 1.5 : 0.0;
    final glowStrength = !enabled
        ? 0.0
        : _focused
        ? 0.45
        : _hovered
        ? 0.25
        : 0.0;
    final shadowColor = enabled
        ? spec.shadow
        : spec.shadow.withValues(alpha: buttons.disabledBackgroundAlpha);
    final glowColor = spec.glow.withValues(alpha: spec.glow.a * glowStrength);

    return SizedBox(
      width: spec.width,
      height: spec.height,
      child: AnimatedContainer(
        duration: _stateAnimationDuration,
        curve: Curves.easeOutCubic,
        transform: Matrix4.translationValues(0, pressedOffset, 0),
        decoration: BoxDecoration(
          borderRadius: outerRadius,
          gradient: LinearGradient(
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
            colors: [outerTop, outerBottom],
          ),
          border: Border.all(color: outerBorder, width: ui.sizes.borderWidth),
          boxShadow: [
            BoxShadow(
              color: shadowColor,
              blurRadius: _pressed ? 4 : 10,
              offset: Offset(0, _pressed ? 2 : 5),
            ),
            if (glowStrength > 0)
              BoxShadow(
                color: glowColor,
                blurRadius: 16,
                spreadRadius: 1,
                offset: const Offset(0, 0),
              ),
          ],
        ),
        child: Padding(
          padding: EdgeInsets.all(bevelInset),
          child: ClipRRect(
            borderRadius: innerRadius,
            child: Material(
              type: MaterialType.transparency,
              child: Ink(
                decoration: BoxDecoration(
                  gradient: LinearGradient(
                    begin: Alignment.topCenter,
                    end: Alignment.bottomCenter,
                    colors: [innerTop, innerBottom],
                  ),
                  border: Border.all(color: innerBorder),
                ),
                child: InkWell(
                  onTap: widget.onPressed,
                  onHover: enabled ? _setHovered : null,
                  onFocusChange: enabled ? _setFocused : null,
                  onHighlightChanged: enabled ? _setPressed : null,
                  customBorder: RoundedRectangleBorder(
                    borderRadius: contentRadius,
                  ),
                  splashColor: textColor.withValues(
                    alpha: buttons.pressedOverlayAlpha + 0.06,
                  ),
                  hoverColor: textColor.withValues(
                    alpha: buttons.hoverOverlayAlpha,
                  ),
                  highlightColor: textColor.withValues(
                    alpha: buttons.pressedOverlayAlpha,
                  ),
                  child: Padding(
                    padding: spec.padding,
                    child: SizedBox.expand(
                      child: Align(
                        alignment: Alignment.center,
                        child: Text(
                          widget.label,
                          maxLines: 1,
                          overflow: TextOverflow.ellipsis,
                          textAlign: TextAlign.center,
                          textWidthBasis: TextWidthBasis.parent,
                          style: textStyle,
                          strutStyle: textStrutStyle,
                        ),
                      ),
                    ),
                  ),
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }
}


===== FILE: lib/ui/components/app_icon_button.dart =====
import 'package:flutter/material.dart';

export '../theme/ui_icon_button_theme.dart'
    show AppIconButtonSize, AppIconButtonVariant;

import '../theme/ui_icon_button_theme.dart';
import '../theme/ui_tokens.dart';

class AppIconButton extends StatelessWidget {
  const AppIconButton({
    super.key,
    required this.icon,
    required this.onPressed,
    this.label,
    this.tooltip,
    this.variant = AppIconButtonVariant.primary,
    this.size = AppIconButtonSize.md,
  }) : assert(
         label != null || tooltip != null,
         'Provide a label or tooltip for accessibility.',
       );

  final IconData icon;
  final VoidCallback? onPressed;
  final String? label;
  final String? tooltip;
  final AppIconButtonVariant variant;
  final AppIconButtonSize size;

  @override
  Widget build(BuildContext context) {
    final ui = context.ui;
    final theme = context.iconButtons;
    final spec = theme.resolveSpec(ui: ui, variant: variant, size: size);
    final enabled = onPressed != null;

    final iconButton = IconButton(
      onPressed: onPressed,
      icon: Icon(icon),
      iconSize: spec.iconSize,
      color: spec.iconColor,
      disabledColor: spec.disabledIconColor,
      tooltip: tooltip ?? label,
      padding: EdgeInsets.zero,
      constraints: spec.constraints,
    );

    if (label == null) return iconButton;

    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        iconButton,
        SizedBox(height: spec.labelSpacing),
        Text(
          label!,
          style: enabled ? spec.labelStyle : spec.disabledLabelStyle,
          textAlign: TextAlign.center,
          maxLines: 1,
          overflow: TextOverflow.ellipsis,
        ),
      ],
    );
  }
}


===== FILE: lib/ui/components/app_inline_edit_text.dart =====
import 'package:flutter/material.dart';

import '../theme/ui_inline_edit_text_theme.dart';
import '../theme/ui_tokens.dart';
import 'app_inline_icon_button.dart';

class AppInlineEditText extends StatefulWidget {
  const AppInlineEditText({
    super.key,
    required this.text,
    required this.displayText,
    required this.hintText,
    required this.onCommit,
    this.enabled = true,
    this.validator,
    this.keyboardType,
    this.textCapitalization = TextCapitalization.none,
    this.maxLength,
  });

  final String text;
  final String displayText;
  final String hintText;
  final bool enabled;

  final String? Function(String value)? validator;
  final Future<void> Function(String value) onCommit;

  final TextInputType? keyboardType;
  final TextCapitalization textCapitalization;
  final int? maxLength;

  @override
  State<AppInlineEditText> createState() => _AppInlineEditTextState();
}

class _AppInlineEditTextState extends State<AppInlineEditText> {
  late final TextEditingController _controller;
  final FocusNode _focusNode = FocusNode();

  bool _editing = false;
  bool _saving = false;
  String? _error;

  @override
  void initState() {
    super.initState();
    _controller = TextEditingController(text: widget.text);
  }

  @override
  void didUpdateWidget(covariant AppInlineEditText oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (_editing) return;
    if (oldWidget.text != widget.text && _controller.text != widget.text) {
      _controller.text = widget.text;
    }
  }

  @override
  void dispose() {
    _focusNode.dispose();
    _controller.dispose();
    super.dispose();
  }

  void _startEditing() {
    if (!widget.enabled) return;
    setState(() {
      _editing = true;
      _error = null;
      _controller.text = widget.text;
    });
    _focusNode.requestFocus();
  }

  void _cancelEditing() {
    if (_saving) return;
    _focusNode.unfocus();
    setState(() {
      _editing = false;
      _error = null;
      _controller.text = widget.text;
    });
  }

  Future<void> _commit() async {
    if (_saving) return;
    if (!widget.enabled) return;

    final raw = _controller.text.trim();
    final err = widget.validator?.call(raw);
    if (err != null) {
      setState(() => _error = err);
      return;
    }

    setState(() {
      _saving = true;
      _error = null;
    });

    try {
      await widget.onCommit(raw);
      if (!mounted) return;
      _focusNode.unfocus();
      setState(() {
        _saving = false;
        _editing = false;
      });
    } catch (_) {
      if (!mounted) return;
      setState(() {
        _saving = false;
        _error = 'Something went wrong.';
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final ui = context.ui;
    final spec = context.inlineEditText.resolveSpec(ui: ui);

    if (!_editing) {
      return Row(
        children: [
          Expanded(
            child: Text(
              widget.displayText,
              style: spec.valueStyle,
              overflow: TextOverflow.ellipsis,
            ),
          ),
          AppInlineIconButton(
            icon: Icons.edit,
            tooltip: 'Edit',
            variant: spec.editButtonVariant,
            size: spec.editButtonSize,
            onPressed: widget.enabled ? _startEditing : null,
          ),
        ],
      );
    }

    final decoration = spec.fieldDecoration.copyWith(
      hintText: widget.hintText,
      errorText: _error,
    );

    return Row(
      children: [
        Expanded(
          child: TextField(
            controller: _controller,
            focusNode: _focusNode,
            autofocus: true,
            keyboardType: widget.keyboardType,
            textCapitalization: widget.textCapitalization,
            maxLength: widget.maxLength,
            style: spec.valueStyle,
            decoration: decoration,
            onSubmitted: (_) => _commit(),
          ),
        ),
        AppInlineIconButton(
          icon: Icons.check,
          tooltip: 'Save',
          variant: spec.saveButtonVariant,
          size: spec.actionButtonSize,
          loading: _saving,
          onPressed: _saving ? null : _commit,
        ),
        AppInlineIconButton(
          icon: Icons.close,
          tooltip: 'Cancel',
          variant: spec.cancelButtonVariant,
          size: spec.actionButtonSize,
          onPressed: _saving ? null : _cancelEditing,
        ),
      ],
    );
  }
}


===== FILE: lib/ui/components/app_inline_icon_button.dart =====
import 'package:flutter/material.dart';

export '../theme/ui_inline_icon_button_theme.dart'
    show AppInlineIconButtonSize, AppInlineIconButtonVariant;

import '../theme/ui_inline_icon_button_theme.dart';
import '../theme/ui_tokens.dart';

class AppInlineIconButton extends StatelessWidget {
  const AppInlineIconButton({
    super.key,
    required this.icon,
    required this.tooltip,
    required this.onPressed,
    this.variant = AppInlineIconButtonVariant.discrete,
    this.size = AppInlineIconButtonSize.sm,
    this.loading = false,
  });

  final IconData icon;
  final String tooltip;
  final VoidCallback? onPressed;
  final AppInlineIconButtonVariant variant;
  final AppInlineIconButtonSize size;
  final bool loading;

  @override
  Widget build(BuildContext context) {
    final ui = context.ui;
    final theme = context.inlineIconButtons;
    final spec = theme.resolveSpec(ui: ui, variant: variant, size: size);

    final effectiveOnPressed = loading ? null : onPressed;

    final Widget iconWidget = loading
        ? SizedBox(
            width: spec.spinnerSize,
            height: spec.spinnerSize,
            child: CircularProgressIndicator(
              strokeWidth: spec.spinnerStrokeWidth,
              color: spec.spinnerColor,
            ),
          )
        : Icon(icon);

    return IconButton(
      onPressed: effectiveOnPressed,
      icon: iconWidget,
      iconSize: spec.iconSize,
      color: spec.iconColor,
      disabledColor: spec.disabledColor,
      tooltip: tooltip,
      padding: spec.padding,
      constraints: spec.constraints,
    );
  }
}


===== FILE: lib/ui/components/app_segmented_control.dart =====
import 'package:flutter/material.dart';

export '../theme/ui_segmented_control_theme.dart' show AppSegmentedControlSize;

import '../theme/ui_segmented_control_theme.dart';
import '../theme/ui_tokens.dart';

class AppSegmentedControl<T> extends StatelessWidget {
  const AppSegmentedControl({
    super.key,
    required this.values,
    required this.selected,
    required this.onChanged,
    required this.labelBuilder,
    this.enabled = true,
    this.size = AppSegmentedControlSize.md,
  });

  final List<T> values;
  final T selected;
  final ValueChanged<T> onChanged;
  final Widget Function(BuildContext context, T value) labelBuilder;
  final bool enabled;
  final AppSegmentedControlSize size;

  @override
  Widget build(BuildContext context) {
    assert(values.isNotEmpty, 'Provide at least one segment value.');

    final ui = context.ui;
    final theme = context.segmentedControls;
    final spec = theme.resolveSpec(ui: ui, size: size);

    final radius = BorderRadius.circular(spec.radius);
    final borderWidth = ui.sizes.borderWidth;
    final borderColor = enabled
        ? theme.border
        : theme.border.withValues(alpha: theme.disabledAlpha);

    final style = ButtonStyle(
      alignment: Alignment.center,
      backgroundColor: WidgetStateProperty.resolveWith((states) {
        final isDisabled = states.contains(WidgetState.disabled);
        final isSelected = states.contains(WidgetState.selected);
        final base = isSelected ? theme.selectedBackground : theme.background;
        return isDisabled ? base.withValues(alpha: theme.disabledAlpha) : base;
      }),
      foregroundColor: WidgetStateProperty.resolveWith((states) {
        final isDisabled = states.contains(WidgetState.disabled);
        final isSelected = states.contains(WidgetState.selected);
        final base = isSelected ? theme.selectedForeground : theme.foreground;
        return isDisabled ? base.withValues(alpha: theme.disabledAlpha) : base;
      }),
      overlayColor: WidgetStateProperty.resolveWith((states) {
        if (states.contains(WidgetState.pressed)) {
          return theme.foreground.withValues(alpha: theme.pressedOverlayAlpha);
        }
        if (states.contains(WidgetState.hovered)) {
          return theme.foreground.withValues(alpha: theme.hoverOverlayAlpha);
        }
        return null;
      }),
      // We draw the border around the whole control instead of per-segment
      // outlines, which can produce subtle visual artifacts on some devices.
      side: WidgetStateProperty.all(BorderSide.none),
      shape: WidgetStateProperty.all(
        RoundedRectangleBorder(borderRadius: radius),
      ),
      padding: WidgetStateProperty.all(spec.padding),
      textStyle: WidgetStateProperty.all(spec.textStyle),
      minimumSize: WidgetStateProperty.all(
        Size(ui.sizes.tapTarget, spec.height),
      ),
      tapTargetSize: MaterialTapTargetSize.shrinkWrap,
    );

    final segments = <ButtonSegment<T>>[
      for (final value in values)
        ButtonSegment<T>(
          value: value,
          label: Center(child: labelBuilder(context, value)),
        ),
    ];

    return DecoratedBox(
      decoration: BoxDecoration(
        borderRadius: radius,
        border: Border.all(color: borderColor, width: borderWidth),
      ),
      child: ClipRRect(
        borderRadius: radius,
        child: SegmentedButton<T>(
          segments: segments,
          selected: {selected},
          showSelectedIcon: spec.showSelectedIcon,
          style: style,
          onSelectionChanged: enabled
              ? (selection) {
                  if (selection.isEmpty) return;
                  onChanged(selection.first);
                }
              : null,
        ),
      ),
    );
  }
}


===== FILE: lib/ui/components/gear_icon.dart =====
import 'package:flutter/material.dart';

import '../../core/accessories/accessory_id.dart';
import '../../core/meta/gear_slot.dart';
import '../../core/projectiles/projectile_id.dart';
import '../../core/spellBook/spell_book_id.dart';
import '../../core/weapons/weapon_id.dart';
import '../icons/throwing_weapon_asset.dart';
import '../icons/ui_icon_coords.dart';
import '../icons/ui_icon_tile.dart';

/// Shared gear icon renderer for loadout screens and gear picker UI.
///
/// The [id] type depends on [slot]:
/// - main/offhand -> [WeaponId]
/// - throwing -> [ProjectileId]
/// - spellbook -> [SpellBookId]
/// - accessory -> [AccessoryId]
class GearIcon extends StatelessWidget {
  const GearIcon({
    super.key,
    required this.slot,
    required this.id,
    this.size = 40,
  });

  final GearSlot slot;
  final Object id;
  final double size;

  @override
  Widget build(BuildContext context) {
    Widget child;
    switch (slot) {
      case GearSlot.mainWeapon:
      case GearSlot.offhandWeapon:
        final weaponId = id as WeaponId;
        final coords = uiIconCoordsForWeapon(weaponId);
        child = coords == null
            ? const SizedBox.shrink()
            : UiIconTile(coords: coords, size: size);
        break;
      case GearSlot.spellBook:
        final bookId = id as SpellBookId;
        final coords = uiIconCoordsForSpellBook(bookId);
        child = coords == null
            ? const SizedBox.shrink()
            : UiIconTile(coords: coords, size: size);
        break;
      case GearSlot.accessory:
        final accessoryId = id as AccessoryId;
        final coords = uiIconCoordsForAccessory(accessoryId);
        child = coords == null
            ? const SizedBox.shrink()
            : UiIconTile(coords: coords, size: size);
        break;
      case GearSlot.throwingWeapon:
        final itemId = id as ProjectileId;
        final path = throwingWeaponAssetPath(itemId);
        child = path == null
            ? const SizedBox.shrink()
            : Image.asset(path, width: size, height: size);
        break;
    }

    return SizedBox.square(dimension: size, child: child);
  }
}


===== FILE: lib/ui/components/leaderboard_table.dart =====
import 'package:flutter/material.dart';

import '../leaderboard/run_result.dart';
import '../theme/ui_leaderboard_theme.dart';
import '../theme/ui_tokens.dart';

class LeaderboardTable extends StatelessWidget {
  const LeaderboardTable({
    super.key,
    required this.entries,
    this.highlightRunId,
    this.hideScoreForRunId,
    this.showHeader = true,
    this.inset = true,
    this.scrollable = false,
  });

  final List<RunResult> entries;
  final int? highlightRunId;
  final int? hideScoreForRunId;
  final bool showHeader;
  final bool inset;
  final bool scrollable;

  @override
  Widget build(BuildContext context) {
    final ui = context.ui;
    final spec = context.leaderboards.resolveSpec(ui: ui);

    final children = <Widget>[];
    if (showHeader) {
      children.add(_LeaderboardHeaderRow(spec: spec));
      if (spec.headerGap > 0) {
        children.add(SizedBox(height: spec.headerGap));
      }
    }

    for (var i = 0; i < entries.length; i += 1) {
      final entry = entries[i];
      final rank = i + 1;
      children.add(
        _LeaderboardRow(
          spec: spec,
          rank: rank,
          entry: entry,
          highlight: highlightRunId != null && entry.runId == highlightRunId,
          hideScore:
              hideScoreForRunId != null && entry.runId == hideScoreForRunId,
        ),
      );
      if (i < entries.length - 1) {
        if (spec.rowGap > 0) {
          children.add(SizedBox(height: spec.rowGap));
        }
      }
    }

    final padding = inset ? spec.tablePadding : EdgeInsets.zero;
    final table = Padding(
      padding: padding,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: children,
      ),
    );

    if (!scrollable) return table;
    return SingleChildScrollView(child: table);
  }
}

class _LeaderboardHeaderRow extends StatelessWidget {
  const _LeaderboardHeaderRow({required this.spec});

  final UiLeaderboardSpec spec;

  @override
  Widget build(BuildContext context) {
    final style = spec.headerTextStyle;

    Widget cell(String text, UiLeaderboardColumn column, TextAlign align) {
      return _LeaderboardColumnCell(
        column: column,
        child: Text(text, style: style, textAlign: align),
      );
    }

    final row = Row(
      children: [
        cell('#Rank', spec.columns.rank, TextAlign.left),
        cell('Score', spec.columns.score, TextAlign.right),
        cell('Distance', spec.columns.distance, TextAlign.right),
        cell('Time', spec.columns.time, TextAlign.right),
      ],
    );

    return SizedBox(
      height: spec.headerHeight,
      child: Center(child: row),
    );
  }
}

class _LeaderboardRow extends StatelessWidget {
  const _LeaderboardRow({
    required this.spec,
    required this.rank,
    required this.entry,
    required this.highlight,
    required this.hideScore,
  });

  final UiLeaderboardSpec spec;
  final int rank;
  final RunResult entry;
  final bool highlight;
  final bool hideScore;

  @override
  Widget build(BuildContext context) {
    final textColor = highlight
        ? spec.highlightTextColor
        : spec.rowTextStyle.color;
    final style = spec.rowTextStyle.copyWith(color: textColor);

    final decoration = BoxDecoration(
      color: highlight ? spec.highlightBackground : spec.rowBackground,
      borderRadius: BorderRadius.circular(spec.rowRadius),
      border: Border.all(
        color: highlight ? spec.highlightBorderColor : spec.rowBorderColor,
        width: spec.rowBorderWidth,
      ),
    );

    final row = Row(
      children: [
        _LeaderboardColumnCell(
          column: spec.columns.rank,
          child: Text('#$rank', style: style),
        ),
        _LeaderboardColumnCell(
          column: spec.columns.score,
          child: Text(
            hideScore ? '—' : entry.score.toString(),
            style: style,
            textAlign: TextAlign.right,
          ),
        ),
        _LeaderboardColumnCell(
          column: spec.columns.distance,
          child: Text(
            '${entry.distanceMeters}m',
            style: style,
            textAlign: TextAlign.right,
          ),
        ),
        _LeaderboardColumnCell(
          column: spec.columns.time,
          child: Text(
            _formatTime(entry.durationSeconds),
            style: style,
            textAlign: TextAlign.right,
          ),
        ),
      ],
    );

    final padded = Padding(padding: spec.rowPadding, child: row);
    final body = SizedBox(
      height: spec.rowHeight,
      child: Center(child: padded),
    );

    return DecoratedBox(decoration: decoration, child: body);
  }
}

String _formatTime(int totalSeconds) {
  final minutes = totalSeconds ~/ 60;
  final seconds = totalSeconds % 60;
  return '${minutes.toString().padLeft(2, '0')}:${seconds.toString().padLeft(2, '0')}';
}

class _LeaderboardColumnCell extends StatelessWidget {
  const _LeaderboardColumnCell({required this.column, required this.child});

  final UiLeaderboardColumn column;
  final Widget child;

  @override
  Widget build(BuildContext context) {
    final width = column.width;
    if (width != null) return SizedBox(width: width, child: child);
    return Expanded(flex: column.flex, child: child);
  }
}


===== FILE: lib/ui/components/level_parallax_preview.dart =====
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

import '../assets/ui_asset_lifecycle.dart';
import '../theme/ui_tokens.dart';

/// Static (non-scrolling) parallax preview for menu cards.
///
/// - Uses UiAssetLifecycle for theme → layers caching.
/// - Precaches per widget lifetime to avoid first-frame hitch.
/// - Never crashes the UI if a layer asset is missing.
class LevelParallaxPreview extends StatefulWidget {
  const LevelParallaxPreview({
    super.key,
    required this.themeId,
    this.baseColor = UiBrandPalette.baseBackground,
    this.alignment = Alignment.bottomCenter,
    this.filterQuality = FilterQuality.none,
  });

  final String? themeId;

  /// Fill behind transparent pixels in layers.
  /// Important because MenuScaffold background is black.
  final Color baseColor;

  final AlignmentGeometry alignment;
  final FilterQuality filterQuality;

  @override
  State<LevelParallaxPreview> createState() => _LevelParallaxPreviewState();
}

class _LevelParallaxPreviewState extends State<LevelParallaxPreview> {
  String? _cacheKey;
  List<AssetImage> _layers = const <AssetImage>[];
  bool _precached = false;

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    _refreshLayers();
  }

  @override
  void didUpdateWidget(LevelParallaxPreview oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.themeId != widget.themeId) {
      _refreshLayers();
    }
  }

  void _refreshLayers() {
    final key = widget.themeId ?? '__null__';
    if (_cacheKey == key && _layers.isNotEmpty) return;

    _cacheKey = key;
    _precached = false;

    final lifecycle = context.read<UiAssetLifecycle>();
    lifecycle
        .getParallaxLayers(widget.themeId)
        .then((layers) {
          if (!mounted || _cacheKey != key) return;
          setState(() => _layers = layers);
          _schedulePrecache(layers);
        })
        .catchError((_) {
          // Best-effort preview; ignore missing assets.
        });
  }

  void _schedulePrecache(List<AssetImage> layers) {
    if (_precached) return;
    _precached = true;
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (!mounted) return;
      unawaited(
        context.read<UiAssetLifecycle>().precacheParallaxLayers(
          layers,
          context,
        ),
      );
    });
  }

  @override
  Widget build(BuildContext context) {
    final overlayColor = context.ui.colors.shadow.withValues(alpha: 0.4);
    return RepaintBoundary(
      child: Stack(
        fit: StackFit.expand,
        children: [
          ColoredBox(color: widget.baseColor),

          for (final provider in _layers)
            Positioned.fill(
              child: Image(
                image: provider,
                fit: BoxFit.cover,
                alignment: widget.alignment,
                filterQuality: widget.filterQuality,
                errorBuilder: (context, error, stackTrace) {
                  // If one layer is missing, just skip it visually.
                  return const SizedBox.shrink();
                },
              ),
            ),

          // Hardcoded tint overlay to improve text readability on top of previews.
          Positioned.fill(child: ColoredBox(color: overlayColor)),
        ],
      ),
    );
  }
}


===== FILE: lib/ui/components/menu_layout.dart =====
import 'dart:math' as math;

import 'package:flutter/material.dart';

class MenuLayout extends StatelessWidget {
  const MenuLayout({
    super.key,
    required this.child,
    this.maxWidth = 1100,
    this.horizontalPadding = 24,
    this.verticalPadding = 6,
    this.scrollable = true,
    this.alignment = Alignment.topCenter,
  });

  final Widget child;
  final double maxWidth;
  final double horizontalPadding;
  final double verticalPadding;
  final bool scrollable;
  final Alignment alignment;

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        final padding = EdgeInsets.symmetric(
          horizontal: horizontalPadding,
          vertical: verticalPadding,
        );
        final availableWidth = math.max(
          0.0,
          constraints.maxWidth - padding.horizontal,
        );
        final width = math.min(availableWidth, maxWidth);

        final aligned = Align(
          alignment: alignment,
          child: Padding(
            padding: padding,
            child: ConstrainedBox(
              constraints: BoxConstraints(maxWidth: width),
              child: child,
            ),
          ),
        );

        if (!scrollable) {
          return aligned;
        }

        final minHeight = math.max(
          0.0,
          constraints.maxHeight - padding.vertical,
        );

        return SingleChildScrollView(
          child: ConstrainedBox(
            constraints: BoxConstraints(minHeight: minHeight),
            child: aligned,
          ),
        );
      },
    );
  }
}


===== FILE: lib/ui/components/menu_scaffold.dart =====
import 'package:flutter/material.dart';

import '../theme/ui_tokens.dart';

/// A scaffold wrapper for menu pages with consistent theme-token styling.
///
/// Handles:
/// - Brand background
/// - Optional AppBar with back button
/// - SafeArea (top/bottom) for content
///
/// Use this for all menu pages to maintain consistency and DRY principles.
class MenuScaffold extends StatelessWidget {
  const MenuScaffold({
    super.key,
    required this.child,
    this.title,
    this.appBarTitle,
    this.centerAppBarTitle = false,
    this.showAppBar = true,
  });

  /// The main content of the page.
  final Widget child;

  /// Optional title for the AppBar. If null, no title is shown.
  final String? title;

  /// Optional custom title widget for the AppBar (e.g. a segmented control).
  ///
  /// If provided, this takes precedence over [title].
  final Widget? appBarTitle;

  /// Whether the AppBar title should be centered.
  ///
  /// Useful when [appBarTitle] is a compact widget (e.g. segmented control)
  /// that should be visually centered in the toolbar.
  final bool centerAppBarTitle;

  /// Whether to show the AppBar with back button. Defaults to true.
  final bool showAppBar;

  @override
  Widget build(BuildContext context) {
    final ui = context.ui;
    final topPadding = MediaQuery.paddingOf(context).top;
    final resolvedTitle =
        appBarTitle ??
        (title != null
            ? Text(
                title!,
                style: ui.text.title.copyWith(
                  color: ui.colors.textPrimary,
                  fontSize: 20,
                  fontWeight: FontWeight.w600,
                ),
              )
            : null);
    final appBarWidget = AppBar(
      title: resolvedTitle,
      backgroundColor: ui.colors.background,
      iconTheme: IconThemeData(color: ui.colors.textPrimary),
      // We'll apply our own SafeArea so we can ignore transient horizontal
      // insets (e.g. Android nav bar) that can cause jitter.
      primary: false,
      centerTitle: centerAppBarTitle,
      titleSpacing: appBarTitle != null ? 0 : null,
    );

    return Scaffold(
      backgroundColor: ui.colors.background,
      appBar: showAppBar
          ? PreferredSize(
              preferredSize: Size.fromHeight(
                topPadding + appBarWidget.preferredSize.height,
              ),
              child: SafeArea(
                left: false,
                right: false,
                bottom: false,
                child: appBarWidget,
              ),
            )
          : null,
      // Avoid horizontal "layout jitter" when transient system UI (e.g. the
      // Android navigation bar) briefly appears/disappears during keyboard and
      // focus transitions. Menu content already applies its own horizontal
      // padding via MenuLayout, and most menu pages are safe to treat as
      // horizontally full-bleed.
      body: SafeArea(
        left: false,
        right: false,
        maintainBottomViewPadding: true,
        child: child,
      ),
    );
  }
}


===== FILE: lib/ui/components/placeholder_page.dart =====
import 'package:flutter/material.dart';

import 'menu_layout.dart';
import 'menu_scaffold.dart';
import '../theme/ui_tokens.dart';

/// A reusable placeholder page for features not yet implemented.
///
/// Displays the page title and "Coming Soon" text with consistent styling.
/// Use this for any menu pages that are placeholders for future features.
class PlaceholderPage extends StatelessWidget {
  const PlaceholderPage({
    super.key,
    required this.title,
    this.message = 'Coming Soon',
  });

  /// The title shown in the AppBar.
  final String title;

  /// The placeholder message shown in the center. Defaults to "Coming Soon".
  final String message;

  @override
  Widget build(BuildContext context) {
    final ui = context.ui;
    return MenuScaffold(
      title: title,
      child: MenuLayout(
        alignment: Alignment.center,
        scrollable: false,
        child: Text(
          message,
          style: ui.text.title.copyWith(color: ui.colors.textMuted),
        ),
      ),
    );
  }
}


===== FILE: lib/ui/components/player_idle_preview.dart =====
import 'package:flame/widgets.dart';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

import '../../core/players/player_character_definition.dart';
import '../assets/ui_asset_lifecycle.dart';

/// Lightweight UI preview for a character's idle animation.
///
/// Caches animation loads per character to avoid asset churn in menus.
class PlayerIdlePreview extends StatelessWidget {
  const PlayerIdlePreview({
    super.key,
    required this.characterId,
    this.size = 88,
  });

  final PlayerCharacterId characterId;
  final double size;

  static final Paint _paint = Paint()..filterQuality = FilterQuality.none;

  @override
  Widget build(BuildContext context) {
    final lifecycle = context.read<UiAssetLifecycle>();
    final future = lifecycle.getIdle(characterId);

    return SizedBox(
      width: size,
      height: size,
      child: FutureBuilder<IdleAnimBundle>(
        future: future,
        builder: (context, snapshot) {
          if (snapshot.connectionState != ConnectionState.done) {
            return _buildPlaceholder();
          }
          final data = snapshot.data;
          if (data == null || snapshot.hasError) {
            return _buildPlaceholder();
          }

          return RepaintBoundary(
            child: Transform.scale(
              scaleX: -1,
              alignment: Alignment.center,
              child: SpriteAnimationWidget(
                animation: data.animation,
                animationTicker: data.animation.createTicker(),
                anchor: data.anchor,
                paint: _paint,
              ),
            ),
          );
        },
      ),
    );
  }

  Widget _buildPlaceholder() {
    return Container(
      alignment: Alignment.center,
      decoration: BoxDecoration(
        color: const Color(0x22000000),
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: Colors.white24),
      ),
      child: const Icon(Icons.person, color: Colors.white24, size: 20),
    );
  }
}


===== FILE: lib/ui/components/weekly_badge_row.dart =====
import 'package:flutter/material.dart';

import 'app_button.dart';
import '../theme/ui_tokens.dart';

class WeeklyBadgeRow extends StatelessWidget {
  const WeeklyBadgeRow({
    super.key,
    required this.onWeeklyPressed,
    required this.onWeeklyLeaderboardPressed,
  });

  final VoidCallback? onWeeklyPressed;
  final VoidCallback onWeeklyLeaderboardPressed;

  @override
  Widget build(BuildContext context) {
    final ui = context.ui;
    return Container(
      padding: EdgeInsets.symmetric(
        horizontal: ui.space.xs,
        vertical: ui.space.xs,
      ),
      decoration: BoxDecoration(
        border: Border.all(
          color: ui.colors.outline,
          width: ui.sizes.borderWidth,
        ),
        borderRadius: BorderRadius.circular(ui.radii.md),
      ),
      child: Row(
        children: [
          Expanded(
            child: Text('Weekly Challenge · Coming Soon', style: ui.text.body),
          ),
          AppButton(
            label: 'PLAY',
            size: AppButtonSize.xxs,
            onPressed: onWeeklyPressed,
          ),
          SizedBox(width: ui.space.xs),
          AppButton(
            label: 'Leaderboard',
            size: AppButtonSize.sm,
            onPressed: onWeeklyLeaderboardPressed,
          ),
        ],
      ),
    );
  }
}


===== FILE: lib/ui/controls/ability_slot_visual_spec.dart =====
import 'package:flutter/material.dart';

import '../../core/abilities/ability_def.dart';
import 'layout/controls_radial_layout.dart';

/// Visual family used to resolve slot button size/tuning.
enum AbilityRadialSlotFamily { action, directional, jump }

/// Anchor identifier in the radial HUD layout.
enum AbilityRadialAnchor { jump, dash, melee, secondary, projectile, spell }

/// Shared slot metadata consumed by both run HUD and loadout radial preview.
@immutable
class AbilityRadialSlotSpec {
  const AbilityRadialSlotSpec({
    required this.slot,
    required this.label,
    required this.icon,
    required this.anchor,
    required this.family,
  });

  final AbilitySlot slot;
  final String label;
  final IconData icon;
  final AbilityRadialAnchor anchor;
  final AbilityRadialSlotFamily family;
}

/// Single source of truth for ability radial slots.
@immutable
class AbilityRadialLayoutSpec {
  const AbilityRadialLayoutSpec({
    required this.slots,
    required this.selectionOrder,
  });

  final List<AbilityRadialSlotSpec> slots;

  /// Slot order used by the loadout radial preview.
  final List<AbilitySlot> selectionOrder;

  AbilityRadialSlotSpec slotSpec(AbilitySlot slot) {
    for (final spec in slots) {
      if (spec.slot == slot) return spec;
    }
    throw StateError('No AbilityRadialSlotSpec found for slot: $slot');
  }

  ControlsAnchor anchorFor({
    required ControlsRadialLayout layout,
    required AbilitySlot slot,
  }) {
    final spec = slotSpec(slot);
    switch (spec.anchor) {
      case AbilityRadialAnchor.jump:
        return layout.jump;
      case AbilityRadialAnchor.dash:
        return layout.dash;
      case AbilityRadialAnchor.melee:
        return layout.melee;
      case AbilityRadialAnchor.secondary:
        return layout.secondary;
      case AbilityRadialAnchor.projectile:
        return layout.projectile;
      case AbilityRadialAnchor.spell:
        return layout.spell;
    }
  }

  double sizeFor({
    required ControlsRadialLayout layout,
    required AbilitySlot slot,
    AbilityRadialSlotFamily? familyOverride,
  }) {
    final family = familyOverride ?? slotSpec(slot).family;
    return sizeForFamily(layout: layout, family: family);
  }

  double sizeForFamily({
    required ControlsRadialLayout layout,
    required AbilityRadialSlotFamily family,
  }) {
    switch (family) {
      case AbilityRadialSlotFamily.action:
        return layout.actionSize;
      case AbilityRadialSlotFamily.directional:
        return layout.directionalSize;
      case AbilityRadialSlotFamily.jump:
        return layout.jumpSize;
    }
  }
}

const AbilityRadialLayoutSpec abilityRadialLayoutSpec = AbilityRadialLayoutSpec(
  slots: <AbilityRadialSlotSpec>[
    AbilityRadialSlotSpec(
      slot: AbilitySlot.primary,
      label: 'Sword',
      icon: Icons.sports_martial_arts_rounded,
      anchor: AbilityRadialAnchor.melee,
      family: AbilityRadialSlotFamily.directional,
    ),
    AbilityRadialSlotSpec(
      slot: AbilitySlot.secondary,
      label: 'Shield',
      icon: Icons.shield,
      anchor: AbilityRadialAnchor.secondary,
      family: AbilityRadialSlotFamily.action,
    ),
    AbilityRadialSlotSpec(
      slot: AbilitySlot.projectile,
      label: 'Projectile',
      icon: Icons.auto_awesome,
      anchor: AbilityRadialAnchor.projectile,
      family: AbilityRadialSlotFamily.directional,
    ),
    AbilityRadialSlotSpec(
      slot: AbilitySlot.mobility,
      label: 'Mobility',
      icon: Icons.flash_on,
      anchor: AbilityRadialAnchor.dash,
      family: AbilityRadialSlotFamily.action,
    ),
    AbilityRadialSlotSpec(
      slot: AbilitySlot.jump,
      label: 'Jump',
      icon: Icons.arrow_upward,
      anchor: AbilityRadialAnchor.jump,
      family: AbilityRadialSlotFamily.jump,
    ),
    AbilityRadialSlotSpec(
      slot: AbilitySlot.spell,
      label: 'Spell',
      icon: Icons.star,
      anchor: AbilityRadialAnchor.spell,
      family: AbilityRadialSlotFamily.action,
    ),
  ],
  selectionOrder: <AbilitySlot>[
    AbilitySlot.jump,
    AbilitySlot.mobility,
    AbilitySlot.primary,
    AbilitySlot.secondary,
    AbilitySlot.projectile,
    AbilitySlot.spell,
  ],
);


===== FILE: lib/ui/controls/action_button.dart =====
import 'package:flutter/material.dart';

import 'control_button_visuals.dart';
import 'controls_tuning.dart';

/// Circular tap action control used by the combat HUD.
///
/// The button fires on pointer-down (`onTapDown`) for low-latency response and
/// is interactable only when `affordable` and not on cooldown.
class ActionButton extends StatelessWidget {
  const ActionButton({
    super.key,
    required this.label,
    required this.icon,
    required this.onPressed,
    required this.tuning,
    required this.size,
    required this.cooldownRing,
    this.affordable = true,
    this.cooldownTicksLeft = 0,
    this.cooldownTicksTotal = 0,
  });

  final String label;
  final IconData icon;
  final VoidCallback onPressed;
  final ActionButtonTuning tuning;
  final CooldownRingTuning cooldownRing;
  final bool affordable;
  final int cooldownTicksLeft;
  final int cooldownTicksTotal;
  final double size;

  @override
  Widget build(BuildContext context) {
    final visual = ControlButtonVisualState.resolve(
      affordable: affordable,
      cooldownTicksLeft: cooldownTicksLeft,
      backgroundColor: tuning.backgroundColor,
      foregroundColor: tuning.foregroundColor,
    );

    return ControlButtonShell(
      size: size,
      cooldownTicksLeft: cooldownTicksLeft,
      cooldownTicksTotal: cooldownTicksTotal,
      cooldownRing: cooldownRing,
      child: Material(
        color: visual.backgroundColor,
        shape: const CircleBorder(),
        child: InkWell(
          customBorder: const CircleBorder(),
          onTapDown: visual.interactable ? (_) => onPressed() : null,
          onTap: null,
          child: ControlButtonContent(
            label: label,
            icon: icon,
            foregroundColor: visual.foregroundColor,
            labelFontSize: tuning.labelFontSize,
            labelGap: tuning.labelGap,
          ),
        ),
      ),
    );
  }
}


===== FILE: lib/ui/controls/control_button_visuals.dart =====
import 'package:flutter/material.dart';

import 'cooldown_ring.dart';
import 'controls_tuning.dart';

/// Resolved visual state for a control button.
///
/// Buttons are interactable only when affordable and not on cooldown.
@immutable
class ControlButtonVisualState {
  const ControlButtonVisualState._({
    required this.interactable,
    required this.backgroundColor,
    required this.foregroundColor,
  });

  factory ControlButtonVisualState.resolve({
    required bool affordable,
    required int cooldownTicksLeft,
    required Color backgroundColor,
    required Color foregroundColor,
  }) {
    return ControlButtonVisualState._(
      interactable: affordable && cooldownTicksLeft <= 0,
      backgroundColor: affordable
          ? backgroundColor
          : _disabledBackground(backgroundColor),
      foregroundColor: affordable
          ? foregroundColor
          : _disabledForeground(foregroundColor),
    );
  }

  final bool interactable;
  final Color backgroundColor;
  final Color foregroundColor;
}

/// Shared circular shell used by action controls.
///
/// This keeps cooldown ring rendering consistent for tap and directional
/// controls.
/// `cooldownTicksLeft`/`cooldownTicksTotal` are simulation ticks.
class ControlButtonShell extends StatelessWidget {
  const ControlButtonShell({
    super.key,
    required this.size,
    required this.cooldownTicksLeft,
    required this.cooldownTicksTotal,
    required this.cooldownRing,
    required this.child,
  });

  final double size;
  final int cooldownTicksLeft;
  final int cooldownTicksTotal;
  final CooldownRingTuning cooldownRing;
  final Widget child;

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      width: size,
      height: size,
      child: Stack(
        fit: StackFit.expand,
        children: [
          child,
          IgnorePointer(
            child: CooldownRing(
              cooldownTicksLeft: cooldownTicksLeft,
              cooldownTicksTotal: cooldownTicksTotal,
              tuning: cooldownRing,
            ),
          ),
        ],
      ),
    );
  }
}

/// Shared icon + label content for circular control buttons.
class ControlButtonContent extends StatelessWidget {
  const ControlButtonContent({
    super.key,
    required this.label,
    required this.icon,
    required this.foregroundColor,
    required this.labelFontSize,
    required this.labelGap,
  });

  final String label;
  final IconData icon;
  final Color foregroundColor;
  final double labelFontSize;
  final double labelGap;

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(icon, color: foregroundColor),
          SizedBox(height: labelGap),
          Text(
            label,
            style: TextStyle(fontSize: labelFontSize, color: foregroundColor),
          ),
        ],
      ),
    );
  }
}

Color _disabledForeground(Color color) => color.withValues(alpha: 0.35);

Color _disabledBackground(Color color) =>
    color.withValues(alpha: color.a * 0.6);


===== FILE: lib/ui/controls/controls_tuning.dart =====
import 'dart:ui';

import 'package:flutter/foundation.dart';

/// Root controls tuning bundle for HUD layout and visuals.
///
/// This object is pure UI configuration; it does not change gameplay rules.
@immutable
class ControlsTuning {
  const ControlsTuning({
    this.layout = const ControlsLayoutTuning(),
    this.style = const ControlsStyleTuning(),
    this.moveButtons = const MoveButtonsTuning(),
  });

  /// Geometry and spacing configuration.
  final ControlsLayoutTuning layout;

  /// Colors, typography, and visual control styles.
  final ControlsStyleTuning style;

  /// Move button geometry + visual tuning.
  final MoveButtonsTuning moveButtons;

  /// Baseline preset used by the run HUD.
  static const defaults = ControlsTuning();
  static const fixed = defaults;
}

/// Spatial tuning for radial control placement and scaling.
///
/// Angle values are degrees. Scale values are multiplicative factors applied to
/// base component sizes.
@immutable
class ControlsLayoutTuning {
  const ControlsLayoutTuning({
    this.edgePadding = 32,
    this.bottomEdgePadding = 16,
    this.buttonGap = 12,
    this.rowGap = 12,
    this.jumpButtonScale = 1.6,
    this.actionButtonScale = 1.0,
    this.directionalButtonScale = 1.0,
    this.directionalDeadzoneScale = 1.0,
    this.ringGapScale = 0.9,
    this.radialStartDeg = 160.0,
    this.radialStepDeg = 35.0,
    this.dashStepMultiplier = -0.4,
    this.meleeStepMultiplier = 1.0,
    this.secondaryStepMultiplier = 3.8,
    this.projectileStepMultiplier = 2.4,
    this.spellVerticalOffset = 72.0,
    this.chargeAnchorGap = 8.0,
  });

  final double edgePadding;
  final double bottomEdgePadding;
  final double buttonGap;
  final double rowGap;

  /// Scales applied to the base action/directional button dimensions.
  final double jumpButtonScale;
  final double actionButtonScale;
  final double directionalButtonScale;
  final double directionalDeadzoneScale;
  final double ringGapScale;

  /// Polar placement parameters (degrees).
  final double radialStartDeg;
  final double radialStepDeg;
  final double dashStepMultiplier;
  final double meleeStepMultiplier;
  final double secondaryStepMultiplier;
  final double projectileStepMultiplier;

  final double spellVerticalOffset;
  final double chargeAnchorGap;
}

/// Visual tuning for reusable control widgets.
@immutable
class ControlsStyleTuning {
  const ControlsStyleTuning({
    this.actionButton = const ActionButtonTuning(),
    this.directionalActionButton = const DirectionalActionButtonTuning(),
    this.cooldownRing = const CooldownRingTuning(),
    this.chargeBar = const ChargeBarTuning(),
  });

  final ActionButtonTuning actionButton;
  final DirectionalActionButtonTuning directionalActionButton;
  final CooldownRingTuning cooldownRing;
  final ChargeBarTuning chargeBar;
}

/// Geometry and paint tuning for the left/right movement pair.
@immutable
class MoveButtonsTuning {
  const MoveButtonsTuning({
    this.buttonWidth = 64,
    this.buttonHeight = 48,
    this.gap = 8,
    this.backgroundColor = const Color(0x33000000),
    this.foregroundColor = const Color(0xFFFFFFFF),
    this.borderColor = const Color(0x55FFFFFF),
    this.borderWidth = 1,
    this.borderRadius = 12,
  });

  final double buttonWidth;
  final double buttonHeight;
  final double gap;
  final Color backgroundColor;
  final Color foregroundColor;
  final Color borderColor;
  final double borderWidth;
  final double borderRadius;
}

/// Paint tuning for cooldown arcs drawn around circular buttons.
@immutable
class CooldownRingTuning {
  const CooldownRingTuning({
    this.thickness = 3,
    this.trackColor = const Color(0x66FFFFFF),
    this.progressColor = const Color(0xFFFFFFFF),
  });

  final double thickness;
  final Color trackColor;
  final Color progressColor;
}

/// Visual tuning for the hold/charge progress bar above controls.
@immutable
class ChargeBarTuning {
  const ChargeBarTuning({
    this.width = 84,
    this.height = 14,
    this.padding = 2,
    this.backgroundColor = const Color(0xAA11161D),
    this.borderColor = const Color(0xFF2C3A47),
    this.borderWidth = 1,
    this.outerRadius = 7,
    this.innerRadius = 5,
    this.idleColor = const Color(0xFF9FA8B2),
    this.halfTierColor = const Color(0xFFF0C15A),
    this.fullTierColor = const Color(0xFF6EDC8C),
  });

  final double width;
  final double height;
  final double padding;
  final Color backgroundColor;
  final Color borderColor;
  final double borderWidth;
  final double outerRadius;
  final double innerRadius;
  final Color idleColor;
  final Color halfTierColor;
  final Color fullTierColor;
}

/// Visual tuning for circular tap/hold action buttons.
@immutable
class ActionButtonTuning {
  const ActionButtonTuning({
    this.size = 52,
    this.backgroundColor = const Color(0x33000000),
    this.foregroundColor = const Color(0xFFFFFFFF),
    this.labelFontSize = 8,
    this.labelGap = 2,
  });

  final double size;
  final Color backgroundColor;
  final Color foregroundColor;
  final double labelFontSize;
  final double labelGap;
}

/// Visual tuning for directional action buttons and their deadzone radius.
@immutable
class DirectionalActionButtonTuning {
  const DirectionalActionButtonTuning({
    this.size = 52,
    this.deadzoneRadius = 12,
    this.backgroundColor = const Color(0x33000000),
    this.foregroundColor = const Color(0xFFFFFFFF),
    this.labelFontSize = 8,
    this.labelGap = 2,
  });

  final double size;
  final double deadzoneRadius;
  final Color backgroundColor;
  final Color foregroundColor;
  final double labelFontSize;
  final double labelGap;
}


===== FILE: lib/ui/controls/cooldown_ring.dart =====
import 'dart:math' as math;

import 'package:flutter/widgets.dart';

import 'controls_tuning.dart';

/// Paint-only cooldown indicator rendered around circular controls.
///
/// `cooldownTicksLeft` and `cooldownTicksTotal` are simulation ticks. Nothing
/// is painted when either value is non-positive.
class CooldownRing extends StatelessWidget {
  const CooldownRing({
    super.key,
    required this.cooldownTicksLeft,
    required this.cooldownTicksTotal,
    required this.tuning,
  });

  final int cooldownTicksLeft;
  final int cooldownTicksTotal;
  final CooldownRingTuning tuning;

  @override
  Widget build(BuildContext context) {
    if (cooldownTicksLeft <= 0 || cooldownTicksTotal <= 0) {
      return const SizedBox.shrink();
    }

    final clampedLeft = cooldownTicksLeft.clamp(0, cooldownTicksTotal);
    final elapsed = 1.0 - (clampedLeft / cooldownTicksTotal);

    return CustomPaint(
      painter: _CooldownRingPainter(
        elapsedFraction: elapsed.clamp(0.0, 1.0),
        thickness: tuning.thickness,
        trackColor: tuning.trackColor,
        progressColor: tuning.progressColor,
      ),
    );
  }
}

class _CooldownRingPainter extends CustomPainter {
  _CooldownRingPainter({
    required this.elapsedFraction,
    required this.thickness,
    required this.trackColor,
    required this.progressColor,
  });

  final double elapsedFraction;
  final double thickness;
  final Color trackColor;
  final Color progressColor;

  @override
  void paint(Canvas canvas, Size size) {
    final inset = thickness / 2;
    final rect = Rect.fromLTWH(
      inset,
      inset,
      size.width - thickness,
      size.height - thickness,
    );

    final trackPaint = Paint()
      ..color = trackColor
      ..style = PaintingStyle.stroke
      ..strokeWidth = thickness;

    final progressPaint = Paint()
      ..color = progressColor
      ..style = PaintingStyle.stroke
      ..strokeWidth = thickness
      ..strokeCap = StrokeCap.round;

    const startAngle = -math.pi / 2;
    canvas.drawArc(rect, startAngle, math.pi * 2, false, trackPaint);
    if (elapsedFraction > 0) {
      canvas.drawArc(
        rect,
        startAngle,
        math.pi * 2 * elapsedFraction,
        false,
        progressPaint,
      );
    }
  }

  @override
  bool shouldRepaint(covariant _CooldownRingPainter oldDelegate) {
    return oldDelegate.elapsedFraction != elapsedFraction ||
        oldDelegate.thickness != thickness ||
        oldDelegate.trackColor != trackColor ||
        oldDelegate.progressColor != progressColor;
  }
}


===== FILE: lib/ui/controls/directional_action_button.dart =====
import 'dart:math' as math;

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

import '../../game/input/aim_preview.dart';
import '../../game/input/aim_quantizer.dart';
import 'control_button_visuals.dart';
import 'controls_tuning.dart';

/// Circular directional action control for aim + release commit input.
///
/// Drag direction is normalized then quantized before forwarding to
/// `onAimDir`, so callers receive stable input suitable for deterministic
/// command routing.
class DirectionalActionButton extends StatefulWidget {
  const DirectionalActionButton({
    super.key,
    required this.label,
    required this.icon,
    required this.onAimDir,
    required this.onAimClear,
    required this.onCommit,
    this.onHoldStart,
    this.onHoldEnd,
    required this.projectileAimPreview,
    required this.tuning,
    required this.size,
    required this.deadzoneRadius,
    required this.cooldownRing,
    this.cancelHitboxRect,
    this.affordable = true,
    this.cooldownTicksLeft = 0,
    this.cooldownTicksTotal = 0,
    this.forceCancelSignal,
  });

  final String label;
  final IconData icon;
  final void Function(double x, double y) onAimDir;
  final VoidCallback onAimClear;
  final VoidCallback onCommit;
  final VoidCallback? onHoldStart;
  final VoidCallback? onHoldEnd;
  final AimPreviewModel projectileAimPreview;
  final DirectionalActionButtonTuning tuning;
  final CooldownRingTuning cooldownRing;
  final ValueListenable<Rect?>? cancelHitboxRect;
  final bool affordable;
  final int cooldownTicksLeft;
  final int cooldownTicksTotal;
  final double size;
  final double deadzoneRadius;
  final ValueListenable<int>? forceCancelSignal;

  @override
  State<DirectionalActionButton> createState() =>
      _DirectionalActionButtonState();
}

class _DirectionalActionButtonState extends State<DirectionalActionButton> {
  int? _pointer;
  bool _canceled = false;
  bool _holdActive = false;
  int _lastForceCancelValue = 0;

  @override
  void initState() {
    super.initState();
    _attachForceCancelListener();
  }

  @override
  void didUpdateWidget(covariant DirectionalActionButton oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.forceCancelSignal != widget.forceCancelSignal) {
      _detachForceCancelListener(oldWidget.forceCancelSignal);
      _attachForceCancelListener();
    }
  }

  @override
  Widget build(BuildContext context) {
    final visual = ControlButtonVisualState.resolve(
      affordable: widget.affordable,
      cooldownTicksLeft: widget.cooldownTicksLeft,
      backgroundColor: widget.tuning.backgroundColor,
      foregroundColor: widget.tuning.foregroundColor,
    );

    return ControlButtonShell(
      size: widget.size,
      cooldownTicksLeft: widget.cooldownTicksLeft,
      cooldownTicksTotal: widget.cooldownTicksTotal,
      cooldownRing: widget.cooldownRing,
      child: IgnorePointer(
        ignoring: !visual.interactable,
        child: Listener(
          onPointerDown: _handlePointerDown,
          onPointerMove: _handlePointerMove,
          onPointerUp: _handlePointerUp,
          onPointerCancel: _handlePointerCancel,
          child: Material(
            color: visual.backgroundColor,
            shape: const CircleBorder(),
            child: ControlButtonContent(
              label: widget.label,
              icon: widget.icon,
              foregroundColor: visual.foregroundColor,
              labelFontSize: widget.tuning.labelFontSize,
              labelGap: widget.tuning.labelGap,
            ),
          ),
        ),
      ),
    );
  }

  void _handlePointerDown(PointerDownEvent event) {
    if (_pointer != null) return;
    _pointer = event.pointer;
    _canceled = false;
    _holdActive = true;
    widget.onHoldStart?.call();
    widget.projectileAimPreview.begin();
    widget.onAimClear();
    _updateAim(event.localPosition);
  }

  void _handlePointerMove(PointerMoveEvent event) {
    if (event.pointer != _pointer) return;
    _updateAim(event.localPosition);
  }

  void _handlePointerUp(PointerUpEvent event) {
    if (event.pointer != _pointer) return;

    // Cancel is decided by where the pointer is released in *screen space*.
    // (The cancel hitbox cannot receive pointer events because the pointer
    // started on this button, so we must hit-test using the global position.)
    final cancelRect = widget.cancelHitboxRect?.value;
    if (cancelRect != null && cancelRect.contains(event.position)) {
      _cancelAim();
    }

    if (!_canceled) widget.onCommit();
    _resetAim();
  }

  void _handlePointerCancel(PointerCancelEvent event) {
    if (event.pointer != _pointer) return;
    // System canceled the pointer stream -> treat as Cancel (never commit).
    _cancelAim();
    _resetAim();
  }

  void _updateAim(Offset localPosition) {
    if (_canceled) return;
    final center = Offset(widget.size / 2, widget.size / 2);
    final dx = localPosition.dx - center.dx;
    final dy = localPosition.dy - center.dy;
    final len = math.sqrt(dx * dx + dy * dy);
    if (len <= widget.deadzoneRadius) {
      widget.onAimClear();
      widget.projectileAimPreview.clearAim();
      return;
    }
    final nx = dx / len;
    final ny = dy / len;
    final qx = AimQuantizer.quantize(nx);
    final qy = AimQuantizer.quantize(ny);
    widget.onAimDir(qx, qy);
    widget.projectileAimPreview.updateAim(qx, qy);
  }

  void _cancelAim() {
    if (_canceled) return;
    _canceled = true;
    widget.onAimClear();
    widget.projectileAimPreview.end();
  }

  void _resetAim() {
    _endHoldIfActive();
    _pointer = null;
    _canceled = false;
    widget.onAimClear();
    widget.projectileAimPreview.end();
  }

  void _endHoldIfActive() {
    if (!_holdActive) return;
    _holdActive = false;
    widget.onHoldEnd?.call();
  }

  @override
  void dispose() {
    _detachForceCancelListener(widget.forceCancelSignal);
    _endHoldIfActive();
    super.dispose();
  }

  void _attachForceCancelListener() {
    final signal = widget.forceCancelSignal;
    if (signal == null) return;
    _lastForceCancelValue = signal.value;
    signal.addListener(_handleForceCancelSignal);
  }

  void _detachForceCancelListener(ValueListenable<int>? signal) {
    signal?.removeListener(_handleForceCancelSignal);
  }

  void _handleForceCancelSignal() {
    final signal = widget.forceCancelSignal;
    if (signal == null) return;
    final next = signal.value;
    if (next == _lastForceCancelValue) return;
    _lastForceCancelValue = next;

    if (_pointer != null) {
      _cancelAim();
      _resetAim();
    }
  }
}


===== FILE: lib/ui/controls/hold_action_button.dart =====
import 'package:flutter/material.dart';

import 'control_button_visuals.dart';
import 'controls_tuning.dart';

/// Circular action button that starts on pointer-down and ends on release.
///
/// This widget tracks the initiating pointer id to avoid cross-pointer leaks on
/// multitouch surfaces. If the widget is disposed while held, it emits a final
/// `onHoldEnd` so caller state cannot remain latched.
class HoldActionButton extends StatefulWidget {
  const HoldActionButton({
    super.key,
    required this.label,
    required this.icon,
    required this.onHoldStart,
    required this.onHoldEnd,
    this.onRelease,
    required this.tuning,
    required this.size,
    required this.cooldownRing,
    this.affordable = true,
    this.cooldownTicksLeft = 0,
    this.cooldownTicksTotal = 0,
  });

  final String label;
  final IconData icon;
  final VoidCallback onHoldStart;
  final VoidCallback onHoldEnd;
  final VoidCallback? onRelease;
  final ActionButtonTuning tuning;
  final CooldownRingTuning cooldownRing;
  final bool affordable;
  final int cooldownTicksLeft;
  final int cooldownTicksTotal;
  final double size;

  @override
  State<HoldActionButton> createState() => _HoldActionButtonState();
}

class _HoldActionButtonState extends State<HoldActionButton> {
  int? _pointer;

  @override
  Widget build(BuildContext context) {
    final visual = ControlButtonVisualState.resolve(
      affordable: widget.affordable,
      cooldownTicksLeft: widget.cooldownTicksLeft,
      backgroundColor: widget.tuning.backgroundColor,
      foregroundColor: widget.tuning.foregroundColor,
    );

    return ControlButtonShell(
      size: widget.size,
      cooldownTicksLeft: widget.cooldownTicksLeft,
      cooldownTicksTotal: widget.cooldownTicksTotal,
      cooldownRing: widget.cooldownRing,
      child: IgnorePointer(
        ignoring: !visual.interactable,
        child: Listener(
          onPointerDown: _handlePointerDown,
          onPointerUp: _handlePointerUp,
          onPointerCancel: _handlePointerCancel,
          child: Material(
            color: visual.backgroundColor,
            shape: const CircleBorder(),
            child: ControlButtonContent(
              label: widget.label,
              icon: widget.icon,
              foregroundColor: visual.foregroundColor,
              labelFontSize: widget.tuning.labelFontSize,
              labelGap: widget.tuning.labelGap,
            ),
          ),
        ),
      ),
    );
  }

  void _handlePointerDown(PointerDownEvent event) {
    if (_pointer != null) return;
    _pointer = event.pointer;
    widget.onHoldStart();
  }

  void _handlePointerUp(PointerUpEvent event) {
    if (event.pointer != _pointer) return;
    _pointer = null;
    widget.onHoldEnd();
    widget.onRelease?.call();
  }

  void _handlePointerCancel(PointerCancelEvent event) {
    if (event.pointer != _pointer) return;
    _pointer = null;
    widget.onHoldEnd();
  }

  @override
  void dispose() {
    if (_pointer != null) {
      widget.onHoldEnd();
    }
    super.dispose();
  }
}


===== FILE: lib/ui/controls/layout/controls_radial_layout.dart =====
import 'dart:math' as math;
import 'dart:ui';

import 'package:flutter/foundation.dart';

import '../controls_tuning.dart';

/// Solves absolute control anchor positions for the radial HUD layout.
///
/// The solver keeps layout math centralized so widgets can focus on composition.
@immutable
class ControlsRadialLayout {
  const ControlsRadialLayout({
    required this.jumpSize,
    required this.actionSize,
    required this.directionalSize,
    required this.directionalDeadzoneRadius,
    required this.jump,
    required this.dash,
    required this.melee,
    required this.secondary,
    required this.projectile,
    required this.spell,
    required this.projectileCharge,
  });

  final double jumpSize;
  final double actionSize;
  final double directionalSize;
  final double directionalDeadzoneRadius;

  final ControlsAnchor jump;
  final ControlsAnchor dash;
  final ControlsAnchor melee;
  final ControlsAnchor secondary;
  final ControlsAnchor projectile;
  final ControlsAnchor spell;
  final ControlsAnchor projectileCharge;
}

@immutable
class ControlsAnchor {
  const ControlsAnchor({required this.right, required this.bottom});

  /// Distance in logical pixels from the right edge of the overlay.
  final double right;

  /// Distance in logical pixels from the bottom edge of the overlay.
  final double bottom;
}

/// Computes radial control anchors from authored layout numbers.
class ControlsRadialLayoutSolver {
  const ControlsRadialLayoutSolver._();

  static ControlsRadialLayout solve({
    required ControlsLayoutTuning layout,
    required ActionButtonTuning action,
    required DirectionalActionButtonTuning directional,
  }) {
    final jumpSize = action.size * layout.jumpButtonScale;
    final actionSize = action.size * layout.actionButtonScale;
    final directionalSize = directional.size * layout.directionalButtonScale;
    final directionalDeadzoneRadius =
        directional.deadzoneRadius * layout.directionalDeadzoneScale;

    Offset polar(double radius, double degrees) {
      final radians = degrees * math.pi / 180.0;
      return Offset(math.cos(radians) * radius, math.sin(radians) * radius);
    }

    double rightFor(Offset centerOffset, double targetSize) {
      return layout.edgePadding +
          jumpSize * 0.5 -
          centerOffset.dx -
          targetSize * 0.5;
    }

    double bottomFor(Offset centerOffset, double targetSize) {
      return layout.edgePadding +
          jumpSize * 0.5 -
          centerOffset.dy -
          targetSize * 0.5;
    }

    final jumpRadius = jumpSize * 0.5;
    final ringGap = layout.buttonGap * layout.ringGapScale;
    final ringRadius =
        jumpRadius + math.max(directionalSize, actionSize) * 0.5 + ringGap;

    final dashOffset = polar(
      ringRadius,
      layout.radialStartDeg + layout.radialStepDeg * layout.dashStepMultiplier,
    );
    final meleeOffset = polar(
      ringRadius,
      layout.radialStartDeg + layout.radialStepDeg * layout.meleeStepMultiplier,
    );
    final secondaryOffset = polar(
      ringRadius,
      layout.radialStartDeg +
          layout.radialStepDeg * layout.secondaryStepMultiplier,
    );
    final projectileOffset = polar(
      ringRadius,
      layout.radialStartDeg +
          layout.radialStepDeg * layout.projectileStepMultiplier,
    );

    final spellSize = actionSize;
    final spellRight = rightFor(secondaryOffset, spellSize);
    final spellBottom =
        bottomFor(secondaryOffset, spellSize) + layout.spellVerticalOffset;

    return ControlsRadialLayout(
      jumpSize: jumpSize,
      actionSize: actionSize,
      directionalSize: directionalSize,
      directionalDeadzoneRadius: directionalDeadzoneRadius,
      jump: ControlsAnchor(
        right: layout.edgePadding,
        bottom: layout.edgePadding,
      ),
      dash: ControlsAnchor(
        right: rightFor(dashOffset, actionSize),
        bottom: bottomFor(dashOffset, actionSize),
      ),
      melee: ControlsAnchor(
        right: rightFor(meleeOffset, directionalSize),
        bottom: bottomFor(meleeOffset, directionalSize),
      ),
      secondary: ControlsAnchor(
        right: rightFor(secondaryOffset, actionSize),
        bottom: bottomFor(secondaryOffset, actionSize),
      ),
      projectile: ControlsAnchor(
        right: rightFor(projectileOffset, directionalSize),
        bottom: bottomFor(projectileOffset, directionalSize),
      ),
      spell: ControlsAnchor(right: spellRight, bottom: spellBottom),
      projectileCharge: ControlsAnchor(
        right: rightFor(projectileOffset, directionalSize),
        bottom:
            bottomFor(projectileOffset, directionalSize) +
            directionalSize +
            layout.chargeAnchorGap,
      ),
    );
  }
}


===== FILE: lib/ui/controls/move_buttons.dart =====
import 'package:flutter/material.dart';

import 'controls_tuning.dart';

/// Two holdable movement buttons that emit a horizontal axis in [-1, 1].
///
/// - Hold left => -1
/// - Hold right => 1
/// - Hold both or none => 0
class MoveButtons extends StatefulWidget {
  const MoveButtons({
    super.key,
    required this.onAxisChanged,
    required this.tuning,
  });

  final ValueChanged<double> onAxisChanged;
  final MoveButtonsTuning tuning;

  @override
  State<MoveButtons> createState() => _MoveButtonsState();
}

class _MoveButtonsState extends State<MoveButtons> {
  final Map<int, _MoveSide> _pointerSides = <int, _MoveSide>{};

  double _axis = 0.0;

  void _syncAxis() {
    final leftHeld = _pointerSides.values.contains(_MoveSide.left);
    final rightHeld = _pointerSides.values.contains(_MoveSide.right);
    final nextAxis = switch ((leftHeld, rightHeld)) {
      (true, false) => -1.0,
      (false, true) => 1.0,
      _ => 0.0,
    };
    if (nextAxis == _axis) return;
    _axis = nextAxis;
    widget.onAxisChanged(nextAxis);
  }

  _MoveSide _sideForX(double x) {
    final leftMaxX = widget.tuning.buttonWidth;
    final rightMinX = widget.tuning.buttonWidth + widget.tuning.gap;
    if (x <= leftMaxX) return _MoveSide.left;
    if (x >= rightMinX) return _MoveSide.right;
    // Pointer is in the visual gap: snap to the nearest side so sliding across
    // the center transitions smoothly without requiring a lift/re-tap.
    final middleX = widget.tuning.buttonWidth + widget.tuning.gap * 0.5;
    return x <= middleX ? _MoveSide.left : _MoveSide.right;
  }

  void _setPointerSide(int pointer, _MoveSide side) {
    final old = _pointerSides[pointer];
    if (old == side) return;
    _pointerSides[pointer] = side;
    setState(() {});
    _syncAxis();
  }

  void _removePointer(int pointer) {
    if (_pointerSides.remove(pointer) != null) {
      setState(() {});
      _syncAxis();
    }
  }

  @override
  Widget build(BuildContext context) {
    final leftPressed = _pointerSides.values.contains(_MoveSide.left);
    final rightPressed = _pointerSides.values.contains(_MoveSide.right);
    final totalWidth = widget.tuning.buttonWidth * 2 + widget.tuning.gap;
    return SizedBox(
      width: totalWidth,
      height: widget.tuning.buttonHeight,
      child: Listener(
        behavior: HitTestBehavior.opaque,
        onPointerDown: (event) =>
            _setPointerSide(event.pointer, _sideForX(event.localPosition.dx)),
        onPointerMove: (event) =>
            _setPointerSide(event.pointer, _sideForX(event.localPosition.dx)),
        onPointerUp: (event) => _removePointer(event.pointer),
        onPointerCancel: (event) => _removePointer(event.pointer),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            _HoldMoveButton(
              label: 'Move left',
              icon: Icons.chevron_left,
              pressed: leftPressed,
              tuning: widget.tuning,
            ),
            SizedBox(width: widget.tuning.gap),
            _HoldMoveButton(
              label: 'Move right',
              icon: Icons.chevron_right,
              pressed: rightPressed,
              tuning: widget.tuning,
            ),
          ],
        ),
      ),
    );
  }
}

class _HoldMoveButton extends StatelessWidget {
  const _HoldMoveButton({
    required this.label,
    required this.icon,
    required this.pressed,
    required this.tuning,
  });

  final String label;
  final IconData icon;
  final bool pressed;
  final MoveButtonsTuning tuning;

  @override
  Widget build(BuildContext context) {
    final backgroundColor = tuning.backgroundColor;
    final base = pressed
        ? backgroundColor.withValues(
            alpha: (backgroundColor.a * 1.5).clamp(0, 1),
          )
        : backgroundColor;
    return Semantics(
      label: label,
      button: true,
      child: Container(
        width: tuning.buttonWidth,
        height: tuning.buttonHeight,
        decoration: BoxDecoration(
          color: base,
          borderRadius: BorderRadius.circular(tuning.borderRadius),
          border: Border.all(
            color: tuning.borderColor,
            width: tuning.borderWidth,
          ),
        ),
        alignment: Alignment.center,
        child: Icon(icon, color: tuning.foregroundColor),
      ),
    );
  }
}

enum _MoveSide { left, right }


===== FILE: lib/ui/controls/runner_controls_overlay_radial.dart =====
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

import 'package:rpg_runner/core/abilities/ability_def.dart';
import '../../game/input/aim_preview.dart';
import 'package:rpg_runner/core/snapshots/enums.dart';
import 'action_button.dart';
import 'ability_slot_visual_spec.dart';
import 'controls_tuning.dart';
import 'directional_action_button.dart';
import 'hold_action_button.dart';
import 'layout/controls_radial_layout.dart';
import 'widgets/spell_control.dart';
import 'widgets/melee_control.dart';
import 'widgets/movement_control.dart';
import 'widgets/projectile_control.dart';

/// Radial in-run control overlay that maps ability modes to concrete widgets.
///
/// This widget is composition-only: it receives authoritative affordability,
/// cooldown ticks, and input modes from outside, then renders the corresponding
/// controls and forwards UI intent callbacks.
class RunnerControlsOverlay extends StatelessWidget {
  const RunnerControlsOverlay({
    super.key,
    required this.onMoveAxis,
    required this.onJumpPressed,
    required this.onMobilityPressed,
    required this.onMobilityCommitted,
    required this.onMobilityHoldStart,
    required this.onMobilityHoldEnd,
    required this.onSecondaryPressed,
    required this.onSecondaryCommitted,
    required this.onSecondaryHoldStart,
    required this.onSecondaryHoldEnd,
    required this.onSpellPressed,
    required this.onProjectileCommitted,
    required this.onProjectilePressed,
    required this.onProjectileHoldStart,
    required this.onProjectileHoldEnd,
    required this.onAimDir,
    required this.onAimClear,
    required this.projectileAimPreview,
    required this.projectileAffordable,
    required this.projectileCooldownTicksLeft,
    required this.projectileCooldownTicksTotal,
    required this.onMeleeCommitted,
    required this.onMeleePressed,
    required this.onMeleeHoldStart,
    required this.onMeleeHoldEnd,
    required this.onMeleeChargeHoldStart,
    required this.onMeleeChargeHoldEnd,
    required this.meleeAimPreview,
    required this.aimCancelHitboxRect,
    required this.meleeAffordable,
    required this.meleeCooldownTicksLeft,
    required this.meleeCooldownTicksTotal,
    required this.meleeInputMode,
    required this.secondaryInputMode,
    required this.projectileInputMode,
    required this.mobilityInputMode,
    required this.chargeBarVisible,
    required this.chargeBarProgress01,
    required this.chargeBarTier,
    required this.jumpAffordable,
    required this.mobilityAffordable,
    required this.mobilityCooldownTicksLeft,
    required this.mobilityCooldownTicksTotal,
    required this.secondaryAffordable,
    required this.secondaryCooldownTicksLeft,
    required this.secondaryCooldownTicksTotal,
    required this.spellAffordable,
    required this.spellCooldownTicksLeft,
    required this.spellCooldownTicksTotal,
    required this.forceAimCancelSignal,
    this.tuning = ControlsTuning.fixed,
  });

  final ValueChanged<double> onMoveAxis;
  final VoidCallback onJumpPressed;
  final VoidCallback onMobilityPressed;
  final VoidCallback onMobilityCommitted;
  final VoidCallback onMobilityHoldStart;
  final VoidCallback onMobilityHoldEnd;
  final VoidCallback onSecondaryPressed;
  final VoidCallback onSecondaryCommitted;
  final VoidCallback onSecondaryHoldStart;
  final VoidCallback onSecondaryHoldEnd;
  final VoidCallback onSpellPressed;
  final VoidCallback onProjectileCommitted;
  final VoidCallback onProjectilePressed;
  final VoidCallback onProjectileHoldStart;
  final VoidCallback onProjectileHoldEnd;
  // Shared/global aim callbacks consumed by both projectile and melee controls.
  final void Function(double x, double y) onAimDir;
  final VoidCallback onAimClear;
  final AimPreviewModel projectileAimPreview;
  final bool chargeBarVisible;
  final double chargeBarProgress01;
  final int chargeBarTier;
  final bool projectileAffordable;
  final int projectileCooldownTicksLeft;
  final int projectileCooldownTicksTotal;
  final VoidCallback onMeleeCommitted;
  final VoidCallback onMeleePressed;
  final VoidCallback onMeleeHoldStart;
  final VoidCallback onMeleeHoldEnd;
  final VoidCallback onMeleeChargeHoldStart;
  final VoidCallback onMeleeChargeHoldEnd;
  final AimPreviewModel meleeAimPreview;
  final ValueListenable<Rect?> aimCancelHitboxRect;
  final bool meleeAffordable;
  final int meleeCooldownTicksLeft;
  final int meleeCooldownTicksTotal;
  final AbilityInputMode meleeInputMode;
  final AbilityInputMode secondaryInputMode;
  final AbilityInputMode projectileInputMode;
  final AbilityInputMode mobilityInputMode;
  final bool jumpAffordable;
  final bool mobilityAffordable;
  final int mobilityCooldownTicksLeft;
  final int mobilityCooldownTicksTotal;
  final bool secondaryAffordable;
  final int secondaryCooldownTicksLeft;
  final int secondaryCooldownTicksTotal;
  final bool spellAffordable;
  final int spellCooldownTicksLeft;
  final int spellCooldownTicksTotal;
  final ValueListenable<int> forceAimCancelSignal;
  final ControlsTuning tuning;

  @override
  Widget build(BuildContext context) {
    final style = tuning.style;
    final action = style.actionButton;
    final cooldownRing = style.cooldownRing;
    final secondarySlot = abilityRadialLayoutSpec.slotSpec(
      AbilitySlot.secondary,
    );
    final mobilitySlot = abilityRadialLayoutSpec.slotSpec(AbilitySlot.mobility);
    final jumpSlot = abilityRadialLayoutSpec.slotSpec(AbilitySlot.jump);
    final layout = ControlsRadialLayoutSolver.solve(
      layout: tuning.layout,
      action: action,
      directional: style.directionalActionButton,
    );
    ControlsAnchor anchorFor(AbilitySlot slot) =>
        abilityRadialLayoutSpec.anchorFor(layout: layout, slot: slot);
    double sizeFor(
      AbilitySlot slot, {
      AbilityRadialSlotFamily? familyOverride,
    }) => abilityRadialLayoutSpec.sizeFor(
      layout: layout,
      slot: slot,
      familyOverride: familyOverride,
    );

    return Stack(
      children: [
        Positioned(
          left: tuning.layout.edgePadding,
          bottom: tuning.layout.bottomEdgePadding,
          child: MovementControl(tuning: tuning, onMoveAxis: onMoveAxis),
        ),
        Positioned(
          right: anchorFor(AbilitySlot.projectile).right,
          bottom: anchorFor(AbilitySlot.projectile).bottom,
          child: ProjectileControl(
            tuning: tuning,
            inputMode: projectileInputMode,
            size: sizeFor(AbilitySlot.projectile),
            deadzoneRadius: layout.directionalDeadzoneRadius,
            onPressed: onProjectilePressed,
            onHoldStart: onProjectileHoldStart,
            onHoldEnd: onProjectileHoldEnd,
            onAimDir: onAimDir,
            onAimClear: onAimClear,
            onCommitted: onProjectileCommitted,
            aimPreview: projectileAimPreview,
            affordable: projectileAffordable,
            cooldownTicksLeft: projectileCooldownTicksLeft,
            cooldownTicksTotal: projectileCooldownTicksTotal,
            cancelHitboxRect: aimCancelHitboxRect,
            forceCancelSignal: forceAimCancelSignal,
          ),
        ),
        Positioned(
          right: anchorFor(AbilitySlot.spell).right,
          bottom: anchorFor(AbilitySlot.spell).bottom,
          child: SpellControl(
            tuning: tuning,
            size: sizeFor(AbilitySlot.spell),
            onPressed: onSpellPressed,
            affordable: spellAffordable,
            cooldownTicksLeft: spellCooldownTicksLeft,
            cooldownTicksTotal: spellCooldownTicksTotal,
          ),
        ),
        Positioned(
          right: anchorFor(AbilitySlot.secondary).right,
          bottom: anchorFor(AbilitySlot.secondary).bottom,
          child: secondaryInputMode == AbilityInputMode.holdMaintain
              ? HoldActionButton(
                  label: secondarySlot.label,
                  icon: secondarySlot.icon,
                  onHoldStart: onSecondaryHoldStart,
                  onHoldEnd: onSecondaryHoldEnd,
                  tuning: action,
                  cooldownRing: cooldownRing,
                  affordable: secondaryAffordable,
                  cooldownTicksLeft: secondaryCooldownTicksLeft,
                  cooldownTicksTotal: secondaryCooldownTicksTotal,
                  size: sizeFor(AbilitySlot.secondary),
                )
              : secondaryInputMode == AbilityInputMode.holdRelease
              ? HoldActionButton(
                  label: secondarySlot.label,
                  icon: secondarySlot.icon,
                  onHoldStart: onSecondaryHoldStart,
                  onHoldEnd: onSecondaryHoldEnd,
                  onRelease: onSecondaryCommitted,
                  tuning: action,
                  cooldownRing: cooldownRing,
                  affordable: secondaryAffordable,
                  cooldownTicksLeft: secondaryCooldownTicksLeft,
                  cooldownTicksTotal: secondaryCooldownTicksTotal,
                  size: sizeFor(AbilitySlot.secondary),
                )
              : secondaryInputMode == AbilityInputMode.holdAimRelease
              ? DirectionalActionButton(
                  label: secondarySlot.label,
                  icon: secondarySlot.icon,
                  onHoldStart: onSecondaryHoldStart,
                  onHoldEnd: onSecondaryHoldEnd,
                  onAimDir: onAimDir,
                  onAimClear: onAimClear,
                  onCommit: onSecondaryCommitted,
                  projectileAimPreview: meleeAimPreview,
                  tuning: style.directionalActionButton,
                  cooldownRing: cooldownRing,
                  cancelHitboxRect: aimCancelHitboxRect,
                  affordable: secondaryAffordable,
                  cooldownTicksLeft: secondaryCooldownTicksLeft,
                  cooldownTicksTotal: secondaryCooldownTicksTotal,
                  size: sizeFor(
                    AbilitySlot.secondary,
                    familyOverride: AbilityRadialSlotFamily.directional,
                  ),
                  deadzoneRadius: layout.directionalDeadzoneRadius,
                  forceCancelSignal: forceAimCancelSignal,
                )
              : ActionButton(
                  label: secondarySlot.label,
                  icon: secondarySlot.icon,
                  onPressed: onSecondaryPressed,
                  tuning: action,
                  cooldownRing: cooldownRing,
                  affordable: secondaryAffordable,
                  cooldownTicksLeft: secondaryCooldownTicksLeft,
                  cooldownTicksTotal: secondaryCooldownTicksTotal,
                  size: sizeFor(AbilitySlot.secondary),
                ),
        ),
        Positioned(
          right: anchorFor(AbilitySlot.primary).right,
          bottom: anchorFor(AbilitySlot.primary).bottom,
          child: MeleeControl(
            tuning: tuning,
            inputMode: meleeInputMode,
            size: sizeFor(AbilitySlot.primary),
            deadzoneRadius: layout.directionalDeadzoneRadius,
            onPressed: onMeleePressed,
            onHoldStart: onMeleeHoldStart,
            onHoldEnd: onMeleeHoldEnd,
            onChargeHoldStart: onMeleeChargeHoldStart,
            onChargeHoldEnd: onMeleeChargeHoldEnd,
            onAimDir: onAimDir,
            onAimClear: onAimClear,
            onCommitted: onMeleeCommitted,
            aimPreview: meleeAimPreview,
            affordable: meleeAffordable,
            cooldownTicksLeft: meleeCooldownTicksLeft,
            cooldownTicksTotal: meleeCooldownTicksTotal,
            cancelHitboxRect: aimCancelHitboxRect,
            forceCancelSignal: forceAimCancelSignal,
          ),
        ),
        Positioned(
          right: anchorFor(AbilitySlot.mobility).right,
          bottom: anchorFor(AbilitySlot.mobility).bottom,
          child: mobilityInputMode == AbilityInputMode.tap
              ? ActionButton(
                  label: mobilitySlot.label,
                  icon: mobilitySlot.icon,
                  onPressed: onMobilityPressed,
                  tuning: action,
                  cooldownRing: cooldownRing,
                  affordable: mobilityAffordable,
                  cooldownTicksLeft: mobilityCooldownTicksLeft,
                  cooldownTicksTotal: mobilityCooldownTicksTotal,
                  size: sizeFor(AbilitySlot.mobility),
                )
              : mobilityInputMode == AbilityInputMode.holdMaintain
              ? HoldActionButton(
                  label: mobilitySlot.label,
                  icon: mobilitySlot.icon,
                  onHoldStart: onMobilityHoldStart,
                  onHoldEnd: onMobilityHoldEnd,
                  tuning: action,
                  cooldownRing: cooldownRing,
                  affordable: mobilityAffordable,
                  cooldownTicksLeft: mobilityCooldownTicksLeft,
                  cooldownTicksTotal: mobilityCooldownTicksTotal,
                  size: sizeFor(AbilitySlot.mobility),
                )
              : mobilityInputMode == AbilityInputMode.holdRelease
              ? HoldActionButton(
                  label: mobilitySlot.label,
                  icon: mobilitySlot.icon,
                  onHoldStart: onMobilityHoldStart,
                  onHoldEnd: onMobilityHoldEnd,
                  onRelease: onMobilityCommitted,
                  tuning: action,
                  cooldownRing: cooldownRing,
                  affordable: mobilityAffordable,
                  cooldownTicksLeft: mobilityCooldownTicksLeft,
                  cooldownTicksTotal: mobilityCooldownTicksTotal,
                  size: sizeFor(AbilitySlot.mobility),
                )
              : DirectionalActionButton(
                  label: mobilitySlot.label,
                  icon: mobilitySlot.icon,
                  onHoldStart: onMobilityHoldStart,
                  onHoldEnd: onMobilityHoldEnd,
                  onAimDir: onAimDir,
                  onAimClear: onAimClear,
                  onCommit: onMobilityCommitted,
                  projectileAimPreview: meleeAimPreview,
                  tuning: style.directionalActionButton,
                  cooldownRing: cooldownRing,
                  cancelHitboxRect: aimCancelHitboxRect,
                  affordable: mobilityAffordable,
                  cooldownTicksLeft: mobilityCooldownTicksLeft,
                  cooldownTicksTotal: mobilityCooldownTicksTotal,
                  size: sizeFor(
                    AbilitySlot.mobility,
                    familyOverride: AbilityRadialSlotFamily.directional,
                  ),
                  deadzoneRadius: layout.directionalDeadzoneRadius,
                  forceCancelSignal: forceAimCancelSignal,
                ),
        ),
        Positioned(
          right: anchorFor(AbilitySlot.jump).right,
          bottom: anchorFor(AbilitySlot.jump).bottom,
          child: ActionButton(
            label: jumpSlot.label,
            icon: jumpSlot.icon,
            onPressed: onJumpPressed,
            tuning: action,
            cooldownRing: cooldownRing,
            affordable: jumpAffordable,
            size: sizeFor(AbilitySlot.jump),
          ),
        ),
        if (chargeBarVisible)
          Positioned(
            right: layout.projectileCharge.right,
            bottom: layout.projectileCharge.bottom,
            child: _ChargeBar(
              tuning: style.chargeBar,
              progress01: chargeBarProgress01,
              tier: chargeBarTier,
            ),
          ),
      ],
    );
  }
}

class _ChargeBar extends StatelessWidget {
  const _ChargeBar({
    required this.tuning,
    required this.progress01,
    required this.tier,
  });

  final ChargeBarTuning tuning;

  /// Normalized progress in [0, 1].
  final double progress01;

  /// Charge tier bucket: 0 = idle, 1 = half, 2 = full.
  final int tier;

  @override
  Widget build(BuildContext context) {
    final clamped = progress01.clamp(0.0, 1.0);
    final fillColor = switch (tier) {
      2 => tuning.fullTierColor,
      1 => tuning.halfTierColor,
      _ => tuning.idleColor,
    };
    return Container(
      width: tuning.width,
      height: tuning.height,
      padding: EdgeInsets.all(tuning.padding),
      decoration: BoxDecoration(
        color: tuning.backgroundColor,
        borderRadius: BorderRadius.circular(tuning.outerRadius),
        border: Border.all(
          color: tuning.borderColor,
          width: tuning.borderWidth,
        ),
      ),
      child: Align(
        alignment: Alignment.centerLeft,
        child: FractionallySizedBox(
          widthFactor: clamped,
          child: Container(
            decoration: BoxDecoration(
              color: fillColor,
              borderRadius: BorderRadius.circular(tuning.innerRadius),
            ),
          ),
        ),
      ),
    );
  }
}


===== FILE: lib/ui/controls/widgets/melee_control.dart =====
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

import '../../../core/abilities/ability_def.dart';
import '../../../core/snapshots/enums.dart';
import '../../../game/input/aim_preview.dart';
import '../action_button.dart';
import '../ability_slot_visual_spec.dart';
import '../controls_tuning.dart';
import '../directional_action_button.dart';
import '../hold_action_button.dart';

/// Resolves melee input mode (tap, hold-release, hold-maintain, directional aim-release).
class MeleeControl extends StatelessWidget {
  const MeleeControl({
    super.key,
    required this.tuning,
    required this.inputMode,
    required this.size,
    required this.deadzoneRadius,
    required this.onPressed,
    required this.onHoldStart,
    required this.onHoldEnd,
    required this.onChargeHoldStart,
    required this.onChargeHoldEnd,
    required this.onAimDir,
    required this.onAimClear,
    required this.onCommitted,
    required this.aimPreview,
    required this.affordable,
    required this.cooldownTicksLeft,
    required this.cooldownTicksTotal,
    required this.cancelHitboxRect,
    required this.forceCancelSignal,
  });

  final ControlsTuning tuning;
  final AbilityInputMode inputMode;
  final double size;
  final double deadzoneRadius;

  final VoidCallback onPressed;
  final VoidCallback onHoldStart;
  final VoidCallback onHoldEnd;
  final VoidCallback onChargeHoldStart;
  final VoidCallback onChargeHoldEnd;
  final void Function(double x, double y) onAimDir;
  final VoidCallback onAimClear;
  final VoidCallback onCommitted;

  final AimPreviewModel aimPreview;
  final bool affordable;
  final int cooldownTicksLeft;
  final int cooldownTicksTotal;
  final ValueListenable<Rect?> cancelHitboxRect;
  final ValueListenable<int> forceCancelSignal;

  @override
  Widget build(BuildContext context) {
    final slot = abilityRadialLayoutSpec.slotSpec(AbilitySlot.primary);
    final action = tuning.style.actionButton;
    final directional = tuning.style.directionalActionButton;
    final cooldownRing = tuning.style.cooldownRing;
    if (inputMode == AbilityInputMode.tap) {
      return ActionButton(
        label: slot.label,
        icon: slot.icon,
        onPressed: onPressed,
        tuning: action,
        cooldownRing: cooldownRing,
        affordable: affordable,
        cooldownTicksLeft: cooldownTicksLeft,
        cooldownTicksTotal: cooldownTicksTotal,
        size: size,
      );
    }
    if (inputMode == AbilityInputMode.holdMaintain) {
      return HoldActionButton(
        label: slot.label,
        icon: slot.icon,
        onHoldStart: onHoldStart,
        onHoldEnd: onHoldEnd,
        tuning: action,
        cooldownRing: cooldownRing,
        affordable: affordable,
        cooldownTicksLeft: cooldownTicksLeft,
        cooldownTicksTotal: cooldownTicksTotal,
        size: size,
      );
    }
    if (inputMode == AbilityInputMode.holdRelease) {
      return HoldActionButton(
        label: slot.label,
        icon: slot.icon,
        onHoldStart: onChargeHoldStart,
        onHoldEnd: onChargeHoldEnd,
        onRelease: onCommitted,
        tuning: action,
        cooldownRing: cooldownRing,
        affordable: affordable,
        cooldownTicksLeft: cooldownTicksLeft,
        cooldownTicksTotal: cooldownTicksTotal,
        size: size,
      );
    }
    return DirectionalActionButton(
      label: slot.label,
      icon: slot.icon,
      onHoldStart: onChargeHoldStart,
      onHoldEnd: onChargeHoldEnd,
      onAimDir: onAimDir,
      onAimClear: onAimClear,
      onCommit: onCommitted,
      projectileAimPreview: aimPreview,
      tuning: directional,
      cooldownRing: cooldownRing,
      cancelHitboxRect: cancelHitboxRect,
      affordable: affordable,
      cooldownTicksLeft: cooldownTicksLeft,
      cooldownTicksTotal: cooldownTicksTotal,
      size: size,
      deadzoneRadius: deadzoneRadius,
      forceCancelSignal: forceCancelSignal,
    );
  }
}


===== FILE: lib/ui/controls/widgets/movement_control.dart =====
import 'package:flutter/material.dart';

import '../controls_tuning.dart';
import '../move_buttons.dart';

/// Adapter that binds movement callbacks to tuned `MoveButtons` visuals.
class MovementControl extends StatelessWidget {
  const MovementControl({
    super.key,
    required this.tuning,
    required this.onMoveAxis,
  });

  final ControlsTuning tuning;
  final ValueChanged<double> onMoveAxis;

  @override
  Widget build(BuildContext context) {
    return MoveButtons(onAxisChanged: onMoveAxis, tuning: tuning.moveButtons);
  }
}


===== FILE: lib/ui/controls/widgets/projectile_control.dart =====
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

import '../../../core/abilities/ability_def.dart';
import '../../../core/snapshots/enums.dart';
import '../../../game/input/aim_preview.dart';
import '../action_button.dart';
import '../ability_slot_visual_spec.dart';
import '../controls_tuning.dart';
import '../directional_action_button.dart';
import '../hold_action_button.dart';

/// Resolves projectile input mode (tap, hold-release, directional aim-release).
class ProjectileControl extends StatelessWidget {
  const ProjectileControl({
    super.key,
    required this.tuning,
    required this.inputMode,
    required this.size,
    required this.deadzoneRadius,
    required this.onPressed,
    required this.onHoldStart,
    required this.onHoldEnd,
    required this.onAimDir,
    required this.onAimClear,
    required this.onCommitted,
    required this.aimPreview,
    required this.affordable,
    required this.cooldownTicksLeft,
    required this.cooldownTicksTotal,
    required this.cancelHitboxRect,
    required this.forceCancelSignal,
  });

  final ControlsTuning tuning;
  final AbilityInputMode inputMode;
  final double size;
  final double deadzoneRadius;

  final VoidCallback onPressed;
  final VoidCallback onHoldStart;
  final VoidCallback onHoldEnd;
  final void Function(double x, double y) onAimDir;
  final VoidCallback onAimClear;
  final VoidCallback onCommitted;

  final AimPreviewModel aimPreview;
  final bool affordable;
  final int cooldownTicksLeft;
  final int cooldownTicksTotal;
  final ValueListenable<Rect?> cancelHitboxRect;

  final ValueListenable<int> forceCancelSignal;

  @override
  Widget build(BuildContext context) {
    final slot = abilityRadialLayoutSpec.slotSpec(AbilitySlot.projectile);
    final action = tuning.style.actionButton;
    final directional = tuning.style.directionalActionButton;
    final cooldownRing = tuning.style.cooldownRing;
    if (inputMode == AbilityInputMode.tap) {
      return ActionButton(
        label: slot.label,
        icon: slot.icon,
        onPressed: onPressed,
        tuning: action,
        cooldownRing: cooldownRing,
        affordable: affordable,
        cooldownTicksLeft: cooldownTicksLeft,
        cooldownTicksTotal: cooldownTicksTotal,
        size: size,
      );
    }
    if (inputMode == AbilityInputMode.holdRelease) {
      return HoldActionButton(
        label: slot.label,
        icon: slot.icon,
        onHoldStart: onHoldStart,
        onHoldEnd: onHoldEnd,
        onRelease: onCommitted,
        tuning: action,
        cooldownRing: cooldownRing,
        affordable: affordable,
        cooldownTicksLeft: cooldownTicksLeft,
        cooldownTicksTotal: cooldownTicksTotal,
        size: size,
      );
    }
    return DirectionalActionButton(
      label: slot.label,
      icon: slot.icon,
      onHoldStart: onHoldStart,
      onHoldEnd: onHoldEnd,
      onAimDir: onAimDir,
      onAimClear: onAimClear,
      onCommit: onCommitted,
      tuning: directional,
      cooldownRing: cooldownRing,
      projectileAimPreview: aimPreview,
      cancelHitboxRect: cancelHitboxRect,
      affordable: affordable,
      cooldownTicksLeft: cooldownTicksLeft,
      cooldownTicksTotal: cooldownTicksTotal,
      size: size,
      deadzoneRadius: deadzoneRadius,
      forceCancelSignal: forceCancelSignal,
    );
  }
}


===== FILE: lib/ui/controls/widgets/spell_control.dart =====
import 'package:flutter/material.dart';

import '../../../core/abilities/ability_def.dart';
import '../action_button.dart';
import '../ability_slot_visual_spec.dart';
import '../controls_tuning.dart';

/// Tap-only spell slot control (self-targeted spells).
class SpellControl extends StatelessWidget {
  const SpellControl({
    super.key,
    required this.tuning,
    required this.size,
    required this.onPressed,
    required this.affordable,
    required this.cooldownTicksLeft,
    required this.cooldownTicksTotal,
  });

  final ControlsTuning tuning;
  final double size;
  final VoidCallback onPressed;
  final bool affordable;
  final int cooldownTicksLeft;
  final int cooldownTicksTotal;

  @override
  Widget build(BuildContext context) {
    final slot = abilityRadialLayoutSpec.slotSpec(AbilitySlot.spell);
    final action = tuning.style.actionButton;
    final cooldownRing = tuning.style.cooldownRing;
    return ActionButton(
      label: slot.label,
      icon: slot.icon,
      onPressed: onPressed,
      tuning: action,
      cooldownRing: cooldownRing,
      affordable: affordable,
      cooldownTicksLeft: cooldownTicksLeft,
      cooldownTicksTotal: cooldownTicksTotal,
      size: size,
    );
  }
}


===== FILE: lib/ui/dev_menu_page.dart =====
import 'package:flutter/material.dart';

import 'app/ui_routes.dart';
import 'theme/ui_tokens.dart';

/// Development-only menu used by the standalone host app (`lib/main.dart`).
///
/// Not part of the embeddable runner API. Host apps should integrate the game
/// via `RunnerGameWidget` / `createRunnerGameRoute` (see `lib/runner.dart`).
class DevMenuPage extends StatelessWidget {
  const DevMenuPage({super.key});

  @override
  Widget build(BuildContext context) {
    final ui = context.ui;
    return Scaffold(
      backgroundColor: ui.colors.background,
      appBar: AppBar(
        title: Text(
          'rpg Runner (Dev)',
          style: ui.text.title.copyWith(
            color: ui.colors.textPrimary,
            fontSize: 20,
            fontWeight: FontWeight.w600,
          ),
        ),
        backgroundColor: ui.colors.background,
        iconTheme: IconThemeData(color: ui.colors.textPrimary),
      ),
      body: Center(
        child: FilledButton(
          onPressed: () {
            Navigator.of(context).pushNamed(UiRoutes.hub);
          },
          child: const Text('Menu'),
        ),
      ),
    );
  }
}


===== FILE: lib/ui/haptics/haptics_cue.dart =====
/// Semantic UI haptic cues.
///
/// Cues let gameplay/UI code request feedback without binding to a specific
/// platform call.
enum UiHapticsCue {
  chargeHalfTierReached,
  chargeFullTierReached,
  holdAbilityTimedOut,
  holdAbilityStaminaDepleted,
  playerHit,
}

/// Relative haptic intensity.
enum UiHapticsIntensity { selection, light, medium, heavy }


===== FILE: lib/ui/haptics/haptics_driver.dart =====
import 'package:flutter/services.dart';

/// Low-level haptics driver abstraction.
///
/// This indirection keeps UI feedback logic testable and centralized.
abstract interface class UiHapticsDriver {
  void selectionClick();
  void lightImpact();
  void mediumImpact();
  void heavyImpact();
}

/// System-backed haptics driver using Flutter's platform channels.
class SystemUiHapticsDriver implements UiHapticsDriver {
  const SystemUiHapticsDriver();

  @override
  void heavyImpact() => HapticFeedback.heavyImpact();

  @override
  void lightImpact() => HapticFeedback.lightImpact();

  @override
  void mediumImpact() => HapticFeedback.mediumImpact();

  @override
  void selectionClick() => HapticFeedback.selectionClick();
}


===== FILE: lib/ui/haptics/haptics_service.dart =====
import 'haptics_cue.dart';
import 'haptics_driver.dart';

/// UI-facing haptics service.
///
/// Consumers should trigger semantic cues instead of raw platform calls.
abstract interface class UiHaptics {
  void trigger(UiHapticsCue cue, {UiHapticsIntensity? intensityOverride});
}

/// Default UI haptics implementation with cue-to-intensity mapping.
class UiHapticsService implements UiHaptics {
  const UiHapticsService({
    this.enabled = true,
    this.driver = const SystemUiHapticsDriver(),
  });

  final bool enabled;
  final UiHapticsDriver driver;

  @override
  void trigger(UiHapticsCue cue, {UiHapticsIntensity? intensityOverride}) {
    if (!enabled) return;
    final intensity = intensityOverride ?? _defaultIntensityFor(cue);
    switch (intensity) {
      case UiHapticsIntensity.selection:
        driver.selectionClick();
      case UiHapticsIntensity.light:
        driver.lightImpact();
      case UiHapticsIntensity.medium:
        driver.mediumImpact();
      case UiHapticsIntensity.heavy:
        driver.heavyImpact();
    }
  }

  UiHapticsIntensity _defaultIntensityFor(UiHapticsCue cue) {
    switch (cue) {
      case UiHapticsCue.chargeHalfTierReached:
        return UiHapticsIntensity.selection;
      case UiHapticsCue.chargeFullTierReached:
        return UiHapticsIntensity.light;
      case UiHapticsCue.holdAbilityTimedOut:
        return UiHapticsIntensity.heavy;
      case UiHapticsCue.holdAbilityStaminaDepleted:
        return UiHapticsIntensity.medium;
      case UiHapticsCue.playerHit:
        return UiHapticsIntensity.medium;
    }
  }
}


===== FILE: lib/ui/hud/game/aim_cancel_button_overlay.dart =====
import 'package:flutter/material.dart';

import '../../../game/input/aim_preview.dart';
import '../../theme/ui_tokens.dart';

/// Visual-only cancel affordance for aimed actions.
///
/// Important: this widget does *not* receive pointer events when the player
/// started the gesture on an action button (hit testing is frozen on pointer
/// down). The action buttons must hit-test this widget's global rect on release.
class AimCancelButtonOverlay extends StatefulWidget {
  const AimCancelButtonOverlay({
    super.key,
    required this.projectileAimPreview,
    required this.meleeAimPreview,
    required this.hitboxRect,
  });

  final AimPreviewModel projectileAimPreview;
  final AimPreviewModel meleeAimPreview;

  /// Global rect (screen space) of the cancel hitbox.
  ///
  /// Directional buttons read this on pointer-up to decide whether to cancel.
  final ValueNotifier<Rect?> hitboxRect;

  @override
  State<AimCancelButtonOverlay> createState() => _AimCancelButtonOverlayState();
}

class _AimCancelButtonOverlayState extends State<AimCancelButtonOverlay> {
  final GlobalKey _hitboxKey = GlobalKey();

  @override
  void initState() {
    super.initState();
    widget.projectileAimPreview.addListener(_onAimChanged);
    widget.meleeAimPreview.addListener(_onAimChanged);
    _onAimChanged();
  }

  @override
  void didUpdateWidget(covariant AimCancelButtonOverlay oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.projectileAimPreview != widget.projectileAimPreview) {
      oldWidget.projectileAimPreview.removeListener(_onAimChanged);
      widget.projectileAimPreview.addListener(_onAimChanged);
    }
    if (oldWidget.meleeAimPreview != widget.meleeAimPreview) {
      oldWidget.meleeAimPreview.removeListener(_onAimChanged);
      widget.meleeAimPreview.addListener(_onAimChanged);
    }
    if (oldWidget.hitboxRect != widget.hitboxRect) {
      // Force recompute if the target notifier changed.
      WidgetsBinding.instance.addPostFrameCallback((_) => _syncHitboxRect());
    }
    _onAimChanged();
  }

  @override
  void dispose() {
    widget.projectileAimPreview.removeListener(_onAimChanged);
    widget.meleeAimPreview.removeListener(_onAimChanged);
    widget.hitboxRect.value = null;
    super.dispose();
  }

  bool get _active =>
      widget.projectileAimPreview.value.active ||
      widget.meleeAimPreview.value.active;

  void _onAimChanged() {
    if (!mounted) return;
    setState(() {});
    WidgetsBinding.instance.addPostFrameCallback((_) => _syncHitboxRect());
  }

  void _syncHitboxRect() {
    if (!mounted) return;

    if (!_active) {
      if (widget.hitboxRect.value != null) {
        widget.hitboxRect.value = null;
      }
      return;
    }

    final ctx = _hitboxKey.currentContext;
    if (ctx == null) return;
    final ro = ctx.findRenderObject();
    if (ro is! RenderBox || !ro.hasSize) return;

    final topLeft = ro.localToGlobal(Offset.zero);
    final rect = topLeft & ro.size;

    if (widget.hitboxRect.value != rect) {
      widget.hitboxRect.value = rect;
    }
  }

  @override
  Widget build(BuildContext context) {
    if (!_active) return const SizedBox.shrink();
    final ui = context.ui;

    // Fixed screen-space location between clock (top-center) and distance (top-right).
    // The hitbox is intentionally larger than the icon for mobile ergonomics.
    return Positioned(
      top: 56,
      right: 180,
      child: IgnorePointer(
        // Visual only; directional buttons do the hit-test in screen space.
        ignoring: true,
        child: SizedBox(
          key: _hitboxKey,
          width: 56,
          height: 56,
          child: DecoratedBox(
            decoration: BoxDecoration(
              color: ui.colors.danger.withValues(alpha: 0.1),
              borderRadius: BorderRadius.circular(28),
            ),
            child: Center(
              child: Icon(Icons.close, size: 22, color: ui.colors.textPrimary),
            ),
          ),
        ),
      ),
    );
  }
}


===== FILE: lib/ui/hud/game/exit_button_overlay.dart =====
import 'package:flutter/material.dart';

import '../../theme/ui_tokens.dart';

class ExitButtonOverlay extends StatelessWidget {
  const ExitButtonOverlay({
    super.key,
    required this.onPressed,
    required this.highlight,
  });

  final VoidCallback? onPressed;
  final bool highlight;

  @override
  Widget build(BuildContext context) {
    final ui = context.ui;
    return Align(
      alignment: Alignment.topRight,
      child: Padding(
        padding: EdgeInsets.all(ui.space.xs),
        child: IconButton(
          onPressed: onPressed,
          icon: const Icon(Icons.close),
          color: highlight ? ui.colors.textPrimary : null,
        ),
      ),
    );
  }
}


===== FILE: lib/ui/hud/game/game_overlay.dart =====
import 'package:flutter/foundation.dart';
import 'package:flutter/widgets.dart';

import '../../../game/game_controller.dart';
import '../../../game/input/aim_preview.dart';
import '../../../game/input/runner_input_router.dart';
import 'package:rpg_runner/core/snapshots/enums.dart';
import '../../controls/runner_controls_overlay_radial.dart';
import 'package:rpg_runner/core/abilities/ability_def.dart';
import '../../runner_game_ui_state.dart';
import 'pause_overlay.dart';
import 'ready_overlay.dart';
import 'top_center_hud_overlay.dart';
import 'top_left_hud_overlay.dart';
import 'top_right_hud_overlay.dart';
import 'aim_cancel_button_overlay.dart';
import 'player_impact_border_overlay.dart';

class GameOverlay extends StatelessWidget {
  const GameOverlay({
    super.key,
    required this.controller,
    required this.input,
    required this.projectileAimPreview,
    required this.meleeAimPreview,
    required this.aimCancelHitboxRect,
    required this.forceAimCancelSignal,
    required this.playerImpactFeedbackSignal,
    required this.uiState,
    required this.onStart,
    required this.onTogglePause,
    required this.showExitButton,
    required this.onExit,
    required this.exitConfirmOpen,
    required this.onExitConfirmResume,
    required this.onExitConfirmExit,
  });

  final GameController controller;
  final RunnerInputRouter input;
  final AimPreviewModel projectileAimPreview;
  final AimPreviewModel meleeAimPreview;
  final ValueNotifier<Rect?> aimCancelHitboxRect;
  final ValueListenable<int> forceAimCancelSignal;
  final ValueListenable<int> playerImpactFeedbackSignal;
  final RunnerGameUiState uiState;
  final VoidCallback onStart;
  final VoidCallback onTogglePause;
  final bool showExitButton;
  final VoidCallback? onExit;
  final bool exitConfirmOpen;
  final VoidCallback onExitConfirmResume;
  final VoidCallback onExitConfirmExit;

  @override
  Widget build(BuildContext context) {
    final hud = controller.snapshot.hud;
    final projectileAffordable =
        hud.canAffordProjectile && hud.projectileSlotValid;
    final meleeAffordable = hud.canAffordMelee && hud.meleeSlotValid;
    final mobilityAffordable = hud.canAffordMobility && hud.mobilitySlotValid;
    final jumpAffordable = hud.canAffordJump && hud.jumpSlotValid;
    final secondaryAffordable =
        hud.canAffordSecondary && hud.secondarySlotValid;
    final spellAffordable = hud.canAffordSpell && hud.spellSlotValid;
    final secondaryUsesSlotHold =
        hud.secondaryInputMode == AbilityInputMode.holdAimRelease ||
        hud.secondaryInputMode == AbilityInputMode.holdRelease;
    final mobilityUsesSlotHold =
        hud.mobilityInputMode == AbilityInputMode.holdAimRelease ||
        hud.mobilityInputMode == AbilityInputMode.holdRelease;
    final chargeBarVisible = hud.chargeEnabled && hud.chargeActive;
    final chargeBarProgress01 = hud.chargeFullTicks > 0
        ? (hud.chargeTicks / hud.chargeFullTicks).clamp(0.0, 1.0)
        : 0.0;

    return Stack(
      fit: StackFit.expand,
      children: [
        IgnorePointer(
          ignoring: !uiState.isRunning,
          child: RunnerControlsOverlay(
            onMoveAxis: input.setMoveAxis,
            onJumpPressed: input.pressJump,
            onMobilityPressed: input.pressDash,
            onMobilityCommitted: () =>
                input.commitMobilityWithAim(clearAim: true),
            onMobilityHoldStart: mobilityUsesSlotHold
                ? () => input.startAbilitySlotHold(AbilitySlot.mobility)
                : input.startMobilityHold,
            onMobilityHoldEnd: mobilityUsesSlotHold
                ? () => input.endAbilitySlotHold(AbilitySlot.mobility)
                : input.endMobilityHold,
            onSecondaryPressed: input.pressSecondary,
            onSecondaryCommitted: input.commitSecondaryStrike,
            onSecondaryHoldStart: secondaryUsesSlotHold
                ? () => input.startAbilitySlotHold(AbilitySlot.secondary)
                : input.startSecondaryHold,
            onSecondaryHoldEnd: secondaryUsesSlotHold
                ? () => input.endAbilitySlotHold(AbilitySlot.secondary)
                : input.endSecondaryHold,
            onSpellPressed: input.pressSpell,
            onProjectileCommitted: () =>
                input.commitProjectileWithAim(clearAim: true),
            onProjectilePressed: input.pressProjectile,
            onProjectileHoldStart: () =>
                input.startAbilitySlotHold(AbilitySlot.projectile),
            onProjectileHoldEnd: () =>
                input.endAbilitySlotHold(AbilitySlot.projectile),
            onAimDir: input.setAimDir,
            onAimClear: input.clearAimDir,
            projectileAimPreview: projectileAimPreview,
            chargeBarVisible: chargeBarVisible,
            chargeBarProgress01: chargeBarProgress01,
            chargeBarTier: hud.chargeTier,
            projectileAffordable: projectileAffordable,
            projectileCooldownTicksLeft:
                hud.cooldownTicksLeft[CooldownGroup.projectile],
            projectileCooldownTicksTotal:
                hud.cooldownTicksTotal[CooldownGroup.projectile],
            onMeleeCommitted: input.commitMeleeStrike,
            onMeleePressed: input.pressStrike,
            onMeleeHoldStart: input.startPrimaryHold,
            onMeleeHoldEnd: input.endPrimaryHold,
            onMeleeChargeHoldStart: () =>
                input.startAbilitySlotHold(AbilitySlot.primary),
            onMeleeChargeHoldEnd: () =>
                input.endAbilitySlotHold(AbilitySlot.primary),
            meleeAimPreview: meleeAimPreview,
            aimCancelHitboxRect: aimCancelHitboxRect,
            meleeAffordable: meleeAffordable,
            meleeCooldownTicksLeft:
                hud.cooldownTicksLeft[CooldownGroup.primary],
            meleeCooldownTicksTotal:
                hud.cooldownTicksTotal[CooldownGroup.primary],
            meleeInputMode: hud.meleeInputMode,
            secondaryInputMode: hud.secondaryInputMode,
            projectileInputMode: hud.projectileInputMode,
            mobilityInputMode: hud.mobilityInputMode,
            jumpAffordable: jumpAffordable,
            mobilityAffordable: mobilityAffordable,
            mobilityCooldownTicksLeft:
                hud.cooldownTicksLeft[CooldownGroup.mobility],
            mobilityCooldownTicksTotal:
                hud.cooldownTicksTotal[CooldownGroup.mobility],
            secondaryAffordable: secondaryAffordable,
            secondaryCooldownTicksLeft:
                hud.cooldownTicksLeft[CooldownGroup.secondary],
            secondaryCooldownTicksTotal:
                hud.cooldownTicksTotal[CooldownGroup.secondary],
            spellAffordable: spellAffordable,
            spellCooldownTicksLeft: hud.cooldownTicksLeft[CooldownGroup.spell0],
            spellCooldownTicksTotal:
                hud.cooldownTicksTotal[CooldownGroup.spell0],
            forceAimCancelSignal: forceAimCancelSignal,
          ),
        ),
        PauseOverlay(
          visible: uiState.showPauseOverlay,
          exitConfirmOpen: exitConfirmOpen,
          onResume: onExitConfirmResume,
          onExit: onExitConfirmExit,
        ),
        ReadyOverlay(visible: uiState.showReadyOverlay, onTap: onStart),
        Align(
          alignment: Alignment.topLeft,
          child: Padding(
            padding: const EdgeInsets.all(12),
            child: TopLeftHudOverlay(controller: controller),
          ),
        ),
        TopCenterHudOverlay(
          controller: controller,
          uiState: uiState,
          onStart: onStart,
          onTogglePause: onTogglePause,
        ),
        AimCancelButtonOverlay(
          projectileAimPreview: projectileAimPreview,
          meleeAimPreview: meleeAimPreview,
          hitboxRect: aimCancelHitboxRect,
        ),
        TopRightHudOverlay(
          controller: controller,
          showExitButton: showExitButton,
          onExit: onExit,
        ),
        PlayerImpactBorderOverlay(triggerSignal: playerImpactFeedbackSignal),
      ],
    );
  }
}


===== FILE: lib/ui/hud/game/pause_overlay.dart =====
import 'package:flutter/material.dart';

import '../../components/app_button.dart';
import '../../theme/ui_tokens.dart';

class PauseOverlay extends StatelessWidget {
  const PauseOverlay({
    super.key,
    required this.visible,
    required this.exitConfirmOpen,
    required this.onResume,
    required this.onExit,
  });

  final bool visible;
  final bool exitConfirmOpen;
  final VoidCallback onResume;
  final VoidCallback onExit;

  @override
  Widget build(BuildContext context) {
    if (!visible) return const SizedBox.shrink();
    final ui = context.ui;

    return SizedBox.expand(
      child: ColoredBox(
        color: ui.colors.shadow.withValues(alpha: 0.4),
        child: SafeArea(
          minimum: EdgeInsets.all(ui.space.md),
          child: Center(
            child: exitConfirmOpen
                ? Column(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Text(
                        'Want to exit?',
                        style: ui.text.title.copyWith(
                          color: ui.colors.textPrimary,
                          fontSize: 22,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                      SizedBox(height: ui.space.sm + ui.space.xxs / 2),
                      Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          AppButton(
                            label: 'Resume',
                            variant: AppButtonVariant.secondary,
                            size: AppButtonSize.xs,
                            onPressed: onResume,
                          ),
                          SizedBox(width: ui.space.sm),
                          AppButton(
                            label: 'Exit',
                            variant: AppButtonVariant.secondary,
                            size: AppButtonSize.xs,
                            onPressed: onExit,
                          ),
                        ],
                      ),
                    ],
                  )
                : const SizedBox.shrink(),
          ),
        ),
      ),
    );
  }
}


===== FILE: lib/ui/hud/game/player_impact_border_overlay.dart =====
import 'dart:ui';

import 'package:flutter/foundation.dart';
import 'package:flutter/widgets.dart';

import '../../theme/ui_tokens.dart';

/// Full-screen red border pulse for direct player impact feedback.
class PlayerImpactBorderOverlay extends StatelessWidget {
  const PlayerImpactBorderOverlay({super.key, required this.triggerSignal});

  final ValueListenable<int> triggerSignal;

  @override
  Widget build(BuildContext context) {
    return IgnorePointer(
      ignoring: true,
      child: ValueListenableBuilder<int>(
        valueListenable: triggerSignal,
        builder: (context, trigger, _) {
          if (trigger == 0) {
            return const SizedBox.expand();
          }
          return TweenAnimationBuilder<double>(
            key: ValueKey(trigger),
            tween: Tween<double>(begin: 1.0, end: 0.0),
            duration: const Duration(milliseconds: 340),
            curve: Curves.easeOutCubic,
            builder: (context, intensity, _) {
              if (intensity <= 0.001) {
                return const SizedBox.expand();
              }
              return CustomPaint(
                painter: _PlayerImpactBorderPainter(intensity: intensity),
                child: const SizedBox.expand(),
              );
            },
          );
        },
      ),
    );
  }
}

class _PlayerImpactBorderPainter extends CustomPainter {
  const _PlayerImpactBorderPainter({required this.intensity});

  final double intensity;
  static const Color _baseColor = UiBrandPalette.crimsonDanger;

  @override
  void paint(Canvas canvas, Size size) {
    final clamped = intensity.clamp(0.0, 1.0);
    if (clamped <= 0.0) return;

    final edgeDepth = lerpDouble(20.0, 68.0, clamped) ?? 20.0;
    final edgeAlpha = lerpDouble(0.06, 0.28, clamped) ?? 0.06;
    final strokeAlpha = lerpDouble(0.12, 0.45, clamped) ?? 0.12;
    final strokeWidth = lerpDouble(2.0, 8.0, clamped) ?? 2.0;

    _paintEdge(
      canvas,
      Rect.fromLTWH(0.0, 0.0, size.width, edgeDepth),
      begin: Alignment.topCenter,
      end: Alignment.bottomCenter,
      alpha: edgeAlpha,
    );
    _paintEdge(
      canvas,
      Rect.fromLTWH(0.0, size.height - edgeDepth, size.width, edgeDepth),
      begin: Alignment.bottomCenter,
      end: Alignment.topCenter,
      alpha: edgeAlpha,
    );
    _paintEdge(
      canvas,
      Rect.fromLTWH(0.0, 0.0, edgeDepth, size.height),
      begin: Alignment.centerLeft,
      end: Alignment.centerRight,
      alpha: edgeAlpha,
    );
    _paintEdge(
      canvas,
      Rect.fromLTWH(size.width - edgeDepth, 0.0, edgeDepth, size.height),
      begin: Alignment.centerRight,
      end: Alignment.centerLeft,
      alpha: edgeAlpha,
    );

    final strokePaint = Paint()
      ..style = PaintingStyle.stroke
      ..strokeWidth = strokeWidth
      ..color = _baseColor.withValues(alpha: strokeAlpha);
    canvas.drawRect(Offset.zero & size, strokePaint);
  }

  void _paintEdge(
    Canvas canvas,
    Rect rect, {
    required Alignment begin,
    required Alignment end,
    required double alpha,
  }) {
    final edgePaint = Paint()
      ..shader = LinearGradient(
        begin: begin,
        end: end,
        colors: <Color>[
          _baseColor.withValues(alpha: alpha),
          _baseColor.withValues(alpha: 0.0),
        ],
      ).createShader(rect);
    canvas.drawRect(rect, edgePaint);
  }

  @override
  bool shouldRepaint(_PlayerImpactBorderPainter oldDelegate) {
    return oldDelegate.intensity != intensity;
  }
}


===== FILE: lib/ui/hud/game/ready_overlay.dart =====
import 'package:flutter/widgets.dart';

import '../../theme/ui_tokens.dart';

class ReadyOverlay extends StatelessWidget {
  const ReadyOverlay({super.key, required this.visible, required this.onTap});

  final bool visible;
  final VoidCallback onTap;

  @override
  Widget build(BuildContext context) {
    if (!visible) return const SizedBox.shrink();
    final ui = context.ui;

    return GestureDetector(
      behavior: HitTestBehavior.opaque,
      onTap: onTap,
      child: ColoredBox(
        color: ui.colors.scrim.withValues(alpha: 0.53),
        child: Center(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Text(
                'Tap to start',
                style: ui.text.title.copyWith(
                  color: ui.colors.textPrimary,
                  fontSize: 28,
                  fontWeight: FontWeight.w600,
                ),
              ),
              SizedBox(height: ui.space.xs),
              Text(
                'Survive as long as possible',
                style: ui.text.body.copyWith(color: ui.colors.textMuted),
              ),
            ],
          ),
        ),
      ),
    );
  }
}


===== FILE: lib/ui/hud/game/score_overlay.dart =====
import 'package:flutter/widgets.dart';

import '../../../game/game_controller.dart';
import '../../theme/ui_tokens.dart';

class ScoreOverlay extends StatelessWidget {
  const ScoreOverlay({super.key, required this.controller, this.padding});

  final GameController controller;
  final EdgeInsets? padding;

  @override
  Widget build(BuildContext context) {
    final ui = context.ui;
    final resolvedPadding =
        padding ??
        EdgeInsets.symmetric(
          horizontal: ui.space.xs + ui.space.xxs / 2,
          vertical: ui.space.xs - ui.space.xxs / 2,
        );
    final labelStyle = ui.text.body.copyWith(
      color: ui.colors.textPrimary,
      fontFeatures: const [FontFeature.tabularFigures()],
    );
    return AnimatedBuilder(
      animation: controller,
      builder: (context, _) {
        final distanceMeters = (controller.snapshot.distance / 100.0).floor();
        final collectibles = controller.snapshot.hud.collectibles;
        return IgnorePointer(
          child: RepaintBoundary(
            child: Container(
              padding: resolvedPadding,
              decoration: BoxDecoration(
                color: ui.colors.shadow.withValues(alpha: 0.4),
                borderRadius: BorderRadius.circular(ui.radii.sm),
              ),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Text(
                    'Distance ${distanceMeters}m',
                    textAlign: TextAlign.center,
                    style: labelStyle,
                  ),
                  SizedBox(height: ui.space.xxs / 2),
                  Text(
                    'Collectibles $collectibles',
                    textAlign: TextAlign.center,
                    style: labelStyle,
                  ),
                ],
              ),
            ),
          ),
        );
      },
    );
  }
}


===== FILE: lib/ui/hud/game/start_pause_button_overlay.dart =====
import 'package:flutter/material.dart';

import '../../runner_game_ui_state.dart';
import '../../theme/ui_tokens.dart';

class StartPauseButtonOverlay extends StatelessWidget {
  const StartPauseButtonOverlay({
    super.key,
    required this.uiState,
    required this.onStart,
    required this.onTogglePause,
  });

  final RunnerGameUiState uiState;
  final VoidCallback onStart;
  final VoidCallback onTogglePause;

  @override
  Widget build(BuildContext context) {
    final ui = context.ui;
    return IconButton(
      onPressed: uiState.gameOver
          ? null
          : () {
              if (!uiState.started) {
                onStart();
                return;
              }
              onTogglePause();
            },
      icon: Icon(uiState.paused ? Icons.play_arrow : Icons.pause),
      color: ui.colors.textPrimary,
      tooltip: uiState.paused ? 'Play' : 'Pause',
    );
  }
}


===== FILE: lib/ui/hud/game/survival_timer_overlay.dart =====
import 'package:flutter/widgets.dart';

import '../../../game/game_controller.dart';
import '../../theme/ui_tokens.dart';

class SurvivalTimerOverlay extends StatelessWidget {
  const SurvivalTimerOverlay({
    super.key,
    required this.controller,
    this.padding,
  });

  final GameController controller;
  final EdgeInsets? padding;

  @override
  Widget build(BuildContext context) {
    final ui = context.ui;
    final resolvedPadding =
        padding ??
        EdgeInsets.symmetric(
          horizontal: ui.space.xs + ui.space.xxs / 2,
          vertical: ui.space.xs - ui.space.xxs / 2,
        );
    return AnimatedBuilder(
      animation: controller,
      builder: (context, _) {
        final ticks = controller.snapshot.tick;
        final hz = controller.tickHz;

        final totalSeconds = ticks ~/ hz;
        final minutes = totalSeconds ~/ 60;
        final seconds = totalSeconds % 60;

        final text =
            '${minutes.toString().padLeft(2, '0')}:${seconds.toString().padLeft(2, '0')}';

        return IgnorePointer(
          child: RepaintBoundary(
            child: Container(
              padding: resolvedPadding,
              decoration: BoxDecoration(
                color: ui.colors.shadow.withValues(alpha: 0.4),
                borderRadius: BorderRadius.circular(ui.radii.sm),
              ),
              child: Text(
                text,
                textAlign: TextAlign.center,
                style: ui.text.headline.copyWith(
                  color: ui.colors.textPrimary,
                  fontFeatures: const [FontFeature.tabularFigures()],
                ),
              ),
            ),
          ),
        );
      },
    );
  }
}


===== FILE: lib/ui/hud/game/top_center_hud_overlay.dart =====
import 'package:flutter/material.dart';

import '../../../game/game_controller.dart';
import 'survival_timer_overlay.dart';
import '../../runner_game_ui_state.dart';
import '../../theme/ui_tokens.dart';
import 'start_pause_button_overlay.dart';

class TopCenterHudOverlay extends StatelessWidget {
  const TopCenterHudOverlay({
    super.key,
    required this.controller,
    required this.uiState,
    required this.onStart,
    required this.onTogglePause,
  });

  final GameController controller;
  final RunnerGameUiState uiState;
  final VoidCallback onStart;
  final VoidCallback onTogglePause;

  @override
  Widget build(BuildContext context) {
    final ui = context.ui;
    return Align(
      alignment: Alignment.topCenter,
      child: Padding(
        padding: EdgeInsets.only(top: ui.space.xs),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            SurvivalTimerOverlay(controller: controller),
            SizedBox(width: ui.space.xs),
            StartPauseButtonOverlay(
              uiState: uiState,
              onStart: onStart,
              onTogglePause: onTogglePause,
            ),
          ],
        ),
      ),
    );
  }
}


===== FILE: lib/ui/hud/game/top_left_hud_overlay.dart =====
import 'package:flutter/widgets.dart';

import '../../../game/game_controller.dart';

class TopLeftHudOverlay extends StatelessWidget {
  const TopLeftHudOverlay({required this.controller, super.key});

  final GameController controller;

  static const double _barWidth = 140;
  static const double _barHeight = 6;
  static const double _barGap = 4;

  @override
  Widget build(BuildContext context) {
    final totalHeight = _barHeight * 3 + _barGap * 2;

    return AnimatedBuilder(
      animation: controller,
      builder: (context, _) {
        final hud = controller.snapshot.hud;
        return IgnorePointer(
          child: RepaintBoundary(
            child: SizedBox(
              width: _barWidth,
              height: totalHeight,

              child: CustomPaint(
                painter: _HudBarsPainter(
                  hp: hud.hp,
                  hpMax: hud.hpMax,
                  mana: hud.mana,
                  manaMax: hud.manaMax,
                  stamina: hud.stamina,
                  staminaMax: hud.staminaMax,
                  barWidth: _barWidth,
                  barHeight: _barHeight,
                  barGap: _barGap,
                ),
              ),
            ),
          ),
        );
      },
    );
  }
}

class _HudBarsPainter extends CustomPainter {
  _HudBarsPainter({
    required this.hp,
    required this.hpMax,
    required this.mana,
    required this.manaMax,
    required this.stamina,
    required this.staminaMax,
    required this.barWidth,
    required this.barHeight,
    required this.barGap,
  });

  final double hp;
  final double hpMax;
  final double mana;
  final double manaMax;
  final double stamina;
  final double staminaMax;
  final double barWidth;
  final double barHeight;
  final double barGap;

  static final Paint _back = Paint()..color = const Color(0xAA000000);
  static final Paint _outline = Paint()
    ..color = const Color(0xFFFFFFFF)
    ..style = PaintingStyle.stroke
    ..strokeWidth = 1;
  static final Paint _hp = Paint()..color = const Color(0xFFDC4440);
  static final Paint _mana = Paint()..color = const Color(0xFF2D98DA);
  static final Paint _stamina = Paint()..color = const Color(0xFF4CD137);

  @override
  void paint(Canvas canvas, Size size) {
    _drawBar(
      canvas,
      y: 0,
      value: hp,
      max: hpMax,
      fill: _hp,
    );
    _drawBar(
      canvas,
      y: barHeight + barGap,
      value: mana,
      max: manaMax,
      fill: _mana,
    );
    _drawBar(
      canvas,
      y: (barHeight + barGap) * 2,
      value: stamina,
      max: staminaMax,
      fill: _stamina,
    );
  }

  void _drawBar(
    Canvas canvas, {
    required double y,
    required double value,
    required double max,
    required Paint fill,
  }) {
    final backRect = Rect.fromLTWH(0, y, barWidth, barHeight);
    canvas.drawRect(backRect, _back);
    canvas.drawRect(backRect, _outline);

    if (max <= 0) return;
    final t = (value / max).clamp(0.0, 1.0);
    if (t <= 0) return;
    canvas.drawRect(Rect.fromLTWH(0, y, barWidth * t, barHeight), fill);
  }

  @override
  bool shouldRepaint(covariant _HudBarsPainter oldDelegate) {
    return hp != oldDelegate.hp ||
        hpMax != oldDelegate.hpMax ||
        mana != oldDelegate.mana ||
        manaMax != oldDelegate.manaMax ||
        stamina != oldDelegate.stamina ||
        staminaMax != oldDelegate.staminaMax ||
        barWidth != oldDelegate.barWidth ||
        barHeight != oldDelegate.barHeight ||
        barGap != oldDelegate.barGap;
  }
}


===== FILE: lib/ui/hud/game/top_right_hud_overlay.dart =====
import 'package:flutter/material.dart';

import '../../../game/game_controller.dart';
import '../../theme/ui_tokens.dart';
import 'score_overlay.dart';

class TopRightHudOverlay extends StatelessWidget {
  const TopRightHudOverlay({
    super.key,
    required this.controller,
    required this.showExitButton,
    required this.onExit,
  });

  final GameController controller;
  final bool showExitButton;
  final VoidCallback? onExit;

  @override
  Widget build(BuildContext context) {
    final ui = context.ui;
    return Align(
      alignment: Alignment.topRight,
      child: Padding(
        padding: EdgeInsets.all(ui.space.xs),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            ScoreOverlay(controller: controller),
            if (showExitButton) ...[
              SizedBox(width: ui.space.xs),
              IconButton(
                onPressed: onExit,
                icon: const Icon(Icons.close),
                color: ui.colors.textPrimary,
                disabledColor: ui.colors.textMuted,
              ),
            ],
          ],
        ),
      ),
    );
  }
}


===== FILE: lib/ui/hud/gameover/game_over_header.dart =====
import 'package:flutter/material.dart';

import '../../theme/ui_tokens.dart';

class GameOverHeader extends StatelessWidget {
  const GameOverHeader({
    super.key,
    required this.subtitleDeathReason,
    required this.displayScore,
  });

  final String? subtitleDeathReason;
  final int? displayScore;

  @override
  Widget build(BuildContext context) {
    final ui = context.ui;
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        Text(
          'Game Over',
          style: ui.text.title.copyWith(
            color: ui.colors.textPrimary,
            fontSize: 28,
            fontWeight: FontWeight.w600,
          ),
        ),
        if (subtitleDeathReason != null) ...[
          SizedBox(height: ui.space.xs),
          Text(
            subtitleDeathReason!,
            style: ui.text.body.copyWith(color: ui.colors.textPrimary),
            textAlign: TextAlign.center,
          ),
        ],
        if (displayScore != null) ...[
          SizedBox(height: ui.space.sm + ui.space.xxs / 2),
          Text(
            'Score: $displayScore',
            style: ui.text.headline.copyWith(
              color: ui.colors.textPrimary,
              fontSize: 16,
              fontWeight: FontWeight.w600,
            ),
            textAlign: TextAlign.center,
          ),
        ],
      ],
    );
  }
}


===== FILE: lib/ui/hud/gameover/game_over_overlay.dart =====
import 'package:flutter/material.dart';
import 'package:flutter/scheduler.dart';

import '../../../core/enemies/enemy_id.dart';
import '../../../core/events/game_event.dart';
import '../../../core/levels/level_id.dart';
import '../../../core/projectiles/projectile_id.dart';
import '../../../core/scoring/run_score_breakdown.dart';
import '../../../core/tuning/score_tuning.dart';
import '../../leaderboard/leaderboard_store.dart';
import '../../state/selection_state.dart';
import 'game_over_header.dart';
import 'leaderboard_panel.dart';
import 'restart_exit_buttons.dart';
import 'score_breakdown_formatter.dart';
import 'score_distribution.dart';
import 'score_feed_controller.dart';
import '../../components/app_button.dart';
import '../../theme/ui_tokens.dart';
// import '../../../core/spells/spell_id.dart';

class GameOverOverlay extends StatefulWidget {
  const GameOverOverlay({
    super.key,
    required this.visible,
    required this.onRestart,
    required this.onExit,
    required this.showExitButton,
    required this.levelId,
    required this.runType,
    required this.runEndedEvent,
    required this.scoreTuning,
    required this.tickHz,
    this.goldEarned,
    this.totalGold,
    this.leaderboardStore,
  });

  final bool visible;
  final VoidCallback onRestart;
  final VoidCallback? onExit;
  final bool showExitButton;
  final LevelId levelId;
  final RunType runType;
  final RunEndedEvent? runEndedEvent;
  final ScoreTuning scoreTuning;
  final int tickHz;
  final int? goldEarned;
  final int? totalGold;
  final LeaderboardStore? leaderboardStore;

  @override
  State<GameOverOverlay> createState() => _GameOverOverlayState();
}

class _GameOverOverlayState extends State<GameOverOverlay>
    with SingleTickerProviderStateMixin {
  late final RunScoreBreakdown _breakdown;
  late final ScoreFeedController _feedController;

  Ticker? _ticker;
  Duration _lastElapsed = Duration.zero;

  @override
  void initState() {
    super.initState();
    _breakdown = _buildBreakdown();
    _feedController = ScoreFeedController(
      rows: _breakdown.rows,
      totalPoints: _breakdown.totalPoints,
    );
  }

  RunScoreBreakdown _buildBreakdown() {
    final event = widget.runEndedEvent;
    if (event == null) {
      return const RunScoreBreakdown(rows: <RunScoreRow>[], totalPoints: 0);
    }

    return buildRunScoreBreakdown(
      tick: event.tick,
      distanceUnits: event.distance,
      collectibles: event.stats.collectibles,
      collectibleScore: event.stats.collectibleScore,
      enemyKillCounts: event.stats.enemyKillCounts,
      tuning: widget.scoreTuning,
      tickHz: widget.tickHz,
    );
  }

  Widget? _buildGoldPanel(BuildContext context) {
    final goldEarned = widget.goldEarned;
    if (goldEarned == null) return null;
    final totalGold = widget.totalGold;
    final ui = context.ui;

    final labelStyle = ui.text.body.copyWith(
      color: ui.colors.textPrimary,
      fontWeight: FontWeight.w600,
    );
    final valueStyle = ui.text.body.copyWith(
      color: ui.colors.accentStrong,
      fontWeight: FontWeight.w700,
    );

    Widget buildRow(String label, String value) {
      return Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Text('$label: ', style: labelStyle),
          Text(value, style: valueStyle),
        ],
      );
    }

    return DecoratedBox(
      decoration: BoxDecoration(
        color: ui.colors.shadow.withValues(alpha: 0.2),
        borderRadius: BorderRadius.circular(ui.radii.sm),
      ),
      child: Padding(
        padding: EdgeInsets.symmetric(
          horizontal: ui.space.sm,
          vertical: ui.space.xs,
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            buildRow('Gold earned', '+$goldEarned'),
            if (totalGold != null) ...[
              SizedBox(height: ui.space.xxs),
              buildRow('Total gold', '$totalGold'),
            ],
          ],
        ),
      ),
    );
  }

  void _startFeed() {
    if (_feedController.startFeed()) {
      _startTicker();
      setState(() {});
    }
  }

  void _startTicker() {
    _ticker?.dispose();
    _lastElapsed = Duration.zero;
    _ticker = createTicker(_onTick)..start();
  }

  void _stopTicker() {
    final ticker = _ticker;
    if (ticker == null) return;
    ticker.stop();
    ticker.dispose();
    _ticker = null;
  }

  void _onTick(Duration elapsed) {
    if (_feedController.feedState != ScoreFeedState.feeding) return;

    final dt = (elapsed - _lastElapsed).inMicroseconds.toDouble() / 1000000.0;
    _lastElapsed = elapsed;
    if (dt <= 0) return;

    final changed = _feedController.tick(dt);
    if (_feedController.feedState == ScoreFeedState.complete) {
      _stopTicker();
    }
    if (changed && mounted) setState(() {});
  }

  void _completeFeed() {
    _feedController.completeFeed();
    _stopTicker();
  }

  void _onCollectPressed() {
    if (_feedController.feedState == ScoreFeedState.idle) {
      _startFeed();
      return;
    }
    if (_feedController.feedState == ScoreFeedState.feeding) {
      _completeFeed();
      setState(() {});
    }
  }

  void _completeThen(VoidCallback? action) {
    if (_feedController.feedState != ScoreFeedState.complete) {
      _completeFeed();
      setState(() {});
    }
    if (action == null) return;
    WidgetsBinding.instance.addPostFrameCallback((_) => action());
  }

  @override
  void dispose() {
    _stopTicker();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    if (!widget.visible) return const SizedBox.shrink();
    final ui = context.ui;

    final subtitleDeathReason = _buildSubtitleDeathReason(widget.runEndedEvent);
    final showCollectButton =
        _feedController.totalPoints > 0 &&
        _feedController.feedState != ScoreFeedState.complete;
    final showScoreInHeader =
        _feedController.feedState == ScoreFeedState.complete;
    final collectLabel = _feedController.feedState == ScoreFeedState.idle
        ? 'Collect Score'
        : 'Skip';
    final goldPanel = _buildGoldPanel(context);
    final rowLabels = [
      for (var i = 0; i < _feedController.rows.length; i += 1)
        formatScoreRow(
          _feedController.rows[i].row,
          _feedController.rows[i].remainingPoints,
          enemyName: _enemyName,
        ),
    ];

    return SizedBox.expand(
      child: ColoredBox(
        color: ui.colors.scrim.withValues(alpha: 0.53),
        child: SafeArea(
          minimum: EdgeInsets.all(ui.space.md),
          child: Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Expanded(
                flex: 2,
                child: Align(
                  alignment: Alignment.topCenter,
                  child: Column(
                    mainAxisSize: MainAxisSize.max,
                    children: [
                      GameOverHeader(
                        subtitleDeathReason: subtitleDeathReason,
                        displayScore: showScoreInHeader
                            ? _feedController.displayScore
                            : null,
                      ),
                      if (goldPanel != null) ...[
                        SizedBox(height: ui.space.xs + ui.space.xxs / 2),
                        goldPanel,
                      ],
                      SizedBox(height: ui.space.sm + ui.space.xxs / 2),
                      if (showCollectButton)
                        AppButton(
                          label: collectLabel,
                          variant: AppButtonVariant.secondary,
                          size: AppButtonSize.md,
                          onPressed: _onCollectPressed,
                        )
                      else
                        RestartExitButtons(
                          restartButton: AppButton(
                            label: 'Restart',
                            variant: AppButtonVariant.secondary,
                            size: AppButtonSize.xs,
                            onPressed: () => _completeThen(widget.onRestart),
                          ),
                          exitButton: widget.showExitButton
                              ? AppButton(
                                  label: 'Exit',
                                  variant: AppButtonVariant.secondary,
                                  size: AppButtonSize.xs,
                                  onPressed: () => _completeThen(widget.onExit),
                                )
                              : null,
                        ),
                      SizedBox(height: ui.space.md),
                      Flexible(child: ScoreDistribution(rowLabels: rowLabels)),
                    ],
                  ),
                ),
              ),
              Expanded(
                flex: 1,
                child: Align(
                  alignment: Alignment.topCenter,
                  child: LeaderboardPanel(
                    levelId: widget.levelId,
                    runType: widget.runType,
                    runEndedEvent: widget.runEndedEvent,
                    scoreTuning: widget.scoreTuning,
                    tickHz: widget.tickHz,
                    revealCurrentRunScore:
                        _feedController.feedState == ScoreFeedState.complete,
                    leaderboardStore: widget.leaderboardStore,
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

String? _buildSubtitleDeathReason(RunEndedEvent? event) {
  if (event == null) return null;
  switch (event.reason) {
    case RunEndReason.gaveUp:
      return 'You gave up the run.';
    case RunEndReason.fellBehindCamera:
      return 'You fell behind.';
    case RunEndReason.fellIntoGap:
      return 'You fell into a gap.';
    case RunEndReason.playerDied:
      return _buildDeathSubtitle(event.deathInfo);
  }
}

String _buildDeathSubtitle(DeathInfo? info) {
  if (info == null) return 'You died.';
  switch (info.kind) {
    case DeathSourceKind.projectile:
      return _buildProjectileDeath(info);
    case DeathSourceKind.meleeHitbox:
      return _buildMeleeDeath(info);
    case DeathSourceKind.statusEffect:
      return 'You succumbed to a status effect.';
    case DeathSourceKind.unknown:
      return 'You died.';
  }
}

String _buildProjectileDeath(DeathInfo info) {
  final projectileId = info.projectileId;
  if (projectileId == null) return 'You died.';
  final projectileName = _projectileName(projectileId);
  /* final spellName =
      info.spellId == null ? null : _spellName(info.spellId!); */
  final enemyName = info.enemyId == null ? null : _enemyName(info.enemyId!);

  final buffer = StringBuffer('Killed by $projectileName');
  /*   if (spellName != null) {
    buffer.write(' ($spellName)');
  } */
  if (enemyName != null) {
    buffer.write(' from $enemyName.');
  } else {
    buffer.write('.');
  }
  return buffer.toString();
}

String _buildMeleeDeath(DeathInfo info) {
  if (info.enemyId == null) return 'You died.';
  return 'Killed by a melee strike from a ${_enemyName(info.enemyId!)}.';
}

String _enemyName(EnemyId id) {
  switch (id) {
    case EnemyId.unocoDemon:
      return 'Unoco Demon';
    case EnemyId.grojib:
      return 'Ground enemy';
  }
}

String _projectileName(ProjectileId id) {
  switch (id) {
    case ProjectileId.unknown:
      return 'Unknown Projectile';
    case ProjectileId.iceBolt:
      return 'Ice Bolt';
    case ProjectileId.thunderBolt:
      return 'thunder Bolt';
    case ProjectileId.fireBolt:
      return 'Fire Bolt';
    case ProjectileId.acidBolt:
      return 'Acid Bolt';
    case ProjectileId.darkBolt:
      return 'Dark Bolt';
    case ProjectileId.earthBolt:
      return 'Earth Bolt';
    case ProjectileId.holyBolt:
      return 'Holy Bolt';
    case ProjectileId.waterBolt:
      return 'Water Bolt';
    case ProjectileId.throwingAxe:
      return 'Throwing Axe';
    case ProjectileId.throwingKnife:
      return 'Throwing Knife';
  }
}

/* String _spellName(SpellId id) {
  switch (id) {
    case SpellId.iceBolt:
      return 'Ice Bolt';
    case SpellId.thunderBolt:
      return 'thunder';
  }
} */


===== FILE: lib/ui/hud/gameover/leaderboard_panel.dart =====
import 'dart:math' as math;

import 'package:flutter/material.dart';

import '../../../core/events/game_event.dart';
import '../../../core/levels/level_id.dart';
import '../../../core/tuning/score_tuning.dart';
import '../../components/leaderboard_table.dart';
import '../../leaderboard/leaderboard_store.dart';
import '../../leaderboard/run_result.dart';
import '../../leaderboard/shared_prefs_leaderboard_store.dart';
import '../../levels/level_id_ui.dart';
import '../../state/selection_state.dart';
import '../../theme/ui_leaderboard_theme.dart';
import '../../theme/ui_tokens.dart';

class LeaderboardPanel extends StatefulWidget {
  const LeaderboardPanel({
    super.key,
    required this.levelId,
    required this.runType,
    required this.runEndedEvent,
    required this.scoreTuning,
    required this.tickHz,
    this.revealCurrentRunScore = true,
    this.leaderboardStore,
  });

  final LevelId levelId;
  final RunType runType;
  final RunEndedEvent? runEndedEvent;
  final ScoreTuning scoreTuning;
  final int tickHz;
  final bool revealCurrentRunScore;
  final LeaderboardStore? leaderboardStore;

  @override
  State<LeaderboardPanel> createState() => _LeaderboardPanelState();
}

class _LeaderboardPanelState extends State<LeaderboardPanel> {
  late final LeaderboardStore _store;
  List<RunResult> _entries = const <RunResult>[];
  int? _currentRunId;
  bool _loaded = false;

  @override
  void initState() {
    super.initState();
    _store = widget.leaderboardStore ?? SharedPrefsLeaderboardStore();
    _loadLeaderboard();
  }

  Future<void> _loadLeaderboard() async {
    final event = widget.runEndedEvent;
    if (event == null) {
      final entries = await _store.loadTop10(
        levelId: widget.levelId,
        runType: widget.runType,
      );
      if (!mounted) return;
      setState(() {
        _entries = entries;
        _loaded = true;
      });
      return;
    }

    final draft = buildRunResult(
      event: event,
      scoreTuning: widget.scoreTuning,
      tickHz: widget.tickHz,
      endedAtMs: DateTime.now().millisecondsSinceEpoch,
    );
    final snapshot = await _store.addResult(
      levelId: widget.levelId,
      runType: widget.runType,
      result: draft,
    );
    if (!mounted) return;
    setState(() {
      _entries = snapshot.entries;
      _currentRunId = snapshot.current.runId;
      _loaded = true;
    });
  }

  @override
  Widget build(BuildContext context) {
    final ui = context.ui;
    final runTypeLabel = switch (widget.runType) {
      RunType.practice => 'Practice',
      RunType.competitive => 'Competitive',
    };
    final titleStyle = ui.text.body.copyWith(
      color: ui.colors.textPrimary,
      fontWeight: FontWeight.w600,
    );
    final spec = context.leaderboards.resolveSpec(ui: ui);
    final textStyle = spec.rowTextStyle;

    Widget content;
    if (!_loaded) {
      content = const Center(child: Text('Loading leaderboard...'));
    } else if (_entries.isEmpty) {
      content = const Center(child: Text('No runs yet.'));
    } else {
      content = LeaderboardTable(
        entries: _entries,
        highlightRunId: _currentRunId,
        hideScoreForRunId: widget.revealCurrentRunScore ? null : _currentRunId,
        inset: false,
        scrollable: true,
      );
    }

    return LayoutBuilder(
      builder: (context, constraints) {
        final maxHeight = constraints.maxHeight;
        final height = maxHeight.isFinite ? math.min(maxHeight, 360.0) : null;

        final styledContent = DefaultTextStyle(
          style: textStyle,
          child: content,
        );

        final body = Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              '${widget.levelId.displayName} $runTypeLabel Scoreboard',
              style: titleStyle,
            ),
            SizedBox(height: ui.space.xs),
            if (height == null)
              styledContent
            else
              Expanded(child: styledContent),
          ],
        );

        final panel = ConstrainedBox(
          constraints: const BoxConstraints(maxWidth: 240),
          child: DecoratedBox(
            decoration: BoxDecoration(
              color: ui.colors.shadow.withValues(alpha: 0.4),
              borderRadius: BorderRadius.circular(ui.radii.sm),
            ),
            child: Padding(padding: EdgeInsets.all(ui.space.sm), child: body),
          ),
        );

        if (height == null) return panel;
        return SizedBox(height: height, child: panel);
      },
    );
  }
}


===== FILE: lib/ui/hud/gameover/restart_exit_buttons.dart =====
import 'package:flutter/material.dart';

class RestartExitButtons extends StatelessWidget {
  const RestartExitButtons({
    super.key,
    required this.restartButton,
    this.exitButton,
    this.trailingButton,
  });

  final Widget restartButton;
  final Widget? exitButton;
  final Widget? trailingButton;

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      width: double.infinity,
      child: Stack(
        alignment: Alignment.center,
        children: [
          Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              restartButton,
              if (exitButton != null) ...[
                const SizedBox(width: 12),
                exitButton!,
              ],
            ],
          ),
          if (trailingButton != null)
            Align(alignment: Alignment.centerRight, child: trailingButton),
        ],
      ),
    );
  }
}


===== FILE: lib/ui/hud/gameover/score_breakdown_formatter.dart =====
import '../../../core/enemies/enemy_id.dart';
import '../../../core/scoring/run_score_breakdown.dart';

String formatScoreRow(
  RunScoreRow row,
  int remainingPoints, {
  required String Function(EnemyId id) enemyName,
}) {
  switch (row.kind) {
    case RunScoreRowKind.distance:
      return 'Distance: ${row.count}m -> $remainingPoints';
    case RunScoreRowKind.time:
      return 'Time: ${_formatTime(row.count)} -> $remainingPoints';
    case RunScoreRowKind.collectibles:
      return 'Collectibles: ${row.count} -> $remainingPoints';
    case RunScoreRowKind.enemyKill:
      final name = row.enemyId == null ? 'Enemy' : enemyName(row.enemyId!);
      return '$name x${row.count} -> $remainingPoints';
  }
}

String _formatTime(int totalSeconds) {
  final minutes = totalSeconds ~/ 60;
  final seconds = totalSeconds % 60;
  return '${minutes.toString().padLeft(2, '0')}:${seconds.toString().padLeft(2, '0')}';
}


===== FILE: lib/ui/hud/gameover/score_distribution.dart =====
import 'package:flutter/material.dart';

import '../../theme/ui_tokens.dart';

class ScoreDistribution extends StatelessWidget {
  const ScoreDistribution({super.key, required this.rowLabels});

  final List<String> rowLabels;

  @override
  Widget build(BuildContext context) {
    final ui = context.ui;
    return Scrollbar(
      child: SingleChildScrollView(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            for (var i = 0; i < rowLabels.length; i += 1) ...[
              Text(
                rowLabels[i],
                style: ui.text.body.copyWith(
                  color: ui.colors.textPrimary,
                  fontWeight: FontWeight.w500,
                ),
                textAlign: TextAlign.center,
              ),
              if (i < rowLabels.length - 1) SizedBox(height: ui.space.xxs),
            ],
          ],
        ),
      ),
    );
  }
}


===== FILE: lib/ui/hud/gameover/score_feed_controller.dart =====
import '../../../core/scoring/run_score_breakdown.dart';

enum ScoreFeedState { idle, feeding, complete }

class ScoreFeedRowState {
  ScoreFeedRowState({
    required this.row,
    required this.pointsPerSecond,
  }) : remainingPoints = row.points;

  final RunScoreRow row;
  final double pointsPerSecond;
  int remainingPoints;
  double carry = 0.0;
}

class ScoreFeedController {
  ScoreFeedController({
    required List<RunScoreRow> rows,
    required this.totalPoints,
    double feedDurationSeconds = 0.8,
  }) : _rows = [
          for (final row in rows)
            ScoreFeedRowState(
              row: row,
              pointsPerSecond:
                  row.points <= 0 ? 0.0 : row.points / feedDurationSeconds,
            ),
        ],
        displayScore = 0,
        feedState =
            totalPoints > 0 ? ScoreFeedState.idle : ScoreFeedState.complete;

  final int totalPoints;
  final List<ScoreFeedRowState> _rows;

  int displayScore;
  ScoreFeedState feedState;

  List<ScoreFeedRowState> get rows => _rows;

  bool startFeed() {
    if (feedState != ScoreFeedState.idle || totalPoints <= 0) return false;
    feedState = ScoreFeedState.feeding;
    return true;
  }

  bool tick(double dtSeconds) {
    if (feedState != ScoreFeedState.feeding || dtSeconds <= 0) {
      return false;
    }

    var gained = 0;
    var anyRemaining = false;

    for (final row in _rows) {
      if (row.remainingPoints <= 0 || row.pointsPerSecond <= 0) continue;
      row.carry += dtSeconds * row.pointsPerSecond;
      final raw = row.carry.floor();
      if (raw <= 0) {
        anyRemaining = true;
        continue;
      }
      row.carry -= raw;
      final consume =
          raw > row.remainingPoints ? row.remainingPoints : raw;
      row.remainingPoints -= consume;
      gained += consume;
      if (row.remainingPoints > 0) anyRemaining = true;
    }

    if (gained > 0) {
      displayScore += gained;
      if (displayScore > totalPoints) displayScore = totalPoints;
    }

    if (!anyRemaining) {
      completeFeed();
      return true;
    }

    return gained > 0;
  }

  void completeFeed() {
    displayScore = totalPoints;
    for (final row in _rows) {
      row.remainingPoints = 0;
      row.carry = 0.0;
    }
    feedState = ScoreFeedState.complete;
  }
}


===== FILE: lib/ui/icons/projectile_icon_frame.dart =====
import 'dart:async';
import 'dart:ui' as ui;

import 'package:flutter/material.dart';

import '../../core/contracts/render_anim_set_definition.dart';
import '../../core/projectiles/projectile_id.dart';
import '../../core/projectiles/projectile_render_catalog.dart';
import '../../core/snapshots/enums.dart';

/// Displays the first frame of a projectile's idle animation as an icon.
///
/// Extracts the source rect from [ProjectileRenderCatalog] metadata (handles
/// strips, multi-row sheets, and grid layouts). Falls back to a transparent
/// box when the projectile has no idle animation.
class ProjectileIconFrame extends StatefulWidget {
  const ProjectileIconFrame({
    super.key,
    required this.projectileId,
    this.size = 32,
  });

  final ProjectileId projectileId;
  final double size;

  @override
  State<ProjectileIconFrame> createState() => _ProjectileIconFrameState();
}

class _ProjectileIconFrameState extends State<ProjectileIconFrame> {
  static const ProjectileRenderCatalog _catalog = ProjectileRenderCatalog();

  ui.Image? _image;
  Rect _srcRect = Rect.zero;
  String? _loadedAsset;

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    _resolveImage();
  }

  @override
  void didUpdateWidget(ProjectileIconFrame oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.projectileId != widget.projectileId) {
      _resolveImage();
    }
  }

  void _resolveImage() {
    if (widget.projectileId == ProjectileId.unknown) {
      _image = null;
      return;
    }

    final anim = _catalog.get(widget.projectileId);
    final source = anim.sourcesByKey[AnimKey.idle];
    if (source == null) {
      _image = null;
      return;
    }

    _srcRect = _firstFrameRect(anim);
    final assetPath = 'assets/images/$source';

    // Avoid reloading the same asset.
    if (assetPath == _loadedAsset && _image != null) return;
    _loadedAsset = assetPath;

    final provider = AssetImage(assetPath);
    final stream = provider.resolve(ImageConfiguration.empty);
    final completer = Completer<ui.Image>();
    final listener = ImageStreamListener(
      (info, _) => completer.complete(info.image),
      onError: (error, _) => completer.completeError(error),
    );
    stream.addListener(listener);
    completer.future.then((image) {
      if (!mounted) return;
      setState(() => _image = image);
    }).ignore();
  }

  @override
  Widget build(BuildContext context) {
    final size = widget.size;
    if (_image == null) return SizedBox.square(dimension: size);
    return CustomPaint(
      size: Size.square(size),
      painter: _FramePainter(image: _image!, srcRect: _srcRect),
    );
  }

  /// Computes the source rectangle for the first frame of [AnimKey.idle].
  static Rect _firstFrameRect(RenderAnimSetDefinition anim) {
    final row = anim.rowByKey[AnimKey.idle] ?? 0;
    final frameStart = anim.frameStartByKey[AnimKey.idle] ?? 0;
    final gridColumns = anim.gridColumnsByKey[AnimKey.idle];

    final double left;
    final double top;

    if (gridColumns != null) {
      // Grid layout: frameStart is a column index within the row.
      final col = frameStart % gridColumns;
      left = col * anim.frameWidth.toDouble();
      top = row * anim.frameHeight.toDouble();
    } else {
      // Horizontal strip: frameStart is an absolute frame index on that row.
      left = frameStart * anim.frameWidth.toDouble();
      top = row * anim.frameHeight.toDouble();
    }

    return Rect.fromLTWH(
      left,
      top,
      anim.frameWidth.toDouble(),
      anim.frameHeight.toDouble(),
    );
  }
}

class _FramePainter extends CustomPainter {
  _FramePainter({required this.image, required this.srcRect});

  final ui.Image image;
  final Rect srcRect;

  @override
  void paint(Canvas canvas, Size canvasSize) {
    final dstRect = Offset.zero & canvasSize;
    canvas.drawImageRect(image, srcRect, dstRect, Paint());
  }

  @override
  bool shouldRepaint(_FramePainter old) =>
      image != old.image || srcRect != old.srcRect;
}


===== FILE: lib/ui/icons/throwing_weapon_asset.dart =====
import '../../core/projectiles/projectile_catalog.dart';
import '../../core/projectiles/projectile_id.dart';
import '../../core/abilities/ability_def.dart' show WeaponType;

String? throwingWeaponAssetPath(
  ProjectileId id, {
  ProjectileCatalog catalog = const ProjectileCatalog(),
}) {
  final def = catalog.tryGet(id);
  if (def == null || def.weaponType != WeaponType.throwingWeapon) return null;
  return switch (id) {
    ProjectileId.unknown => null,
    ProjectileId.throwingKnife =>
      'assets/images/weapons/throwingWeapons/throwingKnife.png',
    ProjectileId.throwingAxe =>
      'assets/images/weapons/throwingWeapons/throwingAxe.png',
    ProjectileId.iceBolt => null,
    ProjectileId.fireBolt => null,
    ProjectileId.acidBolt => null,
    ProjectileId.darkBolt => null,
    ProjectileId.earthBolt => null,
    ProjectileId.holyBolt => null,
    ProjectileId.waterBolt => null,
    ProjectileId.thunderBolt => null,
  };
}


===== FILE: lib/ui/icons/ui_icon_coords.dart =====
import '../../core/accessories/accessory_id.dart';
import '../../core/spellBook/spell_book_id.dart';
import '../../core/weapons/weapon_id.dart';

class UiIconCoords {
  const UiIconCoords(this.row, this.col);

  final int row;
  final int col;
}

UiIconCoords? uiIconCoordsForWeapon(WeaponId id) {
  return switch (id) {
    WeaponId.woodenSword => const UiIconCoords(5, 0),
    WeaponId.basicSword => const UiIconCoords(5, 1),
    WeaponId.solidSword => const UiIconCoords(5, 2),
    WeaponId.woodenShield => const UiIconCoords(6, 0),
    WeaponId.basicShield => const UiIconCoords(6, 1),
    WeaponId.solidShield => const UiIconCoords(6, 2),
  };
}

UiIconCoords? uiIconCoordsForSpellBook(SpellBookId id) {
  return switch (id) {
    SpellBookId.basicSpellBook => const UiIconCoords(13, 0),
    SpellBookId.solidSpellBook => const UiIconCoords(13, 1),
    SpellBookId.epicSpellBook => const UiIconCoords(13, 2),
  };
}

UiIconCoords? uiIconCoordsForAccessory(AccessoryId id) {
  return switch (id) {
    AccessoryId.speedBoots => const UiIconCoords(8, 2),
    AccessoryId.goldenRing => const UiIconCoords(8, 4),
    AccessoryId.teethNecklace => const UiIconCoords(8, 8),
  };
}

const UiIconCoords swapGearIconCoords = UiIconCoords(2, 6);


===== FILE: lib/ui/icons/ui_icon_tile.dart =====
import 'dart:ui' as ui;

import 'package:flutter/material.dart';

import 'ui_icon_coords.dart';

class UiIconTile extends StatefulWidget {
  const UiIconTile({
    super.key,
    required this.coords,
    this.size = 32,
    this.assetPath = _defaultAssetPath,
    this.tilePx = _defaultTilePx,
    this.backgroundColor,
  });

  final UiIconCoords coords;
  final double size;
  final String assetPath;
  final int tilePx;
  final Color? backgroundColor;

  static const String _defaultAssetPath =
      'assets/images/icons/transparentIcons.png';
  static const int _defaultTilePx = 32;

  @override
  State<UiIconTile> createState() => _UiIconTileState();
}

class _UiIconTileState extends State<UiIconTile> {
  ImageStream? _stream;
  ImageStreamListener? _listener;
  ui.Image? _image;

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    _resolve();
  }

  @override
  void didUpdateWidget(covariant UiIconTile oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.assetPath != widget.assetPath) {
      _resolve();
    }
  }

  void _resolve() {
    _unsubscribe();
    final provider = AssetImage(widget.assetPath);
    final stream = provider.resolve(createLocalImageConfiguration(context));
    _stream = stream;
    _listener = ImageStreamListener((info, _) {
      if (!mounted) return;
      setState(() => _image = info.image);
    });
    stream.addListener(_listener!);
  }

  void _unsubscribe() {
    final listener = _listener;
    final stream = _stream;
    if (listener != null && stream != null) {
      stream.removeListener(listener);
    }
    _listener = null;
    _stream = null;
  }

  @override
  void dispose() {
    _unsubscribe();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return CustomPaint(
      size: Size.square(widget.size),
      painter: _UiIconTilePainter(
        image: _image,
        row: widget.coords.row,
        col: widget.coords.col,
        tilePx: widget.tilePx,
        backgroundColor: widget.backgroundColor,
      ),
    );
  }
}

class _UiIconTilePainter extends CustomPainter {
  const _UiIconTilePainter({
    required this.image,
    required this.row,
    required this.col,
    required this.tilePx,
    required this.backgroundColor,
  });

  final ui.Image? image;
  final int row;
  final int col;
  final int tilePx;
  final Color? backgroundColor;

  @override
  void paint(Canvas canvas, Size size) {
    final bg = backgroundColor;
    if (bg != null) {
      canvas.drawRect(Offset.zero & size, Paint()..color = bg);
    }

    final img = image;
    if (img == null) return;

    final src = Rect.fromLTWH(
      col * tilePx.toDouble(),
      row * tilePx.toDouble(),
      tilePx.toDouble(),
      tilePx.toDouble(),
    );
    final dst = Offset.zero & size;
    canvas.drawImageRect(img, src, dst, Paint());
  }

  @override
  bool shouldRepaint(covariant _UiIconTilePainter oldDelegate) {
    return oldDelegate.image != image ||
        oldDelegate.row != row ||
        oldDelegate.col != col ||
        oldDelegate.tilePx != tilePx ||
        oldDelegate.backgroundColor != backgroundColor;
  }
}


===== FILE: lib/ui/leaderboard/leaderboard_store.dart =====
import '../../core/levels/level_id.dart';
import '../state/selection_state.dart';

import 'run_result.dart';

class LeaderboardSnapshot {
  const LeaderboardSnapshot({required this.entries, required this.current});

  final List<RunResult> entries;
  final RunResult current;
}

abstract class LeaderboardStore {
  Future<LeaderboardSnapshot> addResult({
    required LevelId levelId,
    required RunType runType,
    required RunResult result,
  });

  Future<List<RunResult>> loadTop10({
    required LevelId levelId,
    required RunType runType,
  });
}


===== FILE: lib/ui/leaderboard/run_result.dart =====
import '../../core/events/game_event.dart';
import '../../core/scoring/run_score_breakdown.dart';
import '../../core/tuning/score_tuning.dart';

class RunResult {
  const RunResult({
    required this.runId,
    required this.endedAtMs,
    required this.endedReason,
    required this.score,
    required this.distanceMeters,
    required this.durationSeconds,
    required this.tick,
  });

  final int runId;
  final int endedAtMs;
  final RunEndReason endedReason;
  final int score;
  final int distanceMeters;
  final int durationSeconds;
  final int tick;

  RunResult copyWith({
    int? runId,
    int? endedAtMs,
  }) {
    return RunResult(
      runId: runId ?? this.runId,
      endedAtMs: endedAtMs ?? this.endedAtMs,
      endedReason: endedReason,
      score: score,
      distanceMeters: distanceMeters,
      durationSeconds: durationSeconds,
      tick: tick,
    );
  }

  Map<String, dynamic> toJson() => <String, dynamic>{
        'runId': runId,
        'endedAtMs': endedAtMs,
        'endedReason': endedReason.name,
        'score': score,
        'distanceMeters': distanceMeters,
        'durationSeconds': durationSeconds,
        'tick': tick,
      };

  static RunResult fromJson(Map<String, dynamic> json) {
    final reasonName = json['endedReason'] as String?;
    final reason = _reasonFromName(reasonName);
    return RunResult(
      runId: json['runId'] as int? ?? 0,
      endedAtMs: json['endedAtMs'] as int? ?? 0,
      endedReason: reason,
      score: json['score'] as int? ?? 0,
      distanceMeters: json['distanceMeters'] as int? ?? 0,
      durationSeconds: json['durationSeconds'] as int? ?? 0,
      tick: json['tick'] as int? ?? 0,
    );
  }

  static RunEndReason _reasonFromName(String? name) {
    if (name == null) return RunEndReason.playerDied;
    for (final value in RunEndReason.values) {
      if (value.name == name) return value;
    }
    return RunEndReason.playerDied;
  }
}

RunResult buildRunResult({
  required RunEndedEvent event,
  required ScoreTuning scoreTuning,
  required int tickHz,
  required int endedAtMs,
}) {
  final breakdown = buildRunScoreBreakdown(
    tick: event.tick,
    distanceUnits: event.distance,
    collectibles: event.stats.collectibles,
    collectibleScore: event.stats.collectibleScore,
    enemyKillCounts: event.stats.enemyKillCounts,
    tuning: scoreTuning,
    tickHz: tickHz,
  );

  final distanceMeters = (event.distance / kWorldUnitsPerMeter).floor();
  final durationSeconds = tickHz <= 0 ? 0 : event.tick ~/ tickHz;

  return RunResult(
    runId: 0,
    endedAtMs: endedAtMs,
    endedReason: event.reason,
    score: breakdown.totalPoints,
    distanceMeters: distanceMeters,
    durationSeconds: durationSeconds,
    tick: event.tick,
  );
}


===== FILE: lib/ui/leaderboard/shared_prefs_leaderboard_store.dart =====
import 'dart:convert';

import 'package:shared_preferences/shared_preferences.dart';

import '../../core/levels/level_id.dart';
import '../state/selection_state.dart';
import 'leaderboard_store.dart';
import 'run_result.dart';

class SharedPrefsLeaderboardStore implements LeaderboardStore {
  // v3: namespace leaderboards by run type.
  static const String _entriesKeyPrefix = 'leaderboard_v3_entries_';
  static const String _nextIdKeyPrefix = 'leaderboard_v3_next_id_';

  // v2: legacy keys (per-level only). Kept for best-effort migration/read.
  static const String _legacyEntriesKeyPrefix = 'leaderboard_v2_entries_';
  static const String _legacyNextIdKeyPrefix = 'leaderboard_v2_next_id_';

  String _entriesKey(LevelId levelId, RunType runType) =>
      '$_entriesKeyPrefix${levelId.name}_${runType.name}';

  String _nextIdKey(LevelId levelId, RunType runType) =>
      '$_nextIdKeyPrefix${levelId.name}_${runType.name}';

  String _legacyEntriesKey(LevelId levelId) =>
      '$_legacyEntriesKeyPrefix${levelId.name}';

  String _legacyNextIdKey(LevelId levelId) =>
      '$_legacyNextIdKeyPrefix${levelId.name}';

  @override
  Future<LeaderboardSnapshot> addResult({
    required LevelId levelId,
    required RunType runType,
    required RunResult result,
  }) async {
    final prefs = await SharedPreferences.getInstance();

    final existingNextId = prefs.getInt(_nextIdKey(levelId, runType));
    final entries = _loadEntries(prefs, levelId, runType);
    final nextId =
        existingNextId ??
        _nextIdFromLegacyOrEntries(
          prefs: prefs,
          levelId: levelId,
          runType: runType,
          entries: entries,
        );
    final stored = result.copyWith(runId: nextId);
    // Defensive: avoid duplicate runIds (possible when mixing legacy and v3
    // data on first write after upgrade).
    entries.removeWhere((e) => e.runId == stored.runId);
    entries.add(stored);
    entries.sort(_compare);

    final unique = _dedupeByRunId(entries);
    final top = unique.length > 10 ? unique.sublist(0, 10) : unique;
    await prefs.setString(_entriesKey(levelId, runType), _encode(top));
    await prefs.setInt(_nextIdKey(levelId, runType), nextId + 1);

    return LeaderboardSnapshot(
      entries: List<RunResult>.unmodifiable(top),
      current: stored,
    );
  }

  @override
  Future<List<RunResult>> loadTop10({
    required LevelId levelId,
    required RunType runType,
  }) async {
    final prefs = await SharedPreferences.getInstance();
    final entries = _loadEntries(prefs, levelId, runType);
    entries.sort(_compare);
    final unique = _dedupeByRunId(entries);
    if (unique.length > 10) {
      return List<RunResult>.unmodifiable(unique.sublist(0, 10));
    }
    return List<RunResult>.unmodifiable(unique);
  }

  List<RunResult> _loadEntries(
    SharedPreferences prefs,
    LevelId levelId,
    RunType runType,
  ) {
    final primary = prefs.getString(_entriesKey(levelId, runType));
    final raw = (primary == null || primary.isEmpty)
        ? _loadLegacy(prefs, levelId, runType)
        : primary;
    if (raw == null || raw.isEmpty) return <RunResult>[];

    final decoded = jsonDecode(raw);
    if (decoded is! List) return <RunResult>[];

    final entries = <RunResult>[];
    for (final entry in decoded) {
      if (entry is Map<String, dynamic>) {
        entries.add(RunResult.fromJson(entry));
      } else if (entry is Map) {
        entries.add(RunResult.fromJson(Map<String, dynamic>.from(entry)));
      }
    }
    return entries;
  }

  String? _loadLegacy(
    SharedPreferences prefs,
    LevelId levelId,
    RunType runType,
  ) {
    // Best-effort: if a user upgrades from v2, show the legacy per-level
    // scores under practice so the leaderboard isn't empty.
    if (runType != RunType.practice) return null;
    final legacy = prefs.getString(_legacyEntriesKey(levelId));
    if (legacy == null || legacy.isEmpty) return null;
    return legacy;
  }

  String _encode(List<RunResult> entries) {
    return jsonEncode(entries.map((entry) => entry.toJson()).toList());
  }

  int _nextIdFromLegacyOrEntries({
    required SharedPreferences prefs,
    required LevelId levelId,
    required RunType runType,
    required List<RunResult> entries,
  }) {
    // Only attempt v2->v3 continuity for practice leaderboards.
    if (runType != RunType.practice) return 1;

    final legacyNextId = prefs.getInt(_legacyNextIdKey(levelId));
    if (legacyNextId != null && legacyNextId > 0) {
      return legacyNextId;
    }

    // Fall back to the highest runId we can see in the loaded entries (which
    // may be legacy data when v3 is empty) to avoid duplicate runIds.
    var maxId = 0;
    for (final entry in entries) {
      if (entry.runId > maxId) maxId = entry.runId;
    }
    return maxId > 0 ? maxId + 1 : 1;
  }

  List<RunResult> _dedupeByRunId(List<RunResult> sortedEntries) {
    // Keep the highest-ranked entry for each runId (the list is already sorted
    // best-first).
    final seen = <int>{};
    final unique = <RunResult>[];
    for (final entry in sortedEntries) {
      if (seen.add(entry.runId)) unique.add(entry);
    }
    return unique;
  }

  int _compare(RunResult a, RunResult b) {
    if (a.score != b.score) return b.score.compareTo(a.score);
    if (a.endedAtMs != b.endedAtMs) {
      return b.endedAtMs.compareTo(a.endedAtMs);
    }
    return b.runId.compareTo(a.runId);
  }
}


===== FILE: lib/ui/levels/level_id_ui.dart =====
import '../../core/levels/level_id.dart';
import '../../core/levels/level_registry.dart';

/// UI-layer extensions for [LevelId].
extension LevelIdUi on LevelId {
  /// Human-readable display name for the level.
  String get displayName {
    switch (this) {
      case LevelId.forest:
        return 'Forest';
      case LevelId.field:
        return 'Field';
    }
  }

  /// Theme identifier used for asset lookup.
  ///
  /// Resolves through [LevelRegistry] to get the authoritative themeId.
  /// Returns 'field' as fallback if the level has no theme set.
  String get themeId => LevelRegistry.byId(this).themeId ?? 'field';
}


===== FILE: lib/ui/pages/hub/components/hub_menu_icon_column.dart =====
import 'package:flutter/material.dart';

import '../../../components/app_icon_button.dart';

/// Hub navigation icon column shown on the left side of the play hub.
class HubMenuIconColumn extends StatelessWidget {
  const HubMenuIconColumn({
    super.key,
    required this.onCodexPressed,
    required this.onTownPressed,
    required this.onProfilePressed,
    required this.onLeaderboardsPressed,
    required this.onMessagesPressed,
    required this.onSupportPressed,
    required this.onOptionsPressed,
  });

  final VoidCallback onCodexPressed;
  final VoidCallback onTownPressed;
  final VoidCallback onProfilePressed;
  final VoidCallback onLeaderboardsPressed;
  final VoidCallback onMessagesPressed;
  final VoidCallback onSupportPressed;
  final VoidCallback onOptionsPressed;

  @override
  Widget build(BuildContext context) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.center,
      children: [
        Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            AppIconButton(
              icon: Icons.library_books,
              label: 'Codex',
              onPressed: onCodexPressed,
            ),
            AppIconButton(
              icon: Icons.storefront,
              label: 'Town',
              onPressed: onTownPressed,
            ),
          ],
        ),
        Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            AppIconButton(
              icon: Icons.person,
              label: 'Profile',
              onPressed: onProfilePressed,
            ),
            AppIconButton(
              icon: Icons.leaderboard,
              label: 'Top',
              onPressed: onLeaderboardsPressed,
            ),
          ],
        ),
        Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            AppIconButton(
              icon: Icons.message,
              label: 'Messages',
              onPressed: onMessagesPressed,
            ),
            AppIconButton(
              icon: Icons.monetization_on,
              label: 'Support',
              onPressed: onSupportPressed,
            ),
          ],
        ),
        AppIconButton(
          icon: Icons.settings,
          label: 'Options',
          onPressed: onOptionsPressed,
        ),
      ],
    );
  }
}


===== FILE: lib/ui/pages/hub/components/hub_select_card_body.dart =====
import 'package:flutter/material.dart';

import '../../../theme/ui_tokens.dart';

/// Shared inner content for hub selection cards (level/character/etc.).
///
/// Owns typography + spacing contract so individual cards only provide data
/// (header/title/subtitle) and optional visuals (e.g. character preview).
class HubSelectCardBody extends StatelessWidget {
  const HubSelectCardBody({
    super.key,
    required this.label,
    required this.title,
    required this.subtitle,
    this.labelMaxLines = 1,
    this.titleMaxLines = 1,
    this.subtitleMaxLines = 1,
    this.trailing,
  });

  final String label;
  final String title;
  final String subtitle;
  final int labelMaxLines;
  final int titleMaxLines;
  final int subtitleMaxLines;
  final Widget? trailing;

  @override
  Widget build(BuildContext context) {
    final ui = context.ui;
    final base = Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          label,
          style: ui.text.cardLabel,
          maxLines: labelMaxLines,
          overflow: TextOverflow.ellipsis,
        ),
        SizedBox(height: ui.space.xs),
        Text(
          title,
          style: ui.text.cardTitle,
          maxLines: titleMaxLines,
          overflow: TextOverflow.ellipsis,
        ),
        SizedBox(height: ui.space.xxs),
        Text(
          subtitle,
          style: ui.text.cardSubtitle,
          maxLines: subtitleMaxLines,
          overflow: TextOverflow.ellipsis,
        ),
      ],
    );

    final t = trailing;
    if (t == null) return base;

    return Stack(
      children: [
        base,
        Positioned(right: 0, bottom: 0, child: t),
      ],
    );
  }
}


===== FILE: lib/ui/pages/hub/components/hub_select_card_frame.dart =====
import 'dart:math' as math;

import 'package:flutter/material.dart';

import '../../../theme/ui_tokens.dart';
import '../../../theme/ui_hub_theme.dart';

/// Shared frame for hub selection cards (level/character).
///
/// Owns layout contract: size, border, shadow, padding, clipping, and overlay.
class HubSelectCardFrame extends StatelessWidget {
  const HubSelectCardFrame({
    super.key,
    required this.background,
    required this.child,
    this.onTap,
  });

  final Widget background;
  final Widget child;
  final VoidCallback? onTap;

  @override
  Widget build(BuildContext context) {
    final ui = context.ui;
    final hub = context.hub;

    // Card content with border, shadow, clipping, and overlay.
    final content = Container(
      // Card size
      width: hub.selectCardWidth,
      height: hub.selectCardHeight,
      // Card border, shadow, and border radius
      decoration: BoxDecoration(
        color: ui.colors.cardBackground,
        borderRadius: BorderRadius.circular(ui.radii.md),
        border: Border.all(
          color: ui.colors.outline,
          width: ui.sizes.borderWidth,
        ),
        boxShadow: ui.shadows.card,
      ),
      // Card content
      child: ClipRRect(
        borderRadius: BorderRadius.circular(
          math.max(0.0, ui.radii.md - ui.sizes.borderWidth),
        ),
        // Stack background, overlay, and padded child
        child: Stack(
          fit: StackFit.expand,
          children: [
            background,
            Padding(
              padding: EdgeInsets.fromLTRB(
                ui.space.md,
                ui.space.xs,
                ui.space.md,
                ui.space.md,
              ),
              child: child,
            ),
          ],
        ),
      ),
    );

    if (onTap == null) return content;

    return GestureDetector(onTap: onTap, child: content);
  }
}


===== FILE: lib/ui/pages/hub/components/hub_select_character_card.dart =====
import 'package:flutter/material.dart';

import '../../../../core/players/player_character_definition.dart';
import '../../../../core/players/player_character_registry.dart';
import 'hub_select_card_body.dart';
import 'hub_select_card_frame.dart';
import '../../../components/player_idle_preview.dart';
import '../../../theme/ui_hub_theme.dart';
import '../../../theme/ui_tokens.dart';

/// Hub card showing the currently selected character and build name.
class HubSelectCharacterCard extends StatelessWidget {
  const HubSelectCharacterCard({
    super.key,
    required this.characterId,
    required this.buildName,
    required this.onChange,
  });

  final PlayerCharacterId characterId;
  final String buildName;
  final VoidCallback onChange;

  @override
  Widget build(BuildContext context) {
    final ui = context.ui;
    final hub = context.hub;
    final def = PlayerCharacterRegistry.resolve(characterId);

    return HubSelectCardFrame(
      onTap: onChange,
      background: DecoratedBox(
        decoration: BoxDecoration(color: ui.colors.cardBackground),
      ),
      child: HubSelectCardBody(
        label: 'CHARACTER SELECTION',
        title: def.displayName,
        subtitle: buildName,
        trailing: PlayerIdlePreview(
          characterId: characterId,
          size: hub.characterPreviewSize,
        ),
      ),
    );
  }
}


===== FILE: lib/ui/pages/hub/components/hub_select_level_card.dart =====
import 'package:flutter/material.dart';

import '../../../../core/levels/level_id.dart';
import '../../../levels/level_id_ui.dart';
import 'hub_select_card_body.dart';
import 'hub_select_card_frame.dart';
import '../../../components/level_parallax_preview.dart';
import '../../../theme/ui_tokens.dart';

/// Hub card showing the currently selected level.
class HubSelectedLevelCard extends StatelessWidget {
  const HubSelectedLevelCard({
    super.key,
    required this.levelId,
    required this.runTypeLabel,
    required this.onChange,
  });

  final LevelId levelId;
  final String runTypeLabel;
  final VoidCallback onChange;

  @override
  Widget build(BuildContext context) {
    final ui = context.ui;

    return HubSelectCardFrame(
      onTap: onChange,
      background: LevelParallaxPreview(
        themeId: levelId.themeId,
        baseColor: ui.colors.cardBackground,
        alignment: Alignment.center,
      ),
      child: HubSelectCardBody(
        label: 'LEVEL SELECTION',
        title: levelId.displayName.toUpperCase(),
        subtitle: runTypeLabel,
      ),
    );
  }
}


===== FILE: lib/ui/pages/hub/components/hub_top_row.dart =====
import 'dart:async';

import 'package:battery_plus/battery_plus.dart';
import 'package:flutter/material.dart';

import '../../../theme/ui_tokens.dart';

class HubTopRow extends StatefulWidget {
  const HubTopRow({
    super.key,
    required this.displayName,
    required this.profileId,
    required this.gold,
  });

  final String displayName;
  final String profileId;
  final int gold;

  @override
  State<HubTopRow> createState() => _HubTopRowState();
}

class _HubTopRowState extends State<HubTopRow> {
  final Battery _battery = Battery();
  int _batteryLevel = 100;
  BatteryState _batteryState = BatteryState.unknown;
  late Timer _timer;
  DateTime _now = DateTime.now();
  StreamSubscription<BatteryState>? _batteryStateSubscription;

  @override
  void initState() {
    super.initState();
    _initBattery();
    _timer = Timer.periodic(const Duration(seconds: 1), (_) {
      if (mounted) {
        setState(() => _now = DateTime.now());
      }
    });
  }

  Future<void> _initBattery() async {
    _batteryStateSubscription = _battery.onBatteryStateChanged.listen((state) {
      if (mounted) setState(() => _batteryState = state);
    });

    try {
      final level = await _battery.batteryLevel;
      if (mounted) setState(() => _batteryLevel = level);
    } catch (_) {
      // Ignore battery level errors
    }
  }

  @override
  void dispose() {
    _timer.cancel();
    _batteryStateSubscription?.cancel();
    super.dispose();
  }

  IconData get _batteryIcon {
    if (_batteryState == BatteryState.charging) {
      return Icons.battery_charging_full;
    }
    if (_batteryLevel >= 90) return Icons.battery_full;
    if (_batteryLevel >= 60) return Icons.battery_6_bar;
    if (_batteryLevel >= 50) return Icons.battery_5_bar;
    if (_batteryLevel >= 30) return Icons.battery_3_bar;
    if (_batteryLevel >= 20) return Icons.battery_2_bar;
    return Icons.battery_alert; // Alert?
  }

  Color get _batteryColor {
    final ui = context.ui;
    if (_batteryState == BatteryState.charging) return ui.colors.success;
    if (_batteryLevel <= 20) return ui.colors.danger;
    return ui.colors.textMuted;
  }

  @override
  Widget build(BuildContext context) {
    final ui = context.ui;
    final timeStr =
        '${_now.hour.toString().padLeft(2, '0')}:${_now.minute.toString().padLeft(2, '0')}';

    return Container(
      padding: EdgeInsets.zero,
      child: Row(
        children: [
          Expanded(
            child: Text(
              widget.displayName,
              style: ui.text.headline,
              overflow: TextOverflow.ellipsis,
            ),
          ),
          SizedBox(width: ui.space.sm),
          // Gold
          Text(
            widget.gold.toString(),
            style: ui.text.headline,
          ),
          SizedBox(width: ui.space.xs),
          Icon(
            Icons.monetization_on,
            color: ui.colors.accentStrong,
            size: ui.sizes.iconSize.sm,
          ),
          SizedBox(width: ui.space.md),
          Container(
            width: ui.sizes.dividerThickness,
            height: ui.space.lg,
            color: ui.colors.textPrimary,
          ),
          SizedBox(width: ui.space.xs),
          // Battery
          Icon(_batteryIcon, color: _batteryColor, size: ui.sizes.iconSize.sm),
          SizedBox(width: ui.space.xxs),
          Text(
            '$_batteryLevel%',
            style: ui.text.caption,
          ),
          SizedBox(width: ui.space.md),
          // Time
          Icon(
            Icons.access_time,
            color: ui.colors.outlineStrong,
            size: ui.sizes.iconSize.sm,
          ),
          SizedBox(width: ui.space.xxs),
          Text(
            timeStr,
            style: ui.text.caption,
          ),
        ],
      ),
    );
  }
}


===== FILE: lib/ui/pages/hub/play_hub_page.dart =====
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

import '../../app/ui_routes.dart';
import '../../components/app_button.dart';
import '../../components/menu_layout.dart';
import '../../components/menu_scaffold.dart';
import '../../components/weekly_badge_row.dart';
import 'components/hub_menu_icon_column.dart';
import 'components/hub_select_character_card.dart';
import 'components/hub_select_level_card.dart';
import 'components/hub_top_row.dart';
import '../../state/app_state.dart';
import '../../state/profile_counter_keys.dart';
import '../../state/selection_state.dart';
import '../../theme/ui_tokens.dart';

class PlayHubPage extends StatefulWidget {
  const PlayHubPage({super.key});

  @override
  State<PlayHubPage> createState() => _PlayHubPageState();
}

class _PlayHubPageState extends State<PlayHubPage> {
  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (!mounted) return;
      context.read<AppState>().startWarmup();
    });
  }

  @override
  Widget build(BuildContext context) {
    final ui = context.ui;
    final appState = context.watch<AppState>();
    final selection = appState.selection;
    final profile = appState.profile;
    final gold = profile.counters[ProfileCounterKeys.gold] ?? 0;

    return MenuScaffold(
      showAppBar: false,
      child: MenuLayout(
        horizontalPadding: ui.space.lg,
        child: Row(
          crossAxisAlignment: CrossAxisAlignment.center,
          children: [
            HubMenuIconColumn(
              onCodexPressed: () =>
                  Navigator.of(context).pushNamed(UiRoutes.library),
              onTownPressed: () =>
                  Navigator.of(context).pushNamed(UiRoutes.town),
              onProfilePressed: () =>
                  Navigator.of(context).pushNamed(UiRoutes.profile),
              onLeaderboardsPressed: () =>
                  Navigator.of(context).pushNamed(UiRoutes.leaderboards),
              onMessagesPressed: () =>
                  Navigator.of(context).pushNamed(UiRoutes.messages),
              onSupportPressed: () =>
                  Navigator.of(context).pushNamed(UiRoutes.support),
              onOptionsPressed: () =>
                  Navigator.of(context).pushNamed(UiRoutes.options),
            ),
            SizedBox(width: ui.space.xs),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  HubTopRow(
                    displayName: profile.displayName.isEmpty
                        ? 'Guest'
                        : profile.displayName,
                    profileId: profile.profileId,
                    gold: gold,
                  ),
                  SizedBox(height: ui.space.sm),
                  WeeklyBadgeRow(
                    onWeeklyPressed: null,
                    onWeeklyLeaderboardPressed: () =>
                        Navigator.of(context).pushNamed(UiRoutes.leaderboards),
                  ),
                  SizedBox(height: ui.space.lg),
                  Center(
                    child: Wrap(
                      alignment: WrapAlignment.center,
                      spacing: ui.space.md,
                      runSpacing: ui.space.md,
                      children: [
                        HubSelectedLevelCard(
                          levelId: selection.selectedLevelId,
                          runTypeLabel: _runTypeLabel(
                            selection.selectedRunType,
                          ),
                          onChange: () => Navigator.of(
                            context,
                          ).pushNamed(UiRoutes.setupLevel),
                        ),
                        HubSelectCharacterCard(
                          characterId: selection.selectedCharacterId,
                          buildName: selection.buildName,
                          onChange: () => Navigator.of(
                            context,
                          ).pushNamed(UiRoutes.setupLoadout),
                        ),
                      ],
                    ),
                  ),
                  SizedBox(height: ui.space.lg),
                  Center(
                    child: AppButton(
                      label: 'PLAY',
                      size: AppButtonSize.lg,
                      onPressed: () {
                        final args = appState.buildRunStartArgs();
                        Navigator.of(
                          context,
                        ).pushNamed(UiRoutes.run, arguments: args);
                      },
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}

String _runTypeLabel(RunType runType) {
  switch (runType) {
    case RunType.practice:
      return 'Practice (Random)';
    case RunType.competitive:
      return 'Competitive (Season)';
  }
}


===== FILE: lib/ui/pages/lab/loadout_lab_page.dart =====
import 'package:flutter/material.dart';

import '../../components/placeholder_page.dart';

class LoadoutLabPage extends StatelessWidget {
  const LoadoutLabPage({super.key});

  @override
  Widget build(BuildContext context) {
    return const PlaceholderPage(title: 'Loadout Lab');
  }
}


===== FILE: lib/ui/pages/leaderboards/leaderboards_page.dart =====
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

import '../../../core/levels/level_id.dart';
import '../../components/app_segmented_control.dart';
import '../../components/leaderboard_table.dart';
import '../../components/menu_layout.dart';
import '../../components/menu_scaffold.dart';
import '../../leaderboard/run_result.dart';
import '../../leaderboard/shared_prefs_leaderboard_store.dart';
import '../../levels/level_id_ui.dart';
import '../../state/app_state.dart';
import '../../state/selection_state.dart';
import '../../theme/ui_tokens.dart';

enum LeaderboardsRunFilter { practice, competitive, weekly }

class LeaderboardsPage extends StatefulWidget {
  const LeaderboardsPage({super.key});

  @override
  State<LeaderboardsPage> createState() => _LeaderboardsPageState();
}

class _LeaderboardsPageState extends State<LeaderboardsPage> {
  final _store = SharedPrefsLeaderboardStore();
  bool _seeded = false;

  late LeaderboardsRunFilter _runFilter;
  late int _initialTabIndex;
  late LevelId _weeklyLevelId;

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    if (_seeded) return;

    final selection = context.read<AppState>().selection;
    _runFilter = switch (selection.selectedRunType) {
      RunType.practice => LeaderboardsRunFilter.practice,
      RunType.competitive => LeaderboardsRunFilter.competitive,
    };
    _initialTabIndex = _levelIndexOf(selection.selectedLevelId);
    // Weekly is a single leaderboard scope (one level). For now, we default it
    // to the user's currently selected level.
    _weeklyLevelId = selection.selectedLevelId;
    _seeded = true;
  }

  RunType? _toRunType(LeaderboardsRunFilter filter) => switch (filter) {
    LeaderboardsRunFilter.practice => RunType.practice,
    LeaderboardsRunFilter.competitive => RunType.competitive,
    LeaderboardsRunFilter.weekly => null,
  };

  int _levelIndexOf(LevelId levelId) {
    final index = LevelId.values.indexOf(levelId);
    return index == -1 ? 0 : index;
  }

  @override
  Widget build(BuildContext context) {
    final runType = _toRunType(_runFilter);
    final isWeekly = runType == null;

    final segmented = AppSegmentedControl<LeaderboardsRunFilter>(
      values: const [
        LeaderboardsRunFilter.practice,
        LeaderboardsRunFilter.competitive,
        LeaderboardsRunFilter.weekly,
      ],
      selected: _runFilter,
      size: AppSegmentedControlSize.sm,
      onChanged: (value) => setState(() => _runFilter = value),
      labelBuilder: (context, value) => switch (value) {
        LeaderboardsRunFilter.practice => const Text('Practice (Random)'),
        LeaderboardsRunFilter.competitive => const Text('Competitive (Season)'),
        LeaderboardsRunFilter.weekly => const Text('Weekly'),
      },
    );

    return MenuScaffold(
      appBarTitle: segmented,
      centerAppBarTitle: true,
      child: MenuLayout(
        scrollable: false,
        child: isWeekly
            ? _WeeklyLeaderboardPlaceholder(levelId: _weeklyLevelId)
            : _PerLevelLeaderboards(
                store: _store,
                runType: runType,
                initialIndex: _initialTabIndex,
              ),
      ),
    );
  }
}

class _PerLevelLeaderboards extends StatelessWidget {
  const _PerLevelLeaderboards({
    required this.store,
    required this.runType,
    required this.initialIndex,
  });

  final SharedPrefsLeaderboardStore store;
  final RunType runType;
  final int initialIndex;

  @override
  Widget build(BuildContext context) {
    final ui = context.ui;
    final levels = LevelId.values;

    return DefaultTabController(
      length: levels.length,
      initialIndex: initialIndex,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          TabBar(
            isScrollable: true,
            labelColor: ui.colors.textPrimary,
            unselectedLabelColor: ui.colors.textMuted,
            labelStyle: ui.text.label,
            indicatorColor: ui.colors.accent,
            tabs: [
              for (final levelId in levels)
                Tab(text: levelId.displayName.toUpperCase()),
            ],
          ),
          Expanded(
            child: TabBarView(
              children: [
                for (final levelId in levels)
                  _LeaderboardList(
                    key: ValueKey('${levelId.name}-${runType.name}'),
                    store: store,
                    levelId: levelId,
                    runType: runType,
                  ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}

class _LeaderboardList extends StatefulWidget {
  const _LeaderboardList({
    super.key,
    required this.store,
    required this.levelId,
    required this.runType,
  });

  final SharedPrefsLeaderboardStore store;
  final LevelId levelId;
  final RunType runType;

  @override
  State<_LeaderboardList> createState() => _LeaderboardListState();
}

class _LeaderboardListState extends State<_LeaderboardList> {
  late Future<List<RunResult>> _future;

  @override
  void initState() {
    super.initState();
    _future = _load();
  }

  @override
  void didUpdateWidget(covariant _LeaderboardList oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.levelId == widget.levelId &&
        oldWidget.runType == widget.runType) {
      return;
    }
    _future = _load();
  }

  Future<List<RunResult>> _load() {
    return widget.store.loadTop10(
      levelId: widget.levelId,
      runType: widget.runType,
    );
  }

  @override
  Widget build(BuildContext context) {
    final ui = context.ui;

    return FutureBuilder<List<RunResult>>(
      future: _future,
      builder: (context, snapshot) {
        final entries = snapshot.data;
        if (snapshot.connectionState != ConnectionState.done) {
          return Center(child: Text('Loading...', style: ui.text.body));
        }

        if (snapshot.hasError) {
          return Center(
            child: Text('Failed to load leaderboard.', style: ui.text.body),
          );
        }

        if (entries == null || entries.isEmpty) {
          return Center(child: Text('No runs yet.', style: ui.text.body));
        }

        return LeaderboardTable(entries: entries, scrollable: true);
      },
    );
  }
}

class _WeeklyLeaderboardPlaceholder extends StatelessWidget {
  const _WeeklyLeaderboardPlaceholder({required this.levelId});

  final LevelId levelId;

  @override
  Widget build(BuildContext context) {
    final ui = context.ui;
    return Center(
      child: ConstrainedBox(
        constraints: const BoxConstraints(maxWidth: 520),
        child: Text(
          '${levelId.displayName} weekly leaderboard is coming soon.',
          style: ui.text.body,
          textAlign: TextAlign.center,
        ),
      ),
    );
  }
}


===== FILE: lib/ui/pages/meta/credits_page.dart =====
import 'package:flutter/material.dart';

import '../../components/placeholder_page.dart';

class CreditsPage extends StatelessWidget {
  const CreditsPage({super.key});

  @override
  Widget build(BuildContext context) {
    return const PlaceholderPage(title: 'Credits');
  }
}


===== FILE: lib/ui/pages/meta/library_page.dart =====
import 'package:flutter/material.dart';

import '../../components/placeholder_page.dart';

class LibraryPage extends StatelessWidget {
  const LibraryPage({super.key});

  @override
  Widget build(BuildContext context) {
    return const PlaceholderPage(title: 'Library');
  }
}


===== FILE: lib/ui/pages/meta/messages_page.dart =====
import 'package:flutter/material.dart';

import '../../components/placeholder_page.dart';

class MessagesPage extends StatelessWidget {
  const MessagesPage({super.key});

  @override
  Widget build(BuildContext context) {
    return const PlaceholderPage(title: 'Messages');
  }
}


===== FILE: lib/ui/pages/meta/options_page.dart =====
import 'package:flutter/material.dart';

import '../../components/placeholder_page.dart';

class OptionsPage extends StatelessWidget {
  const OptionsPage({super.key});

  @override
  Widget build(BuildContext context) {
    return const PlaceholderPage(title: 'Options');
  }
}


===== FILE: lib/ui/pages/meta/support_page.dart =====
import 'package:flutter/material.dart';

import '../../components/placeholder_page.dart';

class SupportPage extends StatelessWidget {
  const SupportPage({super.key});

  @override
  Widget build(BuildContext context) {
    return const PlaceholderPage(title: 'Support');
  }
}


===== FILE: lib/ui/pages/meta/town_page.dart =====
import 'package:flutter/material.dart';

import '../../components/placeholder_page.dart';

class TownPage extends StatelessWidget {
  const TownPage({super.key});

  @override
  Widget build(BuildContext context) {
    return const PlaceholderPage(title: 'Town');
  }
}


===== FILE: lib/ui/pages/profile/profile_page.dart =====
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

import '../../components/app_inline_edit_text.dart';
import '../../components/menu_layout.dart';
import '../../components/menu_scaffold.dart';
import '../../profile/display_name_policy.dart';
import '../../state/app_state.dart';
import '../../state/profile_counter_keys.dart';
import '../../state/user_profile.dart';
import '../../theme/ui_tokens.dart';

class ProfilePage extends StatefulWidget {
  const ProfilePage({super.key});

  @override
  State<ProfilePage> createState() => _ProfilePageState();
}

class _ProfilePageState extends State<ProfilePage> {
  final _policy = const DisplayNamePolicy();

  static const Duration _cooldown = Duration(hours: 24);

  String _fallbackName(String displayName) =>
      displayName.isEmpty ? 'Guest' : displayName;

  bool _cooldownActive(int lastChangedAtMs, int nowMs) {
    if (lastChangedAtMs <= 0) return false;
    return nowMs - lastChangedAtMs < _cooldown.inMilliseconds;
  }

  Duration _cooldownRemaining(int lastChangedAtMs, int nowMs) {
    final elapsed = nowMs - lastChangedAtMs;
    final remainingMs = _cooldown.inMilliseconds - elapsed;
    final clampedMs = remainingMs.clamp(0, _cooldown.inMilliseconds).toInt();
    return Duration(milliseconds: clampedMs);
  }

  String? _validateDisplayName(UserProfile profile, String raw) {
    final trimmed = raw.trim();
    if (trimmed == profile.displayName) return 'Name is unchanged.';

    final nowMs = DateTime.now().millisecondsSinceEpoch;
    final active = _cooldownActive(profile.displayNameLastChangedAtMs, nowMs);
    if (active) {
      final rem = _cooldownRemaining(profile.displayNameLastChangedAtMs, nowMs);
      return 'You can change your name again in ${rem.inHours}h ${rem.inMinutes.remainder(60)}m.';
    }

    return _policy.validate(trimmed);
  }

  Future<void> _commitDisplayName(String raw) async {
    final appState = context.read<AppState>();
    final profile = appState.profile;
    final trimmed = raw.trim();

    final nowMs = DateTime.now().millisecondsSinceEpoch;
    final shouldSetCooldown = profile.displayName.isNotEmpty;

    await appState.updateProfile((p) {
      return p.copyWith(
        displayName: trimmed,
        displayNameLastChangedAtMs: shouldSetCooldown
            ? nowMs
            : p.displayNameLastChangedAtMs,
      );
    });

    if (!mounted) return;
    ScaffoldMessenger.of(
      context,
    ).showSnackBar(const SnackBar(content: Text('Name updated')));
  }

  @override
  Widget build(BuildContext context) {
    final ui = context.ui;
    final appState = context.watch<AppState>();
    final profile = appState.profile;
    final gold = profile.counters[ProfileCounterKeys.gold] ?? 0;

    return MenuScaffold(
      title: 'Profile',
      showAppBar: true,
      child: MenuLayout(
        child: Center(
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 560),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Container(
                  padding: EdgeInsets.all(ui.space.md),
                  decoration: BoxDecoration(
                    border: Border.all(
                      color: ui.colors.outline,
                      width: ui.sizes.borderWidth,
                    ),
                    borderRadius: BorderRadius.circular(ui.radii.md),
                  ),
                  child: Column(
                    children: [
                      _buildDisplayNameRow(profile),
                      _row('Gold', gold.toString()),
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildDisplayNameRow(UserProfile profile) {
    final ui = context.ui;
    final currentName = profile.displayName;
    final labelStyle = ui.text.label.copyWith(color: ui.colors.textMuted);
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 6),
      child: Row(
        children: [
          SizedBox(width: 80, child: Text('Name', style: labelStyle)),
          Expanded(
            child: AppInlineEditText(
              text: currentName,
              displayText: _fallbackName(currentName),
              hintText: 'Enter name',
              validator: (value) => _validateDisplayName(profile, value),
              onCommit: _commitDisplayName,
            ),
          ),
        ],
      ),
    );
  }

  Widget _row(String label, String value) {
    final ui = context.ui;
    final labelStyle = ui.text.label.copyWith(color: ui.colors.textMuted);
    final valueStyle = ui.text.body.copyWith(color: ui.colors.textPrimary);
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 6),
      child: Row(
        children: [
          SizedBox(width: 80, child: Text(label, style: labelStyle)),
          Expanded(
            child: Text(
              value,
              style: valueStyle,
              overflow: TextOverflow.ellipsis,
            ),
          ),
        ],
      ),
    );
  }
}


===== FILE: lib/ui/pages/selectCharacter/ability/ability_picker_presenter.dart =====
// Presenter helpers for ability selection UI.
//
// This file translates authoritative Core loadout/catalog data into UI-facing
// models, runs trial-loadout legality checks through `LoadoutValidator`, and
// provides immutable slot update helpers for widgets.
//
// Keeping this logic centralized ensures picker screens stay aligned with Core
// rules (visibility, legality, and source constraints) without mutating
// loadouts directly in widget code.
import '../../../../core/abilities/ability_catalog.dart';
import '../../../../core/abilities/ability_def.dart';
import '../../../../core/accessories/accessory_id.dart';
import '../../../../core/ecs/stores/combat/equipped_loadout_store.dart';
import '../../../../core/loadout/loadout_validator.dart';
import '../../../../core/players/player_character_definition.dart';
import '../../../../core/players/player_character_registry.dart';
import '../../../../core/projectiles/projectile_catalog.dart';
import '../../../../core/projectiles/projectile_id.dart';
import '../../../../core/spellBook/spell_book_catalog.dart';
import '../../../../core/spellBook/spell_book_id.dart';
import '../../../../core/weapons/weapon_catalog.dart';
import '../../../../core/weapons/weapon_id.dart';
import '../../../text/gear_text.dart';

const AbilityCatalog _abilityCatalog = AbilityCatalog();
const ProjectileCatalog _projectileCatalog = ProjectileCatalog();
const SpellBookCatalog _spellBookCatalog = SpellBookCatalog();
const LoadoutValidator _loadoutValidator = LoadoutValidator(
  abilityCatalog: _abilityCatalog,
  weaponCatalog: WeaponCatalog(),
  projectileCatalog: _projectileCatalog,
  spellBookCatalog: _spellBookCatalog,
);

/// Display model for one ability option in a picker.
///
/// [isEnabled] represents legality for the current trial loadout, not unlock
/// ownership. UI can still render disabled entries for discoverability.
class AbilityPickerCandidate {
  const AbilityPickerCandidate({
    required this.id,
    required this.def,
    required this.isEnabled,
  });

  final AbilityKey id;
  final AbilityDef def;
  final bool isEnabled;
}

/// Display model for projectile payload selection.
///
/// - [spellId] == null means "use equipped throwing weapon".
/// - [spellId] != null means "use this spell from spellbook".
class ProjectileSourceOption {
  const ProjectileSourceOption({
    required this.projectileId,
    required this.spellId,
    required this.displayName,
    this.description = '',
    this.damageTypeName = '',
    this.statusLines = const <String>[],
  });

  /// Canonical [ProjectileId] for this source (used for icon lookup).
  final ProjectileId projectileId;

  final ProjectileId? spellId;
  final String displayName;

  /// Short description of what this projectile does.
  final String description;

  /// User-facing damage type label (e.g. "Fire", "Physical").
  final String damageTypeName;

  /// Detailed status effect summaries with numbers.
  final List<String> statusLines;
}

/// Display model for the left projectile source panel.
///
/// It explicitly separates source families:
/// - equipped throwing weapon (single tap-select entry)
/// - equipped spellbook (expandable list of spell projectile entries)
class ProjectileSourcePanelModel {
  const ProjectileSourcePanelModel({
    required this.throwingWeaponId,
    required this.throwingWeaponDisplayName,
    required this.spellBookId,
    required this.spellBookDisplayName,
    required this.spellOptions,
  });

  final ProjectileId throwingWeaponId;
  final String throwingWeaponDisplayName;
  final SpellBookId spellBookId;
  final String spellBookDisplayName;
  final List<ProjectileSpellOption> spellOptions;
}

/// Display model for one spell projectile available in the equipped spellbook.
class ProjectileSpellOption {
  const ProjectileSpellOption({
    required this.spellId,
    required this.displayName,
  });

  final ProjectileId spellId;
  final String displayName;
}

/// Returns all visible ability candidates for [slot] under the current loadout.
///
/// Legality is validated through [LoadoutValidator] so UI remains Core-driven.
/// The returned list is sorted by id for deterministic UI ordering.
List<AbilityPickerCandidate> abilityCandidatesForSlot({
  required PlayerCharacterId characterId,
  required AbilitySlot slot,
  required EquippedLoadoutDef loadout,
  ProjectileId? selectedSourceSpellId,
  bool overrideSelectedSource = false,
}) {
  final normalizedLoadout = normalizeLoadoutMaskForCharacter(
    characterId: characterId,
    loadout: loadout,
  );
  final candidates = <AbilityDef>[
    for (final def in AbilityCatalog.abilities.values)
      if (_isAbilityVisibleForCharacter(characterId, def.id) &&
          def.allowedSlots.contains(slot))
        def,
  ];

  final equippedAbilityId = abilityIdForSlot(normalizedLoadout, slot);
  final equippedAbility = _abilityCatalog.resolve(equippedAbilityId);
  // Keep currently equipped ability visible even when character visibility
  // rules changed, so the player can always see and replace invalid legacy
  // selections.
  if (equippedAbility != null &&
      !candidates.any((def) => def.id == equippedAbility.id)) {
    candidates.add(equippedAbility);
  }

  candidates.sort((a, b) => a.id.compareTo(b.id));

  return [
    for (final def in candidates)
      AbilityPickerCandidate(
        id: def.id,
        def: def,
        isEnabled: _isAbilityLegalForSlot(
          loadout: normalizedLoadout,
          slot: slot,
          abilityId: def.id,
          selectedSourceSpellId: selectedSourceSpellId,
          overrideSelectedSource: overrideSelectedSource,
        ),
      ),
  ];
}

/// Forces [loadout.mask] to the selected character's authored slot mask.
///
/// This keeps UI validation and runtime behavior aligned even when older saved
/// selections still carry legacy masks.
EquippedLoadoutDef normalizeLoadoutMaskForCharacter({
  required PlayerCharacterId characterId,
  required EquippedLoadoutDef loadout,
}) {
  final def = PlayerCharacterRegistry.resolve(characterId);
  final targetMask = def.catalog.loadoutSlotMask;
  if (loadout.mask == targetMask) return loadout;
  return _copyLoadout(loadout, mask: targetMask);
}

/// Returns projectile source options exposed by the equipped throwing weapon and spellbook.
ProjectileSourcePanelModel projectileSourcePanelModel(
  EquippedLoadoutDef loadout,
) {
  final spellBook = _spellBookCatalog.get(loadout.spellBookId);
  final spellOptions = <ProjectileSpellOption>[];
  for (final spellId in spellBook.projectileSpellIds) {
    if (_projectileCatalog.tryGet(spellId) == null) continue;
    spellOptions.add(
      ProjectileSpellOption(
        spellId: spellId,
        displayName: projectileDisplayName(spellId),
      ),
    );
  }
  return ProjectileSourcePanelModel(
    throwingWeaponId: loadout.projectileId,
    throwingWeaponDisplayName: projectileDisplayName(loadout.projectileId),
    spellBookId: loadout.spellBookId,
    spellBookDisplayName: spellBookDisplayName(loadout.spellBookId),
    spellOptions: spellOptions,
  );
}

/// Returns flat projectile source options for compatibility with existing call sites.
///
/// `spellId == null` always represents the equipped throwing weapon source.
List<ProjectileSourceOption> projectileSourceOptions(
  EquippedLoadoutDef loadout,
) {
  final sourceModel = projectileSourcePanelModel(loadout);
  final throwingDef = _projectileCatalog.get(sourceModel.throwingWeaponId);
  final options = <ProjectileSourceOption>[
    ProjectileSourceOption(
      projectileId: sourceModel.throwingWeaponId,
      spellId: null,
      displayName: sourceModel.throwingWeaponDisplayName,
      description: projectileDescription(sourceModel.throwingWeaponId),
      damageTypeName: damageTypeDisplayName(throwingDef.damageType),
      statusLines: projectileStatusSummaries(throwingDef),
    ),
  ];
  for (final spell in sourceModel.spellOptions) {
    final spellDef = _projectileCatalog.get(spell.spellId);
    options.add(
      ProjectileSourceOption(
        projectileId: spell.spellId,
        spellId: spell.spellId,
        displayName: spell.displayName,
        description: projectileDescription(spell.spellId),
        damageTypeName: damageTypeDisplayName(spellDef.damageType),
        statusLines: projectileStatusSummaries(spellDef),
      ),
    );
  }
  return options;
}

/// Returns [selected] when still valid for the equipped spellbook, otherwise null.
ProjectileId? normalizeProjectileSourceSelection(
  EquippedLoadoutDef loadout,
  ProjectileId? selected,
) {
  if (selected == null) return null;
  final options = projectileSourceOptions(loadout);
  final exists = options.any((option) => option.spellId == selected);
  return exists ? selected : null;
}

/// Reads the equipped ability id for [slot].
AbilityKey abilityIdForSlot(EquippedLoadoutDef loadout, AbilitySlot slot) {
  switch (slot) {
    case AbilitySlot.primary:
      return loadout.abilityPrimaryId;
    case AbilitySlot.secondary:
      return loadout.abilitySecondaryId;
    case AbilitySlot.projectile:
      return loadout.abilityProjectileId;
    case AbilitySlot.mobility:
      return loadout.abilityMobilityId;
    case AbilitySlot.jump:
      return loadout.abilityJumpId;
    case AbilitySlot.spell:
      return loadout.abilitySpellId;
  }
}

/// Returns a copy where [slot] uses [abilityId].
EquippedLoadoutDef setAbilityForSlot(
  EquippedLoadoutDef loadout, {
  required AbilitySlot slot,
  required AbilityKey abilityId,
}) {
  return _copyLoadout(
    loadout,
    abilityPrimaryId: slot == AbilitySlot.primary ? abilityId : null,
    abilitySecondaryId: slot == AbilitySlot.secondary ? abilityId : null,
    abilityProjectileId: slot == AbilitySlot.projectile ? abilityId : null,
    abilitySpellId: slot == AbilitySlot.spell ? abilityId : null,
    abilityMobilityId: slot == AbilitySlot.mobility ? abilityId : null,
    abilityJumpId: slot == AbilitySlot.jump ? abilityId : null,
  );
}

/// Returns a copy where projectile payload source for [slot] is changed.
///
/// For non-projectile slots this returns the input [loadout] unchanged.
EquippedLoadoutDef setProjectileSourceForSlot(
  EquippedLoadoutDef loadout, {
  required AbilitySlot slot,
  required ProjectileId? selectedSpellId,
}) {
  switch (slot) {
    case AbilitySlot.projectile:
      return _copyLoadout(loadout, projectileSlotSpellId: selectedSpellId);
    case AbilitySlot.primary:
    case AbilitySlot.secondary:
    case AbilitySlot.spell:
    case AbilitySlot.mobility:
    case AbilitySlot.jump:
      return loadout;
  }
}

/// Returns whether [id] should appear in the picker for [characterId].
///
/// Character-prefixed and non-enemy common abilities are visible.
bool _isAbilityVisibleForCharacter(
  PlayerCharacterId characterId,
  AbilityKey id,
) {
  if (id.startsWith('${characterId.name}.')) return true;
  if (id.startsWith('common.') && !id.startsWith('common.enemy_')) return true;
  return false;
}

/// Validates a trial loadout with [abilityId] in [slot] against Core rules.
///
/// Returns `false` when the validator reports any issue for the target slot.
bool _isAbilityLegalForSlot({
  required EquippedLoadoutDef loadout,
  required AbilitySlot slot,
  required AbilityKey abilityId,
  required ProjectileId? selectedSourceSpellId,
  required bool overrideSelectedSource,
}) {
  // Validate a trial loadout so legality always mirrors Core loadout rules.
  var trial = setAbilityForSlot(loadout, slot: slot, abilityId: abilityId);
  if (overrideSelectedSource && slot == AbilitySlot.projectile) {
    trial = setProjectileSourceForSlot(
      trial,
      slot: slot,
      selectedSpellId: selectedSourceSpellId,
    );
  }
  final result = _loadoutValidator.validate(trial);
  for (final issue in result.issues) {
    if (issue.slot == slot) return false;
  }
  return true;
}

/// Copies [loadout] while preserving omitted fields.
///
/// [projectileSlotSpellId] uses [_keepValue] to distinguish "leave unchanged"
/// from an intentional `null` assignment.
EquippedLoadoutDef _copyLoadout(
  EquippedLoadoutDef loadout, {
  int? mask,
  WeaponId? mainWeaponId,
  WeaponId? offhandWeaponId,
  ProjectileId? projectileId,
  SpellBookId? spellBookId,
  Object? projectileSlotSpellId = _keepValue,
  AccessoryId? accessoryId,
  AbilityKey? abilityPrimaryId,
  AbilityKey? abilitySecondaryId,
  AbilityKey? abilityProjectileId,
  AbilityKey? abilitySpellId,
  AbilityKey? abilityMobilityId,
  AbilityKey? abilityJumpId,
}) {
  return EquippedLoadoutDef(
    mask: mask ?? loadout.mask,
    mainWeaponId: mainWeaponId ?? loadout.mainWeaponId,
    offhandWeaponId: offhandWeaponId ?? loadout.offhandWeaponId,
    projectileId: projectileId ?? loadout.projectileId,
    spellBookId: spellBookId ?? loadout.spellBookId,
    projectileSlotSpellId: identical(projectileSlotSpellId, _keepValue)
        ? loadout.projectileSlotSpellId
        : projectileSlotSpellId as ProjectileId?,
    accessoryId: accessoryId ?? loadout.accessoryId,
    abilityPrimaryId: abilityPrimaryId ?? loadout.abilityPrimaryId,
    abilitySecondaryId: abilitySecondaryId ?? loadout.abilitySecondaryId,
    abilityProjectileId: abilityProjectileId ?? loadout.abilityProjectileId,
    abilitySpellId: abilitySpellId ?? loadout.abilitySpellId,
    abilityMobilityId: abilityMobilityId ?? loadout.abilityMobilityId,
    abilityJumpId: abilityJumpId ?? loadout.abilityJumpId,
  );
}

/// Sentinel used by [_copyLoadout] for nullable override semantics.
const Object _keepValue = Object();


===== FILE: lib/ui/pages/selectCharacter/ability/ability_picker_shared.dart =====
import '../../../../core/abilities/ability_def.dart';
import '../../../../core/projectiles/projectile_id.dart';

/// Maps an ability definition to the weapon context used by tooltip text.
///
/// Projectile abilities resolve differently depending on whether the projectile
/// slot is currently bound to a spell projectile or the throwing weapon.
WeaponType? payloadWeaponTypeForTooltip({
  required AbilityDef def,
  required AbilitySlot slot,
  required ProjectileId? selectedSourceSpellId,
}) {
  switch (def.payloadSource) {
    case AbilityPayloadSource.none:
      return null;
    case AbilityPayloadSource.primaryWeapon:
      return null;
    case AbilityPayloadSource.secondaryWeapon:
      return null;
    case AbilityPayloadSource.projectile:
      if (slot == AbilitySlot.projectile && selectedSourceSpellId != null) {
        return WeaponType.projectileSpell;
      }
      return WeaponType.throwingWeapon;
    case AbilityPayloadSource.spellBook:
      return WeaponType.projectileSpell;
  }
}


===== FILE: lib/ui/pages/selectCharacter/gear/gear_picker_candidates_panel.dart =====
import 'package:flutter/material.dart';

import '../../../../core/meta/gear_slot.dart';
import '../../../../core/meta/meta_service.dart';
import '../../../components/gear_icon.dart';
import '../../../theme/ui_tokens.dart';
import 'gear_picker_parts.dart';

/// Right-side candidate panel.
///
/// Renders all slot candidates (unlocked + locked), while keeping the grid
/// non-scrollable and dense for landscape-only presentation.
class GearPickerCandidatesPanel extends StatelessWidget {
  const GearPickerCandidatesPanel({
    super.key,
    required this.slot,
    required this.candidates,
    required this.equippedId,
    required this.selectedId,
    required this.onSelected,
  });

  final GearSlot slot;
  final List<GearSlotCandidate> candidates;
  final Object equippedId;
  final Object? selectedId;
  final ValueChanged<Object> onSelected;

  @override
  Widget build(BuildContext context) {
    final ui = context.ui;
    if (candidates.isEmpty) {
      return Center(
        child: Text(
          'No options for this slot.',
          style: ui.text.body.copyWith(color: ui.colors.textMuted),
        ),
      );
    }

    return LayoutBuilder(
      builder: (context, constraints) {
        final spacing = ui.space.xs;
        final gridSpec = candidateGridSpecForAvailableSpace(
          itemCount: candidates.length,
          availableWidth: constraints.maxWidth,
          availableHeight: constraints.maxHeight,
          spacing: spacing,
        );

        return GridView.builder(
          itemCount: candidates.length,
          physics: const NeverScrollableScrollPhysics(),
          padding: EdgeInsets.zero,
          gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
            crossAxisCount: gridSpec.crossAxisCount,
            mainAxisSpacing: gridSpec.spacing,
            crossAxisSpacing: gridSpec.spacing,
            mainAxisExtent: gridSpec.mainAxisExtent,
          ),
          itemBuilder: (context, index) {
            final candidate = candidates[index];
            return _GearCandidateTile(
              slot: slot,
              id: candidate.id,
              isLocked: !candidate.isUnlocked,
              isEquipped: candidate.id == equippedId,
              selected: candidate.id == selectedId,
              // Locked candidates remain visible but are fully untappable.
              onTap: candidate.isUnlocked
                  ? () => onSelected(candidate.id)
                  : null,
            );
          },
        );
      },
    );
  }
}

/// Fixed-size candidate tile used in the right panel grid.
class _GearCandidateTile extends StatelessWidget {
  const _GearCandidateTile({
    required this.slot,
    required this.id,
    required this.isLocked,
    required this.isEquipped,
    required this.selected,
    required this.onTap,
  });

  final GearSlot slot;
  final Object id;
  final bool isLocked;
  final bool isEquipped;
  final bool selected;
  final VoidCallback? onTap;

  @override
  Widget build(BuildContext context) {
    final ui = context.ui;
    const tileSize = 64.0;
    const iconSize = 48.0;
    final lockedFillColor = ui.colors.background.withValues(alpha: 0.95);
    final selectedFillColor = UiBrandPalette.steelBlueInsetBottom;
    final defaultFillColor = ui.colors.cardBackground;
    final borderColor = isLocked
        ? ui.colors.outline.withValues(alpha: 0.35)
        : selected
        ? ui.colors.accentStrong
        : (isEquipped ? ui.colors.success : ui.colors.outline);

    final fillColor = isLocked
        ? lockedFillColor
        : selected
        ? selectedFillColor
        : defaultFillColor;
    final radius = ui.radii.sm;

    return Align(
      alignment: Alignment.center,
      child: SizedBox.square(
        dimension: tileSize,
        child: Material(
          color: Colors.transparent,
          child: InkWell(
            onTap: onTap,
            borderRadius: BorderRadius.circular(radius),
            child: AnimatedContainer(
              duration: const Duration(milliseconds: 160),
              curve: Curves.easeOutCubic,
              decoration: BoxDecoration(
                color: fillColor,
                borderRadius: BorderRadius.circular(radius),
                border: Border.all(
                  color: borderColor,
                  width: selected ? ui.sizes.borderWidth : 1,
                ),
                boxShadow: selected ? ui.shadows.card : null,
              ),
              child: Stack(
                fit: StackFit.expand,
                children: [
                  Center(
                    child: Opacity(
                      opacity: isLocked ? 0.45 : 1,
                      child: GearIcon(slot: slot, id: id, size: iconSize),
                    ),
                  ),
                  if (isLocked)
                    Positioned(
                      top: 2,
                      left: 2,
                      child: Icon(
                        Icons.lock,
                        size: 10,
                        color: ui.colors.textMuted,
                      ),
                    ),
                  if (isEquipped || selected)
                    Positioned(
                      top: 2,
                      right: 2,
                      child: Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          if (isEquipped) StateDot(color: ui.colors.success),
                          if (isEquipped && selected) const SizedBox(width: 2),
                          if (selected) StateDot(color: ui.colors.accentStrong),
                        ],
                      ),
                    ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}


===== FILE: lib/ui/pages/selectCharacter/gear/gear_picker_dialog.dart =====
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

import '../../../../core/meta/equipped_gear.dart';
import '../../../../core/meta/gear_slot.dart';
import '../../../../core/meta/meta_service.dart';
import '../../../../core/meta/meta_state.dart';
import '../../../../core/players/player_character_definition.dart';
import '../../../components/app_button.dart';
import '../../../state/app_state.dart';
import '../../../theme/ui_tokens.dart';
import 'gear_picker_candidates_panel.dart';
import 'gear_picker_stats_panel.dart';

/// Opens the gear picker modal for a specific [slot] and [characterId].
///
/// The dialog itself is a lightweight shell; panel rendering and stat
/// computation are delegated to dedicated modules.
Future<void> showGearPickerDialog(
  BuildContext context, {
  required MetaState meta,
  required MetaService service,
  required PlayerCharacterId characterId,
  required GearSlot slot,
}) {
  return showDialog<void>(
    context: context,
    barrierColor: context.ui.colors.scrim,
    builder: (dialogContext) {
      return _GearPickerDialog(
        meta: meta,
        service: service,
        characterId: characterId,
        slot: slot,
      );
    },
  );
}

/// Shell widget that owns dialog-local state and action wiring.
///
/// Responsibilities kept here:
/// - modal sizing/layout
/// - selected candidate state
/// - equip action dispatch through [AppState]
class _GearPickerDialog extends StatefulWidget {
  const _GearPickerDialog({
    required this.meta,
    required this.service,
    required this.characterId,
    required this.slot,
  });

  final MetaState meta;
  final MetaService service;
  final PlayerCharacterId characterId;
  final GearSlot slot;

  @override
  State<_GearPickerDialog> createState() => _GearPickerDialogState();
}

class _GearPickerDialogState extends State<_GearPickerDialog> {
  Object? _selectedCandidate;

  @override
  void initState() {
    super.initState();
    _selectedCandidate = _equippedIdForSlot(
      widget.slot,
      widget.meta.equippedFor(widget.characterId),
    );
  }

  @override
  Widget build(BuildContext context) {
    final ui = context.ui;
    final media = MediaQuery.of(context);
    final screenSize = media.size;
    final inset = ui.space.sm;
    final maxDialogWidth = (screenSize.width - (inset * 2))
        .clamp(320.0, 1180.0)
        .toDouble();
    final maxDialogHeight = (screenSize.height - (inset * 2))
        .clamp(300.0, 700.0)
        .toDouble();
    final statsPanelWidth = (maxDialogWidth * 0.35)
        .clamp(240.0, 340.0)
        .toDouble();
    final paneSpacing = ui.space.sm;
    final appState = context.watch<AppState>();
    final equipped = widget.meta.equippedFor(widget.characterId);

    final equippedId = _equippedIdForSlot(widget.slot, equipped);
    final candidates = widget.service.candidatesForSlot(
      widget.meta,
      widget.slot,
    );
    final selectedId = _selectedCandidate;

    // Resolve selected candidate metadata once so "Equip" can be disabled for
    // locked entries even if they are highlighted.
    GearSlotCandidate? selectedCandidate;
    if (selectedId != null) {
      for (final candidate in candidates) {
        if (candidate.id == selectedId) {
          selectedCandidate = candidate;
          break;
        }
      }
    }
    final canSwap =
        selectedId != null &&
        selectedId != equippedId &&
        (selectedCandidate?.isUnlocked ?? false);

    Future<void> equipSelected() async {
      final candidate = _selectedCandidate;
      if (candidate == null || candidate == equippedId) return;
      await appState.equipGear(
        characterId: widget.characterId,
        slot: widget.slot,
        itemId: candidate,
      );
      if (!context.mounted) return;
      Navigator.of(context).pop();
    }

    return Dialog(
      backgroundColor: ui.colors.cardBackground,
      insetPadding: EdgeInsets.all(inset),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(ui.radii.md),
        side: BorderSide(
          color: ui.colors.outline.withValues(alpha: 0.35),
          width: 1.2,
        ),
      ),
      clipBehavior: Clip.antiAlias,
      child: SizedBox(
        width: maxDialogWidth,
        height: maxDialogHeight,
        child: Padding(
          padding: EdgeInsets.all(ui.space.md),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              Expanded(
                child: Row(
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: [
                    SizedBox(
                      width: statsPanelWidth,
                      child: GearPickerStatsPanel(
                        slot: widget.slot,
                        id: selectedId,
                        equippedForCompare: equippedId,
                      ),
                    ),
                    SizedBox(width: paneSpacing),
                    Expanded(
                      child: GearPickerCandidatesPanel(
                        slot: widget.slot,
                        candidates: candidates,
                        equippedId: equippedId,
                        selectedId: selectedId,
                        onSelected: (value) =>
                            setState(() => _selectedCandidate = value),
                      ),
                    ),
                  ],
                ),
              ),
              SizedBox(height: paneSpacing),
              _GearDialogActions(
                canEquip: canSwap,
                onClose: () => Navigator.of(context).pop(),
                onEquip: equipSelected,
              ),
            ],
          ),
        ),
      ),
    );
  }
}

/// Compact action row shared by all slot pickers.
class _GearDialogActions extends StatelessWidget {
  const _GearDialogActions({
    required this.canEquip,
    required this.onClose,
    required this.onEquip,
  });

  final bool canEquip;
  final VoidCallback onClose;
  final VoidCallback onEquip;

  @override
  Widget build(BuildContext context) {
    final ui = context.ui;
    return Align(
      alignment: Alignment.centerRight,
      child: Wrap(
        spacing: ui.space.sm,
        runSpacing: ui.space.xs,
        children: [
          AppButton(
            label: 'Close',
            variant: AppButtonVariant.secondary,
            size: AppButtonSize.xs,
            onPressed: onClose,
          ),
          AppButton(
            label: 'Equip',
            variant: AppButtonVariant.primary,
            size: AppButtonSize.xs,
            onPressed: canEquip ? onEquip : null,
          ),
        ],
      ),
    );
  }
}

/// Reads equipped item id for [slot] from [equipped].
Object _equippedIdForSlot(GearSlot slot, EquippedGear equipped) {
  return switch (slot) {
    GearSlot.mainWeapon => equipped.mainWeaponId,
    GearSlot.offhandWeapon => equipped.offhandWeaponId,
    GearSlot.throwingWeapon => equipped.throwingWeaponId,
    GearSlot.spellBook => equipped.spellBookId,
    GearSlot.accessory => equipped.accessoryId,
  };
}


===== FILE: lib/ui/pages/selectCharacter/gear/gear_picker_parts.dart =====
import 'package:flutter/material.dart';

/// Tiny status marker used for selected/equipped indicators.
class StateDot extends StatelessWidget {
  const StateDot({super.key, required this.color});

  final Color color;

  @override
  Widget build(BuildContext context) {
    return Container(
      width: 6,
      height: 6,
      decoration: BoxDecoration(color: color, shape: BoxShape.circle),
    );
  }
}

/// Layout parameters for the fixed-size candidate grid.
class CandidateGridSpec {
  const CandidateGridSpec({
    required this.crossAxisCount,
    required this.mainAxisExtent,
    required this.spacing,
  });

  final int crossAxisCount;
  final double mainAxisExtent;
  final double spacing;
}

/// Computes a dense, non-scrollable grid spec for the right panel.
///
/// Tiles use a fixed extent; only column count adapts to available width.
CandidateGridSpec candidateGridSpecForAvailableSpace({
  required int itemCount,
  required double availableWidth,
  required double availableHeight,
  required double spacing,
}) {
  const tileExtent = 64.0;
  if (itemCount <= 0 || availableWidth <= 0 || availableHeight <= 0) {
    return CandidateGridSpec(
      crossAxisCount: 1,
      mainAxisExtent: tileExtent,
      spacing: spacing,
    );
  }

  const minTileWidth = tileExtent;
  final maxColumnsByWidth =
      ((availableWidth + spacing) / (minTileWidth + spacing)).floor().clamp(
        1,
        999,
      );

  return CandidateGridSpec(
    crossAxisCount: maxColumnsByWidth,
    mainAxisExtent: tileExtent,
    spacing: spacing,
  );
}


===== FILE: lib/ui/pages/selectCharacter/gear/gear_picker_stats_panel.dart =====
import 'package:flutter/material.dart';

import '../../../../core/meta/gear_slot.dart';
import '../../../components/gear_icon.dart';
import '../../../text/gear_text.dart';
import '../../../theme/ui_tokens.dart';
import 'gear_stats_presenter.dart';

/// Left-side stats panel for the currently selected gear.
///
/// Pure display widget: it consumes precomputed stat lines from
/// [gear_stats_presenter.dart] and does not mutate state.
class GearPickerStatsPanel extends StatelessWidget {
  const GearPickerStatsPanel({
    super.key,
    required this.slot,
    required this.id,
    this.equippedForCompare,
  });

  final GearSlot slot;
  final Object? id;
  final Object? equippedForCompare;

  @override
  Widget build(BuildContext context) {
    final ui = context.ui;
    final panelFillColor = ui.colors.cardBackground;
    final iconFrameFillColor = UiBrandPalette.steelBlueInsetBottom;
    final lines = id == null ? const <GearStatLine>[] : gearStatsFor(slot, id!);
    final compareLines = (id == null || equippedForCompare == null)
        ? const <GearStatLine>[]
        : gearCompareStats(slot, equipped: equippedForCompare!, candidate: id!);
    final compareEmptyText = gearCompareEmptyText(
      selectedId: id,
      equippedForCompare: equippedForCompare,
    );
    final cardPadding = ui.space.xs;
    final iconFrameSize = 48.0;
    final blockSpacing = ui.space.xs;

    return Container(
      decoration: BoxDecoration(
        color: panelFillColor,
        borderRadius: BorderRadius.circular(ui.radii.md),
        border: Border.all(color: ui.colors.outline.withValues(alpha: 0.4)),
        boxShadow: ui.shadows.card,
      ),
      padding: EdgeInsets.all(cardPadding),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          if (id == null)
            Expanded(
              child: Center(
                child: Text(
                  'Select an item to preview stats.',
                  style: ui.text.caption.copyWith(color: ui.colors.textMuted),
                  textAlign: TextAlign.center,
                  maxLines: 2,
                  overflow: TextOverflow.ellipsis,
                ),
              ),
            )
          else
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Container(
                        width: iconFrameSize,
                        height: iconFrameSize,
                        decoration: BoxDecoration(
                          color: iconFrameFillColor,
                          borderRadius: BorderRadius.circular(ui.radii.sm),
                          border: Border.all(
                            color: ui.colors.outline.withValues(alpha: 0.35),
                          ),
                        ),
                        alignment: Alignment.center,
                        child: GearIcon(slot: slot, id: id!),
                      ),
                      SizedBox(width: ui.space.sm),
                      Expanded(
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Text(
                              gearDisplayNameForSlot(slot, id!),
                              style: ui.text.caption.copyWith(
                                color: ui.colors.textPrimary,
                              ),
                              maxLines: 1,
                              overflow: TextOverflow.ellipsis,
                            ),
                            const SizedBox(height: 1),
                            Text(
                              '"${gearDescriptionForSlot(slot, id!)}"',
                              style: ui.text.caption.copyWith(
                                color: ui.colors.textMuted,
                                fontSize: 9,
                                height: 1.0,
                              ),
                              maxLines: 2,
                              softWrap: true,
                              overflow: TextOverflow.clip,
                            ),
                          ],
                        ),
                      ),
                    ],
                  ),
                  SizedBox(height: blockSpacing),
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Expanded(
                          child: _StatSection(
                            title: 'Stats',
                            lines: lines,
                            emptyText: 'No non-zero stat bonuses.',
                          ),
                        ),
                        if (equippedForCompare != null) ...[
                          SizedBox(height: blockSpacing),
                          Expanded(
                            child: _StatSection(
                              title: 'Compared to equipped gear:',
                              lines: compareLines,
                              emptyText: compareEmptyText,
                            ),
                          ),
                        ],
                      ],
                    ),
                  ),
                ],
              ),
            ),
        ],
      ),
    );
  }
}

/// Small bordered section used for base stats and compare stats.
class _StatSection extends StatelessWidget {
  const _StatSection({
    required this.title,
    required this.lines,
    required this.emptyText,
  });

  final String title;
  final List<GearStatLine> lines;
  final String emptyText;

  @override
  Widget build(BuildContext context) {
    final ui = context.ui;
    final sectionFillColor = ui.colors.background;
    final sectionPadding = const EdgeInsets.symmetric(
      horizontal: 6,
      vertical: 4,
    );
    final headingStyle = ui.text.caption.copyWith(
      color: ui.colors.textMuted,
      fontWeight: FontWeight.w700,
      fontSize: 10,
      height: 1.0,
    );
    final emptyStyle = ui.text.caption.copyWith(
      color: ui.colors.textMuted,
      fontSize: 10,
      height: 1.0,
    );
    const interItemGap = 2.0;
    const estimatedRowHeight = 12.0;

    return LayoutBuilder(
      builder: (context, constraints) {
        final availableForRows =
            constraints.maxHeight - sectionPadding.vertical - 10 - interItemGap;
        // Clamp visible lines to the currently available section height to
        // avoid overflows in tighter landscape layouts.
        final maxRows = availableForRows.isFinite
            ? (availableForRows / estimatedRowHeight).floor()
            : lines.length;
        final safeMaxRows = maxRows < 1 ? 1 : maxRows;
        final visibleLines = lines.take(safeMaxRows).toList(growable: false);
        final hiddenLineCount = lines.length - visibleLines.length;

        return Container(
          width: double.infinity,
          padding: sectionPadding,
          decoration: BoxDecoration(
            color: sectionFillColor,
            borderRadius: BorderRadius.circular(ui.radii.sm),
            border: Border.all(
              color: ui.colors.outline.withValues(alpha: 0.25),
            ),
          ),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                title,
                style: headingStyle,
                maxLines: 1,
                overflow: TextOverflow.ellipsis,
              ),
              SizedBox(height: interItemGap),
              if (lines.isEmpty)
                Text(
                  emptyText,
                  style: emptyStyle,
                  maxLines: 1,
                  overflow: TextOverflow.ellipsis,
                )
              else ...[
                for (final line in visibleLines) _StatLineText(line: line),
                if (hiddenLineCount > 0)
                  Text(
                    '+$hiddenLineCount more',
                    style: emptyStyle,
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
              ],
            ],
          ),
        );
      },
    );
  }
}

/// Single stat row with contextual value color (neutral/positive/negative).
class _StatLineText extends StatelessWidget {
  const _StatLineText({required this.line});

  final GearStatLine line;

  @override
  Widget build(BuildContext context) {
    final ui = context.ui;
    final valueColor = switch (line.tone) {
      GearStatLineTone.neutral => ui.colors.textPrimary,
      GearStatLineTone.positive => ui.colors.success,
      GearStatLineTone.negative => ui.colors.danger,
    };
    final labelStyle = ui.text.caption.copyWith(
      color: ui.colors.textMuted,
      fontSize: 10,
      height: 1.0,
    );
    final valueStyle = ui.text.caption.copyWith(
      color: valueColor,
      fontWeight: FontWeight.w600,
      fontSize: 10,
      height: 1.0,
    );

    return Padding(
      padding: const EdgeInsets.only(bottom: 1),
      child: Row(
        children: [
          Expanded(
            child: Text(
              line.label,
              style: labelStyle,
              maxLines: 1,
              overflow: TextOverflow.ellipsis,
            ),
          ),
          Text(
            line.value,
            style: valueStyle,
            maxLines: 1,
            overflow: TextOverflow.ellipsis,
          ),
        ],
      ),
    );
  }
}


===== FILE: lib/ui/pages/selectCharacter/gear/gear_stats_presenter.dart =====
import '../../../../core/accessories/accessory_catalog.dart';
import '../../../../core/accessories/accessory_def.dart';
import '../../../../core/accessories/accessory_id.dart';
import '../../../../core/meta/gear_slot.dart';
import '../../../../core/projectiles/projectile_catalog.dart';
import '../../../../core/projectiles/projectile_item_def.dart';
import '../../../../core/projectiles/projectile_id.dart';
import '../../../../core/spellBook/spell_book_catalog.dart';
import '../../../../core/spellBook/spell_book_def.dart';
import '../../../../core/spellBook/spell_book_id.dart';
import '../../../../core/stats/character_stat_id.dart';
import '../../../../core/stats/gear_stat_bonuses.dart';
import '../../../../core/weapons/weapon_def.dart';
import '../../../../core/weapons/weapon_id.dart';
import '../../../../core/weapons/weapon_catalog.dart';

/// UI tone hints for stat values.
enum GearStatLineTone { neutral, positive, negative }

/// Display-ready stat row used by the stats panel.
class GearStatLine {
  const GearStatLine(
    this.label,
    this.value, {
    this.tone = GearStatLineTone.neutral,
  });

  final String label;
  final String value;
  final GearStatLineTone tone;
}

/// Builds base stat lines for a selected gear item.
///
/// This is pure computation (no widget or state dependencies).
List<GearStatLine> gearStatsFor(GearSlot slot, Object id) {
  switch (slot) {
    case GearSlot.mainWeapon:
    case GearSlot.offhandWeapon:
      final def = const WeaponCatalog().get(id as WeaponId);
      return _weaponDefStats(def);
    case GearSlot.throwingWeapon:
      final def = const ProjectileCatalog().get(id as ProjectileId);
      return _projectileStats(def);
    case GearSlot.spellBook:
      final def = const SpellBookCatalog().get(id as SpellBookId);
      return _spellBookStats(def);
    case GearSlot.accessory:
      final def = const AccessoryCatalog().get(id as AccessoryId);
      return _accessoryStats(def);
  }
}

/// Builds compare stat lines between currently equipped and selected gear.
///
/// Returns an empty list when both ids are the same item.
List<GearStatLine> gearCompareStats(
  GearSlot slot, {
  required Object equipped,
  required Object candidate,
}) {
  if (equipped == candidate) return const <GearStatLine>[];
  switch (slot) {
    case GearSlot.mainWeapon:
    case GearSlot.offhandWeapon:
      final a = const WeaponCatalog().get(equipped as WeaponId);
      final b = const WeaponCatalog().get(candidate as WeaponId);
      return _diffWeaponStats(a, b);
    case GearSlot.throwingWeapon:
      final a = const ProjectileCatalog().get(equipped as ProjectileId);
      final b = const ProjectileCatalog().get(candidate as ProjectileId);
      return _diffWeaponStatsLike(a.stats, b.stats);
    case GearSlot.spellBook:
      final a = const SpellBookCatalog().get(equipped as SpellBookId);
      final b = const SpellBookCatalog().get(candidate as SpellBookId);
      return _diffWeaponStatsLike(a.stats, b.stats);
    case GearSlot.accessory:
      final a = const AccessoryCatalog().get(equipped as AccessoryId);
      final b = const AccessoryCatalog().get(candidate as AccessoryId);
      return _diffAccessoryStats(a.stats, b.stats);
  }
}

/// Empty state text for the compare section.
String gearCompareEmptyText({
  required Object? selectedId,
  required Object? equippedForCompare,
}) {
  if (selectedId != null &&
      equippedForCompare != null &&
      selectedId == equippedForCompare) {
    return 'This gear is currently equipped.';
  }
  return 'No stat differences.';
}

List<GearStatLine> _weaponDefStats(WeaponDef def) {
  final stats = def.stats;
  final lines = <GearStatLine>[
    GearStatLine('Type', _enumLabel(def.weaponType.name)),
  ];
  _addCoreStatLines(lines, stats);
  return lines;
}

List<GearStatLine> _projectileStats(ProjectileItemDef def) {
  final stats = def.stats;
  final lines = <GearStatLine>[
    GearStatLine('Type', _enumLabel(def.weaponType.name)),
    GearStatLine('Damage Type', _enumLabel(def.damageType.name)),
    GearStatLine('Ballistic', def.ballistic ? 'Yes' : 'No'),
  ];
  _addCoreStatLines(lines, stats);
  return lines;
}

List<GearStatLine> _spellBookStats(SpellBookDef def) {
  final stats = def.stats;
  final lines = <GearStatLine>[
    GearStatLine('Type', _enumLabel(def.weaponType.name)),
    GearStatLine(
      'Damage Type',
      def.damageType == null ? 'Ability' : _enumLabel(def.damageType!.name),
    ),
  ];
  _addCoreStatLines(lines, stats);
  return lines;
}

List<GearStatLine> _accessoryStats(AccessoryDef def) {
  final stats = def.stats;
  final lines = <GearStatLine>[];
  _addCoreStatLines(lines, stats);
  return lines;
}

void _addBpStat(List<GearStatLine> lines, String label, int value) {
  if (value == 0) return;
  lines.add(GearStatLine(label, _bpPct(value)));
}

List<GearStatLine> _diffWeaponStats(WeaponDef equipped, WeaponDef candidate) {
  return _diffStatBonuses(equipped.stats, candidate.stats);
}

List<GearStatLine> _diffWeaponStatsLike(GearStatBonuses a, GearStatBonuses b) {
  return _diffStatBonuses(a, b);
}

List<GearStatLine> _diffAccessoryStats(GearStatBonuses a, GearStatBonuses b) {
  return _diffStatBonuses(a, b);
}

void _addCoreStatLines(List<GearStatLine> lines, GearStatBonuses stats) {
  _addBpStat(lines, _labelFor(CharacterStatId.health), stats.healthBonusBp);
  _addBpStat(lines, _labelFor(CharacterStatId.mana), stats.manaBonusBp);
  _addBpStat(lines, _labelFor(CharacterStatId.stamina), stats.staminaBonusBp);
  _addBpStat(lines, _labelFor(CharacterStatId.defense), stats.defenseBonusBp);
  _addBpStat(lines, _labelFor(CharacterStatId.power), _effectivePowerBp(stats));
  _addBpStat(
    lines,
    _labelFor(CharacterStatId.moveSpeed),
    stats.moveSpeedBonusBp,
  );
  _addBpStat(
    lines,
    _labelFor(CharacterStatId.cooldownReduction),
    stats.cooldownReductionBp,
  );
  _addBpStat(
    lines,
    _labelFor(CharacterStatId.critChance),
    _effectiveCritChanceBp(stats),
  );
  _addBpStat(
    lines,
    _labelFor(CharacterStatId.physicalResistance),
    stats.physicalResistanceBp,
  );
  _addBpStat(
    lines,
    _labelFor(CharacterStatId.fireResistance),
    stats.fireResistanceBp,
  );
  _addBpStat(
    lines,
    _labelFor(CharacterStatId.iceResistance),
    stats.iceResistanceBp,
  );
  _addBpStat(
    lines,
    _labelFor(CharacterStatId.thunderResistance),
    stats.thunderResistanceBp,
  );
  _addBpStat(
    lines,
    _labelFor(CharacterStatId.bleedResistance),
    stats.bleedResistanceBp,
  );
}

List<GearStatLine> _diffStatBonuses(GearStatBonuses a, GearStatBonuses b) {
  final lines = <GearStatLine>[];
  if (b.healthBonusBp != a.healthBonusBp) {
    lines.add(
      _deltaBpLine(
        _labelFor(CharacterStatId.health),
        a.healthBonusBp,
        b.healthBonusBp,
      ),
    );
  }
  if (b.manaBonusBp != a.manaBonusBp) {
    lines.add(
      _deltaBpLine(
        _labelFor(CharacterStatId.mana),
        a.manaBonusBp,
        b.manaBonusBp,
      ),
    );
  }
  if (b.staminaBonusBp != a.staminaBonusBp) {
    lines.add(
      _deltaBpLine(
        _labelFor(CharacterStatId.stamina),
        a.staminaBonusBp,
        b.staminaBonusBp,
      ),
    );
  }
  if (b.defenseBonusBp != a.defenseBonusBp) {
    lines.add(
      _deltaBpLine(
        _labelFor(CharacterStatId.defense),
        a.defenseBonusBp,
        b.defenseBonusBp,
      ),
    );
  }
  if (b.moveSpeedBonusBp != a.moveSpeedBonusBp) {
    lines.add(
      _deltaBpLine(
        _labelFor(CharacterStatId.moveSpeed),
        a.moveSpeedBonusBp,
        b.moveSpeedBonusBp,
      ),
    );
  }
  final aPowerBp = _effectivePowerBp(a);
  final bPowerBp = _effectivePowerBp(b);
  if (bPowerBp != aPowerBp) {
    lines.add(
      _deltaBpLine(_labelFor(CharacterStatId.power), aPowerBp, bPowerBp),
    );
  }
  if (b.cooldownReductionBp != a.cooldownReductionBp) {
    lines.add(
      _deltaBpLine(
        _labelFor(CharacterStatId.cooldownReduction),
        a.cooldownReductionBp,
        b.cooldownReductionBp,
      ),
    );
  }
  final aCritChanceBp = _effectiveCritChanceBp(a);
  final bCritChanceBp = _effectiveCritChanceBp(b);
  if (bCritChanceBp != aCritChanceBp) {
    lines.add(
      _deltaBpLine(
        _labelFor(CharacterStatId.critChance),
        aCritChanceBp,
        bCritChanceBp,
      ),
    );
  }
  if (b.physicalResistanceBp != a.physicalResistanceBp) {
    lines.add(
      _deltaBpLine(
        _labelFor(CharacterStatId.physicalResistance),
        a.physicalResistanceBp,
        b.physicalResistanceBp,
      ),
    );
  }
  if (b.fireResistanceBp != a.fireResistanceBp) {
    lines.add(
      _deltaBpLine(
        _labelFor(CharacterStatId.fireResistance),
        a.fireResistanceBp,
        b.fireResistanceBp,
      ),
    );
  }
  if (b.iceResistanceBp != a.iceResistanceBp) {
    lines.add(
      _deltaBpLine(
        _labelFor(CharacterStatId.iceResistance),
        a.iceResistanceBp,
        b.iceResistanceBp,
      ),
    );
  }
  if (b.thunderResistanceBp != a.thunderResistanceBp) {
    lines.add(
      _deltaBpLine(
        _labelFor(CharacterStatId.thunderResistance),
        a.thunderResistanceBp,
        b.thunderResistanceBp,
      ),
    );
  }
  if (b.bleedResistanceBp != a.bleedResistanceBp) {
    lines.add(
      _deltaBpLine(
        _labelFor(CharacterStatId.bleedResistance),
        a.bleedResistanceBp,
        b.bleedResistanceBp,
      ),
    );
  }
  return lines;
}

GearStatLine _deltaBpLine(String label, int equippedValue, int candidateValue) {
  final delta = candidateValue - equippedValue;
  return GearStatLine(
    label,
    _signedPercent(delta / 100),
    tone: _toneForDelta(delta),
  );
}

GearStatLineTone _toneForDelta(int delta) {
  if (delta > 0) return GearStatLineTone.positive;
  if (delta < 0) return GearStatLineTone.negative;
  return GearStatLineTone.neutral;
}

int _effectivePowerBp(GearStatBonuses stats) {
  return stats.powerBonusBp + stats.globalPowerBonusBp;
}

int _effectiveCritChanceBp(GearStatBonuses stats) {
  return stats.critChanceBonusBp + stats.globalCritChanceBonusBp;
}

String _bpPct(int bp) => _signedPercent(bp / 100);

String _signedPercent(double value) {
  final sign = value > 0 ? '+' : '';
  return '$sign${_formatNumber(value)}%';
}

String _formatNumber(double value) {
  final fixed = value.toStringAsFixed(2);
  return fixed.replaceFirst(RegExp(r'\.?0+$'), '');
}

String _enumLabel(String source) {
  final normalized = source
      .replaceAll('_', ' ')
      .replaceAllMapped(
        RegExp(r'([a-z0-9])([A-Z])'),
        (match) => '${match.group(1)} ${match.group(2)}',
      );
  final words = normalized.split(RegExp(r'\s+'));
  return words
      .where((word) => word.isNotEmpty)
      .map((word) {
        if (word == word.toUpperCase()) return word;
        return '${word[0].toUpperCase()}${word.substring(1).toLowerCase()}';
      })
      .join(' ');
}

String _labelFor(CharacterStatId id) => characterStatDescriptor(id).displayName;


===== FILE: lib/ui/pages/selectCharacter/gears_tab.dart =====
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

import '../../../core/meta/gear_slot.dart';
import '../../../core/meta/meta_service.dart';
import '../../../core/players/player_character_definition.dart';
import '../../components/gear_icon.dart';
import '../../state/app_state.dart';
import '../../theme/ui_tokens.dart';
import 'gear/gear_picker_dialog.dart';

class GearsTab extends StatelessWidget {
  const GearsTab({super.key, required this.characterId});

  final PlayerCharacterId characterId;

  @override
  Widget build(BuildContext context) {
    final ui = context.ui;
    final appState = context.watch<AppState>();
    final meta = appState.meta;
    final gear = meta.equippedFor(characterId);
    const service = MetaService();

    return Padding(
      padding: EdgeInsets.only(left: ui.space.xxs, top: ui.space.xxs),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text('Equipped Gear', style: ui.text.headline),
          SizedBox(height: ui.space.xxs),
          Wrap(
            spacing: ui.space.xs,
            runSpacing: ui.space.xs,
            children: [
              _GearSlotButton(
                label: 'Sword',
                child: GearIcon(
                  slot: GearSlot.mainWeapon,
                  id: gear.mainWeaponId,
                ),
                onTap: () => showGearPickerDialog(
                  context,
                  meta: meta,
                  service: service,
                  characterId: characterId,
                  slot: GearSlot.mainWeapon,
                ),
              ),
              _GearSlotButton(
                label: 'Shield',
                child: GearIcon(
                  slot: GearSlot.offhandWeapon,
                  id: gear.offhandWeaponId,
                ),
                onTap: () => showGearPickerDialog(
                  context,
                  meta: meta,
                  service: service,
                  characterId: characterId,
                  slot: GearSlot.offhandWeapon,
                ),
              ),
              _GearSlotButton(
                label: 'Throw',
                child: GearIcon(
                  slot: GearSlot.throwingWeapon,
                  id: gear.throwingWeaponId,
                ),
                onTap: () => showGearPickerDialog(
                  context,
                  meta: meta,
                  service: service,
                  characterId: characterId,
                  slot: GearSlot.throwingWeapon,
                ),
              ),
              _GearSlotButton(
                label: 'Book',
                child: GearIcon(slot: GearSlot.spellBook, id: gear.spellBookId),
                onTap: () => showGearPickerDialog(
                  context,
                  meta: meta,
                  service: service,
                  characterId: characterId,
                  slot: GearSlot.spellBook,
                ),
              ),
              _GearSlotButton(
                label: 'Trinket',
                child: GearIcon(slot: GearSlot.accessory, id: gear.accessoryId),
                onTap: () => showGearPickerDialog(
                  context,
                  meta: meta,
                  service: service,
                  characterId: characterId,
                  slot: GearSlot.accessory,
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }
}

class _GearSlotButton extends StatelessWidget {
  const _GearSlotButton({
    required this.label,
    required this.child,
    required this.onTap,
  });

  final String label;
  final Widget child;
  final VoidCallback onTap;

  @override
  Widget build(BuildContext context) {
    final ui = context.ui;
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        Material(
          color: Colors.transparent,
          child: InkWell(
            onTap: onTap,
            borderRadius: BorderRadius.circular(ui.radii.sm),
            child: Container(
              width: 48,
              height: 48,
              decoration: BoxDecoration(
                color: ui.colors.cardBackground,
                borderRadius: BorderRadius.circular(ui.radii.sm),
                border: Border.all(color: ui.colors.outline),
              ),
              alignment: Alignment.center,
              child: child,
            ),
          ),
        ),
        SizedBox(height: ui.space.xxs),
        Text(label, style: ui.text.caption),
      ],
    );
  }
}


===== FILE: lib/ui/pages/selectCharacter/loadout_setup_page.dart =====
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

import '../../../core/players/player_character_definition.dart';
import '../../../core/players/player_character_registry.dart';
import '../../components/menu_layout.dart';
import '../../components/menu_scaffold.dart';
import '../../state/app_state.dart';
import '../../theme/ui_tokens.dart';
import 'gears_tab.dart';
import 'skills_tab.dart';

// Keep multi-character backend logic intact; UI currently exposes only primary.
const List<PlayerCharacterDefinition> _loadoutSetupUiCharacters = [
  PlayerCharacterRegistry.eloise,
];

class LoadoutSetupPage extends StatefulWidget {
  const LoadoutSetupPage({super.key});

  @override
  State<LoadoutSetupPage> createState() => _LoadoutSetupPageState();
}

class _LoadoutSetupPageState extends State<LoadoutSetupPage> {
  bool _seeded = false;

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    if (_seeded) return;
    final appState = context.read<AppState>();
    final selection = appState.selection;
    final defs = _loadoutSetupUiCharacters;
    if (defs.first.id != selection.selectedCharacterId) {
      unawaited(appState.setCharacter(defs.first.id));
    }
    _seeded = true;
  }

  @override
  Widget build(BuildContext context) {
    final ui = context.ui;
    final selectedDef = _loadoutSetupUiCharacters.first;

    return DefaultTabController(
      length: 2,
      initialIndex: 0,
      child: MenuScaffold(
        appBarTitle: TabBar(
          labelColor: ui.colors.textPrimary,
          unselectedLabelColor: ui.colors.textMuted,
          labelStyle: ui.text.headline,
          indicatorColor: ui.colors.accent,
          tabs: const [
            Tab(text: 'Gear'),
            Tab(text: 'Skills'),
          ],
        ),
        child: MenuLayout(
          scrollable: false,
          child: _LoadoutSetupBody(characterId: selectedDef.id),
        ),
      ),
    );
  }
}

class _LoadoutSetupBody extends StatelessWidget {
  const _LoadoutSetupBody({required this.characterId});

  final PlayerCharacterId characterId;

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        Expanded(
          child: TabBarView(
            // Keep setup tab selection explicit: tabs change via click/tap only.
            physics: const NeverScrollableScrollPhysics(),
            children: [
              GearsTab(characterId: characterId),
              SkillsBar(characterId: characterId),
            ],
          ),
        ),
      ],
    );
  }
}


===== FILE: lib/ui/pages/selectCharacter/skills/skills_details_pane.dart =====
import 'package:flutter/material.dart';

import '../../../text/ability_tooltip_builder.dart';
import '../../../theme/ui_tokens.dart';

class SkillsDetailsPane extends StatelessWidget {
  const SkillsDetailsPane({super.key, required this.tooltip});

  final AbilityTooltip? tooltip;

  @override
  Widget build(BuildContext context) {
    return SingleChildScrollView(child: _AbilityDetailsPane(tooltip: tooltip));
  }
}

class _AbilityDetailsPane extends StatelessWidget {
  const _AbilityDetailsPane({required this.tooltip});

  final AbilityTooltip? tooltip;

  @override
  Widget build(BuildContext context) {
    final ui = context.ui;
    return Container(
      decoration: BoxDecoration(
        color: ui.colors.cardBackground,
        borderRadius: BorderRadius.circular(ui.radii.md),
        border: Border.all(color: ui.colors.outline.withValues(alpha: 0.25)),
      ),
      padding: EdgeInsets.all(ui.space.sm),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        mainAxisSize: MainAxisSize.min,
        children: [
          if (tooltip == null) ...[
            Text(
              'No ability available for this slot.',
              style: ui.text.body.copyWith(color: ui.colors.textMuted),
            ),
          ] else ...[
            Text(
              tooltip!.title,
              style: ui.text.loreHeading.copyWith(color: ui.colors.textPrimary),
            ),
            SizedBox(height: ui.space.xxs),
            Container(
              height: 1,
              color: ui.colors.outline.withValues(alpha: 0.35),
            ),
            if (tooltip!.cooldownSeconds != null) ...[
              SizedBox(height: ui.space.xxs),
              _DetailsMetricLine(
                label: 'Cooldown: ',
                value:
                    '${_formatCooldownSeconds(tooltip!.cooldownSeconds!)} seconds',
              ),
            ],
            if (tooltip!.costLines.isNotEmpty) ...[
              for (final costLine in tooltip!.costLines) ...[
                SizedBox(height: ui.space.xxs),
                _DetailsMetricLine(
                  label: costLine.label,
                  value: costLine.value,
                ),
              ],
            ],
            if (tooltip!.maxDurationSeconds != null) ...[
              SizedBox(height: ui.space.xxs),
              _DetailsMetricLine(
                label: 'Max duration: ',
                value:
                    '${_formatCooldownSeconds(tooltip!.maxDurationSeconds!)} seconds',
              ),
            ],
            SizedBox(height: ui.space.xxs),
            Text.rich(
              TextSpan(
                style: ui.text.body.copyWith(color: ui.colors.textMuted),
                children: _buildDescriptionSpans(
                  description: tooltip!.description,
                  dynamicValues: tooltip!.dynamicDescriptionValues,
                  normalStyle: ui.text.body.copyWith(
                    color: ui.colors.textMuted,
                  ),
                  dynamicStyle: ui.text.body.copyWith(
                    color: ui.colors.valueHighlight,
                    fontWeight: FontWeight.w600,
                  ),
                ),
              ),
            ),
            if (tooltip!.badges.isNotEmpty) ...[
              SizedBox(height: ui.space.xs),
              Wrap(
                spacing: ui.space.xs,
                runSpacing: ui.space.xs,
                children: [
                  for (final badge in tooltip!.badges)
                    _AbilityBadge(text: badge),
                ],
              ),
            ],
          ],
        ],
      ),
    );
  }
}

/// Splits [description] into styled [TextSpan]s, highlighting [dynamicValues].
///
/// Values are matched longest-first to prevent partial overlaps when a shorter
/// token is a substring of a longer one (e.g. "5" inside "50%").
List<TextSpan> _buildDescriptionSpans({
  required String description,
  required List<String> dynamicValues,
  required TextStyle normalStyle,
  required TextStyle dynamicStyle,
}) {
  final values =
      dynamicValues.toSet().where((value) => value.isNotEmpty).toList()
        ..sort((a, b) => b.length.compareTo(a.length));
  if (values.isEmpty) {
    return <TextSpan>[TextSpan(text: description, style: normalStyle)];
  }

  final pattern = values.map(RegExp.escape).join('|');
  final regex = RegExp(pattern);
  final spans = <TextSpan>[];
  var index = 0;
  for (final match in regex.allMatches(description)) {
    if (match.start > index) {
      spans.add(
        TextSpan(
          text: description.substring(index, match.start),
          style: normalStyle,
        ),
      );
    }
    spans.add(TextSpan(text: match.group(0), style: dynamicStyle));
    index = match.end;
  }

  if (index < description.length) {
    spans.add(TextSpan(text: description.substring(index), style: normalStyle));
  }
  return spans;
}

class _DetailsMetricLine extends StatelessWidget {
  const _DetailsMetricLine({required this.label, required this.value});

  final String label;
  final String value;

  @override
  Widget build(BuildContext context) {
    final ui = context.ui;
    final labelStyle = ui.text.loreBody.copyWith(
      color: ui.colors.textMuted,
      fontWeight: FontWeight.w600,
    );
    final valueStyle = ui.text.body.copyWith(
      color: ui.colors.valueHighlight,
      fontWeight: FontWeight.w600,
    );
    return Text.rich(
      TextSpan(
        style: labelStyle,
        children: [
          TextSpan(text: label, style: labelStyle),
          TextSpan(text: value, style: valueStyle),
        ],
      ),
    );
  }
}

String _formatCooldownSeconds(double seconds) {
  return seconds.toStringAsFixed(1).replaceFirst(RegExp(r'\.0$'), '');
}

class _AbilityBadge extends StatelessWidget {
  const _AbilityBadge({required this.text});

  final String text;

  @override
  Widget build(BuildContext context) {
    final ui = context.ui;
    return Container(
      padding: EdgeInsets.symmetric(
        horizontal: ui.space.xs,
        vertical: ui.space.xxs,
      ),
      decoration: BoxDecoration(
        color: UiBrandPalette.steelBlueInsetBottom,
        borderRadius: BorderRadius.circular(ui.radii.sm),
        border: Border.all(color: ui.colors.outline.withValues(alpha: 0.35)),
      ),
      child: Text(
        text,
        style: ui.text.caption.copyWith(
          color: ui.colors.textPrimary,
          fontWeight: FontWeight.w600,
        ),
      ),
    );
  }
}


===== FILE: lib/ui/pages/selectCharacter/skills/skills_list_pane.dart =====
import 'package:flutter/material.dart';

import '../../../../core/abilities/ability_def.dart';
import '../../../../core/projectiles/projectile_id.dart';
import '../../../components/ability_placeholder_icon.dart';
import '../../../components/app_button.dart';
import '../../../icons/projectile_icon_frame.dart';
import '../../../text/ability_text.dart';
import '../../../theme/ui_tokens.dart';
import '../ability/ability_picker_presenter.dart';

class SkillsListPane extends StatelessWidget {
  const SkillsListPane({
    super.key,
    required this.selectedSlot,
    required this.candidates,
    required this.selectedAbilityId,
    required this.onSelectAbility,
    required this.onSelectProjectileSource,
  });

  final AbilitySlot selectedSlot;
  final List<AbilityPickerCandidate> candidates;
  final AbilityKey? selectedAbilityId;
  final ValueChanged<AbilityPickerCandidate> onSelectAbility;
  final VoidCallback? onSelectProjectileSource;

  @override
  Widget build(BuildContext context) {
    final ui = context.ui;
    return Container(
      decoration: BoxDecoration(
        color: ui.colors.cardBackground,
        borderRadius: BorderRadius.circular(ui.radii.md),
        border: Border.all(color: ui.colors.outline.withValues(alpha: 0.25)),
      ),
      padding: EdgeInsets.all(ui.space.xs),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Align(
            alignment: Alignment.center,
            child: Text(
              '${_slotTitle(selectedSlot).toUpperCase()} SKILLS',
              style: ui.text.loreHeading.copyWith(
                color: ui.colors.textPrimary,
                fontSize: 14,
                fontWeight: FontWeight.w600,
                letterSpacing: 0.3,
              ),
              textAlign: TextAlign.center,
              maxLines: 1,
              overflow: TextOverflow.ellipsis,
            ),
          ),
          SizedBox(height: ui.space.xxs),
          Container(
            height: 1,
            color: ui.colors.outline.withValues(alpha: 0.35),
          ),
          SizedBox(height: ui.space.xxs),
          if (onSelectProjectileSource != null) ...[
            Align(
              alignment: Alignment.center,
              child: AppButton(
                label: 'Select Projectile',
                variant: AppButtonVariant.secondary,
                size: AppButtonSize.sm,
                onPressed: onSelectProjectileSource,
              ),
            ),
          ],
          SizedBox(height: ui.space.xxs),
          Expanded(
            child: ListView.separated(
              itemCount: candidates.length,
              separatorBuilder: (_, _) => SizedBox(height: ui.space.xxs),
              itemBuilder: (context, index) {
                final candidate = candidates[index];
                final selected = candidate.id == selectedAbilityId;
                return _AbilityListTile(
                  title: abilityDisplayName(candidate.id),
                  selected: selected,
                  enabled: candidate.isEnabled,
                  onTap: () => onSelectAbility(candidate),
                );
              },
            ),
          ),
        ],
      ),
    );
  }
}

class SkillsProjectileSourceTile extends StatelessWidget {
  const SkillsProjectileSourceTile({
    super.key,
    required this.projectileId,
    required this.title,
    required this.selected,
    required this.onTap,
    this.expanded = false,
    this.description,
    this.damageTypeName,
    this.statusLines = const <String>[],
  });

  /// The [ProjectileId] used to extract the first idle frame as an icon.
  final ProjectileId projectileId;

  final String title;

  /// Whether this tile is the currently chosen projectile source (border
  /// highlight).
  final bool selected;

  final VoidCallback onTap;

  /// Whether the details panel is currently visible. Toggled independently
  /// of [selected] so the user can collapse an already-selected card.
  final bool expanded;

  /// Short description shown when expanded (selected).
  final String? description;

  /// Damage type label shown when expanded (selected).
  final String? damageTypeName;

  /// Detailed status effect summaries shown when expanded.
  final List<String> statusLines;

  @override
  Widget build(BuildContext context) {
    final ui = context.ui;
    final borderColor = selected
        ? ui.colors.accentStrong
        : ui.colors.outline.withValues(alpha: 0.45);
    final fillColor = selected
        ? UiBrandPalette.steelBlueInsetBottom
        : ui.colors.cardBackground;
    return Material(
      color: Colors.transparent,
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(ui.radii.sm),
        child: AnimatedContainer(
          duration: const Duration(milliseconds: 200),
          curve: Curves.easeInOut,
          padding: EdgeInsets.symmetric(
            horizontal: ui.space.sm,
            vertical: ui.space.xs,
          ),
          decoration: BoxDecoration(
            color: fillColor,
            borderRadius: BorderRadius.circular(ui.radii.sm),
            border: Border.all(color: borderColor),
          ),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            mainAxisSize: MainAxisSize.min,
            children: [
              Row(
                children: [
                  ProjectileIconFrame(projectileId: projectileId, size: 32),
                  SizedBox(width: ui.space.xs),
                  Expanded(
                    child: Text(
                      title,
                      style: ui.text.body.copyWith(
                        color: ui.colors.textPrimary,
                      ),
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                  AnimatedRotation(
                    turns: expanded ? 0.5 : 0.0,
                    duration: const Duration(milliseconds: 200),
                    child: Icon(
                      Icons.expand_more,
                      size: 18,
                      color: ui.colors.textMuted,
                    ),
                  ),
                ],
              ),
              AnimatedCrossFade(
                firstChild: const SizedBox.shrink(),
                secondChild: _ExpandedDetails(
                  description: description,
                  damageTypeName: damageTypeName,
                  statusLines: statusLines,
                ),
                crossFadeState: expanded
                    ? CrossFadeState.showSecond
                    : CrossFadeState.showFirst,
                duration: const Duration(milliseconds: 200),
                sizeCurve: Curves.easeInOut,
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class _ExpandedDetails extends StatelessWidget {
  const _ExpandedDetails({
    this.description,
    this.damageTypeName,
    this.statusLines = const <String>[],
  });

  final String? description;
  final String? damageTypeName;
  final List<String> statusLines;

  @override
  Widget build(BuildContext context) {
    final ui = context.ui;
    final hasDescription = description != null && description!.isNotEmpty;
    final hasDamageType = damageTypeName != null && damageTypeName!.isNotEmpty;
    final hasStatus = statusLines.isNotEmpty;
    if (!hasDescription && !hasDamageType && !hasStatus) {
      return const SizedBox.shrink();
    }

    return Padding(
      padding: EdgeInsets.only(top: ui.space.xxs),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        mainAxisSize: MainAxisSize.min,
        children: [
          if (hasDamageType)
            Row(
              children: [
                Text(
                  'Damage: ',
                  style: ui.text.loreBody.copyWith(
                    color: ui.colors.textMuted,
                    fontWeight: FontWeight.w600,
                  ),
                ),
                Text(
                  damageTypeName!,
                  style: ui.text.caption.copyWith(
                    color: ui.colors.valueHighlight,
                    fontWeight: FontWeight.w600,
                  ),
                ),
              ],
            ),
          if (hasDamageType && (hasDescription || hasStatus))
            SizedBox(height: ui.space.xxs),
          if (hasDescription)
            Text(
              description!,
              style: ui.text.caption.copyWith(color: ui.colors.textMuted),
              maxLines: 3,
              overflow: TextOverflow.ellipsis,
            ),
          if (hasDescription && hasStatus) SizedBox(height: ui.space.xxs),
          for (final line in statusLines)
            Padding(
              padding: EdgeInsets.only(top: statusLines.first == line ? 0 : 2),
              child: Row(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    '• ',
                    style: ui.text.loreBody.copyWith(
                      color: ui.colors.textMuted,
                    ),
                  ),
                  Expanded(
                    child: Text.rich(
                      TextSpan(
                        children: _highlightValues(
                          line,
                          normal: ui.text.caption.copyWith(
                            color: ui.colors.textPrimary,
                          ),
                          highlight: ui.text.caption.copyWith(
                            color: ui.colors.valueHighlight,
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                      ),
                    ),
                  ),
                ],
              ),
            ),
        ],
      ),
    );
  }
}

/// Builds [TextSpan]s from [text], highlighting numeric tokens
/// (e.g. "25", "-25%", "3 seconds", "50% chance") in [highlight] style.
List<TextSpan> _highlightValues(
  String text, {
  required TextStyle normal,
  required TextStyle highlight,
}) {
  // Matches numbers with optional leading sign and optional trailing %.
  final regex = RegExp(r'[+-]?\d+(?:\.\d+)?%?');
  final spans = <TextSpan>[];
  var index = 0;
  for (final match in regex.allMatches(text)) {
    if (match.start > index) {
      spans.add(
        TextSpan(text: text.substring(index, match.start), style: normal),
      );
    }
    spans.add(TextSpan(text: match.group(0), style: highlight));
    index = match.end;
  }
  if (index < text.length) {
    spans.add(TextSpan(text: text.substring(index), style: normal));
  }
  return spans;
}

class _AbilityListTile extends StatelessWidget {
  const _AbilityListTile({
    required this.title,
    required this.selected,
    required this.enabled,
    required this.onTap,
  });

  final String title;
  final bool selected;
  final bool enabled;
  final VoidCallback onTap;

  @override
  Widget build(BuildContext context) {
    final ui = context.ui;
    final borderColor = selected
        ? ui.colors.accentStrong
        : ui.colors.outline.withValues(alpha: 0.45);
    final fillColor = selected
        ? UiBrandPalette.steelBlueInsetBottom
        : ui.colors.cardBackground;

    return Opacity(
      opacity: enabled ? 1 : 0.45,
      child: Material(
        color: Colors.transparent,
        child: InkWell(
          onTap: onTap,
          borderRadius: BorderRadius.circular(ui.radii.sm),
          child: Container(
            padding: EdgeInsets.symmetric(
              horizontal: ui.space.xs,
              vertical: ui.space.xxs,
            ),
            decoration: BoxDecoration(
              color: fillColor,
              borderRadius: BorderRadius.circular(ui.radii.sm),
              border: Border.all(color: borderColor),
            ),
            child: Row(
              children: [
                AbilityPlaceholderIcon(
                  label: '',
                  size: 40,
                  emphasis: selected,
                  enabled: enabled,
                ),
                SizedBox(width: ui.space.md),
                Expanded(
                  child: Text(
                    title,
                    style: ui.text.body.copyWith(color: ui.colors.textPrimary),
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

String _slotTitle(AbilitySlot slot) {
  switch (slot) {
    case AbilitySlot.primary:
      return 'Primary';
    case AbilitySlot.secondary:
      return 'Secondary';
    case AbilitySlot.projectile:
      return 'Projectile';
    case AbilitySlot.mobility:
      return 'Mobility';
    case AbilitySlot.spell:
      return 'Spell';
    case AbilitySlot.jump:
      return 'Jump';
  }
}


===== FILE: lib/ui/pages/selectCharacter/skills/skills_projectile_source_dialog.dart =====
import 'package:flutter/material.dart';

import '../../../../core/projectiles/projectile_id.dart';
import '../../../components/app_button.dart';
import '../../../theme/ui_tokens.dart';
import '../ability/ability_picker_presenter.dart';
import 'skills_list_pane.dart';

/// Opens the projectile source picker modal.
Future<void> showProjectileSourceDialog(
  BuildContext context, {
  required List<ProjectileSourceOption> options,
  required ProjectileId? initialSelection,
  required ValueChanged<ProjectileId?> onSelect,
}) {
  return showDialog<void>(
    context: context,
    barrierColor: context.ui.colors.scrim,
    builder: (dialogContext) {
      final ui = dialogContext.ui;
      final media = MediaQuery.of(dialogContext);
      final maxWidth = (media.size.width - (ui.space.sm * 2))
          .clamp(320.0, 460.0)
          .toDouble();
      final maxHeight = (media.size.height - (ui.space.sm * 2))
          .clamp(220.0, 520.0)
          .toDouble();

      return _ProjectileSourceDialog(
        options: options,
        initialSelection: initialSelection,
        maxWidth: maxWidth,
        maxHeight: maxHeight,
        onSelect: onSelect,
      );
    },
  );
}

/// Stateful dialog that lets the user browse projectile sources with
/// expandable detail panels before dismissing.
class _ProjectileSourceDialog extends StatefulWidget {
  const _ProjectileSourceDialog({
    required this.options,
    required this.initialSelection,
    required this.maxWidth,
    required this.maxHeight,
    required this.onSelect,
  });

  final List<ProjectileSourceOption> options;
  final ProjectileId? initialSelection;
  final double maxWidth;
  final double maxHeight;
  final ValueChanged<ProjectileId?> onSelect;

  @override
  State<_ProjectileSourceDialog> createState() =>
      _ProjectileSourceDialogState();
}

class _ProjectileSourceDialogState extends State<_ProjectileSourceDialog> {
  late ProjectileId? _selected;

  /// Index of the tile whose detail panel is open, or `null` when all
  /// tiles are collapsed.
  int? _expandedIndex;

  @override
  void initState() {
    super.initState();
    _selected = widget.initialSelection;
    // Start with the initially-selected tile expanded so the user
    // immediately sees its details.
    for (var i = 0; i < widget.options.length; i += 1) {
      if (widget.options[i].spellId == _selected) {
        _expandedIndex = i;
        break;
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final ui = context.ui;
    return Dialog(
      backgroundColor: ui.colors.cardBackground,
      insetPadding: EdgeInsets.all(ui.space.sm),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(ui.radii.md),
        side: BorderSide(color: ui.colors.outline.withValues(alpha: 0.35)),
      ),
      child: SizedBox(
        width: widget.maxWidth,
        height: widget.maxHeight,
        child: Padding(
          padding: EdgeInsets.all(ui.space.md),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              Text(
                'Select Projectile Source',
                style: ui.text.loreHeading.copyWith(
                  color: ui.colors.textPrimary,
                ),
              ),
              SizedBox(height: ui.space.sm),
              Expanded(
                child: ListView.separated(
                  itemCount: widget.options.length,
                  separatorBuilder: (_, _) => SizedBox(height: ui.space.xs),
                  itemBuilder: (context, index) {
                    final option = widget.options[index];
                    final isSelected = option.spellId == _selected;
                    final isExpanded = _expandedIndex == index;
                    return SkillsProjectileSourceTile(
                      projectileId: option.projectileId,
                      title: option.displayName,
                      selected: isSelected,
                      expanded: isExpanded,
                      description: option.description,
                      damageTypeName: option.damageTypeName,
                      statusLines: option.statusLines,
                      onTap: () {
                        setState(() {
                          _selected = option.spellId;
                          // Toggle expansion: collapse if already open,
                          // otherwise expand the tapped tile.
                          _expandedIndex = _expandedIndex == index
                              ? null
                              : index;
                        });
                        widget.onSelect(option.spellId);
                      },
                    );
                  },
                ),
              ),
              SizedBox(height: ui.space.sm),
              Align(
                alignment: Alignment.centerRight,
                child: AppButton(
                  label: 'Close',
                  variant: AppButtonVariant.secondary,
                  size: AppButtonSize.xs,
                  onPressed: () => Navigator.of(context).pop(),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}


===== FILE: lib/ui/pages/selectCharacter/skills/skills_radial_pane.dart =====
import 'dart:math' as math;

import 'package:flutter/material.dart';

import '../../../../core/abilities/ability_def.dart';
import '../../../controls/action_button.dart';
import '../../../controls/ability_slot_visual_spec.dart';
import '../../../controls/controls_tuning.dart';
import '../../../controls/layout/controls_radial_layout.dart';
import '../../../theme/ui_tokens.dart';

class SkillsRadialPane extends StatelessWidget {
  const SkillsRadialPane({
    super.key,
    required this.selectedSlot,
    required this.onSelectSlot,
  });

  final AbilitySlot selectedSlot;
  final ValueChanged<AbilitySlot> onSelectSlot;

  @override
  Widget build(BuildContext context) {
    return Center(
      child: FittedBox(
        fit: BoxFit.contain,
        alignment: Alignment.center,
        child: SizedBox(
          width: _selectionActionSlotGeometry.width,
          height: _selectionActionSlotGeometry.height,
          child: Stack(
            children: [
              for (final slot in abilityRadialLayoutSpec.selectionOrder)
                Positioned(
                  left:
                      _selectionActionSlotGeometry.placements[slot]!.buttonLeft,
                  top: _selectionActionSlotGeometry.placements[slot]!.buttonTop,
                  child: _ActionSlotButton(
                    slot: slot,
                    selected: slot == selectedSlot,
                    onSelectSlot: onSelectSlot,
                    buttonSize: _selectionActionSlotGeometry
                        .placements[slot]!
                        .buttonSize,
                  ),
                ),
            ],
          ),
        ),
      ),
    );
  }
}

class _ActionSlotButton extends StatelessWidget {
  const _ActionSlotButton({
    required this.slot,
    required this.selected,
    required this.onSelectSlot,
    required this.buttonSize,
  });

  final AbilitySlot slot;
  final bool selected;
  final ValueChanged<AbilitySlot> onSelectSlot;
  final double buttonSize;

  @override
  Widget build(BuildContext context) {
    final ui = context.ui;
    final slotVisual = abilityRadialLayoutSpec.slotSpec(slot);
    // Slightly oversize the ring so selection emphasis stays outside the icon.
    final borderWidth = buttonSize * 1.08;
    return DecoratedBox(
      decoration: BoxDecoration(
        shape: BoxShape.circle,
        border: Border.all(
          color: selected ? ui.colors.accentStrong : Colors.transparent,
          width: borderWidth,
        ),
      ),
      child: Center(
        child: ActionButton(
          label: slotVisual.label,
          icon: slotVisual.icon,
          onPressed: () => onSelectSlot(slot),
          tuning: _actionButtonTuningForSelectionSlot(
            tuning: _selectionControlsTuning,
            slot: slot,
            backgroundColor: ui.colors.textPrimary,
            foregroundColor: ui.colors.background,
          ),
          cooldownRing: _selectionControlsTuning.style.cooldownRing,
          size: buttonSize,
        ),
      ),
    );
  }
}

@immutable
class _ActionSlotPlacement {
  const _ActionSlotPlacement({
    required this.buttonLeft,
    required this.buttonTop,
    required this.buttonSize,
  });

  final double buttonLeft;
  final double buttonTop;
  final double buttonSize;
}

@immutable
class _ActionSlotGeometry {
  const _ActionSlotGeometry({
    required this.width,
    required this.height,
    required this.placements,
  });

  final double width;
  final double height;
  final Map<AbilitySlot, _ActionSlotPlacement> placements;
}

/// Uses a fixed profile so selection-wheel geometry is stable across devices.
const ControlsTuning _selectionControlsTuning = ControlsTuning.fixed;
final ControlsRadialLayout _selectionControlsRadialLayout =
    ControlsRadialLayoutSolver.solve(
      layout: _selectionControlsTuning.layout,
      action: _selectionControlsTuning.style.actionButton,
      directional: _selectionControlsTuning.style.directionalActionButton,
    );
final _ActionSlotGeometry _selectionActionSlotGeometry =
    _buildActionSlotsGeometry(layout: _selectionControlsRadialLayout);

/// Converts radial anchor coordinates into normalized top-left placements.
///
/// The radial spec stores offsets from right/bottom edges. This helper mirrors
/// them into a local `Stack` coordinate space and shifts everything so the
/// smallest x/y starts at zero.
_ActionSlotGeometry _buildActionSlotsGeometry({
  required ControlsRadialLayout layout,
}) {
  final rawSizes = <AbilitySlot, double>{
    for (final slot in abilityRadialLayoutSpec.selectionOrder)
      slot: abilityRadialLayoutSpec.sizeFor(layout: layout, slot: slot),
  };
  var baseWidth = 0.0;
  var baseHeight = 0.0;
  for (final slot in abilityRadialLayoutSpec.selectionOrder) {
    final size = rawSizes[slot]!;
    final anchor = abilityRadialLayoutSpec.anchorFor(
      layout: layout,
      slot: slot,
    );
    baseWidth = math.max(baseWidth, anchor.right + size);
    baseHeight = math.max(baseHeight, anchor.bottom + size);
  }

  final rawPlacements = <AbilitySlot, _ActionSlotPlacement>{};
  for (final slot in abilityRadialLayoutSpec.selectionOrder) {
    final size = rawSizes[slot]!;
    final anchor = abilityRadialLayoutSpec.anchorFor(
      layout: layout,
      slot: slot,
    );
    final buttonLeft = baseWidth - anchor.right - size;
    final buttonTop = baseHeight - anchor.bottom - size;
    rawPlacements[slot] = _ActionSlotPlacement(
      buttonLeft: buttonLeft,
      buttonTop: buttonTop,
      buttonSize: size,
    );
  }

  // Compute bounds for the mirrored coordinates.
  var minX = double.infinity;
  var minY = double.infinity;
  var maxX = double.negativeInfinity;
  var maxY = double.negativeInfinity;
  for (final placement in rawPlacements.values) {
    minX = math.min(minX, placement.buttonLeft);
    minY = math.min(minY, placement.buttonTop);
    maxX = math.max(maxX, placement.buttonLeft + placement.buttonSize);
    maxY = math.max(maxY, placement.buttonTop + placement.buttonSize);
  }
  final shiftX = minX < 0 ? -minX : 0.0;
  final shiftY = minY < 0 ? -minY : 0.0;

  // Shift placements so parent `Stack` starts at (0, 0).
  final normalized = <AbilitySlot, _ActionSlotPlacement>{};
  for (final slot in abilityRadialLayoutSpec.selectionOrder) {
    final placement = rawPlacements[slot]!;
    normalized[slot] = _ActionSlotPlacement(
      buttonLeft: placement.buttonLeft + shiftX,
      buttonTop: placement.buttonTop + shiftY,
      buttonSize: placement.buttonSize,
    );
  }
  return _ActionSlotGeometry(
    width: maxX + shiftX,
    height: maxY + shiftY,
    placements: normalized,
  );
}

/// Resolves action button visuals for the selection wheel.
///
/// Directional slots reuse directional sizing metrics but are rendered with the
/// same high-contrast palette as regular selection buttons.
ActionButtonTuning _actionButtonTuningForSelectionSlot({
  required ControlsTuning tuning,
  required AbilitySlot slot,
  required Color backgroundColor,
  required Color foregroundColor,
}) {
  final family = abilityRadialLayoutSpec.slotSpec(slot).family;
  if (family == AbilityRadialSlotFamily.directional) {
    final directional = tuning.style.directionalActionButton;
    return _highContrastSelectionActionButtonTuning(
      ActionButtonTuning(
        size: directional.size,
        backgroundColor: directional.backgroundColor,
        foregroundColor: directional.foregroundColor,
        labelFontSize: directional.labelFontSize,
        labelGap: directional.labelGap,
      ),
      backgroundColor: backgroundColor,
      foregroundColor: foregroundColor,
    );
  }
  return _highContrastSelectionActionButtonTuning(
    tuning.style.actionButton,
    backgroundColor: backgroundColor,
    foregroundColor: foregroundColor,
  );
}

/// Forces high-contrast icon buttons for menu readability.
ActionButtonTuning _highContrastSelectionActionButtonTuning(
  ActionButtonTuning base, {
  required Color backgroundColor,
  required Color foregroundColor,
}) {
  return ActionButtonTuning(
    size: base.size,
    backgroundColor: backgroundColor,
    foregroundColor: foregroundColor,
    labelFontSize: base.labelFontSize,
    labelGap: base.labelGap,
  );
}


===== FILE: lib/ui/pages/selectCharacter/skills_tab.dart =====
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

import '../../../core/abilities/ability_def.dart';
import '../../../core/ecs/stores/combat/equipped_loadout_store.dart';
import '../../../core/players/player_character_definition.dart';
import '../../state/app_state.dart';
import '../../text/ability_tooltip_builder.dart';
import '../../theme/ui_tokens.dart';
import 'ability/ability_picker_presenter.dart';
import 'ability/ability_picker_shared.dart';
import 'skills/skills_details_pane.dart';
import 'skills/skills_list_pane.dart';
import 'skills/skills_projectile_source_dialog.dart';
import 'skills/skills_radial_pane.dart';

/// Selection-screen skills surface for one [PlayerCharacterId].
///
/// Keeps only ephemeral UI state locally (selected slot and inspected ability)
/// while persisting actual loadout changes through [AppState].
class SkillsBar extends StatefulWidget {
  const SkillsBar({super.key, required this.characterId});

  final PlayerCharacterId characterId;

  @override
  State<SkillsBar> createState() => _SkillsBarState();
}

class _SkillsBarState extends State<SkillsBar> {
  static const DefaultAbilityTooltipBuilder _tooltipBuilder =
      DefaultAbilityTooltipBuilder();

  AbilitySlot _selectedSlot = AbilitySlot.primary;
  AbilityKey? _inspectedAbilityId;

  @override
  Widget build(BuildContext context) {
    final ui = context.ui;
    final appState = context.watch<AppState>();
    final rawLoadout = appState.selection.loadoutFor(widget.characterId);
    final loadout = normalizeLoadoutMaskForCharacter(
      characterId: widget.characterId,
      loadout: rawLoadout,
    );
    final isProjectileSlot = _selectedSlot == AbilitySlot.projectile;
    final selectedSourceSpellId = isProjectileSlot
        ? loadout.projectileSlotSpellId
        : null;
    final candidates = abilityCandidatesForSlot(
      characterId: widget.characterId,
      slot: _selectedSlot,
      loadout: loadout,
      selectedSourceSpellId: selectedSourceSpellId,
      overrideSelectedSource: isProjectileSlot,
    );
    final equippedAbilityId = abilityIdForSlot(loadout, _selectedSlot);
    final inspectedAbilityId = _resolveInspectedAbilityId(
      candidates,
      equippedAbilityId: equippedAbilityId,
    );
    final inspectedCandidate = _candidateById(candidates, inspectedAbilityId);
    final tooltip = inspectedCandidate == null
        ? null
        : _tooltipBuilder.build(
            inspectedCandidate.def,
            ctx: AbilityTooltipContext(
              activeProjectileId: isProjectileSlot
                  ? (selectedSourceSpellId ?? loadout.projectileId)
                  : null,
              payloadWeaponType: payloadWeaponTypeForTooltip(
                def: inspectedCandidate.def,
                slot: _selectedSlot,
                selectedSourceSpellId: selectedSourceSpellId,
              ),
            ),
          );

    return Padding(
      padding: EdgeInsets.only(left: ui.space.xxs, top: ui.space.xxs),
      child: LayoutBuilder(
        builder: (context, constraints) {
          final layout = _skillsLayoutForWidth(constraints.maxWidth);
          return Row(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              SizedBox(
                width: layout.listWidth,
                child: SkillsListPane(
                  selectedSlot: _selectedSlot,
                  candidates: candidates,
                  selectedAbilityId: inspectedAbilityId,
                  onSelectAbility: (candidate) => _onSelectAbility(
                    appState: appState,
                    loadout: loadout,
                    candidate: candidate,
                  ),
                  onSelectProjectileSource: isProjectileSlot
                      ? () => _showProjectileSourcePicker(
                          appState: appState,
                          loadout: loadout,
                        )
                      : null,
                ),
              ),
              SizedBox(width: layout.gap),
              SizedBox(
                width: layout.detailsWidth,
                child: SkillsDetailsPane(tooltip: tooltip),
              ),
              SizedBox(width: layout.gap),
              SizedBox(
                width: layout.radialWidth,
                child: SkillsRadialPane(
                  selectedSlot: _selectedSlot,
                  onSelectSlot: _onSelectSlot,
                ),
              ),
            ],
          );
        },
      ),
    );
  }

  void _onSelectSlot(AbilitySlot slot) {
    if (_selectedSlot == slot) return;
    setState(() {
      _selectedSlot = slot;
      _inspectedAbilityId = null;
    });
  }

  Future<void> _onSelectAbility({
    required AppState appState,
    required EquippedLoadoutDef loadout,
    required AbilityPickerCandidate candidate,
  }) async {
    setState(() {
      _inspectedAbilityId = candidate.id;
    });
    if (!candidate.isEnabled) return;
    final equippedAbilityId = abilityIdForSlot(loadout, _selectedSlot);
    if (equippedAbilityId == candidate.id) return;
    final next = setAbilityForSlot(
      loadout,
      slot: _selectedSlot,
      abilityId: candidate.id,
    );
    await appState.setLoadout(next);
  }

  Future<void> _showProjectileSourcePicker({
    required AppState appState,
    required EquippedLoadoutDef loadout,
  }) {
    final options = projectileSourceOptions(loadout);
    return showProjectileSourceDialog(
      context,
      options: options,
      initialSelection: loadout.projectileSlotSpellId,
      onSelect: (sourceSpellId) async {
        final next = setProjectileSourceForSlot(
          loadout,
          slot: AbilitySlot.projectile,
          selectedSpellId: sourceSpellId,
        );
        await appState.setLoadout(next);
      },
    );
  }

  AbilityKey? _resolveInspectedAbilityId(
    List<AbilityPickerCandidate> candidates, {
    required AbilityKey equippedAbilityId,
  }) {
    if (candidates.isEmpty) return null;

    final inspected = _inspectedAbilityId;
    if (inspected != null) {
      for (final candidate in candidates) {
        if (candidate.id == inspected) return inspected;
      }
    }

    for (final candidate in candidates) {
      if (candidate.id == equippedAbilityId) return equippedAbilityId;
    }
    // Deterministic fallback keeps inspection stable when no equipped match.
    return candidates.first.id;
  }
}

@immutable
class _SkillsLayoutSpec {
  const _SkillsLayoutSpec({
    required this.listWidth,
    required this.detailsWidth,
    required this.radialWidth,
    required this.gap,
  });

  final double listWidth;
  final double detailsWidth;
  final double radialWidth;
  final double gap;
}

/// Computes side-panel widths for the skills screen at [width].
///
/// Uses tunable ratios across list, details, and radial columns.
_SkillsLayoutSpec _skillsLayoutForWidth(double width) {
  const gap = 8.0;
  const listRatio = 0.31;
  const detailsRatio = 0.44;
  const radialRatio = 0.25;
  const ratioTotal = listRatio + detailsRatio + radialRatio;
  final contentWidth = (width - (gap * 2))
      .clamp(0.0, double.infinity)
      .toDouble();
  final listWidth = contentWidth * (listRatio / ratioTotal);
  final detailsWidth = contentWidth * (detailsRatio / ratioTotal);
  final radialWidth = contentWidth * (radialRatio / ratioTotal);
  return _SkillsLayoutSpec(
    listWidth: listWidth,
    detailsWidth: detailsWidth,
    radialWidth: radialWidth,
    gap: gap,
  );
}

AbilityPickerCandidate? _candidateById(
  List<AbilityPickerCandidate> candidates,
  AbilityKey? id,
) {
  if (id == null) return null;
  for (final candidate in candidates) {
    if (candidate.id == id) return candidate;
  }
  return null;
}


===== FILE: lib/ui/pages/selectLevel/level_card.dart =====
import 'package:flutter/material.dart';

import '../../../core/levels/level_id.dart';
import '../../levels/level_id_ui.dart';
import '../../components/level_parallax_preview.dart';
import '../../theme/ui_tokens.dart';

/// A card widget displaying a level with its full parallax background.
///
/// Shows all parallax layers composited as background with the title centered.
/// Use in a row for level selection screens.
class LevelCard extends StatelessWidget {
  const LevelCard({
    super.key,
    required this.levelId,
    required this.onTap,
    this.selected = false,
    this.width,
    this.height = 120,
    this.borderRadius = 12,
  });

  /// The level this card represents.
  final LevelId levelId;

  /// Callback when the card is tapped.
  final VoidCallback onTap;

  /// Whether this card is currently selected.
  final bool selected;

  /// Card width. If null, uses available space (e.g., in Expanded).
  final double? width;

  /// Card height. Defaults to 120.
  final double height;

  /// Corner radius. Defaults to 12.
  final double borderRadius;

  @override
  Widget build(BuildContext context) {
    final ui = context.ui;
    return GestureDetector(
      onTap: onTap,
      child: Container(
        width: width,
        height: height,
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(borderRadius),
          border: Border.all(
            color: selected ? ui.colors.accentStrong : ui.colors.outline,
            width: ui.sizes.borderWidth,
          ),
          boxShadow: [
            BoxShadow(
              color: ui.colors.shadow,
              blurRadius: 8,
              offset: Offset(0, 4),
            ),
          ],
        ),
        child: ClipRRect(
          borderRadius: BorderRadius.circular(borderRadius - 2),
          child: Stack(
            fit: StackFit.expand,
            children: [
              LevelParallaxPreview(
                themeId: levelId.themeId,
                alignment: Alignment.center,
              ),
              Center(
                child: Text(
                  levelId.displayName.toUpperCase(),
                  style: ui.text.cardTitle,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}


===== FILE: lib/ui/pages/selectLevel/level_select_section.dart =====
import 'package:flutter/material.dart';

import '../../../core/levels/level_id.dart';
import 'level_card.dart';

class LevelSelectSection extends StatelessWidget {
  const LevelSelectSection({
    super.key,
    required this.selectedLevelId,
    required this.onSelectLevel,
  });

  final LevelId selectedLevelId;
  final ValueChanged<LevelId> onSelectLevel;

  @override
  Widget build(BuildContext context) {
    return Wrap(
      spacing: 16,
      runSpacing: 16,
      alignment: WrapAlignment.center,
      children: [
        for (final levelId in LevelId.values)
          LevelCard(
            levelId: levelId,
            selected: levelId == selectedLevelId,
            width: 200,
            onTap: () => onSelectLevel(levelId),
          ),
      ],
    );
  }
}


===== FILE: lib/ui/pages/selectLevel/level_setup_page.dart =====
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

import '../../components/app_segmented_control.dart';
import '../../components/menu_layout.dart';
import '../../components/menu_scaffold.dart';
import '../../state/app_state.dart';
import '../../state/selection_state.dart';
import 'level_select_section.dart';

class LevelSetupPage extends StatelessWidget {
  const LevelSetupPage({super.key});

  @override
  Widget build(BuildContext context) {
    final appState = context.watch<AppState>();
    final selection = appState.selection;

    return MenuScaffold(
      title: 'Select Level',
      child: MenuLayout(
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Center(
              child: AppSegmentedControl<RunType>(
                values: const [RunType.practice, RunType.competitive],
                selected: selection.selectedRunType,
                onChanged: appState.setRunType,
                labelBuilder: (context, value) => switch (value) {
                  RunType.practice => const Text('Practice (Random)'),
                  RunType.competitive => const Text('Competitive (Season)'),
                },
              ),
            ),
            const SizedBox(height: 20),
            Center(
              child: LevelSelectSection(
                selectedLevelId: selection.selectedLevelId,
                onSelectLevel: appState.setLevel,
              ),
            ),
          ],
        ),
      ),
    );
  }
}


===== FILE: lib/ui/profile/display_name_policy.dart =====
class DisplayNamePolicy {
  const DisplayNamePolicy();

  static const int minLen = 3;
  static const int maxLen = 16;

  static final RegExp allowed = RegExp(r'^[a-zA-Z0-9 _-]+$');

  static const Set<String> reservedNormalized = <String>{
    'admin',
    'moderator',
    'mod',
    'support',
    'staff',
    'developer',
    'dev',
    'system',
  };

  static const List<String> bannedSubstringsNormalized = <String>[
    'fuck',
    'shit',
    'bitch',
    'asshole',
    'cunt',
    'nazi',
  ];

  String normalize(String input) {
    final trimmed = input.trim();
    final collapsed = trimmed.replaceAll(RegExp(r'\s+'), ' ');
    return collapsed.toLowerCase();
  }

  String? validate(String raw) {
    final name = raw.trim();
    if (name.isEmpty) return 'Name is required.';
    if (name.length < minLen) return 'Name must be at least $minLen characters.';
    if (name.length > maxLen) return 'Name must be at most $maxLen characters.';
    if (!allowed.hasMatch(name)) {
      return 'Only letters, numbers, spaces, "_" and "-" are allowed.';
    }

    final n = normalize(name);
    if (reservedNormalized.contains(n)) {
      return 'That name is reserved.';
    }
    for (final bad in bannedSubstringsNormalized) {
      if (n.contains(bad)) return 'That name is not allowed.';
    }
    return null;
  }
}


===== FILE: lib/ui/runner_game_route.dart =====
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import '../core/ecs/stores/combat/equipped_loadout_store.dart';
import '../core/levels/level_id.dart';
import '../core/players/player_character_definition.dart';
import 'runner_game_widget.dart';
import 'scoped/scoped_preferred_orientations.dart';
import 'scoped/scoped_system_ui_mode.dart';
import 'state/selection_state.dart';

/// Embed-friendly route factory for hosting the mini-game in any Flutter app.
///
/// Host apps can `Navigator.push(createRunnerGameRoute(...))` without depending
/// on this package's development host app (`lib/main.dart`).
///
/// Use [runId] to tag the run for replay/ghost metadata.
Route<void> createRunnerGameRoute({
  int runId = 0,
  int seed = 1,
  required LevelId levelId,
  PlayerCharacterId playerCharacterId = PlayerCharacterId.eloise,
  RunType runType = RunType.practice,
  EquippedLoadoutDef equippedLoadout = const EquippedLoadoutDef(),
  bool lockLandscape = true,
  List<DeviceOrientation>? restoreOrientations,
  SystemUiMode restoreSystemUiMode = SystemUiMode.edgeToEdge,
  RouteSettings? settings,
}) {
  return MaterialPageRoute<void>(
    settings: settings,
    builder: (context) {
      Widget child = RunnerGameWidget(
        runId: runId,
        seed: seed,
        levelId: levelId,
        playerCharacterId: playerCharacterId,
        runType: runType,
        equippedLoadout: equippedLoadout,
        onExit: () => Navigator.of(context).maybePop(),
      );

      if (lockLandscape) {
        child = ScopedPreferredOrientations(
          preferredOrientations: const [
            DeviceOrientation.landscapeLeft,
            DeviceOrientation.landscapeRight,
          ],
          restoreOrientations: restoreOrientations,
          child: child,
        );
      }

      // Hide status + nav bars only for this route.
      child = ScopedSystemUiMode(
        mode: SystemUiMode.immersiveSticky,
        restoreMode: restoreSystemUiMode,
        child: child,
      );

      return Scaffold(body: child);
    },
  );
}


===== FILE: lib/ui/runner_game_ui_state.dart =====
class RunnerGameUiState {
  const RunnerGameUiState({
    required this.started,
    required this.paused,
    required this.gameOver,
    required this.runLoaded,
  });

  final bool started;
  final bool paused;
  final bool gameOver;
  final bool runLoaded;

  bool get canRun => started && !gameOver;

  bool get isRunning => canRun && !paused;

  bool get showReadyOverlay => !started && runLoaded;

  bool get showPauseOverlay => started && paused && !gameOver;
}


===== FILE: lib/ui/runner_game_widget.dart =====
import 'dart:math';

import 'package:flame/game.dart';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

import '../core/abilities/ability_def.dart';
import '../core/contracts/render_contract.dart';
import '../core/events/game_event.dart';
import '../core/ecs/stores/combat/equipped_loadout_store.dart';
import '../core/game_core.dart';
import '../core/levels/level_id.dart';
import '../core/levels/level_registry.dart';
import '../core/players/player_character_definition.dart';
import '../core/players/player_character_registry.dart';
import '../game/game_controller.dart';
import '../game/input/aim_preview.dart';
import '../game/input/runner_input_router.dart';
import '../game/runner_flame_game.dart';
import 'hud/game/game_overlay.dart';
import 'hud/gameover/game_over_overlay.dart';
import 'bootstrap/loader_content.dart';
import 'components/menu_layout.dart';
import 'haptics/haptics_cue.dart';
import 'haptics/haptics_service.dart';
import 'runner_game_ui_state.dart';
import 'state/app_state.dart';
import 'state/profile_counter_keys.dart';
import 'state/selection_state.dart';
import 'theme/ui_tokens.dart';
import 'viewport/game_viewport.dart';
import 'viewport/viewport_metrics.dart';

/// Embed-friendly widget that hosts the mini-game.
///
/// Intended to be mounted by a host app. It owns its [GameController] and
/// cleans it up on dispose.
///
/// Viewport scaling is applied by [GameViewport] to keep the fixed virtual
/// resolution fitted to the available screen.
class RunnerGameWidget extends StatefulWidget {
  const RunnerGameWidget({
    super.key,
    this.runId = 0,
    this.seed = 1,
    required this.levelId,
    this.playerCharacterId = PlayerCharacterId.eloise,
    this.runType = RunType.practice,
    this.equippedLoadout = const EquippedLoadoutDef(),
    this.onExit,
    this.showExitButton = true,
    this.viewportMode = ViewportScaleMode.pixelPerfectContain,
    this.viewportAlignment = Alignment.center,
  });

  /// Master RNG seed for deterministic generation.
  final int seed;

  /// Unique identifier for this run session (replay/ghost).
  final int runId;

  /// Which core level definition to run.
  final LevelId levelId;

  /// Which player character to use for this run.
  final PlayerCharacterId playerCharacterId;

  /// Menu-selected run type (practice/competitive). Used by UI (e.g. leaderboard
  /// namespacing) and may later affect rules/tuning.
  final RunType runType;

  /// Per-run loadout override (from menu / meta inventory).
  final EquippedLoadoutDef equippedLoadout;

  final VoidCallback? onExit;
  final bool showExitButton;

  /// How the game view is scaled to the available screen.
  final ViewportScaleMode viewportMode;

  /// Where the scaled view is placed within the available screen.
  final Alignment viewportAlignment;

  @override
  State<RunnerGameWidget> createState() => _RunnerGameWidgetState();
}

class _RunnerGameWidgetState extends State<RunnerGameWidget>
    with WidgetsBindingObserver {
  final Random _runIdRandom = Random();
  final UiHaptics _haptics = const UiHapticsService();

  bool _pausedByLifecycle = false;
  bool _started = false;
  bool _exitConfirmOpen = false;
  bool _pausedBeforeExitConfirm = false;

  late int _runId;
  int? _lastRewardedRunId;
  int? _lastGoldEarned;
  int? _lastGoldTotal;

  late GameController _controller;
  late RunnerInputRouter _input;
  late AimPreviewModel _projectileAimPreview;
  late AimPreviewModel _meleeAimPreview;
  late ValueNotifier<Rect?> _aimCancelHitboxRect;
  late ValueNotifier<int> _forceAimCancelSignal;
  late ValueNotifier<int> _playerImpactFeedbackSignal;
  int _lastPlayerDamageTick = -1;
  int _lastChargeTier = 0;
  late RunnerFlameGame _game;

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);

    _runId = widget.runId != 0 ? widget.runId : _createFallbackRunId();
    _initGame();

    // Start in "ready" (paused) until the user taps to begin.
    _controller.setPaused(true);
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) =>
      _onLifecycle(state);

  void _onLifecycle(AppLifecycleState state) {
    final runLoaded = _game.loadState.value.phase == RunLoadPhase.worldReady;
    final uiState = _buildUiState(runLoaded: runLoaded);
    if (state == AppLifecycleState.resumed) {
      if (_pausedByLifecycle && uiState.started && !uiState.gameOver) {
        _pausedByLifecycle = false;
        _controller.setPaused(false);
      }
      return;
    }

    // Only mark lifecycle-paused if we were actually running.
    _pausedByLifecycle = uiState.isRunning;
    _controller.setPaused(true);
    _clearInputs();
  }

  void _clearInputs() {
    _input.setMoveAxis(0);
    _input.clearAimDir();
    _input.endPrimaryHold();
    _input.endSecondaryHold();
    _input.endMobilityHold();
    _input.endAbilitySlotHold(AbilitySlot.projectile);
    _projectileAimPreview.end();
    _meleeAimPreview.end();
    _input.pumpHeldInputs();
  }

  void _cancelHeldChargedAim() {
    _input.clearAimDir();
    _projectileAimPreview.end();
    _meleeAimPreview.end();
    _forceAimCancelSignal.value = _forceAimCancelSignal.value + 1;
    _input.pumpHeldInputs();
  }

  void _onControllerTick() {
    _emitChargeHaptics();

    final damageTick = _controller.snapshot.hud.lastDamageTick;
    if (damageTick <= _lastPlayerDamageTick) return;
    _lastPlayerDamageTick = damageTick;
    final hud = _controller.snapshot.hud;
    if (hud.chargeEnabled && hud.chargeActive) {
      _cancelHeldChargedAim();
    }
  }

  void _emitChargeHaptics() {
    final hud = _controller.snapshot.hud;
    final active = hud.chargeEnabled && hud.chargeActive;
    final nextTier = active ? hud.chargeTier : 0;

    if (active && nextTier > _lastChargeTier) {
      if (_lastChargeTier < 1 && nextTier >= 1) {
        _haptics.trigger(UiHapticsCue.chargeHalfTierReached);
      }
      if (_lastChargeTier < 2 && nextTier >= 2) {
        _haptics.trigger(UiHapticsCue.chargeFullTierReached);
      }
    }

    _lastChargeTier = nextTier;
  }

  UiHapticsIntensity _impactHapticsIntensity(int amount100) {
    if (amount100 >= 1400) return UiHapticsIntensity.heavy;
    if (amount100 >= 700) return UiHapticsIntensity.medium;
    return UiHapticsIntensity.light;
  }

  AppState? _maybeAppState() {
    try {
      return Provider.of<AppState>(context, listen: false);
    } on ProviderNotFoundException {
      return null;
    }
  }

  int _createFallbackRunId() {
    final nowMs = DateTime.now().millisecondsSinceEpoch;
    final salt = _runIdRandom.nextInt(1 << 20);
    return (nowMs << 20) | salt;
  }

  int _nextRunId() {
    final appState = _maybeAppState();
    if (appState != null) return appState.createRunId();
    return _createFallbackRunId();
  }

  void _handleGameEvent(GameEvent event) {
    if (event is PlayerImpactFeedbackEvent) {
      _haptics.trigger(
        UiHapticsCue.playerHit,
        intensityOverride: _impactHapticsIntensity(event.amount100),
      );
      _playerImpactFeedbackSignal.value = _playerImpactFeedbackSignal.value + 1;
      return;
    }
    if (event is AbilityHoldEndedEvent) {
      switch (event.reason) {
        case AbilityHoldEndReason.timeout:
          _haptics.trigger(UiHapticsCue.holdAbilityTimedOut);
        case AbilityHoldEndReason.staminaDepleted:
          _haptics.trigger(UiHapticsCue.holdAbilityStaminaDepleted);
      }
      return;
    }
    if (event is AbilityChargeEndedEvent) {
      switch (event.reason) {
        case AbilityChargeEndReason.timeout:
          _haptics.trigger(UiHapticsCue.holdAbilityTimedOut);
      }
      _cancelHeldChargedAim();
      return;
    }
    if (event is! RunEndedEvent) return;
    _grantGold(event);
  }

  void _grantGold(RunEndedEvent event) {
    final runId = event.runId;
    if (_lastRewardedRunId == runId) return;

    _lastRewardedRunId = runId;
    _lastGoldEarned = event.goldEarned;

    final appState = _maybeAppState();
    if (appState == null) {
      _lastGoldTotal = null;
      return;
    }

    final currentGold = appState.profile.counters[ProfileCounterKeys.gold] ?? 0;
    final nextGold = currentGold + event.goldEarned;
    _lastGoldTotal = nextGold;

    appState.updateProfile((current) {
      final counters = Map<String, int>.from(current.counters);
      counters[ProfileCounterKeys.gold] = nextGold;
      return current.copyWith(counters: counters);
    });
  }

  RunnerGameUiState _buildUiState({required bool runLoaded}) {
    final snapshot = _controller.snapshot;
    return RunnerGameUiState(
      started: _started,
      paused: snapshot.paused,
      gameOver: snapshot.gameOver,
      runLoaded: runLoaded,
    );
  }

  void _startGame() {
    setState(() => _started = true);
    _clearInputs();
    _controller.setPaused(false);
  }

  void _restartGame() {
    final oldController = _controller;
    final oldProjectilePreview = _projectileAimPreview;
    final oldMeleePreview = _meleeAimPreview;
    final oldAimCancelHitboxRect = _aimCancelHitboxRect;
    final oldForceAimCancelSignal = _forceAimCancelSignal;
    final oldPlayerImpactFeedbackSignal = _playerImpactFeedbackSignal;
    oldController.removeEventListener(_handleGameEvent);
    oldController.removeListener(_onControllerTick);

    setState(() {
      _pausedByLifecycle = false;
      _started = false;
      _exitConfirmOpen = false;
      _runId = _nextRunId();
      _lastGoldEarned = null;
      _lastGoldTotal = null;
      _initGame();
    });
    _controller.setPaused(true);
    _clearInputs();

    WidgetsBinding.instance.addPostFrameCallback((_) {
      oldController.shutdown();
      oldController.dispose();
      oldProjectilePreview.dispose();
      oldMeleePreview.dispose();
      oldAimCancelHitboxRect.dispose();
      oldForceAimCancelSignal.dispose();
      oldPlayerImpactFeedbackSignal.dispose();
    });
  }

  void _openExitConfirm() {
    final wasPaused = _controller.snapshot.paused;
    if (!wasPaused) _clearInputs();
    _controller.setPaused(true);

    setState(() {
      _pausedBeforeExitConfirm = wasPaused;
      _exitConfirmOpen = true;
    });
  }

  void _closeExitConfirm({required bool resume}) {
    setState(() => _exitConfirmOpen = false);
    if (resume) {
      _controller.setPaused(_pausedBeforeExitConfirm);
    }
  }

  void _confirmExitGiveUp() {
    setState(() => _exitConfirmOpen = false);
    _controller.giveUp();
  }

  void _togglePause() {
    final paused = _controller.snapshot.paused;
    if (!paused) _clearInputs();
    _controller.setPaused(!paused);
  }

  void _initGame() {
    final playerCharacter = PlayerCharacterRegistry.resolve(
      widget.playerCharacterId,
    );
    _controller = GameController(
      core: GameCore(
        seed: widget.seed,
        runId: _runId,
        levelDefinition: LevelRegistry.byId(widget.levelId),
        playerCharacter: playerCharacter,
        equippedLoadoutOverride: widget.equippedLoadout,
      ),
    );
    _controller.addEventListener(_handleGameEvent);
    _controller.addListener(_onControllerTick);
    _input = RunnerInputRouter(controller: _controller);
    _projectileAimPreview = AimPreviewModel();
    _meleeAimPreview = AimPreviewModel();
    _aimCancelHitboxRect = ValueNotifier<Rect?>(null);
    _forceAimCancelSignal = ValueNotifier<int>(0);
    _playerImpactFeedbackSignal = ValueNotifier<int>(0);
    _lastPlayerDamageTick = _controller.snapshot.hud.lastDamageTick;
    _lastChargeTier = 0;
    _game = RunnerFlameGame(
      controller: _controller,
      input: _input,
      projectileAimPreview: _projectileAimPreview,
      meleeAimPreview: _meleeAimPreview,
      playerCharacter: playerCharacter,
    );
  }

  void _disposeGame() {
    _controller.removeEventListener(_handleGameEvent);
    _controller.removeListener(_onControllerTick);
    _controller.shutdown();
    _controller.dispose();
    _projectileAimPreview.dispose();
    _meleeAimPreview.dispose();
    _aimCancelHitboxRect.dispose();
    _forceAimCancelSignal.dispose();
    _playerImpactFeedbackSignal.dispose();
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    _disposeGame();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Stack(
      fit: StackFit.expand,
      children: [
        LayoutBuilder(
          builder: (context, constraints) {
            final devicePixelRatio = MediaQuery.devicePixelRatioOf(context);
            final metrics = computeViewportMetrics(
              constraints,
              devicePixelRatio,
              virtualWidth,
              virtualHeight,
              widget.viewportMode,
              alignment: widget.viewportAlignment,
            );
            Widget gameView = GameViewport(
              metrics: metrics,
              child: GameWidget(
                key: ValueKey(_game),
                game: _game,
                autofocus: false,
                loadingBuilder: (_) => const _RunLoadingView(),
              ),
            );

            return gameView;
          },
        ),
        ValueListenableBuilder<RunLoadState>(
          valueListenable: _game.loadState,
          builder: (context, loadState, _) {
            final runLoaded = loadState.phase == RunLoadPhase.worldReady;
            return AnimatedBuilder(
              animation: _controller,
              builder: (context, _) {
                final uiState = _buildUiState(runLoaded: runLoaded);
                if (uiState.gameOver) {
                  final runEndedEvent = _controller.lastRunEndedEvent;
                  final runEndKey =
                      runEndedEvent?.tick ?? _controller.snapshot.tick;
                  return GameOverOverlay(
                    key: ValueKey(
                      'gameOver-$runEndKey-${runEndedEvent?.reason}',
                    ),
                    visible: true,
                    onRestart: _restartGame,
                    onExit: widget.onExit,
                    showExitButton: widget.showExitButton,
                    levelId: _controller.snapshot.levelId,
                    runType: widget.runType,
                    runEndedEvent: runEndedEvent,
                    scoreTuning: _controller.scoreTuning,
                    tickHz: _controller.tickHz,
                    goldEarned: _lastGoldEarned,
                    totalGold: _lastGoldTotal,
                  );
                }
                return GameOverlay(
                  controller: _controller,
                  input: _input,
                  projectileAimPreview: _projectileAimPreview,
                  meleeAimPreview: _meleeAimPreview,
                  aimCancelHitboxRect: _aimCancelHitboxRect,
                  forceAimCancelSignal: _forceAimCancelSignal,
                  playerImpactFeedbackSignal: _playerImpactFeedbackSignal,
                  uiState: uiState,
                  onStart: _startGame,
                  onTogglePause: _togglePause,
                  showExitButton: widget.showExitButton,
                  onExit: uiState.started && !uiState.gameOver
                      ? _openExitConfirm
                      : widget.onExit,
                  exitConfirmOpen: _exitConfirmOpen,
                  onExitConfirmResume: () => _closeExitConfirm(resume: true),
                  onExitConfirmExit: _confirmExitGiveUp,
                );
              },
            );
          },
        ),
      ],
    );
  }
}

class _RunLoadingView extends StatelessWidget {
  const _RunLoadingView();

  @override
  Widget build(BuildContext context) {
    return ColoredBox(
      color: context.ui.colors.background,
      child: MenuLayout(
        alignment: Alignment.center,
        scrollable: false,
        child: const LoaderContent(),
      ),
    );
  }
}


===== FILE: lib/ui/scoped/scoped_preferred_orientations.dart =====
import 'package:flutter/foundation.dart';
import 'package:flutter/services.dart';
import 'package:flutter/widgets.dart';

/// Applies `SystemChrome.setPreferredOrientations` while this widget is mounted.
///
/// This is intentionally scoped to a subtree (typically a route) so the runner
/// can be embedded in a host app without enforcing a global orientation policy.
///
/// Notes:
/// - Flutter does not expose the *previous* preferred orientations, so the
///   caller must decide what to restore on dispose.
/// - Platform-level orientation support (Android manifest / iOS Info.plist)
///   still needs to include the requested orientations.
class ScopedPreferredOrientations extends StatefulWidget {
  const ScopedPreferredOrientations({
    super.key,
    required this.preferredOrientations,
    required this.child,
    this.restoreOrientations,
  });

  final List<DeviceOrientation> preferredOrientations;
  final List<DeviceOrientation>? restoreOrientations;
  final Widget child;

  @override
  State<ScopedPreferredOrientations> createState() =>
      _ScopedPreferredOrientationsState();
}

class _ScopedPreferredOrientationsState
    extends State<ScopedPreferredOrientations> {
  @override
  void initState() {
    super.initState();
    SystemChrome.setPreferredOrientations(widget.preferredOrientations);
  }

  @override
  void didUpdateWidget(covariant ScopedPreferredOrientations oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (!listEquals(
      oldWidget.preferredOrientations,
      widget.preferredOrientations,
    )) {
      SystemChrome.setPreferredOrientations(widget.preferredOrientations);
    }
  }

  @override
  void dispose() {
    final restore = widget.restoreOrientations;
    if (restore != null) {
      SystemChrome.setPreferredOrientations(restore);
    }
    super.dispose();
  }

  @override
  Widget build(BuildContext context) => widget.child;
}


===== FILE: lib/ui/scoped/scoped_system_ui_mode.dart =====
import 'package:flutter/services.dart';
import 'package:flutter/widgets.dart';

/// Applies `SystemChrome.setEnabledSystemUIMode` while this widget is mounted.
///
/// Scoped to a subtree (typically a route) so embedding stays clean.
class ScopedSystemUiMode extends StatefulWidget {
  const ScopedSystemUiMode({
    super.key,
    required this.mode,
    required this.child,
    this.overlays,
    this.restoreMode = SystemUiMode.edgeToEdge,
    this.restoreOverlays,
  });

  final SystemUiMode mode;
  final List<SystemUiOverlay>? overlays;

  final SystemUiMode restoreMode;
  final List<SystemUiOverlay>? restoreOverlays;

  final Widget child;

  @override
  State<ScopedSystemUiMode> createState() => _ScopedSystemUiModeState();
}

class _ScopedSystemUiModeState extends State<ScopedSystemUiMode> {
  @override
  void initState() {
    super.initState();
    _apply();
  }

  @override
  void didUpdateWidget(covariant ScopedSystemUiMode oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.mode != widget.mode ||
        oldWidget.overlays != widget.overlays) {
      _apply();
    }
  }

  void _apply() {
    SystemChrome.setEnabledSystemUIMode(widget.mode, overlays: widget.overlays);
  }

  @override
  void dispose() {
    SystemChrome.setEnabledSystemUIMode(
      widget.restoreMode,
      overlays: widget.restoreOverlays,
    );
    super.dispose();
  }

  @override
  Widget build(BuildContext context) => widget.child;
}


===== FILE: lib/ui/state/app_state.dart =====
import 'dart:math';

import 'package:flutter/foundation.dart';

import '../../core/abilities/ability_catalog.dart';
import '../../core/abilities/ability_def.dart';
import '../../core/ecs/stores/combat/equipped_loadout_store.dart';
import '../../core/levels/level_id.dart';
import '../../core/loadout/loadout_validator.dart';
import '../../core/meta/gear_slot.dart';
import '../../core/meta/meta_service.dart';
import '../../core/meta/meta_state.dart';
import '../../core/players/player_character_definition.dart';
import '../../core/players/player_character_registry.dart';
import '../../core/projectiles/projectile_catalog.dart';
import '../../core/projectiles/projectile_id.dart';
import '../../core/spellBook/spell_book_catalog.dart';
import '../../core/spellBook/spell_book_id.dart';
import '../../core/weapons/weapon_catalog.dart';
import '../app/ui_routes.dart';
import 'selection_state.dart';
import 'selection_store.dart';
import 'meta_store.dart';
import 'user_profile.dart';
import 'user_profile_store.dart';

class AppState extends ChangeNotifier {
  AppState({
    SelectionStore? selectionStore,
    MetaStore? metaStore,
    UserProfileStore? userProfileStore,
    MetaService? metaService,
  }) : _selectionStore = selectionStore ?? SelectionStore(),
       _metaStore = metaStore ?? MetaStore(),
       _profileStore = userProfileStore ?? UserProfileStore(),
       _metaService = metaService ?? const MetaService();

  final Random _random = Random();
  final SelectionStore _selectionStore;
  final MetaStore _metaStore;
  final UserProfileStore _profileStore;
  final MetaService _metaService;
  static const AbilityCatalog _abilityCatalog = AbilityCatalog();
  static const ProjectileCatalog _projectileCatalog = ProjectileCatalog();
  static const SpellBookCatalog _spellBookCatalog = SpellBookCatalog();
  static const LoadoutValidator _loadoutValidator = LoadoutValidator(
    abilityCatalog: _abilityCatalog,
    weaponCatalog: WeaponCatalog(),
    projectileCatalog: _projectileCatalog,
    spellBookCatalog: _spellBookCatalog,
  );

  SelectionState _selection = SelectionState.defaults;
  MetaState _meta = const MetaService().createNew();
  UserProfile _profile = UserProfile.empty();
  bool _bootstrapped = false;
  bool _warmupStarted = false;

  SelectionState get selection => _selection;
  MetaState get meta => _meta;
  UserProfile get profile => _profile;
  bool get isBootstrapped => _bootstrapped;

  Future<void> bootstrap({bool force = false}) async {
    if (_bootstrapped && !force) return;
    final loadedSelection = await _selectionStore.load();
    final loadedMeta = await _metaStore.load(_metaService);
    final loadedProfile = await _profileStore.load();
    _selection = loadedSelection;
    _meta = loadedMeta;
    _profile = loadedProfile;
    await _normalizeSelectionLoadoutsIfNeeded();
    _bootstrapped = true;
    notifyListeners();
  }

  void applyDefaults() {
    _selection = SelectionState.defaults;
    _meta = _metaService.createNew();
    _profile = _profileStore.createFresh();
    _persistSelection();
    _persistMeta();
    _persistProfile();
    notifyListeners();
  }

  Future<void> setLevel(LevelId levelId) async {
    _selection = _selection.copyWith(selectedLevelId: levelId);
    _persistSelection();
    notifyListeners();
  }

  Future<void> setRunType(RunType runType) async {
    _selection = _selection.copyWith(selectedRunType: runType);
    _persistSelection();
    notifyListeners();
  }

  Future<void> setCharacter(PlayerCharacterId id) async {
    final currentLoadout = _selection.loadoutFor(id);
    final normalizedLoadout = _normalizeLoadoutForCharacter(currentLoadout, id);
    _selection = _selection
        .withLoadoutFor(id, normalizedLoadout)
        .copyWith(selectedCharacterId: id);
    _persistSelection();
    notifyListeners();
  }

  Future<void> setLoadout(EquippedLoadoutDef loadout) async {
    final characterId = _selection.selectedCharacterId;
    final normalizedLoadout = _normalizeLoadoutForCharacter(
      loadout,
      characterId,
    );
    _selection = _selection.withLoadoutFor(characterId, normalizedLoadout);
    _persistSelection();
    notifyListeners();
  }

  Future<void> equipGear({
    required PlayerCharacterId characterId,
    required GearSlot slot,
    required Object itemId,
  }) async {
    final next = _metaService.equip(
      _meta,
      characterId: characterId,
      slot: slot,
      itemId: itemId,
    );
    _meta = next;
    _persistMeta();
    final currentLoadout = _selection.loadoutFor(characterId);
    final synced = _normalizeLoadoutForCharacter(currentLoadout, characterId);
    if (!_sameLoadout(currentLoadout, synced)) {
      _selection = _selection.withLoadoutFor(characterId, synced);
      _persistSelection();
    }
    notifyListeners();
  }

  Future<void> setBuildName(String buildName) async {
    final normalized = SelectionState.normalizeBuildName(buildName);
    if (normalized == _selection.buildName) return;
    _selection = _selection.copyWith(buildName: normalized);
    _persistSelection();
    notifyListeners();
  }

  Future<void> updateProfile(
    UserProfile Function(UserProfile current) fn,
  ) async {
    final current = _profile;
    final updated = fn(current);
    final nowMs = DateTime.now().millisecondsSinceEpoch;
    final next = updated.copyWith(
      schemaVersion: UserProfile.latestSchemaVersion,
      profileId: updated.profileId.isEmpty
          ? current.profileId
          : updated.profileId,
      createdAtMs: updated.createdAtMs == 0
          ? current.createdAtMs
          : updated.createdAtMs,
      updatedAtMs: nowMs,
      revision: current.revision + 1,
    );
    _profile = next;
    await _profileStore.save(next);
    notifyListeners();
  }

  void startWarmup() {
    if (_warmupStarted) return;
    _warmupStarted = true;
  }

  RunStartArgs buildRunStartArgs({int? seed}) {
    final equipped = _buildRunEquippedLoadout();
    return RunStartArgs(
      runId: createRunId(),
      seed: seed ?? _random.nextInt(1 << 31),
      levelId: _selection.selectedLevelId,
      playerCharacterId: _selection.selectedCharacterId,
      runType: _selection.selectedRunType,
      equippedLoadout: equipped,
    );
  }

  EquippedLoadoutDef _buildRunEquippedLoadout() {
    final characterId = _selection.selectedCharacterId;
    return _normalizeLoadoutForCharacter(
      _selection.loadoutFor(characterId),
      characterId,
    );
  }

  int createRunId() => _createRunId();

  int _createRunId() {
    final nowMs = DateTime.now().millisecondsSinceEpoch;
    final salt = _random.nextInt(1 << 20);
    return (nowMs << 20) | salt;
  }

  void _persistSelection() {
    _selectionStore.save(_selection);
  }

  void _persistMeta() {
    _metaStore.save(_meta);
  }

  void _persistProfile() {
    _profileStore.save(_profile);
  }

  Future<void> _normalizeSelectionLoadoutsIfNeeded() async {
    var changed = false;
    var normalizedSelection = _selection;
    for (final characterId in PlayerCharacterId.values) {
      final current = normalizedSelection.loadoutFor(characterId);
      final normalized = _normalizeLoadoutForCharacter(current, characterId);
      if (_sameLoadout(current, normalized)) continue;
      normalizedSelection = normalizedSelection.withLoadoutFor(
        characterId,
        normalized,
      );
      changed = true;
    }
    if (!changed) return;
    _selection = normalizedSelection;
    await _selectionStore.save(_selection);
  }

  EquippedLoadoutDef _normalizeLoadoutForCharacter(
    EquippedLoadoutDef loadout,
    PlayerCharacterId characterId,
  ) {
    final gear = _meta.equippedFor(characterId);
    final character = PlayerCharacterRegistry.resolve(characterId);
    final catalog = character.catalog;
    var normalized = EquippedLoadoutDef(
      mask: catalog.loadoutSlotMask,
      mainWeaponId: gear.mainWeaponId,
      offhandWeaponId: gear.offhandWeaponId,
      projectileId: gear.throwingWeaponId,
      spellBookId: gear.spellBookId,
      projectileSlotSpellId: loadout.projectileSlotSpellId,
      accessoryId: gear.accessoryId,
      abilityPrimaryId: _normalizeAbilityForSlot(
        abilityId: loadout.abilityPrimaryId,
        slot: AbilitySlot.primary,
        fallback: catalog.abilityPrimaryId,
      ),
      abilitySecondaryId: _normalizeAbilityForSlot(
        abilityId: loadout.abilitySecondaryId,
        slot: AbilitySlot.secondary,
        fallback: catalog.abilitySecondaryId,
      ),
      abilityProjectileId: _normalizeAbilityForSlot(
        abilityId: loadout.abilityProjectileId,
        slot: AbilitySlot.projectile,
        fallback: catalog.abilityProjectileId,
      ),
      abilitySpellId: _normalizeAbilityForSlot(
        abilityId: loadout.abilitySpellId,
        slot: AbilitySlot.spell,
        fallback: catalog.abilitySpellId,
      ),
      abilityMobilityId: _normalizeAbilityForSlot(
        abilityId: loadout.abilityMobilityId,
        slot: AbilitySlot.mobility,
        fallback: catalog.abilityMobilityId,
      ),
      abilityJumpId: _normalizeAbilityForSlot(
        abilityId: loadout.abilityJumpId,
        slot: AbilitySlot.jump,
        fallback: catalog.abilityJumpId,
      ),
    );
    final normalizedProjectileSpellId =
        _normalizeProjectileSpellSelectionForLoadout(normalized);
    if (normalizedProjectileSpellId != normalized.projectileSlotSpellId) {
      normalized = _withProjectileSpellSelection(
        normalized,
        projectileSlotSpellId: normalizedProjectileSpellId,
      );
    }
    final normalizedSpellAbilityId = _normalizeSpellAbilityForLoadout(
      normalized,
      characterId: characterId,
    );
    if (normalizedSpellAbilityId != normalized.abilitySpellId) {
      normalized = _withAbilityForSlot(
        normalized,
        slot: AbilitySlot.spell,
        abilityId: normalizedSpellAbilityId,
      );
    }
    return _sameLoadout(normalized, loadout) ? loadout : normalized;
  }

  AbilityKey _normalizeAbilityForSlot({
    required AbilityKey abilityId,
    required AbilitySlot slot,
    required AbilityKey fallback,
  }) {
    final ability = _abilityCatalog.resolve(abilityId);
    if (ability != null && ability.allowedSlots.contains(slot)) {
      return ability.id;
    }
    final fallbackAbility = _abilityCatalog.resolve(fallback);
    if (fallbackAbility != null &&
        fallbackAbility.allowedSlots.contains(slot)) {
      return fallbackAbility.id;
    }
    return fallback;
  }

  AbilityKey _normalizeSpellAbilityForLoadout(
    EquippedLoadoutDef loadout, {
    required PlayerCharacterId characterId,
  }) {
    final current = loadout.abilitySpellId;
    if (_isAbilityValidForSlot(
      loadout,
      slot: AbilitySlot.spell,
      abilityId: current,
    )) {
      return current;
    }

    final replacement = _firstValidAbilityForSlot(
      loadout,
      slot: AbilitySlot.spell,
      characterId: characterId,
    );
    return replacement ?? current;
  }

  ProjectileId? _normalizeProjectileSpellSelectionForLoadout(
    EquippedLoadoutDef loadout,
  ) {
    final current = loadout.projectileSlotSpellId;
    if (current == null) return null;
    if (_isProjectileSpellAllowedBySpellBook(loadout.spellBookId, current)) {
      return current;
    }

    final spellBook = _spellBookCatalog.tryGet(loadout.spellBookId);
    if (spellBook == null) return null;

    for (final spellId in spellBook.projectileSpellIds) {
      if (_isProjectileSpellAllowedBySpellBook(loadout.spellBookId, spellId)) {
        return spellId;
      }
    }
    return null;
  }

  bool _isProjectileSpellAllowedBySpellBook(
    SpellBookId spellBookId,
    ProjectileId spellId,
  ) {
    final spellBook = _spellBookCatalog.tryGet(spellBookId);
    if (spellBook == null) return false;
    if (!spellBook.containsProjectileSpell(spellId)) return false;
    final spellItem = _projectileCatalog.tryGet(spellId);
    if (spellItem == null) return false;
    return spellItem.weaponType == WeaponType.projectileSpell;
  }

  AbilityKey? _firstValidAbilityForSlot(
    EquippedLoadoutDef loadout, {
    required AbilitySlot slot,
    required PlayerCharacterId characterId,
  }) {
    final candidates = <AbilityDef>[
      for (final def in AbilityCatalog.abilities.values)
        if (_isAbilityVisibleForCharacter(characterId, def.id) &&
            def.allowedSlots.contains(slot))
          def,
    ]..sort((a, b) => a.id.compareTo(b.id));

    for (final candidate in candidates) {
      if (_isAbilityValidForSlot(
        loadout,
        slot: slot,
        abilityId: candidate.id,
      )) {
        return candidate.id;
      }
    }
    return null;
  }

  bool _isAbilityValidForSlot(
    EquippedLoadoutDef loadout, {
    required AbilitySlot slot,
    required AbilityKey abilityId,
  }) {
    final trial = _withAbilityForSlot(
      loadout,
      slot: slot,
      abilityId: abilityId,
    );
    final result = _loadoutValidator.validate(trial);
    for (final issue in result.issues) {
      if (issue.slot == slot) {
        return false;
      }
    }
    return true;
  }

  EquippedLoadoutDef _withAbilityForSlot(
    EquippedLoadoutDef loadout, {
    required AbilitySlot slot,
    required AbilityKey abilityId,
  }) {
    return EquippedLoadoutDef(
      mask: loadout.mask,
      mainWeaponId: loadout.mainWeaponId,
      offhandWeaponId: loadout.offhandWeaponId,
      projectileId: loadout.projectileId,
      spellBookId: loadout.spellBookId,
      projectileSlotSpellId: loadout.projectileSlotSpellId,
      accessoryId: loadout.accessoryId,
      abilityPrimaryId: slot == AbilitySlot.primary
          ? abilityId
          : loadout.abilityPrimaryId,
      abilitySecondaryId: slot == AbilitySlot.secondary
          ? abilityId
          : loadout.abilitySecondaryId,
      abilityProjectileId: slot == AbilitySlot.projectile
          ? abilityId
          : loadout.abilityProjectileId,
      abilitySpellId: slot == AbilitySlot.spell
          ? abilityId
          : loadout.abilitySpellId,
      abilityMobilityId: slot == AbilitySlot.mobility
          ? abilityId
          : loadout.abilityMobilityId,
      abilityJumpId: slot == AbilitySlot.jump
          ? abilityId
          : loadout.abilityJumpId,
    );
  }

  EquippedLoadoutDef _withProjectileSpellSelection(
    EquippedLoadoutDef loadout, {
    required ProjectileId? projectileSlotSpellId,
  }) {
    return EquippedLoadoutDef(
      mask: loadout.mask,
      mainWeaponId: loadout.mainWeaponId,
      offhandWeaponId: loadout.offhandWeaponId,
      projectileId: loadout.projectileId,
      spellBookId: loadout.spellBookId,
      projectileSlotSpellId: projectileSlotSpellId,
      accessoryId: loadout.accessoryId,
      abilityPrimaryId: loadout.abilityPrimaryId,
      abilitySecondaryId: loadout.abilitySecondaryId,
      abilityProjectileId: loadout.abilityProjectileId,
      abilitySpellId: loadout.abilitySpellId,
      abilityMobilityId: loadout.abilityMobilityId,
      abilityJumpId: loadout.abilityJumpId,
    );
  }

  bool _isAbilityVisibleForCharacter(
    PlayerCharacterId characterId,
    AbilityKey id,
  ) {
    if (id.startsWith('${characterId.name}.')) {
      return true;
    }
    if (id.startsWith('common.') && !id.startsWith('common.enemy_')) {
      return true;
    }
    return false;
  }

  bool _sameLoadout(EquippedLoadoutDef a, EquippedLoadoutDef b) {
    return a.mask == b.mask &&
        a.mainWeaponId == b.mainWeaponId &&
        a.offhandWeaponId == b.offhandWeaponId &&
        a.projectileId == b.projectileId &&
        a.spellBookId == b.spellBookId &&
        a.projectileSlotSpellId == b.projectileSlotSpellId &&
        a.accessoryId == b.accessoryId &&
        a.abilityPrimaryId == b.abilityPrimaryId &&
        a.abilitySecondaryId == b.abilitySecondaryId &&
        a.abilityProjectileId == b.abilityProjectileId &&
        a.abilitySpellId == b.abilitySpellId &&
        a.abilityMobilityId == b.abilityMobilityId &&
        a.abilityJumpId == b.abilityJumpId;
  }
}


===== FILE: lib/ui/state/meta_store.dart =====
import 'dart:convert';

import 'package:shared_preferences/shared_preferences.dart';

import '../../core/meta/meta_service.dart';
import '../../core/meta/meta_state.dart';

class MetaStore {
  static const String _prefsKey = 'ui.meta_state.v1';

  Future<MetaState> load(MetaService service) async {
    final prefs = await SharedPreferences.getInstance();
    final raw = prefs.getString(_prefsKey);
    final fallback = service.createNew();

    if (raw == null || raw.isEmpty) {
      await save(fallback);
      return fallback;
    }

    try {
      final decoded = jsonDecode(raw);
      Map<String, dynamic>? map;
      if (decoded is Map<String, dynamic>) {
        map = decoded;
      } else if (decoded is Map) {
        map = Map<String, dynamic>.from(decoded);
      }

      if (map != null) {
        final loaded = MetaState.fromJson(map, fallback: fallback);
        final normalized = service.normalize(loaded);
        if (normalized.schemaVersion != loaded.schemaVersion ||
            jsonEncode(normalized.toJson()) != jsonEncode(loaded.toJson())) {
          await save(normalized);
        }
        return normalized;
      }
    } catch (_) {
      // Fall through to defaults.
    }

    await save(fallback);
    return fallback;
  }

  Future<void> save(MetaState state) async {
    final prefs = await SharedPreferences.getInstance();
    final payload = jsonEncode(state.toJson());
    await prefs.setString(_prefsKey, payload);
  }

  Future<void> clear() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.remove(_prefsKey);
  }
}


===== FILE: lib/ui/state/profile_counter_keys.dart =====
class ProfileCounterKeys {
  const ProfileCounterKeys._();

  static const String gold = 'gold';
}


===== FILE: lib/ui/state/profile_flag_keys.dart =====
class ProfileFlagKeys {
  const ProfileFlagKeys._();

  static const String namePromptCompleted = 'namePromptCompleted';
}


===== FILE: lib/ui/state/selection_state.dart =====
import '../../core/ecs/stores/combat/equipped_loadout_store.dart';
import '../../core/levels/level_id.dart';
import '../../core/players/player_character_definition.dart';
import '../../core/projectiles/projectile_id.dart';
import '../../core/spellBook/spell_book_id.dart';
import '../../core/accessories/accessory_id.dart';
import '../../core/weapons/weapon_id.dart';

/// Menu-facing run type for the selected level.
enum RunType { practice, competitive }

/// Persistent menu selection state.
class SelectionState {
  SelectionState({
    required this.selectedLevelId,
    required this.selectedRunType,
    required this.selectedCharacterId,
    required Map<PlayerCharacterId, EquippedLoadoutDef> loadoutsByCharacter,
    required this.buildName,
  }) : loadoutsByCharacter = Map.unmodifiable(
         _ensureLoadoutsForAllCharacters(loadoutsByCharacter),
       );

  static const String defaultBuildName = 'Build 1';
  static const int buildNameMaxLength = 24;

  static final SelectionState defaults = SelectionState(
    selectedLevelId: LevelId.field,
    selectedRunType: RunType.practice,
    selectedCharacterId: PlayerCharacterId.eloise,
    loadoutsByCharacter: _seedLoadoutsWith(const EquippedLoadoutDef()),
    buildName: defaultBuildName,
  );

  final LevelId selectedLevelId;
  final RunType selectedRunType;
  final PlayerCharacterId selectedCharacterId;
  final Map<PlayerCharacterId, EquippedLoadoutDef> loadoutsByCharacter;
  final String buildName;

  bool get isCompetitive => selectedRunType == RunType.competitive;

  EquippedLoadoutDef loadoutFor(PlayerCharacterId id) {
    return loadoutsByCharacter[id] ?? const EquippedLoadoutDef();
  }

  SelectionState copyWith({
    LevelId? selectedLevelId,
    RunType? selectedRunType,
    PlayerCharacterId? selectedCharacterId,
    Map<PlayerCharacterId, EquippedLoadoutDef>? loadoutsByCharacter,
    String? buildName,
  }) {
    return SelectionState(
      selectedLevelId: selectedLevelId ?? this.selectedLevelId,
      selectedRunType: selectedRunType ?? this.selectedRunType,
      selectedCharacterId: selectedCharacterId ?? this.selectedCharacterId,
      loadoutsByCharacter: loadoutsByCharacter ?? this.loadoutsByCharacter,
      buildName: buildName == null
          ? this.buildName
          : normalizeBuildName(buildName),
    );
  }

  SelectionState withLoadoutFor(
    PlayerCharacterId id,
    EquippedLoadoutDef loadout,
  ) {
    final next = Map<PlayerCharacterId, EquippedLoadoutDef>.from(
      loadoutsByCharacter,
    );
    next[id] = loadout;
    return copyWith(loadoutsByCharacter: next);
  }

  Map<String, Object?> toJson() {
    return <String, Object?>{
      'levelId': selectedLevelId.name,
      'runType': selectedRunType.name,
      'characterId': selectedCharacterId.name,
      'loadoutsByCharacter': <String, Object?>{
        for (final id in PlayerCharacterId.values)
          id.name: _loadoutToJson(loadoutFor(id)),
      },
      'buildName': buildName,
    };
  }

  static SelectionState fromJson(Map<String, dynamic> json) {
    final levelId = _enumFromName(
      LevelId.values,
      json['levelId'] as String?,
      LevelId.field,
    );
    final runType = _enumFromName(
      RunType.values,
      json['runType'] as String?,
      RunType.practice,
    );
    final characterId = _enumFromName(
      PlayerCharacterId.values,
      json['characterId'] as String?,
      PlayerCharacterId.eloise,
    );
    final baseLoadout = json.containsKey('loadout')
        ? _loadoutFromJson(json['loadout'])
        : const EquippedLoadoutDef();
    final loadouts = _seedLoadoutsWith(baseLoadout);
    final loadoutsRaw = json['loadoutsByCharacter'];
    if (loadoutsRaw is Map) {
      for (final id in PlayerCharacterId.values) {
        final raw = loadoutsRaw[id.name];
        if (raw is Map<String, dynamic>) {
          loadouts[id] = _loadoutFromJson(raw);
        } else if (raw is Map) {
          loadouts[id] = _loadoutFromJson(Map<String, dynamic>.from(raw));
        }
      }
    }
    final buildName = normalizeBuildName(
      json['buildName'] is String ? json['buildName'] as String : null,
    );

    return SelectionState(
      selectedLevelId: levelId,
      selectedRunType: runType,
      selectedCharacterId: characterId,
      loadoutsByCharacter: loadouts,
      buildName: buildName,
    );
  }

  static String normalizeBuildName(String? raw) {
    final trimmed = (raw ?? '').trim();
    if (trimmed.isEmpty) return defaultBuildName;
    if (trimmed.length <= buildNameMaxLength) return trimmed;
    return trimmed.substring(0, buildNameMaxLength);
  }
}

Map<PlayerCharacterId, EquippedLoadoutDef> _seedLoadoutsWith(
  EquippedLoadoutDef loadout,
) {
  return <PlayerCharacterId, EquippedLoadoutDef>{
    for (final id in PlayerCharacterId.values) id: loadout,
  };
}

Map<PlayerCharacterId, EquippedLoadoutDef> _ensureLoadoutsForAllCharacters(
  Map<PlayerCharacterId, EquippedLoadoutDef> source,
) {
  return <PlayerCharacterId, EquippedLoadoutDef>{
    for (final id in PlayerCharacterId.values)
      id: source[id] ?? const EquippedLoadoutDef(),
  };
}

T _enumFromName<T extends Enum>(List<T> values, String? name, T fallback) {
  if (name == null) return fallback;
  for (final value in values) {
    if (value.name == name) return value;
  }
  return fallback;
}

Map<String, Object?> _loadoutToJson(EquippedLoadoutDef loadout) {
  return <String, Object?>{
    'mask': loadout.mask,
    'mainWeaponId': loadout.mainWeaponId.name,
    'offhandWeaponId': loadout.offhandWeaponId.name,
    'ProjectileId': loadout.projectileId.name,
    'spellBookId': loadout.spellBookId.name,
    'projectileSlotSpellId': loadout.projectileSlotSpellId?.name,
    'accessoryId': loadout.accessoryId.name,
    'abilityPrimaryId': loadout.abilityPrimaryId,
    'abilitySecondaryId': loadout.abilitySecondaryId,
    'abilityProjectileId': loadout.abilityProjectileId,
    'abilitySpellId': loadout.abilitySpellId,
    'abilityMobilityId': loadout.abilityMobilityId,
    'abilityJumpId': loadout.abilityJumpId,
  };
}

EquippedLoadoutDef _loadoutFromJson(Object? raw) {
  if (raw is! Map) {
    return const EquippedLoadoutDef();
  }
  final map = Map<String, dynamic>.from(raw);
  return EquippedLoadoutDef(
    mask: map['mask'] is int ? map['mask'] as int : LoadoutSlotMask.defaultMask,
    mainWeaponId: _enumFromName(
      WeaponId.values,
      map['mainWeaponId'] as String?,
      WeaponId.woodenSword,
    ),
    offhandWeaponId: _enumFromName(
      WeaponId.values,
      map['offhandWeaponId'] as String?,
      WeaponId.woodenShield,
    ),
    projectileId: _enumFromName(
      ProjectileId.values,
      map['ProjectileId'] as String?,
      ProjectileId.throwingKnife,
    ),
    spellBookId: _enumFromName(
      SpellBookId.values,
      map['spellBookId'] as String?,
      SpellBookId.basicSpellBook,
    ),
    projectileSlotSpellId: map.containsKey('projectileSlotSpellId')
        ? _enumFromNameNullable(
            ProjectileId.values,
            map['projectileSlotSpellId'] as String?,
          )
        : const EquippedLoadoutDef().projectileSlotSpellId,
    accessoryId: _enumFromName(
      AccessoryId.values,
      map['accessoryId'] as String?,
      AccessoryId.speedBoots,
    ),
    abilityPrimaryId:
        (map['abilityPrimaryId'] as String?) ??
        const EquippedLoadoutDef().abilityPrimaryId,
    abilitySecondaryId:
        (map['abilitySecondaryId'] as String?) ??
        const EquippedLoadoutDef().abilitySecondaryId,
    abilityProjectileId:
        (map['abilityProjectileId'] as String?) ??
        const EquippedLoadoutDef().abilityProjectileId,
    abilitySpellId:
        (map['abilitySpellId'] as String?) ??
        (map['abilityBonusId'] as String?) ??
        const EquippedLoadoutDef().abilitySpellId,
    abilityMobilityId:
        (map['abilityMobilityId'] as String?) ??
        const EquippedLoadoutDef().abilityMobilityId,
    abilityJumpId:
        (map['abilityJumpId'] as String?) ??
        const EquippedLoadoutDef().abilityJumpId,
  );
}

T? _enumFromNameNullable<T extends Enum>(List<T> values, String? name) {
  if (name == null) return null;
  for (final value in values) {
    if (value.name == name) return value;
  }
  return null;
}


===== FILE: lib/ui/state/selection_store.dart =====
import 'dart:convert';

import 'package:shared_preferences/shared_preferences.dart';

import 'selection_state.dart';

class SelectionStore {
  static const String _prefsKey = 'ui.selection_state.v1';

  Future<SelectionState> load() async {
    final prefs = await SharedPreferences.getInstance();
    final raw = prefs.getString(_prefsKey);
    if (raw == null || raw.isEmpty) {
      return SelectionState.defaults;
    }

    try {
      final decoded = jsonDecode(raw);
      if (decoded is Map<String, dynamic>) {
        return SelectionState.fromJson(decoded);
      }
      if (decoded is Map) {
        return SelectionState.fromJson(Map<String, dynamic>.from(decoded));
      }
    } catch (_) {
      // Fall through to defaults.
    }

    return SelectionState.defaults;
  }

  Future<void> save(SelectionState state) async {
    final prefs = await SharedPreferences.getInstance();
    final payload = jsonEncode(state.toJson());
    await prefs.setString(_prefsKey, payload);
  }

  Future<void> clear() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.remove(_prefsKey);
  }
}


===== FILE: lib/ui/state/user_profile.dart =====
import 'profile_counter_keys.dart';

class UserProfile {
  UserProfile({
    required this.schemaVersion,
    required this.profileId,
    required this.createdAtMs,
    required this.updatedAtMs,
    required this.revision,
    required this.displayName,
    required this.displayNameLastChangedAtMs,
    required Map<String, bool> flags,
    required Map<String, int> counters,
  }) : flags = Map<String, bool>.unmodifiable(flags),
       counters = Map<String, int>.unmodifiable(counters);

  static const int latestSchemaVersion = 2;

  final int schemaVersion;
  final String profileId;
  final int createdAtMs;
  final int updatedAtMs;
  final int revision;
  final String displayName;
  final int displayNameLastChangedAtMs;
  final Map<String, bool> flags;
  final Map<String, int> counters;

  static UserProfile empty() {
    return UserProfile(
      schemaVersion: latestSchemaVersion,
      profileId: 'guest',
      createdAtMs: 0,
      updatedAtMs: 0,
      revision: 0,
      displayName: '',
      displayNameLastChangedAtMs: 0,
      flags: const <String, bool>{},
      counters: const <String, int>{ProfileCounterKeys.gold: 0},
    );
  }

  static UserProfile createNew({
    required String profileId,
    required int nowMs,
  }) {
    return UserProfile(
      schemaVersion: latestSchemaVersion,
      profileId: profileId,
      createdAtMs: nowMs,
      updatedAtMs: nowMs,
      revision: 0,
      displayName: '',
      displayNameLastChangedAtMs: 0,
      flags: const <String, bool>{},
      counters: const <String, int>{ProfileCounterKeys.gold: 0},
    );
  }

  UserProfile copyWith({
    int? schemaVersion,
    String? profileId,
    int? createdAtMs,
    int? updatedAtMs,
    int? revision,
    String? displayName,
    int? displayNameLastChangedAtMs,
    Map<String, bool>? flags,
    Map<String, int>? counters,
  }) {
    return UserProfile(
      schemaVersion: schemaVersion ?? this.schemaVersion,
      profileId: profileId ?? this.profileId,
      createdAtMs: createdAtMs ?? this.createdAtMs,
      updatedAtMs: updatedAtMs ?? this.updatedAtMs,
      revision: revision ?? this.revision,
      displayName: displayName ?? this.displayName,
      displayNameLastChangedAtMs:
          displayNameLastChangedAtMs ?? this.displayNameLastChangedAtMs,
      flags: flags ?? this.flags,
      counters: counters ?? this.counters,
    );
  }

  Map<String, Object?> toJson() {
    return <String, Object?>{
      'schemaVersion': schemaVersion,
      'profileId': profileId,
      'createdAtMs': createdAtMs,
      'updatedAtMs': updatedAtMs,
      'revision': revision,
      'displayName': displayName,
      'displayNameLastChangedAtMs': displayNameLastChangedAtMs,
      'flags': flags,
      'counters': counters,
    };
  }

  factory UserProfile.fromJson(
    Map<String, dynamic> json, {
    required String fallbackProfileId,
    required int nowMs,
  }) {
    final schemaVersion =
        _readInt(json['schemaVersion']) ?? latestSchemaVersion;
    final profileId = _readString(json['profileId']) ?? fallbackProfileId;
    final createdAtMs = _readInt(json['createdAtMs']) ?? nowMs;
    final updatedAtMs = _readInt(json['updatedAtMs']) ?? createdAtMs;
    final revision = _readInt(json['revision']) ?? 0;
    final displayName = _readStringAllowEmpty(json['displayName']) ?? '';
    final displayNameLastChangedAtMs =
        _readInt(json['displayNameLastChangedAtMs']) ?? 0;
    final flags = _readBoolMap(json['flags']);
    final counters = _readIntMap(json['counters']);
    counters.putIfAbsent(ProfileCounterKeys.gold, () => 0);

    return UserProfile(
      schemaVersion: schemaVersion,
      profileId: profileId,
      createdAtMs: createdAtMs,
      updatedAtMs: updatedAtMs,
      revision: revision,
      displayName: displayName,
      displayNameLastChangedAtMs: displayNameLastChangedAtMs,
      flags: flags,
      counters: counters,
    );
  }
}

int? _readInt(Object? raw) {
  if (raw is int) return raw;
  if (raw is num) return raw.toInt();
  return null;
}

String? _readString(Object? raw) {
  if (raw is String && raw.isNotEmpty) return raw;
  return null;
}

String? _readStringAllowEmpty(Object? raw) {
  if (raw is String) return raw;
  return null;
}

Map<String, bool> _readBoolMap(Object? raw) {
  if (raw is! Map) return <String, bool>{};
  final map = <String, bool>{};
  raw.forEach((key, value) {
    if (key is String && value is bool) {
      map[key] = value;
    }
  });
  return map;
}

Map<String, int> _readIntMap(Object? raw) {
  if (raw is! Map) return <String, int>{};
  final map = <String, int>{};
  raw.forEach((key, value) {
    if (key is! String) return;
    if (value is int) {
      map[key] = value;
      return;
    }
    if (value is num) {
      map[key] = value.toInt();
    }
  });
  return map;
}


===== FILE: lib/ui/state/user_profile_store.dart =====
import 'dart:convert';
import 'dart:developer' as developer;
import 'dart:math';

import 'package:shared_preferences/shared_preferences.dart';

import 'user_profile.dart';
import 'profile_counter_keys.dart';

class UserProfileStore {
  UserProfileStore({Random? random, DateTime Function()? now})
    : _random = random ?? Random(),
      _now = now ?? DateTime.now;

  static const String _prefsKey = 'ui.user_profile';

  final Random _random;
  final DateTime Function() _now;

  Future<UserProfile> load() async {
    final prefs = await SharedPreferences.getInstance();
    final raw = prefs.getString(_prefsKey);
    final nowMs = _now().millisecondsSinceEpoch;
    final fallbackProfileId = _generateProfileId(nowMs);

    if (raw == null || raw.isEmpty) {
      final created = UserProfile.createNew(
        profileId: fallbackProfileId,
        nowMs: nowMs,
      );
      await save(created);
      return created;
    }

    try {
      final decoded = jsonDecode(raw);
      Map<String, dynamic>? map;
      if (decoded is Map<String, dynamic>) {
        map = decoded;
      } else if (decoded is Map) {
        map = Map<String, dynamic>.from(decoded);
      }

      if (map == null) {
        _logWarning(
          'Expected map payload for user profile but found '
          '${decoded.runtimeType}.',
        );
      } else {
        final migration = _migrateToLatest(
          map,
          nowMs: nowMs,
          fallbackProfileId: fallbackProfileId,
        );
        final profile = UserProfile.fromJson(
          migration.data,
          fallbackProfileId: fallbackProfileId,
          nowMs: nowMs,
        );
        if (migration.didChange) {
          await save(profile);
        }
        return profile;
      }
    } catch (error, stackTrace) {
      _logWarning(
        'Failed to decode stored user profile.',
        error: error,
        stackTrace: stackTrace,
      );
    }

    final created = UserProfile.createNew(
      profileId: fallbackProfileId,
      nowMs: nowMs,
    );
    await save(created);
    return created;
  }

  Future<void> save(UserProfile profile) async {
    final prefs = await SharedPreferences.getInstance();
    final payload = jsonEncode(profile.toJson());
    await prefs.setString(_prefsKey, payload);
  }

  Future<void> clear() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.remove(_prefsKey);
  }

  UserProfile createFresh() {
    final nowMs = _now().millisecondsSinceEpoch;
    return UserProfile.createNew(
      profileId: _generateProfileId(nowMs),
      nowMs: nowMs,
    );
  }

  _MigrationResult _migrateToLatest(
    Map<String, dynamic> raw, {
    required int nowMs,
    required String fallbackProfileId,
  }) {
    var didChange = false;
    final data = Map<String, dynamic>.from(raw);

    final schemaVersion = _readInt(data['schemaVersion']);
    if (schemaVersion == null) {
      data['schemaVersion'] = UserProfile.latestSchemaVersion;
      didChange = true;
    } else if (schemaVersion < UserProfile.latestSchemaVersion) {
      data['schemaVersion'] = UserProfile.latestSchemaVersion;
      didChange = true;
    }

    final profileId = data['profileId'];
    if (profileId is! String || profileId.isEmpty) {
      data['profileId'] = fallbackProfileId;
      didChange = true;
    }

    final createdAtMs = _readInt(data['createdAtMs']);
    if (createdAtMs == null) {
      data['createdAtMs'] = nowMs;
      didChange = true;
    }

    final updatedAtMs = _readInt(data['updatedAtMs']);
    if (updatedAtMs == null) {
      data['updatedAtMs'] = createdAtMs ?? nowMs;
      didChange = true;
    }

    final revision = _readInt(data['revision']);
    if (revision == null) {
      data['revision'] = 0;
      didChange = true;
    }

    final displayName = data['displayName'];
    if (displayName is! String) {
      data['displayName'] = '';
      didChange = true;
    }

    // displayNameNormalized removal (schema v2)
    if (data.containsKey('displayNameNormalized')) {
      data.remove('displayNameNormalized');
      didChange = true;
    }

    final displayNameLastChangedAtMs = _readInt(
      data['displayNameLastChangedAtMs'],
    );
    if (displayNameLastChangedAtMs == null) {
      data['displayNameLastChangedAtMs'] = 0;
      didChange = true;
    }

    if (data['flags'] is! Map) {
      data['flags'] = <String, bool>{};
      didChange = true;
    }

    if (data['counters'] is! Map) {
      data['counters'] = <String, int>{};
      didChange = true;
    } else {
      final counters = data['counters'];
      if (counters is Map && !counters.containsKey(ProfileCounterKeys.gold)) {
        counters[ProfileCounterKeys.gold] = 0;
        didChange = true;
      }
    }

    return _MigrationResult(data, didChange);
  }

  String _generateProfileId(int nowMs) {
    final stamp = nowMs.toRadixString(36);
    final suffix = _random.nextInt(1 << 31).toRadixString(36);
    return 'guest_${stamp}_$suffix';
  }

  void _logWarning(String message, {Object? error, StackTrace? stackTrace}) {
    developer.log(
      message,
      name: 'UserProfileStore',
      error: error,
      stackTrace: stackTrace,
    );
  }

  int? _readInt(Object? raw) {
    if (raw is int) return raw;
    if (raw is num) return raw.toInt();
    return null;
  }
}

class _MigrationResult {
  const _MigrationResult(this.data, this.didChange);

  final Map<String, dynamic> data;
  final bool didChange;
}


===== FILE: lib/ui/text/ability_tag_resolver.dart =====
import '../../core/abilities/ability_def.dart';
import '../../core/combat/status/status.dart';

/// Coarse UI-facing tags derived from [AbilityDef] mechanics.
///
/// These are intentionally semantic and stable for badges/filters.
enum AbilityUiTag {
  damage,
  defense,
  dash,
  jump,
  hold,
  utility,
  crowdControl,
  charged,
  autoTarget,
  aimed,
}

/// Resolves coarse semantic tags from ability mechanics.
class AbilityTagResolver {
  const AbilityTagResolver({
    StatusProfileCatalog statusProfiles = const StatusProfileCatalog(),
  }) : _statusProfiles = statusProfiles;

  final StatusProfileCatalog _statusProfiles;

  Set<AbilityUiTag> resolve(AbilityDef def) {
    final tags = <AbilityUiTag>{};
    _addRoleTag(tags, def);
    _addStatusTags(tags, def);
    _addMechanicTags(tags, def);
    return Set<AbilityUiTag>.unmodifiable(tags);
  }

  void _addRoleTag(Set<AbilityUiTag> tags, AbilityDef def) {
    switch (def.category) {
      case AbilityCategory.melee:
      case AbilityCategory.ranged:
        tags.add(AbilityUiTag.damage);
      case AbilityCategory.defense:
        tags.add(AbilityUiTag.defense);
      case AbilityCategory.mobility:
        if (def.allowedSlots.contains(AbilitySlot.mobility)) {
          tags.add(AbilityUiTag.dash);
        }
        if (def.allowedSlots.contains(AbilitySlot.jump)) {
          tags.add(AbilityUiTag.jump);
        }
      case AbilityCategory.utility:
        tags.add(AbilityUiTag.utility);
    }
  }

  void _addStatusTags(Set<AbilityUiTag> tags, AbilityDef def) {
    final profileIds = _collectProfileIds(def);
    for (final id in profileIds) {
      final status = _statusProfiles.get(id);
      for (final application in status.applications) {
        if (_isCrowdControlType(application.type)) {
          tags.add(AbilityUiTag.crowdControl);
        }
      }
    }
  }

  bool _isCrowdControlType(StatusEffectType type) {
    switch (type) {
      case StatusEffectType.stun:
      case StatusEffectType.slow:
      case StatusEffectType.silence:
      case StatusEffectType.drench:
        return true;
      case StatusEffectType.dot:
      case StatusEffectType.haste:
      case StatusEffectType.vulnerable:
      case StatusEffectType.weaken:
      case StatusEffectType.resourceOverTime:
        return false;
    }
  }

  Set<StatusProfileId> _collectProfileIds(AbilityDef def) {
    final profileIds = <StatusProfileId>{};
    if (def.selfStatusProfileId != StatusProfileId.none) {
      profileIds.add(def.selfStatusProfileId);
    }
    if (def.mobilityImpact.statusProfileId != StatusProfileId.none) {
      profileIds.add(def.mobilityImpact.statusProfileId);
    }
    for (final proc in def.procs) {
      if (proc.statusProfileId != StatusProfileId.none) {
        profileIds.add(proc.statusProfileId);
      }
    }
    return profileIds;
  }

  void _addMechanicTags(Set<AbilityUiTag> tags, AbilityDef def) {
    if (def.chargeProfile != null) {
      tags.add(AbilityUiTag.charged);
    }

    if (def.holdMode == AbilityHoldMode.holdToMaintain ||
        def.inputLifecycle == AbilityInputLifecycle.holdMaintain) {
      tags.add(AbilityUiTag.hold);
    }

    if (def.targetingModel == TargetingModel.homing) {
      tags.add(AbilityUiTag.autoTarget);
    } else if (_isAimedAbility(def)) {
      tags.add(AbilityUiTag.aimed);
    }
  }

  bool _isAimedAbility(AbilityDef def) {
    if (def.inputLifecycle == AbilityInputLifecycle.holdRelease) return true;
    switch (def.targetingModel) {
      case TargetingModel.aimed:
      case TargetingModel.aimedLine:
      case TargetingModel.aimedCharge:
      case TargetingModel.groundTarget:
        return true;
      case TargetingModel.none:
      case TargetingModel.directional:
      case TargetingModel.homing:
        return false;
    }
  }
}


===== FILE: lib/ui/text/ability_text.dart =====
import '../../core/abilities/ability_def.dart';

/// User-facing display name for an [AbilityKey].
///
/// Kept in one place so call sites can later move to localization keys without
/// changing widget logic.
String abilityDisplayName(AbilityKey id) {
  final override = _displayNameOverrides[id];
  if (override != null) return override;
  final dot = id.indexOf('.');
  final raw = dot >= 0 ? id.substring(dot + 1) : id;
  return _titleCaseSnake(raw);
}

String _titleCaseSnake(String source) {
  final words = source.split('_');
  return words
      .where((word) => word.isNotEmpty)
      .map((word) => '${word[0].toUpperCase()}${word.substring(1)}')
      .join(' ');
}

const Map<AbilityKey, String> _displayNameOverrides = <AbilityKey, String>{
  // Primary: sword arts.
  'eloise.bloodletter_slash': 'Bloodletter Slash',
  'eloise.bloodletter_cleave': 'Bloodletter Cleave',
  'eloise.seeker_slash': 'Seeker Slash',
  'eloise.riposte_guard': 'Riposte Guard',

  // Secondary: shield arts.
  'eloise.concussive_bash': 'Concussive Bash',
  'eloise.concussive_breaker': 'Concussive Breaker',
  'eloise.seeker_bash': 'Seeker Bash',
  'eloise.aegis_riposte': 'Aegis Riposte',
  'eloise.shield_block': 'Shield block',

  // Projectile: ranged attacks.
  'eloise.snap_shot': 'Snap Shot',
  'eloise.quick_shot': 'Quick Shot',
  'eloise.skewer_shot': 'Skewer Shot',
  'eloise.overcharge_shot': 'Overcharge Bolt',

  // Spell: utility and sustain.
  'eloise.arcane_haste': 'Arcane Haste',
  'eloise.vital_surge': 'Vital Surge',
  'eloise.mana_infusion': 'Mana Infusion',
  'eloise.second_wind': 'Second Wind',

  // Mobility.
  'eloise.jump': 'Jump',
  'eloise.double_jump': 'Double Jump',
  'eloise.dash': 'Dash',
  'eloise.roll': 'Concussive Roll',
};


===== FILE: lib/ui/text/ability_tooltip_builder.dart =====
import '../../core/abilities/ability_def.dart';
import '../../core/combat/middleware/parry_middleware.dart';
import '../../core/combat/status/status.dart';
import '../../core/projectiles/projectile_id.dart';
import 'ability_tag_resolver.dart';
import 'ability_text.dart';
import 'gear_text.dart';

class AbilityCostLine {
  const AbilityCostLine({required this.label, required this.value});

  final String label;
  final String value;
}

class AbilityTooltipContext {
  const AbilityTooltipContext({
    this.activeProjectileId,
    this.payloadWeaponType,
  });

  /// The projectile that will actually be fired — either a spell projectile
  /// (e.g. Fire Bolt) or a physical throwing weapon (e.g. Throwing Knife).
  final ProjectileId? activeProjectileId;
  final WeaponType? payloadWeaponType;
}

class AbilityTooltip {
  const AbilityTooltip({
    required this.title,
    required this.description,
    this.dynamicDescriptionValues = const <String>[],
    this.badges = const <String>[],
    this.tags = const <AbilityUiTag>{},
    this.cooldownSeconds,
    this.maxDurationSeconds,
    this.costLines = const <AbilityCostLine>[],
  });

  final String title;
  final String description;
  final List<String> dynamicDescriptionValues;
  final List<String> badges;
  final Set<AbilityUiTag> tags;
  final double? cooldownSeconds;
  final double? maxDurationSeconds;
  final List<AbilityCostLine> costLines;
}

abstract interface class AbilityTooltipBuilder {
  AbilityTooltip build(
    AbilityDef def, {
    AbilityTooltipContext ctx = const AbilityTooltipContext(),
  });
}

class DefaultAbilityTooltipBuilder implements AbilityTooltipBuilder {
  static const double _authoredTicksPerSecond = 60.0;
  static const String _templateMeleeDot =
      '{action} that deals {damage} damage to {targets}. '
      'It causes {status}, dealing {dotDamage} damage per second for {dotDuration} seconds.';
  static const String _templateMeleeControl =
      '{action} that deals {damage} damage to {targets}. '
      'It causes {status} for {duration} seconds.';
  static const String _templateChargedBonus =
      ' Charging increases damage (up to +{damageBonus}%) '
      'and critical chance (up to +{critBonus}%).';
  static const String _templateInterruptible =
      ' This attack can be interrupted by taking damage.';
  static const String _templateGuard =
      'Keep your guard up and reduce incoming damage by {reduction}% while held.';
  static const String _templateRiposteGrant =
      ' Guarded hits grant {riposte}, empowering your next melee hit by +{riposteBonus}% damage.';
  static const String _templateSelfStatus =
      'Grant {status} for {duration} seconds.';
  static const String _templateSnapShot =
      'Fire {projectileSource}{projectileName}, it deals {damage} damage to the closest enemy.';
  static const String _templateQuickShot =
      'Aim and fire {projectileSource}{projectileName}. It deals {damage} damage to a single target.';
  static const String _templateOverchargeShot =
      'Charge and release {projectileSource}{projectileName}. '
      'It deals {damage} damage to a single target.';
  static const String _templateSkewerShot =
      'Fire {projectileSource}{projectileName}, piercing through enemies in its path. '
      'It deals {damage} damage and can hit up to {maxHits} enemies.';
  static const String _riposteLabel = 'Riposte';
  static const String _targetClosestAndReach =
      'the closest enemy and all those who are in the attack reach';
  static const String _targetAimingDirectionAndReach =
      'enemies in aiming direction and in the attack reach';

  const DefaultAbilityTooltipBuilder({
    AbilityTagResolver tagResolver = const AbilityTagResolver(),
    StatusProfileCatalog statusProfiles = const StatusProfileCatalog(),
  }) : _tagResolver = tagResolver,
       _statusProfiles = statusProfiles;

  final AbilityTagResolver _tagResolver;
  final StatusProfileCatalog _statusProfiles;

  @override
  AbilityTooltip build(
    AbilityDef def, {
    AbilityTooltipContext ctx = const AbilityTooltipContext(),
  }) {
    final tags = _tagResolver.resolve(def);
    final badges = _buildBadges(tags);
    final descriptionWithHighlights = _descriptionWithHighlights(def, ctx);
    return AbilityTooltip(
      title: abilityDisplayName(def.id),
      description: descriptionWithHighlights.description,
      dynamicDescriptionValues: List<String>.unmodifiable(
        descriptionWithHighlights.dynamicValues,
      ),
      badges: List<String>.unmodifiable(badges),
      tags: tags,
      cooldownSeconds: _cooldownSeconds(def),
      maxDurationSeconds: _maxDurationSeconds(def),
      costLines: List<AbilityCostLine>.unmodifiable(_costLines(def, ctx)),
    );
  }

  _DescriptionWithHighlights _descriptionWithHighlights(
    AbilityDef def,
    AbilityTooltipContext ctx,
  ) {
    if (def.selfStatusProfileId != StatusProfileId.none) {
      return _selfStatusDescription(def);
    }
    switch (def.id) {
      case 'eloise.bloodletter_slash':
        return _bloodletterSlashDescription(def);
      case 'eloise.seeker_slash':
        return _seekerSlashDescription(def);
      case 'eloise.bloodletter_cleave':
        return _bloodletterCleaveDescription(def);
      case 'eloise.seeker_bash':
        return _seekerBashDescription(def);
      case 'eloise.concussive_bash':
        return _concussiveBashDescription(def);
      case 'eloise.concussive_breaker':
        return _concussiveBreakerDescription(def);
      case 'eloise.snap_shot':
        return _snapShotDescription(def, ctx);
      case 'eloise.quick_shot':
        return _quickShotDescription(def, ctx);
      case 'eloise.overcharge_shot':
        return _overchargeShotDescription(def, ctx);
      case 'eloise.skewer_shot':
        return _skewerShotDescription(def, ctx);
      case 'eloise.dash':
        return _dashDescription(def);
      case 'eloise.roll':
        return _concussiveRollDescription(def);
      case 'eloise.riposte_guard':
      case 'eloise.aegis_riposte':
      case 'eloise.shield_block':
        return _guardDescription(def);
      default:
        return _DescriptionWithHighlights(
          description: _notBuildDescription(def, ctx),
        );
    }
  }

  double? _cooldownSeconds(AbilityDef def) {
    if (def.cooldownTicks <= 0) return null;
    return def.cooldownTicks / _authoredTicksPerSecond;
  }

  double? _maxDurationSeconds(AbilityDef def) {
    if (def.holdMode != AbilityHoldMode.holdToMaintain) return null;
    if (def.activeTicks <= 0) return null;
    return def.activeTicks / _authoredTicksPerSecond;
  }

  List<AbilityCostLine> _costLines(AbilityDef def, AbilityTooltipContext ctx) {
    if (def.allowedSlots.contains(AbilitySlot.jump) && def.maxAirJumps > 0) {
      final lines = <AbilityCostLine>[];
      final firstJump = _formatCostValue(
        def.resolveCostForWeaponType(ctx.payloadWeaponType),
      );
      if (firstJump != null) {
        lines.add(
          AbilityCostLine(label: 'Cost for first jump: ', value: firstJump),
        );
      }
      final secondJump = _formatCostValue(def.airJumpCost);
      if (secondJump != null) {
        lines.add(
          AbilityCostLine(label: 'Cost for second jump: ', value: secondJump),
        );
      }
      return lines;
    }

    final lines = <AbilityCostLine>[];
    if (def.holdMode == AbilityHoldMode.holdToMaintain &&
        def.holdStaminaDrainPerSecond100 > 0) {
      lines.add(
        AbilityCostLine(
          label: 'Cost per second: ',
          value: '${formatFixed100(def.holdStaminaDrainPerSecond100)} Stamina',
        ),
      );
    }

    final regular = _formatCostValue(
      def.resolveCostForWeaponType(ctx.payloadWeaponType),
    );
    if (regular != null) {
      lines.add(AbilityCostLine(label: 'Cost: ', value: regular));
    }
    return lines;
  }

  String? _formatCostValue(AbilityResourceCost cost) {
    final parts = <String>[];
    if (cost.healthCost100 > 0) {
      parts.add('${formatFixed100(cost.healthCost100)} Health');
    }
    if (cost.staminaCost100 > 0) {
      parts.add('${formatFixed100(cost.staminaCost100)} Stamina');
    }
    if (cost.manaCost100 > 0) {
      parts.add('${formatFixed100(cost.manaCost100)} Mana');
    }
    if (parts.isEmpty) return null;
    return parts.join(' / ');
  }

  List<String> _buildBadges(Set<AbilityUiTag> tags) {
    final badges = <String>[];

    void addBadge(String value) {
      if (!badges.contains(value)) badges.add(value);
    }

    for (final tag in AbilityUiTag.values) {
      if (!tags.contains(tag)) continue;
      final label = _badgeLabel(tag);
      if (label != null) addBadge(label);
    }

    return badges;
  }

  String _notBuildDescription(AbilityDef def, AbilityTooltipContext ctx) {
    switch (def.id) {
      case 'common.enemy_strike':
        return 'Tap to strike in front of you.';
      case 'common.enemy_cast':
        return 'Hold then release to cast a ranged bolt.';
      case 'eloise.jump':
        return 'Tap to jump.';
      case 'eloise.double_jump':
        return 'Tap to jump, then tap again in the air for a second jump.';
      default:
        return 'Tap to use this ability.';
    }
  }

  _DescriptionWithHighlights _seekerSlashDescription(AbilityDef def) {
    final damage = formatFixed100(def.baseDamage);
    final dot = _firstDotEffect(def);
    return _buildMeleeDotDescription(
      action: 'Launch an attack',
      damage: damage,
      targets: _targetClosestAndReach,
      dot: dot,
    );
  }

  _DescriptionWithHighlights _bloodletterSlashDescription(AbilityDef def) {
    final damage = formatFixed100(def.baseDamage);
    final dot = _firstDotEffect(def);
    return _buildMeleeDotDescription(
      action: 'Unleash a sword slash',
      damage: damage,
      targets: _targetAimingDirectionAndReach,
      dot: dot,
    );
  }

  _DescriptionWithHighlights _bloodletterCleaveDescription(AbilityDef def) {
    final damage = formatFixed100(def.baseDamage);
    final dot = _firstDotEffect(def);
    final charge = _maxChargeBonuses(def);
    final damageBonus = _formatDecimal(charge.damageBonusBp / 100.0);
    final critBonus = _formatDecimal(charge.critBonusBp / 100.0);

    return _buildMeleeDotDescription(
      action: 'Unleash a powerful cleaving attack',
      damage: damage,
      targets: _targetAimingDirectionAndReach,
      dot: dot,
      damageBonus: damageBonus,
      critBonus: critBonus,
      includeInterruptibleLine: true,
    );
  }

  _DescriptionWithHighlights _seekerBashDescription(AbilityDef def) {
    final damage = formatFixed100(def.baseDamage);
    final control = _firstControlEffect(def);
    return _descriptionFromTemplate(
      template: _templateMeleeControl,
      values: <String, String>{
        'action': 'Strike with a shield bash',
        'damage': damage,
        'targets': _targetClosestAndReach,
        'status': control.name,
        'duration': _formatDecimal(control.durationSeconds),
      },
      dynamicKeys: <String>['damage', 'status', 'duration'],
    );
  }

  _DescriptionWithHighlights _concussiveBashDescription(AbilityDef def) {
    final damage = formatFixed100(def.baseDamage);
    final control = _firstControlEffect(def);
    return _descriptionFromTemplate(
      template: _templateMeleeControl,
      values: <String, String>{
        'action': 'Perform a shield bash',
        'damage': damage,
        'targets': _targetAimingDirectionAndReach,
        'status': control.name,
        'duration': _formatDecimal(control.durationSeconds),
      },
      dynamicKeys: <String>['damage', 'status', 'duration'],
    );
  }

  _DescriptionWithHighlights _concussiveBreakerDescription(AbilityDef def) {
    final damage = formatFixed100(def.baseDamage);
    final control = _firstControlEffect(def);
    final charge = _maxChargeBonuses(def);
    final damageBonus = _formatDecimal(charge.damageBonusBp / 100.0);
    final critBonus = _formatDecimal(charge.critBonusBp / 100.0);

    return _descriptionFromTemplate(
      template: _templateMeleeControl + _templateChargedBonus + _templateInterruptible,
      values: <String, String>{
        'action': 'Launch a heavy shield breaker',
        'damage': damage,
        'targets': _targetAimingDirectionAndReach,
        'status': control.name,
        'duration': _formatDecimal(control.durationSeconds),
        'damageBonus': damageBonus,
        'critBonus': critBonus,
      },
      dynamicKeys: <String>[
        'damage',
        'status',
        'duration',
        'damageBonus',
        'critBonus',
      ],
    );
  }

  _DescriptionWithHighlights _snapShotDescription(
    AbilityDef def,
    AbilityTooltipContext ctx,
  ) {
    return _descriptionFromTemplate(
      template: _templateSnapShot,
      values: <String, String>{
        'projectileSource': _projectileSourceLabel(ctx),
        'projectileName': _projectileName(ctx),
        'damage': formatFixed100(def.baseDamage),
      },
      dynamicKeys: <String>['projectileName', 'damage'],
    );
  }

  _DescriptionWithHighlights _quickShotDescription(
    AbilityDef def,
    AbilityTooltipContext ctx,
  ) {
    return _descriptionFromTemplate(
      template: _templateQuickShot,
      values: <String, String>{
        'projectileSource': _projectileSourceLabel(ctx),
        'projectileName': _projectileName(ctx),
        'damage': formatFixed100(def.baseDamage),
      },
      dynamicKeys: <String>['projectileName', 'damage'],
    );
  }

  _DescriptionWithHighlights _overchargeShotDescription(
    AbilityDef def,
    AbilityTooltipContext ctx,
  ) {
    final charge = _maxChargeBonuses(def);
    final damageBonus = _formatDecimal(charge.damageBonusBp / 100.0);
    final critBonus = _formatDecimal(charge.critBonusBp / 100.0);

    return _descriptionFromTemplate(
      template:
          _templateOverchargeShot + _templateChargedBonus + _templateInterruptible,
      values: <String, String>{
        'projectileSource': _projectileSourceLabel(ctx),
        'projectileName': _projectileName(ctx),
        'damage': formatFixed100(def.baseDamage),
        'damageBonus': damageBonus,
        'critBonus': critBonus,
      },
      dynamicKeys: <String>[
        'projectileName',
        'damage',
        'damageBonus',
        'critBonus',
      ],
    );
  }

  _DescriptionWithHighlights _skewerShotDescription(
    AbilityDef def,
    AbilityTooltipContext ctx,
  ) {
    final hitDelivery = def.hitDelivery;
    final maxHits = hitDelivery is ProjectileHitDelivery
        ? hitDelivery.chainCount.toString()
        : '?';
    return _descriptionFromTemplate(
      template: _templateSkewerShot,
      values: <String, String>{
        'projectileSource': _projectileSourceLabel(ctx),
        'projectileName': _projectileName(ctx),
        'damage': formatFixed100(def.baseDamage),
        'maxHits': maxHits,
      },
      dynamicKeys: <String>['projectileName', 'damage', 'maxHits'],
    );
  }

  _DescriptionWithHighlights _dashDescription(AbilityDef def) {
    return const _DescriptionWithHighlights(description: 'Dash forward quickly.');
  }

  _DescriptionWithHighlights _concussiveRollDescription(AbilityDef def) {
    final control = _mobilityControlEffect(def);
    return _descriptionFromTemplate(
      template: 'Perform a concussive roll. Enemies hit are affected by {status}.',
      values: <String, String>{
        'status': control.name,
      },
      dynamicKeys: <String>['status'],
    );
  }

  _DescriptionWithHighlights _selfStatusDescription(AbilityDef def) {
    final profile = _statusProfiles.get(def.selfStatusProfileId);
    final application = profile.applications.first;
    final statusLabel = _selfStatusLabel(application);
    final duration = _formatOneDecimal(application.durationSeconds);
    return _descriptionFromTemplate(
      template: _templateSelfStatus,
      values: <String, String>{
        'status': statusLabel,
        'duration': duration,
      },
      dynamicKeys: <String>['status', 'duration'],
    );
  }

  _DescriptionWithHighlights _buildMeleeDotDescription({
    required String action,
    required String damage,
    required String targets,
    required _StatusDotSummary dot,
    String? damageBonus,
    String? critBonus,
    bool includeInterruptibleLine = false,
  }) {
    final values = <String, String>{
      'action': action,
      'damage': damage,
      'targets': targets,
      'status': dot.name,
      'dotDamage': formatFixed100(dot.damage100),
      'dotDuration': _formatDecimal(dot.durationSeconds),
      if (damageBonus != null) 'damageBonus': damageBonus,
      if (critBonus != null) 'critBonus': critBonus,
    };

    var template = _templateMeleeDot;
    final dynamicKeys = <String>[
      'damage',
      'status',
      'dotDamage',
      'dotDuration',
    ];

    if (damageBonus != null && critBonus != null) {
      template += _templateChargedBonus;
      dynamicKeys
        ..add('damageBonus')
        ..add('critBonus');
    }
    if (includeInterruptibleLine) {
      template += _templateInterruptible;
    }

    return _descriptionFromTemplate(
      template: template,
      values: values,
      dynamicKeys: dynamicKeys,
    );
  }

  _DescriptionWithHighlights _guardDescription(AbilityDef def) {
    final reduction = _formatDecimal(def.damageIgnoredBp / 100.0);
    final riposteBonus = _formatDecimal(
      ParryMiddleware.defaultRiposteBonusBp / 100.0,
    );
    final values = <String, String>{
      'reduction': reduction,
      if (def.grantsRiposteOnGuardedHit) 'riposte': _riposteLabel,
      if (def.grantsRiposteOnGuardedHit) 'riposteBonus': riposteBonus,
    };
    var template = _templateGuard;
    final dynamicKeys = <String>['reduction'];
    if (def.grantsRiposteOnGuardedHit) {
      template += _templateRiposteGrant;
      dynamicKeys
        ..add('riposte')
        ..add('riposteBonus');
    }
    return _descriptionFromTemplate(
      template: template,
      values: values,
      dynamicKeys: dynamicKeys,
    );
  }

  _DescriptionWithHighlights _descriptionFromTemplate({
    required String template,
    required Map<String, String> values,
    required List<String> dynamicKeys,
  }) {
    var description = template;
    for (final entry in values.entries) {
      description = description.replaceAll('{${entry.key}}', entry.value);
    }
    final dynamicValues = _orderedUniqueNonEmpty(<String>[
      for (final key in dynamicKeys) values[key] ?? '',
    ]);
    return _DescriptionWithHighlights(
      description: description,
      dynamicValues: dynamicValues,
    );
  }

  _StatusDotSummary _firstDotEffect(AbilityDef def) {
    for (final proc in def.procs) {
      if (proc.statusProfileId == StatusProfileId.none) continue;
      final profile = _statusProfiles.get(proc.statusProfileId);
      for (final application in profile.applications) {
        if (application.type != StatusEffectType.dot) continue;
        return _StatusDotSummary(
          name: _statusDisplayName(proc.statusProfileId),
          damage100: application.magnitude,
          durationSeconds: application.durationSeconds,
        );
      }
    }
    return const _StatusDotSummary.none();
  }

  _StatusControlSummary _firstControlEffect(AbilityDef def) {
    for (final proc in def.procs) {
      if (proc.statusProfileId == StatusProfileId.none) continue;
      final profile = _statusProfiles.get(proc.statusProfileId);
      for (final application in profile.applications) {
        switch (application.type) {
          case StatusEffectType.stun:
          case StatusEffectType.slow:
          case StatusEffectType.silence:
          case StatusEffectType.weaken:
          case StatusEffectType.vulnerable:
          case StatusEffectType.drench:
            return _StatusControlSummary(
              name: _statusDisplayName(proc.statusProfileId),
              durationSeconds: application.durationSeconds,
            );
          case StatusEffectType.dot:
          case StatusEffectType.haste:
          case StatusEffectType.resourceOverTime:
            continue;
        }
      }
    }
    return const _StatusControlSummary.none();
  }

  _StatusControlSummary _mobilityControlEffect(AbilityDef def) {
    final profileId = def.mobilityImpact.statusProfileId;
    if (profileId == StatusProfileId.none) {
      return const _StatusControlSummary.none();
    }
    final profile = _statusProfiles.get(profileId);
    for (final application in profile.applications) {
      switch (application.type) {
        case StatusEffectType.stun:
        case StatusEffectType.slow:
        case StatusEffectType.silence:
        case StatusEffectType.weaken:
        case StatusEffectType.vulnerable:
        case StatusEffectType.drench:
          return _StatusControlSummary(
            name: _statusDisplayName(profileId),
            durationSeconds: application.durationSeconds,
          );
        case StatusEffectType.dot:
        case StatusEffectType.haste:
        case StatusEffectType.resourceOverTime:
          continue;
      }
    }
    return const _StatusControlSummary.none();
  }

  _ChargeBonusSummary _maxChargeBonuses(AbilityDef def) {
    final tiers = def.chargeProfile?.tiers;
    if (tiers == null || tiers.isEmpty) {
      return const _ChargeBonusSummary.none();
    }

    var maxDamageScaleBp = tiers.first.damageScaleBp;
    var maxCritBonusBp = tiers.first.critBonusBp;
    for (final tier in tiers.skip(1)) {
      if (tier.damageScaleBp > maxDamageScaleBp) {
        maxDamageScaleBp = tier.damageScaleBp;
      }
      if (tier.critBonusBp > maxCritBonusBp) {
        maxCritBonusBp = tier.critBonusBp;
      }
    }

    final damageBonusBp = maxDamageScaleBp > 10000
        ? maxDamageScaleBp - 10000
        : 0;
    final critBonusBp = maxCritBonusBp > 0 ? maxCritBonusBp : 0;
    return _ChargeBonusSummary(
      damageBonusBp: damageBonusBp,
      critBonusBp: critBonusBp,
    );
  }

  String _statusDisplayName(StatusProfileId id) {
    switch (id) {
      case StatusProfileId.meleeBleed:
        return 'Bleed';
      case StatusProfileId.burnOnHit:
        return 'Burn';
      case StatusProfileId.acidOnHit:
        return 'Acid';
      case StatusProfileId.stunOnHit:
        return 'Stun';
      default:
        return 'damage over time';
    }
  }

  String _projectileSourceLabel(AbilityTooltipContext ctx) {
    return ctx.payloadWeaponType == WeaponType.projectileSpell
        ? 'the selected spell projectile'
        : 'your equipped projectile';
  }

  String _projectileName(AbilityTooltipContext ctx) {
    final activeProjectileId = ctx.activeProjectileId;
    if (activeProjectileId == null) return '';
    return ' (${projectileDisplayName(activeProjectileId)})';
  }

  String _selfStatusLabel(StatusApplication application) {
    switch (application.type) {
      case StatusEffectType.haste:
        return 'Haste';
      case StatusEffectType.resourceOverTime:
        switch (application.resourceType) {
          case StatusResourceType.health:
            return 'Health Regeneration';
          case StatusResourceType.mana:
            return 'Mana Regeneration';
          case StatusResourceType.stamina:
            return 'Stamina Regeneration';
          case null:
            return 'Resource Regeneration';
        }
      case StatusEffectType.dot:
      case StatusEffectType.slow:
      case StatusEffectType.stun:
      case StatusEffectType.vulnerable:
      case StatusEffectType.weaken:
      case StatusEffectType.drench:
      case StatusEffectType.silence:
        return 'Status Effect';
    }
  }

  String _formatOneDecimal(double value) {
    return value.toStringAsFixed(1);
  }

  String _formatDecimal(double value) {
    final text = value.toStringAsFixed(2);
    return text.replaceFirst(RegExp(r'\.?0+$'), '');
  }

  List<String> _orderedUniqueNonEmpty(List<String> values) {
    final seen = <String>{};
    final result = <String>[];
    for (final value in values) {
      if (value.isEmpty || !seen.add(value)) continue;
      result.add(value);
    }
    return result;
  }

  String? _badgeLabel(AbilityUiTag tag) {
    switch (tag) {
      case AbilityUiTag.damage:
        return 'DAMAGE';
      case AbilityUiTag.defense:
        return 'DEFENSE';
      case AbilityUiTag.dash:
        return 'DASH';
      case AbilityUiTag.jump:
        return 'JUMP';
      case AbilityUiTag.hold:
        return 'HOLD';
      case AbilityUiTag.utility:
        return 'UTILITY';
      case AbilityUiTag.crowdControl:
        return 'CONTROL';
      case AbilityUiTag.charged:
        return 'CHARGED';
      case AbilityUiTag.autoTarget:
        return 'AUTO-AIM';
      case AbilityUiTag.aimed:
        return 'AIM';
    }
  }
}

class _StatusDotSummary {
  const _StatusDotSummary({
    required this.name,
    required this.damage100,
    required this.durationSeconds,
  });

  const _StatusDotSummary.none()
    : name = 'damage over time',
      damage100 = 0,
      durationSeconds = 0;

  final String name;
  final int damage100;
  final double durationSeconds;
}

class _StatusControlSummary {
  const _StatusControlSummary({
    required this.name,
    required this.durationSeconds,
  });

  const _StatusControlSummary.none() : name = 'Control', durationSeconds = 0;

  final String name;
  final double durationSeconds;
}

class _ChargeBonusSummary {
  const _ChargeBonusSummary({
    required this.damageBonusBp,
    required this.critBonusBp,
  });

  const _ChargeBonusSummary.none() : damageBonusBp = 0, critBonusBp = 0;

  final int damageBonusBp;
  final int critBonusBp;
}

class _DescriptionWithHighlights {
  const _DescriptionWithHighlights({
    required this.description,
    this.dynamicValues = const <String>[],
  });

  final String description;
  final List<String> dynamicValues;
}


===== FILE: lib/ui/text/gear_text.dart =====
import '../../core/accessories/accessory_id.dart';
import '../../core/combat/damage_type.dart';
import '../../core/combat/status/status.dart';
import '../../core/meta/gear_slot.dart';
import '../../core/projectiles/projectile_id.dart';
import '../../core/projectiles/projectile_item_def.dart';
import '../../core/spellBook/spell_book_id.dart';
import '../../core/weapons/weapon_id.dart';
import '../../core/weapons/weapon_proc.dart';

/// User-facing display name for a [WeaponId].
String weaponDisplayName(WeaponId id) {
  return _weaponDisplayNameOverrides[id] ?? _titleCaseEnum(id.name);
}

/// User-facing short description for a [WeaponId].
String weaponDescription(WeaponId id) {
  return _weaponDescriptionOverrides[id] ?? _defaultDescription;
}

/// User-facing display name for a [ProjectileId].
///
/// Shared by gear picker and projectile source picker.
String projectileDisplayName(ProjectileId id) {
  return _projectileDisplayNameOverrides[id] ?? _titleCaseEnum(id.name);
}

/// User-facing short description for a [ProjectileId].
String projectileDescription(ProjectileId id) {
  return _projectileDescriptionOverrides[id] ?? _defaultDescription;
}

/// User-facing display name for a [DamageType].
String damageTypeDisplayName(DamageType type) {
  return switch (type) {
    DamageType.physical => 'Physical',
    DamageType.fire => 'Fire',
    DamageType.ice => 'Ice',
    DamageType.water => 'Water',
    DamageType.thunder => 'Thunder',
    DamageType.acid => 'Acid',
    DamageType.dark => 'Dark',
    DamageType.bleed => 'Bleed',
    DamageType.earth => 'Earth',
    DamageType.holy => 'Holy',
  };
}

/// Returns detailed status effect summaries for a projectile's on-hit procs.
///
/// Each entry is a human-readable line with the effect name and numbers,
/// e.g. "Burn: 5 fire damage/s for 5s" or "Stun: 1s".
List<String> projectileStatusSummaries(
  ProjectileItemDef def, {
  StatusProfileCatalog statusProfiles = const StatusProfileCatalog(),
}) {
  final lines = <String>[];
  for (final proc in def.procs) {
    if (proc.statusProfileId == StatusProfileId.none) continue;
    final profile = statusProfiles.get(proc.statusProfileId);
    for (final app in profile.applications) {
      final line = _statusApplicationSummary(app, proc);
      if (line != null) lines.add(line);
    }
  }
  return lines;
}

String? _statusApplicationSummary(StatusApplication app, WeaponProc proc) {
  final duration = _formatDuration(app.durationSeconds);
  final chance = proc.chanceBp < 10000
      ? ' (${_formatBp(proc.chanceBp)}% chance)'
      : '';

  switch (app.type) {
    case StatusEffectType.dot:
      final dps = formatFixed100(app.magnitude);
      final dmgType = app.dotDamageType != null
          ? damageTypeDisplayName(app.dotDamageType!)
          : 'DoT';
      return '$dmgType: $dps damage per second for $duration$chance';
    case StatusEffectType.slow:
      return 'Slow: -${_formatBp(app.magnitude)}% speed for $duration$chance';
    case StatusEffectType.stun:
      return 'Stun: $duration$chance';
    case StatusEffectType.silence:
      return 'Silence: $duration$chance';
    case StatusEffectType.vulnerable:
      return 'Vulnerable: +${_formatBp(app.magnitude)}% damage taken for $duration$chance';
    case StatusEffectType.weaken:
      return 'Weaken: -${_formatBp(app.magnitude)}% outgoing damage for $duration$chance';
    case StatusEffectType.drench:
      return 'Drench: -${_formatBp(app.magnitude)}% attack/cast speed for $duration$chance';
    case StatusEffectType.haste:
    case StatusEffectType.resourceOverTime:
      return null;
  }
}

String _formatDuration(double seconds) {
  final text = seconds.toStringAsFixed(1);
  final value = text.replaceFirst(RegExp(r'\.0$'), '');
  return value == '1' ? '$value second' : '$value seconds';
}

String _formatBp(int bp) {
  final percent = bp / 100.0;
  final text = percent.toStringAsFixed(1);
  return text.replaceFirst(RegExp(r'\.0$'), '');
}

/// Formats a fixed-point ×100 integer as a minimal decimal string (e.g. 1500 → "15").
String formatFixed100(int value100) {
  final value = (value100 / 100.0).toStringAsFixed(2);
  return value.replaceFirst(RegExp(r'\.?0+$'), '');
}

/// User-facing display name for a [SpellBookId].
String spellBookDisplayName(SpellBookId id) {
  return _spellBookDisplayNameOverrides[id] ?? _titleCaseEnum(id.name);
}

/// User-facing short description for a [SpellBookId].
String spellBookDescription(SpellBookId id) {
  return _spellBookDescriptionOverrides[id] ?? _defaultDescription;
}

/// User-facing display name for an [AccessoryId].
String accessoryDisplayName(AccessoryId id) {
  return _accessoryDisplayNameOverrides[id] ?? _titleCaseEnum(id.name);
}

/// User-facing short description for an [AccessoryId].
String accessoryDescription(AccessoryId id) {
  return _accessoryDescriptionOverrides[id] ?? _defaultDescription;
}

/// Returns the display text for a gear item shown in UI.
///
/// This is intentionally centralized so call sites can later move to
/// localization keys without rewriting widget logic.
String gearDisplayNameForSlot(GearSlot slot, Object id) {
  return switch (slot) {
    GearSlot.mainWeapon ||
    GearSlot.offhandWeapon => weaponDisplayName(id as WeaponId),
    GearSlot.throwingWeapon => projectileDisplayName(id as ProjectileId),
    GearSlot.spellBook => spellBookDisplayName(id as SpellBookId),
    GearSlot.accessory => accessoryDisplayName(id as AccessoryId),
  };
}

/// Returns a short description for a gear item shown in UI.
String gearDescriptionForSlot(GearSlot slot, Object id) {
  return switch (slot) {
    GearSlot.mainWeapon ||
    GearSlot.offhandWeapon => weaponDescription(id as WeaponId),
    GearSlot.throwingWeapon => projectileDescription(id as ProjectileId),
    GearSlot.spellBook => spellBookDescription(id as SpellBookId),
    GearSlot.accessory => accessoryDescription(id as AccessoryId),
  };
}

String _titleCaseEnum(String source) {
  final normalized = source
      .replaceAll('_', ' ')
      .replaceAllMapped(
        RegExp(r'([a-z0-9])([A-Z])'),
        (match) => '${match.group(1)} ${match.group(2)}',
      );
  final words = normalized.split(RegExp(r'\s+'));
  return words
      .where((word) => word.isNotEmpty)
      .map((word) => '${word[0].toUpperCase()}${word.substring(1)}')
      .join(' ');
}

const String _defaultDescription = 'No description available yet.';

const Map<WeaponId, String> _weaponDisplayNameOverrides = <WeaponId, String>{
  WeaponId.woodenSword: 'Wooden Sword',
  WeaponId.basicSword: 'Basic Sword',
  WeaponId.solidSword: 'Solid Sword',
  WeaponId.woodenShield: 'Wooden Shield',
  WeaponId.basicShield: 'Basic Shield',
  WeaponId.solidShield: 'Solid Shield',
};

const Map<WeaponId, String> _weaponDescriptionOverrides = <WeaponId, String>{
  WeaponId.woodenSword: 'Starter blade with low power.',
  WeaponId.basicSword: 'Balanced one-handed sword.',
  WeaponId.solidSword: 'Heavier one-handed sword with higher power.',
  WeaponId.woodenShield: 'Starter shield with low output.',
  WeaponId.basicShield: 'Balanced shield for defensive actions.',
  WeaponId.solidShield: 'Reinforced shield with higher output.',
};

const Map<ProjectileId, String> _projectileDisplayNameOverrides =
    <ProjectileId, String>{
      ProjectileId.iceBolt: 'Ice Bolt',
      ProjectileId.fireBolt: 'Fire Bolt',
      ProjectileId.acidBolt: 'Acid Bolt',
      ProjectileId.darkBolt: 'Dark Bolt',
      ProjectileId.earthBolt: 'Earth Bolt',
      ProjectileId.holyBolt: 'Holy Bolt',
      ProjectileId.waterBolt: 'Water Bolt',
      ProjectileId.thunderBolt: 'Thunder Bolt',
      ProjectileId.throwingKnife: 'Throwing Knife',
      ProjectileId.throwingAxe: 'Throwing Axe',
    };

const Map<ProjectileId, String> _projectileDescriptionOverrides =
    <ProjectileId, String>{
      ProjectileId.iceBolt: 'Spell projectile that chills on hit.',
      ProjectileId.fireBolt: 'Spell projectile that burns on hit.',
      ProjectileId.acidBolt:
          'Spell projectile that corrodes and increases damage taken.',
      ProjectileId.darkBolt:
          'Spell projectile that weakens enemy outgoing damage on hit.',
      ProjectileId.earthBolt: 'Spell projectile that stuns enemies on hit.',
      ProjectileId.holyBolt:
          'Spell projectile that silences enemy casts for 3 seconds.',
      ProjectileId.waterBolt:
          'Spell projectile that drenches and slows attack/cast speed.',
      ProjectileId.thunderBolt: 'Spell projectile with thunder damage.',
      ProjectileId.throwingKnife: 'Fast ballistic throw with a light arc.',
      ProjectileId.throwingAxe: 'Heavy ballistic throw with a steeper arc.',
    };

const Map<SpellBookId, String> _spellBookDisplayNameOverrides =
    <SpellBookId, String>{
      SpellBookId.basicSpellBook: 'Basic Spellbook',
      SpellBookId.solidSpellBook: 'Solid Spellbook',
      SpellBookId.epicSpellBook: 'Epic Spellbook',
    };

const Map<SpellBookId, String> _spellBookDescriptionOverrides =
    <SpellBookId, String>{
      SpellBookId.basicSpellBook: 'Starter spell focus with lower output.',
      SpellBookId.solidSpellBook: 'Balanced spell focus.',
      SpellBookId.epicSpellBook: 'Advanced spell focus with higher output.',
    };

const Map<AccessoryId, String> _accessoryDisplayNameOverrides =
    <AccessoryId, String>{
      AccessoryId.speedBoots: 'Speed Boots',
      AccessoryId.goldenRing: 'Golden Ring',
      AccessoryId.teethNecklace: 'Teeth Necklace',
    };

const Map<AccessoryId, String> _accessoryDescriptionOverrides =
    <AccessoryId, String>{
      AccessoryId.speedBoots: 'Improves move speed.',
      AccessoryId.goldenRing: 'Improves maximum health.',
      AccessoryId.teethNecklace: 'Improves maximum stamina.',
    };


===== FILE: lib/ui/theme/ui_button_theme.dart =====
import 'package:flutter/material.dart';

import 'ui_tokens.dart';

enum AppButtonVariant { primary, secondary, danger }

enum AppButtonSize { xxs, xs, sm, md, lg }

@immutable
class UiButtonTheme extends ThemeExtension<UiButtonTheme> {
  const UiButtonTheme({
    required this.primary,
    required this.secondary,
    required this.danger,
    required this.sizes,
    required this.text,
    this.disabledBackgroundAlpha = 0.4,
    this.disabledForegroundAlpha = 0.5,
    this.disabledBorderAlpha = 0.4,
    this.pressedOverlayAlpha = 0.09,
    this.hoverOverlayAlpha = 0.05,
  });

  final UiButtonVariantTheme primary;
  final UiButtonVariantTheme secondary;
  final UiButtonVariantTheme danger;
  final UiButtonSizes sizes;
  final UiButtonTextStyles text;

  final double disabledBackgroundAlpha;
  final double disabledForegroundAlpha;
  final double disabledBorderAlpha;
  final double pressedOverlayAlpha;
  final double hoverOverlayAlpha;

  static const UiButtonTheme standard = UiButtonTheme(
    primary: UiButtonVariantTheme(
      background: UiBrandPalette.steelBlueBackground,
      foreground: UiBrandPalette.steelBlueForeground,
      border: UiBrandPalette.wornGoldBorder,
      surfaceTop: UiBrandPalette.steelBlueSurfaceTop,
      surfaceBottom: UiBrandPalette.steelBlueSurfaceBottom,
      insetTop: UiBrandPalette.steelBlueInsetTop,
      insetBottom: UiBrandPalette.steelBlueInsetBottom,
      insetBorder: UiBrandPalette.wornGoldInsetBorder,
      shadow: UiBrandPalette.buttonShadow,
      glow: UiBrandPalette.wornGoldGlow,
    ),
    secondary: UiButtonVariantTheme(
      background: UiBrandPalette.steelBlueBackground,
      foreground: UiBrandPalette.steelBlueForeground,
      border: UiBrandPalette.wornGoldBorder,
      surfaceTop: UiBrandPalette.steelBlueSurfaceTop,
      surfaceBottom: UiBrandPalette.steelBlueSurfaceBottom,
      insetTop: UiBrandPalette.steelBlueInsetTop,
      insetBottom: UiBrandPalette.steelBlueInsetBottom,
      insetBorder: UiBrandPalette.wornGoldInsetBorder,
      shadow: UiBrandPalette.buttonShadow,
      glow: UiBrandPalette.wornGoldGlow,
    ),
    danger: UiButtonVariantTheme(
      background: UiBrandPalette.mutedPlumBackground,
      foreground: UiBrandPalette.mutedPlumForeground,
      border: UiBrandPalette.mutedPlumBorder,
      surfaceTop: UiBrandPalette.mutedPlumSurfaceTop,
      surfaceBottom: UiBrandPalette.mutedPlumSurfaceBottom,
      insetTop: UiBrandPalette.mutedPlumInsetTop,
      insetBottom: UiBrandPalette.mutedPlumInsetBottom,
      insetBorder: UiBrandPalette.mutedPlumInsetBorder,
      shadow: UiBrandPalette.buttonShadow,
      glow: UiBrandPalette.mutedPlumGlow,
    ),
    sizes: UiButtonSizes(
      xxs: UiButtonSizeMetrics(width: 96, height: 48),
      xs: UiButtonSizeMetrics(width: 120, height: 48),
      sm: UiButtonSizeMetrics(width: 144, height: 48),
      md: UiButtonSizeMetrics(width: 160, height: 48),
      lg: UiButtonSizeMetrics(width: 192, height: 48),
    ),
    text: UiButtonTextStyles(
      xxs: TextStyle(
        fontFamily: 'CrimsonText',
        fontSize: 15,
        fontWeight: FontWeight.w700,
      ),
      xs: TextStyle(
        fontFamily: 'CrimsonText',
        fontSize: 15,
        fontWeight: FontWeight.w700,
      ),
      sm: TextStyle(
        fontFamily: 'CrimsonText',
        fontSize: 15,
        fontWeight: FontWeight.w700,
      ),
      md: TextStyle(
        fontFamily: 'CrimsonText',
        fontSize: 17,
        fontWeight: FontWeight.w700,
      ),
      lg: TextStyle(
        fontFamily: 'CrimsonText',
        fontSize: 18,
        fontWeight: FontWeight.w700,
      ),
    ),
  );

  UiButtonVariantTheme variant(AppButtonVariant variant) => switch (variant) {
    AppButtonVariant.primary => primary,
    AppButtonVariant.secondary => secondary,
    AppButtonVariant.danger => danger,
  };

  UiButtonSpec resolveSpec({
    required UiTokens ui,
    required AppButtonVariant variant,
    required AppButtonSize size,
  }) {
    final variantTheme = this.variant(variant);
    return UiButtonSpec(
      width: sizes.width(size),
      height: sizes.height(size),
      padding: EdgeInsets.symmetric(horizontal: ui.space.md, vertical: 10),
      textStyle: text.style(size),
      background: variantTheme.background,
      foreground: variantTheme.foreground,
      border: variantTheme.border,
      surfaceTop: variantTheme.surfaceTop,
      surfaceBottom: variantTheme.surfaceBottom,
      insetTop: variantTheme.insetTop,
      insetBottom: variantTheme.insetBottom,
      insetBorder: variantTheme.insetBorder,
      shadow: variantTheme.shadow,
      glow: variantTheme.glow,
    );
  }

  @override
  UiButtonTheme copyWith({
    UiButtonVariantTheme? primary,
    UiButtonVariantTheme? secondary,
    UiButtonVariantTheme? danger,
    UiButtonSizes? sizes,
    UiButtonTextStyles? text,
    double? disabledBackgroundAlpha,
    double? disabledForegroundAlpha,
    double? disabledBorderAlpha,
    double? pressedOverlayAlpha,
    double? hoverOverlayAlpha,
  }) {
    return UiButtonTheme(
      primary: primary ?? this.primary,
      secondary: secondary ?? this.secondary,
      danger: danger ?? this.danger,
      sizes: sizes ?? this.sizes,
      text: text ?? this.text,
      disabledBackgroundAlpha:
          disabledBackgroundAlpha ?? this.disabledBackgroundAlpha,
      disabledForegroundAlpha:
          disabledForegroundAlpha ?? this.disabledForegroundAlpha,
      disabledBorderAlpha: disabledBorderAlpha ?? this.disabledBorderAlpha,
      pressedOverlayAlpha: pressedOverlayAlpha ?? this.pressedOverlayAlpha,
      hoverOverlayAlpha: hoverOverlayAlpha ?? this.hoverOverlayAlpha,
    );
  }

  @override
  UiButtonTheme lerp(ThemeExtension<UiButtonTheme>? other, double t) {
    if (other is! UiButtonTheme) return this;
    return t < 0.5 ? this : other;
  }
}

@immutable
class UiButtonVariantTheme {
  const UiButtonVariantTheme({
    required this.background,
    required this.foreground,
    required this.border,
    Color? surfaceTop,
    Color? surfaceBottom,
    Color? insetTop,
    Color? insetBottom,
    Color? insetBorder,
    Color? shadow,
    Color? glow,
  }) : surfaceTop = surfaceTop ?? background,
       surfaceBottom = surfaceBottom ?? background,
       insetTop = insetTop ?? background,
       insetBottom = insetBottom ?? background,
       insetBorder = insetBorder ?? border,
       shadow = shadow ?? UiBrandPalette.buttonShadow,
       glow = glow ?? Colors.transparent;

  final Color background;
  final Color foreground;
  final Color border;
  final Color surfaceTop;
  final Color surfaceBottom;
  final Color insetTop;
  final Color insetBottom;
  final Color insetBorder;
  final Color shadow;
  final Color glow;
}

@immutable
class UiButtonSizes {
  const UiButtonSizes({
    required this.xxs,
    required this.xs,
    required this.sm,
    required this.md,
    required this.lg,
  });

  final UiButtonSizeMetrics xxs;
  final UiButtonSizeMetrics xs;
  final UiButtonSizeMetrics sm;
  final UiButtonSizeMetrics md;
  final UiButtonSizeMetrics lg;

  double width(AppButtonSize size) => switch (size) {
    AppButtonSize.xxs => xxs.width,
    AppButtonSize.xs => xs.width,
    AppButtonSize.sm => sm.width,
    AppButtonSize.md => md.width,
    AppButtonSize.lg => lg.width,
  };

  double height(AppButtonSize size) => switch (size) {
    AppButtonSize.xxs => xxs.height,
    AppButtonSize.xs => xs.height,
    AppButtonSize.sm => sm.height,
    AppButtonSize.md => md.height,
    AppButtonSize.lg => lg.height,
  };
}

@immutable
class UiButtonSizeMetrics {
  const UiButtonSizeMetrics({required this.width, required this.height});

  final double width;
  final double height;
}

@immutable
class UiButtonSpec {
  const UiButtonSpec({
    required this.width,
    required this.height,
    required this.padding,
    required this.textStyle,
    required this.background,
    required this.foreground,
    required this.border,
    required this.surfaceTop,
    required this.surfaceBottom,
    required this.insetTop,
    required this.insetBottom,
    required this.insetBorder,
    required this.shadow,
    required this.glow,
  });

  final double width;
  final double height;
  final EdgeInsetsGeometry padding;
  final TextStyle textStyle;
  final Color background;
  final Color foreground;
  final Color border;
  final Color surfaceTop;
  final Color surfaceBottom;
  final Color insetTop;
  final Color insetBottom;
  final Color insetBorder;
  final Color shadow;
  final Color glow;
}

@immutable
class UiButtonTextStyles {
  const UiButtonTextStyles({
    required this.xxs,
    required this.xs,
    required this.sm,
    required this.md,
    required this.lg,
  });

  final TextStyle xxs;
  final TextStyle xs;
  final TextStyle sm;
  final TextStyle md;
  final TextStyle lg;

  TextStyle style(AppButtonSize size) => switch (size) {
    AppButtonSize.xxs => xxs,
    AppButtonSize.xs => xs,
    AppButtonSize.sm => sm,
    AppButtonSize.md => md,
    AppButtonSize.lg => lg,
  };
}

extension UiButtonThemeContext on BuildContext {
  UiButtonTheme get buttons =>
      Theme.of(this).extension<UiButtonTheme>() ?? UiButtonTheme.standard;
}


===== FILE: lib/ui/theme/ui_hub_theme.dart =====
import 'package:flutter/material.dart';

/// Hub-scoped UI defaults.
///
/// These are not global "design tokens"; they're defaults for hub components
/// (e.g. the select card frame). Keeping them separate prevents `UiTokens`
/// from accumulating one-off component sizing.
@immutable
class UiHubTheme extends ThemeExtension<UiHubTheme> {
  const UiHubTheme({
    required this.selectCardWidth,
    required this.selectCardHeight,
    required this.characterPreviewSize,
  });

  final double selectCardWidth;
  final double selectCardHeight;
  final double characterPreviewSize;

  static const UiHubTheme standard = UiHubTheme(
    selectCardWidth: 240,
    selectCardHeight: 144,
    characterPreviewSize: 96,
  );

  @override
  UiHubTheme copyWith({
    double? selectCardWidth,
    double? selectCardHeight,
    double? characterPreviewSize,
  }) {
    return UiHubTheme(
      selectCardWidth: selectCardWidth ?? this.selectCardWidth,
      selectCardHeight: selectCardHeight ?? this.selectCardHeight,
      characterPreviewSize: characterPreviewSize ?? this.characterPreviewSize,
    );
  }

  @override
  UiHubTheme lerp(ThemeExtension<UiHubTheme>? other, double t) {
    if (other is! UiHubTheme) return this;
    return t < 0.5 ? this : other;
  }
}

extension UiHubThemeContext on BuildContext {
  UiHubTheme get hub =>
      Theme.of(this).extension<UiHubTheme>() ?? UiHubTheme.standard;
}


===== FILE: lib/ui/theme/ui_icon_button_theme.dart =====
import 'package:flutter/material.dart';

import 'ui_tokens.dart';

enum AppIconButtonVariant { primary, secondary, danger }

enum AppIconButtonSize { sm, md, lg }

@immutable
class UiIconButtonTheme extends ThemeExtension<UiIconButtonTheme> {
  const UiIconButtonTheme({
    required this.primary,
    required this.secondary,
    required this.danger,
    required this.sizes,
    required this.text,
    this.disabledAlpha = 0.4,
  });

  final UiIconButtonVariantTheme primary;
  final UiIconButtonVariantTheme secondary;
  final UiIconButtonVariantTheme danger;

  final UiIconButtonSizes sizes;
  final UiIconButtonTextStyles text;

  final double disabledAlpha;

  static const UiIconButtonTheme standard = UiIconButtonTheme(
    primary: UiIconButtonVariantTheme(
      iconColor: UiBrandPalette.steelBlueForeground,
      labelColor: UiBrandPalette.steelBlueForeground,
    ),
    secondary: UiIconButtonVariantTheme(
      iconColor: UiBrandPalette.baseBackground,
      labelColor: UiBrandPalette.steelBlueSurfaceTop,
    ),
    danger: UiIconButtonVariantTheme(
      iconColor: UiBrandPalette.crimsonDanger,
      labelColor: UiBrandPalette.crimsonDanger,
    ),
    sizes: UiIconButtonSizes(
      sm: UiIconButtonSizeMetrics(iconSize: 24),
      md: UiIconButtonSizeMetrics(iconSize: 32),
      lg: UiIconButtonSizeMetrics(iconSize: 40),
    ),
    text: UiIconButtonTextStyles(
      sm: TextStyle(fontSize: 12, fontWeight: FontWeight.w500),
      md: TextStyle(fontSize: 12, fontWeight: FontWeight.w500),
      lg: TextStyle(fontSize: 12, fontWeight: FontWeight.w500),
    ),
  );

  UiIconButtonVariantTheme variant(AppIconButtonVariant variant) =>
      switch (variant) {
        AppIconButtonVariant.primary => primary,
        AppIconButtonVariant.secondary => secondary,
        AppIconButtonVariant.danger => danger,
      };

  UiIconButtonSpec resolveSpec({
    required UiTokens ui,
    required AppIconButtonVariant variant,
    required AppIconButtonSize size,
  }) {
    final variantTheme = this.variant(variant);
    final sizeMetrics = sizes.metrics(size);
    final labelStyleBase = text.style(size);
    final disabledIconColor = variantTheme.iconColor.withValues(
      alpha: disabledAlpha,
    );
    final disabledLabelColor = variantTheme.labelColor.withValues(
      alpha: disabledAlpha,
    );

    return UiIconButtonSpec(
      iconSize: sizeMetrics.iconSize,
      constraints: BoxConstraints(
        minWidth: ui.sizes.tapTarget,
        minHeight: ui.sizes.tapTarget,
      ),
      labelSpacing: ui.space.xxs,
      iconColor: variantTheme.iconColor,
      disabledIconColor: disabledIconColor,
      labelStyle: labelStyleBase.copyWith(color: variantTheme.labelColor),
      disabledLabelStyle: labelStyleBase.copyWith(color: disabledLabelColor),
    );
  }

  @override
  UiIconButtonTheme copyWith({
    UiIconButtonVariantTheme? primary,
    UiIconButtonVariantTheme? secondary,
    UiIconButtonVariantTheme? danger,
    UiIconButtonSizes? sizes,
    UiIconButtonTextStyles? text,
    double? disabledAlpha,
  }) {
    return UiIconButtonTheme(
      primary: primary ?? this.primary,
      secondary: secondary ?? this.secondary,
      danger: danger ?? this.danger,
      sizes: sizes ?? this.sizes,
      text: text ?? this.text,
      disabledAlpha: disabledAlpha ?? this.disabledAlpha,
    );
  }

  @override
  UiIconButtonTheme lerp(ThemeExtension<UiIconButtonTheme>? other, double t) {
    if (other is! UiIconButtonTheme) return this;
    return t < 0.5 ? this : other;
  }
}

@immutable
class UiIconButtonVariantTheme {
  const UiIconButtonVariantTheme({
    required this.iconColor,
    required this.labelColor,
  });

  final Color iconColor;
  final Color labelColor;
}

@immutable
class UiIconButtonSizes {
  const UiIconButtonSizes({
    required this.sm,
    required this.md,
    required this.lg,
  });

  final UiIconButtonSizeMetrics sm;
  final UiIconButtonSizeMetrics md;
  final UiIconButtonSizeMetrics lg;

  UiIconButtonSizeMetrics metrics(AppIconButtonSize size) => switch (size) {
    AppIconButtonSize.sm => sm,
    AppIconButtonSize.md => md,
    AppIconButtonSize.lg => lg,
  };
}

@immutable
class UiIconButtonSizeMetrics {
  const UiIconButtonSizeMetrics({required this.iconSize});

  final double iconSize;
}

@immutable
class UiIconButtonTextStyles {
  const UiIconButtonTextStyles({
    required this.sm,
    required this.md,
    required this.lg,
  });

  final TextStyle sm;
  final TextStyle md;
  final TextStyle lg;

  TextStyle style(AppIconButtonSize size) => switch (size) {
    AppIconButtonSize.sm => sm,
    AppIconButtonSize.md => md,
    AppIconButtonSize.lg => lg,
  };
}

@immutable
class UiIconButtonSpec {
  const UiIconButtonSpec({
    required this.iconSize,
    required this.constraints,
    required this.labelSpacing,
    required this.iconColor,
    required this.disabledIconColor,
    required this.labelStyle,
    required this.disabledLabelStyle,
  });

  final double iconSize;
  final BoxConstraints constraints;
  final double labelSpacing;
  final Color iconColor;
  final Color disabledIconColor;
  final TextStyle labelStyle;
  final TextStyle disabledLabelStyle;
}

extension UiIconButtonThemeContext on BuildContext {
  UiIconButtonTheme get iconButtons =>
      Theme.of(this).extension<UiIconButtonTheme>() ??
      UiIconButtonTheme.standard;
}


===== FILE: lib/ui/theme/ui_inline_edit_text_theme.dart =====
import 'package:flutter/material.dart';

import 'ui_inline_icon_button_theme.dart';
import 'ui_tokens.dart';

@immutable
class UiInlineEditTextTheme extends ThemeExtension<UiInlineEditTextTheme> {
  const UiInlineEditTextTheme({
    required this.valueStyle,
    required this.hintStyle,
    required this.borderColor,
    required this.enabledBorderColor,
    required this.focusedBorderColor,
    required this.editButtonVariant,
    required this.saveButtonVariant,
    required this.cancelButtonVariant,
    required this.editButtonSize,
    required this.actionButtonSize,
    this.fieldPadding = const EdgeInsets.symmetric(horizontal: 0, vertical: 8),
  });

  final TextStyle valueStyle;
  final TextStyle hintStyle;

  final Color borderColor;
  final Color enabledBorderColor;
  final Color focusedBorderColor;

  final AppInlineIconButtonVariant editButtonVariant;
  final AppInlineIconButtonVariant saveButtonVariant;
  final AppInlineIconButtonVariant cancelButtonVariant;

  final AppInlineIconButtonSize editButtonSize;
  final AppInlineIconButtonSize actionButtonSize;

  final EdgeInsets fieldPadding;

  static const UiInlineEditTextTheme standard = UiInlineEditTextTheme(
    valueStyle: TextStyle(color: UiBrandPalette.steelBlueForeground),
    hintStyle: TextStyle(color: UiBrandPalette.steelBlueMutedText),
    borderColor: UiBrandPalette.wornGoldInsetBorder,
    enabledBorderColor: UiBrandPalette.wornGoldOutline,
    focusedBorderColor: UiBrandPalette.wornGoldInsetBorder,
    editButtonVariant: AppInlineIconButtonVariant.discrete,
    saveButtonVariant: AppInlineIconButtonVariant.success,
    cancelButtonVariant: AppInlineIconButtonVariant.discrete,
    editButtonSize: AppInlineIconButtonSize.xs,
    actionButtonSize: AppInlineIconButtonSize.sm,
  );

  UiInlineEditTextSpec resolveSpec({required UiTokens ui}) {
    return UiInlineEditTextSpec(
      valueStyle: valueStyle,
      fieldDecoration: InputDecoration(
        isDense: true,
        contentPadding: fieldPadding,
        border: UnderlineInputBorder(
          borderSide: BorderSide(color: borderColor),
        ),
        enabledBorder: UnderlineInputBorder(
          borderSide: BorderSide(color: enabledBorderColor),
        ),
        focusedBorder: UnderlineInputBorder(
          borderSide: BorderSide(color: focusedBorderColor),
        ),
        hintStyle: hintStyle,
      ),
      editButtonVariant: editButtonVariant,
      saveButtonVariant: saveButtonVariant,
      cancelButtonVariant: cancelButtonVariant,
      editButtonSize: editButtonSize,
      actionButtonSize: actionButtonSize,
    );
  }

  @override
  UiInlineEditTextTheme copyWith({
    TextStyle? valueStyle,
    TextStyle? hintStyle,
    Color? borderColor,
    Color? enabledBorderColor,
    Color? focusedBorderColor,
    AppInlineIconButtonVariant? editButtonVariant,
    AppInlineIconButtonVariant? saveButtonVariant,
    AppInlineIconButtonVariant? cancelButtonVariant,
    AppInlineIconButtonSize? editButtonSize,
    AppInlineIconButtonSize? actionButtonSize,
    EdgeInsets? fieldPadding,
  }) {
    return UiInlineEditTextTheme(
      valueStyle: valueStyle ?? this.valueStyle,
      hintStyle: hintStyle ?? this.hintStyle,
      borderColor: borderColor ?? this.borderColor,
      enabledBorderColor: enabledBorderColor ?? this.enabledBorderColor,
      focusedBorderColor: focusedBorderColor ?? this.focusedBorderColor,
      editButtonVariant: editButtonVariant ?? this.editButtonVariant,
      saveButtonVariant: saveButtonVariant ?? this.saveButtonVariant,
      cancelButtonVariant: cancelButtonVariant ?? this.cancelButtonVariant,
      editButtonSize: editButtonSize ?? this.editButtonSize,
      actionButtonSize: actionButtonSize ?? this.actionButtonSize,
      fieldPadding: fieldPadding ?? this.fieldPadding,
    );
  }

  @override
  UiInlineEditTextTheme lerp(
    ThemeExtension<UiInlineEditTextTheme>? other,
    double t,
  ) {
    if (other is! UiInlineEditTextTheme) return this;
    return t < 0.5 ? this : other;
  }
}

@immutable
class UiInlineEditTextSpec {
  const UiInlineEditTextSpec({
    required this.valueStyle,
    required this.fieldDecoration,
    required this.editButtonVariant,
    required this.saveButtonVariant,
    required this.cancelButtonVariant,
    required this.editButtonSize,
    required this.actionButtonSize,
  });

  final TextStyle valueStyle;
  final InputDecoration fieldDecoration;
  final AppInlineIconButtonVariant editButtonVariant;
  final AppInlineIconButtonVariant saveButtonVariant;
  final AppInlineIconButtonVariant cancelButtonVariant;
  final AppInlineIconButtonSize editButtonSize;
  final AppInlineIconButtonSize actionButtonSize;
}

extension UiInlineEditTextThemeContext on BuildContext {
  UiInlineEditTextTheme get inlineEditText =>
      Theme.of(this).extension<UiInlineEditTextTheme>() ??
      UiInlineEditTextTheme.standard;
}


===== FILE: lib/ui/theme/ui_inline_icon_button_theme.dart =====
import 'package:flutter/material.dart';

import 'ui_tokens.dart';

enum AppInlineIconButtonVariant { discrete, success, danger }

enum AppInlineIconButtonSize { xs, sm }

@immutable
class UiInlineIconButtonTheme extends ThemeExtension<UiInlineIconButtonTheme> {
  const UiInlineIconButtonTheme({
    required this.discrete,
    required this.success,
    required this.danger,
    required this.sizes,
    this.disabledAlpha = 0.4,
  });

  final UiInlineIconButtonVariantTheme discrete;
  final UiInlineIconButtonVariantTheme success;
  final UiInlineIconButtonVariantTheme danger;

  final UiInlineIconButtonSizes sizes;

  final double disabledAlpha;

  static const UiInlineIconButtonTheme standard = UiInlineIconButtonTheme(
    discrete: UiInlineIconButtonVariantTheme(
      iconColor: UiBrandPalette.steelBlueMutedText,
    ),
    success: UiInlineIconButtonVariantTheme(
      iconColor: UiBrandPalette.mutedMossSuccess,
    ),
    danger: UiInlineIconButtonVariantTheme(
      iconColor: UiBrandPalette.crimsonDanger,
    ),
    sizes: UiInlineIconButtonSizes(
      xs: UiInlineIconButtonSizeMetrics(
        iconSize: 16,
        padding: EdgeInsets.zero,
        spinnerSize: 16,
        spinnerStrokeWidth: 2,
      ),
      sm: UiInlineIconButtonSizeMetrics(
        iconSize: 20,
        padding: EdgeInsets.all(4),
        spinnerSize: 16,
        spinnerStrokeWidth: 2,
      ),
    ),
  );

  UiInlineIconButtonVariantTheme variant(AppInlineIconButtonVariant variant) =>
      switch (variant) {
        AppInlineIconButtonVariant.discrete => discrete,
        AppInlineIconButtonVariant.success => success,
        AppInlineIconButtonVariant.danger => danger,
      };

  UiInlineIconButtonSpec resolveSpec({
    required UiTokens ui,
    required AppInlineIconButtonVariant variant,
    required AppInlineIconButtonSize size,
  }) {
    final v = this.variant(variant);
    final s = sizes.metrics(size);

    final iconColor = v.iconColor;
    final disabledColor = iconColor.withValues(alpha: disabledAlpha);

    return UiInlineIconButtonSpec(
      iconSize: s.iconSize,
      padding: s.padding,
      constraints: const BoxConstraints(),
      iconColor: iconColor,
      disabledColor: disabledColor,
      spinnerSize: s.spinnerSize,
      spinnerStrokeWidth: s.spinnerStrokeWidth,
      spinnerColor: iconColor,
      tapTarget: ui.sizes.tapTarget,
    );
  }

  @override
  UiInlineIconButtonTheme copyWith({
    UiInlineIconButtonVariantTheme? discrete,
    UiInlineIconButtonVariantTheme? success,
    UiInlineIconButtonVariantTheme? danger,
    UiInlineIconButtonSizes? sizes,
    double? disabledAlpha,
  }) {
    return UiInlineIconButtonTheme(
      discrete: discrete ?? this.discrete,
      success: success ?? this.success,
      danger: danger ?? this.danger,
      sizes: sizes ?? this.sizes,
      disabledAlpha: disabledAlpha ?? this.disabledAlpha,
    );
  }

  @override
  UiInlineIconButtonTheme lerp(
    ThemeExtension<UiInlineIconButtonTheme>? other,
    double t,
  ) {
    if (other is! UiInlineIconButtonTheme) return this;
    return t < 0.5 ? this : other;
  }
}

@immutable
class UiInlineIconButtonVariantTheme {
  const UiInlineIconButtonVariantTheme({required this.iconColor});

  final Color iconColor;
}

@immutable
class UiInlineIconButtonSizes {
  const UiInlineIconButtonSizes({required this.xs, required this.sm});

  final UiInlineIconButtonSizeMetrics xs;
  final UiInlineIconButtonSizeMetrics sm;

  UiInlineIconButtonSizeMetrics metrics(AppInlineIconButtonSize size) =>
      switch (size) {
        AppInlineIconButtonSize.xs => xs,
        AppInlineIconButtonSize.sm => sm,
      };
}

@immutable
class UiInlineIconButtonSizeMetrics {
  const UiInlineIconButtonSizeMetrics({
    required this.iconSize,
    required this.padding,
    required this.spinnerSize,
    required this.spinnerStrokeWidth,
  });

  final double iconSize;
  final EdgeInsets padding;
  final double spinnerSize;
  final double spinnerStrokeWidth;
}

@immutable
class UiInlineIconButtonSpec {
  const UiInlineIconButtonSpec({
    required this.iconSize,
    required this.padding,
    required this.constraints,
    required this.iconColor,
    required this.disabledColor,
    required this.spinnerSize,
    required this.spinnerStrokeWidth,
    required this.spinnerColor,
    required this.tapTarget,
  });

  final double iconSize;
  final EdgeInsets padding;
  final BoxConstraints constraints;
  final Color iconColor;
  final Color disabledColor;
  final double spinnerSize;
  final double spinnerStrokeWidth;
  final Color spinnerColor;

  /// For opt-in semantics sizing (e.g. using `Semantics` or tooltip). This does
  /// not constrain layout for dense inline buttons.
  final double tapTarget;
}

extension UiInlineIconButtonThemeContext on BuildContext {
  UiInlineIconButtonTheme get inlineIconButtons =>
      Theme.of(this).extension<UiInlineIconButtonTheme>() ??
      UiInlineIconButtonTheme.standard;
}


===== FILE: lib/ui/theme/ui_leaderboard_theme.dart =====
import 'package:flutter/material.dart';

import 'ui_tokens.dart';

@immutable
class UiLeaderboardTheme extends ThemeExtension<UiLeaderboardTheme> {
  const UiLeaderboardTheme({
    required this.columns,
    required this.rowHeight,
    required this.headerHeight,
    this.rowGap = 2,
    this.headerGap = 2,
    this.rowPadding = const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
    this.tablePadding = const EdgeInsets.symmetric(horizontal: 12),
    this.rowRadius = 8,
    this.rowBorderWidth = 1,
    required this.rowBackground,
    required this.rowBorderColor,
    required this.highlightBackground,
    required this.highlightBorderColor,
    required this.rowTextStyle,
    required this.headerTextStyle,
    required this.highlightTextColor,
  });

  final UiLeaderboardColumns columns;
  final double rowHeight;
  final double headerHeight;
  final double rowGap;
  final double headerGap;
  final EdgeInsets rowPadding;
  final EdgeInsets tablePadding;
  final double rowRadius;
  final double rowBorderWidth;

  final Color rowBackground;
  final Color rowBorderColor;
  final Color highlightBackground;
  final Color highlightBorderColor;
  final Color highlightTextColor;

  final TextStyle rowTextStyle;
  final TextStyle headerTextStyle;

  static const UiLeaderboardTheme standard = UiLeaderboardTheme(
    columns: UiLeaderboardColumns(
      rank: UiLeaderboardColumn(width: 40),
      score: UiLeaderboardColumn(flex: 1),
      distance: UiLeaderboardColumn(flex: 1),
      time: UiLeaderboardColumn(flex: 1),
    ),
    rowHeight: 32,
    headerHeight: 20,
    rowBackground: UiBrandPalette.shadow,
    rowBorderColor: UiBrandPalette.steelBlueMutedText,
    highlightBackground: UiBrandPalette.wornGoldGlow,
    highlightBorderColor: UiBrandPalette.wornGoldInsetBorder,
    highlightTextColor: UiBrandPalette.wornGoldInsetBorder,
    rowTextStyle: TextStyle(
      color: UiBrandPalette.steelBlueForeground,
      fontSize: 12,
      fontWeight: FontWeight.w400,
    ),
    headerTextStyle: TextStyle(
      color: UiBrandPalette.steelBlueMutedText,
      fontSize: 12,
      fontWeight: FontWeight.w500,
    ),
  );

  UiLeaderboardSpec resolveSpec({required UiTokens ui}) {
    final resolvedRowTextStyle = rowTextStyle.copyWith(
      color: rowTextStyle.color ?? ui.colors.textPrimary,
    );
    final resolvedHeaderTextStyle = headerTextStyle.copyWith(
      color: headerTextStyle.color ?? ui.colors.textMuted,
    );

    return UiLeaderboardSpec(
      columns: columns,
      rowHeight: rowHeight,
      headerHeight: headerHeight,
      rowGap: rowGap,
      headerGap: headerGap,
      rowPadding: rowPadding,
      tablePadding: tablePadding,
      rowRadius: rowRadius,
      rowBorderWidth: rowBorderWidth,
      rowBackground: rowBackground,
      rowBorderColor: rowBorderColor,
      highlightBackground: highlightBackground,
      highlightBorderColor: highlightBorderColor,
      rowTextStyle: resolvedRowTextStyle,
      headerTextStyle: resolvedHeaderTextStyle,
      highlightTextColor: highlightTextColor,
    );
  }

  @override
  UiLeaderboardTheme copyWith({
    UiLeaderboardColumns? columns,
    double? rowHeight,
    double? headerHeight,
    double? rowGap,
    double? headerGap,
    EdgeInsets? rowPadding,
    EdgeInsets? tablePadding,
    double? rowRadius,
    double? rowBorderWidth,
    Color? rowBackground,
    Color? rowBorderColor,
    Color? highlightBackground,
    Color? highlightBorderColor,
    Color? highlightTextColor,
    TextStyle? rowTextStyle,
    TextStyle? headerTextStyle,
  }) {
    return UiLeaderboardTheme(
      columns: columns ?? this.columns,
      rowHeight: rowHeight ?? this.rowHeight,
      headerHeight: headerHeight ?? this.headerHeight,
      rowGap: rowGap ?? this.rowGap,
      headerGap: headerGap ?? this.headerGap,
      rowPadding: rowPadding ?? this.rowPadding,
      tablePadding: tablePadding ?? this.tablePadding,
      rowRadius: rowRadius ?? this.rowRadius,
      rowBorderWidth: rowBorderWidth ?? this.rowBorderWidth,
      rowBackground: rowBackground ?? this.rowBackground,
      rowBorderColor: rowBorderColor ?? this.rowBorderColor,
      highlightBackground: highlightBackground ?? this.highlightBackground,
      highlightBorderColor: highlightBorderColor ?? this.highlightBorderColor,
      highlightTextColor: highlightTextColor ?? this.highlightTextColor,
      rowTextStyle: rowTextStyle ?? this.rowTextStyle,
      headerTextStyle: headerTextStyle ?? this.headerTextStyle,
    );
  }

  @override
  UiLeaderboardTheme lerp(ThemeExtension<UiLeaderboardTheme>? other, double t) {
    if (other is! UiLeaderboardTheme) return this;
    return t < 0.5 ? this : other;
  }
}

@immutable
class UiLeaderboardSpec {
  const UiLeaderboardSpec({
    required this.columns,
    required this.rowHeight,
    required this.headerHeight,
    required this.rowGap,
    required this.headerGap,
    required this.rowPadding,
    required this.tablePadding,
    required this.rowRadius,
    required this.rowBorderWidth,
    required this.rowBackground,
    required this.rowBorderColor,
    required this.highlightBackground,
    required this.highlightBorderColor,
    required this.rowTextStyle,
    required this.headerTextStyle,
    required this.highlightTextColor,
  });

  final UiLeaderboardColumns columns;
  final double rowHeight;
  final double headerHeight;
  final double rowGap;
  final double headerGap;
  final EdgeInsets rowPadding;
  final EdgeInsets tablePadding;
  final double rowRadius;
  final double rowBorderWidth;
  final Color rowBackground;
  final Color rowBorderColor;
  final Color highlightBackground;
  final Color highlightBorderColor;
  final Color highlightTextColor;
  final TextStyle rowTextStyle;
  final TextStyle headerTextStyle;
}

@immutable
class UiLeaderboardColumns {
  const UiLeaderboardColumns({
    required this.rank,
    required this.score,
    required this.distance,
    required this.time,
  });

  final UiLeaderboardColumn rank;
  final UiLeaderboardColumn score;
  final UiLeaderboardColumn distance;
  final UiLeaderboardColumn time;
}

@immutable
class UiLeaderboardColumn {
  const UiLeaderboardColumn({this.width, this.flex = 1});

  final double? width;
  final int flex;
}

extension UiLeaderboardThemeContext on BuildContext {
  UiLeaderboardTheme get leaderboards =>
      Theme.of(this).extension<UiLeaderboardTheme>() ??
      UiLeaderboardTheme.standard;
}


===== FILE: lib/ui/theme/ui_segmented_control_theme.dart =====
import 'package:flutter/material.dart';

import 'ui_tokens.dart';

enum AppSegmentedControlSize { sm, md }

@immutable
class UiSegmentedControlTheme extends ThemeExtension<UiSegmentedControlTheme> {
  const UiSegmentedControlTheme({
    required this.background,
    required this.selectedBackground,
    required this.foreground,
    required this.selectedForeground,
    required this.border,
    required this.sizes,
    required this.text,
    this.disabledAlpha = 0.45,
    this.pressedOverlayAlpha = 0.12,
    this.hoverOverlayAlpha = 0.08,
    this.showSelectedIcon = false,
  });

  final Color background;
  final Color selectedBackground;
  final Color foreground;
  final Color selectedForeground;
  final Color border;

  final UiSegmentedControlSizes sizes;
  final UiSegmentedControlTextStyles text;

  final double disabledAlpha;
  final double pressedOverlayAlpha;
  final double hoverOverlayAlpha;
  final bool showSelectedIcon;

  static const UiSegmentedControlTheme standard = UiSegmentedControlTheme(
    background: UiBrandPalette.steelBlueSurfaceBottom,
    selectedBackground: UiBrandPalette.wornGoldInsetBorder,
    foreground: UiBrandPalette.steelBlueForeground,
    selectedForeground: UiBrandPalette.baseBackground,
    border: UiBrandPalette.wornGoldBorder,
    sizes: UiSegmentedControlSizes(
      sm: UiSegmentedControlSizeMetrics(height: 32, paddingHorizontal: 8),
      md: UiSegmentedControlSizeMetrics(height: 48, paddingHorizontal: 16),
    ),
    text: UiSegmentedControlTextStyles(
      sm: TextStyle(fontSize: 12, fontWeight: FontWeight.w500),
      md: TextStyle(fontSize: 14, fontWeight: FontWeight.w500),
    ),
  );

  UiSegmentedControlSpec resolveSpec({
    required UiTokens ui,
    required AppSegmentedControlSize size,
  }) {
    final metrics = sizes.metrics(size);

    return UiSegmentedControlSpec(
      height: metrics.height,
      padding: EdgeInsets.symmetric(horizontal: metrics.paddingHorizontal),
      radius: ui.radii.xl,
      textStyle: text.style(size).copyWith(letterSpacing: 1.2),
      showSelectedIcon: showSelectedIcon,
    );
  }

  @override
  UiSegmentedControlTheme copyWith({
    Color? background,
    Color? selectedBackground,
    Color? foreground,
    Color? selectedForeground,
    Color? border,
    UiSegmentedControlSizes? sizes,
    UiSegmentedControlTextStyles? text,
    double? disabledAlpha,
    double? pressedOverlayAlpha,
    double? hoverOverlayAlpha,
    bool? showSelectedIcon,
  }) {
    return UiSegmentedControlTheme(
      background: background ?? this.background,
      selectedBackground: selectedBackground ?? this.selectedBackground,
      foreground: foreground ?? this.foreground,
      selectedForeground: selectedForeground ?? this.selectedForeground,
      border: border ?? this.border,
      sizes: sizes ?? this.sizes,
      text: text ?? this.text,
      disabledAlpha: disabledAlpha ?? this.disabledAlpha,
      pressedOverlayAlpha: pressedOverlayAlpha ?? this.pressedOverlayAlpha,
      hoverOverlayAlpha: hoverOverlayAlpha ?? this.hoverOverlayAlpha,
      showSelectedIcon: showSelectedIcon ?? this.showSelectedIcon,
    );
  }

  @override
  UiSegmentedControlTheme lerp(
    ThemeExtension<UiSegmentedControlTheme>? other,
    double t,
  ) {
    if (other is! UiSegmentedControlTheme) return this;
    return t < 0.5 ? this : other;
  }
}

@immutable
class UiSegmentedControlSizes {
  const UiSegmentedControlSizes({required this.sm, required this.md});

  final UiSegmentedControlSizeMetrics sm;
  final UiSegmentedControlSizeMetrics md;

  UiSegmentedControlSizeMetrics metrics(AppSegmentedControlSize size) =>
      switch (size) {
        AppSegmentedControlSize.sm => sm,
        AppSegmentedControlSize.md => md,
      };
}

@immutable
class UiSegmentedControlSizeMetrics {
  const UiSegmentedControlSizeMetrics({
    required this.height,
    required this.paddingHorizontal,
  });

  final double height;
  final double paddingHorizontal;
}

@immutable
class UiSegmentedControlTextStyles {
  const UiSegmentedControlTextStyles({required this.sm, required this.md});

  final TextStyle sm;
  final TextStyle md;

  TextStyle style(AppSegmentedControlSize size) => switch (size) {
    AppSegmentedControlSize.sm => sm,
    AppSegmentedControlSize.md => md,
  };
}

@immutable
class UiSegmentedControlSpec {
  const UiSegmentedControlSpec({
    required this.height,
    required this.padding,
    required this.radius,
    required this.textStyle,
    required this.showSelectedIcon,
  });

  final double height;
  final EdgeInsetsGeometry padding;
  final double radius;
  final TextStyle textStyle;
  final bool showSelectedIcon;
}

extension UiSegmentedControlThemeContext on BuildContext {
  UiSegmentedControlTheme get segmentedControls =>
      Theme.of(this).extension<UiSegmentedControlTheme>() ??
      UiSegmentedControlTheme.standard;
}


===== FILE: lib/ui/theme/ui_tokens.dart =====
import 'package:flutter/material.dart';

/// Shared brand palette constants for cross-component color reuse.
class UiBrandPalette {
  const UiBrandPalette._();

  static const baseBackground = Color(0xFF0F141A);
  static const cardBackground = Color(0xFF131A22);

  static const steelBlueBackground = Color(0xFF1D2731);
  static const steelBlueForeground = Color(0xFFD2DAE3);
  static const steelBlueMutedText = Color(0xB3D2DAE3);
  static const steelBlueSurfaceTop = Color(0xFF354656);
  static const steelBlueSurfaceBottom = Color(0xFF131C24);
  static const steelBlueInsetTop = Color(0xFF283748);
  static const steelBlueInsetBottom = Color(0xFF10161C);

  static const wornGoldBorder = Color(0xFF8E7A4F);
  static const wornGoldOutline = Color(0xB38E7A4F);
  static const wornGoldInsetBorder = Color(0xFFAE9664);
  static const wornGoldGlow = Color(0x1A8E7A4F);

  static const mutedMossValueHighlight = Color.fromARGB(255, 68, 134, 78);
  static const mutedMossSuccess = Color.fromARGB(255, 63, 146, 63);
  static const crimsonDanger = Color(0xFFA93D48);

  static const mutedPlumBackground = Color(0xFF282328);
  static const mutedPlumForeground = Color(0xFFD9CFD7);
  static const mutedPlumBorder = Color(0xFF7E6675);
  static const mutedPlumSurfaceTop = Color(0xFF433843);
  static const mutedPlumSurfaceBottom = Color(0xFF191519);
  static const mutedPlumInsetTop = Color(0xFF332A33);
  static const mutedPlumInsetBottom = Color(0xFF141114);
  static const mutedPlumInsetBorder = Color(0xFF957C8C);
  static const mutedPlumGlow = Color(0x1A7E6675);

  static const scrim = Color(0xAA000000);
  static const shadow = Color(0x8A000000);
  static const buttonShadow = Color(0xB3000000);
  static const black = Color(0xFF000000);
}

@immutable
class UiTokens extends ThemeExtension<UiTokens> {
  const UiTokens({
    required this.space,
    required this.radii,
    required this.text,
    required this.colors,
    required this.sizes,
    required this.shadows,
  });

  final UiSpace space;
  final UiRadii radii;
  final UiTextStyles text;
  final UiColors colors;
  final UiSizes sizes;
  final UiShadows shadows;

  static const UiTokens standard = UiTokens(
    space: UiSpace(xxs: 4, xs: 8, sm: 12, md: 16, lg: 24, xl: 32, xxl: 48),
    radii: UiRadii(sm: 8, md: 12, lg: 16, xl: 24),
    colors: UiColors(
      background: UiBrandPalette.baseBackground,
      surface: UiBrandPalette.steelBlueBackground,
      cardBackground: UiBrandPalette.cardBackground,
      textPrimary: UiBrandPalette.steelBlueForeground,
      textMuted: UiBrandPalette.steelBlueMutedText,
      outline: UiBrandPalette.wornGoldOutline,
      outlineStrong: UiBrandPalette.wornGoldInsetBorder,
      accent: UiBrandPalette.wornGoldBorder,
      accentStrong: UiBrandPalette.wornGoldInsetBorder,
      valueHighlight: UiBrandPalette.mutedMossValueHighlight,
      danger: UiBrandPalette.crimsonDanger,
      success: UiBrandPalette.mutedMossSuccess,
      scrim: UiBrandPalette.scrim,
      shadow: UiBrandPalette.shadow,
    ),
    sizes: UiSizes(
      tapTarget: 48,
      iconSize: UiIconSizes(xs: 12, sm: 16, md: 24, lg: 32),
      dividerThickness: 2,
      borderWidth: 2,
    ),
    shadows: UiShadows(
      card: [
        BoxShadow(
          color: UiBrandPalette.shadow,
          blurRadius: 8,
          offset: Offset(0, 4),
        ),
      ],
      textStrong: [
        Shadow(
          color: UiBrandPalette.black,
          blurRadius: 4,
          offset: Offset(0, 4),
        ),
      ],
    ),
    text: UiTextStyles(
      display: TextStyle(
        fontFamily: 'CrimsonText',
        color: UiBrandPalette.steelBlueForeground,
        fontSize: 32,
        fontWeight: FontWeight.w700,
        letterSpacing: 0.4,
      ),
      title: TextStyle(
        fontFamily: 'CrimsonText',
        color: UiBrandPalette.steelBlueForeground,
        fontSize: 24,
        fontWeight: FontWeight.w700,
        letterSpacing: 0.3,
      ),
      headline: TextStyle(
        fontFamily: 'CrimsonText',
        color: UiBrandPalette.steelBlueForeground,
        fontSize: 18,
        fontWeight: FontWeight.w700,
      ),
      body: TextStyle(
        fontFamily: 'CrimsonText',
        color: UiBrandPalette.steelBlueForeground,
        fontSize: 14,
        fontWeight: FontWeight.w400,
      ),
      label: TextStyle(
        fontFamily: 'CrimsonText',
        color: UiBrandPalette.steelBlueForeground,
        fontSize: 12,
        fontWeight: FontWeight.w600,
        letterSpacing: 1.2,
      ),
      caption: TextStyle(
        fontFamily: 'CrimsonText',
        color: UiBrandPalette.steelBlueMutedText,
        fontSize: 12,
        fontWeight: FontWeight.w500,
      ),
      loreHeading: TextStyle(
        fontFamily: 'CrimsonText',
        color: UiBrandPalette.steelBlueForeground,
        fontSize: 16,
        fontWeight: FontWeight.w600,
        letterSpacing: 0.2,
      ),
      loreBody: TextStyle(
        fontFamily: 'CrimsonText',
        color: UiBrandPalette.steelBlueMutedText,
        fontSize: 12,
        fontWeight: FontWeight.w400,
      ),
      cardLabel: TextStyle(
        fontFamily: 'CrimsonText',
        color: UiBrandPalette.steelBlueForeground,
        fontSize: 14,
        letterSpacing: 1,
        fontWeight: FontWeight.w700,
        shadows: [
          Shadow(
            color: UiBrandPalette.black,
            blurRadius: 4,
            offset: Offset(0, 4),
          ),
        ],
      ),
      cardTitle: TextStyle(
        fontFamily: 'CrimsonText',
        color: UiBrandPalette.steelBlueForeground,
        fontSize: 18,
        fontWeight: FontWeight.w700,
        letterSpacing: 0.3,
        shadows: [
          Shadow(
            color: UiBrandPalette.black,
            blurRadius: 4,
            offset: Offset(0, 4),
          ),
        ],
      ),
      cardSubtitle: TextStyle(
        fontFamily: 'CrimsonText',
        color: UiBrandPalette.steelBlueForeground,
        fontSize: 14,
        fontWeight: FontWeight.w700,
        shadows: [
          Shadow(
            color: UiBrandPalette.black,
            blurRadius: 4,
            offset: Offset(0, 4),
          ),
        ],
      ),
    ),
  );

  @override
  UiTokens copyWith({
    UiSpace? space,
    UiRadii? radii,
    UiTextStyles? text,
    UiColors? colors,
    UiSizes? sizes,
    UiShadows? shadows,
  }) {
    return UiTokens(
      space: space ?? this.space,
      radii: radii ?? this.radii,
      text: text ?? this.text,
      colors: colors ?? this.colors,
      sizes: sizes ?? this.sizes,
      shadows: shadows ?? this.shadows,
    );
  }

  @override
  UiTokens lerp(ThemeExtension<UiTokens>? other, double t) {
    if (other is! UiTokens) return this;
    return t < 0.5 ? this : other;
  }
}

class UiSpace {
  const UiSpace({
    required this.xxs,
    required this.xs,
    required this.sm,
    required this.md,
    required this.lg,
    required this.xl,
    required this.xxl,
  });

  final double xxs;
  final double xs;
  final double sm;
  final double md;
  final double lg;
  final double xl;
  final double xxl;
}

class UiRadii {
  const UiRadii({
    required this.sm,
    required this.md,
    required this.lg,
    required this.xl,
  });

  final double sm;
  final double md;
  final double lg;
  final double xl;
}

class UiTextStyles {
  const UiTextStyles({
    required this.display,
    required this.title,
    required this.headline,
    required this.body,
    required this.label,
    required this.caption,
    required this.loreHeading,
    required this.loreBody,
    required this.cardLabel,
    required this.cardTitle,
    required this.cardSubtitle,
  });

  final TextStyle display;
  final TextStyle title;
  final TextStyle headline;
  final TextStyle body;
  final TextStyle label;
  final TextStyle caption;
  final TextStyle loreHeading;
  final TextStyle loreBody;
  final TextStyle cardLabel;
  final TextStyle cardTitle;
  final TextStyle cardSubtitle;
}

class UiColors {
  const UiColors({
    required this.background,
    required this.surface,
    required this.cardBackground,
    required this.textPrimary,
    required this.textMuted,
    required this.outline,
    required this.outlineStrong,
    required this.accent,
    required this.accentStrong,
    required this.valueHighlight,
    required this.danger,
    required this.success,
    required this.scrim,
    required this.shadow,
  });

  final Color background;
  final Color surface;
  final Color cardBackground;
  final Color textPrimary;
  final Color textMuted;
  final Color outline;
  final Color outlineStrong;
  final Color accent;
  final Color accentStrong;
  final Color valueHighlight;
  final Color danger;
  final Color success;
  final Color scrim;
  final Color shadow;
}

class UiSizes {
  const UiSizes({
    required this.tapTarget,
    required this.iconSize,
    required this.dividerThickness,
    required this.borderWidth,
  });

  final double tapTarget;
  final UiIconSizes iconSize;
  final double dividerThickness;
  final double borderWidth;
}

class UiIconSizes {
  const UiIconSizes({
    required this.xs,
    required this.sm,
    required this.md,
    required this.lg,
  });

  final double xs;
  final double sm;
  final double md;
  final double lg;
}

class UiShadows {
  const UiShadows({required this.card, required this.textStrong});

  final List<BoxShadow> card;
  final List<Shadow> textStrong;
}

extension UiTokensContext on BuildContext {
  UiTokens get ui => Theme.of(this).extension<UiTokens>() ?? UiTokens.standard;
}


===== FILE: lib/ui/viewport/game_viewport.dart =====
import 'package:flutter/widgets.dart';

import '../theme/ui_tokens.dart';
import 'viewport_metrics.dart';

/// Scales a fixed virtual canvas into the available space.
///
/// Use [computeViewportMetrics] so rendering and input mapping share the same
/// view size + offset.
class GameViewport extends StatelessWidget {
  const GameViewport({
    super.key,
    required this.metrics,
    required this.child,
    this.letterboxColor = UiBrandPalette.black,
  });

  final ViewportMetrics metrics;
  final Widget child;
  final Color letterboxColor;

  @override
  Widget build(BuildContext context) {
    return ColoredBox(
      color: letterboxColor,
      child: ClipRect(
        child: SizedBox.expand(
          child: Stack(
            fit: StackFit.expand,
            children: [
              Positioned(
                left: metrics.offsetX,
                top: metrics.offsetY,
                width: metrics.viewW,
                height: metrics.viewH,
                child: child,
              ),
            ],
          ),
        ),
      ),
    );
  }
}


===== FILE: lib/ui/viewport/viewport_metrics.dart =====
import 'dart:math' as math;

import 'package:flutter/widgets.dart';
/// Viewport scaling modes for fitting a fixed virtual canvas to the screen.
enum ViewportScaleMode {
  /// Integer physical-pixel scale (pixel-perfect, no cropping).
  ///
  /// Fits the entire virtual canvas on-screen, letterboxing the remaining area.
  pixelPerfectContain,

  /// Integer physical-pixel scale (pixel-perfect, with cropping).
  ///
  /// Fully covers the screen by scaling up until both dimensions fit. Any
  /// overflow is cropped by the outer [ClipRect].
  pixelPerfectCover,
}

/// Shared viewport sizing results for rendering and input mapping.
@immutable
class ViewportMetrics {
  const ViewportMetrics({
    required this.viewW,
    required this.viewH,
    required this.offsetX,
    required this.offsetY,
  });

  /// Scaled viewport width in logical pixels.
  final double viewW;

  /// Scaled viewport height in logical pixels.
  final double viewH;

  /// Viewport top-left offset in logical pixels.
  final double offsetX;

  /// Viewport top-left offset in logical pixels.
  final double offsetY;
}

/// Computes shared viewport metrics from the current layout constraints.
ViewportMetrics computeViewportMetrics(
  BoxConstraints constraints,
  double devicePixelRatio,
  int virtualW,
  int virtualH,
  ViewportScaleMode mode, {
  Alignment alignment = Alignment.center,
}) {
  assert(devicePixelRatio > 0);
  assert(virtualW > 0);
  assert(virtualH > 0);

  final screenW = constraints.hasBoundedWidth ? constraints.maxWidth : 0.0;
  final screenH = constraints.hasBoundedHeight ? constraints.maxHeight : 0.0;
  final screenPxW = screenW * devicePixelRatio;
  final screenPxH = screenH * devicePixelRatio;

  final scaleW = screenPxW / virtualW;
  final scaleH = screenPxH / virtualH;

  final scalePx = switch (mode) {
    ViewportScaleMode.pixelPerfectContain =>
      math.max(1.0, math.min(scaleW, scaleH).floorToDouble()),
    ViewportScaleMode.pixelPerfectCover =>
      math.max(1.0, math.max(scaleW, scaleH).ceilToDouble()),
  };

  final viewPxW = virtualW * scalePx;
  final viewPxH = virtualH * scalePx;
  final viewW = viewPxW / devicePixelRatio;
  final viewH = viewPxH / devicePixelRatio;

  final alignX = (alignment.x + 1.0) * 0.5;
  final alignY = (alignment.y + 1.0) * 0.5;
  final offsetX = (screenW - viewW) * alignX;
  final offsetY = (screenH - viewH) * alignY;

  return ViewportMetrics(
    viewW: viewW,
    viewH: viewH,
    offsetX: offsetX,
    offsetY: offsetY,
  );
}

